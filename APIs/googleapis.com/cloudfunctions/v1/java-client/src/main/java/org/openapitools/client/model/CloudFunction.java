/*
 * Cloud Functions API
 * Manages lightweight user-provided functions executed in response to events.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.EventTrigger;
import org.openapitools.client.model.HttpsTrigger;
import org.openapitools.client.model.OnDeployUpdatePolicy;
import org.openapitools.client.model.SecretEnvVar;
import org.openapitools.client.model.SecretVolume;
import org.openapitools.client.model.SourceRepository;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes a Cloud Function that contains user computation executed in response to an event. It encapsulate function and triggers configurations.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:56.190824-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CloudFunction {
  public static final String SERIALIZED_NAME_AUTOMATIC_UPDATE_POLICY = "automaticUpdatePolicy";
  @SerializedName(SERIALIZED_NAME_AUTOMATIC_UPDATE_POLICY)
  private Object automaticUpdatePolicy;

  public static final String SERIALIZED_NAME_AVAILABLE_MEMORY_MB = "availableMemoryMb";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_MEMORY_MB)
  private Integer availableMemoryMb;

  public static final String SERIALIZED_NAME_BUILD_ENVIRONMENT_VARIABLES = "buildEnvironmentVariables";
  @SerializedName(SERIALIZED_NAME_BUILD_ENVIRONMENT_VARIABLES)
  private Map<String, String> buildEnvironmentVariables = new HashMap<>();

  public static final String SERIALIZED_NAME_BUILD_ID = "buildId";
  @SerializedName(SERIALIZED_NAME_BUILD_ID)
  private String buildId;

  public static final String SERIALIZED_NAME_BUILD_NAME = "buildName";
  @SerializedName(SERIALIZED_NAME_BUILD_NAME)
  private String buildName;

  public static final String SERIALIZED_NAME_BUILD_SERVICE_ACCOUNT = "buildServiceAccount";
  @SerializedName(SERIALIZED_NAME_BUILD_SERVICE_ACCOUNT)
  private String buildServiceAccount;

  public static final String SERIALIZED_NAME_BUILD_WORKER_POOL = "buildWorkerPool";
  @SerializedName(SERIALIZED_NAME_BUILD_WORKER_POOL)
  private String buildWorkerPool;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  /**
   * Docker Registry to use for this deployment. If unspecified, it defaults to &#x60;ARTIFACT_REGISTRY&#x60;. If &#x60;docker_repository&#x60; field is specified, this field should either be left unspecified or set to &#x60;ARTIFACT_REGISTRY&#x60;.
   */
  @JsonAdapter(DockerRegistryEnum.Adapter.class)
  public enum DockerRegistryEnum {
    DOCKER_REGISTRY_UNSPECIFIED("DOCKER_REGISTRY_UNSPECIFIED"),
    
    CONTAINER_REGISTRY("CONTAINER_REGISTRY"),
    
    ARTIFACT_REGISTRY("ARTIFACT_REGISTRY");

    private String value;

    DockerRegistryEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DockerRegistryEnum fromValue(String value) {
      for (DockerRegistryEnum b : DockerRegistryEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DockerRegistryEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DockerRegistryEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DockerRegistryEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DockerRegistryEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DockerRegistryEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DOCKER_REGISTRY = "dockerRegistry";
  @SerializedName(SERIALIZED_NAME_DOCKER_REGISTRY)
  private DockerRegistryEnum dockerRegistry;

  public static final String SERIALIZED_NAME_DOCKER_REPOSITORY = "dockerRepository";
  @SerializedName(SERIALIZED_NAME_DOCKER_REPOSITORY)
  private String dockerRepository;

  public static final String SERIALIZED_NAME_ENTRY_POINT = "entryPoint";
  @SerializedName(SERIALIZED_NAME_ENTRY_POINT)
  private String entryPoint;

  public static final String SERIALIZED_NAME_ENVIRONMENT_VARIABLES = "environmentVariables";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_VARIABLES)
  private Map<String, String> environmentVariables = new HashMap<>();

  public static final String SERIALIZED_NAME_EVENT_TRIGGER = "eventTrigger";
  @SerializedName(SERIALIZED_NAME_EVENT_TRIGGER)
  private EventTrigger eventTrigger;

  public static final String SERIALIZED_NAME_HTTPS_TRIGGER = "httpsTrigger";
  @SerializedName(SERIALIZED_NAME_HTTPS_TRIGGER)
  private HttpsTrigger httpsTrigger;

  /**
   * The ingress settings for the function, controlling what traffic can reach it.
   */
  @JsonAdapter(IngressSettingsEnum.Adapter.class)
  public enum IngressSettingsEnum {
    INGRESS_SETTINGS_UNSPECIFIED("INGRESS_SETTINGS_UNSPECIFIED"),
    
    ALLOW_ALL("ALLOW_ALL"),
    
    ALLOW_INTERNAL_ONLY("ALLOW_INTERNAL_ONLY"),
    
    ALLOW_INTERNAL_AND_GCLB("ALLOW_INTERNAL_AND_GCLB");

    private String value;

    IngressSettingsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IngressSettingsEnum fromValue(String value) {
      for (IngressSettingsEnum b : IngressSettingsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IngressSettingsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IngressSettingsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IngressSettingsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IngressSettingsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IngressSettingsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INGRESS_SETTINGS = "ingressSettings";
  @SerializedName(SERIALIZED_NAME_INGRESS_SETTINGS)
  private IngressSettingsEnum ingressSettings;

  public static final String SERIALIZED_NAME_KMS_KEY_NAME = "kmsKeyName";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_NAME)
  private String kmsKeyName;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MAX_INSTANCES = "maxInstances";
  @SerializedName(SERIALIZED_NAME_MAX_INSTANCES)
  private Integer maxInstances;

  public static final String SERIALIZED_NAME_MIN_INSTANCES = "minInstances";
  @SerializedName(SERIALIZED_NAME_MIN_INSTANCES)
  private Integer minInstances;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_ON_DEPLOY_UPDATE_POLICY = "onDeployUpdatePolicy";
  @SerializedName(SERIALIZED_NAME_ON_DEPLOY_UPDATE_POLICY)
  private OnDeployUpdatePolicy onDeployUpdatePolicy;

  public static final String SERIALIZED_NAME_RUNTIME = "runtime";
  @SerializedName(SERIALIZED_NAME_RUNTIME)
  private String runtime;

  public static final String SERIALIZED_NAME_SECRET_ENVIRONMENT_VARIABLES = "secretEnvironmentVariables";
  @SerializedName(SERIALIZED_NAME_SECRET_ENVIRONMENT_VARIABLES)
  private List<SecretEnvVar> secretEnvironmentVariables = new ArrayList<>();

  public static final String SERIALIZED_NAME_SECRET_VOLUMES = "secretVolumes";
  @SerializedName(SERIALIZED_NAME_SECRET_VOLUMES)
  private List<SecretVolume> secretVolumes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL = "serviceAccountEmail";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL)
  private String serviceAccountEmail;

  public static final String SERIALIZED_NAME_SOURCE_ARCHIVE_URL = "sourceArchiveUrl";
  @SerializedName(SERIALIZED_NAME_SOURCE_ARCHIVE_URL)
  private String sourceArchiveUrl;

  public static final String SERIALIZED_NAME_SOURCE_REPOSITORY = "sourceRepository";
  @SerializedName(SERIALIZED_NAME_SOURCE_REPOSITORY)
  private SourceRepository sourceRepository;

  public static final String SERIALIZED_NAME_SOURCE_TOKEN = "sourceToken";
  @SerializedName(SERIALIZED_NAME_SOURCE_TOKEN)
  private String sourceToken;

  public static final String SERIALIZED_NAME_SOURCE_UPLOAD_URL = "sourceUploadUrl";
  @SerializedName(SERIALIZED_NAME_SOURCE_UPLOAD_URL)
  private String sourceUploadUrl;

  /**
   * Output only. Status of the function deployment.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    CLOUD_FUNCTION_STATUS_UNSPECIFIED("CLOUD_FUNCTION_STATUS_UNSPECIFIED"),
    
    ACTIVE("ACTIVE"),
    
    OFFLINE("OFFLINE"),
    
    DEPLOY_IN_PROGRESS("DEPLOY_IN_PROGRESS"),
    
    DELETE_IN_PROGRESS("DELETE_IN_PROGRESS"),
    
    UNKNOWN("UNKNOWN");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private String timeout;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_VERSION_ID = "versionId";
  @SerializedName(SERIALIZED_NAME_VERSION_ID)
  private String versionId;

  public static final String SERIALIZED_NAME_VPC_CONNECTOR = "vpcConnector";
  @SerializedName(SERIALIZED_NAME_VPC_CONNECTOR)
  private String vpcConnector;

  /**
   * The egress settings for the connector, controlling what traffic is diverted through it.
   */
  @JsonAdapter(VpcConnectorEgressSettingsEnum.Adapter.class)
  public enum VpcConnectorEgressSettingsEnum {
    VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED("VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED"),
    
    PRIVATE_RANGES_ONLY("PRIVATE_RANGES_ONLY"),
    
    ALL_TRAFFIC("ALL_TRAFFIC");

    private String value;

    VpcConnectorEgressSettingsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VpcConnectorEgressSettingsEnum fromValue(String value) {
      for (VpcConnectorEgressSettingsEnum b : VpcConnectorEgressSettingsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VpcConnectorEgressSettingsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VpcConnectorEgressSettingsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VpcConnectorEgressSettingsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VpcConnectorEgressSettingsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VpcConnectorEgressSettingsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VPC_CONNECTOR_EGRESS_SETTINGS = "vpcConnectorEgressSettings";
  @SerializedName(SERIALIZED_NAME_VPC_CONNECTOR_EGRESS_SETTINGS)
  private VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings;

  public CloudFunction() {
  }

  public CloudFunction(
     String buildId, 
     String buildName, 
     StatusEnum status, 
     String updateTime, 
     String versionId
  ) {
    this();
    this.buildId = buildId;
    this.buildName = buildName;
    this.status = status;
    this.updateTime = updateTime;
    this.versionId = versionId;
  }

  public CloudFunction automaticUpdatePolicy(Object automaticUpdatePolicy) {
    this.automaticUpdatePolicy = automaticUpdatePolicy;
    return this;
  }

  /**
   * Security patches are applied automatically to the runtime without requiring the function to be redeployed.
   * @return automaticUpdatePolicy
   */
  @javax.annotation.Nullable
  public Object getAutomaticUpdatePolicy() {
    return automaticUpdatePolicy;
  }

  public void setAutomaticUpdatePolicy(Object automaticUpdatePolicy) {
    this.automaticUpdatePolicy = automaticUpdatePolicy;
  }


  public CloudFunction availableMemoryMb(Integer availableMemoryMb) {
    this.availableMemoryMb = availableMemoryMb;
    return this;
  }

  /**
   * The amount of memory in MB available for a function. Defaults to 256MB.
   * @return availableMemoryMb
   */
  @javax.annotation.Nullable
  public Integer getAvailableMemoryMb() {
    return availableMemoryMb;
  }

  public void setAvailableMemoryMb(Integer availableMemoryMb) {
    this.availableMemoryMb = availableMemoryMb;
  }


  public CloudFunction buildEnvironmentVariables(Map<String, String> buildEnvironmentVariables) {
    this.buildEnvironmentVariables = buildEnvironmentVariables;
    return this;
  }

  public CloudFunction putBuildEnvironmentVariablesItem(String key, String buildEnvironmentVariablesItem) {
    if (this.buildEnvironmentVariables == null) {
      this.buildEnvironmentVariables = new HashMap<>();
    }
    this.buildEnvironmentVariables.put(key, buildEnvironmentVariablesItem);
    return this;
  }

  /**
   * Build environment variables that shall be available during build time.
   * @return buildEnvironmentVariables
   */
  @javax.annotation.Nullable
  public Map<String, String> getBuildEnvironmentVariables() {
    return buildEnvironmentVariables;
  }

  public void setBuildEnvironmentVariables(Map<String, String> buildEnvironmentVariables) {
    this.buildEnvironmentVariables = buildEnvironmentVariables;
  }


  /**
   * Output only. The Cloud Build ID of the latest successful deployment of the function.
   * @return buildId
   */
  @javax.annotation.Nullable
  public String getBuildId() {
    return buildId;
  }



  /**
   * Output only. The Cloud Build Name of the function deployment. &#x60;projects//locations//builds/&#x60;.
   * @return buildName
   */
  @javax.annotation.Nullable
  public String getBuildName() {
    return buildName;
  }



  public CloudFunction buildServiceAccount(String buildServiceAccount) {
    this.buildServiceAccount = buildServiceAccount;
    return this;
  }

  /**
   * Optional. A service account the user provides for use with Cloud Build.
   * @return buildServiceAccount
   */
  @javax.annotation.Nullable
  public String getBuildServiceAccount() {
    return buildServiceAccount;
  }

  public void setBuildServiceAccount(String buildServiceAccount) {
    this.buildServiceAccount = buildServiceAccount;
  }


  public CloudFunction buildWorkerPool(String buildWorkerPool) {
    this.buildWorkerPool = buildWorkerPool;
    return this;
  }

  /**
   * Name of the Cloud Build Custom Worker Pool that should be used to build the function. The format of this field is &#x60;projects/{project}/locations/{region}/workerPools/{workerPool}&#x60; where &#x60;{project}&#x60; and &#x60;{region}&#x60; are the project id and region respectively where the worker pool is defined and &#x60;{workerPool}&#x60; is the short name of the worker pool. If the project id is not the same as the function, then the Cloud Functions Service Agent (&#x60;service-@gcf-admin-robot.iam.gserviceaccount.com&#x60;) must be granted the role Cloud Build Custom Workers Builder (&#x60;roles/cloudbuild.customworkers.builder&#x60;) in the project.
   * @return buildWorkerPool
   */
  @javax.annotation.Nullable
  public String getBuildWorkerPool() {
    return buildWorkerPool;
  }

  public void setBuildWorkerPool(String buildWorkerPool) {
    this.buildWorkerPool = buildWorkerPool;
  }


  public CloudFunction description(String description) {
    this.description = description;
    return this;
  }

  /**
   * User-provided description of a function.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public CloudFunction dockerRegistry(DockerRegistryEnum dockerRegistry) {
    this.dockerRegistry = dockerRegistry;
    return this;
  }

  /**
   * Docker Registry to use for this deployment. If unspecified, it defaults to &#x60;ARTIFACT_REGISTRY&#x60;. If &#x60;docker_repository&#x60; field is specified, this field should either be left unspecified or set to &#x60;ARTIFACT_REGISTRY&#x60;.
   * @return dockerRegistry
   */
  @javax.annotation.Nullable
  public DockerRegistryEnum getDockerRegistry() {
    return dockerRegistry;
  }

  public void setDockerRegistry(DockerRegistryEnum dockerRegistry) {
    this.dockerRegistry = dockerRegistry;
  }


  public CloudFunction dockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
    return this;
  }

  /**
   * User managed repository created in Artifact Registry optionally with a customer managed encryption key. If specified, deployments will use Artifact Registry. If unspecified and the deployment is eligible to use Artifact Registry, GCF will create and use a repository named &#39;gcf-artifacts&#39; for every deployed region. This is the repository to which the function docker image will be pushed after it is built by Cloud Build. It must match the pattern &#x60;projects/{project}/locations/{location}/repositories/{repository}&#x60;. Cross-project repositories are not supported. Cross-location repositories are not supported. Repository format must be &#39;DOCKER&#39;.
   * @return dockerRepository
   */
  @javax.annotation.Nullable
  public String getDockerRepository() {
    return dockerRepository;
  }

  public void setDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
  }


  public CloudFunction entryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
    return this;
  }

  /**
   * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix (ID of the function), if not specified.
   * @return entryPoint
   */
  @javax.annotation.Nullable
  public String getEntryPoint() {
    return entryPoint;
  }

  public void setEntryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
  }


  public CloudFunction environmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
    return this;
  }

  public CloudFunction putEnvironmentVariablesItem(String key, String environmentVariablesItem) {
    if (this.environmentVariables == null) {
      this.environmentVariables = new HashMap<>();
    }
    this.environmentVariables.put(key, environmentVariablesItem);
    return this;
  }

  /**
   * Environment variables that shall be available during function execution.
   * @return environmentVariables
   */
  @javax.annotation.Nullable
  public Map<String, String> getEnvironmentVariables() {
    return environmentVariables;
  }

  public void setEnvironmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
  }


  public CloudFunction eventTrigger(EventTrigger eventTrigger) {
    this.eventTrigger = eventTrigger;
    return this;
  }

  /**
   * Get eventTrigger
   * @return eventTrigger
   */
  @javax.annotation.Nullable
  public EventTrigger getEventTrigger() {
    return eventTrigger;
  }

  public void setEventTrigger(EventTrigger eventTrigger) {
    this.eventTrigger = eventTrigger;
  }


  public CloudFunction httpsTrigger(HttpsTrigger httpsTrigger) {
    this.httpsTrigger = httpsTrigger;
    return this;
  }

  /**
   * Get httpsTrigger
   * @return httpsTrigger
   */
  @javax.annotation.Nullable
  public HttpsTrigger getHttpsTrigger() {
    return httpsTrigger;
  }

  public void setHttpsTrigger(HttpsTrigger httpsTrigger) {
    this.httpsTrigger = httpsTrigger;
  }


  public CloudFunction ingressSettings(IngressSettingsEnum ingressSettings) {
    this.ingressSettings = ingressSettings;
    return this;
  }

  /**
   * The ingress settings for the function, controlling what traffic can reach it.
   * @return ingressSettings
   */
  @javax.annotation.Nullable
  public IngressSettingsEnum getIngressSettings() {
    return ingressSettings;
  }

  public void setIngressSettings(IngressSettingsEnum ingressSettings) {
    this.ingressSettings = ingressSettings;
  }


  public CloudFunction kmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
    return this;
  }

  /**
   * Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources. It must match the pattern &#x60;projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}&#x60;. If specified, you must also provide an artifact registry repository using the &#x60;docker_repository&#x60; field that was created with the same KMS crypto key. The following service accounts need to be granted the role &#39;Cloud KMS CryptoKey Encrypter/Decrypter (roles/cloudkms.cryptoKeyEncrypterDecrypter)&#39; on the Key/KeyRing/Project/Organization (least access preferred). 1. Google Cloud Functions service account (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) - Required to protect the function&#39;s image. 2. Google Storage service account (service-{project_number}@gs-project-accounts.iam.gserviceaccount.com) - Required to protect the function&#39;s source code. If this service account does not exist, deploying a function without a KMS key or retrieving the service agent name provisions it. For more information, see https://cloud.google.com/storage/docs/projects#service-agents and https://cloud.google.com/storage/docs/getting-service-agent#gsutil. Google Cloud Functions delegates access to service agents to protect function resources in internal projects that are not accessible by the end user.
   * @return kmsKeyName
   */
  @javax.annotation.Nullable
  public String getKmsKeyName() {
    return kmsKeyName;
  }

  public void setKmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
  }


  public CloudFunction labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public CloudFunction putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels associated with this Cloud Function.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public CloudFunction maxInstances(Integer maxInstances) {
    this.maxInstances = maxInstances;
    return this;
  }

  /**
   * The limit on the maximum number of function instances that may coexist at a given time. In some cases, such as rapid traffic surges, Cloud Functions may, for a short period of time, create more instances than the specified max instances limit. If your function cannot tolerate this temporary behavior, you may want to factor in a safety margin and set a lower max instances value than your function can tolerate. See the [Max Instances](https://cloud.google.com/functions/docs/max-instances) Guide for more details.
   * @return maxInstances
   */
  @javax.annotation.Nullable
  public Integer getMaxInstances() {
    return maxInstances;
  }

  public void setMaxInstances(Integer maxInstances) {
    this.maxInstances = maxInstances;
  }


  public CloudFunction minInstances(Integer minInstances) {
    this.minInstances = minInstances;
    return this;
  }

  /**
   * A lower bound for the number function instances that may coexist at a given time.
   * @return minInstances
   */
  @javax.annotation.Nullable
  public Integer getMinInstances() {
    return minInstances;
  }

  public void setMinInstances(Integer minInstances) {
    this.minInstances = minInstances;
  }


  public CloudFunction name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A user-defined name of the function. Function names must be unique globally and match pattern &#x60;projects/_*_/locations/_*_/functions/_*&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  @Deprecated
  public CloudFunction network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Deprecated: use vpc_connector
   * @return network
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  @Deprecated
  public void setNetwork(String network) {
    this.network = network;
  }


  public CloudFunction onDeployUpdatePolicy(OnDeployUpdatePolicy onDeployUpdatePolicy) {
    this.onDeployUpdatePolicy = onDeployUpdatePolicy;
    return this;
  }

  /**
   * Get onDeployUpdatePolicy
   * @return onDeployUpdatePolicy
   */
  @javax.annotation.Nullable
  public OnDeployUpdatePolicy getOnDeployUpdatePolicy() {
    return onDeployUpdatePolicy;
  }

  public void setOnDeployUpdatePolicy(OnDeployUpdatePolicy onDeployUpdatePolicy) {
    this.onDeployUpdatePolicy = onDeployUpdatePolicy;
  }


  public CloudFunction runtime(String runtime) {
    this.runtime = runtime;
    return this;
  }

  /**
   * The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function. For a complete list of possible choices, see the [&#x60;gcloud&#x60; command reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
   * @return runtime
   */
  @javax.annotation.Nullable
  public String getRuntime() {
    return runtime;
  }

  public void setRuntime(String runtime) {
    this.runtime = runtime;
  }


  public CloudFunction secretEnvironmentVariables(List<SecretEnvVar> secretEnvironmentVariables) {
    this.secretEnvironmentVariables = secretEnvironmentVariables;
    return this;
  }

  public CloudFunction addSecretEnvironmentVariablesItem(SecretEnvVar secretEnvironmentVariablesItem) {
    if (this.secretEnvironmentVariables == null) {
      this.secretEnvironmentVariables = new ArrayList<>();
    }
    this.secretEnvironmentVariables.add(secretEnvironmentVariablesItem);
    return this;
  }

  /**
   * Secret environment variables configuration.
   * @return secretEnvironmentVariables
   */
  @javax.annotation.Nullable
  public List<SecretEnvVar> getSecretEnvironmentVariables() {
    return secretEnvironmentVariables;
  }

  public void setSecretEnvironmentVariables(List<SecretEnvVar> secretEnvironmentVariables) {
    this.secretEnvironmentVariables = secretEnvironmentVariables;
  }


  public CloudFunction secretVolumes(List<SecretVolume> secretVolumes) {
    this.secretVolumes = secretVolumes;
    return this;
  }

  public CloudFunction addSecretVolumesItem(SecretVolume secretVolumesItem) {
    if (this.secretVolumes == null) {
      this.secretVolumes = new ArrayList<>();
    }
    this.secretVolumes.add(secretVolumesItem);
    return this;
  }

  /**
   * Secret volumes configuration.
   * @return secretVolumes
   */
  @javax.annotation.Nullable
  public List<SecretVolume> getSecretVolumes() {
    return secretVolumes;
  }

  public void setSecretVolumes(List<SecretVolume> secretVolumes) {
    this.secretVolumes = secretVolumes;
  }


  public CloudFunction serviceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
    return this;
  }

  /**
   * The email of the function&#39;s service account. If empty, defaults to &#x60;{project_id}@appspot.gserviceaccount.com&#x60;.
   * @return serviceAccountEmail
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmail() {
    return serviceAccountEmail;
  }

  public void setServiceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
  }


  public CloudFunction sourceArchiveUrl(String sourceArchiveUrl) {
    this.sourceArchiveUrl = sourceArchiveUrl;
    return this;
  }

  /**
   * The Google Cloud Storage URL, starting with &#x60;gs://&#x60;, pointing to the zip archive which contains the function.
   * @return sourceArchiveUrl
   */
  @javax.annotation.Nullable
  public String getSourceArchiveUrl() {
    return sourceArchiveUrl;
  }

  public void setSourceArchiveUrl(String sourceArchiveUrl) {
    this.sourceArchiveUrl = sourceArchiveUrl;
  }


  public CloudFunction sourceRepository(SourceRepository sourceRepository) {
    this.sourceRepository = sourceRepository;
    return this;
  }

  /**
   * Get sourceRepository
   * @return sourceRepository
   */
  @javax.annotation.Nullable
  public SourceRepository getSourceRepository() {
    return sourceRepository;
  }

  public void setSourceRepository(SourceRepository sourceRepository) {
    this.sourceRepository = sourceRepository;
  }


  public CloudFunction sourceToken(String sourceToken) {
    this.sourceToken = sourceToken;
    return this;
  }

  /**
   * Input only. An identifier for Firebase function sources. Disclaimer: This field is only supported for Firebase function deployments.
   * @return sourceToken
   */
  @javax.annotation.Nullable
  public String getSourceToken() {
    return sourceToken;
  }

  public void setSourceToken(String sourceToken) {
    this.sourceToken = sourceToken;
  }


  public CloudFunction sourceUploadUrl(String sourceUploadUrl) {
    this.sourceUploadUrl = sourceUploadUrl;
    return this;
  }

  /**
   * The Google Cloud Storage signed URL used for source uploading, generated by calling [google.cloud.functions.v1.GenerateUploadUrl]. The signature is validated on write methods (Create, Update) The signature is stripped from the Function object on read methods (Get, List)
   * @return sourceUploadUrl
   */
  @javax.annotation.Nullable
  public String getSourceUploadUrl() {
    return sourceUploadUrl;
  }

  public void setSourceUploadUrl(String sourceUploadUrl) {
    this.sourceUploadUrl = sourceUploadUrl;
  }


  /**
   * Output only. Status of the function deployment.
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }



  public CloudFunction timeout(String timeout) {
    this.timeout = timeout;
    return this;
  }

  /**
   * The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.
   * @return timeout
   */
  @javax.annotation.Nullable
  public String getTimeout() {
    return timeout;
  }

  public void setTimeout(String timeout) {
    this.timeout = timeout;
  }


  /**
   * Output only. The last update timestamp of a Cloud Function.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  /**
   * Output only. The version identifier of the Cloud Function. Each deployment attempt results in a new version of a function being created.
   * @return versionId
   */
  @javax.annotation.Nullable
  public String getVersionId() {
    return versionId;
  }



  public CloudFunction vpcConnector(String vpcConnector) {
    this.vpcConnector = vpcConnector;
    return this;
  }

  /**
   * The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is &#x60;projects/_*_/locations/_*_/connectors/_*&#x60; This field is mutually exclusive with &#x60;network&#x60; field and will eventually replace it. See [the VPC documentation](https://cloud.google.com/compute/docs/vpc) for more information on connecting Cloud projects.
   * @return vpcConnector
   */
  @javax.annotation.Nullable
  public String getVpcConnector() {
    return vpcConnector;
  }

  public void setVpcConnector(String vpcConnector) {
    this.vpcConnector = vpcConnector;
  }


  public CloudFunction vpcConnectorEgressSettings(VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings) {
    this.vpcConnectorEgressSettings = vpcConnectorEgressSettings;
    return this;
  }

  /**
   * The egress settings for the connector, controlling what traffic is diverted through it.
   * @return vpcConnectorEgressSettings
   */
  @javax.annotation.Nullable
  public VpcConnectorEgressSettingsEnum getVpcConnectorEgressSettings() {
    return vpcConnectorEgressSettings;
  }

  public void setVpcConnectorEgressSettings(VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings) {
    this.vpcConnectorEgressSettings = vpcConnectorEgressSettings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CloudFunction cloudFunction = (CloudFunction) o;
    return Objects.equals(this.automaticUpdatePolicy, cloudFunction.automaticUpdatePolicy) &&
        Objects.equals(this.availableMemoryMb, cloudFunction.availableMemoryMb) &&
        Objects.equals(this.buildEnvironmentVariables, cloudFunction.buildEnvironmentVariables) &&
        Objects.equals(this.buildId, cloudFunction.buildId) &&
        Objects.equals(this.buildName, cloudFunction.buildName) &&
        Objects.equals(this.buildServiceAccount, cloudFunction.buildServiceAccount) &&
        Objects.equals(this.buildWorkerPool, cloudFunction.buildWorkerPool) &&
        Objects.equals(this.description, cloudFunction.description) &&
        Objects.equals(this.dockerRegistry, cloudFunction.dockerRegistry) &&
        Objects.equals(this.dockerRepository, cloudFunction.dockerRepository) &&
        Objects.equals(this.entryPoint, cloudFunction.entryPoint) &&
        Objects.equals(this.environmentVariables, cloudFunction.environmentVariables) &&
        Objects.equals(this.eventTrigger, cloudFunction.eventTrigger) &&
        Objects.equals(this.httpsTrigger, cloudFunction.httpsTrigger) &&
        Objects.equals(this.ingressSettings, cloudFunction.ingressSettings) &&
        Objects.equals(this.kmsKeyName, cloudFunction.kmsKeyName) &&
        Objects.equals(this.labels, cloudFunction.labels) &&
        Objects.equals(this.maxInstances, cloudFunction.maxInstances) &&
        Objects.equals(this.minInstances, cloudFunction.minInstances) &&
        Objects.equals(this.name, cloudFunction.name) &&
        Objects.equals(this.network, cloudFunction.network) &&
        Objects.equals(this.onDeployUpdatePolicy, cloudFunction.onDeployUpdatePolicy) &&
        Objects.equals(this.runtime, cloudFunction.runtime) &&
        Objects.equals(this.secretEnvironmentVariables, cloudFunction.secretEnvironmentVariables) &&
        Objects.equals(this.secretVolumes, cloudFunction.secretVolumes) &&
        Objects.equals(this.serviceAccountEmail, cloudFunction.serviceAccountEmail) &&
        Objects.equals(this.sourceArchiveUrl, cloudFunction.sourceArchiveUrl) &&
        Objects.equals(this.sourceRepository, cloudFunction.sourceRepository) &&
        Objects.equals(this.sourceToken, cloudFunction.sourceToken) &&
        Objects.equals(this.sourceUploadUrl, cloudFunction.sourceUploadUrl) &&
        Objects.equals(this.status, cloudFunction.status) &&
        Objects.equals(this.timeout, cloudFunction.timeout) &&
        Objects.equals(this.updateTime, cloudFunction.updateTime) &&
        Objects.equals(this.versionId, cloudFunction.versionId) &&
        Objects.equals(this.vpcConnector, cloudFunction.vpcConnector) &&
        Objects.equals(this.vpcConnectorEgressSettings, cloudFunction.vpcConnectorEgressSettings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(automaticUpdatePolicy, availableMemoryMb, buildEnvironmentVariables, buildId, buildName, buildServiceAccount, buildWorkerPool, description, dockerRegistry, dockerRepository, entryPoint, environmentVariables, eventTrigger, httpsTrigger, ingressSettings, kmsKeyName, labels, maxInstances, minInstances, name, network, onDeployUpdatePolicy, runtime, secretEnvironmentVariables, secretVolumes, serviceAccountEmail, sourceArchiveUrl, sourceRepository, sourceToken, sourceUploadUrl, status, timeout, updateTime, versionId, vpcConnector, vpcConnectorEgressSettings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CloudFunction {\n");
    sb.append("    automaticUpdatePolicy: ").append(toIndentedString(automaticUpdatePolicy)).append("\n");
    sb.append("    availableMemoryMb: ").append(toIndentedString(availableMemoryMb)).append("\n");
    sb.append("    buildEnvironmentVariables: ").append(toIndentedString(buildEnvironmentVariables)).append("\n");
    sb.append("    buildId: ").append(toIndentedString(buildId)).append("\n");
    sb.append("    buildName: ").append(toIndentedString(buildName)).append("\n");
    sb.append("    buildServiceAccount: ").append(toIndentedString(buildServiceAccount)).append("\n");
    sb.append("    buildWorkerPool: ").append(toIndentedString(buildWorkerPool)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    dockerRegistry: ").append(toIndentedString(dockerRegistry)).append("\n");
    sb.append("    dockerRepository: ").append(toIndentedString(dockerRepository)).append("\n");
    sb.append("    entryPoint: ").append(toIndentedString(entryPoint)).append("\n");
    sb.append("    environmentVariables: ").append(toIndentedString(environmentVariables)).append("\n");
    sb.append("    eventTrigger: ").append(toIndentedString(eventTrigger)).append("\n");
    sb.append("    httpsTrigger: ").append(toIndentedString(httpsTrigger)).append("\n");
    sb.append("    ingressSettings: ").append(toIndentedString(ingressSettings)).append("\n");
    sb.append("    kmsKeyName: ").append(toIndentedString(kmsKeyName)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    maxInstances: ").append(toIndentedString(maxInstances)).append("\n");
    sb.append("    minInstances: ").append(toIndentedString(minInstances)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    onDeployUpdatePolicy: ").append(toIndentedString(onDeployUpdatePolicy)).append("\n");
    sb.append("    runtime: ").append(toIndentedString(runtime)).append("\n");
    sb.append("    secretEnvironmentVariables: ").append(toIndentedString(secretEnvironmentVariables)).append("\n");
    sb.append("    secretVolumes: ").append(toIndentedString(secretVolumes)).append("\n");
    sb.append("    serviceAccountEmail: ").append(toIndentedString(serviceAccountEmail)).append("\n");
    sb.append("    sourceArchiveUrl: ").append(toIndentedString(sourceArchiveUrl)).append("\n");
    sb.append("    sourceRepository: ").append(toIndentedString(sourceRepository)).append("\n");
    sb.append("    sourceToken: ").append(toIndentedString(sourceToken)).append("\n");
    sb.append("    sourceUploadUrl: ").append(toIndentedString(sourceUploadUrl)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    versionId: ").append(toIndentedString(versionId)).append("\n");
    sb.append("    vpcConnector: ").append(toIndentedString(vpcConnector)).append("\n");
    sb.append("    vpcConnectorEgressSettings: ").append(toIndentedString(vpcConnectorEgressSettings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("automaticUpdatePolicy");
    openapiFields.add("availableMemoryMb");
    openapiFields.add("buildEnvironmentVariables");
    openapiFields.add("buildId");
    openapiFields.add("buildName");
    openapiFields.add("buildServiceAccount");
    openapiFields.add("buildWorkerPool");
    openapiFields.add("description");
    openapiFields.add("dockerRegistry");
    openapiFields.add("dockerRepository");
    openapiFields.add("entryPoint");
    openapiFields.add("environmentVariables");
    openapiFields.add("eventTrigger");
    openapiFields.add("httpsTrigger");
    openapiFields.add("ingressSettings");
    openapiFields.add("kmsKeyName");
    openapiFields.add("labels");
    openapiFields.add("maxInstances");
    openapiFields.add("minInstances");
    openapiFields.add("name");
    openapiFields.add("network");
    openapiFields.add("onDeployUpdatePolicy");
    openapiFields.add("runtime");
    openapiFields.add("secretEnvironmentVariables");
    openapiFields.add("secretVolumes");
    openapiFields.add("serviceAccountEmail");
    openapiFields.add("sourceArchiveUrl");
    openapiFields.add("sourceRepository");
    openapiFields.add("sourceToken");
    openapiFields.add("sourceUploadUrl");
    openapiFields.add("status");
    openapiFields.add("timeout");
    openapiFields.add("updateTime");
    openapiFields.add("versionId");
    openapiFields.add("vpcConnector");
    openapiFields.add("vpcConnectorEgressSettings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CloudFunction
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CloudFunction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CloudFunction is not found in the empty JSON string", CloudFunction.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CloudFunction.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CloudFunction` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("buildId") != null && !jsonObj.get("buildId").isJsonNull()) && !jsonObj.get("buildId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buildId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buildId").toString()));
      }
      if ((jsonObj.get("buildName") != null && !jsonObj.get("buildName").isJsonNull()) && !jsonObj.get("buildName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buildName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buildName").toString()));
      }
      if ((jsonObj.get("buildServiceAccount") != null && !jsonObj.get("buildServiceAccount").isJsonNull()) && !jsonObj.get("buildServiceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buildServiceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buildServiceAccount").toString()));
      }
      if ((jsonObj.get("buildWorkerPool") != null && !jsonObj.get("buildWorkerPool").isJsonNull()) && !jsonObj.get("buildWorkerPool").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buildWorkerPool` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buildWorkerPool").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("dockerRegistry") != null && !jsonObj.get("dockerRegistry").isJsonNull()) && !jsonObj.get("dockerRegistry").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dockerRegistry` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dockerRegistry").toString()));
      }
      // validate the optional field `dockerRegistry`
      if (jsonObj.get("dockerRegistry") != null && !jsonObj.get("dockerRegistry").isJsonNull()) {
        DockerRegistryEnum.validateJsonElement(jsonObj.get("dockerRegistry"));
      }
      if ((jsonObj.get("dockerRepository") != null && !jsonObj.get("dockerRepository").isJsonNull()) && !jsonObj.get("dockerRepository").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dockerRepository` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dockerRepository").toString()));
      }
      if ((jsonObj.get("entryPoint") != null && !jsonObj.get("entryPoint").isJsonNull()) && !jsonObj.get("entryPoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entryPoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entryPoint").toString()));
      }
      // validate the optional field `eventTrigger`
      if (jsonObj.get("eventTrigger") != null && !jsonObj.get("eventTrigger").isJsonNull()) {
        EventTrigger.validateJsonElement(jsonObj.get("eventTrigger"));
      }
      // validate the optional field `httpsTrigger`
      if (jsonObj.get("httpsTrigger") != null && !jsonObj.get("httpsTrigger").isJsonNull()) {
        HttpsTrigger.validateJsonElement(jsonObj.get("httpsTrigger"));
      }
      if ((jsonObj.get("ingressSettings") != null && !jsonObj.get("ingressSettings").isJsonNull()) && !jsonObj.get("ingressSettings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ingressSettings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ingressSettings").toString()));
      }
      // validate the optional field `ingressSettings`
      if (jsonObj.get("ingressSettings") != null && !jsonObj.get("ingressSettings").isJsonNull()) {
        IngressSettingsEnum.validateJsonElement(jsonObj.get("ingressSettings"));
      }
      if ((jsonObj.get("kmsKeyName") != null && !jsonObj.get("kmsKeyName").isJsonNull()) && !jsonObj.get("kmsKeyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKeyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKeyName").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      // validate the optional field `onDeployUpdatePolicy`
      if (jsonObj.get("onDeployUpdatePolicy") != null && !jsonObj.get("onDeployUpdatePolicy").isJsonNull()) {
        OnDeployUpdatePolicy.validateJsonElement(jsonObj.get("onDeployUpdatePolicy"));
      }
      if ((jsonObj.get("runtime") != null && !jsonObj.get("runtime").isJsonNull()) && !jsonObj.get("runtime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `runtime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("runtime").toString()));
      }
      if (jsonObj.get("secretEnvironmentVariables") != null && !jsonObj.get("secretEnvironmentVariables").isJsonNull()) {
        JsonArray jsonArraysecretEnvironmentVariables = jsonObj.getAsJsonArray("secretEnvironmentVariables");
        if (jsonArraysecretEnvironmentVariables != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secretEnvironmentVariables").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secretEnvironmentVariables` to be an array in the JSON string but got `%s`", jsonObj.get("secretEnvironmentVariables").toString()));
          }

          // validate the optional field `secretEnvironmentVariables` (array)
          for (int i = 0; i < jsonArraysecretEnvironmentVariables.size(); i++) {
            SecretEnvVar.validateJsonElement(jsonArraysecretEnvironmentVariables.get(i));
          };
        }
      }
      if (jsonObj.get("secretVolumes") != null && !jsonObj.get("secretVolumes").isJsonNull()) {
        JsonArray jsonArraysecretVolumes = jsonObj.getAsJsonArray("secretVolumes");
        if (jsonArraysecretVolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secretVolumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secretVolumes` to be an array in the JSON string but got `%s`", jsonObj.get("secretVolumes").toString()));
          }

          // validate the optional field `secretVolumes` (array)
          for (int i = 0; i < jsonArraysecretVolumes.size(); i++) {
            SecretVolume.validateJsonElement(jsonArraysecretVolumes.get(i));
          };
        }
      }
      if ((jsonObj.get("serviceAccountEmail") != null && !jsonObj.get("serviceAccountEmail").isJsonNull()) && !jsonObj.get("serviceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmail").toString()));
      }
      if ((jsonObj.get("sourceArchiveUrl") != null && !jsonObj.get("sourceArchiveUrl").isJsonNull()) && !jsonObj.get("sourceArchiveUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceArchiveUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceArchiveUrl").toString()));
      }
      // validate the optional field `sourceRepository`
      if (jsonObj.get("sourceRepository") != null && !jsonObj.get("sourceRepository").isJsonNull()) {
        SourceRepository.validateJsonElement(jsonObj.get("sourceRepository"));
      }
      if ((jsonObj.get("sourceToken") != null && !jsonObj.get("sourceToken").isJsonNull()) && !jsonObj.get("sourceToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceToken").toString()));
      }
      if ((jsonObj.get("sourceUploadUrl") != null && !jsonObj.get("sourceUploadUrl").isJsonNull()) && !jsonObj.get("sourceUploadUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceUploadUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceUploadUrl").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("timeout") != null && !jsonObj.get("timeout").isJsonNull()) && !jsonObj.get("timeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeout").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      if ((jsonObj.get("versionId") != null && !jsonObj.get("versionId").isJsonNull()) && !jsonObj.get("versionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `versionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("versionId").toString()));
      }
      if ((jsonObj.get("vpcConnector") != null && !jsonObj.get("vpcConnector").isJsonNull()) && !jsonObj.get("vpcConnector").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpcConnector` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpcConnector").toString()));
      }
      if ((jsonObj.get("vpcConnectorEgressSettings") != null && !jsonObj.get("vpcConnectorEgressSettings").isJsonNull()) && !jsonObj.get("vpcConnectorEgressSettings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpcConnectorEgressSettings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpcConnectorEgressSettings").toString()));
      }
      // validate the optional field `vpcConnectorEgressSettings`
      if (jsonObj.get("vpcConnectorEgressSettings") != null && !jsonObj.get("vpcConnectorEgressSettings").isJsonNull()) {
        VpcConnectorEgressSettingsEnum.validateJsonElement(jsonObj.get("vpcConnectorEgressSettings"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CloudFunction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CloudFunction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CloudFunction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CloudFunction.class));

       return (TypeAdapter<T>) new TypeAdapter<CloudFunction>() {
           @Override
           public void write(JsonWriter out, CloudFunction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CloudFunction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CloudFunction given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CloudFunction
   * @throws IOException if the JSON string is invalid with respect to CloudFunction
   */
  public static CloudFunction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CloudFunction.class);
  }

  /**
   * Convert an instance of CloudFunction to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

