/**
 * Cloud Functions API
 * Manages lightweight user-provided functions executed in response to events.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import OnDeployUpdatePolicy from './OnDeployUpdatePolicy';
import Source from './Source';
import SourceProvenance from './SourceProvenance';

/**
 * The BuildConfig model module.
 * @module model/BuildConfig
 * @version v2
 */
class BuildConfig {
    /**
     * Constructs a new <code>BuildConfig</code>.
     * Describes the Build step of the function that builds a container from the given source.
     * @alias module:model/BuildConfig
     */
    constructor() { 
        
        BuildConfig.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>BuildConfig</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/BuildConfig} obj Optional instance to populate.
     * @return {module:model/BuildConfig} The populated <code>BuildConfig</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new BuildConfig();

            if (data.hasOwnProperty('automaticUpdatePolicy')) {
                obj['automaticUpdatePolicy'] = ApiClient.convertToType(data['automaticUpdatePolicy'], Object);
            }
            if (data.hasOwnProperty('build')) {
                obj['build'] = ApiClient.convertToType(data['build'], 'String');
            }
            if (data.hasOwnProperty('dockerRegistry')) {
                obj['dockerRegistry'] = ApiClient.convertToType(data['dockerRegistry'], 'String');
            }
            if (data.hasOwnProperty('dockerRepository')) {
                obj['dockerRepository'] = ApiClient.convertToType(data['dockerRepository'], 'String');
            }
            if (data.hasOwnProperty('entryPoint')) {
                obj['entryPoint'] = ApiClient.convertToType(data['entryPoint'], 'String');
            }
            if (data.hasOwnProperty('environmentVariables')) {
                obj['environmentVariables'] = ApiClient.convertToType(data['environmentVariables'], {'String': 'String'});
            }
            if (data.hasOwnProperty('onDeployUpdatePolicy')) {
                obj['onDeployUpdatePolicy'] = OnDeployUpdatePolicy.constructFromObject(data['onDeployUpdatePolicy']);
            }
            if (data.hasOwnProperty('runtime')) {
                obj['runtime'] = ApiClient.convertToType(data['runtime'], 'String');
            }
            if (data.hasOwnProperty('serviceAccount')) {
                obj['serviceAccount'] = ApiClient.convertToType(data['serviceAccount'], 'String');
            }
            if (data.hasOwnProperty('source')) {
                obj['source'] = Source.constructFromObject(data['source']);
            }
            if (data.hasOwnProperty('sourceProvenance')) {
                obj['sourceProvenance'] = SourceProvenance.constructFromObject(data['sourceProvenance']);
            }
            if (data.hasOwnProperty('sourceToken')) {
                obj['sourceToken'] = ApiClient.convertToType(data['sourceToken'], 'String');
            }
            if (data.hasOwnProperty('workerPool')) {
                obj['workerPool'] = ApiClient.convertToType(data['workerPool'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>BuildConfig</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>BuildConfig</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['build'] && !(typeof data['build'] === 'string' || data['build'] instanceof String)) {
            throw new Error("Expected the field `build` to be a primitive type in the JSON string but got " + data['build']);
        }
        // ensure the json data is a string
        if (data['dockerRegistry'] && !(typeof data['dockerRegistry'] === 'string' || data['dockerRegistry'] instanceof String)) {
            throw new Error("Expected the field `dockerRegistry` to be a primitive type in the JSON string but got " + data['dockerRegistry']);
        }
        // ensure the json data is a string
        if (data['dockerRepository'] && !(typeof data['dockerRepository'] === 'string' || data['dockerRepository'] instanceof String)) {
            throw new Error("Expected the field `dockerRepository` to be a primitive type in the JSON string but got " + data['dockerRepository']);
        }
        // ensure the json data is a string
        if (data['entryPoint'] && !(typeof data['entryPoint'] === 'string' || data['entryPoint'] instanceof String)) {
            throw new Error("Expected the field `entryPoint` to be a primitive type in the JSON string but got " + data['entryPoint']);
        }
        // validate the optional field `onDeployUpdatePolicy`
        if (data['onDeployUpdatePolicy']) { // data not null
          OnDeployUpdatePolicy.validateJSON(data['onDeployUpdatePolicy']);
        }
        // ensure the json data is a string
        if (data['runtime'] && !(typeof data['runtime'] === 'string' || data['runtime'] instanceof String)) {
            throw new Error("Expected the field `runtime` to be a primitive type in the JSON string but got " + data['runtime']);
        }
        // ensure the json data is a string
        if (data['serviceAccount'] && !(typeof data['serviceAccount'] === 'string' || data['serviceAccount'] instanceof String)) {
            throw new Error("Expected the field `serviceAccount` to be a primitive type in the JSON string but got " + data['serviceAccount']);
        }
        // validate the optional field `source`
        if (data['source']) { // data not null
          Source.validateJSON(data['source']);
        }
        // validate the optional field `sourceProvenance`
        if (data['sourceProvenance']) { // data not null
          SourceProvenance.validateJSON(data['sourceProvenance']);
        }
        // ensure the json data is a string
        if (data['sourceToken'] && !(typeof data['sourceToken'] === 'string' || data['sourceToken'] instanceof String)) {
            throw new Error("Expected the field `sourceToken` to be a primitive type in the JSON string but got " + data['sourceToken']);
        }
        // ensure the json data is a string
        if (data['workerPool'] && !(typeof data['workerPool'] === 'string' || data['workerPool'] instanceof String)) {
            throw new Error("Expected the field `workerPool` to be a primitive type in the JSON string but got " + data['workerPool']);
        }

        return true;
    }


}



/**
 * Security patches are applied automatically to the runtime without requiring the function to be redeployed.
 * @member {Object} automaticUpdatePolicy
 */
BuildConfig.prototype['automaticUpdatePolicy'] = undefined;

/**
 * Output only. The Cloud Build name of the latest successful deployment of the function.
 * @member {String} build
 */
BuildConfig.prototype['build'] = undefined;

/**
 * Docker Registry to use for this deployment. This configuration is only applicable to 1st Gen functions, 2nd Gen functions can only use Artifact Registry. If `docker_repository` field is specified, this field will be automatically set as `ARTIFACT_REGISTRY`. If unspecified, it currently defaults to `CONTAINER_REGISTRY`. This field may be overridden by the backend for eligible deployments.
 * @member {module:model/BuildConfig.DockerRegistryEnum} dockerRegistry
 */
BuildConfig.prototype['dockerRegistry'] = undefined;

/**
 * Repository in Artifact Registry to which the function docker image will be pushed after it is built by Cloud Build. If specified by user, it is created and managed by user with a customer managed encryption key. Otherwise, GCF will create and use a repository named 'gcf-artifacts' for every deployed region. It must match the pattern `projects/{project}/locations/{location}/repositories/{repository}`. Cross-project repositories are not supported. Cross-location repositories are not supported. Repository format must be 'DOCKER'.
 * @member {String} dockerRepository
 */
BuildConfig.prototype['dockerRepository'] = undefined;

/**
 * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named \"function\". For Node.js this is name of a function exported by the module specified in `source_location`.
 * @member {String} entryPoint
 */
BuildConfig.prototype['entryPoint'] = undefined;

/**
 * User-provided build-time environment variables for the function
 * @member {Object.<String, String>} environmentVariables
 */
BuildConfig.prototype['environmentVariables'] = undefined;

/**
 * @member {module:model/OnDeployUpdatePolicy} onDeployUpdatePolicy
 */
BuildConfig.prototype['onDeployUpdatePolicy'] = undefined;

/**
 * The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function. For a complete list of possible choices, see the [`gcloud` command reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
 * @member {String} runtime
 */
BuildConfig.prototype['runtime'] = undefined;

/**
 * [Preview] Service account to be used for building the container
 * @member {String} serviceAccount
 */
BuildConfig.prototype['serviceAccount'] = undefined;

/**
 * @member {module:model/Source} source
 */
BuildConfig.prototype['source'] = undefined;

/**
 * @member {module:model/SourceProvenance} sourceProvenance
 */
BuildConfig.prototype['sourceProvenance'] = undefined;

/**
 * An identifier for Firebase function sources. Disclaimer: This field is only supported for Firebase function deployments.
 * @member {String} sourceToken
 */
BuildConfig.prototype['sourceToken'] = undefined;

/**
 * Name of the Cloud Build Custom Worker Pool that should be used to build the function. The format of this field is `projects/{project}/locations/{region}/workerPools/{workerPool}` where {project} and {region} are the project id and region respectively where the worker pool is defined and {workerPool} is the short name of the worker pool. If the project id is not the same as the function, then the Cloud Functions Service Agent (service-@gcf-admin-robot.iam.gserviceaccount.com) must be granted the role Cloud Build Custom Workers Builder (roles/cloudbuild.customworkers.builder) in the project.
 * @member {String} workerPool
 */
BuildConfig.prototype['workerPool'] = undefined;





/**
 * Allowed values for the <code>dockerRegistry</code> property.
 * @enum {String}
 * @readonly
 */
BuildConfig['DockerRegistryEnum'] = {

    /**
     * value: "DOCKER_REGISTRY_UNSPECIFIED"
     * @const
     */
    "DOCKER_REGISTRY_UNSPECIFIED": "DOCKER_REGISTRY_UNSPECIFIED",

    /**
     * value: "CONTAINER_REGISTRY"
     * @const
     */
    "CONTAINER_REGISTRY": "CONTAINER_REGISTRY",

    /**
     * value: "ARTIFACT_REGISTRY"
     * @const
     */
    "ARTIFACT_REGISTRY": "ARTIFACT_REGISTRY"
};



export default BuildConfig;

