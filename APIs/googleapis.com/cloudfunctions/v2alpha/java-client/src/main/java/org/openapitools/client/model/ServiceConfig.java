/*
 * Cloud Functions API
 * Manages lightweight user-provided functions executed in response to events.
 *
 * The version of the OpenAPI document: v2alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.SecretEnvVar;
import org.openapitools.client.model.SecretVolume;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the Service being deployed. Currently Supported : Cloud Run (fully managed).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:56.157616-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ServiceConfig {
  public static final String SERIALIZED_NAME_ALL_TRAFFIC_ON_LATEST_REVISION = "allTrafficOnLatestRevision";
  @SerializedName(SERIALIZED_NAME_ALL_TRAFFIC_ON_LATEST_REVISION)
  private Boolean allTrafficOnLatestRevision;

  public static final String SERIALIZED_NAME_AVAILABLE_CPU = "availableCpu";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_CPU)
  private String availableCpu;

  public static final String SERIALIZED_NAME_AVAILABLE_MEMORY = "availableMemory";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_MEMORY)
  private String availableMemory;

  public static final String SERIALIZED_NAME_ENVIRONMENT_VARIABLES = "environmentVariables";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_VARIABLES)
  private Map<String, String> environmentVariables = new HashMap<>();

  /**
   * The ingress settings for the function, controlling what traffic can reach it.
   */
  @JsonAdapter(IngressSettingsEnum.Adapter.class)
  public enum IngressSettingsEnum {
    INGRESS_SETTINGS_UNSPECIFIED("INGRESS_SETTINGS_UNSPECIFIED"),
    
    ALLOW_ALL("ALLOW_ALL"),
    
    ALLOW_INTERNAL_ONLY("ALLOW_INTERNAL_ONLY"),
    
    ALLOW_INTERNAL_AND_GCLB("ALLOW_INTERNAL_AND_GCLB");

    private String value;

    IngressSettingsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IngressSettingsEnum fromValue(String value) {
      for (IngressSettingsEnum b : IngressSettingsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IngressSettingsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IngressSettingsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IngressSettingsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IngressSettingsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IngressSettingsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INGRESS_SETTINGS = "ingressSettings";
  @SerializedName(SERIALIZED_NAME_INGRESS_SETTINGS)
  private IngressSettingsEnum ingressSettings;

  public static final String SERIALIZED_NAME_MAX_INSTANCE_COUNT = "maxInstanceCount";
  @SerializedName(SERIALIZED_NAME_MAX_INSTANCE_COUNT)
  private Integer maxInstanceCount;

  public static final String SERIALIZED_NAME_MAX_INSTANCE_REQUEST_CONCURRENCY = "maxInstanceRequestConcurrency";
  @SerializedName(SERIALIZED_NAME_MAX_INSTANCE_REQUEST_CONCURRENCY)
  private Integer maxInstanceRequestConcurrency;

  public static final String SERIALIZED_NAME_MIN_INSTANCE_COUNT = "minInstanceCount";
  @SerializedName(SERIALIZED_NAME_MIN_INSTANCE_COUNT)
  private Integer minInstanceCount;

  public static final String SERIALIZED_NAME_REVISION = "revision";
  @SerializedName(SERIALIZED_NAME_REVISION)
  private String revision;

  public static final String SERIALIZED_NAME_SECRET_ENVIRONMENT_VARIABLES = "secretEnvironmentVariables";
  @SerializedName(SERIALIZED_NAME_SECRET_ENVIRONMENT_VARIABLES)
  private List<SecretEnvVar> secretEnvironmentVariables = new ArrayList<>();

  public static final String SERIALIZED_NAME_SECRET_VOLUMES = "secretVolumes";
  @SerializedName(SERIALIZED_NAME_SECRET_VOLUMES)
  private List<SecretVolume> secretVolumes = new ArrayList<>();

  /**
   * Security level configure whether the function only accepts https. This configuration is only applicable to 1st Gen functions with Http trigger. By default https is optional for 1st Gen functions; 2nd Gen functions are https ONLY.
   */
  @JsonAdapter(SecurityLevelEnum.Adapter.class)
  public enum SecurityLevelEnum {
    SECURITY_LEVEL_UNSPECIFIED("SECURITY_LEVEL_UNSPECIFIED"),
    
    SECURE_ALWAYS("SECURE_ALWAYS"),
    
    SECURE_OPTIONAL("SECURE_OPTIONAL");

    private String value;

    SecurityLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecurityLevelEnum fromValue(String value) {
      for (SecurityLevelEnum b : SecurityLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SecurityLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecurityLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecurityLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SecurityLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SecurityLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECURITY_LEVEL = "securityLevel";
  @SerializedName(SERIALIZED_NAME_SECURITY_LEVEL)
  private SecurityLevelEnum securityLevel;

  public static final String SERIALIZED_NAME_SERVICE = "service";
  @SerializedName(SERIALIZED_NAME_SERVICE)
  private String service;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL = "serviceAccountEmail";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL)
  private String serviceAccountEmail;

  public static final String SERIALIZED_NAME_TIMEOUT_SECONDS = "timeoutSeconds";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_SECONDS)
  private Integer timeoutSeconds;

  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  private String uri;

  public static final String SERIALIZED_NAME_VPC_CONNECTOR = "vpcConnector";
  @SerializedName(SERIALIZED_NAME_VPC_CONNECTOR)
  private String vpcConnector;

  /**
   * The egress settings for the connector, controlling what traffic is diverted through it.
   */
  @JsonAdapter(VpcConnectorEgressSettingsEnum.Adapter.class)
  public enum VpcConnectorEgressSettingsEnum {
    VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED("VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED"),
    
    PRIVATE_RANGES_ONLY("PRIVATE_RANGES_ONLY"),
    
    ALL_TRAFFIC("ALL_TRAFFIC");

    private String value;

    VpcConnectorEgressSettingsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VpcConnectorEgressSettingsEnum fromValue(String value) {
      for (VpcConnectorEgressSettingsEnum b : VpcConnectorEgressSettingsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VpcConnectorEgressSettingsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VpcConnectorEgressSettingsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VpcConnectorEgressSettingsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VpcConnectorEgressSettingsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VpcConnectorEgressSettingsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VPC_CONNECTOR_EGRESS_SETTINGS = "vpcConnectorEgressSettings";
  @SerializedName(SERIALIZED_NAME_VPC_CONNECTOR_EGRESS_SETTINGS)
  private VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings;

  public ServiceConfig() {
  }

  public ServiceConfig(
     String revision, 
     String service, 
     String uri
  ) {
    this();
    this.revision = revision;
    this.service = service;
    this.uri = uri;
  }

  public ServiceConfig allTrafficOnLatestRevision(Boolean allTrafficOnLatestRevision) {
    this.allTrafficOnLatestRevision = allTrafficOnLatestRevision;
    return this;
  }

  /**
   * Whether 100% of traffic is routed to the latest revision. On CreateFunction and UpdateFunction, when set to true, the revision being deployed will serve 100% of traffic, ignoring any traffic split settings, if any. On GetFunction, true will be returned if the latest revision is serving 100% of traffic.
   * @return allTrafficOnLatestRevision
   */
  @javax.annotation.Nullable
  public Boolean getAllTrafficOnLatestRevision() {
    return allTrafficOnLatestRevision;
  }

  public void setAllTrafficOnLatestRevision(Boolean allTrafficOnLatestRevision) {
    this.allTrafficOnLatestRevision = allTrafficOnLatestRevision;
  }


  public ServiceConfig availableCpu(String availableCpu) {
    this.availableCpu = availableCpu;
    return this;
  }

  /**
   * The number of CPUs used in a single container instance. Default value is calculated from available memory. Supports the same values as Cloud Run, see https://cloud.google.com/run/docs/reference/rest/v1/Container#resourcerequirements Example: \&quot;1\&quot; indicates 1 vCPU
   * @return availableCpu
   */
  @javax.annotation.Nullable
  public String getAvailableCpu() {
    return availableCpu;
  }

  public void setAvailableCpu(String availableCpu) {
    this.availableCpu = availableCpu;
  }


  public ServiceConfig availableMemory(String availableMemory) {
    this.availableMemory = availableMemory;
    return this;
  }

  /**
   * The amount of memory available for a function. Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is supplied the value is interpreted as bytes. See https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go a full description.
   * @return availableMemory
   */
  @javax.annotation.Nullable
  public String getAvailableMemory() {
    return availableMemory;
  }

  public void setAvailableMemory(String availableMemory) {
    this.availableMemory = availableMemory;
  }


  public ServiceConfig environmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
    return this;
  }

  public ServiceConfig putEnvironmentVariablesItem(String key, String environmentVariablesItem) {
    if (this.environmentVariables == null) {
      this.environmentVariables = new HashMap<>();
    }
    this.environmentVariables.put(key, environmentVariablesItem);
    return this;
  }

  /**
   * Environment variables that shall be available during function execution.
   * @return environmentVariables
   */
  @javax.annotation.Nullable
  public Map<String, String> getEnvironmentVariables() {
    return environmentVariables;
  }

  public void setEnvironmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
  }


  public ServiceConfig ingressSettings(IngressSettingsEnum ingressSettings) {
    this.ingressSettings = ingressSettings;
    return this;
  }

  /**
   * The ingress settings for the function, controlling what traffic can reach it.
   * @return ingressSettings
   */
  @javax.annotation.Nullable
  public IngressSettingsEnum getIngressSettings() {
    return ingressSettings;
  }

  public void setIngressSettings(IngressSettingsEnum ingressSettings) {
    this.ingressSettings = ingressSettings;
  }


  public ServiceConfig maxInstanceCount(Integer maxInstanceCount) {
    this.maxInstanceCount = maxInstanceCount;
    return this;
  }

  /**
   * The limit on the maximum number of function instances that may coexist at a given time. In some cases, such as rapid traffic surges, Cloud Functions may, for a short period of time, create more instances than the specified max instances limit. If your function cannot tolerate this temporary behavior, you may want to factor in a safety margin and set a lower max instances value than your function can tolerate. See the [Max Instances](https://cloud.google.com/functions/docs/max-instances) Guide for more details.
   * @return maxInstanceCount
   */
  @javax.annotation.Nullable
  public Integer getMaxInstanceCount() {
    return maxInstanceCount;
  }

  public void setMaxInstanceCount(Integer maxInstanceCount) {
    this.maxInstanceCount = maxInstanceCount;
  }


  public ServiceConfig maxInstanceRequestConcurrency(Integer maxInstanceRequestConcurrency) {
    this.maxInstanceRequestConcurrency = maxInstanceRequestConcurrency;
    return this;
  }

  /**
   * Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
   * @return maxInstanceRequestConcurrency
   */
  @javax.annotation.Nullable
  public Integer getMaxInstanceRequestConcurrency() {
    return maxInstanceRequestConcurrency;
  }

  public void setMaxInstanceRequestConcurrency(Integer maxInstanceRequestConcurrency) {
    this.maxInstanceRequestConcurrency = maxInstanceRequestConcurrency;
  }


  public ServiceConfig minInstanceCount(Integer minInstanceCount) {
    this.minInstanceCount = minInstanceCount;
    return this;
  }

  /**
   * The limit on the minimum number of function instances that may coexist at a given time. Function instances are kept in idle state for a short period after they finished executing the request to reduce cold start time for subsequent requests. Setting a minimum instance count will ensure that the given number of instances are kept running in idle state always. This can help with cold start times when jump in incoming request count occurs after the idle instance would have been stopped in the default case.
   * @return minInstanceCount
   */
  @javax.annotation.Nullable
  public Integer getMinInstanceCount() {
    return minInstanceCount;
  }

  public void setMinInstanceCount(Integer minInstanceCount) {
    this.minInstanceCount = minInstanceCount;
  }


  /**
   * Output only. The name of service revision.
   * @return revision
   */
  @javax.annotation.Nullable
  public String getRevision() {
    return revision;
  }



  public ServiceConfig secretEnvironmentVariables(List<SecretEnvVar> secretEnvironmentVariables) {
    this.secretEnvironmentVariables = secretEnvironmentVariables;
    return this;
  }

  public ServiceConfig addSecretEnvironmentVariablesItem(SecretEnvVar secretEnvironmentVariablesItem) {
    if (this.secretEnvironmentVariables == null) {
      this.secretEnvironmentVariables = new ArrayList<>();
    }
    this.secretEnvironmentVariables.add(secretEnvironmentVariablesItem);
    return this;
  }

  /**
   * Secret environment variables configuration.
   * @return secretEnvironmentVariables
   */
  @javax.annotation.Nullable
  public List<SecretEnvVar> getSecretEnvironmentVariables() {
    return secretEnvironmentVariables;
  }

  public void setSecretEnvironmentVariables(List<SecretEnvVar> secretEnvironmentVariables) {
    this.secretEnvironmentVariables = secretEnvironmentVariables;
  }


  public ServiceConfig secretVolumes(List<SecretVolume> secretVolumes) {
    this.secretVolumes = secretVolumes;
    return this;
  }

  public ServiceConfig addSecretVolumesItem(SecretVolume secretVolumesItem) {
    if (this.secretVolumes == null) {
      this.secretVolumes = new ArrayList<>();
    }
    this.secretVolumes.add(secretVolumesItem);
    return this;
  }

  /**
   * Secret volumes configuration.
   * @return secretVolumes
   */
  @javax.annotation.Nullable
  public List<SecretVolume> getSecretVolumes() {
    return secretVolumes;
  }

  public void setSecretVolumes(List<SecretVolume> secretVolumes) {
    this.secretVolumes = secretVolumes;
  }


  public ServiceConfig securityLevel(SecurityLevelEnum securityLevel) {
    this.securityLevel = securityLevel;
    return this;
  }

  /**
   * Security level configure whether the function only accepts https. This configuration is only applicable to 1st Gen functions with Http trigger. By default https is optional for 1st Gen functions; 2nd Gen functions are https ONLY.
   * @return securityLevel
   */
  @javax.annotation.Nullable
  public SecurityLevelEnum getSecurityLevel() {
    return securityLevel;
  }

  public void setSecurityLevel(SecurityLevelEnum securityLevel) {
    this.securityLevel = securityLevel;
  }


  /**
   * Output only. Name of the service associated with a Function. The format of this field is &#x60;projects/{project}/locations/{region}/services/{service}&#x60;
   * @return service
   */
  @javax.annotation.Nullable
  public String getService() {
    return service;
  }



  public ServiceConfig serviceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
    return this;
  }

  /**
   * The email of the service&#39;s service account. If empty, defaults to &#x60;{project_number}-compute@developer.gserviceaccount.com&#x60;.
   * @return serviceAccountEmail
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmail() {
    return serviceAccountEmail;
  }

  public void setServiceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
  }


  public ServiceConfig timeoutSeconds(Integer timeoutSeconds) {
    this.timeoutSeconds = timeoutSeconds;
    return this;
  }

  /**
   * The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.
   * @return timeoutSeconds
   */
  @javax.annotation.Nullable
  public Integer getTimeoutSeconds() {
    return timeoutSeconds;
  }

  public void setTimeoutSeconds(Integer timeoutSeconds) {
    this.timeoutSeconds = timeoutSeconds;
  }


  /**
   * Output only. URI of the Service deployed.
   * @return uri
   */
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }



  public ServiceConfig vpcConnector(String vpcConnector) {
    this.vpcConnector = vpcConnector;
    return this;
  }

  /**
   * The Serverless VPC Access connector that this cloud function can connect to. The format of this field is &#x60;projects/_*_/locations/_*_/connectors/_*&#x60;.
   * @return vpcConnector
   */
  @javax.annotation.Nullable
  public String getVpcConnector() {
    return vpcConnector;
  }

  public void setVpcConnector(String vpcConnector) {
    this.vpcConnector = vpcConnector;
  }


  public ServiceConfig vpcConnectorEgressSettings(VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings) {
    this.vpcConnectorEgressSettings = vpcConnectorEgressSettings;
    return this;
  }

  /**
   * The egress settings for the connector, controlling what traffic is diverted through it.
   * @return vpcConnectorEgressSettings
   */
  @javax.annotation.Nullable
  public VpcConnectorEgressSettingsEnum getVpcConnectorEgressSettings() {
    return vpcConnectorEgressSettings;
  }

  public void setVpcConnectorEgressSettings(VpcConnectorEgressSettingsEnum vpcConnectorEgressSettings) {
    this.vpcConnectorEgressSettings = vpcConnectorEgressSettings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServiceConfig serviceConfig = (ServiceConfig) o;
    return Objects.equals(this.allTrafficOnLatestRevision, serviceConfig.allTrafficOnLatestRevision) &&
        Objects.equals(this.availableCpu, serviceConfig.availableCpu) &&
        Objects.equals(this.availableMemory, serviceConfig.availableMemory) &&
        Objects.equals(this.environmentVariables, serviceConfig.environmentVariables) &&
        Objects.equals(this.ingressSettings, serviceConfig.ingressSettings) &&
        Objects.equals(this.maxInstanceCount, serviceConfig.maxInstanceCount) &&
        Objects.equals(this.maxInstanceRequestConcurrency, serviceConfig.maxInstanceRequestConcurrency) &&
        Objects.equals(this.minInstanceCount, serviceConfig.minInstanceCount) &&
        Objects.equals(this.revision, serviceConfig.revision) &&
        Objects.equals(this.secretEnvironmentVariables, serviceConfig.secretEnvironmentVariables) &&
        Objects.equals(this.secretVolumes, serviceConfig.secretVolumes) &&
        Objects.equals(this.securityLevel, serviceConfig.securityLevel) &&
        Objects.equals(this.service, serviceConfig.service) &&
        Objects.equals(this.serviceAccountEmail, serviceConfig.serviceAccountEmail) &&
        Objects.equals(this.timeoutSeconds, serviceConfig.timeoutSeconds) &&
        Objects.equals(this.uri, serviceConfig.uri) &&
        Objects.equals(this.vpcConnector, serviceConfig.vpcConnector) &&
        Objects.equals(this.vpcConnectorEgressSettings, serviceConfig.vpcConnectorEgressSettings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allTrafficOnLatestRevision, availableCpu, availableMemory, environmentVariables, ingressSettings, maxInstanceCount, maxInstanceRequestConcurrency, minInstanceCount, revision, secretEnvironmentVariables, secretVolumes, securityLevel, service, serviceAccountEmail, timeoutSeconds, uri, vpcConnector, vpcConnectorEgressSettings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServiceConfig {\n");
    sb.append("    allTrafficOnLatestRevision: ").append(toIndentedString(allTrafficOnLatestRevision)).append("\n");
    sb.append("    availableCpu: ").append(toIndentedString(availableCpu)).append("\n");
    sb.append("    availableMemory: ").append(toIndentedString(availableMemory)).append("\n");
    sb.append("    environmentVariables: ").append(toIndentedString(environmentVariables)).append("\n");
    sb.append("    ingressSettings: ").append(toIndentedString(ingressSettings)).append("\n");
    sb.append("    maxInstanceCount: ").append(toIndentedString(maxInstanceCount)).append("\n");
    sb.append("    maxInstanceRequestConcurrency: ").append(toIndentedString(maxInstanceRequestConcurrency)).append("\n");
    sb.append("    minInstanceCount: ").append(toIndentedString(minInstanceCount)).append("\n");
    sb.append("    revision: ").append(toIndentedString(revision)).append("\n");
    sb.append("    secretEnvironmentVariables: ").append(toIndentedString(secretEnvironmentVariables)).append("\n");
    sb.append("    secretVolumes: ").append(toIndentedString(secretVolumes)).append("\n");
    sb.append("    securityLevel: ").append(toIndentedString(securityLevel)).append("\n");
    sb.append("    service: ").append(toIndentedString(service)).append("\n");
    sb.append("    serviceAccountEmail: ").append(toIndentedString(serviceAccountEmail)).append("\n");
    sb.append("    timeoutSeconds: ").append(toIndentedString(timeoutSeconds)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    vpcConnector: ").append(toIndentedString(vpcConnector)).append("\n");
    sb.append("    vpcConnectorEgressSettings: ").append(toIndentedString(vpcConnectorEgressSettings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allTrafficOnLatestRevision");
    openapiFields.add("availableCpu");
    openapiFields.add("availableMemory");
    openapiFields.add("environmentVariables");
    openapiFields.add("ingressSettings");
    openapiFields.add("maxInstanceCount");
    openapiFields.add("maxInstanceRequestConcurrency");
    openapiFields.add("minInstanceCount");
    openapiFields.add("revision");
    openapiFields.add("secretEnvironmentVariables");
    openapiFields.add("secretVolumes");
    openapiFields.add("securityLevel");
    openapiFields.add("service");
    openapiFields.add("serviceAccountEmail");
    openapiFields.add("timeoutSeconds");
    openapiFields.add("uri");
    openapiFields.add("vpcConnector");
    openapiFields.add("vpcConnectorEgressSettings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ServiceConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ServiceConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServiceConfig is not found in the empty JSON string", ServiceConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ServiceConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ServiceConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("availableCpu") != null && !jsonObj.get("availableCpu").isJsonNull()) && !jsonObj.get("availableCpu").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableCpu` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availableCpu").toString()));
      }
      if ((jsonObj.get("availableMemory") != null && !jsonObj.get("availableMemory").isJsonNull()) && !jsonObj.get("availableMemory").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableMemory` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availableMemory").toString()));
      }
      if ((jsonObj.get("ingressSettings") != null && !jsonObj.get("ingressSettings").isJsonNull()) && !jsonObj.get("ingressSettings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ingressSettings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ingressSettings").toString()));
      }
      // validate the optional field `ingressSettings`
      if (jsonObj.get("ingressSettings") != null && !jsonObj.get("ingressSettings").isJsonNull()) {
        IngressSettingsEnum.validateJsonElement(jsonObj.get("ingressSettings"));
      }
      if ((jsonObj.get("revision") != null && !jsonObj.get("revision").isJsonNull()) && !jsonObj.get("revision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revision").toString()));
      }
      if (jsonObj.get("secretEnvironmentVariables") != null && !jsonObj.get("secretEnvironmentVariables").isJsonNull()) {
        JsonArray jsonArraysecretEnvironmentVariables = jsonObj.getAsJsonArray("secretEnvironmentVariables");
        if (jsonArraysecretEnvironmentVariables != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secretEnvironmentVariables").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secretEnvironmentVariables` to be an array in the JSON string but got `%s`", jsonObj.get("secretEnvironmentVariables").toString()));
          }

          // validate the optional field `secretEnvironmentVariables` (array)
          for (int i = 0; i < jsonArraysecretEnvironmentVariables.size(); i++) {
            SecretEnvVar.validateJsonElement(jsonArraysecretEnvironmentVariables.get(i));
          };
        }
      }
      if (jsonObj.get("secretVolumes") != null && !jsonObj.get("secretVolumes").isJsonNull()) {
        JsonArray jsonArraysecretVolumes = jsonObj.getAsJsonArray("secretVolumes");
        if (jsonArraysecretVolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secretVolumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secretVolumes` to be an array in the JSON string but got `%s`", jsonObj.get("secretVolumes").toString()));
          }

          // validate the optional field `secretVolumes` (array)
          for (int i = 0; i < jsonArraysecretVolumes.size(); i++) {
            SecretVolume.validateJsonElement(jsonArraysecretVolumes.get(i));
          };
        }
      }
      if ((jsonObj.get("securityLevel") != null && !jsonObj.get("securityLevel").isJsonNull()) && !jsonObj.get("securityLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityLevel").toString()));
      }
      // validate the optional field `securityLevel`
      if (jsonObj.get("securityLevel") != null && !jsonObj.get("securityLevel").isJsonNull()) {
        SecurityLevelEnum.validateJsonElement(jsonObj.get("securityLevel"));
      }
      if ((jsonObj.get("service") != null && !jsonObj.get("service").isJsonNull()) && !jsonObj.get("service").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `service` to be a primitive type in the JSON string but got `%s`", jsonObj.get("service").toString()));
      }
      if ((jsonObj.get("serviceAccountEmail") != null && !jsonObj.get("serviceAccountEmail").isJsonNull()) && !jsonObj.get("serviceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmail").toString()));
      }
      if ((jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) && !jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      if ((jsonObj.get("vpcConnector") != null && !jsonObj.get("vpcConnector").isJsonNull()) && !jsonObj.get("vpcConnector").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpcConnector` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpcConnector").toString()));
      }
      if ((jsonObj.get("vpcConnectorEgressSettings") != null && !jsonObj.get("vpcConnectorEgressSettings").isJsonNull()) && !jsonObj.get("vpcConnectorEgressSettings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpcConnectorEgressSettings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpcConnectorEgressSettings").toString()));
      }
      // validate the optional field `vpcConnectorEgressSettings`
      if (jsonObj.get("vpcConnectorEgressSettings") != null && !jsonObj.get("vpcConnectorEgressSettings").isJsonNull()) {
        VpcConnectorEgressSettingsEnum.validateJsonElement(jsonObj.get("vpcConnectorEgressSettings"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ServiceConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ServiceConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ServiceConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ServiceConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ServiceConfig>() {
           @Override
           public void write(JsonWriter out, ServiceConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ServiceConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ServiceConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ServiceConfig
   * @throws IOException if the JSON string is invalid with respect to ServiceConfig
   */
  public static ServiceConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServiceConfig.class);
  }

  /**
   * Convert an instance of ServiceConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

