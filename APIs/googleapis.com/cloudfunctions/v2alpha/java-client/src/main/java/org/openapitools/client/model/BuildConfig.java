/*
 * Cloud Functions API
 * Manages lightweight user-provided functions executed in response to events.
 *
 * The version of the OpenAPI document: v2alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.OnDeployUpdatePolicy;
import org.openapitools.client.model.Source;
import org.openapitools.client.model.SourceProvenance;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the Build step of the function that builds a container from the given source.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:56.157616-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildConfig {
  public static final String SERIALIZED_NAME_AUTOMATIC_UPDATE_POLICY = "automaticUpdatePolicy";
  @SerializedName(SERIALIZED_NAME_AUTOMATIC_UPDATE_POLICY)
  private Object automaticUpdatePolicy;

  public static final String SERIALIZED_NAME_BUILD = "build";
  @SerializedName(SERIALIZED_NAME_BUILD)
  private String build;

  /**
   * Docker Registry to use for this deployment. This configuration is only applicable to 1st Gen functions, 2nd Gen functions can only use Artifact Registry. If &#x60;docker_repository&#x60; field is specified, this field will be automatically set as &#x60;ARTIFACT_REGISTRY&#x60;. If unspecified, it currently defaults to &#x60;CONTAINER_REGISTRY&#x60;. This field may be overridden by the backend for eligible deployments.
   */
  @JsonAdapter(DockerRegistryEnum.Adapter.class)
  public enum DockerRegistryEnum {
    DOCKER_REGISTRY_UNSPECIFIED("DOCKER_REGISTRY_UNSPECIFIED"),
    
    CONTAINER_REGISTRY("CONTAINER_REGISTRY"),
    
    ARTIFACT_REGISTRY("ARTIFACT_REGISTRY");

    private String value;

    DockerRegistryEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DockerRegistryEnum fromValue(String value) {
      for (DockerRegistryEnum b : DockerRegistryEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DockerRegistryEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DockerRegistryEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DockerRegistryEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DockerRegistryEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DockerRegistryEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DOCKER_REGISTRY = "dockerRegistry";
  @SerializedName(SERIALIZED_NAME_DOCKER_REGISTRY)
  private DockerRegistryEnum dockerRegistry;

  public static final String SERIALIZED_NAME_DOCKER_REPOSITORY = "dockerRepository";
  @SerializedName(SERIALIZED_NAME_DOCKER_REPOSITORY)
  private String dockerRepository;

  public static final String SERIALIZED_NAME_ENTRY_POINT = "entryPoint";
  @SerializedName(SERIALIZED_NAME_ENTRY_POINT)
  private String entryPoint;

  public static final String SERIALIZED_NAME_ENVIRONMENT_VARIABLES = "environmentVariables";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_VARIABLES)
  private Map<String, String> environmentVariables = new HashMap<>();

  public static final String SERIALIZED_NAME_ON_DEPLOY_UPDATE_POLICY = "onDeployUpdatePolicy";
  @SerializedName(SERIALIZED_NAME_ON_DEPLOY_UPDATE_POLICY)
  private OnDeployUpdatePolicy onDeployUpdatePolicy;

  public static final String SERIALIZED_NAME_RUNTIME = "runtime";
  @SerializedName(SERIALIZED_NAME_RUNTIME)
  private String runtime;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private Source source;

  public static final String SERIALIZED_NAME_SOURCE_PROVENANCE = "sourceProvenance";
  @SerializedName(SERIALIZED_NAME_SOURCE_PROVENANCE)
  private SourceProvenance sourceProvenance;

  public static final String SERIALIZED_NAME_SOURCE_TOKEN = "sourceToken";
  @SerializedName(SERIALIZED_NAME_SOURCE_TOKEN)
  private String sourceToken;

  public static final String SERIALIZED_NAME_WORKER_POOL = "workerPool";
  @SerializedName(SERIALIZED_NAME_WORKER_POOL)
  private String workerPool;

  public BuildConfig() {
  }

  public BuildConfig(
     String build
  ) {
    this();
    this.build = build;
  }

  public BuildConfig automaticUpdatePolicy(Object automaticUpdatePolicy) {
    this.automaticUpdatePolicy = automaticUpdatePolicy;
    return this;
  }

  /**
   * Security patches are applied automatically to the runtime without requiring the function to be redeployed.
   * @return automaticUpdatePolicy
   */
  @javax.annotation.Nullable
  public Object getAutomaticUpdatePolicy() {
    return automaticUpdatePolicy;
  }

  public void setAutomaticUpdatePolicy(Object automaticUpdatePolicy) {
    this.automaticUpdatePolicy = automaticUpdatePolicy;
  }


  /**
   * Output only. The Cloud Build name of the latest successful deployment of the function.
   * @return build
   */
  @javax.annotation.Nullable
  public String getBuild() {
    return build;
  }



  public BuildConfig dockerRegistry(DockerRegistryEnum dockerRegistry) {
    this.dockerRegistry = dockerRegistry;
    return this;
  }

  /**
   * Docker Registry to use for this deployment. This configuration is only applicable to 1st Gen functions, 2nd Gen functions can only use Artifact Registry. If &#x60;docker_repository&#x60; field is specified, this field will be automatically set as &#x60;ARTIFACT_REGISTRY&#x60;. If unspecified, it currently defaults to &#x60;CONTAINER_REGISTRY&#x60;. This field may be overridden by the backend for eligible deployments.
   * @return dockerRegistry
   */
  @javax.annotation.Nullable
  public DockerRegistryEnum getDockerRegistry() {
    return dockerRegistry;
  }

  public void setDockerRegistry(DockerRegistryEnum dockerRegistry) {
    this.dockerRegistry = dockerRegistry;
  }


  public BuildConfig dockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
    return this;
  }

  /**
   * Repository in Artifact Registry to which the function docker image will be pushed after it is built by Cloud Build. If specified by user, it is created and managed by user with a customer managed encryption key. Otherwise, GCF will create and use a repository named &#39;gcf-artifacts&#39; for every deployed region. It must match the pattern &#x60;projects/{project}/locations/{location}/repositories/{repository}&#x60;. Cross-project repositories are not supported. Cross-location repositories are not supported. Repository format must be &#39;DOCKER&#39;.
   * @return dockerRepository
   */
  @javax.annotation.Nullable
  public String getDockerRepository() {
    return dockerRepository;
  }

  public void setDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
  }


  public BuildConfig entryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
    return this;
  }

  /**
   * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named \&quot;function\&quot;. For Node.js this is name of a function exported by the module specified in &#x60;source_location&#x60;.
   * @return entryPoint
   */
  @javax.annotation.Nullable
  public String getEntryPoint() {
    return entryPoint;
  }

  public void setEntryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
  }


  public BuildConfig environmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
    return this;
  }

  public BuildConfig putEnvironmentVariablesItem(String key, String environmentVariablesItem) {
    if (this.environmentVariables == null) {
      this.environmentVariables = new HashMap<>();
    }
    this.environmentVariables.put(key, environmentVariablesItem);
    return this;
  }

  /**
   * User-provided build-time environment variables for the function
   * @return environmentVariables
   */
  @javax.annotation.Nullable
  public Map<String, String> getEnvironmentVariables() {
    return environmentVariables;
  }

  public void setEnvironmentVariables(Map<String, String> environmentVariables) {
    this.environmentVariables = environmentVariables;
  }


  public BuildConfig onDeployUpdatePolicy(OnDeployUpdatePolicy onDeployUpdatePolicy) {
    this.onDeployUpdatePolicy = onDeployUpdatePolicy;
    return this;
  }

  /**
   * Get onDeployUpdatePolicy
   * @return onDeployUpdatePolicy
   */
  @javax.annotation.Nullable
  public OnDeployUpdatePolicy getOnDeployUpdatePolicy() {
    return onDeployUpdatePolicy;
  }

  public void setOnDeployUpdatePolicy(OnDeployUpdatePolicy onDeployUpdatePolicy) {
    this.onDeployUpdatePolicy = onDeployUpdatePolicy;
  }


  public BuildConfig runtime(String runtime) {
    this.runtime = runtime;
    return this;
  }

  /**
   * The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function. For a complete list of possible choices, see the [&#x60;gcloud&#x60; command reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
   * @return runtime
   */
  @javax.annotation.Nullable
  public String getRuntime() {
    return runtime;
  }

  public void setRuntime(String runtime) {
    this.runtime = runtime;
  }


  public BuildConfig serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * [Preview] Service account to be used for building the container
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public BuildConfig source(Source source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nullable
  public Source getSource() {
    return source;
  }

  public void setSource(Source source) {
    this.source = source;
  }


  public BuildConfig sourceProvenance(SourceProvenance sourceProvenance) {
    this.sourceProvenance = sourceProvenance;
    return this;
  }

  /**
   * Get sourceProvenance
   * @return sourceProvenance
   */
  @javax.annotation.Nullable
  public SourceProvenance getSourceProvenance() {
    return sourceProvenance;
  }

  public void setSourceProvenance(SourceProvenance sourceProvenance) {
    this.sourceProvenance = sourceProvenance;
  }


  public BuildConfig sourceToken(String sourceToken) {
    this.sourceToken = sourceToken;
    return this;
  }

  /**
   * An identifier for Firebase function sources. Disclaimer: This field is only supported for Firebase function deployments.
   * @return sourceToken
   */
  @javax.annotation.Nullable
  public String getSourceToken() {
    return sourceToken;
  }

  public void setSourceToken(String sourceToken) {
    this.sourceToken = sourceToken;
  }


  public BuildConfig workerPool(String workerPool) {
    this.workerPool = workerPool;
    return this;
  }

  /**
   * Name of the Cloud Build Custom Worker Pool that should be used to build the function. The format of this field is &#x60;projects/{project}/locations/{region}/workerPools/{workerPool}&#x60; where {project} and {region} are the project id and region respectively where the worker pool is defined and {workerPool} is the short name of the worker pool. If the project id is not the same as the function, then the Cloud Functions Service Agent (service-@gcf-admin-robot.iam.gserviceaccount.com) must be granted the role Cloud Build Custom Workers Builder (roles/cloudbuild.customworkers.builder) in the project.
   * @return workerPool
   */
  @javax.annotation.Nullable
  public String getWorkerPool() {
    return workerPool;
  }

  public void setWorkerPool(String workerPool) {
    this.workerPool = workerPool;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BuildConfig buildConfig = (BuildConfig) o;
    return Objects.equals(this.automaticUpdatePolicy, buildConfig.automaticUpdatePolicy) &&
        Objects.equals(this.build, buildConfig.build) &&
        Objects.equals(this.dockerRegistry, buildConfig.dockerRegistry) &&
        Objects.equals(this.dockerRepository, buildConfig.dockerRepository) &&
        Objects.equals(this.entryPoint, buildConfig.entryPoint) &&
        Objects.equals(this.environmentVariables, buildConfig.environmentVariables) &&
        Objects.equals(this.onDeployUpdatePolicy, buildConfig.onDeployUpdatePolicy) &&
        Objects.equals(this.runtime, buildConfig.runtime) &&
        Objects.equals(this.serviceAccount, buildConfig.serviceAccount) &&
        Objects.equals(this.source, buildConfig.source) &&
        Objects.equals(this.sourceProvenance, buildConfig.sourceProvenance) &&
        Objects.equals(this.sourceToken, buildConfig.sourceToken) &&
        Objects.equals(this.workerPool, buildConfig.workerPool);
  }

  @Override
  public int hashCode() {
    return Objects.hash(automaticUpdatePolicy, build, dockerRegistry, dockerRepository, entryPoint, environmentVariables, onDeployUpdatePolicy, runtime, serviceAccount, source, sourceProvenance, sourceToken, workerPool);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BuildConfig {\n");
    sb.append("    automaticUpdatePolicy: ").append(toIndentedString(automaticUpdatePolicy)).append("\n");
    sb.append("    build: ").append(toIndentedString(build)).append("\n");
    sb.append("    dockerRegistry: ").append(toIndentedString(dockerRegistry)).append("\n");
    sb.append("    dockerRepository: ").append(toIndentedString(dockerRepository)).append("\n");
    sb.append("    entryPoint: ").append(toIndentedString(entryPoint)).append("\n");
    sb.append("    environmentVariables: ").append(toIndentedString(environmentVariables)).append("\n");
    sb.append("    onDeployUpdatePolicy: ").append(toIndentedString(onDeployUpdatePolicy)).append("\n");
    sb.append("    runtime: ").append(toIndentedString(runtime)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    sourceProvenance: ").append(toIndentedString(sourceProvenance)).append("\n");
    sb.append("    sourceToken: ").append(toIndentedString(sourceToken)).append("\n");
    sb.append("    workerPool: ").append(toIndentedString(workerPool)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("automaticUpdatePolicy");
    openapiFields.add("build");
    openapiFields.add("dockerRegistry");
    openapiFields.add("dockerRepository");
    openapiFields.add("entryPoint");
    openapiFields.add("environmentVariables");
    openapiFields.add("onDeployUpdatePolicy");
    openapiFields.add("runtime");
    openapiFields.add("serviceAccount");
    openapiFields.add("source");
    openapiFields.add("sourceProvenance");
    openapiFields.add("sourceToken");
    openapiFields.add("workerPool");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BuildConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BuildConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BuildConfig is not found in the empty JSON string", BuildConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BuildConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BuildConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("build") != null && !jsonObj.get("build").isJsonNull()) && !jsonObj.get("build").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `build` to be a primitive type in the JSON string but got `%s`", jsonObj.get("build").toString()));
      }
      if ((jsonObj.get("dockerRegistry") != null && !jsonObj.get("dockerRegistry").isJsonNull()) && !jsonObj.get("dockerRegistry").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dockerRegistry` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dockerRegistry").toString()));
      }
      // validate the optional field `dockerRegistry`
      if (jsonObj.get("dockerRegistry") != null && !jsonObj.get("dockerRegistry").isJsonNull()) {
        DockerRegistryEnum.validateJsonElement(jsonObj.get("dockerRegistry"));
      }
      if ((jsonObj.get("dockerRepository") != null && !jsonObj.get("dockerRepository").isJsonNull()) && !jsonObj.get("dockerRepository").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dockerRepository` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dockerRepository").toString()));
      }
      if ((jsonObj.get("entryPoint") != null && !jsonObj.get("entryPoint").isJsonNull()) && !jsonObj.get("entryPoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entryPoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entryPoint").toString()));
      }
      // validate the optional field `onDeployUpdatePolicy`
      if (jsonObj.get("onDeployUpdatePolicy") != null && !jsonObj.get("onDeployUpdatePolicy").isJsonNull()) {
        OnDeployUpdatePolicy.validateJsonElement(jsonObj.get("onDeployUpdatePolicy"));
      }
      if ((jsonObj.get("runtime") != null && !jsonObj.get("runtime").isJsonNull()) && !jsonObj.get("runtime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `runtime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("runtime").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        Source.validateJsonElement(jsonObj.get("source"));
      }
      // validate the optional field `sourceProvenance`
      if (jsonObj.get("sourceProvenance") != null && !jsonObj.get("sourceProvenance").isJsonNull()) {
        SourceProvenance.validateJsonElement(jsonObj.get("sourceProvenance"));
      }
      if ((jsonObj.get("sourceToken") != null && !jsonObj.get("sourceToken").isJsonNull()) && !jsonObj.get("sourceToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceToken").toString()));
      }
      if ((jsonObj.get("workerPool") != null && !jsonObj.get("workerPool").isJsonNull()) && !jsonObj.get("workerPool").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerPool` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerPool").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BuildConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BuildConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BuildConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BuildConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<BuildConfig>() {
           @Override
           public void write(JsonWriter out, BuildConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BuildConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BuildConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BuildConfig
   * @throws IOException if the JSON string is invalid with respect to BuildConfig
   */
  public static BuildConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BuildConfig.class);
  }

  /**
   * Convert an instance of BuildConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

