# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.absolute_date_range import AbsoluteDateRange
from openapi_server.models.realtime_time_range import RealtimeTimeRange
from openapi_server.models.relative_date_range import RelativeDateRange
from openapi_server import util


class FilterSet(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, absolute_date_range: AbsoluteDateRange=None, breakdown_dimensions: List[str]=None, creative_id: str=None, deal_id: str=None, environment: str=None, format: str=None, formats: List[str]=None, name: str=None, platforms: List[str]=None, publisher_identifiers: List[str]=None, realtime_time_range: RealtimeTimeRange=None, relative_date_range: RelativeDateRange=None, seller_network_ids: List[int]=None, time_series_granularity: str=None):
        """FilterSet - a model defined in OpenAPI

        :param absolute_date_range: The absolute_date_range of this FilterSet.
        :param breakdown_dimensions: The breakdown_dimensions of this FilterSet.
        :param creative_id: The creative_id of this FilterSet.
        :param deal_id: The deal_id of this FilterSet.
        :param environment: The environment of this FilterSet.
        :param format: The format of this FilterSet.
        :param formats: The formats of this FilterSet.
        :param name: The name of this FilterSet.
        :param platforms: The platforms of this FilterSet.
        :param publisher_identifiers: The publisher_identifiers of this FilterSet.
        :param realtime_time_range: The realtime_time_range of this FilterSet.
        :param relative_date_range: The relative_date_range of this FilterSet.
        :param seller_network_ids: The seller_network_ids of this FilterSet.
        :param time_series_granularity: The time_series_granularity of this FilterSet.
        """
        self.openapi_types = {
            'absolute_date_range': AbsoluteDateRange,
            'breakdown_dimensions': List[str],
            'creative_id': str,
            'deal_id': str,
            'environment': str,
            'format': str,
            'formats': List[str],
            'name': str,
            'platforms': List[str],
            'publisher_identifiers': List[str],
            'realtime_time_range': RealtimeTimeRange,
            'relative_date_range': RelativeDateRange,
            'seller_network_ids': List[int],
            'time_series_granularity': str
        }

        self.attribute_map = {
            'absolute_date_range': 'absoluteDateRange',
            'breakdown_dimensions': 'breakdownDimensions',
            'creative_id': 'creativeId',
            'deal_id': 'dealId',
            'environment': 'environment',
            'format': 'format',
            'formats': 'formats',
            'name': 'name',
            'platforms': 'platforms',
            'publisher_identifiers': 'publisherIdentifiers',
            'realtime_time_range': 'realtimeTimeRange',
            'relative_date_range': 'relativeDateRange',
            'seller_network_ids': 'sellerNetworkIds',
            'time_series_granularity': 'timeSeriesGranularity'
        }

        self._absolute_date_range = absolute_date_range
        self._breakdown_dimensions = breakdown_dimensions
        self._creative_id = creative_id
        self._deal_id = deal_id
        self._environment = environment
        self._format = format
        self._formats = formats
        self._name = name
        self._platforms = platforms
        self._publisher_identifiers = publisher_identifiers
        self._realtime_time_range = realtime_time_range
        self._relative_date_range = relative_date_range
        self._seller_network_ids = seller_network_ids
        self._time_series_granularity = time_series_granularity

    @classmethod
    def from_dict(cls, dikt: dict) -> 'FilterSet':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The FilterSet of this FilterSet.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def absolute_date_range(self):
        """Gets the absolute_date_range of this FilterSet.


        :return: The absolute_date_range of this FilterSet.
        :rtype: AbsoluteDateRange
        """
        return self._absolute_date_range

    @absolute_date_range.setter
    def absolute_date_range(self, absolute_date_range):
        """Sets the absolute_date_range of this FilterSet.


        :param absolute_date_range: The absolute_date_range of this FilterSet.
        :type absolute_date_range: AbsoluteDateRange
        """

        self._absolute_date_range = absolute_date_range

    @property
    def breakdown_dimensions(self):
        """Gets the breakdown_dimensions of this FilterSet.

        The set of dimensions along which to break down the response; may be empty. If multiple dimensions are requested, the breakdown is along the Cartesian product of the requested dimensions.

        :return: The breakdown_dimensions of this FilterSet.
        :rtype: List[str]
        """
        return self._breakdown_dimensions

    @breakdown_dimensions.setter
    def breakdown_dimensions(self, breakdown_dimensions):
        """Sets the breakdown_dimensions of this FilterSet.

        The set of dimensions along which to break down the response; may be empty. If multiple dimensions are requested, the breakdown is along the Cartesian product of the requested dimensions.

        :param breakdown_dimensions: The breakdown_dimensions of this FilterSet.
        :type breakdown_dimensions: List[str]
        """
        allowed_values = ["BREAKDOWN_DIMENSION_UNSPECIFIED", "PUBLISHER_IDENTIFIER"]  # noqa: E501
        if not set(breakdown_dimensions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `breakdown_dimensions` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(breakdown_dimensions) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._breakdown_dimensions = breakdown_dimensions

    @property
    def creative_id(self):
        """Gets the creative_id of this FilterSet.

        The ID of the creative on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.

        :return: The creative_id of this FilterSet.
        :rtype: str
        """
        return self._creative_id

    @creative_id.setter
    def creative_id(self, creative_id):
        """Sets the creative_id of this FilterSet.

        The ID of the creative on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.

        :param creative_id: The creative_id of this FilterSet.
        :type creative_id: str
        """

        self._creative_id = creative_id

    @property
    def deal_id(self):
        """Gets the deal_id of this FilterSet.

        The ID of the deal on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.

        :return: The deal_id of this FilterSet.
        :rtype: str
        """
        return self._deal_id

    @deal_id.setter
    def deal_id(self, deal_id):
        """Sets the deal_id of this FilterSet.

        The ID of the deal on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.

        :param deal_id: The deal_id of this FilterSet.
        :type deal_id: str
        """

        self._deal_id = deal_id

    @property
    def environment(self):
        """Gets the environment of this FilterSet.

        The environment on which to filter; optional.

        :return: The environment of this FilterSet.
        :rtype: str
        """
        return self._environment

    @environment.setter
    def environment(self, environment):
        """Sets the environment of this FilterSet.

        The environment on which to filter; optional.

        :param environment: The environment of this FilterSet.
        :type environment: str
        """
        allowed_values = ["ENVIRONMENT_UNSPECIFIED", "WEB", "APP"]  # noqa: E501
        if environment not in allowed_values:
            raise ValueError(
                "Invalid value for `environment` ({0}), must be one of {1}"
                .format(environment, allowed_values)
            )

        self._environment = environment

    @property
    def format(self):
        """Gets the format of this FilterSet.

        Creative format bidded on or allowed to bid on, can be empty.

        :return: The format of this FilterSet.
        :rtype: str
        """
        return self._format

    @format.setter
    def format(self, format):
        """Sets the format of this FilterSet.

        Creative format bidded on or allowed to bid on, can be empty.

        :param format: The format of this FilterSet.
        :type format: str
        """
        allowed_values = ["FORMAT_UNSPECIFIED", "NATIVE_DISPLAY", "NATIVE_VIDEO", "NON_NATIVE_DISPLAY", "NON_NATIVE_VIDEO"]  # noqa: E501
        if format not in allowed_values:
            raise ValueError(
                "Invalid value for `format` ({0}), must be one of {1}"
                .format(format, allowed_values)
            )

        self._format = format

    @property
    def formats(self):
        """Gets the formats of this FilterSet.

        Creative formats bidded on or allowed to bid on, can be empty. Although this field is a list, it can only be populated with a single item. A HTTP 400 bad request error will be returned in the response if you specify multiple items.

        :return: The formats of this FilterSet.
        :rtype: List[str]
        """
        return self._formats

    @formats.setter
    def formats(self, formats):
        """Sets the formats of this FilterSet.

        Creative formats bidded on or allowed to bid on, can be empty. Although this field is a list, it can only be populated with a single item. A HTTP 400 bad request error will be returned in the response if you specify multiple items.

        :param formats: The formats of this FilterSet.
        :type formats: List[str]
        """
        allowed_values = ["FORMAT_UNSPECIFIED", "NATIVE_DISPLAY", "NATIVE_VIDEO", "NON_NATIVE_DISPLAY", "NON_NATIVE_VIDEO"]  # noqa: E501
        if not set(formats).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `formats` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(formats) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._formats = formats

    @property
    def name(self):
        """Gets the name of this FilterSet.

        A user-defined name of the filter set. Filter set names must be unique globally and match one of the patterns: - `bidders/*/filterSets/*` (for accessing bidder-level troubleshooting data) - `bidders/*/accounts/*/filterSets/*` (for accessing account-level troubleshooting data) This field is required in create operations.

        :return: The name of this FilterSet.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this FilterSet.

        A user-defined name of the filter set. Filter set names must be unique globally and match one of the patterns: - `bidders/*/filterSets/*` (for accessing bidder-level troubleshooting data) - `bidders/*/accounts/*/filterSets/*` (for accessing account-level troubleshooting data) This field is required in create operations.

        :param name: The name of this FilterSet.
        :type name: str
        """

        self._name = name

    @property
    def platforms(self):
        """Gets the platforms of this FilterSet.

        The list of platforms on which to filter; may be empty. The filters represented by multiple platforms are ORed together (for example, if non-empty, results must match any one of the platforms).

        :return: The platforms of this FilterSet.
        :rtype: List[str]
        """
        return self._platforms

    @platforms.setter
    def platforms(self, platforms):
        """Sets the platforms of this FilterSet.

        The list of platforms on which to filter; may be empty. The filters represented by multiple platforms are ORed together (for example, if non-empty, results must match any one of the platforms).

        :param platforms: The platforms of this FilterSet.
        :type platforms: List[str]
        """
        allowed_values = ["PLATFORM_UNSPECIFIED", "DESKTOP", "TABLET", "MOBILE"]  # noqa: E501
        if not set(platforms).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `platforms` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(platforms) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._platforms = platforms

    @property
    def publisher_identifiers(self):
        """Gets the publisher_identifiers of this FilterSet.

        For Open Bidding partners only. The list of publisher identifiers on which to filter; may be empty. The filters represented by multiple publisher identifiers are ORed together.

        :return: The publisher_identifiers of this FilterSet.
        :rtype: List[str]
        """
        return self._publisher_identifiers

    @publisher_identifiers.setter
    def publisher_identifiers(self, publisher_identifiers):
        """Sets the publisher_identifiers of this FilterSet.

        For Open Bidding partners only. The list of publisher identifiers on which to filter; may be empty. The filters represented by multiple publisher identifiers are ORed together.

        :param publisher_identifiers: The publisher_identifiers of this FilterSet.
        :type publisher_identifiers: List[str]
        """

        self._publisher_identifiers = publisher_identifiers

    @property
    def realtime_time_range(self):
        """Gets the realtime_time_range of this FilterSet.


        :return: The realtime_time_range of this FilterSet.
        :rtype: RealtimeTimeRange
        """
        return self._realtime_time_range

    @realtime_time_range.setter
    def realtime_time_range(self, realtime_time_range):
        """Sets the realtime_time_range of this FilterSet.


        :param realtime_time_range: The realtime_time_range of this FilterSet.
        :type realtime_time_range: RealtimeTimeRange
        """

        self._realtime_time_range = realtime_time_range

    @property
    def relative_date_range(self):
        """Gets the relative_date_range of this FilterSet.


        :return: The relative_date_range of this FilterSet.
        :rtype: RelativeDateRange
        """
        return self._relative_date_range

    @relative_date_range.setter
    def relative_date_range(self, relative_date_range):
        """Sets the relative_date_range of this FilterSet.


        :param relative_date_range: The relative_date_range of this FilterSet.
        :type relative_date_range: RelativeDateRange
        """

        self._relative_date_range = relative_date_range

    @property
    def seller_network_ids(self):
        """Gets the seller_network_ids of this FilterSet.

        For Authorized Buyers only. The list of IDs of the seller (publisher) networks on which to filter; may be empty. The filters represented by multiple seller network IDs are ORed together (for example, if non-empty, results must match any one of the publisher networks). See [seller-network-ids](https://developers.google.com/authorized-buyers/rtb/downloads/seller-network-ids) file for the set of existing seller network IDs.

        :return: The seller_network_ids of this FilterSet.
        :rtype: List[int]
        """
        return self._seller_network_ids

    @seller_network_ids.setter
    def seller_network_ids(self, seller_network_ids):
        """Sets the seller_network_ids of this FilterSet.

        For Authorized Buyers only. The list of IDs of the seller (publisher) networks on which to filter; may be empty. The filters represented by multiple seller network IDs are ORed together (for example, if non-empty, results must match any one of the publisher networks). See [seller-network-ids](https://developers.google.com/authorized-buyers/rtb/downloads/seller-network-ids) file for the set of existing seller network IDs.

        :param seller_network_ids: The seller_network_ids of this FilterSet.
        :type seller_network_ids: List[int]
        """

        self._seller_network_ids = seller_network_ids

    @property
    def time_series_granularity(self):
        """Gets the time_series_granularity of this FilterSet.

        The granularity of time intervals if a time series breakdown is preferred; optional.

        :return: The time_series_granularity of this FilterSet.
        :rtype: str
        """
        return self._time_series_granularity

    @time_series_granularity.setter
    def time_series_granularity(self, time_series_granularity):
        """Sets the time_series_granularity of this FilterSet.

        The granularity of time intervals if a time series breakdown is preferred; optional.

        :param time_series_granularity: The time_series_granularity of this FilterSet.
        :type time_series_granularity: str
        """
        allowed_values = ["TIME_SERIES_GRANULARITY_UNSPECIFIED", "HOURLY", "DAILY"]  # noqa: E501
        if time_series_granularity not in allowed_values:
            raise ValueError(
                "Invalid value for `time_series_granularity` ({0}), must be one of {1}"
                .format(time_series_granularity, allowed_values)
            )

        self._time_series_granularity = time_series_granularity
