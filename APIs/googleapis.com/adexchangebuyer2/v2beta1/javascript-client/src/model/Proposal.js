/**
 * Ad Exchange Buyer API II
 * Accesses the latest features for managing Authorized Buyers accounts, Real-Time Bidding configurations and auction metrics, and Marketplace programmatic deals.
 *
 * The version of the OpenAPI document: v2beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Buyer from './Buyer';
import ContactInformation from './ContactInformation';
import Deal from './Deal';
import Note from './Note';
import PrivateData from './PrivateData';
import Seller from './Seller';

/**
 * The Proposal model module.
 * @module model/Proposal
 * @version v2beta1
 */
class Proposal {
    /**
     * Constructs a new <code>Proposal</code>.
     * Represents a proposal in the Marketplace. A proposal is the unit of negotiation between a seller and a buyer and contains deals which are served. Note: You can&#39;t update, create, or otherwise modify Private Auction deals through the API. Fields are updatable unless noted otherwise.
     * @alias module:model/Proposal
     */
    constructor() { 
        
        Proposal.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Proposal</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Proposal} obj Optional instance to populate.
     * @return {module:model/Proposal} The populated <code>Proposal</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Proposal();

            if (data.hasOwnProperty('billedBuyer')) {
                obj['billedBuyer'] = Buyer.constructFromObject(data['billedBuyer']);
            }
            if (data.hasOwnProperty('buyer')) {
                obj['buyer'] = Buyer.constructFromObject(data['buyer']);
            }
            if (data.hasOwnProperty('buyerContacts')) {
                obj['buyerContacts'] = ApiClient.convertToType(data['buyerContacts'], [ContactInformation]);
            }
            if (data.hasOwnProperty('buyerPrivateData')) {
                obj['buyerPrivateData'] = PrivateData.constructFromObject(data['buyerPrivateData']);
            }
            if (data.hasOwnProperty('deals')) {
                obj['deals'] = ApiClient.convertToType(data['deals'], [Deal]);
            }
            if (data.hasOwnProperty('displayName')) {
                obj['displayName'] = ApiClient.convertToType(data['displayName'], 'String');
            }
            if (data.hasOwnProperty('isRenegotiating')) {
                obj['isRenegotiating'] = ApiClient.convertToType(data['isRenegotiating'], 'Boolean');
            }
            if (data.hasOwnProperty('isSetupComplete')) {
                obj['isSetupComplete'] = ApiClient.convertToType(data['isSetupComplete'], 'Boolean');
            }
            if (data.hasOwnProperty('lastUpdaterOrCommentorRole')) {
                obj['lastUpdaterOrCommentorRole'] = ApiClient.convertToType(data['lastUpdaterOrCommentorRole'], 'String');
            }
            if (data.hasOwnProperty('notes')) {
                obj['notes'] = ApiClient.convertToType(data['notes'], [Note]);
            }
            if (data.hasOwnProperty('originatorRole')) {
                obj['originatorRole'] = ApiClient.convertToType(data['originatorRole'], 'String');
            }
            if (data.hasOwnProperty('privateAuctionId')) {
                obj['privateAuctionId'] = ApiClient.convertToType(data['privateAuctionId'], 'String');
            }
            if (data.hasOwnProperty('proposalId')) {
                obj['proposalId'] = ApiClient.convertToType(data['proposalId'], 'String');
            }
            if (data.hasOwnProperty('proposalRevision')) {
                obj['proposalRevision'] = ApiClient.convertToType(data['proposalRevision'], 'String');
            }
            if (data.hasOwnProperty('proposalState')) {
                obj['proposalState'] = ApiClient.convertToType(data['proposalState'], 'String');
            }
            if (data.hasOwnProperty('seller')) {
                obj['seller'] = Seller.constructFromObject(data['seller']);
            }
            if (data.hasOwnProperty('sellerContacts')) {
                obj['sellerContacts'] = ApiClient.convertToType(data['sellerContacts'], [ContactInformation]);
            }
            if (data.hasOwnProperty('termsAndConditions')) {
                obj['termsAndConditions'] = ApiClient.convertToType(data['termsAndConditions'], 'String');
            }
            if (data.hasOwnProperty('updateTime')) {
                obj['updateTime'] = ApiClient.convertToType(data['updateTime'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Proposal</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Proposal</code>.
     */
    static validateJSON(data) {
        // validate the optional field `billedBuyer`
        if (data['billedBuyer']) { // data not null
          Buyer.validateJSON(data['billedBuyer']);
        }
        // validate the optional field `buyer`
        if (data['buyer']) { // data not null
          Buyer.validateJSON(data['buyer']);
        }
        if (data['buyerContacts']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['buyerContacts'])) {
                throw new Error("Expected the field `buyerContacts` to be an array in the JSON data but got " + data['buyerContacts']);
            }
            // validate the optional field `buyerContacts` (array)
            for (const item of data['buyerContacts']) {
                ContactInformation.validateJSON(item);
            };
        }
        // validate the optional field `buyerPrivateData`
        if (data['buyerPrivateData']) { // data not null
          PrivateData.validateJSON(data['buyerPrivateData']);
        }
        if (data['deals']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['deals'])) {
                throw new Error("Expected the field `deals` to be an array in the JSON data but got " + data['deals']);
            }
            // validate the optional field `deals` (array)
            for (const item of data['deals']) {
                Deal.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['displayName'] && !(typeof data['displayName'] === 'string' || data['displayName'] instanceof String)) {
            throw new Error("Expected the field `displayName` to be a primitive type in the JSON string but got " + data['displayName']);
        }
        // ensure the json data is a string
        if (data['lastUpdaterOrCommentorRole'] && !(typeof data['lastUpdaterOrCommentorRole'] === 'string' || data['lastUpdaterOrCommentorRole'] instanceof String)) {
            throw new Error("Expected the field `lastUpdaterOrCommentorRole` to be a primitive type in the JSON string but got " + data['lastUpdaterOrCommentorRole']);
        }
        if (data['notes']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['notes'])) {
                throw new Error("Expected the field `notes` to be an array in the JSON data but got " + data['notes']);
            }
            // validate the optional field `notes` (array)
            for (const item of data['notes']) {
                Note.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['originatorRole'] && !(typeof data['originatorRole'] === 'string' || data['originatorRole'] instanceof String)) {
            throw new Error("Expected the field `originatorRole` to be a primitive type in the JSON string but got " + data['originatorRole']);
        }
        // ensure the json data is a string
        if (data['privateAuctionId'] && !(typeof data['privateAuctionId'] === 'string' || data['privateAuctionId'] instanceof String)) {
            throw new Error("Expected the field `privateAuctionId` to be a primitive type in the JSON string but got " + data['privateAuctionId']);
        }
        // ensure the json data is a string
        if (data['proposalId'] && !(typeof data['proposalId'] === 'string' || data['proposalId'] instanceof String)) {
            throw new Error("Expected the field `proposalId` to be a primitive type in the JSON string but got " + data['proposalId']);
        }
        // ensure the json data is a string
        if (data['proposalRevision'] && !(typeof data['proposalRevision'] === 'string' || data['proposalRevision'] instanceof String)) {
            throw new Error("Expected the field `proposalRevision` to be a primitive type in the JSON string but got " + data['proposalRevision']);
        }
        // ensure the json data is a string
        if (data['proposalState'] && !(typeof data['proposalState'] === 'string' || data['proposalState'] instanceof String)) {
            throw new Error("Expected the field `proposalState` to be a primitive type in the JSON string but got " + data['proposalState']);
        }
        // validate the optional field `seller`
        if (data['seller']) { // data not null
          Seller.validateJSON(data['seller']);
        }
        if (data['sellerContacts']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['sellerContacts'])) {
                throw new Error("Expected the field `sellerContacts` to be an array in the JSON data but got " + data['sellerContacts']);
            }
            // validate the optional field `sellerContacts` (array)
            for (const item of data['sellerContacts']) {
                ContactInformation.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['termsAndConditions'] && !(typeof data['termsAndConditions'] === 'string' || data['termsAndConditions'] instanceof String)) {
            throw new Error("Expected the field `termsAndConditions` to be a primitive type in the JSON string but got " + data['termsAndConditions']);
        }
        // ensure the json data is a string
        if (data['updateTime'] && !(typeof data['updateTime'] === 'string' || data['updateTime'] instanceof String)) {
            throw new Error("Expected the field `updateTime` to be a primitive type in the JSON string but got " + data['updateTime']);
        }

        return true;
    }


}



/**
 * @member {module:model/Buyer} billedBuyer
 */
Proposal.prototype['billedBuyer'] = undefined;

/**
 * @member {module:model/Buyer} buyer
 */
Proposal.prototype['buyer'] = undefined;

/**
 * Contact information for the buyer.
 * @member {Array.<module:model/ContactInformation>} buyerContacts
 */
Proposal.prototype['buyerContacts'] = undefined;

/**
 * @member {module:model/PrivateData} buyerPrivateData
 */
Proposal.prototype['buyerPrivateData'] = undefined;

/**
 * The deals associated with this proposal. For Private Auction proposals (whose deals have NonGuaranteedAuctionTerms), there will only be one deal.
 * @member {Array.<module:model/Deal>} deals
 */
Proposal.prototype['deals'] = undefined;

/**
 * The name for the proposal.
 * @member {String} displayName
 */
Proposal.prototype['displayName'] = undefined;

/**
 * Output only. True if the proposal is being renegotiated.
 * @member {Boolean} isRenegotiating
 */
Proposal.prototype['isRenegotiating'] = undefined;

/**
 * Output only. True, if the buyside inventory setup is complete for this proposal.
 * @member {Boolean} isSetupComplete
 */
Proposal.prototype['isSetupComplete'] = undefined;

/**
 * Output only. The role of the last user that either updated the proposal or left a comment.
 * @member {module:model/Proposal.LastUpdaterOrCommentorRoleEnum} lastUpdaterOrCommentorRole
 */
Proposal.prototype['lastUpdaterOrCommentorRole'] = undefined;

/**
 * Output only. The notes associated with this proposal.
 * @member {Array.<module:model/Note>} notes
 */
Proposal.prototype['notes'] = undefined;

/**
 * Output only. Indicates whether the buyer/seller created the proposal.
 * @member {module:model/Proposal.OriginatorRoleEnum} originatorRole
 */
Proposal.prototype['originatorRole'] = undefined;

/**
 * Output only. Private auction ID if this proposal is a private auction proposal.
 * @member {String} privateAuctionId
 */
Proposal.prototype['privateAuctionId'] = undefined;

/**
 * Output only. The unique ID of the proposal.
 * @member {String} proposalId
 */
Proposal.prototype['proposalId'] = undefined;

/**
 * Output only. The revision number for the proposal. Each update to the proposal or the deal causes the proposal revision number to auto-increment. The buyer keeps track of the last revision number they know of and pass it in when making an update. If the head revision number on the server has since incremented, then an ABORTED error is returned during the update operation to let the buyer know that a subsequent update was made.
 * @member {String} proposalRevision
 */
Proposal.prototype['proposalRevision'] = undefined;

/**
 * Output only. The current state of the proposal.
 * @member {module:model/Proposal.ProposalStateEnum} proposalState
 */
Proposal.prototype['proposalState'] = undefined;

/**
 * @member {module:model/Seller} seller
 */
Proposal.prototype['seller'] = undefined;

/**
 * Output only. Contact information for the seller.
 * @member {Array.<module:model/ContactInformation>} sellerContacts
 */
Proposal.prototype['sellerContacts'] = undefined;

/**
 * Output only. The terms and conditions set by the publisher for this proposal.
 * @member {String} termsAndConditions
 */
Proposal.prototype['termsAndConditions'] = undefined;

/**
 * Output only. The time when the proposal was last revised.
 * @member {String} updateTime
 */
Proposal.prototype['updateTime'] = undefined;





/**
 * Allowed values for the <code>lastUpdaterOrCommentorRole</code> property.
 * @enum {String}
 * @readonly
 */
Proposal['LastUpdaterOrCommentorRoleEnum'] = {

    /**
     * value: "BUYER_SELLER_ROLE_UNSPECIFIED"
     * @const
     */
    "BUYER_SELLER_ROLE_UNSPECIFIED": "BUYER_SELLER_ROLE_UNSPECIFIED",

    /**
     * value: "BUYER"
     * @const
     */
    "BUYER": "BUYER",

    /**
     * value: "SELLER"
     * @const
     */
    "SELLER": "SELLER"
};


/**
 * Allowed values for the <code>originatorRole</code> property.
 * @enum {String}
 * @readonly
 */
Proposal['OriginatorRoleEnum'] = {

    /**
     * value: "BUYER_SELLER_ROLE_UNSPECIFIED"
     * @const
     */
    "BUYER_SELLER_ROLE_UNSPECIFIED": "BUYER_SELLER_ROLE_UNSPECIFIED",

    /**
     * value: "BUYER"
     * @const
     */
    "BUYER": "BUYER",

    /**
     * value: "SELLER"
     * @const
     */
    "SELLER": "SELLER"
};


/**
 * Allowed values for the <code>proposalState</code> property.
 * @enum {String}
 * @readonly
 */
Proposal['ProposalStateEnum'] = {

    /**
     * value: "PROPOSAL_STATE_UNSPECIFIED"
     * @const
     */
    "PROPOSAL_STATE_UNSPECIFIED": "PROPOSAL_STATE_UNSPECIFIED",

    /**
     * value: "PROPOSED"
     * @const
     */
    "PROPOSED": "PROPOSED",

    /**
     * value: "BUYER_ACCEPTED"
     * @const
     */
    "BUYER_ACCEPTED": "BUYER_ACCEPTED",

    /**
     * value: "SELLER_ACCEPTED"
     * @const
     */
    "SELLER_ACCEPTED": "SELLER_ACCEPTED",

    /**
     * value: "CANCELED"
     * @const
     */
    "CANCELED": "CANCELED",

    /**
     * value: "FINALIZED"
     * @const
     */
    "FINALIZED": "FINALIZED"
};



export default Proposal;

