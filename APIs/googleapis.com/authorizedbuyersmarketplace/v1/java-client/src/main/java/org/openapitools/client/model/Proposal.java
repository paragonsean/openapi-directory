/*
 * Authorized Buyers Marketplace API
 * The Authorized Buyers Marketplace API lets buyers programmatically discover inventory; propose, retrieve and negotiate deals with publishers.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Contact;
import org.openapitools.client.model.Note;
import org.openapitools.client.model.PrivateData;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a proposal in the Marketplace. A proposal is the unit of negotiation between a seller and a buyer.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:31:11.931533-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Proposal {
  public static final String SERIALIZED_NAME_BILLED_BUYER = "billedBuyer";
  @SerializedName(SERIALIZED_NAME_BILLED_BUYER)
  private String billedBuyer;

  public static final String SERIALIZED_NAME_BUYER = "buyer";
  @SerializedName(SERIALIZED_NAME_BUYER)
  private String buyer;

  public static final String SERIALIZED_NAME_BUYER_CONTACTS = "buyerContacts";
  @SerializedName(SERIALIZED_NAME_BUYER_CONTACTS)
  private List<Contact> buyerContacts = new ArrayList<>();

  public static final String SERIALIZED_NAME_BUYER_PRIVATE_DATA = "buyerPrivateData";
  @SerializedName(SERIALIZED_NAME_BUYER_PRIVATE_DATA)
  private PrivateData buyerPrivateData;

  public static final String SERIALIZED_NAME_CLIENT = "client";
  @SerializedName(SERIALIZED_NAME_CLIENT)
  private String client;

  /**
   * Output only. Type of deal the proposal contains.
   */
  @JsonAdapter(DealTypeEnum.Adapter.class)
  public enum DealTypeEnum {
    DEAL_TYPE_UNSPECIFIED("DEAL_TYPE_UNSPECIFIED"),
    
    PREFERRED_DEAL("PREFERRED_DEAL"),
    
    PRIVATE_AUCTION("PRIVATE_AUCTION"),
    
    PROGRAMMATIC_GUARANTEED("PROGRAMMATIC_GUARANTEED");

    private String value;

    DealTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DealTypeEnum fromValue(String value) {
      for (DealTypeEnum b : DealTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DealTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DealTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DealTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DealTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DealTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEAL_TYPE = "dealType";
  @SerializedName(SERIALIZED_NAME_DEAL_TYPE)
  private DealTypeEnum dealType;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_IS_RENEGOTIATING = "isRenegotiating";
  @SerializedName(SERIALIZED_NAME_IS_RENEGOTIATING)
  private Boolean isRenegotiating;

  /**
   * Output only. The role of the last user that either updated the proposal or left a comment.
   */
  @JsonAdapter(LastUpdaterOrCommentorRoleEnum.Adapter.class)
  public enum LastUpdaterOrCommentorRoleEnum {
    BUYER_SELLER_ROLE_UNSPECIFIED("BUYER_SELLER_ROLE_UNSPECIFIED"),
    
    BUYER("BUYER"),
    
    SELLER("SELLER");

    private String value;

    LastUpdaterOrCommentorRoleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LastUpdaterOrCommentorRoleEnum fromValue(String value) {
      for (LastUpdaterOrCommentorRoleEnum b : LastUpdaterOrCommentorRoleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LastUpdaterOrCommentorRoleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LastUpdaterOrCommentorRoleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LastUpdaterOrCommentorRoleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LastUpdaterOrCommentorRoleEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LastUpdaterOrCommentorRoleEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LAST_UPDATER_OR_COMMENTOR_ROLE = "lastUpdaterOrCommentorRole";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATER_OR_COMMENTOR_ROLE)
  private LastUpdaterOrCommentorRoleEnum lastUpdaterOrCommentorRole;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NOTES = "notes";
  @SerializedName(SERIALIZED_NAME_NOTES)
  private List<Note> notes = new ArrayList<>();

  /**
   * Output only. Indicates whether the buyer/seller created the proposal.
   */
  @JsonAdapter(OriginatorRoleEnum.Adapter.class)
  public enum OriginatorRoleEnum {
    BUYER_SELLER_ROLE_UNSPECIFIED("BUYER_SELLER_ROLE_UNSPECIFIED"),
    
    BUYER("BUYER"),
    
    SELLER("SELLER");

    private String value;

    OriginatorRoleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OriginatorRoleEnum fromValue(String value) {
      for (OriginatorRoleEnum b : OriginatorRoleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OriginatorRoleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OriginatorRoleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OriginatorRoleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OriginatorRoleEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OriginatorRoleEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ORIGINATOR_ROLE = "originatorRole";
  @SerializedName(SERIALIZED_NAME_ORIGINATOR_ROLE)
  private OriginatorRoleEnum originatorRole;

  public static final String SERIALIZED_NAME_PAUSING_CONSENTED = "pausingConsented";
  @SerializedName(SERIALIZED_NAME_PAUSING_CONSENTED)
  private Boolean pausingConsented;

  public static final String SERIALIZED_NAME_PROPOSAL_REVISION = "proposalRevision";
  @SerializedName(SERIALIZED_NAME_PROPOSAL_REVISION)
  private String proposalRevision;

  public static final String SERIALIZED_NAME_PUBLISHER_PROFILE = "publisherProfile";
  @SerializedName(SERIALIZED_NAME_PUBLISHER_PROFILE)
  private String publisherProfile;

  public static final String SERIALIZED_NAME_SELLER_CONTACTS = "sellerContacts";
  @SerializedName(SERIALIZED_NAME_SELLER_CONTACTS)
  private List<Contact> sellerContacts = new ArrayList<>();

  /**
   * Output only. Indicates the state of the proposal.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    BUYER_REVIEW_REQUESTED("BUYER_REVIEW_REQUESTED"),
    
    SELLER_REVIEW_REQUESTED("SELLER_REVIEW_REQUESTED"),
    
    BUYER_ACCEPTANCE_REQUESTED("BUYER_ACCEPTANCE_REQUESTED"),
    
    FINALIZED("FINALIZED"),
    
    TERMINATED("TERMINATED");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_TERMS_AND_CONDITIONS = "termsAndConditions";
  @SerializedName(SERIALIZED_NAME_TERMS_AND_CONDITIONS)
  private String termsAndConditions;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Proposal() {
  }

  public Proposal(
     String billedBuyer, 
     String buyer, 
     String client, 
     DealTypeEnum dealType, 
     String displayName, 
     Boolean isRenegotiating, 
     LastUpdaterOrCommentorRoleEnum lastUpdaterOrCommentorRole, 
     OriginatorRoleEnum originatorRole, 
     String proposalRevision, 
     List<Contact> sellerContacts, 
     StateEnum state, 
     String termsAndConditions, 
     String updateTime
  ) {
    this();
    this.billedBuyer = billedBuyer;
    this.buyer = buyer;
    this.client = client;
    this.dealType = dealType;
    this.displayName = displayName;
    this.isRenegotiating = isRenegotiating;
    this.lastUpdaterOrCommentorRole = lastUpdaterOrCommentorRole;
    this.originatorRole = originatorRole;
    this.proposalRevision = proposalRevision;
    this.sellerContacts = sellerContacts;
    this.state = state;
    this.termsAndConditions = termsAndConditions;
    this.updateTime = updateTime;
  }

  /**
   * Output only. When the client field is populated, this field refers to the buyer who creates and manages the client buyer and gets billed on behalf of the client buyer; when the buyer field is populated, this field is the same value as buyer. Format : &#x60;buyers/{buyerAccountId}&#x60;
   * @return billedBuyer
   */
  @javax.annotation.Nullable
  public String getBilledBuyer() {
    return billedBuyer;
  }



  /**
   * Output only. Refers to a buyer in The Realtime-bidding API. Format: &#x60;buyers/{buyerAccountId}&#x60;
   * @return buyer
   */
  @javax.annotation.Nullable
  public String getBuyer() {
    return buyer;
  }



  public Proposal buyerContacts(List<Contact> buyerContacts) {
    this.buyerContacts = buyerContacts;
    return this;
  }

  public Proposal addBuyerContactsItem(Contact buyerContactsItem) {
    if (this.buyerContacts == null) {
      this.buyerContacts = new ArrayList<>();
    }
    this.buyerContacts.add(buyerContactsItem);
    return this;
  }

  /**
   * Contact information for the buyer.
   * @return buyerContacts
   */
  @javax.annotation.Nullable
  public List<Contact> getBuyerContacts() {
    return buyerContacts;
  }

  public void setBuyerContacts(List<Contact> buyerContacts) {
    this.buyerContacts = buyerContacts;
  }


  public Proposal buyerPrivateData(PrivateData buyerPrivateData) {
    this.buyerPrivateData = buyerPrivateData;
    return this;
  }

  /**
   * Get buyerPrivateData
   * @return buyerPrivateData
   */
  @javax.annotation.Nullable
  public PrivateData getBuyerPrivateData() {
    return buyerPrivateData;
  }

  public void setBuyerPrivateData(PrivateData buyerPrivateData) {
    this.buyerPrivateData = buyerPrivateData;
  }


  /**
   * Output only. Refers to a Client. Format: &#x60;buyers/{buyerAccountId}/clients/{clientAccountid}&#x60;
   * @return client
   */
  @javax.annotation.Nullable
  public String getClient() {
    return client;
  }



  /**
   * Output only. Type of deal the proposal contains.
   * @return dealType
   */
  @javax.annotation.Nullable
  public DealTypeEnum getDealType() {
    return dealType;
  }



  /**
   * Output only. The descriptive name for the proposal. Maximum length of 255 unicode characters is allowed. Control characters are not allowed. Buyers cannot update this field. Note: Not to be confused with name, which is a unique identifier of the proposal.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }



  /**
   * Output only. True if the proposal was previously finalized and is now being renegotiated.
   * @return isRenegotiating
   */
  @javax.annotation.Nullable
  public Boolean getIsRenegotiating() {
    return isRenegotiating;
  }



  /**
   * Output only. The role of the last user that either updated the proposal or left a comment.
   * @return lastUpdaterOrCommentorRole
   */
  @javax.annotation.Nullable
  public LastUpdaterOrCommentorRoleEnum getLastUpdaterOrCommentorRole() {
    return lastUpdaterOrCommentorRole;
  }



  public Proposal name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Immutable. The name of the proposal serving as a unique identifier. Format: buyers/{accountId}/proposals/{proposalId}
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Proposal notes(List<Note> notes) {
    this.notes = notes;
    return this;
  }

  public Proposal addNotesItem(Note notesItem) {
    if (this.notes == null) {
      this.notes = new ArrayList<>();
    }
    this.notes.add(notesItem);
    return this;
  }

  /**
   * A list of notes from the buyer and the seller attached to this proposal.
   * @return notes
   */
  @javax.annotation.Nullable
  public List<Note> getNotes() {
    return notes;
  }

  public void setNotes(List<Note> notes) {
    this.notes = notes;
  }


  /**
   * Output only. Indicates whether the buyer/seller created the proposal.
   * @return originatorRole
   */
  @javax.annotation.Nullable
  public OriginatorRoleEnum getOriginatorRole() {
    return originatorRole;
  }



  public Proposal pausingConsented(Boolean pausingConsented) {
    this.pausingConsented = pausingConsented;
    return this;
  }

  /**
   * Whether pausing is allowed for the proposal. This is a negotiable term between buyers and publishers.
   * @return pausingConsented
   */
  @javax.annotation.Nullable
  public Boolean getPausingConsented() {
    return pausingConsented;
  }

  public void setPausingConsented(Boolean pausingConsented) {
    this.pausingConsented = pausingConsented;
  }


  /**
   * Output only. The revision number for the proposal. Each update to the proposal or deal causes the proposal revision number to auto-increment. The buyer keeps track of the last revision number they know of and pass it in when making an update. If the head revision number on the server has since incremented, then an ABORTED error is returned during the update operation to let the buyer know that a subsequent update was made.
   * @return proposalRevision
   */
  @javax.annotation.Nullable
  public String getProposalRevision() {
    return proposalRevision;
  }



  public Proposal publisherProfile(String publisherProfile) {
    this.publisherProfile = publisherProfile;
    return this;
  }

  /**
   * Immutable. Reference to the seller on the proposal. Format: &#x60;buyers/{buyerAccountId}/publisherProfiles/{publisherProfileId}&#x60; Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.
   * @return publisherProfile
   */
  @javax.annotation.Nullable
  public String getPublisherProfile() {
    return publisherProfile;
  }

  public void setPublisherProfile(String publisherProfile) {
    this.publisherProfile = publisherProfile;
  }


  /**
   * Output only. Contact information for the seller.
   * @return sellerContacts
   */
  @javax.annotation.Nullable
  public List<Contact> getSellerContacts() {
    return sellerContacts;
  }



  /**
   * Output only. Indicates the state of the proposal.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  /**
   * Output only. The terms and conditions associated with this proposal. Accepting a proposal implies acceptance of this field. This is created by the seller, the buyer can only view it.
   * @return termsAndConditions
   */
  @javax.annotation.Nullable
  public String getTermsAndConditions() {
    return termsAndConditions;
  }



  /**
   * Output only. The time when the proposal was last revised.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Proposal proposal = (Proposal) o;
    return Objects.equals(this.billedBuyer, proposal.billedBuyer) &&
        Objects.equals(this.buyer, proposal.buyer) &&
        Objects.equals(this.buyerContacts, proposal.buyerContacts) &&
        Objects.equals(this.buyerPrivateData, proposal.buyerPrivateData) &&
        Objects.equals(this.client, proposal.client) &&
        Objects.equals(this.dealType, proposal.dealType) &&
        Objects.equals(this.displayName, proposal.displayName) &&
        Objects.equals(this.isRenegotiating, proposal.isRenegotiating) &&
        Objects.equals(this.lastUpdaterOrCommentorRole, proposal.lastUpdaterOrCommentorRole) &&
        Objects.equals(this.name, proposal.name) &&
        Objects.equals(this.notes, proposal.notes) &&
        Objects.equals(this.originatorRole, proposal.originatorRole) &&
        Objects.equals(this.pausingConsented, proposal.pausingConsented) &&
        Objects.equals(this.proposalRevision, proposal.proposalRevision) &&
        Objects.equals(this.publisherProfile, proposal.publisherProfile) &&
        Objects.equals(this.sellerContacts, proposal.sellerContacts) &&
        Objects.equals(this.state, proposal.state) &&
        Objects.equals(this.termsAndConditions, proposal.termsAndConditions) &&
        Objects.equals(this.updateTime, proposal.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(billedBuyer, buyer, buyerContacts, buyerPrivateData, client, dealType, displayName, isRenegotiating, lastUpdaterOrCommentorRole, name, notes, originatorRole, pausingConsented, proposalRevision, publisherProfile, sellerContacts, state, termsAndConditions, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Proposal {\n");
    sb.append("    billedBuyer: ").append(toIndentedString(billedBuyer)).append("\n");
    sb.append("    buyer: ").append(toIndentedString(buyer)).append("\n");
    sb.append("    buyerContacts: ").append(toIndentedString(buyerContacts)).append("\n");
    sb.append("    buyerPrivateData: ").append(toIndentedString(buyerPrivateData)).append("\n");
    sb.append("    client: ").append(toIndentedString(client)).append("\n");
    sb.append("    dealType: ").append(toIndentedString(dealType)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    isRenegotiating: ").append(toIndentedString(isRenegotiating)).append("\n");
    sb.append("    lastUpdaterOrCommentorRole: ").append(toIndentedString(lastUpdaterOrCommentorRole)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notes: ").append(toIndentedString(notes)).append("\n");
    sb.append("    originatorRole: ").append(toIndentedString(originatorRole)).append("\n");
    sb.append("    pausingConsented: ").append(toIndentedString(pausingConsented)).append("\n");
    sb.append("    proposalRevision: ").append(toIndentedString(proposalRevision)).append("\n");
    sb.append("    publisherProfile: ").append(toIndentedString(publisherProfile)).append("\n");
    sb.append("    sellerContacts: ").append(toIndentedString(sellerContacts)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    termsAndConditions: ").append(toIndentedString(termsAndConditions)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("billedBuyer");
    openapiFields.add("buyer");
    openapiFields.add("buyerContacts");
    openapiFields.add("buyerPrivateData");
    openapiFields.add("client");
    openapiFields.add("dealType");
    openapiFields.add("displayName");
    openapiFields.add("isRenegotiating");
    openapiFields.add("lastUpdaterOrCommentorRole");
    openapiFields.add("name");
    openapiFields.add("notes");
    openapiFields.add("originatorRole");
    openapiFields.add("pausingConsented");
    openapiFields.add("proposalRevision");
    openapiFields.add("publisherProfile");
    openapiFields.add("sellerContacts");
    openapiFields.add("state");
    openapiFields.add("termsAndConditions");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Proposal
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Proposal.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Proposal is not found in the empty JSON string", Proposal.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Proposal.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Proposal` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("billedBuyer") != null && !jsonObj.get("billedBuyer").isJsonNull()) && !jsonObj.get("billedBuyer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billedBuyer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billedBuyer").toString()));
      }
      if ((jsonObj.get("buyer") != null && !jsonObj.get("buyer").isJsonNull()) && !jsonObj.get("buyer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buyer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buyer").toString()));
      }
      if (jsonObj.get("buyerContacts") != null && !jsonObj.get("buyerContacts").isJsonNull()) {
        JsonArray jsonArraybuyerContacts = jsonObj.getAsJsonArray("buyerContacts");
        if (jsonArraybuyerContacts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("buyerContacts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `buyerContacts` to be an array in the JSON string but got `%s`", jsonObj.get("buyerContacts").toString()));
          }

          // validate the optional field `buyerContacts` (array)
          for (int i = 0; i < jsonArraybuyerContacts.size(); i++) {
            Contact.validateJsonElement(jsonArraybuyerContacts.get(i));
          };
        }
      }
      // validate the optional field `buyerPrivateData`
      if (jsonObj.get("buyerPrivateData") != null && !jsonObj.get("buyerPrivateData").isJsonNull()) {
        PrivateData.validateJsonElement(jsonObj.get("buyerPrivateData"));
      }
      if ((jsonObj.get("client") != null && !jsonObj.get("client").isJsonNull()) && !jsonObj.get("client").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client").toString()));
      }
      if ((jsonObj.get("dealType") != null && !jsonObj.get("dealType").isJsonNull()) && !jsonObj.get("dealType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dealType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dealType").toString()));
      }
      // validate the optional field `dealType`
      if (jsonObj.get("dealType") != null && !jsonObj.get("dealType").isJsonNull()) {
        DealTypeEnum.validateJsonElement(jsonObj.get("dealType"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("lastUpdaterOrCommentorRole") != null && !jsonObj.get("lastUpdaterOrCommentorRole").isJsonNull()) && !jsonObj.get("lastUpdaterOrCommentorRole").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdaterOrCommentorRole` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdaterOrCommentorRole").toString()));
      }
      // validate the optional field `lastUpdaterOrCommentorRole`
      if (jsonObj.get("lastUpdaterOrCommentorRole") != null && !jsonObj.get("lastUpdaterOrCommentorRole").isJsonNull()) {
        LastUpdaterOrCommentorRoleEnum.validateJsonElement(jsonObj.get("lastUpdaterOrCommentorRole"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("notes") != null && !jsonObj.get("notes").isJsonNull()) {
        JsonArray jsonArraynotes = jsonObj.getAsJsonArray("notes");
        if (jsonArraynotes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("notes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `notes` to be an array in the JSON string but got `%s`", jsonObj.get("notes").toString()));
          }

          // validate the optional field `notes` (array)
          for (int i = 0; i < jsonArraynotes.size(); i++) {
            Note.validateJsonElement(jsonArraynotes.get(i));
          };
        }
      }
      if ((jsonObj.get("originatorRole") != null && !jsonObj.get("originatorRole").isJsonNull()) && !jsonObj.get("originatorRole").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originatorRole` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originatorRole").toString()));
      }
      // validate the optional field `originatorRole`
      if (jsonObj.get("originatorRole") != null && !jsonObj.get("originatorRole").isJsonNull()) {
        OriginatorRoleEnum.validateJsonElement(jsonObj.get("originatorRole"));
      }
      if ((jsonObj.get("proposalRevision") != null && !jsonObj.get("proposalRevision").isJsonNull()) && !jsonObj.get("proposalRevision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `proposalRevision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("proposalRevision").toString()));
      }
      if ((jsonObj.get("publisherProfile") != null && !jsonObj.get("publisherProfile").isJsonNull()) && !jsonObj.get("publisherProfile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publisherProfile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publisherProfile").toString()));
      }
      if (jsonObj.get("sellerContacts") != null && !jsonObj.get("sellerContacts").isJsonNull()) {
        JsonArray jsonArraysellerContacts = jsonObj.getAsJsonArray("sellerContacts");
        if (jsonArraysellerContacts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sellerContacts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sellerContacts` to be an array in the JSON string but got `%s`", jsonObj.get("sellerContacts").toString()));
          }

          // validate the optional field `sellerContacts` (array)
          for (int i = 0; i < jsonArraysellerContacts.size(); i++) {
            Contact.validateJsonElement(jsonArraysellerContacts.get(i));
          };
        }
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("termsAndConditions") != null && !jsonObj.get("termsAndConditions").isJsonNull()) && !jsonObj.get("termsAndConditions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `termsAndConditions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("termsAndConditions").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Proposal.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Proposal' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Proposal> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Proposal.class));

       return (TypeAdapter<T>) new TypeAdapter<Proposal>() {
           @Override
           public void write(JsonWriter out, Proposal value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Proposal read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Proposal given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Proposal
   * @throws IOException if the JSON string is invalid with respect to Proposal
   */
  public static Proposal fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Proposal.class);
  }

  /**
   * Convert an instance of Proposal to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

