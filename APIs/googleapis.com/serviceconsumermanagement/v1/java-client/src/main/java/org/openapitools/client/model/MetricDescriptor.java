/*
 * Service Consumer Management API
 * Manages the service consumers of a Service Infrastructure service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.LabelDescriptor;
import org.openapitools.client.model.MetricDescriptorMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a metric type and its schema. Once a metric descriptor is created, deleting or altering it stops data collection and makes the metric type&#39;s existing data unusable. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:19.968058-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MetricDescriptor {
  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private List<LabelDescriptor> labels = new ArrayList<>();

  /**
   * Optional. The launch stage of the metric definition.
   */
  @JsonAdapter(LaunchStageEnum.Adapter.class)
  public enum LaunchStageEnum {
    LAUNCH_STAGE_UNSPECIFIED("LAUNCH_STAGE_UNSPECIFIED"),
    
    UNIMPLEMENTED("UNIMPLEMENTED"),
    
    PRELAUNCH("PRELAUNCH"),
    
    EARLY_ACCESS("EARLY_ACCESS"),
    
    ALPHA("ALPHA"),
    
    BETA("BETA"),
    
    GA("GA"),
    
    DEPRECATED("DEPRECATED");

    private String value;

    LaunchStageEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LaunchStageEnum fromValue(String value) {
      for (LaunchStageEnum b : LaunchStageEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LaunchStageEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LaunchStageEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LaunchStageEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LaunchStageEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LaunchStageEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LAUNCH_STAGE = "launchStage";
  @SerializedName(SERIALIZED_NAME_LAUNCH_STAGE)
  private LaunchStageEnum launchStage;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private MetricDescriptorMetadata metadata;

  /**
   * Whether the metric records instantaneous values, changes to a value, etc. Some combinations of &#x60;metric_kind&#x60; and &#x60;value_type&#x60; might not be supported.
   */
  @JsonAdapter(MetricKindEnum.Adapter.class)
  public enum MetricKindEnum {
    METRIC_KIND_UNSPECIFIED("METRIC_KIND_UNSPECIFIED"),
    
    GAUGE("GAUGE"),
    
    DELTA("DELTA"),
    
    CUMULATIVE("CUMULATIVE");

    private String value;

    MetricKindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MetricKindEnum fromValue(String value) {
      for (MetricKindEnum b : MetricKindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MetricKindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MetricKindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MetricKindEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MetricKindEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MetricKindEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_METRIC_KIND = "metricKind";
  @SerializedName(SERIALIZED_NAME_METRIC_KIND)
  private MetricKindEnum metricKind;

  public static final String SERIALIZED_NAME_MONITORED_RESOURCE_TYPES = "monitoredResourceTypes";
  @SerializedName(SERIALIZED_NAME_MONITORED_RESOURCE_TYPES)
  private List<String> monitoredResourceTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_UNIT = "unit";
  @SerializedName(SERIALIZED_NAME_UNIT)
  private String unit;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of &#x60;metric_kind&#x60; and &#x60;value_type&#x60; might not be supported.
   */
  @JsonAdapter(ValueTypeEnum.Adapter.class)
  public enum ValueTypeEnum {
    VALUE_TYPE_UNSPECIFIED("VALUE_TYPE_UNSPECIFIED"),
    
    BOOL("BOOL"),
    
    INT64("INT64"),
    
    DOUBLE("DOUBLE"),
    
    STRING("STRING"),
    
    DISTRIBUTION("DISTRIBUTION"),
    
    MONEY("MONEY");

    private String value;

    ValueTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValueTypeEnum fromValue(String value) {
      for (ValueTypeEnum b : ValueTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValueTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValueTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValueTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALUE_TYPE = "valueType";
  @SerializedName(SERIALIZED_NAME_VALUE_TYPE)
  private ValueTypeEnum valueType;

  public MetricDescriptor() {
  }

  public MetricDescriptor description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A detailed description of the metric, which can be used in documentation.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public MetricDescriptor displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example \&quot;Request count\&quot;. This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public MetricDescriptor labels(List<LabelDescriptor> labels) {
    this.labels = labels;
    return this;
  }

  public MetricDescriptor addLabelsItem(LabelDescriptor labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

  /**
   * The set of labels that can be used to describe a specific instance of this metric type. For example, the &#x60;appengine.googleapis.com/http/server/response_latencies&#x60; metric type has a label for the HTTP response code, &#x60;response_code&#x60;, so you can look at latencies for successful responses or just for responses that failed.
   * @return labels
   */
  @javax.annotation.Nullable
  public List<LabelDescriptor> getLabels() {
    return labels;
  }

  public void setLabels(List<LabelDescriptor> labels) {
    this.labels = labels;
  }


  public MetricDescriptor launchStage(LaunchStageEnum launchStage) {
    this.launchStage = launchStage;
    return this;
  }

  /**
   * Optional. The launch stage of the metric definition.
   * @return launchStage
   */
  @javax.annotation.Nullable
  public LaunchStageEnum getLaunchStage() {
    return launchStage;
  }

  public void setLaunchStage(LaunchStageEnum launchStage) {
    this.launchStage = launchStage;
  }


  public MetricDescriptor metadata(MetricDescriptorMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  public MetricDescriptorMetadata getMetadata() {
    return metadata;
  }

  public void setMetadata(MetricDescriptorMetadata metadata) {
    this.metadata = metadata;
  }


  public MetricDescriptor metricKind(MetricKindEnum metricKind) {
    this.metricKind = metricKind;
    return this;
  }

  /**
   * Whether the metric records instantaneous values, changes to a value, etc. Some combinations of &#x60;metric_kind&#x60; and &#x60;value_type&#x60; might not be supported.
   * @return metricKind
   */
  @javax.annotation.Nullable
  public MetricKindEnum getMetricKind() {
    return metricKind;
  }

  public void setMetricKind(MetricKindEnum metricKind) {
    this.metricKind = metricKind;
  }


  public MetricDescriptor monitoredResourceTypes(List<String> monitoredResourceTypes) {
    this.monitoredResourceTypes = monitoredResourceTypes;
    return this;
  }

  public MetricDescriptor addMonitoredResourceTypesItem(String monitoredResourceTypesItem) {
    if (this.monitoredResourceTypes == null) {
      this.monitoredResourceTypes = new ArrayList<>();
    }
    this.monitoredResourceTypes.add(monitoredResourceTypesItem);
    return this;
  }

  /**
   * Read-only. If present, then a time series, which is identified partially by a metric type and a MonitoredResourceDescriptor, that is associated with this metric type can only be associated with one of the monitored resource types listed here.
   * @return monitoredResourceTypes
   */
  @javax.annotation.Nullable
  public List<String> getMonitoredResourceTypes() {
    return monitoredResourceTypes;
  }

  public void setMonitoredResourceTypes(List<String> monitoredResourceTypes) {
    this.monitoredResourceTypes = monitoredResourceTypes;
  }


  public MetricDescriptor name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The resource name of the metric descriptor.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public MetricDescriptor type(String type) {
    this.type = type;
    return this;
  }

  /**
   * The metric type, including its DNS name prefix. The type is not URL-encoded. All user-defined metric types have the DNS name &#x60;custom.googleapis.com&#x60; or &#x60;external.googleapis.com&#x60;. Metric types should use a natural hierarchical grouping. For example: \&quot;custom.googleapis.com/invoice/paid/amount\&quot; \&quot;external.googleapis.com/prometheus/up\&quot; \&quot;appengine.googleapis.com/http/server/response_latencies\&quot;
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  public MetricDescriptor unit(String unit) {
    this.unit = unit;
    return this;
  }

  /**
   * The units in which the metric value is reported. It is only applicable if the &#x60;value_type&#x60; is &#x60;INT64&#x60;, &#x60;DOUBLE&#x60;, or &#x60;DISTRIBUTION&#x60;. The &#x60;unit&#x60; defines the representation of the stored metric values. Different systems might scale the values to be more easily displayed (so a value of &#x60;0.02kBy&#x60; _might_ be displayed as &#x60;20By&#x60;, and a value of &#x60;3523kBy&#x60; _might_ be displayed as &#x60;3.5MBy&#x60;). However, if the &#x60;unit&#x60; is &#x60;kBy&#x60;, then the value of the metric is always in thousands of bytes, no matter how it might be displayed. If you want a custom metric to record the exact number of CPU-seconds used by a job, you can create an &#x60;INT64 CUMULATIVE&#x60; metric whose &#x60;unit&#x60; is &#x60;s{CPU}&#x60; (or equivalently &#x60;1s{CPU}&#x60; or just &#x60;s&#x60;). If the job uses 12,005 CPU-seconds, then the value is written as &#x60;12005&#x60;. Alternatively, if you want a custom metric to record data in a more granular way, you can create a &#x60;DOUBLE CUMULATIVE&#x60; metric whose &#x60;unit&#x60; is &#x60;ks{CPU}&#x60;, and then write the value &#x60;12.005&#x60; (which is &#x60;12005/1000&#x60;), or use &#x60;Kis{CPU}&#x60; and write &#x60;11.723&#x60; (which is &#x60;12005/1024&#x60;). The supported units are a subset of [The Unified Code for Units of Measure](https://unitsofmeasure.org/ucum.html) standard: **Basic units (UNIT)** * &#x60;bit&#x60; bit * &#x60;By&#x60; byte * &#x60;s&#x60; second * &#x60;min&#x60; minute * &#x60;h&#x60; hour * &#x60;d&#x60; day * &#x60;1&#x60; dimensionless **Prefixes (PREFIX)** * &#x60;k&#x60; kilo (10^3) * &#x60;M&#x60; mega (10^6) * &#x60;G&#x60; giga (10^9) * &#x60;T&#x60; tera (10^12) * &#x60;P&#x60; peta (10^15) * &#x60;E&#x60; exa (10^18) * &#x60;Z&#x60; zetta (10^21) * &#x60;Y&#x60; yotta (10^24) * &#x60;m&#x60; milli (10^-3) * &#x60;u&#x60; micro (10^-6) * &#x60;n&#x60; nano (10^-9) * &#x60;p&#x60; pico (10^-12) * &#x60;f&#x60; femto (10^-15) * &#x60;a&#x60; atto (10^-18) * &#x60;z&#x60; zepto (10^-21) * &#x60;y&#x60; yocto (10^-24) * &#x60;Ki&#x60; kibi (2^10) * &#x60;Mi&#x60; mebi (2^20) * &#x60;Gi&#x60; gibi (2^30) * &#x60;Ti&#x60; tebi (2^40) * &#x60;Pi&#x60; pebi (2^50) **Grammar** The grammar also includes these connectors: * &#x60;/&#x60; division or ratio (as an infix operator). For examples, &#x60;kBy/{email}&#x60; or &#x60;MiBy/10ms&#x60; (although you should almost never have &#x60;/s&#x60; in a metric &#x60;unit&#x60;; rates should always be computed at query time from the underlying cumulative or delta value). * &#x60;.&#x60; multiplication or composition (as an infix operator). For examples, &#x60;GBy.d&#x60; or &#x60;k{watt}.h&#x60;. The grammar for a unit is as follows: Expression &#x3D; Component { \&quot;.\&quot; Component } { \&quot;/\&quot; Component } ; Component &#x3D; ( [ PREFIX ] UNIT | \&quot;%\&quot; ) [ Annotation ] | Annotation | \&quot;1\&quot; ; Annotation &#x3D; \&quot;{\&quot; NAME \&quot;}\&quot; ; Notes: * &#x60;Annotation&#x60; is just a comment if it follows a &#x60;UNIT&#x60;. If the annotation is used alone, then the unit is equivalent to &#x60;1&#x60;. For examples, &#x60;{request}/s &#x3D;&#x3D; 1/s&#x60;, &#x60;By{transmitted}/s &#x3D;&#x3D; By/s&#x60;. * &#x60;NAME&#x60; is a sequence of non-blank printable ASCII characters not containing &#x60;{&#x60; or &#x60;}&#x60;. * &#x60;1&#x60; represents a unitary [dimensionless unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such as in &#x60;1/s&#x60;. It is typically used when none of the basic units are appropriate. For example, \&quot;new users per day\&quot; can be represented as &#x60;1/d&#x60; or &#x60;{new-users}/d&#x60; (and a metric value &#x60;5&#x60; would mean \&quot;5 new users). Alternatively, \&quot;thousands of page views per day\&quot; would be represented as &#x60;1000/d&#x60; or &#x60;k1/d&#x60; or &#x60;k{page_views}/d&#x60; (and a metric value of &#x60;5.3&#x60; would mean \&quot;5300 page views per day\&quot;). * &#x60;%&#x60; represents dimensionless value of 1/100, and annotates values giving a percentage (so the metric values are typically in the range of 0..100, and a metric value &#x60;3&#x60; means \&quot;3 percent\&quot;). * &#x60;10^2.%&#x60; indicates a metric contains a ratio, typically in the range 0..1, that will be multiplied by 100 and displayed as a percentage (so a metric value &#x60;0.03&#x60; means \&quot;3 percent\&quot;).
   * @return unit
   */
  @javax.annotation.Nullable
  public String getUnit() {
    return unit;
  }

  public void setUnit(String unit) {
    this.unit = unit;
  }


  public MetricDescriptor valueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
    return this;
  }

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of &#x60;metric_kind&#x60; and &#x60;value_type&#x60; might not be supported.
   * @return valueType
   */
  @javax.annotation.Nullable
  public ValueTypeEnum getValueType() {
    return valueType;
  }

  public void setValueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MetricDescriptor metricDescriptor = (MetricDescriptor) o;
    return Objects.equals(this.description, metricDescriptor.description) &&
        Objects.equals(this.displayName, metricDescriptor.displayName) &&
        Objects.equals(this.labels, metricDescriptor.labels) &&
        Objects.equals(this.launchStage, metricDescriptor.launchStage) &&
        Objects.equals(this.metadata, metricDescriptor.metadata) &&
        Objects.equals(this.metricKind, metricDescriptor.metricKind) &&
        Objects.equals(this.monitoredResourceTypes, metricDescriptor.monitoredResourceTypes) &&
        Objects.equals(this.name, metricDescriptor.name) &&
        Objects.equals(this.type, metricDescriptor.type) &&
        Objects.equals(this.unit, metricDescriptor.unit) &&
        Objects.equals(this.valueType, metricDescriptor.valueType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, displayName, labels, launchStage, metadata, metricKind, monitoredResourceTypes, name, type, unit, valueType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MetricDescriptor {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    launchStage: ").append(toIndentedString(launchStage)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    metricKind: ").append(toIndentedString(metricKind)).append("\n");
    sb.append("    monitoredResourceTypes: ").append(toIndentedString(monitoredResourceTypes)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    unit: ").append(toIndentedString(unit)).append("\n");
    sb.append("    valueType: ").append(toIndentedString(valueType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("description");
    openapiFields.add("displayName");
    openapiFields.add("labels");
    openapiFields.add("launchStage");
    openapiFields.add("metadata");
    openapiFields.add("metricKind");
    openapiFields.add("monitoredResourceTypes");
    openapiFields.add("name");
    openapiFields.add("type");
    openapiFields.add("unit");
    openapiFields.add("valueType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MetricDescriptor
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MetricDescriptor.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MetricDescriptor is not found in the empty JSON string", MetricDescriptor.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MetricDescriptor.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MetricDescriptor` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        JsonArray jsonArraylabels = jsonObj.getAsJsonArray("labels");
        if (jsonArraylabels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("labels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `labels` to be an array in the JSON string but got `%s`", jsonObj.get("labels").toString()));
          }

          // validate the optional field `labels` (array)
          for (int i = 0; i < jsonArraylabels.size(); i++) {
            LabelDescriptor.validateJsonElement(jsonArraylabels.get(i));
          };
        }
      }
      if ((jsonObj.get("launchStage") != null && !jsonObj.get("launchStage").isJsonNull()) && !jsonObj.get("launchStage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `launchStage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("launchStage").toString()));
      }
      // validate the optional field `launchStage`
      if (jsonObj.get("launchStage") != null && !jsonObj.get("launchStage").isJsonNull()) {
        LaunchStageEnum.validateJsonElement(jsonObj.get("launchStage"));
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        MetricDescriptorMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
      if ((jsonObj.get("metricKind") != null && !jsonObj.get("metricKind").isJsonNull()) && !jsonObj.get("metricKind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metricKind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metricKind").toString()));
      }
      // validate the optional field `metricKind`
      if (jsonObj.get("metricKind") != null && !jsonObj.get("metricKind").isJsonNull()) {
        MetricKindEnum.validateJsonElement(jsonObj.get("metricKind"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("monitoredResourceTypes") != null && !jsonObj.get("monitoredResourceTypes").isJsonNull() && !jsonObj.get("monitoredResourceTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitoredResourceTypes` to be an array in the JSON string but got `%s`", jsonObj.get("monitoredResourceTypes").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("unit") != null && !jsonObj.get("unit").isJsonNull()) && !jsonObj.get("unit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unit").toString()));
      }
      if ((jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) && !jsonObj.get("valueType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valueType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valueType").toString()));
      }
      // validate the optional field `valueType`
      if (jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) {
        ValueTypeEnum.validateJsonElement(jsonObj.get("valueType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MetricDescriptor.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MetricDescriptor' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MetricDescriptor> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MetricDescriptor.class));

       return (TypeAdapter<T>) new TypeAdapter<MetricDescriptor>() {
           @Override
           public void write(JsonWriter out, MetricDescriptor value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MetricDescriptor read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MetricDescriptor given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MetricDescriptor
   * @throws IOException if the JSON string is invalid with respect to MetricDescriptor
   */
  public static MetricDescriptor fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MetricDescriptor.class);
  }

  /**
   * Convert an instance of MetricDescriptor to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

