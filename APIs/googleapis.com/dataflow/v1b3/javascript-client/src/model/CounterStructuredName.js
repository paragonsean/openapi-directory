/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The CounterStructuredName model module.
 * @module model/CounterStructuredName
 * @version v1b3
 */
class CounterStructuredName {
    /**
     * Constructs a new <code>CounterStructuredName</code>.
     * Identifies a counter within a per-job namespace. Counters whose structured names are the same get merged into a single value for the job.
     * @alias module:model/CounterStructuredName
     */
    constructor() { 
        
        CounterStructuredName.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>CounterStructuredName</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/CounterStructuredName} obj Optional instance to populate.
     * @return {module:model/CounterStructuredName} The populated <code>CounterStructuredName</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new CounterStructuredName();

            if (data.hasOwnProperty('componentStepName')) {
                obj['componentStepName'] = ApiClient.convertToType(data['componentStepName'], 'String');
            }
            if (data.hasOwnProperty('executionStepName')) {
                obj['executionStepName'] = ApiClient.convertToType(data['executionStepName'], 'String');
            }
            if (data.hasOwnProperty('inputIndex')) {
                obj['inputIndex'] = ApiClient.convertToType(data['inputIndex'], 'Number');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('origin')) {
                obj['origin'] = ApiClient.convertToType(data['origin'], 'String');
            }
            if (data.hasOwnProperty('originNamespace')) {
                obj['originNamespace'] = ApiClient.convertToType(data['originNamespace'], 'String');
            }
            if (data.hasOwnProperty('originalRequestingStepName')) {
                obj['originalRequestingStepName'] = ApiClient.convertToType(data['originalRequestingStepName'], 'String');
            }
            if (data.hasOwnProperty('originalStepName')) {
                obj['originalStepName'] = ApiClient.convertToType(data['originalStepName'], 'String');
            }
            if (data.hasOwnProperty('portion')) {
                obj['portion'] = ApiClient.convertToType(data['portion'], 'String');
            }
            if (data.hasOwnProperty('workerId')) {
                obj['workerId'] = ApiClient.convertToType(data['workerId'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>CounterStructuredName</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>CounterStructuredName</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['componentStepName'] && !(typeof data['componentStepName'] === 'string' || data['componentStepName'] instanceof String)) {
            throw new Error("Expected the field `componentStepName` to be a primitive type in the JSON string but got " + data['componentStepName']);
        }
        // ensure the json data is a string
        if (data['executionStepName'] && !(typeof data['executionStepName'] === 'string' || data['executionStepName'] instanceof String)) {
            throw new Error("Expected the field `executionStepName` to be a primitive type in the JSON string but got " + data['executionStepName']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['origin'] && !(typeof data['origin'] === 'string' || data['origin'] instanceof String)) {
            throw new Error("Expected the field `origin` to be a primitive type in the JSON string but got " + data['origin']);
        }
        // ensure the json data is a string
        if (data['originNamespace'] && !(typeof data['originNamespace'] === 'string' || data['originNamespace'] instanceof String)) {
            throw new Error("Expected the field `originNamespace` to be a primitive type in the JSON string but got " + data['originNamespace']);
        }
        // ensure the json data is a string
        if (data['originalRequestingStepName'] && !(typeof data['originalRequestingStepName'] === 'string' || data['originalRequestingStepName'] instanceof String)) {
            throw new Error("Expected the field `originalRequestingStepName` to be a primitive type in the JSON string but got " + data['originalRequestingStepName']);
        }
        // ensure the json data is a string
        if (data['originalStepName'] && !(typeof data['originalStepName'] === 'string' || data['originalStepName'] instanceof String)) {
            throw new Error("Expected the field `originalStepName` to be a primitive type in the JSON string but got " + data['originalStepName']);
        }
        // ensure the json data is a string
        if (data['portion'] && !(typeof data['portion'] === 'string' || data['portion'] instanceof String)) {
            throw new Error("Expected the field `portion` to be a primitive type in the JSON string but got " + data['portion']);
        }
        // ensure the json data is a string
        if (data['workerId'] && !(typeof data['workerId'] === 'string' || data['workerId'] instanceof String)) {
            throw new Error("Expected the field `workerId` to be a primitive type in the JSON string but got " + data['workerId']);
        }

        return true;
    }


}



/**
 * Name of the optimized step being executed by the workers.
 * @member {String} componentStepName
 */
CounterStructuredName.prototype['componentStepName'] = undefined;

/**
 * Name of the stage. An execution step contains multiple component steps.
 * @member {String} executionStepName
 */
CounterStructuredName.prototype['executionStepName'] = undefined;

/**
 * Index of an input collection that's being read from/written to as a side input. The index identifies a step's side inputs starting by 1 (e.g. the first side input has input_index 1, the third has input_index 3). Side inputs are identified by a pair of (original_step_name, input_index). This field helps uniquely identify them.
 * @member {Number} inputIndex
 */
CounterStructuredName.prototype['inputIndex'] = undefined;

/**
 * Counter name. Not necessarily globally-unique, but unique within the context of the other fields. Required.
 * @member {String} name
 */
CounterStructuredName.prototype['name'] = undefined;

/**
 * One of the standard Origins defined above.
 * @member {module:model/CounterStructuredName.OriginEnum} origin
 */
CounterStructuredName.prototype['origin'] = undefined;

/**
 * A string containing a more specific namespace of the counter's origin.
 * @member {String} originNamespace
 */
CounterStructuredName.prototype['originNamespace'] = undefined;

/**
 * The step name requesting an operation, such as GBK. I.e. the ParDo causing a read/write from shuffle to occur, or a read from side inputs.
 * @member {String} originalRequestingStepName
 */
CounterStructuredName.prototype['originalRequestingStepName'] = undefined;

/**
 * System generated name of the original step in the user's graph, before optimization.
 * @member {String} originalStepName
 */
CounterStructuredName.prototype['originalStepName'] = undefined;

/**
 * Portion of this counter, either key or value.
 * @member {module:model/CounterStructuredName.PortionEnum} portion
 */
CounterStructuredName.prototype['portion'] = undefined;

/**
 * ID of a particular worker.
 * @member {String} workerId
 */
CounterStructuredName.prototype['workerId'] = undefined;





/**
 * Allowed values for the <code>origin</code> property.
 * @enum {String}
 * @readonly
 */
CounterStructuredName['OriginEnum'] = {

    /**
     * value: "SYSTEM"
     * @const
     */
    "SYSTEM": "SYSTEM",

    /**
     * value: "USER"
     * @const
     */
    "USER": "USER"
};


/**
 * Allowed values for the <code>portion</code> property.
 * @enum {String}
 * @readonly
 */
CounterStructuredName['PortionEnum'] = {

    /**
     * value: "ALL"
     * @const
     */
    "ALL": "ALL",

    /**
     * value: "KEY"
     * @const
     */
    "KEY": "KEY",

    /**
     * value: "VALUE"
     * @const
     */
    "VALUE": "VALUE"
};



export default CounterStructuredName;

