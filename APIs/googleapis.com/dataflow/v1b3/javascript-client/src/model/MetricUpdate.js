/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import MetricStructuredName from './MetricStructuredName';

/**
 * The MetricUpdate model module.
 * @module model/MetricUpdate
 * @version v1b3
 */
class MetricUpdate {
    /**
     * Constructs a new <code>MetricUpdate</code>.
     * Describes the state of a metric.
     * @alias module:model/MetricUpdate
     */
    constructor() { 
        
        MetricUpdate.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>MetricUpdate</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/MetricUpdate} obj Optional instance to populate.
     * @return {module:model/MetricUpdate} The populated <code>MetricUpdate</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new MetricUpdate();

            if (data.hasOwnProperty('cumulative')) {
                obj['cumulative'] = ApiClient.convertToType(data['cumulative'], 'Boolean');
            }
            if (data.hasOwnProperty('distribution')) {
                obj['distribution'] = ApiClient.convertToType(data['distribution'], Object);
            }
            if (data.hasOwnProperty('gauge')) {
                obj['gauge'] = ApiClient.convertToType(data['gauge'], Object);
            }
            if (data.hasOwnProperty('internal')) {
                obj['internal'] = ApiClient.convertToType(data['internal'], Object);
            }
            if (data.hasOwnProperty('kind')) {
                obj['kind'] = ApiClient.convertToType(data['kind'], 'String');
            }
            if (data.hasOwnProperty('meanCount')) {
                obj['meanCount'] = ApiClient.convertToType(data['meanCount'], Object);
            }
            if (data.hasOwnProperty('meanSum')) {
                obj['meanSum'] = ApiClient.convertToType(data['meanSum'], Object);
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = MetricStructuredName.constructFromObject(data['name']);
            }
            if (data.hasOwnProperty('scalar')) {
                obj['scalar'] = ApiClient.convertToType(data['scalar'], Object);
            }
            if (data.hasOwnProperty('set')) {
                obj['set'] = ApiClient.convertToType(data['set'], Object);
            }
            if (data.hasOwnProperty('updateTime')) {
                obj['updateTime'] = ApiClient.convertToType(data['updateTime'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>MetricUpdate</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>MetricUpdate</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['kind'] && !(typeof data['kind'] === 'string' || data['kind'] instanceof String)) {
            throw new Error("Expected the field `kind` to be a primitive type in the JSON string but got " + data['kind']);
        }
        // validate the optional field `name`
        if (data['name']) { // data not null
          MetricStructuredName.validateJSON(data['name']);
        }
        // ensure the json data is a string
        if (data['updateTime'] && !(typeof data['updateTime'] === 'string' || data['updateTime'] instanceof String)) {
            throw new Error("Expected the field `updateTime` to be a primitive type in the JSON string but got " + data['updateTime']);
        }

        return true;
    }


}



/**
 * True if this metric is reported as the total cumulative aggregate value accumulated since the worker started working on this WorkItem. By default this is false, indicating that this metric is reported as a delta that is not associated with any WorkItem.
 * @member {Boolean} cumulative
 */
MetricUpdate.prototype['cumulative'] = undefined;

/**
 * A struct value describing properties of a distribution of numeric values.
 * @member {Object} distribution
 */
MetricUpdate.prototype['distribution'] = undefined;

/**
 * A struct value describing properties of a Gauge. Metrics of gauge type show the value of a metric across time, and is aggregated based on the newest value.
 * @member {Object} gauge
 */
MetricUpdate.prototype['gauge'] = undefined;

/**
 * Worker-computed aggregate value for internal use by the Dataflow service.
 * @member {Object} internal
 */
MetricUpdate.prototype['internal'] = undefined;

/**
 * Metric aggregation kind. The possible metric aggregation kinds are \"Sum\", \"Max\", \"Min\", \"Mean\", \"Set\", \"And\", \"Or\", and \"Distribution\". The specified aggregation kind is case-insensitive. If omitted, this is not an aggregated value but instead a single metric sample value.
 * @member {String} kind
 */
MetricUpdate.prototype['kind'] = undefined;

/**
 * Worker-computed aggregate value for the \"Mean\" aggregation kind. This holds the count of the aggregated values and is used in combination with mean_sum above to obtain the actual mean aggregate value. The only possible value type is Long.
 * @member {Object} meanCount
 */
MetricUpdate.prototype['meanCount'] = undefined;

/**
 * Worker-computed aggregate value for the \"Mean\" aggregation kind. This holds the sum of the aggregated values and is used in combination with mean_count below to obtain the actual mean aggregate value. The only possible value types are Long and Double.
 * @member {Object} meanSum
 */
MetricUpdate.prototype['meanSum'] = undefined;

/**
 * @member {module:model/MetricStructuredName} name
 */
MetricUpdate.prototype['name'] = undefined;

/**
 * Worker-computed aggregate value for aggregation kinds \"Sum\", \"Max\", \"Min\", \"And\", and \"Or\". The possible value types are Long, Double, and Boolean.
 * @member {Object} scalar
 */
MetricUpdate.prototype['scalar'] = undefined;

/**
 * Worker-computed aggregate value for the \"Set\" aggregation kind. The only possible value type is a list of Values whose type can be Long, Double, or String, according to the metric's type. All Values in the list must be of the same type.
 * @member {Object} set
 */
MetricUpdate.prototype['set'] = undefined;

/**
 * Timestamp associated with the metric value. Optional when workers are reporting work progress; it will be filled in responses from the metrics API.
 * @member {String} updateTime
 */
MetricUpdate.prototype['updateTime'] = undefined;






export default MetricUpdate;

