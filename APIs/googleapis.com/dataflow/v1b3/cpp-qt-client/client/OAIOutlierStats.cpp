/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOutlierStats.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOutlierStats::OAIOutlierStats(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOutlierStats::OAIOutlierStats() {
    this->initializeModel();
}

OAIOutlierStats::~OAIOutlierStats() {}

void OAIOutlierStats::initializeModel() {

    m_overflow_count_isSet = false;
    m_overflow_count_isValid = false;

    m_overflow_mean_isSet = false;
    m_overflow_mean_isValid = false;

    m_underflow_count_isSet = false;
    m_underflow_count_isValid = false;

    m_underflow_mean_isSet = false;
    m_underflow_mean_isValid = false;
}

void OAIOutlierStats::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOutlierStats::fromJsonObject(QJsonObject json) {

    m_overflow_count_isValid = ::OpenAPI::fromJsonValue(m_overflow_count, json[QString("overflowCount")]);
    m_overflow_count_isSet = !json[QString("overflowCount")].isNull() && m_overflow_count_isValid;

    m_overflow_mean_isValid = ::OpenAPI::fromJsonValue(m_overflow_mean, json[QString("overflowMean")]);
    m_overflow_mean_isSet = !json[QString("overflowMean")].isNull() && m_overflow_mean_isValid;

    m_underflow_count_isValid = ::OpenAPI::fromJsonValue(m_underflow_count, json[QString("underflowCount")]);
    m_underflow_count_isSet = !json[QString("underflowCount")].isNull() && m_underflow_count_isValid;

    m_underflow_mean_isValid = ::OpenAPI::fromJsonValue(m_underflow_mean, json[QString("underflowMean")]);
    m_underflow_mean_isSet = !json[QString("underflowMean")].isNull() && m_underflow_mean_isValid;
}

QString OAIOutlierStats::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOutlierStats::asJsonObject() const {
    QJsonObject obj;
    if (m_overflow_count_isSet) {
        obj.insert(QString("overflowCount"), ::OpenAPI::toJsonValue(m_overflow_count));
    }
    if (m_overflow_mean_isSet) {
        obj.insert(QString("overflowMean"), ::OpenAPI::toJsonValue(m_overflow_mean));
    }
    if (m_underflow_count_isSet) {
        obj.insert(QString("underflowCount"), ::OpenAPI::toJsonValue(m_underflow_count));
    }
    if (m_underflow_mean_isSet) {
        obj.insert(QString("underflowMean"), ::OpenAPI::toJsonValue(m_underflow_mean));
    }
    return obj;
}

QString OAIOutlierStats::getOverflowCount() const {
    return m_overflow_count;
}
void OAIOutlierStats::setOverflowCount(const QString &overflow_count) {
    m_overflow_count = overflow_count;
    m_overflow_count_isSet = true;
}

bool OAIOutlierStats::is_overflow_count_Set() const{
    return m_overflow_count_isSet;
}

bool OAIOutlierStats::is_overflow_count_Valid() const{
    return m_overflow_count_isValid;
}

double OAIOutlierStats::getOverflowMean() const {
    return m_overflow_mean;
}
void OAIOutlierStats::setOverflowMean(const double &overflow_mean) {
    m_overflow_mean = overflow_mean;
    m_overflow_mean_isSet = true;
}

bool OAIOutlierStats::is_overflow_mean_Set() const{
    return m_overflow_mean_isSet;
}

bool OAIOutlierStats::is_overflow_mean_Valid() const{
    return m_overflow_mean_isValid;
}

QString OAIOutlierStats::getUnderflowCount() const {
    return m_underflow_count;
}
void OAIOutlierStats::setUnderflowCount(const QString &underflow_count) {
    m_underflow_count = underflow_count;
    m_underflow_count_isSet = true;
}

bool OAIOutlierStats::is_underflow_count_Set() const{
    return m_underflow_count_isSet;
}

bool OAIOutlierStats::is_underflow_count_Valid() const{
    return m_underflow_count_isValid;
}

double OAIOutlierStats::getUnderflowMean() const {
    return m_underflow_mean;
}
void OAIOutlierStats::setUnderflowMean(const double &underflow_mean) {
    m_underflow_mean = underflow_mean;
    m_underflow_mean_isSet = true;
}

bool OAIOutlierStats::is_underflow_mean_Set() const{
    return m_underflow_mean_isSet;
}

bool OAIOutlierStats::is_underflow_mean_Valid() const{
    return m_underflow_mean_isValid;
}

bool OAIOutlierStats::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_overflow_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_overflow_mean_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_underflow_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_underflow_mean_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOutlierStats::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
