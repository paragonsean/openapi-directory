/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITaskRunnerSettings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITaskRunnerSettings::OAITaskRunnerSettings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITaskRunnerSettings::OAITaskRunnerSettings() {
    this->initializeModel();
}

OAITaskRunnerSettings::~OAITaskRunnerSettings() {}

void OAITaskRunnerSettings::initializeModel() {

    m_alsologtostderr_isSet = false;
    m_alsologtostderr_isValid = false;

    m_base_task_dir_isSet = false;
    m_base_task_dir_isValid = false;

    m_base_url_isSet = false;
    m_base_url_isValid = false;

    m_commandlines_file_name_isSet = false;
    m_commandlines_file_name_isValid = false;

    m_continue_on_exception_isSet = false;
    m_continue_on_exception_isValid = false;

    m_dataflow_api_version_isSet = false;
    m_dataflow_api_version_isValid = false;

    m_harness_command_isSet = false;
    m_harness_command_isValid = false;

    m_language_hint_isSet = false;
    m_language_hint_isValid = false;

    m_log_dir_isSet = false;
    m_log_dir_isValid = false;

    m_log_to_serialconsole_isSet = false;
    m_log_to_serialconsole_isValid = false;

    m_log_upload_location_isSet = false;
    m_log_upload_location_isValid = false;

    m_oauth_scopes_isSet = false;
    m_oauth_scopes_isValid = false;

    m_parallel_worker_settings_isSet = false;
    m_parallel_worker_settings_isValid = false;

    m_streaming_worker_main_class_isSet = false;
    m_streaming_worker_main_class_isValid = false;

    m_task_group_isSet = false;
    m_task_group_isValid = false;

    m_task_user_isSet = false;
    m_task_user_isValid = false;

    m_temp_storage_prefix_isSet = false;
    m_temp_storage_prefix_isValid = false;

    m_vm_id_isSet = false;
    m_vm_id_isValid = false;

    m_workflow_file_name_isSet = false;
    m_workflow_file_name_isValid = false;
}

void OAITaskRunnerSettings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITaskRunnerSettings::fromJsonObject(QJsonObject json) {

    m_alsologtostderr_isValid = ::OpenAPI::fromJsonValue(m_alsologtostderr, json[QString("alsologtostderr")]);
    m_alsologtostderr_isSet = !json[QString("alsologtostderr")].isNull() && m_alsologtostderr_isValid;

    m_base_task_dir_isValid = ::OpenAPI::fromJsonValue(m_base_task_dir, json[QString("baseTaskDir")]);
    m_base_task_dir_isSet = !json[QString("baseTaskDir")].isNull() && m_base_task_dir_isValid;

    m_base_url_isValid = ::OpenAPI::fromJsonValue(m_base_url, json[QString("baseUrl")]);
    m_base_url_isSet = !json[QString("baseUrl")].isNull() && m_base_url_isValid;

    m_commandlines_file_name_isValid = ::OpenAPI::fromJsonValue(m_commandlines_file_name, json[QString("commandlinesFileName")]);
    m_commandlines_file_name_isSet = !json[QString("commandlinesFileName")].isNull() && m_commandlines_file_name_isValid;

    m_continue_on_exception_isValid = ::OpenAPI::fromJsonValue(m_continue_on_exception, json[QString("continueOnException")]);
    m_continue_on_exception_isSet = !json[QString("continueOnException")].isNull() && m_continue_on_exception_isValid;

    m_dataflow_api_version_isValid = ::OpenAPI::fromJsonValue(m_dataflow_api_version, json[QString("dataflowApiVersion")]);
    m_dataflow_api_version_isSet = !json[QString("dataflowApiVersion")].isNull() && m_dataflow_api_version_isValid;

    m_harness_command_isValid = ::OpenAPI::fromJsonValue(m_harness_command, json[QString("harnessCommand")]);
    m_harness_command_isSet = !json[QString("harnessCommand")].isNull() && m_harness_command_isValid;

    m_language_hint_isValid = ::OpenAPI::fromJsonValue(m_language_hint, json[QString("languageHint")]);
    m_language_hint_isSet = !json[QString("languageHint")].isNull() && m_language_hint_isValid;

    m_log_dir_isValid = ::OpenAPI::fromJsonValue(m_log_dir, json[QString("logDir")]);
    m_log_dir_isSet = !json[QString("logDir")].isNull() && m_log_dir_isValid;

    m_log_to_serialconsole_isValid = ::OpenAPI::fromJsonValue(m_log_to_serialconsole, json[QString("logToSerialconsole")]);
    m_log_to_serialconsole_isSet = !json[QString("logToSerialconsole")].isNull() && m_log_to_serialconsole_isValid;

    m_log_upload_location_isValid = ::OpenAPI::fromJsonValue(m_log_upload_location, json[QString("logUploadLocation")]);
    m_log_upload_location_isSet = !json[QString("logUploadLocation")].isNull() && m_log_upload_location_isValid;

    m_oauth_scopes_isValid = ::OpenAPI::fromJsonValue(m_oauth_scopes, json[QString("oauthScopes")]);
    m_oauth_scopes_isSet = !json[QString("oauthScopes")].isNull() && m_oauth_scopes_isValid;

    m_parallel_worker_settings_isValid = ::OpenAPI::fromJsonValue(m_parallel_worker_settings, json[QString("parallelWorkerSettings")]);
    m_parallel_worker_settings_isSet = !json[QString("parallelWorkerSettings")].isNull() && m_parallel_worker_settings_isValid;

    m_streaming_worker_main_class_isValid = ::OpenAPI::fromJsonValue(m_streaming_worker_main_class, json[QString("streamingWorkerMainClass")]);
    m_streaming_worker_main_class_isSet = !json[QString("streamingWorkerMainClass")].isNull() && m_streaming_worker_main_class_isValid;

    m_task_group_isValid = ::OpenAPI::fromJsonValue(m_task_group, json[QString("taskGroup")]);
    m_task_group_isSet = !json[QString("taskGroup")].isNull() && m_task_group_isValid;

    m_task_user_isValid = ::OpenAPI::fromJsonValue(m_task_user, json[QString("taskUser")]);
    m_task_user_isSet = !json[QString("taskUser")].isNull() && m_task_user_isValid;

    m_temp_storage_prefix_isValid = ::OpenAPI::fromJsonValue(m_temp_storage_prefix, json[QString("tempStoragePrefix")]);
    m_temp_storage_prefix_isSet = !json[QString("tempStoragePrefix")].isNull() && m_temp_storage_prefix_isValid;

    m_vm_id_isValid = ::OpenAPI::fromJsonValue(m_vm_id, json[QString("vmId")]);
    m_vm_id_isSet = !json[QString("vmId")].isNull() && m_vm_id_isValid;

    m_workflow_file_name_isValid = ::OpenAPI::fromJsonValue(m_workflow_file_name, json[QString("workflowFileName")]);
    m_workflow_file_name_isSet = !json[QString("workflowFileName")].isNull() && m_workflow_file_name_isValid;
}

QString OAITaskRunnerSettings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITaskRunnerSettings::asJsonObject() const {
    QJsonObject obj;
    if (m_alsologtostderr_isSet) {
        obj.insert(QString("alsologtostderr"), ::OpenAPI::toJsonValue(m_alsologtostderr));
    }
    if (m_base_task_dir_isSet) {
        obj.insert(QString("baseTaskDir"), ::OpenAPI::toJsonValue(m_base_task_dir));
    }
    if (m_base_url_isSet) {
        obj.insert(QString("baseUrl"), ::OpenAPI::toJsonValue(m_base_url));
    }
    if (m_commandlines_file_name_isSet) {
        obj.insert(QString("commandlinesFileName"), ::OpenAPI::toJsonValue(m_commandlines_file_name));
    }
    if (m_continue_on_exception_isSet) {
        obj.insert(QString("continueOnException"), ::OpenAPI::toJsonValue(m_continue_on_exception));
    }
    if (m_dataflow_api_version_isSet) {
        obj.insert(QString("dataflowApiVersion"), ::OpenAPI::toJsonValue(m_dataflow_api_version));
    }
    if (m_harness_command_isSet) {
        obj.insert(QString("harnessCommand"), ::OpenAPI::toJsonValue(m_harness_command));
    }
    if (m_language_hint_isSet) {
        obj.insert(QString("languageHint"), ::OpenAPI::toJsonValue(m_language_hint));
    }
    if (m_log_dir_isSet) {
        obj.insert(QString("logDir"), ::OpenAPI::toJsonValue(m_log_dir));
    }
    if (m_log_to_serialconsole_isSet) {
        obj.insert(QString("logToSerialconsole"), ::OpenAPI::toJsonValue(m_log_to_serialconsole));
    }
    if (m_log_upload_location_isSet) {
        obj.insert(QString("logUploadLocation"), ::OpenAPI::toJsonValue(m_log_upload_location));
    }
    if (m_oauth_scopes.size() > 0) {
        obj.insert(QString("oauthScopes"), ::OpenAPI::toJsonValue(m_oauth_scopes));
    }
    if (m_parallel_worker_settings.isSet()) {
        obj.insert(QString("parallelWorkerSettings"), ::OpenAPI::toJsonValue(m_parallel_worker_settings));
    }
    if (m_streaming_worker_main_class_isSet) {
        obj.insert(QString("streamingWorkerMainClass"), ::OpenAPI::toJsonValue(m_streaming_worker_main_class));
    }
    if (m_task_group_isSet) {
        obj.insert(QString("taskGroup"), ::OpenAPI::toJsonValue(m_task_group));
    }
    if (m_task_user_isSet) {
        obj.insert(QString("taskUser"), ::OpenAPI::toJsonValue(m_task_user));
    }
    if (m_temp_storage_prefix_isSet) {
        obj.insert(QString("tempStoragePrefix"), ::OpenAPI::toJsonValue(m_temp_storage_prefix));
    }
    if (m_vm_id_isSet) {
        obj.insert(QString("vmId"), ::OpenAPI::toJsonValue(m_vm_id));
    }
    if (m_workflow_file_name_isSet) {
        obj.insert(QString("workflowFileName"), ::OpenAPI::toJsonValue(m_workflow_file_name));
    }
    return obj;
}

bool OAITaskRunnerSettings::isAlsologtostderr() const {
    return m_alsologtostderr;
}
void OAITaskRunnerSettings::setAlsologtostderr(const bool &alsologtostderr) {
    m_alsologtostderr = alsologtostderr;
    m_alsologtostderr_isSet = true;
}

bool OAITaskRunnerSettings::is_alsologtostderr_Set() const{
    return m_alsologtostderr_isSet;
}

bool OAITaskRunnerSettings::is_alsologtostderr_Valid() const{
    return m_alsologtostderr_isValid;
}

QString OAITaskRunnerSettings::getBaseTaskDir() const {
    return m_base_task_dir;
}
void OAITaskRunnerSettings::setBaseTaskDir(const QString &base_task_dir) {
    m_base_task_dir = base_task_dir;
    m_base_task_dir_isSet = true;
}

bool OAITaskRunnerSettings::is_base_task_dir_Set() const{
    return m_base_task_dir_isSet;
}

bool OAITaskRunnerSettings::is_base_task_dir_Valid() const{
    return m_base_task_dir_isValid;
}

QString OAITaskRunnerSettings::getBaseUrl() const {
    return m_base_url;
}
void OAITaskRunnerSettings::setBaseUrl(const QString &base_url) {
    m_base_url = base_url;
    m_base_url_isSet = true;
}

bool OAITaskRunnerSettings::is_base_url_Set() const{
    return m_base_url_isSet;
}

bool OAITaskRunnerSettings::is_base_url_Valid() const{
    return m_base_url_isValid;
}

QString OAITaskRunnerSettings::getCommandlinesFileName() const {
    return m_commandlines_file_name;
}
void OAITaskRunnerSettings::setCommandlinesFileName(const QString &commandlines_file_name) {
    m_commandlines_file_name = commandlines_file_name;
    m_commandlines_file_name_isSet = true;
}

bool OAITaskRunnerSettings::is_commandlines_file_name_Set() const{
    return m_commandlines_file_name_isSet;
}

bool OAITaskRunnerSettings::is_commandlines_file_name_Valid() const{
    return m_commandlines_file_name_isValid;
}

bool OAITaskRunnerSettings::isContinueOnException() const {
    return m_continue_on_exception;
}
void OAITaskRunnerSettings::setContinueOnException(const bool &continue_on_exception) {
    m_continue_on_exception = continue_on_exception;
    m_continue_on_exception_isSet = true;
}

bool OAITaskRunnerSettings::is_continue_on_exception_Set() const{
    return m_continue_on_exception_isSet;
}

bool OAITaskRunnerSettings::is_continue_on_exception_Valid() const{
    return m_continue_on_exception_isValid;
}

QString OAITaskRunnerSettings::getDataflowApiVersion() const {
    return m_dataflow_api_version;
}
void OAITaskRunnerSettings::setDataflowApiVersion(const QString &dataflow_api_version) {
    m_dataflow_api_version = dataflow_api_version;
    m_dataflow_api_version_isSet = true;
}

bool OAITaskRunnerSettings::is_dataflow_api_version_Set() const{
    return m_dataflow_api_version_isSet;
}

bool OAITaskRunnerSettings::is_dataflow_api_version_Valid() const{
    return m_dataflow_api_version_isValid;
}

QString OAITaskRunnerSettings::getHarnessCommand() const {
    return m_harness_command;
}
void OAITaskRunnerSettings::setHarnessCommand(const QString &harness_command) {
    m_harness_command = harness_command;
    m_harness_command_isSet = true;
}

bool OAITaskRunnerSettings::is_harness_command_Set() const{
    return m_harness_command_isSet;
}

bool OAITaskRunnerSettings::is_harness_command_Valid() const{
    return m_harness_command_isValid;
}

QString OAITaskRunnerSettings::getLanguageHint() const {
    return m_language_hint;
}
void OAITaskRunnerSettings::setLanguageHint(const QString &language_hint) {
    m_language_hint = language_hint;
    m_language_hint_isSet = true;
}

bool OAITaskRunnerSettings::is_language_hint_Set() const{
    return m_language_hint_isSet;
}

bool OAITaskRunnerSettings::is_language_hint_Valid() const{
    return m_language_hint_isValid;
}

QString OAITaskRunnerSettings::getLogDir() const {
    return m_log_dir;
}
void OAITaskRunnerSettings::setLogDir(const QString &log_dir) {
    m_log_dir = log_dir;
    m_log_dir_isSet = true;
}

bool OAITaskRunnerSettings::is_log_dir_Set() const{
    return m_log_dir_isSet;
}

bool OAITaskRunnerSettings::is_log_dir_Valid() const{
    return m_log_dir_isValid;
}

bool OAITaskRunnerSettings::isLogToSerialconsole() const {
    return m_log_to_serialconsole;
}
void OAITaskRunnerSettings::setLogToSerialconsole(const bool &log_to_serialconsole) {
    m_log_to_serialconsole = log_to_serialconsole;
    m_log_to_serialconsole_isSet = true;
}

bool OAITaskRunnerSettings::is_log_to_serialconsole_Set() const{
    return m_log_to_serialconsole_isSet;
}

bool OAITaskRunnerSettings::is_log_to_serialconsole_Valid() const{
    return m_log_to_serialconsole_isValid;
}

QString OAITaskRunnerSettings::getLogUploadLocation() const {
    return m_log_upload_location;
}
void OAITaskRunnerSettings::setLogUploadLocation(const QString &log_upload_location) {
    m_log_upload_location = log_upload_location;
    m_log_upload_location_isSet = true;
}

bool OAITaskRunnerSettings::is_log_upload_location_Set() const{
    return m_log_upload_location_isSet;
}

bool OAITaskRunnerSettings::is_log_upload_location_Valid() const{
    return m_log_upload_location_isValid;
}

QList<QString> OAITaskRunnerSettings::getOauthScopes() const {
    return m_oauth_scopes;
}
void OAITaskRunnerSettings::setOauthScopes(const QList<QString> &oauth_scopes) {
    m_oauth_scopes = oauth_scopes;
    m_oauth_scopes_isSet = true;
}

bool OAITaskRunnerSettings::is_oauth_scopes_Set() const{
    return m_oauth_scopes_isSet;
}

bool OAITaskRunnerSettings::is_oauth_scopes_Valid() const{
    return m_oauth_scopes_isValid;
}

OAIWorkerSettings OAITaskRunnerSettings::getParallelWorkerSettings() const {
    return m_parallel_worker_settings;
}
void OAITaskRunnerSettings::setParallelWorkerSettings(const OAIWorkerSettings &parallel_worker_settings) {
    m_parallel_worker_settings = parallel_worker_settings;
    m_parallel_worker_settings_isSet = true;
}

bool OAITaskRunnerSettings::is_parallel_worker_settings_Set() const{
    return m_parallel_worker_settings_isSet;
}

bool OAITaskRunnerSettings::is_parallel_worker_settings_Valid() const{
    return m_parallel_worker_settings_isValid;
}

QString OAITaskRunnerSettings::getStreamingWorkerMainClass() const {
    return m_streaming_worker_main_class;
}
void OAITaskRunnerSettings::setStreamingWorkerMainClass(const QString &streaming_worker_main_class) {
    m_streaming_worker_main_class = streaming_worker_main_class;
    m_streaming_worker_main_class_isSet = true;
}

bool OAITaskRunnerSettings::is_streaming_worker_main_class_Set() const{
    return m_streaming_worker_main_class_isSet;
}

bool OAITaskRunnerSettings::is_streaming_worker_main_class_Valid() const{
    return m_streaming_worker_main_class_isValid;
}

QString OAITaskRunnerSettings::getTaskGroup() const {
    return m_task_group;
}
void OAITaskRunnerSettings::setTaskGroup(const QString &task_group) {
    m_task_group = task_group;
    m_task_group_isSet = true;
}

bool OAITaskRunnerSettings::is_task_group_Set() const{
    return m_task_group_isSet;
}

bool OAITaskRunnerSettings::is_task_group_Valid() const{
    return m_task_group_isValid;
}

QString OAITaskRunnerSettings::getTaskUser() const {
    return m_task_user;
}
void OAITaskRunnerSettings::setTaskUser(const QString &task_user) {
    m_task_user = task_user;
    m_task_user_isSet = true;
}

bool OAITaskRunnerSettings::is_task_user_Set() const{
    return m_task_user_isSet;
}

bool OAITaskRunnerSettings::is_task_user_Valid() const{
    return m_task_user_isValid;
}

QString OAITaskRunnerSettings::getTempStoragePrefix() const {
    return m_temp_storage_prefix;
}
void OAITaskRunnerSettings::setTempStoragePrefix(const QString &temp_storage_prefix) {
    m_temp_storage_prefix = temp_storage_prefix;
    m_temp_storage_prefix_isSet = true;
}

bool OAITaskRunnerSettings::is_temp_storage_prefix_Set() const{
    return m_temp_storage_prefix_isSet;
}

bool OAITaskRunnerSettings::is_temp_storage_prefix_Valid() const{
    return m_temp_storage_prefix_isValid;
}

QString OAITaskRunnerSettings::getVmId() const {
    return m_vm_id;
}
void OAITaskRunnerSettings::setVmId(const QString &vm_id) {
    m_vm_id = vm_id;
    m_vm_id_isSet = true;
}

bool OAITaskRunnerSettings::is_vm_id_Set() const{
    return m_vm_id_isSet;
}

bool OAITaskRunnerSettings::is_vm_id_Valid() const{
    return m_vm_id_isValid;
}

QString OAITaskRunnerSettings::getWorkflowFileName() const {
    return m_workflow_file_name;
}
void OAITaskRunnerSettings::setWorkflowFileName(const QString &workflow_file_name) {
    m_workflow_file_name = workflow_file_name;
    m_workflow_file_name_isSet = true;
}

bool OAITaskRunnerSettings::is_workflow_file_name_Set() const{
    return m_workflow_file_name_isSet;
}

bool OAITaskRunnerSettings::is_workflow_file_name_Valid() const{
    return m_workflow_file_name_isValid;
}

bool OAITaskRunnerSettings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alsologtostderr_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_base_task_dir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_base_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_commandlines_file_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_continue_on_exception_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dataflow_api_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_harness_command_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_language_hint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_log_dir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_log_to_serialconsole_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_log_upload_location_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_oauth_scopes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_parallel_worker_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_streaming_worker_main_class_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_task_group_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_task_user_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_temp_storage_prefix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vm_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_workflow_file_name_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITaskRunnerSettings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
