/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStreamingScalingReport.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStreamingScalingReport::OAIStreamingScalingReport(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStreamingScalingReport::OAIStreamingScalingReport() {
    this->initializeModel();
}

OAIStreamingScalingReport::~OAIStreamingScalingReport() {}

void OAIStreamingScalingReport::initializeModel() {

    m_active_bundle_count_isSet = false;
    m_active_bundle_count_isValid = false;

    m_active_thread_count_isSet = false;
    m_active_thread_count_isValid = false;

    m_maximum_bundle_count_isSet = false;
    m_maximum_bundle_count_isValid = false;

    m_maximum_bytes_isSet = false;
    m_maximum_bytes_isValid = false;

    m_maximum_bytes_count_isSet = false;
    m_maximum_bytes_count_isValid = false;

    m_maximum_thread_count_isSet = false;
    m_maximum_thread_count_isValid = false;

    m_outstanding_bundle_count_isSet = false;
    m_outstanding_bundle_count_isValid = false;

    m_outstanding_bytes_isSet = false;
    m_outstanding_bytes_isValid = false;

    m_outstanding_bytes_count_isSet = false;
    m_outstanding_bytes_count_isValid = false;
}

void OAIStreamingScalingReport::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStreamingScalingReport::fromJsonObject(QJsonObject json) {

    m_active_bundle_count_isValid = ::OpenAPI::fromJsonValue(m_active_bundle_count, json[QString("activeBundleCount")]);
    m_active_bundle_count_isSet = !json[QString("activeBundleCount")].isNull() && m_active_bundle_count_isValid;

    m_active_thread_count_isValid = ::OpenAPI::fromJsonValue(m_active_thread_count, json[QString("activeThreadCount")]);
    m_active_thread_count_isSet = !json[QString("activeThreadCount")].isNull() && m_active_thread_count_isValid;

    m_maximum_bundle_count_isValid = ::OpenAPI::fromJsonValue(m_maximum_bundle_count, json[QString("maximumBundleCount")]);
    m_maximum_bundle_count_isSet = !json[QString("maximumBundleCount")].isNull() && m_maximum_bundle_count_isValid;

    m_maximum_bytes_isValid = ::OpenAPI::fromJsonValue(m_maximum_bytes, json[QString("maximumBytes")]);
    m_maximum_bytes_isSet = !json[QString("maximumBytes")].isNull() && m_maximum_bytes_isValid;

    m_maximum_bytes_count_isValid = ::OpenAPI::fromJsonValue(m_maximum_bytes_count, json[QString("maximumBytesCount")]);
    m_maximum_bytes_count_isSet = !json[QString("maximumBytesCount")].isNull() && m_maximum_bytes_count_isValid;

    m_maximum_thread_count_isValid = ::OpenAPI::fromJsonValue(m_maximum_thread_count, json[QString("maximumThreadCount")]);
    m_maximum_thread_count_isSet = !json[QString("maximumThreadCount")].isNull() && m_maximum_thread_count_isValid;

    m_outstanding_bundle_count_isValid = ::OpenAPI::fromJsonValue(m_outstanding_bundle_count, json[QString("outstandingBundleCount")]);
    m_outstanding_bundle_count_isSet = !json[QString("outstandingBundleCount")].isNull() && m_outstanding_bundle_count_isValid;

    m_outstanding_bytes_isValid = ::OpenAPI::fromJsonValue(m_outstanding_bytes, json[QString("outstandingBytes")]);
    m_outstanding_bytes_isSet = !json[QString("outstandingBytes")].isNull() && m_outstanding_bytes_isValid;

    m_outstanding_bytes_count_isValid = ::OpenAPI::fromJsonValue(m_outstanding_bytes_count, json[QString("outstandingBytesCount")]);
    m_outstanding_bytes_count_isSet = !json[QString("outstandingBytesCount")].isNull() && m_outstanding_bytes_count_isValid;
}

QString OAIStreamingScalingReport::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStreamingScalingReport::asJsonObject() const {
    QJsonObject obj;
    if (m_active_bundle_count_isSet) {
        obj.insert(QString("activeBundleCount"), ::OpenAPI::toJsonValue(m_active_bundle_count));
    }
    if (m_active_thread_count_isSet) {
        obj.insert(QString("activeThreadCount"), ::OpenAPI::toJsonValue(m_active_thread_count));
    }
    if (m_maximum_bundle_count_isSet) {
        obj.insert(QString("maximumBundleCount"), ::OpenAPI::toJsonValue(m_maximum_bundle_count));
    }
    if (m_maximum_bytes_isSet) {
        obj.insert(QString("maximumBytes"), ::OpenAPI::toJsonValue(m_maximum_bytes));
    }
    if (m_maximum_bytes_count_isSet) {
        obj.insert(QString("maximumBytesCount"), ::OpenAPI::toJsonValue(m_maximum_bytes_count));
    }
    if (m_maximum_thread_count_isSet) {
        obj.insert(QString("maximumThreadCount"), ::OpenAPI::toJsonValue(m_maximum_thread_count));
    }
    if (m_outstanding_bundle_count_isSet) {
        obj.insert(QString("outstandingBundleCount"), ::OpenAPI::toJsonValue(m_outstanding_bundle_count));
    }
    if (m_outstanding_bytes_isSet) {
        obj.insert(QString("outstandingBytes"), ::OpenAPI::toJsonValue(m_outstanding_bytes));
    }
    if (m_outstanding_bytes_count_isSet) {
        obj.insert(QString("outstandingBytesCount"), ::OpenAPI::toJsonValue(m_outstanding_bytes_count));
    }
    return obj;
}

qint32 OAIStreamingScalingReport::getActiveBundleCount() const {
    return m_active_bundle_count;
}
void OAIStreamingScalingReport::setActiveBundleCount(const qint32 &active_bundle_count) {
    m_active_bundle_count = active_bundle_count;
    m_active_bundle_count_isSet = true;
}

bool OAIStreamingScalingReport::is_active_bundle_count_Set() const{
    return m_active_bundle_count_isSet;
}

bool OAIStreamingScalingReport::is_active_bundle_count_Valid() const{
    return m_active_bundle_count_isValid;
}

qint32 OAIStreamingScalingReport::getActiveThreadCount() const {
    return m_active_thread_count;
}
void OAIStreamingScalingReport::setActiveThreadCount(const qint32 &active_thread_count) {
    m_active_thread_count = active_thread_count;
    m_active_thread_count_isSet = true;
}

bool OAIStreamingScalingReport::is_active_thread_count_Set() const{
    return m_active_thread_count_isSet;
}

bool OAIStreamingScalingReport::is_active_thread_count_Valid() const{
    return m_active_thread_count_isValid;
}

qint32 OAIStreamingScalingReport::getMaximumBundleCount() const {
    return m_maximum_bundle_count;
}
void OAIStreamingScalingReport::setMaximumBundleCount(const qint32 &maximum_bundle_count) {
    m_maximum_bundle_count = maximum_bundle_count;
    m_maximum_bundle_count_isSet = true;
}

bool OAIStreamingScalingReport::is_maximum_bundle_count_Set() const{
    return m_maximum_bundle_count_isSet;
}

bool OAIStreamingScalingReport::is_maximum_bundle_count_Valid() const{
    return m_maximum_bundle_count_isValid;
}

QString OAIStreamingScalingReport::getMaximumBytes() const {
    return m_maximum_bytes;
}
void OAIStreamingScalingReport::setMaximumBytes(const QString &maximum_bytes) {
    m_maximum_bytes = maximum_bytes;
    m_maximum_bytes_isSet = true;
}

bool OAIStreamingScalingReport::is_maximum_bytes_Set() const{
    return m_maximum_bytes_isSet;
}

bool OAIStreamingScalingReport::is_maximum_bytes_Valid() const{
    return m_maximum_bytes_isValid;
}

qint32 OAIStreamingScalingReport::getMaximumBytesCount() const {
    return m_maximum_bytes_count;
}
void OAIStreamingScalingReport::setMaximumBytesCount(const qint32 &maximum_bytes_count) {
    m_maximum_bytes_count = maximum_bytes_count;
    m_maximum_bytes_count_isSet = true;
}

bool OAIStreamingScalingReport::is_maximum_bytes_count_Set() const{
    return m_maximum_bytes_count_isSet;
}

bool OAIStreamingScalingReport::is_maximum_bytes_count_Valid() const{
    return m_maximum_bytes_count_isValid;
}

qint32 OAIStreamingScalingReport::getMaximumThreadCount() const {
    return m_maximum_thread_count;
}
void OAIStreamingScalingReport::setMaximumThreadCount(const qint32 &maximum_thread_count) {
    m_maximum_thread_count = maximum_thread_count;
    m_maximum_thread_count_isSet = true;
}

bool OAIStreamingScalingReport::is_maximum_thread_count_Set() const{
    return m_maximum_thread_count_isSet;
}

bool OAIStreamingScalingReport::is_maximum_thread_count_Valid() const{
    return m_maximum_thread_count_isValid;
}

qint32 OAIStreamingScalingReport::getOutstandingBundleCount() const {
    return m_outstanding_bundle_count;
}
void OAIStreamingScalingReport::setOutstandingBundleCount(const qint32 &outstanding_bundle_count) {
    m_outstanding_bundle_count = outstanding_bundle_count;
    m_outstanding_bundle_count_isSet = true;
}

bool OAIStreamingScalingReport::is_outstanding_bundle_count_Set() const{
    return m_outstanding_bundle_count_isSet;
}

bool OAIStreamingScalingReport::is_outstanding_bundle_count_Valid() const{
    return m_outstanding_bundle_count_isValid;
}

QString OAIStreamingScalingReport::getOutstandingBytes() const {
    return m_outstanding_bytes;
}
void OAIStreamingScalingReport::setOutstandingBytes(const QString &outstanding_bytes) {
    m_outstanding_bytes = outstanding_bytes;
    m_outstanding_bytes_isSet = true;
}

bool OAIStreamingScalingReport::is_outstanding_bytes_Set() const{
    return m_outstanding_bytes_isSet;
}

bool OAIStreamingScalingReport::is_outstanding_bytes_Valid() const{
    return m_outstanding_bytes_isValid;
}

qint32 OAIStreamingScalingReport::getOutstandingBytesCount() const {
    return m_outstanding_bytes_count;
}
void OAIStreamingScalingReport::setOutstandingBytesCount(const qint32 &outstanding_bytes_count) {
    m_outstanding_bytes_count = outstanding_bytes_count;
    m_outstanding_bytes_count_isSet = true;
}

bool OAIStreamingScalingReport::is_outstanding_bytes_count_Set() const{
    return m_outstanding_bytes_count_isSet;
}

bool OAIStreamingScalingReport::is_outstanding_bytes_count_Valid() const{
    return m_outstanding_bytes_count_isValid;
}

bool OAIStreamingScalingReport::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_active_bundle_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_active_thread_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_bundle_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_bytes_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_thread_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_outstanding_bundle_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_outstanding_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_outstanding_bytes_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStreamingScalingReport::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
