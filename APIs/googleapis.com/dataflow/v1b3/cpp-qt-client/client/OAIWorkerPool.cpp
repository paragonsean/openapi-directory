/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIWorkerPool.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIWorkerPool::OAIWorkerPool(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIWorkerPool::OAIWorkerPool() {
    this->initializeModel();
}

OAIWorkerPool::~OAIWorkerPool() {}

void OAIWorkerPool::initializeModel() {

    m_autoscaling_settings_isSet = false;
    m_autoscaling_settings_isValid = false;

    m_data_disks_isSet = false;
    m_data_disks_isValid = false;

    m_default_package_set_isSet = false;
    m_default_package_set_isValid = false;

    m_disk_size_gb_isSet = false;
    m_disk_size_gb_isValid = false;

    m_disk_source_image_isSet = false;
    m_disk_source_image_isValid = false;

    m_disk_type_isSet = false;
    m_disk_type_isValid = false;

    m_ip_configuration_isSet = false;
    m_ip_configuration_isValid = false;

    m_kind_isSet = false;
    m_kind_isValid = false;

    m_machine_type_isSet = false;
    m_machine_type_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_network_isSet = false;
    m_network_isValid = false;

    m_num_threads_per_worker_isSet = false;
    m_num_threads_per_worker_isValid = false;

    m_num_workers_isSet = false;
    m_num_workers_isValid = false;

    m_on_host_maintenance_isSet = false;
    m_on_host_maintenance_isValid = false;

    m_packages_isSet = false;
    m_packages_isValid = false;

    m_pool_args_isSet = false;
    m_pool_args_isValid = false;

    m_sdk_harness_container_images_isSet = false;
    m_sdk_harness_container_images_isValid = false;

    m_subnetwork_isSet = false;
    m_subnetwork_isValid = false;

    m_taskrunner_settings_isSet = false;
    m_taskrunner_settings_isValid = false;

    m_teardown_policy_isSet = false;
    m_teardown_policy_isValid = false;

    m_worker_harness_container_image_isSet = false;
    m_worker_harness_container_image_isValid = false;

    m_zone_isSet = false;
    m_zone_isValid = false;
}

void OAIWorkerPool::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIWorkerPool::fromJsonObject(QJsonObject json) {

    m_autoscaling_settings_isValid = ::OpenAPI::fromJsonValue(m_autoscaling_settings, json[QString("autoscalingSettings")]);
    m_autoscaling_settings_isSet = !json[QString("autoscalingSettings")].isNull() && m_autoscaling_settings_isValid;

    m_data_disks_isValid = ::OpenAPI::fromJsonValue(m_data_disks, json[QString("dataDisks")]);
    m_data_disks_isSet = !json[QString("dataDisks")].isNull() && m_data_disks_isValid;

    m_default_package_set_isValid = ::OpenAPI::fromJsonValue(m_default_package_set, json[QString("defaultPackageSet")]);
    m_default_package_set_isSet = !json[QString("defaultPackageSet")].isNull() && m_default_package_set_isValid;

    m_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_disk_size_gb, json[QString("diskSizeGb")]);
    m_disk_size_gb_isSet = !json[QString("diskSizeGb")].isNull() && m_disk_size_gb_isValid;

    m_disk_source_image_isValid = ::OpenAPI::fromJsonValue(m_disk_source_image, json[QString("diskSourceImage")]);
    m_disk_source_image_isSet = !json[QString("diskSourceImage")].isNull() && m_disk_source_image_isValid;

    m_disk_type_isValid = ::OpenAPI::fromJsonValue(m_disk_type, json[QString("diskType")]);
    m_disk_type_isSet = !json[QString("diskType")].isNull() && m_disk_type_isValid;

    m_ip_configuration_isValid = ::OpenAPI::fromJsonValue(m_ip_configuration, json[QString("ipConfiguration")]);
    m_ip_configuration_isSet = !json[QString("ipConfiguration")].isNull() && m_ip_configuration_isValid;

    m_kind_isValid = ::OpenAPI::fromJsonValue(m_kind, json[QString("kind")]);
    m_kind_isSet = !json[QString("kind")].isNull() && m_kind_isValid;

    m_machine_type_isValid = ::OpenAPI::fromJsonValue(m_machine_type, json[QString("machineType")]);
    m_machine_type_isSet = !json[QString("machineType")].isNull() && m_machine_type_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_network_isValid = ::OpenAPI::fromJsonValue(m_network, json[QString("network")]);
    m_network_isSet = !json[QString("network")].isNull() && m_network_isValid;

    m_num_threads_per_worker_isValid = ::OpenAPI::fromJsonValue(m_num_threads_per_worker, json[QString("numThreadsPerWorker")]);
    m_num_threads_per_worker_isSet = !json[QString("numThreadsPerWorker")].isNull() && m_num_threads_per_worker_isValid;

    m_num_workers_isValid = ::OpenAPI::fromJsonValue(m_num_workers, json[QString("numWorkers")]);
    m_num_workers_isSet = !json[QString("numWorkers")].isNull() && m_num_workers_isValid;

    m_on_host_maintenance_isValid = ::OpenAPI::fromJsonValue(m_on_host_maintenance, json[QString("onHostMaintenance")]);
    m_on_host_maintenance_isSet = !json[QString("onHostMaintenance")].isNull() && m_on_host_maintenance_isValid;

    m_packages_isValid = ::OpenAPI::fromJsonValue(m_packages, json[QString("packages")]);
    m_packages_isSet = !json[QString("packages")].isNull() && m_packages_isValid;

    m_pool_args_isValid = ::OpenAPI::fromJsonValue(m_pool_args, json[QString("poolArgs")]);
    m_pool_args_isSet = !json[QString("poolArgs")].isNull() && m_pool_args_isValid;

    m_sdk_harness_container_images_isValid = ::OpenAPI::fromJsonValue(m_sdk_harness_container_images, json[QString("sdkHarnessContainerImages")]);
    m_sdk_harness_container_images_isSet = !json[QString("sdkHarnessContainerImages")].isNull() && m_sdk_harness_container_images_isValid;

    m_subnetwork_isValid = ::OpenAPI::fromJsonValue(m_subnetwork, json[QString("subnetwork")]);
    m_subnetwork_isSet = !json[QString("subnetwork")].isNull() && m_subnetwork_isValid;

    m_taskrunner_settings_isValid = ::OpenAPI::fromJsonValue(m_taskrunner_settings, json[QString("taskrunnerSettings")]);
    m_taskrunner_settings_isSet = !json[QString("taskrunnerSettings")].isNull() && m_taskrunner_settings_isValid;

    m_teardown_policy_isValid = ::OpenAPI::fromJsonValue(m_teardown_policy, json[QString("teardownPolicy")]);
    m_teardown_policy_isSet = !json[QString("teardownPolicy")].isNull() && m_teardown_policy_isValid;

    m_worker_harness_container_image_isValid = ::OpenAPI::fromJsonValue(m_worker_harness_container_image, json[QString("workerHarnessContainerImage")]);
    m_worker_harness_container_image_isSet = !json[QString("workerHarnessContainerImage")].isNull() && m_worker_harness_container_image_isValid;

    m_zone_isValid = ::OpenAPI::fromJsonValue(m_zone, json[QString("zone")]);
    m_zone_isSet = !json[QString("zone")].isNull() && m_zone_isValid;
}

QString OAIWorkerPool::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIWorkerPool::asJsonObject() const {
    QJsonObject obj;
    if (m_autoscaling_settings.isSet()) {
        obj.insert(QString("autoscalingSettings"), ::OpenAPI::toJsonValue(m_autoscaling_settings));
    }
    if (m_data_disks.size() > 0) {
        obj.insert(QString("dataDisks"), ::OpenAPI::toJsonValue(m_data_disks));
    }
    if (m_default_package_set_isSet) {
        obj.insert(QString("defaultPackageSet"), ::OpenAPI::toJsonValue(m_default_package_set));
    }
    if (m_disk_size_gb_isSet) {
        obj.insert(QString("diskSizeGb"), ::OpenAPI::toJsonValue(m_disk_size_gb));
    }
    if (m_disk_source_image_isSet) {
        obj.insert(QString("diskSourceImage"), ::OpenAPI::toJsonValue(m_disk_source_image));
    }
    if (m_disk_type_isSet) {
        obj.insert(QString("diskType"), ::OpenAPI::toJsonValue(m_disk_type));
    }
    if (m_ip_configuration_isSet) {
        obj.insert(QString("ipConfiguration"), ::OpenAPI::toJsonValue(m_ip_configuration));
    }
    if (m_kind_isSet) {
        obj.insert(QString("kind"), ::OpenAPI::toJsonValue(m_kind));
    }
    if (m_machine_type_isSet) {
        obj.insert(QString("machineType"), ::OpenAPI::toJsonValue(m_machine_type));
    }
    if (m_metadata.size() > 0) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_network_isSet) {
        obj.insert(QString("network"), ::OpenAPI::toJsonValue(m_network));
    }
    if (m_num_threads_per_worker_isSet) {
        obj.insert(QString("numThreadsPerWorker"), ::OpenAPI::toJsonValue(m_num_threads_per_worker));
    }
    if (m_num_workers_isSet) {
        obj.insert(QString("numWorkers"), ::OpenAPI::toJsonValue(m_num_workers));
    }
    if (m_on_host_maintenance_isSet) {
        obj.insert(QString("onHostMaintenance"), ::OpenAPI::toJsonValue(m_on_host_maintenance));
    }
    if (m_packages.size() > 0) {
        obj.insert(QString("packages"), ::OpenAPI::toJsonValue(m_packages));
    }
    if (m_pool_args.size() > 0) {
        obj.insert(QString("poolArgs"), ::OpenAPI::toJsonValue(m_pool_args));
    }
    if (m_sdk_harness_container_images.size() > 0) {
        obj.insert(QString("sdkHarnessContainerImages"), ::OpenAPI::toJsonValue(m_sdk_harness_container_images));
    }
    if (m_subnetwork_isSet) {
        obj.insert(QString("subnetwork"), ::OpenAPI::toJsonValue(m_subnetwork));
    }
    if (m_taskrunner_settings.isSet()) {
        obj.insert(QString("taskrunnerSettings"), ::OpenAPI::toJsonValue(m_taskrunner_settings));
    }
    if (m_teardown_policy_isSet) {
        obj.insert(QString("teardownPolicy"), ::OpenAPI::toJsonValue(m_teardown_policy));
    }
    if (m_worker_harness_container_image_isSet) {
        obj.insert(QString("workerHarnessContainerImage"), ::OpenAPI::toJsonValue(m_worker_harness_container_image));
    }
    if (m_zone_isSet) {
        obj.insert(QString("zone"), ::OpenAPI::toJsonValue(m_zone));
    }
    return obj;
}

OAIAutoscalingSettings OAIWorkerPool::getAutoscalingSettings() const {
    return m_autoscaling_settings;
}
void OAIWorkerPool::setAutoscalingSettings(const OAIAutoscalingSettings &autoscaling_settings) {
    m_autoscaling_settings = autoscaling_settings;
    m_autoscaling_settings_isSet = true;
}

bool OAIWorkerPool::is_autoscaling_settings_Set() const{
    return m_autoscaling_settings_isSet;
}

bool OAIWorkerPool::is_autoscaling_settings_Valid() const{
    return m_autoscaling_settings_isValid;
}

QList<OAIDisk> OAIWorkerPool::getDataDisks() const {
    return m_data_disks;
}
void OAIWorkerPool::setDataDisks(const QList<OAIDisk> &data_disks) {
    m_data_disks = data_disks;
    m_data_disks_isSet = true;
}

bool OAIWorkerPool::is_data_disks_Set() const{
    return m_data_disks_isSet;
}

bool OAIWorkerPool::is_data_disks_Valid() const{
    return m_data_disks_isValid;
}

QString OAIWorkerPool::getDefaultPackageSet() const {
    return m_default_package_set;
}
void OAIWorkerPool::setDefaultPackageSet(const QString &default_package_set) {
    m_default_package_set = default_package_set;
    m_default_package_set_isSet = true;
}

bool OAIWorkerPool::is_default_package_set_Set() const{
    return m_default_package_set_isSet;
}

bool OAIWorkerPool::is_default_package_set_Valid() const{
    return m_default_package_set_isValid;
}

qint32 OAIWorkerPool::getDiskSizeGb() const {
    return m_disk_size_gb;
}
void OAIWorkerPool::setDiskSizeGb(const qint32 &disk_size_gb) {
    m_disk_size_gb = disk_size_gb;
    m_disk_size_gb_isSet = true;
}

bool OAIWorkerPool::is_disk_size_gb_Set() const{
    return m_disk_size_gb_isSet;
}

bool OAIWorkerPool::is_disk_size_gb_Valid() const{
    return m_disk_size_gb_isValid;
}

QString OAIWorkerPool::getDiskSourceImage() const {
    return m_disk_source_image;
}
void OAIWorkerPool::setDiskSourceImage(const QString &disk_source_image) {
    m_disk_source_image = disk_source_image;
    m_disk_source_image_isSet = true;
}

bool OAIWorkerPool::is_disk_source_image_Set() const{
    return m_disk_source_image_isSet;
}

bool OAIWorkerPool::is_disk_source_image_Valid() const{
    return m_disk_source_image_isValid;
}

QString OAIWorkerPool::getDiskType() const {
    return m_disk_type;
}
void OAIWorkerPool::setDiskType(const QString &disk_type) {
    m_disk_type = disk_type;
    m_disk_type_isSet = true;
}

bool OAIWorkerPool::is_disk_type_Set() const{
    return m_disk_type_isSet;
}

bool OAIWorkerPool::is_disk_type_Valid() const{
    return m_disk_type_isValid;
}

QString OAIWorkerPool::getIpConfiguration() const {
    return m_ip_configuration;
}
void OAIWorkerPool::setIpConfiguration(const QString &ip_configuration) {
    m_ip_configuration = ip_configuration;
    m_ip_configuration_isSet = true;
}

bool OAIWorkerPool::is_ip_configuration_Set() const{
    return m_ip_configuration_isSet;
}

bool OAIWorkerPool::is_ip_configuration_Valid() const{
    return m_ip_configuration_isValid;
}

QString OAIWorkerPool::getKind() const {
    return m_kind;
}
void OAIWorkerPool::setKind(const QString &kind) {
    m_kind = kind;
    m_kind_isSet = true;
}

bool OAIWorkerPool::is_kind_Set() const{
    return m_kind_isSet;
}

bool OAIWorkerPool::is_kind_Valid() const{
    return m_kind_isValid;
}

QString OAIWorkerPool::getMachineType() const {
    return m_machine_type;
}
void OAIWorkerPool::setMachineType(const QString &machine_type) {
    m_machine_type = machine_type;
    m_machine_type_isSet = true;
}

bool OAIWorkerPool::is_machine_type_Set() const{
    return m_machine_type_isSet;
}

bool OAIWorkerPool::is_machine_type_Valid() const{
    return m_machine_type_isValid;
}

QMap<QString, QString> OAIWorkerPool::getMetadata() const {
    return m_metadata;
}
void OAIWorkerPool::setMetadata(const QMap<QString, QString> &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAIWorkerPool::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAIWorkerPool::is_metadata_Valid() const{
    return m_metadata_isValid;
}

QString OAIWorkerPool::getNetwork() const {
    return m_network;
}
void OAIWorkerPool::setNetwork(const QString &network) {
    m_network = network;
    m_network_isSet = true;
}

bool OAIWorkerPool::is_network_Set() const{
    return m_network_isSet;
}

bool OAIWorkerPool::is_network_Valid() const{
    return m_network_isValid;
}

qint32 OAIWorkerPool::getNumThreadsPerWorker() const {
    return m_num_threads_per_worker;
}
void OAIWorkerPool::setNumThreadsPerWorker(const qint32 &num_threads_per_worker) {
    m_num_threads_per_worker = num_threads_per_worker;
    m_num_threads_per_worker_isSet = true;
}

bool OAIWorkerPool::is_num_threads_per_worker_Set() const{
    return m_num_threads_per_worker_isSet;
}

bool OAIWorkerPool::is_num_threads_per_worker_Valid() const{
    return m_num_threads_per_worker_isValid;
}

qint32 OAIWorkerPool::getNumWorkers() const {
    return m_num_workers;
}
void OAIWorkerPool::setNumWorkers(const qint32 &num_workers) {
    m_num_workers = num_workers;
    m_num_workers_isSet = true;
}

bool OAIWorkerPool::is_num_workers_Set() const{
    return m_num_workers_isSet;
}

bool OAIWorkerPool::is_num_workers_Valid() const{
    return m_num_workers_isValid;
}

QString OAIWorkerPool::getOnHostMaintenance() const {
    return m_on_host_maintenance;
}
void OAIWorkerPool::setOnHostMaintenance(const QString &on_host_maintenance) {
    m_on_host_maintenance = on_host_maintenance;
    m_on_host_maintenance_isSet = true;
}

bool OAIWorkerPool::is_on_host_maintenance_Set() const{
    return m_on_host_maintenance_isSet;
}

bool OAIWorkerPool::is_on_host_maintenance_Valid() const{
    return m_on_host_maintenance_isValid;
}

QList<OAIPackage> OAIWorkerPool::getPackages() const {
    return m_packages;
}
void OAIWorkerPool::setPackages(const QList<OAIPackage> &packages) {
    m_packages = packages;
    m_packages_isSet = true;
}

bool OAIWorkerPool::is_packages_Set() const{
    return m_packages_isSet;
}

bool OAIWorkerPool::is_packages_Valid() const{
    return m_packages_isValid;
}

QMap<QString, QJsonValue> OAIWorkerPool::getPoolArgs() const {
    return m_pool_args;
}
void OAIWorkerPool::setPoolArgs(const QMap<QString, QJsonValue> &pool_args) {
    m_pool_args = pool_args;
    m_pool_args_isSet = true;
}

bool OAIWorkerPool::is_pool_args_Set() const{
    return m_pool_args_isSet;
}

bool OAIWorkerPool::is_pool_args_Valid() const{
    return m_pool_args_isValid;
}

QList<OAISdkHarnessContainerImage> OAIWorkerPool::getSdkHarnessContainerImages() const {
    return m_sdk_harness_container_images;
}
void OAIWorkerPool::setSdkHarnessContainerImages(const QList<OAISdkHarnessContainerImage> &sdk_harness_container_images) {
    m_sdk_harness_container_images = sdk_harness_container_images;
    m_sdk_harness_container_images_isSet = true;
}

bool OAIWorkerPool::is_sdk_harness_container_images_Set() const{
    return m_sdk_harness_container_images_isSet;
}

bool OAIWorkerPool::is_sdk_harness_container_images_Valid() const{
    return m_sdk_harness_container_images_isValid;
}

QString OAIWorkerPool::getSubnetwork() const {
    return m_subnetwork;
}
void OAIWorkerPool::setSubnetwork(const QString &subnetwork) {
    m_subnetwork = subnetwork;
    m_subnetwork_isSet = true;
}

bool OAIWorkerPool::is_subnetwork_Set() const{
    return m_subnetwork_isSet;
}

bool OAIWorkerPool::is_subnetwork_Valid() const{
    return m_subnetwork_isValid;
}

OAITaskRunnerSettings OAIWorkerPool::getTaskrunnerSettings() const {
    return m_taskrunner_settings;
}
void OAIWorkerPool::setTaskrunnerSettings(const OAITaskRunnerSettings &taskrunner_settings) {
    m_taskrunner_settings = taskrunner_settings;
    m_taskrunner_settings_isSet = true;
}

bool OAIWorkerPool::is_taskrunner_settings_Set() const{
    return m_taskrunner_settings_isSet;
}

bool OAIWorkerPool::is_taskrunner_settings_Valid() const{
    return m_taskrunner_settings_isValid;
}

QString OAIWorkerPool::getTeardownPolicy() const {
    return m_teardown_policy;
}
void OAIWorkerPool::setTeardownPolicy(const QString &teardown_policy) {
    m_teardown_policy = teardown_policy;
    m_teardown_policy_isSet = true;
}

bool OAIWorkerPool::is_teardown_policy_Set() const{
    return m_teardown_policy_isSet;
}

bool OAIWorkerPool::is_teardown_policy_Valid() const{
    return m_teardown_policy_isValid;
}

QString OAIWorkerPool::getWorkerHarnessContainerImage() const {
    return m_worker_harness_container_image;
}
void OAIWorkerPool::setWorkerHarnessContainerImage(const QString &worker_harness_container_image) {
    m_worker_harness_container_image = worker_harness_container_image;
    m_worker_harness_container_image_isSet = true;
}

bool OAIWorkerPool::is_worker_harness_container_image_Set() const{
    return m_worker_harness_container_image_isSet;
}

bool OAIWorkerPool::is_worker_harness_container_image_Valid() const{
    return m_worker_harness_container_image_isValid;
}

QString OAIWorkerPool::getZone() const {
    return m_zone;
}
void OAIWorkerPool::setZone(const QString &zone) {
    m_zone = zone;
    m_zone_isSet = true;
}

bool OAIWorkerPool::is_zone_Set() const{
    return m_zone_isSet;
}

bool OAIWorkerPool::is_zone_Valid() const{
    return m_zone_isValid;
}

bool OAIWorkerPool::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_autoscaling_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_disks.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_package_set_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_source_image_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_configuration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_machine_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_threads_per_worker_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_workers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_on_host_maintenance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_packages.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_pool_args.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_sdk_harness_container_images.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_subnetwork_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_taskrunner_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_teardown_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_worker_harness_container_image_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIWorkerPool::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
