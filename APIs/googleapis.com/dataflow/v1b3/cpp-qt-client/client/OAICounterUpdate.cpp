/**
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICounterUpdate.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICounterUpdate::OAICounterUpdate(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICounterUpdate::OAICounterUpdate() {
    this->initializeModel();
}

OAICounterUpdate::~OAICounterUpdate() {}

void OAICounterUpdate::initializeModel() {

    m_boolean_isSet = false;
    m_boolean_isValid = false;

    m_cumulative_isSet = false;
    m_cumulative_isValid = false;

    m_distribution_isSet = false;
    m_distribution_isValid = false;

    m_floating_point_isSet = false;
    m_floating_point_isValid = false;

    m_floating_point_list_isSet = false;
    m_floating_point_list_isValid = false;

    m_floating_point_mean_isSet = false;
    m_floating_point_mean_isValid = false;

    m_integer_isSet = false;
    m_integer_isValid = false;

    m_integer_gauge_isSet = false;
    m_integer_gauge_isValid = false;

    m_integer_list_isSet = false;
    m_integer_list_isValid = false;

    m_integer_mean_isSet = false;
    m_integer_mean_isValid = false;

    m_internal_isSet = false;
    m_internal_isValid = false;

    m_name_and_kind_isSet = false;
    m_name_and_kind_isValid = false;

    m_short_id_isSet = false;
    m_short_id_isValid = false;

    m_string_list_isSet = false;
    m_string_list_isValid = false;

    m_structured_name_and_metadata_isSet = false;
    m_structured_name_and_metadata_isValid = false;
}

void OAICounterUpdate::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICounterUpdate::fromJsonObject(QJsonObject json) {

    m_boolean_isValid = ::OpenAPI::fromJsonValue(m_boolean, json[QString("boolean")]);
    m_boolean_isSet = !json[QString("boolean")].isNull() && m_boolean_isValid;

    m_cumulative_isValid = ::OpenAPI::fromJsonValue(m_cumulative, json[QString("cumulative")]);
    m_cumulative_isSet = !json[QString("cumulative")].isNull() && m_cumulative_isValid;

    m_distribution_isValid = ::OpenAPI::fromJsonValue(m_distribution, json[QString("distribution")]);
    m_distribution_isSet = !json[QString("distribution")].isNull() && m_distribution_isValid;

    m_floating_point_isValid = ::OpenAPI::fromJsonValue(m_floating_point, json[QString("floatingPoint")]);
    m_floating_point_isSet = !json[QString("floatingPoint")].isNull() && m_floating_point_isValid;

    m_floating_point_list_isValid = ::OpenAPI::fromJsonValue(m_floating_point_list, json[QString("floatingPointList")]);
    m_floating_point_list_isSet = !json[QString("floatingPointList")].isNull() && m_floating_point_list_isValid;

    m_floating_point_mean_isValid = ::OpenAPI::fromJsonValue(m_floating_point_mean, json[QString("floatingPointMean")]);
    m_floating_point_mean_isSet = !json[QString("floatingPointMean")].isNull() && m_floating_point_mean_isValid;

    m_integer_isValid = ::OpenAPI::fromJsonValue(m_integer, json[QString("integer")]);
    m_integer_isSet = !json[QString("integer")].isNull() && m_integer_isValid;

    m_integer_gauge_isValid = ::OpenAPI::fromJsonValue(m_integer_gauge, json[QString("integerGauge")]);
    m_integer_gauge_isSet = !json[QString("integerGauge")].isNull() && m_integer_gauge_isValid;

    m_integer_list_isValid = ::OpenAPI::fromJsonValue(m_integer_list, json[QString("integerList")]);
    m_integer_list_isSet = !json[QString("integerList")].isNull() && m_integer_list_isValid;

    m_integer_mean_isValid = ::OpenAPI::fromJsonValue(m_integer_mean, json[QString("integerMean")]);
    m_integer_mean_isSet = !json[QString("integerMean")].isNull() && m_integer_mean_isValid;

    m_internal_isValid = ::OpenAPI::fromJsonValue(m_internal, json[QString("internal")]);
    m_internal_isSet = !json[QString("internal")].isNull() && m_internal_isValid;

    m_name_and_kind_isValid = ::OpenAPI::fromJsonValue(m_name_and_kind, json[QString("nameAndKind")]);
    m_name_and_kind_isSet = !json[QString("nameAndKind")].isNull() && m_name_and_kind_isValid;

    m_short_id_isValid = ::OpenAPI::fromJsonValue(m_short_id, json[QString("shortId")]);
    m_short_id_isSet = !json[QString("shortId")].isNull() && m_short_id_isValid;

    m_string_list_isValid = ::OpenAPI::fromJsonValue(m_string_list, json[QString("stringList")]);
    m_string_list_isSet = !json[QString("stringList")].isNull() && m_string_list_isValid;

    m_structured_name_and_metadata_isValid = ::OpenAPI::fromJsonValue(m_structured_name_and_metadata, json[QString("structuredNameAndMetadata")]);
    m_structured_name_and_metadata_isSet = !json[QString("structuredNameAndMetadata")].isNull() && m_structured_name_and_metadata_isValid;
}

QString OAICounterUpdate::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICounterUpdate::asJsonObject() const {
    QJsonObject obj;
    if (m_boolean_isSet) {
        obj.insert(QString("boolean"), ::OpenAPI::toJsonValue(m_boolean));
    }
    if (m_cumulative_isSet) {
        obj.insert(QString("cumulative"), ::OpenAPI::toJsonValue(m_cumulative));
    }
    if (m_distribution.isSet()) {
        obj.insert(QString("distribution"), ::OpenAPI::toJsonValue(m_distribution));
    }
    if (m_floating_point_isSet) {
        obj.insert(QString("floatingPoint"), ::OpenAPI::toJsonValue(m_floating_point));
    }
    if (m_floating_point_list.isSet()) {
        obj.insert(QString("floatingPointList"), ::OpenAPI::toJsonValue(m_floating_point_list));
    }
    if (m_floating_point_mean.isSet()) {
        obj.insert(QString("floatingPointMean"), ::OpenAPI::toJsonValue(m_floating_point_mean));
    }
    if (m_integer.isSet()) {
        obj.insert(QString("integer"), ::OpenAPI::toJsonValue(m_integer));
    }
    if (m_integer_gauge.isSet()) {
        obj.insert(QString("integerGauge"), ::OpenAPI::toJsonValue(m_integer_gauge));
    }
    if (m_integer_list.isSet()) {
        obj.insert(QString("integerList"), ::OpenAPI::toJsonValue(m_integer_list));
    }
    if (m_integer_mean.isSet()) {
        obj.insert(QString("integerMean"), ::OpenAPI::toJsonValue(m_integer_mean));
    }
    if (m_internal_isSet) {
        obj.insert(QString("internal"), ::OpenAPI::toJsonValue(m_internal));
    }
    if (m_name_and_kind.isSet()) {
        obj.insert(QString("nameAndKind"), ::OpenAPI::toJsonValue(m_name_and_kind));
    }
    if (m_short_id_isSet) {
        obj.insert(QString("shortId"), ::OpenAPI::toJsonValue(m_short_id));
    }
    if (m_string_list.isSet()) {
        obj.insert(QString("stringList"), ::OpenAPI::toJsonValue(m_string_list));
    }
    if (m_structured_name_and_metadata.isSet()) {
        obj.insert(QString("structuredNameAndMetadata"), ::OpenAPI::toJsonValue(m_structured_name_and_metadata));
    }
    return obj;
}

bool OAICounterUpdate::isBoolean() const {
    return m_boolean;
}
void OAICounterUpdate::setBoolean(const bool &boolean) {
    m_boolean = boolean;
    m_boolean_isSet = true;
}

bool OAICounterUpdate::is_boolean_Set() const{
    return m_boolean_isSet;
}

bool OAICounterUpdate::is_boolean_Valid() const{
    return m_boolean_isValid;
}

bool OAICounterUpdate::isCumulative() const {
    return m_cumulative;
}
void OAICounterUpdate::setCumulative(const bool &cumulative) {
    m_cumulative = cumulative;
    m_cumulative_isSet = true;
}

bool OAICounterUpdate::is_cumulative_Set() const{
    return m_cumulative_isSet;
}

bool OAICounterUpdate::is_cumulative_Valid() const{
    return m_cumulative_isValid;
}

OAIDistributionUpdate OAICounterUpdate::getDistribution() const {
    return m_distribution;
}
void OAICounterUpdate::setDistribution(const OAIDistributionUpdate &distribution) {
    m_distribution = distribution;
    m_distribution_isSet = true;
}

bool OAICounterUpdate::is_distribution_Set() const{
    return m_distribution_isSet;
}

bool OAICounterUpdate::is_distribution_Valid() const{
    return m_distribution_isValid;
}

double OAICounterUpdate::getFloatingPoint() const {
    return m_floating_point;
}
void OAICounterUpdate::setFloatingPoint(const double &floating_point) {
    m_floating_point = floating_point;
    m_floating_point_isSet = true;
}

bool OAICounterUpdate::is_floating_point_Set() const{
    return m_floating_point_isSet;
}

bool OAICounterUpdate::is_floating_point_Valid() const{
    return m_floating_point_isValid;
}

OAIFloatingPointList OAICounterUpdate::getFloatingPointList() const {
    return m_floating_point_list;
}
void OAICounterUpdate::setFloatingPointList(const OAIFloatingPointList &floating_point_list) {
    m_floating_point_list = floating_point_list;
    m_floating_point_list_isSet = true;
}

bool OAICounterUpdate::is_floating_point_list_Set() const{
    return m_floating_point_list_isSet;
}

bool OAICounterUpdate::is_floating_point_list_Valid() const{
    return m_floating_point_list_isValid;
}

OAIFloatingPointMean OAICounterUpdate::getFloatingPointMean() const {
    return m_floating_point_mean;
}
void OAICounterUpdate::setFloatingPointMean(const OAIFloatingPointMean &floating_point_mean) {
    m_floating_point_mean = floating_point_mean;
    m_floating_point_mean_isSet = true;
}

bool OAICounterUpdate::is_floating_point_mean_Set() const{
    return m_floating_point_mean_isSet;
}

bool OAICounterUpdate::is_floating_point_mean_Valid() const{
    return m_floating_point_mean_isValid;
}

OAISplitInt64 OAICounterUpdate::getInteger() const {
    return m_integer;
}
void OAICounterUpdate::setInteger(const OAISplitInt64 &integer) {
    m_integer = integer;
    m_integer_isSet = true;
}

bool OAICounterUpdate::is_integer_Set() const{
    return m_integer_isSet;
}

bool OAICounterUpdate::is_integer_Valid() const{
    return m_integer_isValid;
}

OAIIntegerGauge OAICounterUpdate::getIntegerGauge() const {
    return m_integer_gauge;
}
void OAICounterUpdate::setIntegerGauge(const OAIIntegerGauge &integer_gauge) {
    m_integer_gauge = integer_gauge;
    m_integer_gauge_isSet = true;
}

bool OAICounterUpdate::is_integer_gauge_Set() const{
    return m_integer_gauge_isSet;
}

bool OAICounterUpdate::is_integer_gauge_Valid() const{
    return m_integer_gauge_isValid;
}

OAIIntegerList OAICounterUpdate::getIntegerList() const {
    return m_integer_list;
}
void OAICounterUpdate::setIntegerList(const OAIIntegerList &integer_list) {
    m_integer_list = integer_list;
    m_integer_list_isSet = true;
}

bool OAICounterUpdate::is_integer_list_Set() const{
    return m_integer_list_isSet;
}

bool OAICounterUpdate::is_integer_list_Valid() const{
    return m_integer_list_isValid;
}

OAIIntegerMean OAICounterUpdate::getIntegerMean() const {
    return m_integer_mean;
}
void OAICounterUpdate::setIntegerMean(const OAIIntegerMean &integer_mean) {
    m_integer_mean = integer_mean;
    m_integer_mean_isSet = true;
}

bool OAICounterUpdate::is_integer_mean_Set() const{
    return m_integer_mean_isSet;
}

bool OAICounterUpdate::is_integer_mean_Valid() const{
    return m_integer_mean_isValid;
}

QJsonValue OAICounterUpdate::getInternal() const {
    return m_internal;
}
void OAICounterUpdate::setInternal(const QJsonValue &internal) {
    m_internal = internal;
    m_internal_isSet = true;
}

bool OAICounterUpdate::is_internal_Set() const{
    return m_internal_isSet;
}

bool OAICounterUpdate::is_internal_Valid() const{
    return m_internal_isValid;
}

OAINameAndKind OAICounterUpdate::getNameAndKind() const {
    return m_name_and_kind;
}
void OAICounterUpdate::setNameAndKind(const OAINameAndKind &name_and_kind) {
    m_name_and_kind = name_and_kind;
    m_name_and_kind_isSet = true;
}

bool OAICounterUpdate::is_name_and_kind_Set() const{
    return m_name_and_kind_isSet;
}

bool OAICounterUpdate::is_name_and_kind_Valid() const{
    return m_name_and_kind_isValid;
}

QString OAICounterUpdate::getShortId() const {
    return m_short_id;
}
void OAICounterUpdate::setShortId(const QString &short_id) {
    m_short_id = short_id;
    m_short_id_isSet = true;
}

bool OAICounterUpdate::is_short_id_Set() const{
    return m_short_id_isSet;
}

bool OAICounterUpdate::is_short_id_Valid() const{
    return m_short_id_isValid;
}

OAIStringList OAICounterUpdate::getStringList() const {
    return m_string_list;
}
void OAICounterUpdate::setStringList(const OAIStringList &string_list) {
    m_string_list = string_list;
    m_string_list_isSet = true;
}

bool OAICounterUpdate::is_string_list_Set() const{
    return m_string_list_isSet;
}

bool OAICounterUpdate::is_string_list_Valid() const{
    return m_string_list_isValid;
}

OAICounterStructuredNameAndMetadata OAICounterUpdate::getStructuredNameAndMetadata() const {
    return m_structured_name_and_metadata;
}
void OAICounterUpdate::setStructuredNameAndMetadata(const OAICounterStructuredNameAndMetadata &structured_name_and_metadata) {
    m_structured_name_and_metadata = structured_name_and_metadata;
    m_structured_name_and_metadata_isSet = true;
}

bool OAICounterUpdate::is_structured_name_and_metadata_Set() const{
    return m_structured_name_and_metadata_isSet;
}

bool OAICounterUpdate::is_structured_name_and_metadata_Valid() const{
    return m_structured_name_and_metadata_isValid;
}

bool OAICounterUpdate::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_boolean_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cumulative_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_distribution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_floating_point_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_floating_point_list.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_floating_point_mean.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_integer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_integer_gauge.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_integer_list.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_integer_mean.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_internal_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_and_kind.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_short_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_string_list.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_structured_name_and_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICounterUpdate::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
