/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The environment values to be set at runtime for flex template. LINT.IfChange
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FlexTemplateRuntimeEnvironment {
  public static final String SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS = "additionalExperiments";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS)
  private List<String> additionalExperiments = new ArrayList<>();

  public static final String SERIALIZED_NAME_ADDITIONAL_USER_LABELS = "additionalUserLabels";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_USER_LABELS)
  private Map<String, String> additionalUserLabels = new HashMap<>();

  /**
   * The algorithm to use for autoscaling
   */
  @JsonAdapter(AutoscalingAlgorithmEnum.Adapter.class)
  public enum AutoscalingAlgorithmEnum {
    UNKNOWN("AUTOSCALING_ALGORITHM_UNKNOWN"),
    
    NONE("AUTOSCALING_ALGORITHM_NONE"),
    
    BASIC("AUTOSCALING_ALGORITHM_BASIC");

    private String value;

    AutoscalingAlgorithmEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AutoscalingAlgorithmEnum fromValue(String value) {
      for (AutoscalingAlgorithmEnum b : AutoscalingAlgorithmEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AutoscalingAlgorithmEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AutoscalingAlgorithmEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AutoscalingAlgorithmEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AutoscalingAlgorithmEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AutoscalingAlgorithmEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AUTOSCALING_ALGORITHM = "autoscalingAlgorithm";
  @SerializedName(SERIALIZED_NAME_AUTOSCALING_ALGORITHM)
  private AutoscalingAlgorithmEnum autoscalingAlgorithm;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_DUMP_HEAP_ON_OOM = "dumpHeapOnOom";
  @SerializedName(SERIALIZED_NAME_DUMP_HEAP_ON_OOM)
  private Boolean dumpHeapOnOom;

  public static final String SERIALIZED_NAME_ENABLE_LAUNCHER_VM_SERIAL_PORT_LOGGING = "enableLauncherVmSerialPortLogging";
  @SerializedName(SERIALIZED_NAME_ENABLE_LAUNCHER_VM_SERIAL_PORT_LOGGING)
  private Boolean enableLauncherVmSerialPortLogging;

  public static final String SERIALIZED_NAME_ENABLE_STREAMING_ENGINE = "enableStreamingEngine";
  @SerializedName(SERIALIZED_NAME_ENABLE_STREAMING_ENGINE)
  private Boolean enableStreamingEngine;

  /**
   * Set FlexRS goal for the job. https://cloud.google.com/dataflow/docs/guides/flexrs
   */
  @JsonAdapter(FlexrsGoalEnum.Adapter.class)
  public enum FlexrsGoalEnum {
    UNSPECIFIED("FLEXRS_UNSPECIFIED"),
    
    SPEED_OPTIMIZED("FLEXRS_SPEED_OPTIMIZED"),
    
    COST_OPTIMIZED("FLEXRS_COST_OPTIMIZED");

    private String value;

    FlexrsGoalEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FlexrsGoalEnum fromValue(String value) {
      for (FlexrsGoalEnum b : FlexrsGoalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FlexrsGoalEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FlexrsGoalEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FlexrsGoalEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FlexrsGoalEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FlexrsGoalEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FLEXRS_GOAL = "flexrsGoal";
  @SerializedName(SERIALIZED_NAME_FLEXRS_GOAL)
  private FlexrsGoalEnum flexrsGoal;

  /**
   * Configuration for VM IPs.
   */
  @JsonAdapter(IpConfigurationEnum.Adapter.class)
  public enum IpConfigurationEnum {
    UNSPECIFIED("WORKER_IP_UNSPECIFIED"),
    
    PUBLIC("WORKER_IP_PUBLIC"),
    
    PRIVATE("WORKER_IP_PRIVATE");

    private String value;

    IpConfigurationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IpConfigurationEnum fromValue(String value) {
      for (IpConfigurationEnum b : IpConfigurationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IpConfigurationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IpConfigurationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IpConfigurationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IpConfigurationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IpConfigurationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IP_CONFIGURATION = "ipConfiguration";
  @SerializedName(SERIALIZED_NAME_IP_CONFIGURATION)
  private IpConfigurationEnum ipConfiguration;

  public static final String SERIALIZED_NAME_KMS_KEY_NAME = "kmsKeyName";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_NAME)
  private String kmsKeyName;

  public static final String SERIALIZED_NAME_LAUNCHER_MACHINE_TYPE = "launcherMachineType";
  @SerializedName(SERIALIZED_NAME_LAUNCHER_MACHINE_TYPE)
  private String launcherMachineType;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_MAX_WORKERS = "maxWorkers";
  @SerializedName(SERIALIZED_NAME_MAX_WORKERS)
  private Integer maxWorkers;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_NUM_WORKERS = "numWorkers";
  @SerializedName(SERIALIZED_NAME_NUM_WORKERS)
  private Integer numWorkers;

  public static final String SERIALIZED_NAME_SAVE_HEAP_DUMPS_TO_GCS_PATH = "saveHeapDumpsToGcsPath";
  @SerializedName(SERIALIZED_NAME_SAVE_HEAP_DUMPS_TO_GCS_PATH)
  private String saveHeapDumpsToGcsPath;

  public static final String SERIALIZED_NAME_SDK_CONTAINER_IMAGE = "sdkContainerImage";
  @SerializedName(SERIALIZED_NAME_SDK_CONTAINER_IMAGE)
  private String sdkContainerImage;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL = "serviceAccountEmail";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL)
  private String serviceAccountEmail;

  public static final String SERIALIZED_NAME_STAGING_LOCATION = "stagingLocation";
  @SerializedName(SERIALIZED_NAME_STAGING_LOCATION)
  private String stagingLocation;

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   */
  @JsonAdapter(StreamingModeEnum.Adapter.class)
  public enum StreamingModeEnum {
    UNSPECIFIED("STREAMING_MODE_UNSPECIFIED"),
    
    EXACTLY_ONCE("STREAMING_MODE_EXACTLY_ONCE"),
    
    AT_LEAST_ONCE("STREAMING_MODE_AT_LEAST_ONCE");

    private String value;

    StreamingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StreamingModeEnum fromValue(String value) {
      for (StreamingModeEnum b : StreamingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StreamingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StreamingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StreamingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StreamingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StreamingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STREAMING_MODE = "streamingMode";
  @SerializedName(SERIALIZED_NAME_STREAMING_MODE)
  private StreamingModeEnum streamingMode;

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_TEMP_LOCATION = "tempLocation";
  @SerializedName(SERIALIZED_NAME_TEMP_LOCATION)
  private String tempLocation;

  public static final String SERIALIZED_NAME_WORKER_REGION = "workerRegion";
  @SerializedName(SERIALIZED_NAME_WORKER_REGION)
  private String workerRegion;

  public static final String SERIALIZED_NAME_WORKER_ZONE = "workerZone";
  @SerializedName(SERIALIZED_NAME_WORKER_ZONE)
  private String workerZone;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public FlexTemplateRuntimeEnvironment() {
  }

  public FlexTemplateRuntimeEnvironment additionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
    return this;
  }

  public FlexTemplateRuntimeEnvironment addAdditionalExperimentsItem(String additionalExperimentsItem) {
    if (this.additionalExperiments == null) {
      this.additionalExperiments = new ArrayList<>();
    }
    this.additionalExperiments.add(additionalExperimentsItem);
    return this;
  }

  /**
   * Additional experiment flags for the job.
   * @return additionalExperiments
   */
  @javax.annotation.Nullable
  public List<String> getAdditionalExperiments() {
    return additionalExperiments;
  }

  public void setAdditionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
  }


  public FlexTemplateRuntimeEnvironment additionalUserLabels(Map<String, String> additionalUserLabels) {
    this.additionalUserLabels = additionalUserLabels;
    return this;
  }

  public FlexTemplateRuntimeEnvironment putAdditionalUserLabelsItem(String key, String additionalUserLabelsItem) {
    if (this.additionalUserLabels == null) {
      this.additionalUserLabels = new HashMap<>();
    }
    this.additionalUserLabels.put(key, additionalUserLabelsItem);
    return this;
  }

  /**
   * Additional user labels to be specified for the job. Keys and values must follow the restrictions specified in the [labeling restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) page. An object containing a list of \&quot;key\&quot;: value pairs. Example: { \&quot;name\&quot;: \&quot;wrench\&quot;, \&quot;mass\&quot;: \&quot;1kg\&quot;, \&quot;count\&quot;: \&quot;3\&quot; }.
   * @return additionalUserLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getAdditionalUserLabels() {
    return additionalUserLabels;
  }

  public void setAdditionalUserLabels(Map<String, String> additionalUserLabels) {
    this.additionalUserLabels = additionalUserLabels;
  }


  public FlexTemplateRuntimeEnvironment autoscalingAlgorithm(AutoscalingAlgorithmEnum autoscalingAlgorithm) {
    this.autoscalingAlgorithm = autoscalingAlgorithm;
    return this;
  }

  /**
   * The algorithm to use for autoscaling
   * @return autoscalingAlgorithm
   */
  @javax.annotation.Nullable
  public AutoscalingAlgorithmEnum getAutoscalingAlgorithm() {
    return autoscalingAlgorithm;
  }

  public void setAutoscalingAlgorithm(AutoscalingAlgorithmEnum autoscalingAlgorithm) {
    this.autoscalingAlgorithm = autoscalingAlgorithm;
  }


  public FlexTemplateRuntimeEnvironment diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Worker disk size, in gigabytes.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public FlexTemplateRuntimeEnvironment dumpHeapOnOom(Boolean dumpHeapOnOom) {
    this.dumpHeapOnOom = dumpHeapOnOom;
    return this;
  }

  /**
   * If true, when processing time is spent almost entirely on garbage collection (GC), saves a heap dump before ending the thread or process. If false, ends the thread or process without saving a heap dump. Does not save a heap dump when the Java Virtual Machine (JVM) has an out of memory error during processing. The location of the heap file is either echoed back to the user, or the user is given the opportunity to download the heap file.
   * @return dumpHeapOnOom
   */
  @javax.annotation.Nullable
  public Boolean getDumpHeapOnOom() {
    return dumpHeapOnOom;
  }

  public void setDumpHeapOnOom(Boolean dumpHeapOnOom) {
    this.dumpHeapOnOom = dumpHeapOnOom;
  }


  public FlexTemplateRuntimeEnvironment enableLauncherVmSerialPortLogging(Boolean enableLauncherVmSerialPortLogging) {
    this.enableLauncherVmSerialPortLogging = enableLauncherVmSerialPortLogging;
    return this;
  }

  /**
   * If true serial port logging will be enabled for the launcher VM.
   * @return enableLauncherVmSerialPortLogging
   */
  @javax.annotation.Nullable
  public Boolean getEnableLauncherVmSerialPortLogging() {
    return enableLauncherVmSerialPortLogging;
  }

  public void setEnableLauncherVmSerialPortLogging(Boolean enableLauncherVmSerialPortLogging) {
    this.enableLauncherVmSerialPortLogging = enableLauncherVmSerialPortLogging;
  }


  public FlexTemplateRuntimeEnvironment enableStreamingEngine(Boolean enableStreamingEngine) {
    this.enableStreamingEngine = enableStreamingEngine;
    return this;
  }

  /**
   * Whether to enable Streaming Engine for the job.
   * @return enableStreamingEngine
   */
  @javax.annotation.Nullable
  public Boolean getEnableStreamingEngine() {
    return enableStreamingEngine;
  }

  public void setEnableStreamingEngine(Boolean enableStreamingEngine) {
    this.enableStreamingEngine = enableStreamingEngine;
  }


  public FlexTemplateRuntimeEnvironment flexrsGoal(FlexrsGoalEnum flexrsGoal) {
    this.flexrsGoal = flexrsGoal;
    return this;
  }

  /**
   * Set FlexRS goal for the job. https://cloud.google.com/dataflow/docs/guides/flexrs
   * @return flexrsGoal
   */
  @javax.annotation.Nullable
  public FlexrsGoalEnum getFlexrsGoal() {
    return flexrsGoal;
  }

  public void setFlexrsGoal(FlexrsGoalEnum flexrsGoal) {
    this.flexrsGoal = flexrsGoal;
  }


  public FlexTemplateRuntimeEnvironment ipConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
    return this;
  }

  /**
   * Configuration for VM IPs.
   * @return ipConfiguration
   */
  @javax.annotation.Nullable
  public IpConfigurationEnum getIpConfiguration() {
    return ipConfiguration;
  }

  public void setIpConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
  }


  public FlexTemplateRuntimeEnvironment kmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
    return this;
  }

  /**
   * Name for the Cloud KMS key for the job. Key format is: projects//locations//keyRings//cryptoKeys/
   * @return kmsKeyName
   */
  @javax.annotation.Nullable
  public String getKmsKeyName() {
    return kmsKeyName;
  }

  public void setKmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
  }


  public FlexTemplateRuntimeEnvironment launcherMachineType(String launcherMachineType) {
    this.launcherMachineType = launcherMachineType;
    return this;
  }

  /**
   * The machine type to use for launching the job. The default is n1-standard-1.
   * @return launcherMachineType
   */
  @javax.annotation.Nullable
  public String getLauncherMachineType() {
    return launcherMachineType;
  }

  public void setLauncherMachineType(String launcherMachineType) {
    this.launcherMachineType = launcherMachineType;
  }


  public FlexTemplateRuntimeEnvironment machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * The machine type to use for the job. Defaults to the value from the template if not specified.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public FlexTemplateRuntimeEnvironment maxWorkers(Integer maxWorkers) {
    this.maxWorkers = maxWorkers;
    return this;
  }

  /**
   * The maximum number of Google Compute Engine instances to be made available to your pipeline during execution, from 1 to 1000.
   * @return maxWorkers
   */
  @javax.annotation.Nullable
  public Integer getMaxWorkers() {
    return maxWorkers;
  }

  public void setMaxWorkers(Integer maxWorkers) {
    this.maxWorkers = maxWorkers;
  }


  public FlexTemplateRuntimeEnvironment network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Network to which VMs will be assigned. If empty or unspecified, the service will use the network \&quot;default\&quot;.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public FlexTemplateRuntimeEnvironment numWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
    return this;
  }

  /**
   * The initial number of Google Compute Engine instances for the job.
   * @return numWorkers
   */
  @javax.annotation.Nullable
  public Integer getNumWorkers() {
    return numWorkers;
  }

  public void setNumWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
  }


  public FlexTemplateRuntimeEnvironment saveHeapDumpsToGcsPath(String saveHeapDumpsToGcsPath) {
    this.saveHeapDumpsToGcsPath = saveHeapDumpsToGcsPath;
    return this;
  }

  /**
   * Cloud Storage bucket (directory) to upload heap dumps to. Enabling this field implies that &#x60;dump_heap_on_oom&#x60; is set to true.
   * @return saveHeapDumpsToGcsPath
   */
  @javax.annotation.Nullable
  public String getSaveHeapDumpsToGcsPath() {
    return saveHeapDumpsToGcsPath;
  }

  public void setSaveHeapDumpsToGcsPath(String saveHeapDumpsToGcsPath) {
    this.saveHeapDumpsToGcsPath = saveHeapDumpsToGcsPath;
  }


  public FlexTemplateRuntimeEnvironment sdkContainerImage(String sdkContainerImage) {
    this.sdkContainerImage = sdkContainerImage;
    return this;
  }

  /**
   * Docker registry location of container image to use for the &#39;worker harness. Default is the container for the version of the SDK. Note this field is only valid for portable pipelines.
   * @return sdkContainerImage
   */
  @javax.annotation.Nullable
  public String getSdkContainerImage() {
    return sdkContainerImage;
  }

  public void setSdkContainerImage(String sdkContainerImage) {
    this.sdkContainerImage = sdkContainerImage;
  }


  public FlexTemplateRuntimeEnvironment serviceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
    return this;
  }

  /**
   * The email address of the service account to run the job as.
   * @return serviceAccountEmail
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmail() {
    return serviceAccountEmail;
  }

  public void setServiceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
  }


  public FlexTemplateRuntimeEnvironment stagingLocation(String stagingLocation) {
    this.stagingLocation = stagingLocation;
    return this;
  }

  /**
   * The Cloud Storage path for staging local files. Must be a valid Cloud Storage URL, beginning with &#x60;gs://&#x60;.
   * @return stagingLocation
   */
  @javax.annotation.Nullable
  public String getStagingLocation() {
    return stagingLocation;
  }

  public void setStagingLocation(String stagingLocation) {
    this.stagingLocation = stagingLocation;
  }


  public FlexTemplateRuntimeEnvironment streamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
    return this;
  }

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   * @return streamingMode
   */
  @javax.annotation.Nullable
  public StreamingModeEnum getStreamingMode() {
    return streamingMode;
  }

  public void setStreamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
  }


  public FlexTemplateRuntimeEnvironment subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Subnetwork to which VMs will be assigned, if desired. You can specify a subnetwork using either a complete URL or an abbreviated path. Expected to be of the form \&quot;https://www.googleapis.com/compute/v1/projects/HOST_PROJECT_ID/regions/REGION/subnetworks/SUBNETWORK\&quot; or \&quot;regions/REGION/subnetworks/SUBNETWORK\&quot;. If the subnetwork is located in a Shared VPC network, you must use the complete URL.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  public FlexTemplateRuntimeEnvironment tempLocation(String tempLocation) {
    this.tempLocation = tempLocation;
    return this;
  }

  /**
   * The Cloud Storage path to use for temporary files. Must be a valid Cloud Storage URL, beginning with &#x60;gs://&#x60;.
   * @return tempLocation
   */
  @javax.annotation.Nullable
  public String getTempLocation() {
    return tempLocation;
  }

  public void setTempLocation(String tempLocation) {
    this.tempLocation = tempLocation;
  }


  public FlexTemplateRuntimeEnvironment workerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
    return this;
  }

  /**
   * The Compute Engine region (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1\&quot;. Mutually exclusive with worker_zone. If neither worker_region nor worker_zone is specified, default to the control plane&#39;s region.
   * @return workerRegion
   */
  @javax.annotation.Nullable
  public String getWorkerRegion() {
    return workerRegion;
  }

  public void setWorkerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
  }


  public FlexTemplateRuntimeEnvironment workerZone(String workerZone) {
    this.workerZone = workerZone;
    return this;
  }

  /**
   * The Compute Engine zone (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1-a\&quot;. Mutually exclusive with worker_region. If neither worker_region nor worker_zone is specified, a zone in the control plane&#39;s region is chosen based on available capacity. If both &#x60;worker_zone&#x60; and &#x60;zone&#x60; are set, &#x60;worker_zone&#x60; takes precedence.
   * @return workerZone
   */
  @javax.annotation.Nullable
  public String getWorkerZone() {
    return workerZone;
  }

  public void setWorkerZone(String workerZone) {
    this.workerZone = workerZone;
  }


  public FlexTemplateRuntimeEnvironment zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * The Compute Engine [availability zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones) for launching worker instances to run your pipeline. In the future, worker_zone will take precedence.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlexTemplateRuntimeEnvironment flexTemplateRuntimeEnvironment = (FlexTemplateRuntimeEnvironment) o;
    return Objects.equals(this.additionalExperiments, flexTemplateRuntimeEnvironment.additionalExperiments) &&
        Objects.equals(this.additionalUserLabels, flexTemplateRuntimeEnvironment.additionalUserLabels) &&
        Objects.equals(this.autoscalingAlgorithm, flexTemplateRuntimeEnvironment.autoscalingAlgorithm) &&
        Objects.equals(this.diskSizeGb, flexTemplateRuntimeEnvironment.diskSizeGb) &&
        Objects.equals(this.dumpHeapOnOom, flexTemplateRuntimeEnvironment.dumpHeapOnOom) &&
        Objects.equals(this.enableLauncherVmSerialPortLogging, flexTemplateRuntimeEnvironment.enableLauncherVmSerialPortLogging) &&
        Objects.equals(this.enableStreamingEngine, flexTemplateRuntimeEnvironment.enableStreamingEngine) &&
        Objects.equals(this.flexrsGoal, flexTemplateRuntimeEnvironment.flexrsGoal) &&
        Objects.equals(this.ipConfiguration, flexTemplateRuntimeEnvironment.ipConfiguration) &&
        Objects.equals(this.kmsKeyName, flexTemplateRuntimeEnvironment.kmsKeyName) &&
        Objects.equals(this.launcherMachineType, flexTemplateRuntimeEnvironment.launcherMachineType) &&
        Objects.equals(this.machineType, flexTemplateRuntimeEnvironment.machineType) &&
        Objects.equals(this.maxWorkers, flexTemplateRuntimeEnvironment.maxWorkers) &&
        Objects.equals(this.network, flexTemplateRuntimeEnvironment.network) &&
        Objects.equals(this.numWorkers, flexTemplateRuntimeEnvironment.numWorkers) &&
        Objects.equals(this.saveHeapDumpsToGcsPath, flexTemplateRuntimeEnvironment.saveHeapDumpsToGcsPath) &&
        Objects.equals(this.sdkContainerImage, flexTemplateRuntimeEnvironment.sdkContainerImage) &&
        Objects.equals(this.serviceAccountEmail, flexTemplateRuntimeEnvironment.serviceAccountEmail) &&
        Objects.equals(this.stagingLocation, flexTemplateRuntimeEnvironment.stagingLocation) &&
        Objects.equals(this.streamingMode, flexTemplateRuntimeEnvironment.streamingMode) &&
        Objects.equals(this.subnetwork, flexTemplateRuntimeEnvironment.subnetwork) &&
        Objects.equals(this.tempLocation, flexTemplateRuntimeEnvironment.tempLocation) &&
        Objects.equals(this.workerRegion, flexTemplateRuntimeEnvironment.workerRegion) &&
        Objects.equals(this.workerZone, flexTemplateRuntimeEnvironment.workerZone) &&
        Objects.equals(this.zone, flexTemplateRuntimeEnvironment.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalExperiments, additionalUserLabels, autoscalingAlgorithm, diskSizeGb, dumpHeapOnOom, enableLauncherVmSerialPortLogging, enableStreamingEngine, flexrsGoal, ipConfiguration, kmsKeyName, launcherMachineType, machineType, maxWorkers, network, numWorkers, saveHeapDumpsToGcsPath, sdkContainerImage, serviceAccountEmail, stagingLocation, streamingMode, subnetwork, tempLocation, workerRegion, workerZone, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlexTemplateRuntimeEnvironment {\n");
    sb.append("    additionalExperiments: ").append(toIndentedString(additionalExperiments)).append("\n");
    sb.append("    additionalUserLabels: ").append(toIndentedString(additionalUserLabels)).append("\n");
    sb.append("    autoscalingAlgorithm: ").append(toIndentedString(autoscalingAlgorithm)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    dumpHeapOnOom: ").append(toIndentedString(dumpHeapOnOom)).append("\n");
    sb.append("    enableLauncherVmSerialPortLogging: ").append(toIndentedString(enableLauncherVmSerialPortLogging)).append("\n");
    sb.append("    enableStreamingEngine: ").append(toIndentedString(enableStreamingEngine)).append("\n");
    sb.append("    flexrsGoal: ").append(toIndentedString(flexrsGoal)).append("\n");
    sb.append("    ipConfiguration: ").append(toIndentedString(ipConfiguration)).append("\n");
    sb.append("    kmsKeyName: ").append(toIndentedString(kmsKeyName)).append("\n");
    sb.append("    launcherMachineType: ").append(toIndentedString(launcherMachineType)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    maxWorkers: ").append(toIndentedString(maxWorkers)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    numWorkers: ").append(toIndentedString(numWorkers)).append("\n");
    sb.append("    saveHeapDumpsToGcsPath: ").append(toIndentedString(saveHeapDumpsToGcsPath)).append("\n");
    sb.append("    sdkContainerImage: ").append(toIndentedString(sdkContainerImage)).append("\n");
    sb.append("    serviceAccountEmail: ").append(toIndentedString(serviceAccountEmail)).append("\n");
    sb.append("    stagingLocation: ").append(toIndentedString(stagingLocation)).append("\n");
    sb.append("    streamingMode: ").append(toIndentedString(streamingMode)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    tempLocation: ").append(toIndentedString(tempLocation)).append("\n");
    sb.append("    workerRegion: ").append(toIndentedString(workerRegion)).append("\n");
    sb.append("    workerZone: ").append(toIndentedString(workerZone)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("additionalExperiments");
    openapiFields.add("additionalUserLabels");
    openapiFields.add("autoscalingAlgorithm");
    openapiFields.add("diskSizeGb");
    openapiFields.add("dumpHeapOnOom");
    openapiFields.add("enableLauncherVmSerialPortLogging");
    openapiFields.add("enableStreamingEngine");
    openapiFields.add("flexrsGoal");
    openapiFields.add("ipConfiguration");
    openapiFields.add("kmsKeyName");
    openapiFields.add("launcherMachineType");
    openapiFields.add("machineType");
    openapiFields.add("maxWorkers");
    openapiFields.add("network");
    openapiFields.add("numWorkers");
    openapiFields.add("saveHeapDumpsToGcsPath");
    openapiFields.add("sdkContainerImage");
    openapiFields.add("serviceAccountEmail");
    openapiFields.add("stagingLocation");
    openapiFields.add("streamingMode");
    openapiFields.add("subnetwork");
    openapiFields.add("tempLocation");
    openapiFields.add("workerRegion");
    openapiFields.add("workerZone");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FlexTemplateRuntimeEnvironment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FlexTemplateRuntimeEnvironment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FlexTemplateRuntimeEnvironment is not found in the empty JSON string", FlexTemplateRuntimeEnvironment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FlexTemplateRuntimeEnvironment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FlexTemplateRuntimeEnvironment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("additionalExperiments") != null && !jsonObj.get("additionalExperiments").isJsonNull() && !jsonObj.get("additionalExperiments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `additionalExperiments` to be an array in the JSON string but got `%s`", jsonObj.get("additionalExperiments").toString()));
      }
      if ((jsonObj.get("autoscalingAlgorithm") != null && !jsonObj.get("autoscalingAlgorithm").isJsonNull()) && !jsonObj.get("autoscalingAlgorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoscalingAlgorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoscalingAlgorithm").toString()));
      }
      // validate the optional field `autoscalingAlgorithm`
      if (jsonObj.get("autoscalingAlgorithm") != null && !jsonObj.get("autoscalingAlgorithm").isJsonNull()) {
        AutoscalingAlgorithmEnum.validateJsonElement(jsonObj.get("autoscalingAlgorithm"));
      }
      if ((jsonObj.get("flexrsGoal") != null && !jsonObj.get("flexrsGoal").isJsonNull()) && !jsonObj.get("flexrsGoal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flexrsGoal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flexrsGoal").toString()));
      }
      // validate the optional field `flexrsGoal`
      if (jsonObj.get("flexrsGoal") != null && !jsonObj.get("flexrsGoal").isJsonNull()) {
        FlexrsGoalEnum.validateJsonElement(jsonObj.get("flexrsGoal"));
      }
      if ((jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) && !jsonObj.get("ipConfiguration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipConfiguration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipConfiguration").toString()));
      }
      // validate the optional field `ipConfiguration`
      if (jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) {
        IpConfigurationEnum.validateJsonElement(jsonObj.get("ipConfiguration"));
      }
      if ((jsonObj.get("kmsKeyName") != null && !jsonObj.get("kmsKeyName").isJsonNull()) && !jsonObj.get("kmsKeyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKeyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKeyName").toString()));
      }
      if ((jsonObj.get("launcherMachineType") != null && !jsonObj.get("launcherMachineType").isJsonNull()) && !jsonObj.get("launcherMachineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `launcherMachineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("launcherMachineType").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("saveHeapDumpsToGcsPath") != null && !jsonObj.get("saveHeapDumpsToGcsPath").isJsonNull()) && !jsonObj.get("saveHeapDumpsToGcsPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `saveHeapDumpsToGcsPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("saveHeapDumpsToGcsPath").toString()));
      }
      if ((jsonObj.get("sdkContainerImage") != null && !jsonObj.get("sdkContainerImage").isJsonNull()) && !jsonObj.get("sdkContainerImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sdkContainerImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sdkContainerImage").toString()));
      }
      if ((jsonObj.get("serviceAccountEmail") != null && !jsonObj.get("serviceAccountEmail").isJsonNull()) && !jsonObj.get("serviceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmail").toString()));
      }
      if ((jsonObj.get("stagingLocation") != null && !jsonObj.get("stagingLocation").isJsonNull()) && !jsonObj.get("stagingLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stagingLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stagingLocation").toString()));
      }
      if ((jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) && !jsonObj.get("streamingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamingMode").toString()));
      }
      // validate the optional field `streamingMode`
      if (jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) {
        StreamingModeEnum.validateJsonElement(jsonObj.get("streamingMode"));
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      if ((jsonObj.get("tempLocation") != null && !jsonObj.get("tempLocation").isJsonNull()) && !jsonObj.get("tempLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tempLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tempLocation").toString()));
      }
      if ((jsonObj.get("workerRegion") != null && !jsonObj.get("workerRegion").isJsonNull()) && !jsonObj.get("workerRegion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerRegion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerRegion").toString()));
      }
      if ((jsonObj.get("workerZone") != null && !jsonObj.get("workerZone").isJsonNull()) && !jsonObj.get("workerZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerZone").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FlexTemplateRuntimeEnvironment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FlexTemplateRuntimeEnvironment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FlexTemplateRuntimeEnvironment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FlexTemplateRuntimeEnvironment.class));

       return (TypeAdapter<T>) new TypeAdapter<FlexTemplateRuntimeEnvironment>() {
           @Override
           public void write(JsonWriter out, FlexTemplateRuntimeEnvironment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FlexTemplateRuntimeEnvironment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FlexTemplateRuntimeEnvironment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FlexTemplateRuntimeEnvironment
   * @throws IOException if the JSON string is invalid with respect to FlexTemplateRuntimeEnvironment
   */
  public static FlexTemplateRuntimeEnvironment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FlexTemplateRuntimeEnvironment.class);
  }

  /**
   * Convert an instance of FlexTemplateRuntimeEnvironment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

