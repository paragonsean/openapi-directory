/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The environment values to set at runtime.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RuntimeEnvironment {
  public static final String SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS = "additionalExperiments";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS)
  private List<String> additionalExperiments = new ArrayList<>();

  public static final String SERIALIZED_NAME_ADDITIONAL_USER_LABELS = "additionalUserLabels";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_USER_LABELS)
  private Map<String, String> additionalUserLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_BYPASS_TEMP_DIR_VALIDATION = "bypassTempDirValidation";
  @SerializedName(SERIALIZED_NAME_BYPASS_TEMP_DIR_VALIDATION)
  private Boolean bypassTempDirValidation;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_ENABLE_STREAMING_ENGINE = "enableStreamingEngine";
  @SerializedName(SERIALIZED_NAME_ENABLE_STREAMING_ENGINE)
  private Boolean enableStreamingEngine;

  /**
   * Optional. Configuration for VM IPs.
   */
  @JsonAdapter(IpConfigurationEnum.Adapter.class)
  public enum IpConfigurationEnum {
    UNSPECIFIED("WORKER_IP_UNSPECIFIED"),
    
    PUBLIC("WORKER_IP_PUBLIC"),
    
    PRIVATE("WORKER_IP_PRIVATE");

    private String value;

    IpConfigurationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IpConfigurationEnum fromValue(String value) {
      for (IpConfigurationEnum b : IpConfigurationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IpConfigurationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IpConfigurationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IpConfigurationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IpConfigurationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IpConfigurationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IP_CONFIGURATION = "ipConfiguration";
  @SerializedName(SERIALIZED_NAME_IP_CONFIGURATION)
  private IpConfigurationEnum ipConfiguration;

  public static final String SERIALIZED_NAME_KMS_KEY_NAME = "kmsKeyName";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_NAME)
  private String kmsKeyName;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_MAX_WORKERS = "maxWorkers";
  @SerializedName(SERIALIZED_NAME_MAX_WORKERS)
  private Integer maxWorkers;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_NUM_WORKERS = "numWorkers";
  @SerializedName(SERIALIZED_NAME_NUM_WORKERS)
  private Integer numWorkers;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL = "serviceAccountEmail";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL)
  private String serviceAccountEmail;

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   */
  @JsonAdapter(StreamingModeEnum.Adapter.class)
  public enum StreamingModeEnum {
    UNSPECIFIED("STREAMING_MODE_UNSPECIFIED"),
    
    EXACTLY_ONCE("STREAMING_MODE_EXACTLY_ONCE"),
    
    AT_LEAST_ONCE("STREAMING_MODE_AT_LEAST_ONCE");

    private String value;

    StreamingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StreamingModeEnum fromValue(String value) {
      for (StreamingModeEnum b : StreamingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StreamingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StreamingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StreamingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StreamingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StreamingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STREAMING_MODE = "streamingMode";
  @SerializedName(SERIALIZED_NAME_STREAMING_MODE)
  private StreamingModeEnum streamingMode;

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_TEMP_LOCATION = "tempLocation";
  @SerializedName(SERIALIZED_NAME_TEMP_LOCATION)
  private String tempLocation;

  public static final String SERIALIZED_NAME_WORKER_REGION = "workerRegion";
  @SerializedName(SERIALIZED_NAME_WORKER_REGION)
  private String workerRegion;

  public static final String SERIALIZED_NAME_WORKER_ZONE = "workerZone";
  @SerializedName(SERIALIZED_NAME_WORKER_ZONE)
  private String workerZone;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public RuntimeEnvironment() {
  }

  public RuntimeEnvironment additionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
    return this;
  }

  public RuntimeEnvironment addAdditionalExperimentsItem(String additionalExperimentsItem) {
    if (this.additionalExperiments == null) {
      this.additionalExperiments = new ArrayList<>();
    }
    this.additionalExperiments.add(additionalExperimentsItem);
    return this;
  }

  /**
   * Optional. Additional experiment flags for the job, specified with the &#x60;--experiments&#x60; option.
   * @return additionalExperiments
   */
  @javax.annotation.Nullable
  public List<String> getAdditionalExperiments() {
    return additionalExperiments;
  }

  public void setAdditionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
  }


  public RuntimeEnvironment additionalUserLabels(Map<String, String> additionalUserLabels) {
    this.additionalUserLabels = additionalUserLabels;
    return this;
  }

  public RuntimeEnvironment putAdditionalUserLabelsItem(String key, String additionalUserLabelsItem) {
    if (this.additionalUserLabels == null) {
      this.additionalUserLabels = new HashMap<>();
    }
    this.additionalUserLabels.put(key, additionalUserLabelsItem);
    return this;
  }

  /**
   * Optional. Additional user labels to be specified for the job. Keys and values should follow the restrictions specified in the [labeling restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) page. An object containing a list of \&quot;key\&quot;: value pairs. Example: { \&quot;name\&quot;: \&quot;wrench\&quot;, \&quot;mass\&quot;: \&quot;1kg\&quot;, \&quot;count\&quot;: \&quot;3\&quot; }.
   * @return additionalUserLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getAdditionalUserLabels() {
    return additionalUserLabels;
  }

  public void setAdditionalUserLabels(Map<String, String> additionalUserLabels) {
    this.additionalUserLabels = additionalUserLabels;
  }


  public RuntimeEnvironment bypassTempDirValidation(Boolean bypassTempDirValidation) {
    this.bypassTempDirValidation = bypassTempDirValidation;
    return this;
  }

  /**
   * Optional. Whether to bypass the safety checks for the job&#39;s temporary directory. Use with caution.
   * @return bypassTempDirValidation
   */
  @javax.annotation.Nullable
  public Boolean getBypassTempDirValidation() {
    return bypassTempDirValidation;
  }

  public void setBypassTempDirValidation(Boolean bypassTempDirValidation) {
    this.bypassTempDirValidation = bypassTempDirValidation;
  }


  public RuntimeEnvironment diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Optional. The disk size, in gigabytes, to use on each remote Compute Engine worker instance.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public RuntimeEnvironment enableStreamingEngine(Boolean enableStreamingEngine) {
    this.enableStreamingEngine = enableStreamingEngine;
    return this;
  }

  /**
   * Optional. Whether to enable Streaming Engine for the job.
   * @return enableStreamingEngine
   */
  @javax.annotation.Nullable
  public Boolean getEnableStreamingEngine() {
    return enableStreamingEngine;
  }

  public void setEnableStreamingEngine(Boolean enableStreamingEngine) {
    this.enableStreamingEngine = enableStreamingEngine;
  }


  public RuntimeEnvironment ipConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
    return this;
  }

  /**
   * Optional. Configuration for VM IPs.
   * @return ipConfiguration
   */
  @javax.annotation.Nullable
  public IpConfigurationEnum getIpConfiguration() {
    return ipConfiguration;
  }

  public void setIpConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
  }


  public RuntimeEnvironment kmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
    return this;
  }

  /**
   * Optional. Name for the Cloud KMS key for the job. Key format is: projects//locations//keyRings//cryptoKeys/
   * @return kmsKeyName
   */
  @javax.annotation.Nullable
  public String getKmsKeyName() {
    return kmsKeyName;
  }

  public void setKmsKeyName(String kmsKeyName) {
    this.kmsKeyName = kmsKeyName;
  }


  public RuntimeEnvironment machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Optional. The machine type to use for the job. Defaults to the value from the template if not specified.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public RuntimeEnvironment maxWorkers(Integer maxWorkers) {
    this.maxWorkers = maxWorkers;
    return this;
  }

  /**
   * Optional. The maximum number of Google Compute Engine instances to be made available to your pipeline during execution, from 1 to 1000. The default value is 1.
   * @return maxWorkers
   */
  @javax.annotation.Nullable
  public Integer getMaxWorkers() {
    return maxWorkers;
  }

  public void setMaxWorkers(Integer maxWorkers) {
    this.maxWorkers = maxWorkers;
  }


  public RuntimeEnvironment network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Optional. Network to which VMs will be assigned. If empty or unspecified, the service will use the network \&quot;default\&quot;.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public RuntimeEnvironment numWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
    return this;
  }

  /**
   * Optional. The initial number of Google Compute Engine instances for the job. The default value is 11.
   * @return numWorkers
   */
  @javax.annotation.Nullable
  public Integer getNumWorkers() {
    return numWorkers;
  }

  public void setNumWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
  }


  public RuntimeEnvironment serviceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
    return this;
  }

  /**
   * Optional. The email address of the service account to run the job as.
   * @return serviceAccountEmail
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmail() {
    return serviceAccountEmail;
  }

  public void setServiceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
  }


  public RuntimeEnvironment streamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
    return this;
  }

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   * @return streamingMode
   */
  @javax.annotation.Nullable
  public StreamingModeEnum getStreamingMode() {
    return streamingMode;
  }

  public void setStreamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
  }


  public RuntimeEnvironment subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Optional. Subnetwork to which VMs will be assigned, if desired. You can specify a subnetwork using either a complete URL or an abbreviated path. Expected to be of the form \&quot;https://www.googleapis.com/compute/v1/projects/HOST_PROJECT_ID/regions/REGION/subnetworks/SUBNETWORK\&quot; or \&quot;regions/REGION/subnetworks/SUBNETWORK\&quot;. If the subnetwork is located in a Shared VPC network, you must use the complete URL.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  public RuntimeEnvironment tempLocation(String tempLocation) {
    this.tempLocation = tempLocation;
    return this;
  }

  /**
   * Required. The Cloud Storage path to use for temporary files. Must be a valid Cloud Storage URL, beginning with &#x60;gs://&#x60;.
   * @return tempLocation
   */
  @javax.annotation.Nullable
  public String getTempLocation() {
    return tempLocation;
  }

  public void setTempLocation(String tempLocation) {
    this.tempLocation = tempLocation;
  }


  public RuntimeEnvironment workerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
    return this;
  }

  /**
   * Required. The Compute Engine region (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1\&quot;. Mutually exclusive with worker_zone. If neither worker_region nor worker_zone is specified, default to the control plane&#39;s region.
   * @return workerRegion
   */
  @javax.annotation.Nullable
  public String getWorkerRegion() {
    return workerRegion;
  }

  public void setWorkerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
  }


  public RuntimeEnvironment workerZone(String workerZone) {
    this.workerZone = workerZone;
    return this;
  }

  /**
   * Optional. The Compute Engine zone (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1-a\&quot;. Mutually exclusive with worker_region. If neither worker_region nor worker_zone is specified, a zone in the control plane&#39;s region is chosen based on available capacity. If both &#x60;worker_zone&#x60; and &#x60;zone&#x60; are set, &#x60;worker_zone&#x60; takes precedence.
   * @return workerZone
   */
  @javax.annotation.Nullable
  public String getWorkerZone() {
    return workerZone;
  }

  public void setWorkerZone(String workerZone) {
    this.workerZone = workerZone;
  }


  public RuntimeEnvironment zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * Optional. The Compute Engine [availability zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones) for launching worker instances to run your pipeline. In the future, worker_zone will take precedence.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RuntimeEnvironment runtimeEnvironment = (RuntimeEnvironment) o;
    return Objects.equals(this.additionalExperiments, runtimeEnvironment.additionalExperiments) &&
        Objects.equals(this.additionalUserLabels, runtimeEnvironment.additionalUserLabels) &&
        Objects.equals(this.bypassTempDirValidation, runtimeEnvironment.bypassTempDirValidation) &&
        Objects.equals(this.diskSizeGb, runtimeEnvironment.diskSizeGb) &&
        Objects.equals(this.enableStreamingEngine, runtimeEnvironment.enableStreamingEngine) &&
        Objects.equals(this.ipConfiguration, runtimeEnvironment.ipConfiguration) &&
        Objects.equals(this.kmsKeyName, runtimeEnvironment.kmsKeyName) &&
        Objects.equals(this.machineType, runtimeEnvironment.machineType) &&
        Objects.equals(this.maxWorkers, runtimeEnvironment.maxWorkers) &&
        Objects.equals(this.network, runtimeEnvironment.network) &&
        Objects.equals(this.numWorkers, runtimeEnvironment.numWorkers) &&
        Objects.equals(this.serviceAccountEmail, runtimeEnvironment.serviceAccountEmail) &&
        Objects.equals(this.streamingMode, runtimeEnvironment.streamingMode) &&
        Objects.equals(this.subnetwork, runtimeEnvironment.subnetwork) &&
        Objects.equals(this.tempLocation, runtimeEnvironment.tempLocation) &&
        Objects.equals(this.workerRegion, runtimeEnvironment.workerRegion) &&
        Objects.equals(this.workerZone, runtimeEnvironment.workerZone) &&
        Objects.equals(this.zone, runtimeEnvironment.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalExperiments, additionalUserLabels, bypassTempDirValidation, diskSizeGb, enableStreamingEngine, ipConfiguration, kmsKeyName, machineType, maxWorkers, network, numWorkers, serviceAccountEmail, streamingMode, subnetwork, tempLocation, workerRegion, workerZone, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RuntimeEnvironment {\n");
    sb.append("    additionalExperiments: ").append(toIndentedString(additionalExperiments)).append("\n");
    sb.append("    additionalUserLabels: ").append(toIndentedString(additionalUserLabels)).append("\n");
    sb.append("    bypassTempDirValidation: ").append(toIndentedString(bypassTempDirValidation)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    enableStreamingEngine: ").append(toIndentedString(enableStreamingEngine)).append("\n");
    sb.append("    ipConfiguration: ").append(toIndentedString(ipConfiguration)).append("\n");
    sb.append("    kmsKeyName: ").append(toIndentedString(kmsKeyName)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    maxWorkers: ").append(toIndentedString(maxWorkers)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    numWorkers: ").append(toIndentedString(numWorkers)).append("\n");
    sb.append("    serviceAccountEmail: ").append(toIndentedString(serviceAccountEmail)).append("\n");
    sb.append("    streamingMode: ").append(toIndentedString(streamingMode)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    tempLocation: ").append(toIndentedString(tempLocation)).append("\n");
    sb.append("    workerRegion: ").append(toIndentedString(workerRegion)).append("\n");
    sb.append("    workerZone: ").append(toIndentedString(workerZone)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("additionalExperiments");
    openapiFields.add("additionalUserLabels");
    openapiFields.add("bypassTempDirValidation");
    openapiFields.add("diskSizeGb");
    openapiFields.add("enableStreamingEngine");
    openapiFields.add("ipConfiguration");
    openapiFields.add("kmsKeyName");
    openapiFields.add("machineType");
    openapiFields.add("maxWorkers");
    openapiFields.add("network");
    openapiFields.add("numWorkers");
    openapiFields.add("serviceAccountEmail");
    openapiFields.add("streamingMode");
    openapiFields.add("subnetwork");
    openapiFields.add("tempLocation");
    openapiFields.add("workerRegion");
    openapiFields.add("workerZone");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RuntimeEnvironment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RuntimeEnvironment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RuntimeEnvironment is not found in the empty JSON string", RuntimeEnvironment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RuntimeEnvironment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RuntimeEnvironment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("additionalExperiments") != null && !jsonObj.get("additionalExperiments").isJsonNull() && !jsonObj.get("additionalExperiments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `additionalExperiments` to be an array in the JSON string but got `%s`", jsonObj.get("additionalExperiments").toString()));
      }
      if ((jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) && !jsonObj.get("ipConfiguration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipConfiguration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipConfiguration").toString()));
      }
      // validate the optional field `ipConfiguration`
      if (jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) {
        IpConfigurationEnum.validateJsonElement(jsonObj.get("ipConfiguration"));
      }
      if ((jsonObj.get("kmsKeyName") != null && !jsonObj.get("kmsKeyName").isJsonNull()) && !jsonObj.get("kmsKeyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKeyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKeyName").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("serviceAccountEmail") != null && !jsonObj.get("serviceAccountEmail").isJsonNull()) && !jsonObj.get("serviceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmail").toString()));
      }
      if ((jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) && !jsonObj.get("streamingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamingMode").toString()));
      }
      // validate the optional field `streamingMode`
      if (jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) {
        StreamingModeEnum.validateJsonElement(jsonObj.get("streamingMode"));
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      if ((jsonObj.get("tempLocation") != null && !jsonObj.get("tempLocation").isJsonNull()) && !jsonObj.get("tempLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tempLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tempLocation").toString()));
      }
      if ((jsonObj.get("workerRegion") != null && !jsonObj.get("workerRegion").isJsonNull()) && !jsonObj.get("workerRegion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerRegion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerRegion").toString()));
      }
      if ((jsonObj.get("workerZone") != null && !jsonObj.get("workerZone").isJsonNull()) && !jsonObj.get("workerZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerZone").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RuntimeEnvironment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RuntimeEnvironment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RuntimeEnvironment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RuntimeEnvironment.class));

       return (TypeAdapter<T>) new TypeAdapter<RuntimeEnvironment>() {
           @Override
           public void write(JsonWriter out, RuntimeEnvironment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RuntimeEnvironment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RuntimeEnvironment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RuntimeEnvironment
   * @throws IOException if the JSON string is invalid with respect to RuntimeEnvironment
   */
  public static RuntimeEnvironment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RuntimeEnvironment.class);
  }

  /**
   * Convert an instance of RuntimeEnvironment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

