/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.MetricStructuredName;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the state of a metric.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MetricUpdate {
  public static final String SERIALIZED_NAME_CUMULATIVE = "cumulative";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE)
  private Boolean cumulative;

  public static final String SERIALIZED_NAME_DISTRIBUTION = "distribution";
  @SerializedName(SERIALIZED_NAME_DISTRIBUTION)
  private Object distribution = null;

  public static final String SERIALIZED_NAME_GAUGE = "gauge";
  @SerializedName(SERIALIZED_NAME_GAUGE)
  private Object gauge = null;

  public static final String SERIALIZED_NAME_INTERNAL = "internal";
  @SerializedName(SERIALIZED_NAME_INTERNAL)
  private Object internal = null;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MEAN_COUNT = "meanCount";
  @SerializedName(SERIALIZED_NAME_MEAN_COUNT)
  private Object meanCount = null;

  public static final String SERIALIZED_NAME_MEAN_SUM = "meanSum";
  @SerializedName(SERIALIZED_NAME_MEAN_SUM)
  private Object meanSum = null;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private MetricStructuredName name;

  public static final String SERIALIZED_NAME_SCALAR = "scalar";
  @SerializedName(SERIALIZED_NAME_SCALAR)
  private Object scalar = null;

  public static final String SERIALIZED_NAME_SET = "set";
  @SerializedName(SERIALIZED_NAME_SET)
  private Object set = null;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public MetricUpdate() {
  }

  public MetricUpdate cumulative(Boolean cumulative) {
    this.cumulative = cumulative;
    return this;
  }

  /**
   * True if this metric is reported as the total cumulative aggregate value accumulated since the worker started working on this WorkItem. By default this is false, indicating that this metric is reported as a delta that is not associated with any WorkItem.
   * @return cumulative
   */
  @javax.annotation.Nullable
  public Boolean getCumulative() {
    return cumulative;
  }

  public void setCumulative(Boolean cumulative) {
    this.cumulative = cumulative;
  }


  public MetricUpdate distribution(Object distribution) {
    this.distribution = distribution;
    return this;
  }

  /**
   * A struct value describing properties of a distribution of numeric values.
   * @return distribution
   */
  @javax.annotation.Nullable
  public Object getDistribution() {
    return distribution;
  }

  public void setDistribution(Object distribution) {
    this.distribution = distribution;
  }


  public MetricUpdate gauge(Object gauge) {
    this.gauge = gauge;
    return this;
  }

  /**
   * A struct value describing properties of a Gauge. Metrics of gauge type show the value of a metric across time, and is aggregated based on the newest value.
   * @return gauge
   */
  @javax.annotation.Nullable
  public Object getGauge() {
    return gauge;
  }

  public void setGauge(Object gauge) {
    this.gauge = gauge;
  }


  public MetricUpdate internal(Object internal) {
    this.internal = internal;
    return this;
  }

  /**
   * Worker-computed aggregate value for internal use by the Dataflow service.
   * @return internal
   */
  @javax.annotation.Nullable
  public Object getInternal() {
    return internal;
  }

  public void setInternal(Object internal) {
    this.internal = internal;
  }


  public MetricUpdate kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Metric aggregation kind. The possible metric aggregation kinds are \&quot;Sum\&quot;, \&quot;Max\&quot;, \&quot;Min\&quot;, \&quot;Mean\&quot;, \&quot;Set\&quot;, \&quot;And\&quot;, \&quot;Or\&quot;, and \&quot;Distribution\&quot;. The specified aggregation kind is case-insensitive. If omitted, this is not an aggregated value but instead a single metric sample value.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public MetricUpdate meanCount(Object meanCount) {
    this.meanCount = meanCount;
    return this;
  }

  /**
   * Worker-computed aggregate value for the \&quot;Mean\&quot; aggregation kind. This holds the count of the aggregated values and is used in combination with mean_sum above to obtain the actual mean aggregate value. The only possible value type is Long.
   * @return meanCount
   */
  @javax.annotation.Nullable
  public Object getMeanCount() {
    return meanCount;
  }

  public void setMeanCount(Object meanCount) {
    this.meanCount = meanCount;
  }


  public MetricUpdate meanSum(Object meanSum) {
    this.meanSum = meanSum;
    return this;
  }

  /**
   * Worker-computed aggregate value for the \&quot;Mean\&quot; aggregation kind. This holds the sum of the aggregated values and is used in combination with mean_count below to obtain the actual mean aggregate value. The only possible value types are Long and Double.
   * @return meanSum
   */
  @javax.annotation.Nullable
  public Object getMeanSum() {
    return meanSum;
  }

  public void setMeanSum(Object meanSum) {
    this.meanSum = meanSum;
  }


  public MetricUpdate name(MetricStructuredName name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public MetricStructuredName getName() {
    return name;
  }

  public void setName(MetricStructuredName name) {
    this.name = name;
  }


  public MetricUpdate scalar(Object scalar) {
    this.scalar = scalar;
    return this;
  }

  /**
   * Worker-computed aggregate value for aggregation kinds \&quot;Sum\&quot;, \&quot;Max\&quot;, \&quot;Min\&quot;, \&quot;And\&quot;, and \&quot;Or\&quot;. The possible value types are Long, Double, and Boolean.
   * @return scalar
   */
  @javax.annotation.Nullable
  public Object getScalar() {
    return scalar;
  }

  public void setScalar(Object scalar) {
    this.scalar = scalar;
  }


  public MetricUpdate set(Object set) {
    this.set = set;
    return this;
  }

  /**
   * Worker-computed aggregate value for the \&quot;Set\&quot; aggregation kind. The only possible value type is a list of Values whose type can be Long, Double, or String, according to the metric&#39;s type. All Values in the list must be of the same type.
   * @return set
   */
  @javax.annotation.Nullable
  public Object getSet() {
    return set;
  }

  public void setSet(Object set) {
    this.set = set;
  }


  public MetricUpdate updateTime(String updateTime) {
    this.updateTime = updateTime;
    return this;
  }

  /**
   * Timestamp associated with the metric value. Optional when workers are reporting work progress; it will be filled in responses from the metrics API.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }

  public void setUpdateTime(String updateTime) {
    this.updateTime = updateTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MetricUpdate metricUpdate = (MetricUpdate) o;
    return Objects.equals(this.cumulative, metricUpdate.cumulative) &&
        Objects.equals(this.distribution, metricUpdate.distribution) &&
        Objects.equals(this.gauge, metricUpdate.gauge) &&
        Objects.equals(this.internal, metricUpdate.internal) &&
        Objects.equals(this.kind, metricUpdate.kind) &&
        Objects.equals(this.meanCount, metricUpdate.meanCount) &&
        Objects.equals(this.meanSum, metricUpdate.meanSum) &&
        Objects.equals(this.name, metricUpdate.name) &&
        Objects.equals(this.scalar, metricUpdate.scalar) &&
        Objects.equals(this.set, metricUpdate.set) &&
        Objects.equals(this.updateTime, metricUpdate.updateTime);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(cumulative, distribution, gauge, internal, kind, meanCount, meanSum, name, scalar, set, updateTime);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MetricUpdate {\n");
    sb.append("    cumulative: ").append(toIndentedString(cumulative)).append("\n");
    sb.append("    distribution: ").append(toIndentedString(distribution)).append("\n");
    sb.append("    gauge: ").append(toIndentedString(gauge)).append("\n");
    sb.append("    internal: ").append(toIndentedString(internal)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    meanCount: ").append(toIndentedString(meanCount)).append("\n");
    sb.append("    meanSum: ").append(toIndentedString(meanSum)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    scalar: ").append(toIndentedString(scalar)).append("\n");
    sb.append("    set: ").append(toIndentedString(set)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cumulative");
    openapiFields.add("distribution");
    openapiFields.add("gauge");
    openapiFields.add("internal");
    openapiFields.add("kind");
    openapiFields.add("meanCount");
    openapiFields.add("meanSum");
    openapiFields.add("name");
    openapiFields.add("scalar");
    openapiFields.add("set");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MetricUpdate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MetricUpdate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MetricUpdate is not found in the empty JSON string", MetricUpdate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MetricUpdate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MetricUpdate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `name`
      if (jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) {
        MetricStructuredName.validateJsonElement(jsonObj.get("name"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MetricUpdate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MetricUpdate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MetricUpdate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MetricUpdate.class));

       return (TypeAdapter<T>) new TypeAdapter<MetricUpdate>() {
           @Override
           public void write(JsonWriter out, MetricUpdate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MetricUpdate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MetricUpdate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MetricUpdate
   * @throws IOException if the JSON string is invalid with respect to MetricUpdate
   */
  public static MetricUpdate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MetricUpdate.class);
  }

  /**
   * Convert an instance of MetricUpdate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

