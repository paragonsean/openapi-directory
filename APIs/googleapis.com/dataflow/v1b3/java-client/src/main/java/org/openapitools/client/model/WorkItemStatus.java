/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ApproximateProgress;
import org.openapitools.client.model.ApproximateReportedProgress;
import org.openapitools.client.model.CounterUpdate;
import org.openapitools.client.model.DynamicSourceSplit;
import org.openapitools.client.model.MetricUpdate;
import org.openapitools.client.model.Position;
import org.openapitools.client.model.SourceFork;
import org.openapitools.client.model.SourceOperationResponse;
import org.openapitools.client.model.Status;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Conveys a worker&#39;s progress through the work described by a WorkItem.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WorkItemStatus {
  public static final String SERIALIZED_NAME_COMPLETED = "completed";
  @SerializedName(SERIALIZED_NAME_COMPLETED)
  private Boolean completed;

  public static final String SERIALIZED_NAME_COUNTER_UPDATES = "counterUpdates";
  @SerializedName(SERIALIZED_NAME_COUNTER_UPDATES)
  private List<CounterUpdate> counterUpdates = new ArrayList<>();

  public static final String SERIALIZED_NAME_DYNAMIC_SOURCE_SPLIT = "dynamicSourceSplit";
  @SerializedName(SERIALIZED_NAME_DYNAMIC_SOURCE_SPLIT)
  private DynamicSourceSplit dynamicSourceSplit;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private List<Status> errors = new ArrayList<>();

  public static final String SERIALIZED_NAME_METRIC_UPDATES = "metricUpdates";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_METRIC_UPDATES)
  private List<MetricUpdate> metricUpdates = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROGRESS = "progress";
  @SerializedName(SERIALIZED_NAME_PROGRESS)
  private ApproximateProgress progress;

  public static final String SERIALIZED_NAME_REPORT_INDEX = "reportIndex";
  @SerializedName(SERIALIZED_NAME_REPORT_INDEX)
  private String reportIndex;

  public static final String SERIALIZED_NAME_REPORTED_PROGRESS = "reportedProgress";
  @SerializedName(SERIALIZED_NAME_REPORTED_PROGRESS)
  private ApproximateReportedProgress reportedProgress;

  public static final String SERIALIZED_NAME_REQUESTED_LEASE_DURATION = "requestedLeaseDuration";
  @SerializedName(SERIALIZED_NAME_REQUESTED_LEASE_DURATION)
  private String requestedLeaseDuration;

  public static final String SERIALIZED_NAME_SOURCE_FORK = "sourceFork";
  @SerializedName(SERIALIZED_NAME_SOURCE_FORK)
  private SourceFork sourceFork;

  public static final String SERIALIZED_NAME_SOURCE_OPERATION_RESPONSE = "sourceOperationResponse";
  @SerializedName(SERIALIZED_NAME_SOURCE_OPERATION_RESPONSE)
  private SourceOperationResponse sourceOperationResponse;

  public static final String SERIALIZED_NAME_STOP_POSITION = "stopPosition";
  @SerializedName(SERIALIZED_NAME_STOP_POSITION)
  private Position stopPosition;

  public static final String SERIALIZED_NAME_TOTAL_THROTTLER_WAIT_TIME_SECONDS = "totalThrottlerWaitTimeSeconds";
  @SerializedName(SERIALIZED_NAME_TOTAL_THROTTLER_WAIT_TIME_SECONDS)
  private Double totalThrottlerWaitTimeSeconds;

  public static final String SERIALIZED_NAME_WORK_ITEM_ID = "workItemId";
  @SerializedName(SERIALIZED_NAME_WORK_ITEM_ID)
  private String workItemId;

  public WorkItemStatus() {
  }

  public WorkItemStatus completed(Boolean completed) {
    this.completed = completed;
    return this;
  }

  /**
   * True if the WorkItem was completed (successfully or unsuccessfully).
   * @return completed
   */
  @javax.annotation.Nullable
  public Boolean getCompleted() {
    return completed;
  }

  public void setCompleted(Boolean completed) {
    this.completed = completed;
  }


  public WorkItemStatus counterUpdates(List<CounterUpdate> counterUpdates) {
    this.counterUpdates = counterUpdates;
    return this;
  }

  public WorkItemStatus addCounterUpdatesItem(CounterUpdate counterUpdatesItem) {
    if (this.counterUpdates == null) {
      this.counterUpdates = new ArrayList<>();
    }
    this.counterUpdates.add(counterUpdatesItem);
    return this;
  }

  /**
   * Worker output counters for this WorkItem.
   * @return counterUpdates
   */
  @javax.annotation.Nullable
  public List<CounterUpdate> getCounterUpdates() {
    return counterUpdates;
  }

  public void setCounterUpdates(List<CounterUpdate> counterUpdates) {
    this.counterUpdates = counterUpdates;
  }


  public WorkItemStatus dynamicSourceSplit(DynamicSourceSplit dynamicSourceSplit) {
    this.dynamicSourceSplit = dynamicSourceSplit;
    return this;
  }

  /**
   * Get dynamicSourceSplit
   * @return dynamicSourceSplit
   */
  @javax.annotation.Nullable
  public DynamicSourceSplit getDynamicSourceSplit() {
    return dynamicSourceSplit;
  }

  public void setDynamicSourceSplit(DynamicSourceSplit dynamicSourceSplit) {
    this.dynamicSourceSplit = dynamicSourceSplit;
  }


  public WorkItemStatus errors(List<Status> errors) {
    this.errors = errors;
    return this;
  }

  public WorkItemStatus addErrorsItem(Status errorsItem) {
    if (this.errors == null) {
      this.errors = new ArrayList<>();
    }
    this.errors.add(errorsItem);
    return this;
  }

  /**
   * Specifies errors which occurred during processing. If errors are provided, and completed &#x3D; true, then the WorkItem is considered to have failed.
   * @return errors
   */
  @javax.annotation.Nullable
  public List<Status> getErrors() {
    return errors;
  }

  public void setErrors(List<Status> errors) {
    this.errors = errors;
  }


  @Deprecated
  public WorkItemStatus metricUpdates(List<MetricUpdate> metricUpdates) {
    this.metricUpdates = metricUpdates;
    return this;
  }

  public WorkItemStatus addMetricUpdatesItem(MetricUpdate metricUpdatesItem) {
    if (this.metricUpdates == null) {
      this.metricUpdates = new ArrayList<>();
    }
    this.metricUpdates.add(metricUpdatesItem);
    return this;
  }

  /**
   * DEPRECATED in favor of counter_updates.
   * @return metricUpdates
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<MetricUpdate> getMetricUpdates() {
    return metricUpdates;
  }

  @Deprecated
  public void setMetricUpdates(List<MetricUpdate> metricUpdates) {
    this.metricUpdates = metricUpdates;
  }


  public WorkItemStatus progress(ApproximateProgress progress) {
    this.progress = progress;
    return this;
  }

  /**
   * Get progress
   * @return progress
   */
  @javax.annotation.Nullable
  public ApproximateProgress getProgress() {
    return progress;
  }

  public void setProgress(ApproximateProgress progress) {
    this.progress = progress;
  }


  public WorkItemStatus reportIndex(String reportIndex) {
    this.reportIndex = reportIndex;
    return this;
  }

  /**
   * The report index. When a WorkItem is leased, the lease will contain an initial report index. When a WorkItem&#39;s status is reported to the system, the report should be sent with that report index, and the response will contain the index the worker should use for the next report. Reports received with unexpected index values will be rejected by the service. In order to preserve idempotency, the worker should not alter the contents of a report, even if the worker must submit the same report multiple times before getting back a response. The worker should not submit a subsequent report until the response for the previous report had been received from the service.
   * @return reportIndex
   */
  @javax.annotation.Nullable
  public String getReportIndex() {
    return reportIndex;
  }

  public void setReportIndex(String reportIndex) {
    this.reportIndex = reportIndex;
  }


  public WorkItemStatus reportedProgress(ApproximateReportedProgress reportedProgress) {
    this.reportedProgress = reportedProgress;
    return this;
  }

  /**
   * Get reportedProgress
   * @return reportedProgress
   */
  @javax.annotation.Nullable
  public ApproximateReportedProgress getReportedProgress() {
    return reportedProgress;
  }

  public void setReportedProgress(ApproximateReportedProgress reportedProgress) {
    this.reportedProgress = reportedProgress;
  }


  public WorkItemStatus requestedLeaseDuration(String requestedLeaseDuration) {
    this.requestedLeaseDuration = requestedLeaseDuration;
    return this;
  }

  /**
   * Amount of time the worker requests for its lease.
   * @return requestedLeaseDuration
   */
  @javax.annotation.Nullable
  public String getRequestedLeaseDuration() {
    return requestedLeaseDuration;
  }

  public void setRequestedLeaseDuration(String requestedLeaseDuration) {
    this.requestedLeaseDuration = requestedLeaseDuration;
  }


  public WorkItemStatus sourceFork(SourceFork sourceFork) {
    this.sourceFork = sourceFork;
    return this;
  }

  /**
   * Get sourceFork
   * @return sourceFork
   */
  @javax.annotation.Nullable
  public SourceFork getSourceFork() {
    return sourceFork;
  }

  public void setSourceFork(SourceFork sourceFork) {
    this.sourceFork = sourceFork;
  }


  public WorkItemStatus sourceOperationResponse(SourceOperationResponse sourceOperationResponse) {
    this.sourceOperationResponse = sourceOperationResponse;
    return this;
  }

  /**
   * Get sourceOperationResponse
   * @return sourceOperationResponse
   */
  @javax.annotation.Nullable
  public SourceOperationResponse getSourceOperationResponse() {
    return sourceOperationResponse;
  }

  public void setSourceOperationResponse(SourceOperationResponse sourceOperationResponse) {
    this.sourceOperationResponse = sourceOperationResponse;
  }


  public WorkItemStatus stopPosition(Position stopPosition) {
    this.stopPosition = stopPosition;
    return this;
  }

  /**
   * Get stopPosition
   * @return stopPosition
   */
  @javax.annotation.Nullable
  public Position getStopPosition() {
    return stopPosition;
  }

  public void setStopPosition(Position stopPosition) {
    this.stopPosition = stopPosition;
  }


  public WorkItemStatus totalThrottlerWaitTimeSeconds(Double totalThrottlerWaitTimeSeconds) {
    this.totalThrottlerWaitTimeSeconds = totalThrottlerWaitTimeSeconds;
    return this;
  }

  /**
   * Total time the worker spent being throttled by external systems.
   * @return totalThrottlerWaitTimeSeconds
   */
  @javax.annotation.Nullable
  public Double getTotalThrottlerWaitTimeSeconds() {
    return totalThrottlerWaitTimeSeconds;
  }

  public void setTotalThrottlerWaitTimeSeconds(Double totalThrottlerWaitTimeSeconds) {
    this.totalThrottlerWaitTimeSeconds = totalThrottlerWaitTimeSeconds;
  }


  public WorkItemStatus workItemId(String workItemId) {
    this.workItemId = workItemId;
    return this;
  }

  /**
   * Identifies the WorkItem.
   * @return workItemId
   */
  @javax.annotation.Nullable
  public String getWorkItemId() {
    return workItemId;
  }

  public void setWorkItemId(String workItemId) {
    this.workItemId = workItemId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WorkItemStatus workItemStatus = (WorkItemStatus) o;
    return Objects.equals(this.completed, workItemStatus.completed) &&
        Objects.equals(this.counterUpdates, workItemStatus.counterUpdates) &&
        Objects.equals(this.dynamicSourceSplit, workItemStatus.dynamicSourceSplit) &&
        Objects.equals(this.errors, workItemStatus.errors) &&
        Objects.equals(this.metricUpdates, workItemStatus.metricUpdates) &&
        Objects.equals(this.progress, workItemStatus.progress) &&
        Objects.equals(this.reportIndex, workItemStatus.reportIndex) &&
        Objects.equals(this.reportedProgress, workItemStatus.reportedProgress) &&
        Objects.equals(this.requestedLeaseDuration, workItemStatus.requestedLeaseDuration) &&
        Objects.equals(this.sourceFork, workItemStatus.sourceFork) &&
        Objects.equals(this.sourceOperationResponse, workItemStatus.sourceOperationResponse) &&
        Objects.equals(this.stopPosition, workItemStatus.stopPosition) &&
        Objects.equals(this.totalThrottlerWaitTimeSeconds, workItemStatus.totalThrottlerWaitTimeSeconds) &&
        Objects.equals(this.workItemId, workItemStatus.workItemId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(completed, counterUpdates, dynamicSourceSplit, errors, metricUpdates, progress, reportIndex, reportedProgress, requestedLeaseDuration, sourceFork, sourceOperationResponse, stopPosition, totalThrottlerWaitTimeSeconds, workItemId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WorkItemStatus {\n");
    sb.append("    completed: ").append(toIndentedString(completed)).append("\n");
    sb.append("    counterUpdates: ").append(toIndentedString(counterUpdates)).append("\n");
    sb.append("    dynamicSourceSplit: ").append(toIndentedString(dynamicSourceSplit)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    metricUpdates: ").append(toIndentedString(metricUpdates)).append("\n");
    sb.append("    progress: ").append(toIndentedString(progress)).append("\n");
    sb.append("    reportIndex: ").append(toIndentedString(reportIndex)).append("\n");
    sb.append("    reportedProgress: ").append(toIndentedString(reportedProgress)).append("\n");
    sb.append("    requestedLeaseDuration: ").append(toIndentedString(requestedLeaseDuration)).append("\n");
    sb.append("    sourceFork: ").append(toIndentedString(sourceFork)).append("\n");
    sb.append("    sourceOperationResponse: ").append(toIndentedString(sourceOperationResponse)).append("\n");
    sb.append("    stopPosition: ").append(toIndentedString(stopPosition)).append("\n");
    sb.append("    totalThrottlerWaitTimeSeconds: ").append(toIndentedString(totalThrottlerWaitTimeSeconds)).append("\n");
    sb.append("    workItemId: ").append(toIndentedString(workItemId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("completed");
    openapiFields.add("counterUpdates");
    openapiFields.add("dynamicSourceSplit");
    openapiFields.add("errors");
    openapiFields.add("metricUpdates");
    openapiFields.add("progress");
    openapiFields.add("reportIndex");
    openapiFields.add("reportedProgress");
    openapiFields.add("requestedLeaseDuration");
    openapiFields.add("sourceFork");
    openapiFields.add("sourceOperationResponse");
    openapiFields.add("stopPosition");
    openapiFields.add("totalThrottlerWaitTimeSeconds");
    openapiFields.add("workItemId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WorkItemStatus
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WorkItemStatus.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WorkItemStatus is not found in the empty JSON string", WorkItemStatus.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WorkItemStatus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WorkItemStatus` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("counterUpdates") != null && !jsonObj.get("counterUpdates").isJsonNull()) {
        JsonArray jsonArraycounterUpdates = jsonObj.getAsJsonArray("counterUpdates");
        if (jsonArraycounterUpdates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("counterUpdates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `counterUpdates` to be an array in the JSON string but got `%s`", jsonObj.get("counterUpdates").toString()));
          }

          // validate the optional field `counterUpdates` (array)
          for (int i = 0; i < jsonArraycounterUpdates.size(); i++) {
            CounterUpdate.validateJsonElement(jsonArraycounterUpdates.get(i));
          };
        }
      }
      // validate the optional field `dynamicSourceSplit`
      if (jsonObj.get("dynamicSourceSplit") != null && !jsonObj.get("dynamicSourceSplit").isJsonNull()) {
        DynamicSourceSplit.validateJsonElement(jsonObj.get("dynamicSourceSplit"));
      }
      if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
        JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
        if (jsonArrayerrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errors` to be an array in the JSON string but got `%s`", jsonObj.get("errors").toString()));
          }

          // validate the optional field `errors` (array)
          for (int i = 0; i < jsonArrayerrors.size(); i++) {
            Status.validateJsonElement(jsonArrayerrors.get(i));
          };
        }
      }
      if (jsonObj.get("metricUpdates") != null && !jsonObj.get("metricUpdates").isJsonNull()) {
        JsonArray jsonArraymetricUpdates = jsonObj.getAsJsonArray("metricUpdates");
        if (jsonArraymetricUpdates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metricUpdates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metricUpdates` to be an array in the JSON string but got `%s`", jsonObj.get("metricUpdates").toString()));
          }

          // validate the optional field `metricUpdates` (array)
          for (int i = 0; i < jsonArraymetricUpdates.size(); i++) {
            MetricUpdate.validateJsonElement(jsonArraymetricUpdates.get(i));
          };
        }
      }
      // validate the optional field `progress`
      if (jsonObj.get("progress") != null && !jsonObj.get("progress").isJsonNull()) {
        ApproximateProgress.validateJsonElement(jsonObj.get("progress"));
      }
      if ((jsonObj.get("reportIndex") != null && !jsonObj.get("reportIndex").isJsonNull()) && !jsonObj.get("reportIndex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reportIndex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reportIndex").toString()));
      }
      // validate the optional field `reportedProgress`
      if (jsonObj.get("reportedProgress") != null && !jsonObj.get("reportedProgress").isJsonNull()) {
        ApproximateReportedProgress.validateJsonElement(jsonObj.get("reportedProgress"));
      }
      if ((jsonObj.get("requestedLeaseDuration") != null && !jsonObj.get("requestedLeaseDuration").isJsonNull()) && !jsonObj.get("requestedLeaseDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedLeaseDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedLeaseDuration").toString()));
      }
      // validate the optional field `sourceFork`
      if (jsonObj.get("sourceFork") != null && !jsonObj.get("sourceFork").isJsonNull()) {
        SourceFork.validateJsonElement(jsonObj.get("sourceFork"));
      }
      // validate the optional field `sourceOperationResponse`
      if (jsonObj.get("sourceOperationResponse") != null && !jsonObj.get("sourceOperationResponse").isJsonNull()) {
        SourceOperationResponse.validateJsonElement(jsonObj.get("sourceOperationResponse"));
      }
      // validate the optional field `stopPosition`
      if (jsonObj.get("stopPosition") != null && !jsonObj.get("stopPosition").isJsonNull()) {
        Position.validateJsonElement(jsonObj.get("stopPosition"));
      }
      if ((jsonObj.get("workItemId") != null && !jsonObj.get("workItemId").isJsonNull()) && !jsonObj.get("workItemId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workItemId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workItemId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WorkItemStatus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WorkItemStatus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WorkItemStatus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WorkItemStatus.class));

       return (TypeAdapter<T>) new TypeAdapter<WorkItemStatus>() {
           @Override
           public void write(JsonWriter out, WorkItemStatus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WorkItemStatus read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WorkItemStatus given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WorkItemStatus
   * @throws IOException if the JSON string is invalid with respect to WorkItemStatus
   */
  public static WorkItemStatus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WorkItemStatus.class);
  }

  /**
   * Convert an instance of WorkItemStatus to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

