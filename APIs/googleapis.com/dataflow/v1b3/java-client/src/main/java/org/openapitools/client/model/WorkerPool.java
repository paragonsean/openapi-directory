/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.AutoscalingSettings;
import org.openapitools.client.model.Disk;
import org.openapitools.client.model.ModelPackage;
import org.openapitools.client.model.SdkHarnessContainerImage;
import org.openapitools.client.model.TaskRunnerSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes one particular pool of Cloud Dataflow workers to be instantiated by the Cloud Dataflow service in order to perform the computations required by a job. Note that a workflow job may use multiple pools, in order to match the various computational requirements of the various stages of the job.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WorkerPool {
  public static final String SERIALIZED_NAME_AUTOSCALING_SETTINGS = "autoscalingSettings";
  @SerializedName(SERIALIZED_NAME_AUTOSCALING_SETTINGS)
  private AutoscalingSettings autoscalingSettings;

  public static final String SERIALIZED_NAME_DATA_DISKS = "dataDisks";
  @SerializedName(SERIALIZED_NAME_DATA_DISKS)
  private List<Disk> dataDisks = new ArrayList<>();

  /**
   * The default package set to install. This allows the service to select a default set of packages which are useful to worker harnesses written in a particular language.
   */
  @JsonAdapter(DefaultPackageSetEnum.Adapter.class)
  public enum DefaultPackageSetEnum {
    UNKNOWN("DEFAULT_PACKAGE_SET_UNKNOWN"),
    
    NONE("DEFAULT_PACKAGE_SET_NONE"),
    
    JAVA("DEFAULT_PACKAGE_SET_JAVA"),
    
    PYTHON("DEFAULT_PACKAGE_SET_PYTHON");

    private String value;

    DefaultPackageSetEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultPackageSetEnum fromValue(String value) {
      for (DefaultPackageSetEnum b : DefaultPackageSetEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultPackageSetEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultPackageSetEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultPackageSetEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DefaultPackageSetEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DefaultPackageSetEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_PACKAGE_SET = "defaultPackageSet";
  @SerializedName(SERIALIZED_NAME_DEFAULT_PACKAGE_SET)
  private DefaultPackageSetEnum defaultPackageSet;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_DISK_SOURCE_IMAGE = "diskSourceImage";
  @SerializedName(SERIALIZED_NAME_DISK_SOURCE_IMAGE)
  private String diskSourceImage;

  public static final String SERIALIZED_NAME_DISK_TYPE = "diskType";
  @SerializedName(SERIALIZED_NAME_DISK_TYPE)
  private String diskType;

  /**
   * Configuration for VM IPs.
   */
  @JsonAdapter(IpConfigurationEnum.Adapter.class)
  public enum IpConfigurationEnum {
    UNSPECIFIED("WORKER_IP_UNSPECIFIED"),
    
    PUBLIC("WORKER_IP_PUBLIC"),
    
    PRIVATE("WORKER_IP_PRIVATE");

    private String value;

    IpConfigurationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IpConfigurationEnum fromValue(String value) {
      for (IpConfigurationEnum b : IpConfigurationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IpConfigurationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IpConfigurationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IpConfigurationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IpConfigurationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IpConfigurationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IP_CONFIGURATION = "ipConfiguration";
  @SerializedName(SERIALIZED_NAME_IP_CONFIGURATION)
  private IpConfigurationEnum ipConfiguration;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_NUM_THREADS_PER_WORKER = "numThreadsPerWorker";
  @SerializedName(SERIALIZED_NAME_NUM_THREADS_PER_WORKER)
  private Integer numThreadsPerWorker;

  public static final String SERIALIZED_NAME_NUM_WORKERS = "numWorkers";
  @SerializedName(SERIALIZED_NAME_NUM_WORKERS)
  private Integer numWorkers;

  public static final String SERIALIZED_NAME_ON_HOST_MAINTENANCE = "onHostMaintenance";
  @SerializedName(SERIALIZED_NAME_ON_HOST_MAINTENANCE)
  private String onHostMaintenance;

  public static final String SERIALIZED_NAME_PACKAGES = "packages";
  @SerializedName(SERIALIZED_NAME_PACKAGES)
  private List<ModelPackage> packages = new ArrayList<>();

  public static final String SERIALIZED_NAME_POOL_ARGS = "poolArgs";
  @SerializedName(SERIALIZED_NAME_POOL_ARGS)
  private Map<String, Object> poolArgs = new HashMap<>();

  public static final String SERIALIZED_NAME_SDK_HARNESS_CONTAINER_IMAGES = "sdkHarnessContainerImages";
  @SerializedName(SERIALIZED_NAME_SDK_HARNESS_CONTAINER_IMAGES)
  private List<SdkHarnessContainerImage> sdkHarnessContainerImages = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_TASKRUNNER_SETTINGS = "taskrunnerSettings";
  @SerializedName(SERIALIZED_NAME_TASKRUNNER_SETTINGS)
  private TaskRunnerSettings taskrunnerSettings;

  /**
   * Sets the policy for determining when to turndown worker pool. Allowed values are: &#x60;TEARDOWN_ALWAYS&#x60;, &#x60;TEARDOWN_ON_SUCCESS&#x60;, and &#x60;TEARDOWN_NEVER&#x60;. &#x60;TEARDOWN_ALWAYS&#x60; means workers are always torn down regardless of whether the job succeeds. &#x60;TEARDOWN_ON_SUCCESS&#x60; means workers are torn down if the job succeeds. &#x60;TEARDOWN_NEVER&#x60; means the workers are never torn down. If the workers are not torn down by the service, they will continue to run and use Google Compute Engine VM resources in the user&#39;s project until they are explicitly terminated by the user. Because of this, Google recommends using the &#x60;TEARDOWN_ALWAYS&#x60; policy except for small, manually supervised test jobs. If unknown or unspecified, the service will attempt to choose a reasonable default.
   */
  @JsonAdapter(TeardownPolicyEnum.Adapter.class)
  public enum TeardownPolicyEnum {
    POLICY_UNKNOWN("TEARDOWN_POLICY_UNKNOWN"),
    
    ALWAYS("TEARDOWN_ALWAYS"),
    
    ON_SUCCESS("TEARDOWN_ON_SUCCESS"),
    
    NEVER("TEARDOWN_NEVER");

    private String value;

    TeardownPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TeardownPolicyEnum fromValue(String value) {
      for (TeardownPolicyEnum b : TeardownPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TeardownPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TeardownPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TeardownPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TeardownPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TeardownPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TEARDOWN_POLICY = "teardownPolicy";
  @SerializedName(SERIALIZED_NAME_TEARDOWN_POLICY)
  private TeardownPolicyEnum teardownPolicy;

  public static final String SERIALIZED_NAME_WORKER_HARNESS_CONTAINER_IMAGE = "workerHarnessContainerImage";
  @SerializedName(SERIALIZED_NAME_WORKER_HARNESS_CONTAINER_IMAGE)
  private String workerHarnessContainerImage;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public WorkerPool() {
  }

  public WorkerPool autoscalingSettings(AutoscalingSettings autoscalingSettings) {
    this.autoscalingSettings = autoscalingSettings;
    return this;
  }

  /**
   * Get autoscalingSettings
   * @return autoscalingSettings
   */
  @javax.annotation.Nullable
  public AutoscalingSettings getAutoscalingSettings() {
    return autoscalingSettings;
  }

  public void setAutoscalingSettings(AutoscalingSettings autoscalingSettings) {
    this.autoscalingSettings = autoscalingSettings;
  }


  public WorkerPool dataDisks(List<Disk> dataDisks) {
    this.dataDisks = dataDisks;
    return this;
  }

  public WorkerPool addDataDisksItem(Disk dataDisksItem) {
    if (this.dataDisks == null) {
      this.dataDisks = new ArrayList<>();
    }
    this.dataDisks.add(dataDisksItem);
    return this;
  }

  /**
   * Data disks that are used by a VM in this workflow.
   * @return dataDisks
   */
  @javax.annotation.Nullable
  public List<Disk> getDataDisks() {
    return dataDisks;
  }

  public void setDataDisks(List<Disk> dataDisks) {
    this.dataDisks = dataDisks;
  }


  public WorkerPool defaultPackageSet(DefaultPackageSetEnum defaultPackageSet) {
    this.defaultPackageSet = defaultPackageSet;
    return this;
  }

  /**
   * The default package set to install. This allows the service to select a default set of packages which are useful to worker harnesses written in a particular language.
   * @return defaultPackageSet
   */
  @javax.annotation.Nullable
  public DefaultPackageSetEnum getDefaultPackageSet() {
    return defaultPackageSet;
  }

  public void setDefaultPackageSet(DefaultPackageSetEnum defaultPackageSet) {
    this.defaultPackageSet = defaultPackageSet;
  }


  public WorkerPool diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Size of root disk for VMs, in GB. If zero or unspecified, the service will attempt to choose a reasonable default.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public WorkerPool diskSourceImage(String diskSourceImage) {
    this.diskSourceImage = diskSourceImage;
    return this;
  }

  /**
   * Fully qualified source image for disks.
   * @return diskSourceImage
   */
  @javax.annotation.Nullable
  public String getDiskSourceImage() {
    return diskSourceImage;
  }

  public void setDiskSourceImage(String diskSourceImage) {
    this.diskSourceImage = diskSourceImage;
  }


  public WorkerPool diskType(String diskType) {
    this.diskType = diskType;
    return this;
  }

  /**
   * Type of root disk for VMs. If empty or unspecified, the service will attempt to choose a reasonable default.
   * @return diskType
   */
  @javax.annotation.Nullable
  public String getDiskType() {
    return diskType;
  }

  public void setDiskType(String diskType) {
    this.diskType = diskType;
  }


  public WorkerPool ipConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
    return this;
  }

  /**
   * Configuration for VM IPs.
   * @return ipConfiguration
   */
  @javax.annotation.Nullable
  public IpConfigurationEnum getIpConfiguration() {
    return ipConfiguration;
  }

  public void setIpConfiguration(IpConfigurationEnum ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
  }


  public WorkerPool kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * The kind of the worker pool; currently only &#x60;harness&#x60; and &#x60;shuffle&#x60; are supported.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public WorkerPool machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Machine type (e.g. \&quot;n1-standard-1\&quot;). If empty or unspecified, the service will attempt to choose a reasonable default.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public WorkerPool metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public WorkerPool putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Metadata to set on the Google Compute Engine VMs.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public WorkerPool network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Network to which VMs will be assigned. If empty or unspecified, the service will use the network \&quot;default\&quot;.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public WorkerPool numThreadsPerWorker(Integer numThreadsPerWorker) {
    this.numThreadsPerWorker = numThreadsPerWorker;
    return this;
  }

  /**
   * The number of threads per worker harness. If empty or unspecified, the service will choose a number of threads (according to the number of cores on the selected machine type for batch, or 1 by convention for streaming).
   * @return numThreadsPerWorker
   */
  @javax.annotation.Nullable
  public Integer getNumThreadsPerWorker() {
    return numThreadsPerWorker;
  }

  public void setNumThreadsPerWorker(Integer numThreadsPerWorker) {
    this.numThreadsPerWorker = numThreadsPerWorker;
  }


  public WorkerPool numWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
    return this;
  }

  /**
   * Number of Google Compute Engine workers in this pool needed to execute the job. If zero or unspecified, the service will attempt to choose a reasonable default.
   * @return numWorkers
   */
  @javax.annotation.Nullable
  public Integer getNumWorkers() {
    return numWorkers;
  }

  public void setNumWorkers(Integer numWorkers) {
    this.numWorkers = numWorkers;
  }


  public WorkerPool onHostMaintenance(String onHostMaintenance) {
    this.onHostMaintenance = onHostMaintenance;
    return this;
  }

  /**
   * The action to take on host maintenance, as defined by the Google Compute Engine API.
   * @return onHostMaintenance
   */
  @javax.annotation.Nullable
  public String getOnHostMaintenance() {
    return onHostMaintenance;
  }

  public void setOnHostMaintenance(String onHostMaintenance) {
    this.onHostMaintenance = onHostMaintenance;
  }


  public WorkerPool packages(List<ModelPackage> packages) {
    this.packages = packages;
    return this;
  }

  public WorkerPool addPackagesItem(ModelPackage packagesItem) {
    if (this.packages == null) {
      this.packages = new ArrayList<>();
    }
    this.packages.add(packagesItem);
    return this;
  }

  /**
   * Packages to be installed on workers.
   * @return packages
   */
  @javax.annotation.Nullable
  public List<ModelPackage> getPackages() {
    return packages;
  }

  public void setPackages(List<ModelPackage> packages) {
    this.packages = packages;
  }


  public WorkerPool poolArgs(Map<String, Object> poolArgs) {
    this.poolArgs = poolArgs;
    return this;
  }

  public WorkerPool putPoolArgsItem(String key, Object poolArgsItem) {
    if (this.poolArgs == null) {
      this.poolArgs = new HashMap<>();
    }
    this.poolArgs.put(key, poolArgsItem);
    return this;
  }

  /**
   * Extra arguments for this worker pool.
   * @return poolArgs
   */
  @javax.annotation.Nullable
  public Map<String, Object> getPoolArgs() {
    return poolArgs;
  }

  public void setPoolArgs(Map<String, Object> poolArgs) {
    this.poolArgs = poolArgs;
  }


  public WorkerPool sdkHarnessContainerImages(List<SdkHarnessContainerImage> sdkHarnessContainerImages) {
    this.sdkHarnessContainerImages = sdkHarnessContainerImages;
    return this;
  }

  public WorkerPool addSdkHarnessContainerImagesItem(SdkHarnessContainerImage sdkHarnessContainerImagesItem) {
    if (this.sdkHarnessContainerImages == null) {
      this.sdkHarnessContainerImages = new ArrayList<>();
    }
    this.sdkHarnessContainerImages.add(sdkHarnessContainerImagesItem);
    return this;
  }

  /**
   * Set of SDK harness containers needed to execute this pipeline. This will only be set in the Fn API path. For non-cross-language pipelines this should have only one entry. Cross-language pipelines will have two or more entries.
   * @return sdkHarnessContainerImages
   */
  @javax.annotation.Nullable
  public List<SdkHarnessContainerImage> getSdkHarnessContainerImages() {
    return sdkHarnessContainerImages;
  }

  public void setSdkHarnessContainerImages(List<SdkHarnessContainerImage> sdkHarnessContainerImages) {
    this.sdkHarnessContainerImages = sdkHarnessContainerImages;
  }


  public WorkerPool subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Subnetwork to which VMs will be assigned, if desired. Expected to be of the form \&quot;regions/REGION/subnetworks/SUBNETWORK\&quot;.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  public WorkerPool taskrunnerSettings(TaskRunnerSettings taskrunnerSettings) {
    this.taskrunnerSettings = taskrunnerSettings;
    return this;
  }

  /**
   * Get taskrunnerSettings
   * @return taskrunnerSettings
   */
  @javax.annotation.Nullable
  public TaskRunnerSettings getTaskrunnerSettings() {
    return taskrunnerSettings;
  }

  public void setTaskrunnerSettings(TaskRunnerSettings taskrunnerSettings) {
    this.taskrunnerSettings = taskrunnerSettings;
  }


  public WorkerPool teardownPolicy(TeardownPolicyEnum teardownPolicy) {
    this.teardownPolicy = teardownPolicy;
    return this;
  }

  /**
   * Sets the policy for determining when to turndown worker pool. Allowed values are: &#x60;TEARDOWN_ALWAYS&#x60;, &#x60;TEARDOWN_ON_SUCCESS&#x60;, and &#x60;TEARDOWN_NEVER&#x60;. &#x60;TEARDOWN_ALWAYS&#x60; means workers are always torn down regardless of whether the job succeeds. &#x60;TEARDOWN_ON_SUCCESS&#x60; means workers are torn down if the job succeeds. &#x60;TEARDOWN_NEVER&#x60; means the workers are never torn down. If the workers are not torn down by the service, they will continue to run and use Google Compute Engine VM resources in the user&#39;s project until they are explicitly terminated by the user. Because of this, Google recommends using the &#x60;TEARDOWN_ALWAYS&#x60; policy except for small, manually supervised test jobs. If unknown or unspecified, the service will attempt to choose a reasonable default.
   * @return teardownPolicy
   */
  @javax.annotation.Nullable
  public TeardownPolicyEnum getTeardownPolicy() {
    return teardownPolicy;
  }

  public void setTeardownPolicy(TeardownPolicyEnum teardownPolicy) {
    this.teardownPolicy = teardownPolicy;
  }


  public WorkerPool workerHarnessContainerImage(String workerHarnessContainerImage) {
    this.workerHarnessContainerImage = workerHarnessContainerImage;
    return this;
  }

  /**
   * Required. Docker container image that executes the Cloud Dataflow worker harness, residing in Google Container Registry. Deprecated for the Fn API path. Use sdk_harness_container_images instead.
   * @return workerHarnessContainerImage
   */
  @javax.annotation.Nullable
  public String getWorkerHarnessContainerImage() {
    return workerHarnessContainerImage;
  }

  public void setWorkerHarnessContainerImage(String workerHarnessContainerImage) {
    this.workerHarnessContainerImage = workerHarnessContainerImage;
  }


  public WorkerPool zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * Zone to run the worker pools in. If empty or unspecified, the service will attempt to choose a reasonable default.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WorkerPool workerPool = (WorkerPool) o;
    return Objects.equals(this.autoscalingSettings, workerPool.autoscalingSettings) &&
        Objects.equals(this.dataDisks, workerPool.dataDisks) &&
        Objects.equals(this.defaultPackageSet, workerPool.defaultPackageSet) &&
        Objects.equals(this.diskSizeGb, workerPool.diskSizeGb) &&
        Objects.equals(this.diskSourceImage, workerPool.diskSourceImage) &&
        Objects.equals(this.diskType, workerPool.diskType) &&
        Objects.equals(this.ipConfiguration, workerPool.ipConfiguration) &&
        Objects.equals(this.kind, workerPool.kind) &&
        Objects.equals(this.machineType, workerPool.machineType) &&
        Objects.equals(this.metadata, workerPool.metadata) &&
        Objects.equals(this.network, workerPool.network) &&
        Objects.equals(this.numThreadsPerWorker, workerPool.numThreadsPerWorker) &&
        Objects.equals(this.numWorkers, workerPool.numWorkers) &&
        Objects.equals(this.onHostMaintenance, workerPool.onHostMaintenance) &&
        Objects.equals(this.packages, workerPool.packages) &&
        Objects.equals(this.poolArgs, workerPool.poolArgs) &&
        Objects.equals(this.sdkHarnessContainerImages, workerPool.sdkHarnessContainerImages) &&
        Objects.equals(this.subnetwork, workerPool.subnetwork) &&
        Objects.equals(this.taskrunnerSettings, workerPool.taskrunnerSettings) &&
        Objects.equals(this.teardownPolicy, workerPool.teardownPolicy) &&
        Objects.equals(this.workerHarnessContainerImage, workerPool.workerHarnessContainerImage) &&
        Objects.equals(this.zone, workerPool.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoscalingSettings, dataDisks, defaultPackageSet, diskSizeGb, diskSourceImage, diskType, ipConfiguration, kind, machineType, metadata, network, numThreadsPerWorker, numWorkers, onHostMaintenance, packages, poolArgs, sdkHarnessContainerImages, subnetwork, taskrunnerSettings, teardownPolicy, workerHarnessContainerImage, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WorkerPool {\n");
    sb.append("    autoscalingSettings: ").append(toIndentedString(autoscalingSettings)).append("\n");
    sb.append("    dataDisks: ").append(toIndentedString(dataDisks)).append("\n");
    sb.append("    defaultPackageSet: ").append(toIndentedString(defaultPackageSet)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    diskSourceImage: ").append(toIndentedString(diskSourceImage)).append("\n");
    sb.append("    diskType: ").append(toIndentedString(diskType)).append("\n");
    sb.append("    ipConfiguration: ").append(toIndentedString(ipConfiguration)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    numThreadsPerWorker: ").append(toIndentedString(numThreadsPerWorker)).append("\n");
    sb.append("    numWorkers: ").append(toIndentedString(numWorkers)).append("\n");
    sb.append("    onHostMaintenance: ").append(toIndentedString(onHostMaintenance)).append("\n");
    sb.append("    packages: ").append(toIndentedString(packages)).append("\n");
    sb.append("    poolArgs: ").append(toIndentedString(poolArgs)).append("\n");
    sb.append("    sdkHarnessContainerImages: ").append(toIndentedString(sdkHarnessContainerImages)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    taskrunnerSettings: ").append(toIndentedString(taskrunnerSettings)).append("\n");
    sb.append("    teardownPolicy: ").append(toIndentedString(teardownPolicy)).append("\n");
    sb.append("    workerHarnessContainerImage: ").append(toIndentedString(workerHarnessContainerImage)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoscalingSettings");
    openapiFields.add("dataDisks");
    openapiFields.add("defaultPackageSet");
    openapiFields.add("diskSizeGb");
    openapiFields.add("diskSourceImage");
    openapiFields.add("diskType");
    openapiFields.add("ipConfiguration");
    openapiFields.add("kind");
    openapiFields.add("machineType");
    openapiFields.add("metadata");
    openapiFields.add("network");
    openapiFields.add("numThreadsPerWorker");
    openapiFields.add("numWorkers");
    openapiFields.add("onHostMaintenance");
    openapiFields.add("packages");
    openapiFields.add("poolArgs");
    openapiFields.add("sdkHarnessContainerImages");
    openapiFields.add("subnetwork");
    openapiFields.add("taskrunnerSettings");
    openapiFields.add("teardownPolicy");
    openapiFields.add("workerHarnessContainerImage");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WorkerPool
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WorkerPool.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WorkerPool is not found in the empty JSON string", WorkerPool.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WorkerPool.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WorkerPool` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `autoscalingSettings`
      if (jsonObj.get("autoscalingSettings") != null && !jsonObj.get("autoscalingSettings").isJsonNull()) {
        AutoscalingSettings.validateJsonElement(jsonObj.get("autoscalingSettings"));
      }
      if (jsonObj.get("dataDisks") != null && !jsonObj.get("dataDisks").isJsonNull()) {
        JsonArray jsonArraydataDisks = jsonObj.getAsJsonArray("dataDisks");
        if (jsonArraydataDisks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dataDisks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dataDisks` to be an array in the JSON string but got `%s`", jsonObj.get("dataDisks").toString()));
          }

          // validate the optional field `dataDisks` (array)
          for (int i = 0; i < jsonArraydataDisks.size(); i++) {
            Disk.validateJsonElement(jsonArraydataDisks.get(i));
          };
        }
      }
      if ((jsonObj.get("defaultPackageSet") != null && !jsonObj.get("defaultPackageSet").isJsonNull()) && !jsonObj.get("defaultPackageSet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultPackageSet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultPackageSet").toString()));
      }
      // validate the optional field `defaultPackageSet`
      if (jsonObj.get("defaultPackageSet") != null && !jsonObj.get("defaultPackageSet").isJsonNull()) {
        DefaultPackageSetEnum.validateJsonElement(jsonObj.get("defaultPackageSet"));
      }
      if ((jsonObj.get("diskSourceImage") != null && !jsonObj.get("diskSourceImage").isJsonNull()) && !jsonObj.get("diskSourceImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskSourceImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskSourceImage").toString()));
      }
      if ((jsonObj.get("diskType") != null && !jsonObj.get("diskType").isJsonNull()) && !jsonObj.get("diskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskType").toString()));
      }
      if ((jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) && !jsonObj.get("ipConfiguration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipConfiguration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipConfiguration").toString()));
      }
      // validate the optional field `ipConfiguration`
      if (jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) {
        IpConfigurationEnum.validateJsonElement(jsonObj.get("ipConfiguration"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("onHostMaintenance") != null && !jsonObj.get("onHostMaintenance").isJsonNull()) && !jsonObj.get("onHostMaintenance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `onHostMaintenance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("onHostMaintenance").toString()));
      }
      if (jsonObj.get("packages") != null && !jsonObj.get("packages").isJsonNull()) {
        JsonArray jsonArraypackages = jsonObj.getAsJsonArray("packages");
        if (jsonArraypackages != null) {
          // ensure the json data is an array
          if (!jsonObj.get("packages").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `packages` to be an array in the JSON string but got `%s`", jsonObj.get("packages").toString()));
          }

          // validate the optional field `packages` (array)
          for (int i = 0; i < jsonArraypackages.size(); i++) {
            ModelPackage.validateJsonElement(jsonArraypackages.get(i));
          };
        }
      }
      if (jsonObj.get("sdkHarnessContainerImages") != null && !jsonObj.get("sdkHarnessContainerImages").isJsonNull()) {
        JsonArray jsonArraysdkHarnessContainerImages = jsonObj.getAsJsonArray("sdkHarnessContainerImages");
        if (jsonArraysdkHarnessContainerImages != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sdkHarnessContainerImages").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sdkHarnessContainerImages` to be an array in the JSON string but got `%s`", jsonObj.get("sdkHarnessContainerImages").toString()));
          }

          // validate the optional field `sdkHarnessContainerImages` (array)
          for (int i = 0; i < jsonArraysdkHarnessContainerImages.size(); i++) {
            SdkHarnessContainerImage.validateJsonElement(jsonArraysdkHarnessContainerImages.get(i));
          };
        }
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      // validate the optional field `taskrunnerSettings`
      if (jsonObj.get("taskrunnerSettings") != null && !jsonObj.get("taskrunnerSettings").isJsonNull()) {
        TaskRunnerSettings.validateJsonElement(jsonObj.get("taskrunnerSettings"));
      }
      if ((jsonObj.get("teardownPolicy") != null && !jsonObj.get("teardownPolicy").isJsonNull()) && !jsonObj.get("teardownPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `teardownPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("teardownPolicy").toString()));
      }
      // validate the optional field `teardownPolicy`
      if (jsonObj.get("teardownPolicy") != null && !jsonObj.get("teardownPolicy").isJsonNull()) {
        TeardownPolicyEnum.validateJsonElement(jsonObj.get("teardownPolicy"));
      }
      if ((jsonObj.get("workerHarnessContainerImage") != null && !jsonObj.get("workerHarnessContainerImage").isJsonNull()) && !jsonObj.get("workerHarnessContainerImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerHarnessContainerImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerHarnessContainerImage").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WorkerPool.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WorkerPool' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WorkerPool> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WorkerPool.class));

       return (TypeAdapter<T>) new TypeAdapter<WorkerPool>() {
           @Override
           public void write(JsonWriter out, WorkerPool value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WorkerPool read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WorkerPool given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WorkerPool
   * @throws IOException if the JSON string is invalid with respect to WorkerPool
   */
  public static WorkerPool fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WorkerPool.class);
  }

  /**
   * Convert an instance of WorkerPool to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

