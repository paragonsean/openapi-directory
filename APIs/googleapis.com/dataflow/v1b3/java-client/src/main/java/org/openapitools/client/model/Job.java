/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Environment;
import org.openapitools.client.model.ExecutionStageState;
import org.openapitools.client.model.JobExecutionInfo;
import org.openapitools.client.model.JobMetadata;
import org.openapitools.client.model.PipelineDescription;
import org.openapitools.client.model.RuntimeUpdatableParams;
import org.openapitools.client.model.Step;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a job to be run by the Cloud Dataflow service. Do not enter confidential information when you supply string values using the API.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Job {
  public static final String SERIALIZED_NAME_CLIENT_REQUEST_ID = "clientRequestId";
  @SerializedName(SERIALIZED_NAME_CLIENT_REQUEST_ID)
  private String clientRequestId;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CREATED_FROM_SNAPSHOT_ID = "createdFromSnapshotId";
  @SerializedName(SERIALIZED_NAME_CREATED_FROM_SNAPSHOT_ID)
  private String createdFromSnapshotId;

  /**
   * The current state of the job. Jobs are created in the &#x60;JOB_STATE_STOPPED&#x60; state unless otherwise specified. A job in the &#x60;JOB_STATE_RUNNING&#x60; state may asynchronously enter a terminal state. After a job has reached a terminal state, no further state updates may be made. This field might be mutated by the Dataflow service; callers cannot mutate it.
   */
  @JsonAdapter(CurrentStateEnum.Adapter.class)
  public enum CurrentStateEnum {
    UNKNOWN("JOB_STATE_UNKNOWN"),
    
    STOPPED("JOB_STATE_STOPPED"),
    
    RUNNING("JOB_STATE_RUNNING"),
    
    DONE("JOB_STATE_DONE"),
    
    FAILED("JOB_STATE_FAILED"),
    
    CANCELLED("JOB_STATE_CANCELLED"),
    
    UPDATED("JOB_STATE_UPDATED"),
    
    DRAINING("JOB_STATE_DRAINING"),
    
    DRAINED("JOB_STATE_DRAINED"),
    
    PENDING("JOB_STATE_PENDING"),
    
    CANCELLING("JOB_STATE_CANCELLING"),
    
    QUEUED("JOB_STATE_QUEUED"),
    
    RESOURCE_CLEANING_UP("JOB_STATE_RESOURCE_CLEANING_UP");

    private String value;

    CurrentStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CurrentStateEnum fromValue(String value) {
      for (CurrentStateEnum b : CurrentStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CurrentStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CurrentStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CurrentStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CurrentStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CurrentStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CURRENT_STATE = "currentState";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATE)
  private CurrentStateEnum currentState;

  public static final String SERIALIZED_NAME_CURRENT_STATE_TIME = "currentStateTime";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATE_TIME)
  private String currentStateTime;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private Environment environment;

  public static final String SERIALIZED_NAME_EXECUTION_INFO = "executionInfo";
  @SerializedName(SERIALIZED_NAME_EXECUTION_INFO)
  private JobExecutionInfo executionInfo;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_JOB_METADATA = "jobMetadata";
  @SerializedName(SERIALIZED_NAME_JOB_METADATA)
  private JobMetadata jobMetadata;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PIPELINE_DESCRIPTION = "pipelineDescription";
  @SerializedName(SERIALIZED_NAME_PIPELINE_DESCRIPTION)
  private PipelineDescription pipelineDescription;

  public static final String SERIALIZED_NAME_PROJECT_ID = "projectId";
  @SerializedName(SERIALIZED_NAME_PROJECT_ID)
  private String projectId;

  public static final String SERIALIZED_NAME_REPLACE_JOB_ID = "replaceJobId";
  @SerializedName(SERIALIZED_NAME_REPLACE_JOB_ID)
  private String replaceJobId;

  public static final String SERIALIZED_NAME_REPLACED_BY_JOB_ID = "replacedByJobId";
  @SerializedName(SERIALIZED_NAME_REPLACED_BY_JOB_ID)
  private String replacedByJobId;

  /**
   * The job&#39;s requested state. Applies to &#x60;UpdateJob&#x60; requests. Set &#x60;requested_state&#x60; with &#x60;UpdateJob&#x60; requests to switch between the states &#x60;JOB_STATE_STOPPED&#x60; and &#x60;JOB_STATE_RUNNING&#x60;. You can also use &#x60;UpdateJob&#x60; requests to change a job&#39;s state from &#x60;JOB_STATE_RUNNING&#x60; to &#x60;JOB_STATE_CANCELLED&#x60;, &#x60;JOB_STATE_DONE&#x60;, or &#x60;JOB_STATE_DRAINED&#x60;. These states irrevocably terminate the job if it hasn&#39;t already reached a terminal state. This field has no effect on &#x60;CreateJob&#x60; requests.
   */
  @JsonAdapter(RequestedStateEnum.Adapter.class)
  public enum RequestedStateEnum {
    UNKNOWN("JOB_STATE_UNKNOWN"),
    
    STOPPED("JOB_STATE_STOPPED"),
    
    RUNNING("JOB_STATE_RUNNING"),
    
    DONE("JOB_STATE_DONE"),
    
    FAILED("JOB_STATE_FAILED"),
    
    CANCELLED("JOB_STATE_CANCELLED"),
    
    UPDATED("JOB_STATE_UPDATED"),
    
    DRAINING("JOB_STATE_DRAINING"),
    
    DRAINED("JOB_STATE_DRAINED"),
    
    PENDING("JOB_STATE_PENDING"),
    
    CANCELLING("JOB_STATE_CANCELLING"),
    
    QUEUED("JOB_STATE_QUEUED"),
    
    RESOURCE_CLEANING_UP("JOB_STATE_RESOURCE_CLEANING_UP");

    private String value;

    RequestedStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RequestedStateEnum fromValue(String value) {
      for (RequestedStateEnum b : RequestedStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RequestedStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RequestedStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RequestedStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RequestedStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RequestedStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REQUESTED_STATE = "requestedState";
  @SerializedName(SERIALIZED_NAME_REQUESTED_STATE)
  private RequestedStateEnum requestedState;

  public static final String SERIALIZED_NAME_RUNTIME_UPDATABLE_PARAMS = "runtimeUpdatableParams";
  @SerializedName(SERIALIZED_NAME_RUNTIME_UPDATABLE_PARAMS)
  private RuntimeUpdatableParams runtimeUpdatableParams;

  public static final String SERIALIZED_NAME_SATISFIES_PZI = "satisfiesPzi";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZI)
  private Boolean satisfiesPzi;

  public static final String SERIALIZED_NAME_SATISFIES_PZS = "satisfiesPzs";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZS)
  private Boolean satisfiesPzs;

  public static final String SERIALIZED_NAME_STAGE_STATES = "stageStates";
  @SerializedName(SERIALIZED_NAME_STAGE_STATES)
  private List<ExecutionStageState> stageStates = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  public static final String SERIALIZED_NAME_STEPS = "steps";
  @SerializedName(SERIALIZED_NAME_STEPS)
  private List<Step> steps = new ArrayList<>();

  public static final String SERIALIZED_NAME_STEPS_LOCATION = "stepsLocation";
  @SerializedName(SERIALIZED_NAME_STEPS_LOCATION)
  private String stepsLocation;

  public static final String SERIALIZED_NAME_TEMP_FILES = "tempFiles";
  @SerializedName(SERIALIZED_NAME_TEMP_FILES)
  private List<String> tempFiles = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSFORM_NAME_MAPPING = "transformNameMapping";
  @SerializedName(SERIALIZED_NAME_TRANSFORM_NAME_MAPPING)
  private Map<String, String> transformNameMapping = new HashMap<>();

  /**
   * The type of Dataflow job.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    UNKNOWN("JOB_TYPE_UNKNOWN"),
    
    BATCH("JOB_TYPE_BATCH"),
    
    STREAMING("JOB_TYPE_STREAMING");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public Job() {
  }

  public Job(
     Boolean satisfiesPzi
  ) {
    this();
    this.satisfiesPzi = satisfiesPzi;
  }

  public Job clientRequestId(String clientRequestId) {
    this.clientRequestId = clientRequestId;
    return this;
  }

  /**
   * The client&#39;s unique identifier of the job, re-used across retried attempts. If this field is set, the service will ensure its uniqueness. The request to create a job will fail if the service has knowledge of a previously submitted job with the same client&#39;s ID and job name. The caller may use this field to ensure idempotence of job creation across retried attempts to create a job. By default, the field is empty and, in that case, the service ignores it.
   * @return clientRequestId
   */
  @javax.annotation.Nullable
  public String getClientRequestId() {
    return clientRequestId;
  }

  public void setClientRequestId(String clientRequestId) {
    this.clientRequestId = clientRequestId;
  }


  public Job createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * The timestamp when the job was initially created. Immutable and set by the Cloud Dataflow service.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  public Job createdFromSnapshotId(String createdFromSnapshotId) {
    this.createdFromSnapshotId = createdFromSnapshotId;
    return this;
  }

  /**
   * If this is specified, the job&#39;s initial state is populated from the given snapshot.
   * @return createdFromSnapshotId
   */
  @javax.annotation.Nullable
  public String getCreatedFromSnapshotId() {
    return createdFromSnapshotId;
  }

  public void setCreatedFromSnapshotId(String createdFromSnapshotId) {
    this.createdFromSnapshotId = createdFromSnapshotId;
  }


  public Job currentState(CurrentStateEnum currentState) {
    this.currentState = currentState;
    return this;
  }

  /**
   * The current state of the job. Jobs are created in the &#x60;JOB_STATE_STOPPED&#x60; state unless otherwise specified. A job in the &#x60;JOB_STATE_RUNNING&#x60; state may asynchronously enter a terminal state. After a job has reached a terminal state, no further state updates may be made. This field might be mutated by the Dataflow service; callers cannot mutate it.
   * @return currentState
   */
  @javax.annotation.Nullable
  public CurrentStateEnum getCurrentState() {
    return currentState;
  }

  public void setCurrentState(CurrentStateEnum currentState) {
    this.currentState = currentState;
  }


  public Job currentStateTime(String currentStateTime) {
    this.currentStateTime = currentStateTime;
    return this;
  }

  /**
   * The timestamp associated with the current state.
   * @return currentStateTime
   */
  @javax.annotation.Nullable
  public String getCurrentStateTime() {
    return currentStateTime;
  }

  public void setCurrentStateTime(String currentStateTime) {
    this.currentStateTime = currentStateTime;
  }


  public Job environment(Environment environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nullable
  public Environment getEnvironment() {
    return environment;
  }

  public void setEnvironment(Environment environment) {
    this.environment = environment;
  }


  public Job executionInfo(JobExecutionInfo executionInfo) {
    this.executionInfo = executionInfo;
    return this;
  }

  /**
   * Get executionInfo
   * @return executionInfo
   */
  @javax.annotation.Nullable
  public JobExecutionInfo getExecutionInfo() {
    return executionInfo;
  }

  public void setExecutionInfo(JobExecutionInfo executionInfo) {
    this.executionInfo = executionInfo;
  }


  public Job id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The unique ID of this job. This field is set by the Dataflow service when the job is created, and is immutable for the life of the job.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Job jobMetadata(JobMetadata jobMetadata) {
    this.jobMetadata = jobMetadata;
    return this;
  }

  /**
   * Get jobMetadata
   * @return jobMetadata
   */
  @javax.annotation.Nullable
  public JobMetadata getJobMetadata() {
    return jobMetadata;
  }

  public void setJobMetadata(JobMetadata jobMetadata) {
    this.jobMetadata = jobMetadata;
  }


  public Job labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Job putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * User-defined labels for this job. The labels map can contain no more than 64 entries. Entries of the labels map are UTF8 strings that comply with the following restrictions: * Keys must conform to regexp: \\p{Ll}\\p{Lo}{0,62} * Values must conform to regexp: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} * Both keys and values are additionally constrained to be &lt;&#x3D; 128 bytes in size.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Job location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The [regional endpoint] (https://cloud.google.com/dataflow/docs/concepts/regional-endpoints) that contains this job.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public Job name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The user-specified Dataflow job name. Only one active job with a given name can exist in a project within one region at any given time. Jobs in different regions can have the same name. If a caller attempts to create a job with the same name as an active job that already exists, the attempt returns the existing job. The name must match the regular expression &#x60;[a-z]([-a-z0-9]{0,1022}[a-z0-9])?&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Job pipelineDescription(PipelineDescription pipelineDescription) {
    this.pipelineDescription = pipelineDescription;
    return this;
  }

  /**
   * Get pipelineDescription
   * @return pipelineDescription
   */
  @javax.annotation.Nullable
  public PipelineDescription getPipelineDescription() {
    return pipelineDescription;
  }

  public void setPipelineDescription(PipelineDescription pipelineDescription) {
    this.pipelineDescription = pipelineDescription;
  }


  public Job projectId(String projectId) {
    this.projectId = projectId;
    return this;
  }

  /**
   * The ID of the Google Cloud project that the job belongs to.
   * @return projectId
   */
  @javax.annotation.Nullable
  public String getProjectId() {
    return projectId;
  }

  public void setProjectId(String projectId) {
    this.projectId = projectId;
  }


  public Job replaceJobId(String replaceJobId) {
    this.replaceJobId = replaceJobId;
    return this;
  }

  /**
   * If this job is an update of an existing job, this field is the job ID of the job it replaced. When sending a &#x60;CreateJobRequest&#x60;, you can update a job by specifying it here. The job named here is stopped, and its intermediate state is transferred to this job.
   * @return replaceJobId
   */
  @javax.annotation.Nullable
  public String getReplaceJobId() {
    return replaceJobId;
  }

  public void setReplaceJobId(String replaceJobId) {
    this.replaceJobId = replaceJobId;
  }


  public Job replacedByJobId(String replacedByJobId) {
    this.replacedByJobId = replacedByJobId;
    return this;
  }

  /**
   * If another job is an update of this job (and thus, this job is in &#x60;JOB_STATE_UPDATED&#x60;), this field contains the ID of that job.
   * @return replacedByJobId
   */
  @javax.annotation.Nullable
  public String getReplacedByJobId() {
    return replacedByJobId;
  }

  public void setReplacedByJobId(String replacedByJobId) {
    this.replacedByJobId = replacedByJobId;
  }


  public Job requestedState(RequestedStateEnum requestedState) {
    this.requestedState = requestedState;
    return this;
  }

  /**
   * The job&#39;s requested state. Applies to &#x60;UpdateJob&#x60; requests. Set &#x60;requested_state&#x60; with &#x60;UpdateJob&#x60; requests to switch between the states &#x60;JOB_STATE_STOPPED&#x60; and &#x60;JOB_STATE_RUNNING&#x60;. You can also use &#x60;UpdateJob&#x60; requests to change a job&#39;s state from &#x60;JOB_STATE_RUNNING&#x60; to &#x60;JOB_STATE_CANCELLED&#x60;, &#x60;JOB_STATE_DONE&#x60;, or &#x60;JOB_STATE_DRAINED&#x60;. These states irrevocably terminate the job if it hasn&#39;t already reached a terminal state. This field has no effect on &#x60;CreateJob&#x60; requests.
   * @return requestedState
   */
  @javax.annotation.Nullable
  public RequestedStateEnum getRequestedState() {
    return requestedState;
  }

  public void setRequestedState(RequestedStateEnum requestedState) {
    this.requestedState = requestedState;
  }


  public Job runtimeUpdatableParams(RuntimeUpdatableParams runtimeUpdatableParams) {
    this.runtimeUpdatableParams = runtimeUpdatableParams;
    return this;
  }

  /**
   * Get runtimeUpdatableParams
   * @return runtimeUpdatableParams
   */
  @javax.annotation.Nullable
  public RuntimeUpdatableParams getRuntimeUpdatableParams() {
    return runtimeUpdatableParams;
  }

  public void setRuntimeUpdatableParams(RuntimeUpdatableParams runtimeUpdatableParams) {
    this.runtimeUpdatableParams = runtimeUpdatableParams;
  }


  /**
   * Output only. Reserved for future use. This field is set only in responses from the server; it is ignored if it is set in any requests.
   * @return satisfiesPzi
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzi() {
    return satisfiesPzi;
  }



  public Job satisfiesPzs(Boolean satisfiesPzs) {
    this.satisfiesPzs = satisfiesPzs;
    return this;
  }

  /**
   * Reserved for future use. This field is set only in responses from the server; it is ignored if it is set in any requests.
   * @return satisfiesPzs
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzs() {
    return satisfiesPzs;
  }

  public void setSatisfiesPzs(Boolean satisfiesPzs) {
    this.satisfiesPzs = satisfiesPzs;
  }


  public Job stageStates(List<ExecutionStageState> stageStates) {
    this.stageStates = stageStates;
    return this;
  }

  public Job addStageStatesItem(ExecutionStageState stageStatesItem) {
    if (this.stageStates == null) {
      this.stageStates = new ArrayList<>();
    }
    this.stageStates.add(stageStatesItem);
    return this;
  }

  /**
   * This field may be mutated by the Cloud Dataflow service; callers cannot mutate it.
   * @return stageStates
   */
  @javax.annotation.Nullable
  public List<ExecutionStageState> getStageStates() {
    return stageStates;
  }

  public void setStageStates(List<ExecutionStageState> stageStates) {
    this.stageStates = stageStates;
  }


  public Job startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * The timestamp when the job was started (transitioned to JOB_STATE_PENDING). Flexible resource scheduling jobs are started with some delay after job creation, so start_time is unset before start and is updated when the job is started by the Cloud Dataflow service. For other jobs, start_time always equals to create_time and is immutable and set by the Cloud Dataflow service.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }


  public Job steps(List<Step> steps) {
    this.steps = steps;
    return this;
  }

  public Job addStepsItem(Step stepsItem) {
    if (this.steps == null) {
      this.steps = new ArrayList<>();
    }
    this.steps.add(stepsItem);
    return this;
  }

  /**
   * Exactly one of step or steps_location should be specified. The top-level steps that constitute the entire job. Only retrieved with JOB_VIEW_ALL.
   * @return steps
   */
  @javax.annotation.Nullable
  public List<Step> getSteps() {
    return steps;
  }

  public void setSteps(List<Step> steps) {
    this.steps = steps;
  }


  public Job stepsLocation(String stepsLocation) {
    this.stepsLocation = stepsLocation;
    return this;
  }

  /**
   * The Cloud Storage location where the steps are stored.
   * @return stepsLocation
   */
  @javax.annotation.Nullable
  public String getStepsLocation() {
    return stepsLocation;
  }

  public void setStepsLocation(String stepsLocation) {
    this.stepsLocation = stepsLocation;
  }


  public Job tempFiles(List<String> tempFiles) {
    this.tempFiles = tempFiles;
    return this;
  }

  public Job addTempFilesItem(String tempFilesItem) {
    if (this.tempFiles == null) {
      this.tempFiles = new ArrayList<>();
    }
    this.tempFiles.add(tempFilesItem);
    return this;
  }

  /**
   * A set of files the system should be aware of that are used for temporary storage. These temporary files will be removed on job completion. No duplicates are allowed. No file patterns are supported. The supported files are: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
   * @return tempFiles
   */
  @javax.annotation.Nullable
  public List<String> getTempFiles() {
    return tempFiles;
  }

  public void setTempFiles(List<String> tempFiles) {
    this.tempFiles = tempFiles;
  }


  public Job transformNameMapping(Map<String, String> transformNameMapping) {
    this.transformNameMapping = transformNameMapping;
    return this;
  }

  public Job putTransformNameMappingItem(String key, String transformNameMappingItem) {
    if (this.transformNameMapping == null) {
      this.transformNameMapping = new HashMap<>();
    }
    this.transformNameMapping.put(key, transformNameMappingItem);
    return this;
  }

  /**
   * The map of transform name prefixes of the job to be replaced to the corresponding name prefixes of the new job.
   * @return transformNameMapping
   */
  @javax.annotation.Nullable
  public Map<String, String> getTransformNameMapping() {
    return transformNameMapping;
  }

  public void setTransformNameMapping(Map<String, String> transformNameMapping) {
    this.transformNameMapping = transformNameMapping;
  }


  public Job type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * The type of Dataflow job.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Job job = (Job) o;
    return Objects.equals(this.clientRequestId, job.clientRequestId) &&
        Objects.equals(this.createTime, job.createTime) &&
        Objects.equals(this.createdFromSnapshotId, job.createdFromSnapshotId) &&
        Objects.equals(this.currentState, job.currentState) &&
        Objects.equals(this.currentStateTime, job.currentStateTime) &&
        Objects.equals(this.environment, job.environment) &&
        Objects.equals(this.executionInfo, job.executionInfo) &&
        Objects.equals(this.id, job.id) &&
        Objects.equals(this.jobMetadata, job.jobMetadata) &&
        Objects.equals(this.labels, job.labels) &&
        Objects.equals(this.location, job.location) &&
        Objects.equals(this.name, job.name) &&
        Objects.equals(this.pipelineDescription, job.pipelineDescription) &&
        Objects.equals(this.projectId, job.projectId) &&
        Objects.equals(this.replaceJobId, job.replaceJobId) &&
        Objects.equals(this.replacedByJobId, job.replacedByJobId) &&
        Objects.equals(this.requestedState, job.requestedState) &&
        Objects.equals(this.runtimeUpdatableParams, job.runtimeUpdatableParams) &&
        Objects.equals(this.satisfiesPzi, job.satisfiesPzi) &&
        Objects.equals(this.satisfiesPzs, job.satisfiesPzs) &&
        Objects.equals(this.stageStates, job.stageStates) &&
        Objects.equals(this.startTime, job.startTime) &&
        Objects.equals(this.steps, job.steps) &&
        Objects.equals(this.stepsLocation, job.stepsLocation) &&
        Objects.equals(this.tempFiles, job.tempFiles) &&
        Objects.equals(this.transformNameMapping, job.transformNameMapping) &&
        Objects.equals(this.type, job.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientRequestId, createTime, createdFromSnapshotId, currentState, currentStateTime, environment, executionInfo, id, jobMetadata, labels, location, name, pipelineDescription, projectId, replaceJobId, replacedByJobId, requestedState, runtimeUpdatableParams, satisfiesPzi, satisfiesPzs, stageStates, startTime, steps, stepsLocation, tempFiles, transformNameMapping, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Job {\n");
    sb.append("    clientRequestId: ").append(toIndentedString(clientRequestId)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    createdFromSnapshotId: ").append(toIndentedString(createdFromSnapshotId)).append("\n");
    sb.append("    currentState: ").append(toIndentedString(currentState)).append("\n");
    sb.append("    currentStateTime: ").append(toIndentedString(currentStateTime)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    executionInfo: ").append(toIndentedString(executionInfo)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    jobMetadata: ").append(toIndentedString(jobMetadata)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    pipelineDescription: ").append(toIndentedString(pipelineDescription)).append("\n");
    sb.append("    projectId: ").append(toIndentedString(projectId)).append("\n");
    sb.append("    replaceJobId: ").append(toIndentedString(replaceJobId)).append("\n");
    sb.append("    replacedByJobId: ").append(toIndentedString(replacedByJobId)).append("\n");
    sb.append("    requestedState: ").append(toIndentedString(requestedState)).append("\n");
    sb.append("    runtimeUpdatableParams: ").append(toIndentedString(runtimeUpdatableParams)).append("\n");
    sb.append("    satisfiesPzi: ").append(toIndentedString(satisfiesPzi)).append("\n");
    sb.append("    satisfiesPzs: ").append(toIndentedString(satisfiesPzs)).append("\n");
    sb.append("    stageStates: ").append(toIndentedString(stageStates)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    steps: ").append(toIndentedString(steps)).append("\n");
    sb.append("    stepsLocation: ").append(toIndentedString(stepsLocation)).append("\n");
    sb.append("    tempFiles: ").append(toIndentedString(tempFiles)).append("\n");
    sb.append("    transformNameMapping: ").append(toIndentedString(transformNameMapping)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clientRequestId");
    openapiFields.add("createTime");
    openapiFields.add("createdFromSnapshotId");
    openapiFields.add("currentState");
    openapiFields.add("currentStateTime");
    openapiFields.add("environment");
    openapiFields.add("executionInfo");
    openapiFields.add("id");
    openapiFields.add("jobMetadata");
    openapiFields.add("labels");
    openapiFields.add("location");
    openapiFields.add("name");
    openapiFields.add("pipelineDescription");
    openapiFields.add("projectId");
    openapiFields.add("replaceJobId");
    openapiFields.add("replacedByJobId");
    openapiFields.add("requestedState");
    openapiFields.add("runtimeUpdatableParams");
    openapiFields.add("satisfiesPzi");
    openapiFields.add("satisfiesPzs");
    openapiFields.add("stageStates");
    openapiFields.add("startTime");
    openapiFields.add("steps");
    openapiFields.add("stepsLocation");
    openapiFields.add("tempFiles");
    openapiFields.add("transformNameMapping");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Job
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Job.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Job is not found in the empty JSON string", Job.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Job.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Job` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("clientRequestId") != null && !jsonObj.get("clientRequestId").isJsonNull()) && !jsonObj.get("clientRequestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientRequestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientRequestId").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("createdFromSnapshotId") != null && !jsonObj.get("createdFromSnapshotId").isJsonNull()) && !jsonObj.get("createdFromSnapshotId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdFromSnapshotId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdFromSnapshotId").toString()));
      }
      if ((jsonObj.get("currentState") != null && !jsonObj.get("currentState").isJsonNull()) && !jsonObj.get("currentState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currentState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currentState").toString()));
      }
      // validate the optional field `currentState`
      if (jsonObj.get("currentState") != null && !jsonObj.get("currentState").isJsonNull()) {
        CurrentStateEnum.validateJsonElement(jsonObj.get("currentState"));
      }
      if ((jsonObj.get("currentStateTime") != null && !jsonObj.get("currentStateTime").isJsonNull()) && !jsonObj.get("currentStateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currentStateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currentStateTime").toString()));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        Environment.validateJsonElement(jsonObj.get("environment"));
      }
      // validate the optional field `executionInfo`
      if (jsonObj.get("executionInfo") != null && !jsonObj.get("executionInfo").isJsonNull()) {
        JobExecutionInfo.validateJsonElement(jsonObj.get("executionInfo"));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `jobMetadata`
      if (jsonObj.get("jobMetadata") != null && !jsonObj.get("jobMetadata").isJsonNull()) {
        JobMetadata.validateJsonElement(jsonObj.get("jobMetadata"));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `pipelineDescription`
      if (jsonObj.get("pipelineDescription") != null && !jsonObj.get("pipelineDescription").isJsonNull()) {
        PipelineDescription.validateJsonElement(jsonObj.get("pipelineDescription"));
      }
      if ((jsonObj.get("projectId") != null && !jsonObj.get("projectId").isJsonNull()) && !jsonObj.get("projectId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projectId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projectId").toString()));
      }
      if ((jsonObj.get("replaceJobId") != null && !jsonObj.get("replaceJobId").isJsonNull()) && !jsonObj.get("replaceJobId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replaceJobId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replaceJobId").toString()));
      }
      if ((jsonObj.get("replacedByJobId") != null && !jsonObj.get("replacedByJobId").isJsonNull()) && !jsonObj.get("replacedByJobId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replacedByJobId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replacedByJobId").toString()));
      }
      if ((jsonObj.get("requestedState") != null && !jsonObj.get("requestedState").isJsonNull()) && !jsonObj.get("requestedState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedState").toString()));
      }
      // validate the optional field `requestedState`
      if (jsonObj.get("requestedState") != null && !jsonObj.get("requestedState").isJsonNull()) {
        RequestedStateEnum.validateJsonElement(jsonObj.get("requestedState"));
      }
      // validate the optional field `runtimeUpdatableParams`
      if (jsonObj.get("runtimeUpdatableParams") != null && !jsonObj.get("runtimeUpdatableParams").isJsonNull()) {
        RuntimeUpdatableParams.validateJsonElement(jsonObj.get("runtimeUpdatableParams"));
      }
      if (jsonObj.get("stageStates") != null && !jsonObj.get("stageStates").isJsonNull()) {
        JsonArray jsonArraystageStates = jsonObj.getAsJsonArray("stageStates");
        if (jsonArraystageStates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("stageStates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `stageStates` to be an array in the JSON string but got `%s`", jsonObj.get("stageStates").toString()));
          }

          // validate the optional field `stageStates` (array)
          for (int i = 0; i < jsonArraystageStates.size(); i++) {
            ExecutionStageState.validateJsonElement(jsonArraystageStates.get(i));
          };
        }
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if (jsonObj.get("steps") != null && !jsonObj.get("steps").isJsonNull()) {
        JsonArray jsonArraysteps = jsonObj.getAsJsonArray("steps");
        if (jsonArraysteps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("steps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `steps` to be an array in the JSON string but got `%s`", jsonObj.get("steps").toString()));
          }

          // validate the optional field `steps` (array)
          for (int i = 0; i < jsonArraysteps.size(); i++) {
            Step.validateJsonElement(jsonArraysteps.get(i));
          };
        }
      }
      if ((jsonObj.get("stepsLocation") != null && !jsonObj.get("stepsLocation").isJsonNull()) && !jsonObj.get("stepsLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stepsLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stepsLocation").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tempFiles") != null && !jsonObj.get("tempFiles").isJsonNull() && !jsonObj.get("tempFiles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tempFiles` to be an array in the JSON string but got `%s`", jsonObj.get("tempFiles").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Job.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Job' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Job> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Job.class));

       return (TypeAdapter<T>) new TypeAdapter<Job>() {
           @Override
           public void write(JsonWriter out, Job value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Job read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Job given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Job
   * @throws IOException if the JSON string is invalid with respect to Job
   */
  public static Job fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Job.class);
  }

  /**
   * Convert an instance of Job to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

