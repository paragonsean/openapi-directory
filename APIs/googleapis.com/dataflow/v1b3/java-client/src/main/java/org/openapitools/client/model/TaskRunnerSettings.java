/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.WorkerSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Taskrunner configuration settings.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TaskRunnerSettings {
  public static final String SERIALIZED_NAME_ALSOLOGTOSTDERR = "alsologtostderr";
  @SerializedName(SERIALIZED_NAME_ALSOLOGTOSTDERR)
  private Boolean alsologtostderr;

  public static final String SERIALIZED_NAME_BASE_TASK_DIR = "baseTaskDir";
  @SerializedName(SERIALIZED_NAME_BASE_TASK_DIR)
  private String baseTaskDir;

  public static final String SERIALIZED_NAME_BASE_URL = "baseUrl";
  @SerializedName(SERIALIZED_NAME_BASE_URL)
  private String baseUrl;

  public static final String SERIALIZED_NAME_COMMANDLINES_FILE_NAME = "commandlinesFileName";
  @SerializedName(SERIALIZED_NAME_COMMANDLINES_FILE_NAME)
  private String commandlinesFileName;

  public static final String SERIALIZED_NAME_CONTINUE_ON_EXCEPTION = "continueOnException";
  @SerializedName(SERIALIZED_NAME_CONTINUE_ON_EXCEPTION)
  private Boolean continueOnException;

  public static final String SERIALIZED_NAME_DATAFLOW_API_VERSION = "dataflowApiVersion";
  @SerializedName(SERIALIZED_NAME_DATAFLOW_API_VERSION)
  private String dataflowApiVersion;

  public static final String SERIALIZED_NAME_HARNESS_COMMAND = "harnessCommand";
  @SerializedName(SERIALIZED_NAME_HARNESS_COMMAND)
  private String harnessCommand;

  public static final String SERIALIZED_NAME_LANGUAGE_HINT = "languageHint";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_HINT)
  private String languageHint;

  public static final String SERIALIZED_NAME_LOG_DIR = "logDir";
  @SerializedName(SERIALIZED_NAME_LOG_DIR)
  private String logDir;

  public static final String SERIALIZED_NAME_LOG_TO_SERIALCONSOLE = "logToSerialconsole";
  @SerializedName(SERIALIZED_NAME_LOG_TO_SERIALCONSOLE)
  private Boolean logToSerialconsole;

  public static final String SERIALIZED_NAME_LOG_UPLOAD_LOCATION = "logUploadLocation";
  @SerializedName(SERIALIZED_NAME_LOG_UPLOAD_LOCATION)
  private String logUploadLocation;

  public static final String SERIALIZED_NAME_OAUTH_SCOPES = "oauthScopes";
  @SerializedName(SERIALIZED_NAME_OAUTH_SCOPES)
  private List<String> oauthScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARALLEL_WORKER_SETTINGS = "parallelWorkerSettings";
  @SerializedName(SERIALIZED_NAME_PARALLEL_WORKER_SETTINGS)
  private WorkerSettings parallelWorkerSettings;

  public static final String SERIALIZED_NAME_STREAMING_WORKER_MAIN_CLASS = "streamingWorkerMainClass";
  @SerializedName(SERIALIZED_NAME_STREAMING_WORKER_MAIN_CLASS)
  private String streamingWorkerMainClass;

  public static final String SERIALIZED_NAME_TASK_GROUP = "taskGroup";
  @SerializedName(SERIALIZED_NAME_TASK_GROUP)
  private String taskGroup;

  public static final String SERIALIZED_NAME_TASK_USER = "taskUser";
  @SerializedName(SERIALIZED_NAME_TASK_USER)
  private String taskUser;

  public static final String SERIALIZED_NAME_TEMP_STORAGE_PREFIX = "tempStoragePrefix";
  @SerializedName(SERIALIZED_NAME_TEMP_STORAGE_PREFIX)
  private String tempStoragePrefix;

  public static final String SERIALIZED_NAME_VM_ID = "vmId";
  @SerializedName(SERIALIZED_NAME_VM_ID)
  private String vmId;

  public static final String SERIALIZED_NAME_WORKFLOW_FILE_NAME = "workflowFileName";
  @SerializedName(SERIALIZED_NAME_WORKFLOW_FILE_NAME)
  private String workflowFileName;

  public TaskRunnerSettings() {
  }

  public TaskRunnerSettings alsologtostderr(Boolean alsologtostderr) {
    this.alsologtostderr = alsologtostderr;
    return this;
  }

  /**
   * Whether to also send taskrunner log info to stderr.
   * @return alsologtostderr
   */
  @javax.annotation.Nullable
  public Boolean getAlsologtostderr() {
    return alsologtostderr;
  }

  public void setAlsologtostderr(Boolean alsologtostderr) {
    this.alsologtostderr = alsologtostderr;
  }


  public TaskRunnerSettings baseTaskDir(String baseTaskDir) {
    this.baseTaskDir = baseTaskDir;
    return this;
  }

  /**
   * The location on the worker for task-specific subdirectories.
   * @return baseTaskDir
   */
  @javax.annotation.Nullable
  public String getBaseTaskDir() {
    return baseTaskDir;
  }

  public void setBaseTaskDir(String baseTaskDir) {
    this.baseTaskDir = baseTaskDir;
  }


  public TaskRunnerSettings baseUrl(String baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }

  /**
   * The base URL for the taskrunner to use when accessing Google Cloud APIs. When workers access Google Cloud APIs, they logically do so via relative URLs. If this field is specified, it supplies the base URL to use for resolving these relative URLs. The normative algorithm used is defined by RFC 1808, \&quot;Relative Uniform Resource Locators\&quot;. If not specified, the default value is \&quot;http://www.googleapis.com/\&quot;
   * @return baseUrl
   */
  @javax.annotation.Nullable
  public String getBaseUrl() {
    return baseUrl;
  }

  public void setBaseUrl(String baseUrl) {
    this.baseUrl = baseUrl;
  }


  public TaskRunnerSettings commandlinesFileName(String commandlinesFileName) {
    this.commandlinesFileName = commandlinesFileName;
    return this;
  }

  /**
   * The file to store preprocessing commands in.
   * @return commandlinesFileName
   */
  @javax.annotation.Nullable
  public String getCommandlinesFileName() {
    return commandlinesFileName;
  }

  public void setCommandlinesFileName(String commandlinesFileName) {
    this.commandlinesFileName = commandlinesFileName;
  }


  public TaskRunnerSettings continueOnException(Boolean continueOnException) {
    this.continueOnException = continueOnException;
    return this;
  }

  /**
   * Whether to continue taskrunner if an exception is hit.
   * @return continueOnException
   */
  @javax.annotation.Nullable
  public Boolean getContinueOnException() {
    return continueOnException;
  }

  public void setContinueOnException(Boolean continueOnException) {
    this.continueOnException = continueOnException;
  }


  public TaskRunnerSettings dataflowApiVersion(String dataflowApiVersion) {
    this.dataflowApiVersion = dataflowApiVersion;
    return this;
  }

  /**
   * The API version of endpoint, e.g. \&quot;v1b3\&quot;
   * @return dataflowApiVersion
   */
  @javax.annotation.Nullable
  public String getDataflowApiVersion() {
    return dataflowApiVersion;
  }

  public void setDataflowApiVersion(String dataflowApiVersion) {
    this.dataflowApiVersion = dataflowApiVersion;
  }


  public TaskRunnerSettings harnessCommand(String harnessCommand) {
    this.harnessCommand = harnessCommand;
    return this;
  }

  /**
   * The command to launch the worker harness.
   * @return harnessCommand
   */
  @javax.annotation.Nullable
  public String getHarnessCommand() {
    return harnessCommand;
  }

  public void setHarnessCommand(String harnessCommand) {
    this.harnessCommand = harnessCommand;
  }


  public TaskRunnerSettings languageHint(String languageHint) {
    this.languageHint = languageHint;
    return this;
  }

  /**
   * The suggested backend language.
   * @return languageHint
   */
  @javax.annotation.Nullable
  public String getLanguageHint() {
    return languageHint;
  }

  public void setLanguageHint(String languageHint) {
    this.languageHint = languageHint;
  }


  public TaskRunnerSettings logDir(String logDir) {
    this.logDir = logDir;
    return this;
  }

  /**
   * The directory on the VM to store logs.
   * @return logDir
   */
  @javax.annotation.Nullable
  public String getLogDir() {
    return logDir;
  }

  public void setLogDir(String logDir) {
    this.logDir = logDir;
  }


  public TaskRunnerSettings logToSerialconsole(Boolean logToSerialconsole) {
    this.logToSerialconsole = logToSerialconsole;
    return this;
  }

  /**
   * Whether to send taskrunner log info to Google Compute Engine VM serial console.
   * @return logToSerialconsole
   */
  @javax.annotation.Nullable
  public Boolean getLogToSerialconsole() {
    return logToSerialconsole;
  }

  public void setLogToSerialconsole(Boolean logToSerialconsole) {
    this.logToSerialconsole = logToSerialconsole;
  }


  public TaskRunnerSettings logUploadLocation(String logUploadLocation) {
    this.logUploadLocation = logUploadLocation;
    return this;
  }

  /**
   * Indicates where to put logs. If this is not specified, the logs will not be uploaded. The supported resource type is: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
   * @return logUploadLocation
   */
  @javax.annotation.Nullable
  public String getLogUploadLocation() {
    return logUploadLocation;
  }

  public void setLogUploadLocation(String logUploadLocation) {
    this.logUploadLocation = logUploadLocation;
  }


  public TaskRunnerSettings oauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
    return this;
  }

  public TaskRunnerSettings addOauthScopesItem(String oauthScopesItem) {
    if (this.oauthScopes == null) {
      this.oauthScopes = new ArrayList<>();
    }
    this.oauthScopes.add(oauthScopesItem);
    return this;
  }

  /**
   * The OAuth2 scopes to be requested by the taskrunner in order to access the Cloud Dataflow API.
   * @return oauthScopes
   */
  @javax.annotation.Nullable
  public List<String> getOauthScopes() {
    return oauthScopes;
  }

  public void setOauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
  }


  public TaskRunnerSettings parallelWorkerSettings(WorkerSettings parallelWorkerSettings) {
    this.parallelWorkerSettings = parallelWorkerSettings;
    return this;
  }

  /**
   * Get parallelWorkerSettings
   * @return parallelWorkerSettings
   */
  @javax.annotation.Nullable
  public WorkerSettings getParallelWorkerSettings() {
    return parallelWorkerSettings;
  }

  public void setParallelWorkerSettings(WorkerSettings parallelWorkerSettings) {
    this.parallelWorkerSettings = parallelWorkerSettings;
  }


  public TaskRunnerSettings streamingWorkerMainClass(String streamingWorkerMainClass) {
    this.streamingWorkerMainClass = streamingWorkerMainClass;
    return this;
  }

  /**
   * The streaming worker main class name.
   * @return streamingWorkerMainClass
   */
  @javax.annotation.Nullable
  public String getStreamingWorkerMainClass() {
    return streamingWorkerMainClass;
  }

  public void setStreamingWorkerMainClass(String streamingWorkerMainClass) {
    this.streamingWorkerMainClass = streamingWorkerMainClass;
  }


  public TaskRunnerSettings taskGroup(String taskGroup) {
    this.taskGroup = taskGroup;
    return this;
  }

  /**
   * The UNIX group ID on the worker VM to use for tasks launched by taskrunner; e.g. \&quot;wheel\&quot;.
   * @return taskGroup
   */
  @javax.annotation.Nullable
  public String getTaskGroup() {
    return taskGroup;
  }

  public void setTaskGroup(String taskGroup) {
    this.taskGroup = taskGroup;
  }


  public TaskRunnerSettings taskUser(String taskUser) {
    this.taskUser = taskUser;
    return this;
  }

  /**
   * The UNIX user ID on the worker VM to use for tasks launched by taskrunner; e.g. \&quot;root\&quot;.
   * @return taskUser
   */
  @javax.annotation.Nullable
  public String getTaskUser() {
    return taskUser;
  }

  public void setTaskUser(String taskUser) {
    this.taskUser = taskUser;
  }


  public TaskRunnerSettings tempStoragePrefix(String tempStoragePrefix) {
    this.tempStoragePrefix = tempStoragePrefix;
    return this;
  }

  /**
   * The prefix of the resources the taskrunner should use for temporary storage. The supported resource type is: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
   * @return tempStoragePrefix
   */
  @javax.annotation.Nullable
  public String getTempStoragePrefix() {
    return tempStoragePrefix;
  }

  public void setTempStoragePrefix(String tempStoragePrefix) {
    this.tempStoragePrefix = tempStoragePrefix;
  }


  public TaskRunnerSettings vmId(String vmId) {
    this.vmId = vmId;
    return this;
  }

  /**
   * The ID string of the VM.
   * @return vmId
   */
  @javax.annotation.Nullable
  public String getVmId() {
    return vmId;
  }

  public void setVmId(String vmId) {
    this.vmId = vmId;
  }


  public TaskRunnerSettings workflowFileName(String workflowFileName) {
    this.workflowFileName = workflowFileName;
    return this;
  }

  /**
   * The file to store the workflow in.
   * @return workflowFileName
   */
  @javax.annotation.Nullable
  public String getWorkflowFileName() {
    return workflowFileName;
  }

  public void setWorkflowFileName(String workflowFileName) {
    this.workflowFileName = workflowFileName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TaskRunnerSettings taskRunnerSettings = (TaskRunnerSettings) o;
    return Objects.equals(this.alsologtostderr, taskRunnerSettings.alsologtostderr) &&
        Objects.equals(this.baseTaskDir, taskRunnerSettings.baseTaskDir) &&
        Objects.equals(this.baseUrl, taskRunnerSettings.baseUrl) &&
        Objects.equals(this.commandlinesFileName, taskRunnerSettings.commandlinesFileName) &&
        Objects.equals(this.continueOnException, taskRunnerSettings.continueOnException) &&
        Objects.equals(this.dataflowApiVersion, taskRunnerSettings.dataflowApiVersion) &&
        Objects.equals(this.harnessCommand, taskRunnerSettings.harnessCommand) &&
        Objects.equals(this.languageHint, taskRunnerSettings.languageHint) &&
        Objects.equals(this.logDir, taskRunnerSettings.logDir) &&
        Objects.equals(this.logToSerialconsole, taskRunnerSettings.logToSerialconsole) &&
        Objects.equals(this.logUploadLocation, taskRunnerSettings.logUploadLocation) &&
        Objects.equals(this.oauthScopes, taskRunnerSettings.oauthScopes) &&
        Objects.equals(this.parallelWorkerSettings, taskRunnerSettings.parallelWorkerSettings) &&
        Objects.equals(this.streamingWorkerMainClass, taskRunnerSettings.streamingWorkerMainClass) &&
        Objects.equals(this.taskGroup, taskRunnerSettings.taskGroup) &&
        Objects.equals(this.taskUser, taskRunnerSettings.taskUser) &&
        Objects.equals(this.tempStoragePrefix, taskRunnerSettings.tempStoragePrefix) &&
        Objects.equals(this.vmId, taskRunnerSettings.vmId) &&
        Objects.equals(this.workflowFileName, taskRunnerSettings.workflowFileName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alsologtostderr, baseTaskDir, baseUrl, commandlinesFileName, continueOnException, dataflowApiVersion, harnessCommand, languageHint, logDir, logToSerialconsole, logUploadLocation, oauthScopes, parallelWorkerSettings, streamingWorkerMainClass, taskGroup, taskUser, tempStoragePrefix, vmId, workflowFileName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TaskRunnerSettings {\n");
    sb.append("    alsologtostderr: ").append(toIndentedString(alsologtostderr)).append("\n");
    sb.append("    baseTaskDir: ").append(toIndentedString(baseTaskDir)).append("\n");
    sb.append("    baseUrl: ").append(toIndentedString(baseUrl)).append("\n");
    sb.append("    commandlinesFileName: ").append(toIndentedString(commandlinesFileName)).append("\n");
    sb.append("    continueOnException: ").append(toIndentedString(continueOnException)).append("\n");
    sb.append("    dataflowApiVersion: ").append(toIndentedString(dataflowApiVersion)).append("\n");
    sb.append("    harnessCommand: ").append(toIndentedString(harnessCommand)).append("\n");
    sb.append("    languageHint: ").append(toIndentedString(languageHint)).append("\n");
    sb.append("    logDir: ").append(toIndentedString(logDir)).append("\n");
    sb.append("    logToSerialconsole: ").append(toIndentedString(logToSerialconsole)).append("\n");
    sb.append("    logUploadLocation: ").append(toIndentedString(logUploadLocation)).append("\n");
    sb.append("    oauthScopes: ").append(toIndentedString(oauthScopes)).append("\n");
    sb.append("    parallelWorkerSettings: ").append(toIndentedString(parallelWorkerSettings)).append("\n");
    sb.append("    streamingWorkerMainClass: ").append(toIndentedString(streamingWorkerMainClass)).append("\n");
    sb.append("    taskGroup: ").append(toIndentedString(taskGroup)).append("\n");
    sb.append("    taskUser: ").append(toIndentedString(taskUser)).append("\n");
    sb.append("    tempStoragePrefix: ").append(toIndentedString(tempStoragePrefix)).append("\n");
    sb.append("    vmId: ").append(toIndentedString(vmId)).append("\n");
    sb.append("    workflowFileName: ").append(toIndentedString(workflowFileName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alsologtostderr");
    openapiFields.add("baseTaskDir");
    openapiFields.add("baseUrl");
    openapiFields.add("commandlinesFileName");
    openapiFields.add("continueOnException");
    openapiFields.add("dataflowApiVersion");
    openapiFields.add("harnessCommand");
    openapiFields.add("languageHint");
    openapiFields.add("logDir");
    openapiFields.add("logToSerialconsole");
    openapiFields.add("logUploadLocation");
    openapiFields.add("oauthScopes");
    openapiFields.add("parallelWorkerSettings");
    openapiFields.add("streamingWorkerMainClass");
    openapiFields.add("taskGroup");
    openapiFields.add("taskUser");
    openapiFields.add("tempStoragePrefix");
    openapiFields.add("vmId");
    openapiFields.add("workflowFileName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TaskRunnerSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TaskRunnerSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TaskRunnerSettings is not found in the empty JSON string", TaskRunnerSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TaskRunnerSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TaskRunnerSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("baseTaskDir") != null && !jsonObj.get("baseTaskDir").isJsonNull()) && !jsonObj.get("baseTaskDir").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseTaskDir` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseTaskDir").toString()));
      }
      if ((jsonObj.get("baseUrl") != null && !jsonObj.get("baseUrl").isJsonNull()) && !jsonObj.get("baseUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseUrl").toString()));
      }
      if ((jsonObj.get("commandlinesFileName") != null && !jsonObj.get("commandlinesFileName").isJsonNull()) && !jsonObj.get("commandlinesFileName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commandlinesFileName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commandlinesFileName").toString()));
      }
      if ((jsonObj.get("dataflowApiVersion") != null && !jsonObj.get("dataflowApiVersion").isJsonNull()) && !jsonObj.get("dataflowApiVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataflowApiVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataflowApiVersion").toString()));
      }
      if ((jsonObj.get("harnessCommand") != null && !jsonObj.get("harnessCommand").isJsonNull()) && !jsonObj.get("harnessCommand").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `harnessCommand` to be a primitive type in the JSON string but got `%s`", jsonObj.get("harnessCommand").toString()));
      }
      if ((jsonObj.get("languageHint") != null && !jsonObj.get("languageHint").isJsonNull()) && !jsonObj.get("languageHint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageHint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageHint").toString()));
      }
      if ((jsonObj.get("logDir") != null && !jsonObj.get("logDir").isJsonNull()) && !jsonObj.get("logDir").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logDir` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logDir").toString()));
      }
      if ((jsonObj.get("logUploadLocation") != null && !jsonObj.get("logUploadLocation").isJsonNull()) && !jsonObj.get("logUploadLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logUploadLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logUploadLocation").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("oauthScopes") != null && !jsonObj.get("oauthScopes").isJsonNull() && !jsonObj.get("oauthScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthScopes` to be an array in the JSON string but got `%s`", jsonObj.get("oauthScopes").toString()));
      }
      // validate the optional field `parallelWorkerSettings`
      if (jsonObj.get("parallelWorkerSettings") != null && !jsonObj.get("parallelWorkerSettings").isJsonNull()) {
        WorkerSettings.validateJsonElement(jsonObj.get("parallelWorkerSettings"));
      }
      if ((jsonObj.get("streamingWorkerMainClass") != null && !jsonObj.get("streamingWorkerMainClass").isJsonNull()) && !jsonObj.get("streamingWorkerMainClass").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamingWorkerMainClass` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamingWorkerMainClass").toString()));
      }
      if ((jsonObj.get("taskGroup") != null && !jsonObj.get("taskGroup").isJsonNull()) && !jsonObj.get("taskGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taskGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taskGroup").toString()));
      }
      if ((jsonObj.get("taskUser") != null && !jsonObj.get("taskUser").isJsonNull()) && !jsonObj.get("taskUser").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taskUser` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taskUser").toString()));
      }
      if ((jsonObj.get("tempStoragePrefix") != null && !jsonObj.get("tempStoragePrefix").isJsonNull()) && !jsonObj.get("tempStoragePrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tempStoragePrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tempStoragePrefix").toString()));
      }
      if ((jsonObj.get("vmId") != null && !jsonObj.get("vmId").isJsonNull()) && !jsonObj.get("vmId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmId").toString()));
      }
      if ((jsonObj.get("workflowFileName") != null && !jsonObj.get("workflowFileName").isJsonNull()) && !jsonObj.get("workflowFileName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workflowFileName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workflowFileName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TaskRunnerSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TaskRunnerSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TaskRunnerSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TaskRunnerSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<TaskRunnerSettings>() {
           @Override
           public void write(JsonWriter out, TaskRunnerSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TaskRunnerSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TaskRunnerSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TaskRunnerSettings
   * @throws IOException if the JSON string is invalid with respect to TaskRunnerSettings
   */
  public static TaskRunnerSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TaskRunnerSettings.class);
  }

  /**
   * Convert an instance of TaskRunnerSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

