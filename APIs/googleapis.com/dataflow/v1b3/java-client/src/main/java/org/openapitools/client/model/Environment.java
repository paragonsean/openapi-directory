/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DebugOptions;
import org.openapitools.client.model.WorkerPool;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the environment in which a Dataflow Job runs.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Environment {
  public static final String SERIALIZED_NAME_CLUSTER_MANAGER_API_SERVICE = "clusterManagerApiService";
  @SerializedName(SERIALIZED_NAME_CLUSTER_MANAGER_API_SERVICE)
  private String clusterManagerApiService;

  public static final String SERIALIZED_NAME_DATASET = "dataset";
  @SerializedName(SERIALIZED_NAME_DATASET)
  private String dataset;

  public static final String SERIALIZED_NAME_DEBUG_OPTIONS = "debugOptions";
  @SerializedName(SERIALIZED_NAME_DEBUG_OPTIONS)
  private DebugOptions debugOptions;

  public static final String SERIALIZED_NAME_EXPERIMENTS = "experiments";
  @SerializedName(SERIALIZED_NAME_EXPERIMENTS)
  private List<String> experiments = new ArrayList<>();

  /**
   * Which Flexible Resource Scheduling mode to run in.
   */
  @JsonAdapter(FlexResourceSchedulingGoalEnum.Adapter.class)
  public enum FlexResourceSchedulingGoalEnum {
    UNSPECIFIED("FLEXRS_UNSPECIFIED"),
    
    SPEED_OPTIMIZED("FLEXRS_SPEED_OPTIMIZED"),
    
    COST_OPTIMIZED("FLEXRS_COST_OPTIMIZED");

    private String value;

    FlexResourceSchedulingGoalEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FlexResourceSchedulingGoalEnum fromValue(String value) {
      for (FlexResourceSchedulingGoalEnum b : FlexResourceSchedulingGoalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FlexResourceSchedulingGoalEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FlexResourceSchedulingGoalEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FlexResourceSchedulingGoalEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FlexResourceSchedulingGoalEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FlexResourceSchedulingGoalEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FLEX_RESOURCE_SCHEDULING_GOAL = "flexResourceSchedulingGoal";
  @SerializedName(SERIALIZED_NAME_FLEX_RESOURCE_SCHEDULING_GOAL)
  private FlexResourceSchedulingGoalEnum flexResourceSchedulingGoal;

  public static final String SERIALIZED_NAME_INTERNAL_EXPERIMENTS = "internalExperiments";
  @SerializedName(SERIALIZED_NAME_INTERNAL_EXPERIMENTS)
  private Map<String, Object> internalExperiments = new HashMap<>();

  public static final String SERIALIZED_NAME_SDK_PIPELINE_OPTIONS = "sdkPipelineOptions";
  @SerializedName(SERIALIZED_NAME_SDK_PIPELINE_OPTIONS)
  private Map<String, Object> sdkPipelineOptions = new HashMap<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL = "serviceAccountEmail";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL)
  private String serviceAccountEmail;

  public static final String SERIALIZED_NAME_SERVICE_KMS_KEY_NAME = "serviceKmsKeyName";
  @SerializedName(SERIALIZED_NAME_SERVICE_KMS_KEY_NAME)
  private String serviceKmsKeyName;

  public static final String SERIALIZED_NAME_SERVICE_OPTIONS = "serviceOptions";
  @SerializedName(SERIALIZED_NAME_SERVICE_OPTIONS)
  private List<String> serviceOptions = new ArrayList<>();

  /**
   * Output only. The shuffle mode used for the job.
   */
  @JsonAdapter(ShuffleModeEnum.Adapter.class)
  public enum ShuffleModeEnum {
    SHUFFLE_MODE_UNSPECIFIED("SHUFFLE_MODE_UNSPECIFIED"),
    
    VM_BASED("VM_BASED"),
    
    SERVICE_BASED("SERVICE_BASED");

    private String value;

    ShuffleModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ShuffleModeEnum fromValue(String value) {
      for (ShuffleModeEnum b : ShuffleModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ShuffleModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ShuffleModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ShuffleModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ShuffleModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ShuffleModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SHUFFLE_MODE = "shuffleMode";
  @SerializedName(SERIALIZED_NAME_SHUFFLE_MODE)
  private ShuffleModeEnum shuffleMode;

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   */
  @JsonAdapter(StreamingModeEnum.Adapter.class)
  public enum StreamingModeEnum {
    UNSPECIFIED("STREAMING_MODE_UNSPECIFIED"),
    
    EXACTLY_ONCE("STREAMING_MODE_EXACTLY_ONCE"),
    
    AT_LEAST_ONCE("STREAMING_MODE_AT_LEAST_ONCE");

    private String value;

    StreamingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StreamingModeEnum fromValue(String value) {
      for (StreamingModeEnum b : StreamingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StreamingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StreamingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StreamingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StreamingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StreamingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STREAMING_MODE = "streamingMode";
  @SerializedName(SERIALIZED_NAME_STREAMING_MODE)
  private StreamingModeEnum streamingMode;

  public static final String SERIALIZED_NAME_TEMP_STORAGE_PREFIX = "tempStoragePrefix";
  @SerializedName(SERIALIZED_NAME_TEMP_STORAGE_PREFIX)
  private String tempStoragePrefix;

  public static final String SERIALIZED_NAME_USE_STREAMING_ENGINE_RESOURCE_BASED_BILLING = "useStreamingEngineResourceBasedBilling";
  @SerializedName(SERIALIZED_NAME_USE_STREAMING_ENGINE_RESOURCE_BASED_BILLING)
  private Boolean useStreamingEngineResourceBasedBilling;

  public static final String SERIALIZED_NAME_USER_AGENT = "userAgent";
  @SerializedName(SERIALIZED_NAME_USER_AGENT)
  private Map<String, Object> userAgent = new HashMap<>();

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private Map<String, Object> version = new HashMap<>();

  public static final String SERIALIZED_NAME_WORKER_POOLS = "workerPools";
  @SerializedName(SERIALIZED_NAME_WORKER_POOLS)
  private List<WorkerPool> workerPools = new ArrayList<>();

  public static final String SERIALIZED_NAME_WORKER_REGION = "workerRegion";
  @SerializedName(SERIALIZED_NAME_WORKER_REGION)
  private String workerRegion;

  public static final String SERIALIZED_NAME_WORKER_ZONE = "workerZone";
  @SerializedName(SERIALIZED_NAME_WORKER_ZONE)
  private String workerZone;

  public Environment() {
  }

  public Environment(
     ShuffleModeEnum shuffleMode, 
     Boolean useStreamingEngineResourceBasedBilling
  ) {
    this();
    this.shuffleMode = shuffleMode;
    this.useStreamingEngineResourceBasedBilling = useStreamingEngineResourceBasedBilling;
  }

  public Environment clusterManagerApiService(String clusterManagerApiService) {
    this.clusterManagerApiService = clusterManagerApiService;
    return this;
  }

  /**
   * The type of cluster manager API to use. If unknown or unspecified, the service will attempt to choose a reasonable default. This should be in the form of the API service name, e.g. \&quot;compute.googleapis.com\&quot;.
   * @return clusterManagerApiService
   */
  @javax.annotation.Nullable
  public String getClusterManagerApiService() {
    return clusterManagerApiService;
  }

  public void setClusterManagerApiService(String clusterManagerApiService) {
    this.clusterManagerApiService = clusterManagerApiService;
  }


  public Environment dataset(String dataset) {
    this.dataset = dataset;
    return this;
  }

  /**
   * The dataset for the current project where various workflow related tables are stored. The supported resource type is: Google BigQuery: bigquery.googleapis.com/{dataset}
   * @return dataset
   */
  @javax.annotation.Nullable
  public String getDataset() {
    return dataset;
  }

  public void setDataset(String dataset) {
    this.dataset = dataset;
  }


  public Environment debugOptions(DebugOptions debugOptions) {
    this.debugOptions = debugOptions;
    return this;
  }

  /**
   * Get debugOptions
   * @return debugOptions
   */
  @javax.annotation.Nullable
  public DebugOptions getDebugOptions() {
    return debugOptions;
  }

  public void setDebugOptions(DebugOptions debugOptions) {
    this.debugOptions = debugOptions;
  }


  public Environment experiments(List<String> experiments) {
    this.experiments = experiments;
    return this;
  }

  public Environment addExperimentsItem(String experimentsItem) {
    if (this.experiments == null) {
      this.experiments = new ArrayList<>();
    }
    this.experiments.add(experimentsItem);
    return this;
  }

  /**
   * The list of experiments to enable. This field should be used for SDK related experiments and not for service related experiments. The proper field for service related experiments is service_options.
   * @return experiments
   */
  @javax.annotation.Nullable
  public List<String> getExperiments() {
    return experiments;
  }

  public void setExperiments(List<String> experiments) {
    this.experiments = experiments;
  }


  public Environment flexResourceSchedulingGoal(FlexResourceSchedulingGoalEnum flexResourceSchedulingGoal) {
    this.flexResourceSchedulingGoal = flexResourceSchedulingGoal;
    return this;
  }

  /**
   * Which Flexible Resource Scheduling mode to run in.
   * @return flexResourceSchedulingGoal
   */
  @javax.annotation.Nullable
  public FlexResourceSchedulingGoalEnum getFlexResourceSchedulingGoal() {
    return flexResourceSchedulingGoal;
  }

  public void setFlexResourceSchedulingGoal(FlexResourceSchedulingGoalEnum flexResourceSchedulingGoal) {
    this.flexResourceSchedulingGoal = flexResourceSchedulingGoal;
  }


  public Environment internalExperiments(Map<String, Object> internalExperiments) {
    this.internalExperiments = internalExperiments;
    return this;
  }

  public Environment putInternalExperimentsItem(String key, Object internalExperimentsItem) {
    if (this.internalExperiments == null) {
      this.internalExperiments = new HashMap<>();
    }
    this.internalExperiments.put(key, internalExperimentsItem);
    return this;
  }

  /**
   * Experimental settings.
   * @return internalExperiments
   */
  @javax.annotation.Nullable
  public Map<String, Object> getInternalExperiments() {
    return internalExperiments;
  }

  public void setInternalExperiments(Map<String, Object> internalExperiments) {
    this.internalExperiments = internalExperiments;
  }


  public Environment sdkPipelineOptions(Map<String, Object> sdkPipelineOptions) {
    this.sdkPipelineOptions = sdkPipelineOptions;
    return this;
  }

  public Environment putSdkPipelineOptionsItem(String key, Object sdkPipelineOptionsItem) {
    if (this.sdkPipelineOptions == null) {
      this.sdkPipelineOptions = new HashMap<>();
    }
    this.sdkPipelineOptions.put(key, sdkPipelineOptionsItem);
    return this;
  }

  /**
   * The Cloud Dataflow SDK pipeline options specified by the user. These options are passed through the service and are used to recreate the SDK pipeline options on the worker in a language agnostic and platform independent way.
   * @return sdkPipelineOptions
   */
  @javax.annotation.Nullable
  public Map<String, Object> getSdkPipelineOptions() {
    return sdkPipelineOptions;
  }

  public void setSdkPipelineOptions(Map<String, Object> sdkPipelineOptions) {
    this.sdkPipelineOptions = sdkPipelineOptions;
  }


  public Environment serviceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
    return this;
  }

  /**
   * Identity to run virtual machines as. Defaults to the default account.
   * @return serviceAccountEmail
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmail() {
    return serviceAccountEmail;
  }

  public void setServiceAccountEmail(String serviceAccountEmail) {
    this.serviceAccountEmail = serviceAccountEmail;
  }


  public Environment serviceKmsKeyName(String serviceKmsKeyName) {
    this.serviceKmsKeyName = serviceKmsKeyName;
    return this;
  }

  /**
   * If set, contains the Cloud KMS key identifier used to encrypt data at rest, AKA a Customer Managed Encryption Key (CMEK). Format: projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY
   * @return serviceKmsKeyName
   */
  @javax.annotation.Nullable
  public String getServiceKmsKeyName() {
    return serviceKmsKeyName;
  }

  public void setServiceKmsKeyName(String serviceKmsKeyName) {
    this.serviceKmsKeyName = serviceKmsKeyName;
  }


  public Environment serviceOptions(List<String> serviceOptions) {
    this.serviceOptions = serviceOptions;
    return this;
  }

  public Environment addServiceOptionsItem(String serviceOptionsItem) {
    if (this.serviceOptions == null) {
      this.serviceOptions = new ArrayList<>();
    }
    this.serviceOptions.add(serviceOptionsItem);
    return this;
  }

  /**
   * The list of service options to enable. This field should be used for service related experiments only. These experiments, when graduating to GA, should be replaced by dedicated fields or become default (i.e. always on).
   * @return serviceOptions
   */
  @javax.annotation.Nullable
  public List<String> getServiceOptions() {
    return serviceOptions;
  }

  public void setServiceOptions(List<String> serviceOptions) {
    this.serviceOptions = serviceOptions;
  }


  /**
   * Output only. The shuffle mode used for the job.
   * @return shuffleMode
   */
  @javax.annotation.Nullable
  public ShuffleModeEnum getShuffleMode() {
    return shuffleMode;
  }



  public Environment streamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
    return this;
  }

  /**
   * Optional. Specifies the Streaming Engine message processing guarantees. Reduces cost and latency but might result in duplicate messages committed to storage. Designed to run simple mapping streaming ETL jobs at the lowest cost. For example, Change Data Capture (CDC) to BigQuery is a canonical use case.
   * @return streamingMode
   */
  @javax.annotation.Nullable
  public StreamingModeEnum getStreamingMode() {
    return streamingMode;
  }

  public void setStreamingMode(StreamingModeEnum streamingMode) {
    this.streamingMode = streamingMode;
  }


  public Environment tempStoragePrefix(String tempStoragePrefix) {
    this.tempStoragePrefix = tempStoragePrefix;
    return this;
  }

  /**
   * The prefix of the resources the system should use for temporary storage. The system will append the suffix \&quot;/temp-{JOBNAME} to this resource prefix, where {JOBNAME} is the value of the job_name field. The resulting bucket and object prefix is used as the prefix of the resources used to store temporary data needed during the job execution. NOTE: This will override the value in taskrunner_settings. The supported resource type is: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
   * @return tempStoragePrefix
   */
  @javax.annotation.Nullable
  public String getTempStoragePrefix() {
    return tempStoragePrefix;
  }

  public void setTempStoragePrefix(String tempStoragePrefix) {
    this.tempStoragePrefix = tempStoragePrefix;
  }


  /**
   * Output only. Whether the job uses the Streaming Engine resource-based billing model.
   * @return useStreamingEngineResourceBasedBilling
   */
  @javax.annotation.Nullable
  public Boolean getUseStreamingEngineResourceBasedBilling() {
    return useStreamingEngineResourceBasedBilling;
  }



  public Environment userAgent(Map<String, Object> userAgent) {
    this.userAgent = userAgent;
    return this;
  }

  public Environment putUserAgentItem(String key, Object userAgentItem) {
    if (this.userAgent == null) {
      this.userAgent = new HashMap<>();
    }
    this.userAgent.put(key, userAgentItem);
    return this;
  }

  /**
   * A description of the process that generated the request.
   * @return userAgent
   */
  @javax.annotation.Nullable
  public Map<String, Object> getUserAgent() {
    return userAgent;
  }

  public void setUserAgent(Map<String, Object> userAgent) {
    this.userAgent = userAgent;
  }


  public Environment version(Map<String, Object> version) {
    this.version = version;
    return this;
  }

  public Environment putVersionItem(String key, Object versionItem) {
    if (this.version == null) {
      this.version = new HashMap<>();
    }
    this.version.put(key, versionItem);
    return this;
  }

  /**
   * A structure describing which components and their versions of the service are required in order to run the job.
   * @return version
   */
  @javax.annotation.Nullable
  public Map<String, Object> getVersion() {
    return version;
  }

  public void setVersion(Map<String, Object> version) {
    this.version = version;
  }


  public Environment workerPools(List<WorkerPool> workerPools) {
    this.workerPools = workerPools;
    return this;
  }

  public Environment addWorkerPoolsItem(WorkerPool workerPoolsItem) {
    if (this.workerPools == null) {
      this.workerPools = new ArrayList<>();
    }
    this.workerPools.add(workerPoolsItem);
    return this;
  }

  /**
   * The worker pools. At least one \&quot;harness\&quot; worker pool must be specified in order for the job to have workers.
   * @return workerPools
   */
  @javax.annotation.Nullable
  public List<WorkerPool> getWorkerPools() {
    return workerPools;
  }

  public void setWorkerPools(List<WorkerPool> workerPools) {
    this.workerPools = workerPools;
  }


  public Environment workerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
    return this;
  }

  /**
   * The Compute Engine region (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1\&quot;. Mutually exclusive with worker_zone. If neither worker_region nor worker_zone is specified, default to the control plane&#39;s region.
   * @return workerRegion
   */
  @javax.annotation.Nullable
  public String getWorkerRegion() {
    return workerRegion;
  }

  public void setWorkerRegion(String workerRegion) {
    this.workerRegion = workerRegion;
  }


  public Environment workerZone(String workerZone) {
    this.workerZone = workerZone;
    return this;
  }

  /**
   * The Compute Engine zone (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. \&quot;us-west1-a\&quot;. Mutually exclusive with worker_region. If neither worker_region nor worker_zone is specified, a zone in the control plane&#39;s region is chosen based on available capacity.
   * @return workerZone
   */
  @javax.annotation.Nullable
  public String getWorkerZone() {
    return workerZone;
  }

  public void setWorkerZone(String workerZone) {
    this.workerZone = workerZone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Environment environment = (Environment) o;
    return Objects.equals(this.clusterManagerApiService, environment.clusterManagerApiService) &&
        Objects.equals(this.dataset, environment.dataset) &&
        Objects.equals(this.debugOptions, environment.debugOptions) &&
        Objects.equals(this.experiments, environment.experiments) &&
        Objects.equals(this.flexResourceSchedulingGoal, environment.flexResourceSchedulingGoal) &&
        Objects.equals(this.internalExperiments, environment.internalExperiments) &&
        Objects.equals(this.sdkPipelineOptions, environment.sdkPipelineOptions) &&
        Objects.equals(this.serviceAccountEmail, environment.serviceAccountEmail) &&
        Objects.equals(this.serviceKmsKeyName, environment.serviceKmsKeyName) &&
        Objects.equals(this.serviceOptions, environment.serviceOptions) &&
        Objects.equals(this.shuffleMode, environment.shuffleMode) &&
        Objects.equals(this.streamingMode, environment.streamingMode) &&
        Objects.equals(this.tempStoragePrefix, environment.tempStoragePrefix) &&
        Objects.equals(this.useStreamingEngineResourceBasedBilling, environment.useStreamingEngineResourceBasedBilling) &&
        Objects.equals(this.userAgent, environment.userAgent) &&
        Objects.equals(this.version, environment.version) &&
        Objects.equals(this.workerPools, environment.workerPools) &&
        Objects.equals(this.workerRegion, environment.workerRegion) &&
        Objects.equals(this.workerZone, environment.workerZone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clusterManagerApiService, dataset, debugOptions, experiments, flexResourceSchedulingGoal, internalExperiments, sdkPipelineOptions, serviceAccountEmail, serviceKmsKeyName, serviceOptions, shuffleMode, streamingMode, tempStoragePrefix, useStreamingEngineResourceBasedBilling, userAgent, version, workerPools, workerRegion, workerZone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Environment {\n");
    sb.append("    clusterManagerApiService: ").append(toIndentedString(clusterManagerApiService)).append("\n");
    sb.append("    dataset: ").append(toIndentedString(dataset)).append("\n");
    sb.append("    debugOptions: ").append(toIndentedString(debugOptions)).append("\n");
    sb.append("    experiments: ").append(toIndentedString(experiments)).append("\n");
    sb.append("    flexResourceSchedulingGoal: ").append(toIndentedString(flexResourceSchedulingGoal)).append("\n");
    sb.append("    internalExperiments: ").append(toIndentedString(internalExperiments)).append("\n");
    sb.append("    sdkPipelineOptions: ").append(toIndentedString(sdkPipelineOptions)).append("\n");
    sb.append("    serviceAccountEmail: ").append(toIndentedString(serviceAccountEmail)).append("\n");
    sb.append("    serviceKmsKeyName: ").append(toIndentedString(serviceKmsKeyName)).append("\n");
    sb.append("    serviceOptions: ").append(toIndentedString(serviceOptions)).append("\n");
    sb.append("    shuffleMode: ").append(toIndentedString(shuffleMode)).append("\n");
    sb.append("    streamingMode: ").append(toIndentedString(streamingMode)).append("\n");
    sb.append("    tempStoragePrefix: ").append(toIndentedString(tempStoragePrefix)).append("\n");
    sb.append("    useStreamingEngineResourceBasedBilling: ").append(toIndentedString(useStreamingEngineResourceBasedBilling)).append("\n");
    sb.append("    userAgent: ").append(toIndentedString(userAgent)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    workerPools: ").append(toIndentedString(workerPools)).append("\n");
    sb.append("    workerRegion: ").append(toIndentedString(workerRegion)).append("\n");
    sb.append("    workerZone: ").append(toIndentedString(workerZone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clusterManagerApiService");
    openapiFields.add("dataset");
    openapiFields.add("debugOptions");
    openapiFields.add("experiments");
    openapiFields.add("flexResourceSchedulingGoal");
    openapiFields.add("internalExperiments");
    openapiFields.add("sdkPipelineOptions");
    openapiFields.add("serviceAccountEmail");
    openapiFields.add("serviceKmsKeyName");
    openapiFields.add("serviceOptions");
    openapiFields.add("shuffleMode");
    openapiFields.add("streamingMode");
    openapiFields.add("tempStoragePrefix");
    openapiFields.add("useStreamingEngineResourceBasedBilling");
    openapiFields.add("userAgent");
    openapiFields.add("version");
    openapiFields.add("workerPools");
    openapiFields.add("workerRegion");
    openapiFields.add("workerZone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Environment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Environment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Environment is not found in the empty JSON string", Environment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Environment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Environment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("clusterManagerApiService") != null && !jsonObj.get("clusterManagerApiService").isJsonNull()) && !jsonObj.get("clusterManagerApiService").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterManagerApiService` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterManagerApiService").toString()));
      }
      if ((jsonObj.get("dataset") != null && !jsonObj.get("dataset").isJsonNull()) && !jsonObj.get("dataset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataset").toString()));
      }
      // validate the optional field `debugOptions`
      if (jsonObj.get("debugOptions") != null && !jsonObj.get("debugOptions").isJsonNull()) {
        DebugOptions.validateJsonElement(jsonObj.get("debugOptions"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("experiments") != null && !jsonObj.get("experiments").isJsonNull() && !jsonObj.get("experiments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `experiments` to be an array in the JSON string but got `%s`", jsonObj.get("experiments").toString()));
      }
      if ((jsonObj.get("flexResourceSchedulingGoal") != null && !jsonObj.get("flexResourceSchedulingGoal").isJsonNull()) && !jsonObj.get("flexResourceSchedulingGoal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flexResourceSchedulingGoal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flexResourceSchedulingGoal").toString()));
      }
      // validate the optional field `flexResourceSchedulingGoal`
      if (jsonObj.get("flexResourceSchedulingGoal") != null && !jsonObj.get("flexResourceSchedulingGoal").isJsonNull()) {
        FlexResourceSchedulingGoalEnum.validateJsonElement(jsonObj.get("flexResourceSchedulingGoal"));
      }
      if ((jsonObj.get("serviceAccountEmail") != null && !jsonObj.get("serviceAccountEmail").isJsonNull()) && !jsonObj.get("serviceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmail").toString()));
      }
      if ((jsonObj.get("serviceKmsKeyName") != null && !jsonObj.get("serviceKmsKeyName").isJsonNull()) && !jsonObj.get("serviceKmsKeyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceKmsKeyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceKmsKeyName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("serviceOptions") != null && !jsonObj.get("serviceOptions").isJsonNull() && !jsonObj.get("serviceOptions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceOptions` to be an array in the JSON string but got `%s`", jsonObj.get("serviceOptions").toString()));
      }
      if ((jsonObj.get("shuffleMode") != null && !jsonObj.get("shuffleMode").isJsonNull()) && !jsonObj.get("shuffleMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shuffleMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shuffleMode").toString()));
      }
      // validate the optional field `shuffleMode`
      if (jsonObj.get("shuffleMode") != null && !jsonObj.get("shuffleMode").isJsonNull()) {
        ShuffleModeEnum.validateJsonElement(jsonObj.get("shuffleMode"));
      }
      if ((jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) && !jsonObj.get("streamingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamingMode").toString()));
      }
      // validate the optional field `streamingMode`
      if (jsonObj.get("streamingMode") != null && !jsonObj.get("streamingMode").isJsonNull()) {
        StreamingModeEnum.validateJsonElement(jsonObj.get("streamingMode"));
      }
      if ((jsonObj.get("tempStoragePrefix") != null && !jsonObj.get("tempStoragePrefix").isJsonNull()) && !jsonObj.get("tempStoragePrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tempStoragePrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tempStoragePrefix").toString()));
      }
      if (jsonObj.get("workerPools") != null && !jsonObj.get("workerPools").isJsonNull()) {
        JsonArray jsonArrayworkerPools = jsonObj.getAsJsonArray("workerPools");
        if (jsonArrayworkerPools != null) {
          // ensure the json data is an array
          if (!jsonObj.get("workerPools").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `workerPools` to be an array in the JSON string but got `%s`", jsonObj.get("workerPools").toString()));
          }

          // validate the optional field `workerPools` (array)
          for (int i = 0; i < jsonArrayworkerPools.size(); i++) {
            WorkerPool.validateJsonElement(jsonArrayworkerPools.get(i));
          };
        }
      }
      if ((jsonObj.get("workerRegion") != null && !jsonObj.get("workerRegion").isJsonNull()) && !jsonObj.get("workerRegion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerRegion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerRegion").toString()));
      }
      if ((jsonObj.get("workerZone") != null && !jsonObj.get("workerZone").isJsonNull()) && !jsonObj.get("workerZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerZone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Environment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Environment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Environment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Environment.class));

       return (TypeAdapter<T>) new TypeAdapter<Environment>() {
           @Override
           public void write(JsonWriter out, Environment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Environment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Environment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Environment
   * @throws IOException if the JSON string is invalid with respect to Environment
   */
  public static Environment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Environment.class);
  }

  /**
   * Convert an instance of Environment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

