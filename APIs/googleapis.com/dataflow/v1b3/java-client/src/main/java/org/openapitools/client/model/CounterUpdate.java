/*
 * Dataflow API
 * Manages Google Cloud Dataflow projects on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1b3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.CounterStructuredNameAndMetadata;
import org.openapitools.client.model.DistributionUpdate;
import org.openapitools.client.model.FloatingPointList;
import org.openapitools.client.model.FloatingPointMean;
import org.openapitools.client.model.IntegerGauge;
import org.openapitools.client.model.IntegerList;
import org.openapitools.client.model.IntegerMean;
import org.openapitools.client.model.NameAndKind;
import org.openapitools.client.model.SplitInt64;
import org.openapitools.client.model.StringList;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An update to a Counter sent from a worker.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:54.918086-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CounterUpdate {
  public static final String SERIALIZED_NAME_BOOLEAN = "boolean";
  @SerializedName(SERIALIZED_NAME_BOOLEAN)
  private Boolean _boolean;

  public static final String SERIALIZED_NAME_CUMULATIVE = "cumulative";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE)
  private Boolean cumulative;

  public static final String SERIALIZED_NAME_DISTRIBUTION = "distribution";
  @SerializedName(SERIALIZED_NAME_DISTRIBUTION)
  private DistributionUpdate distribution;

  public static final String SERIALIZED_NAME_FLOATING_POINT = "floatingPoint";
  @SerializedName(SERIALIZED_NAME_FLOATING_POINT)
  private Double floatingPoint;

  public static final String SERIALIZED_NAME_FLOATING_POINT_LIST = "floatingPointList";
  @SerializedName(SERIALIZED_NAME_FLOATING_POINT_LIST)
  private FloatingPointList floatingPointList;

  public static final String SERIALIZED_NAME_FLOATING_POINT_MEAN = "floatingPointMean";
  @SerializedName(SERIALIZED_NAME_FLOATING_POINT_MEAN)
  private FloatingPointMean floatingPointMean;

  public static final String SERIALIZED_NAME_INTEGER = "integer";
  @SerializedName(SERIALIZED_NAME_INTEGER)
  private SplitInt64 integer;

  public static final String SERIALIZED_NAME_INTEGER_GAUGE = "integerGauge";
  @SerializedName(SERIALIZED_NAME_INTEGER_GAUGE)
  private IntegerGauge integerGauge;

  public static final String SERIALIZED_NAME_INTEGER_LIST = "integerList";
  @SerializedName(SERIALIZED_NAME_INTEGER_LIST)
  private IntegerList integerList;

  public static final String SERIALIZED_NAME_INTEGER_MEAN = "integerMean";
  @SerializedName(SERIALIZED_NAME_INTEGER_MEAN)
  private IntegerMean integerMean;

  public static final String SERIALIZED_NAME_INTERNAL = "internal";
  @SerializedName(SERIALIZED_NAME_INTERNAL)
  private Object internal = null;

  public static final String SERIALIZED_NAME_NAME_AND_KIND = "nameAndKind";
  @SerializedName(SERIALIZED_NAME_NAME_AND_KIND)
  private NameAndKind nameAndKind;

  public static final String SERIALIZED_NAME_SHORT_ID = "shortId";
  @SerializedName(SERIALIZED_NAME_SHORT_ID)
  private String shortId;

  public static final String SERIALIZED_NAME_STRING_LIST = "stringList";
  @SerializedName(SERIALIZED_NAME_STRING_LIST)
  private StringList stringList;

  public static final String SERIALIZED_NAME_STRUCTURED_NAME_AND_METADATA = "structuredNameAndMetadata";
  @SerializedName(SERIALIZED_NAME_STRUCTURED_NAME_AND_METADATA)
  private CounterStructuredNameAndMetadata structuredNameAndMetadata;

  public CounterUpdate() {
  }

  public CounterUpdate _boolean(Boolean _boolean) {
    this._boolean = _boolean;
    return this;
  }

  /**
   * Boolean value for And, Or.
   * @return _boolean
   */
  @javax.annotation.Nullable
  public Boolean getBoolean() {
    return _boolean;
  }

  public void setBoolean(Boolean _boolean) {
    this._boolean = _boolean;
  }


  public CounterUpdate cumulative(Boolean cumulative) {
    this.cumulative = cumulative;
    return this;
  }

  /**
   * True if this counter is reported as the total cumulative aggregate value accumulated since the worker started working on this WorkItem. By default this is false, indicating that this counter is reported as a delta.
   * @return cumulative
   */
  @javax.annotation.Nullable
  public Boolean getCumulative() {
    return cumulative;
  }

  public void setCumulative(Boolean cumulative) {
    this.cumulative = cumulative;
  }


  public CounterUpdate distribution(DistributionUpdate distribution) {
    this.distribution = distribution;
    return this;
  }

  /**
   * Get distribution
   * @return distribution
   */
  @javax.annotation.Nullable
  public DistributionUpdate getDistribution() {
    return distribution;
  }

  public void setDistribution(DistributionUpdate distribution) {
    this.distribution = distribution;
  }


  public CounterUpdate floatingPoint(Double floatingPoint) {
    this.floatingPoint = floatingPoint;
    return this;
  }

  /**
   * Floating point value for Sum, Max, Min.
   * @return floatingPoint
   */
  @javax.annotation.Nullable
  public Double getFloatingPoint() {
    return floatingPoint;
  }

  public void setFloatingPoint(Double floatingPoint) {
    this.floatingPoint = floatingPoint;
  }


  public CounterUpdate floatingPointList(FloatingPointList floatingPointList) {
    this.floatingPointList = floatingPointList;
    return this;
  }

  /**
   * Get floatingPointList
   * @return floatingPointList
   */
  @javax.annotation.Nullable
  public FloatingPointList getFloatingPointList() {
    return floatingPointList;
  }

  public void setFloatingPointList(FloatingPointList floatingPointList) {
    this.floatingPointList = floatingPointList;
  }


  public CounterUpdate floatingPointMean(FloatingPointMean floatingPointMean) {
    this.floatingPointMean = floatingPointMean;
    return this;
  }

  /**
   * Get floatingPointMean
   * @return floatingPointMean
   */
  @javax.annotation.Nullable
  public FloatingPointMean getFloatingPointMean() {
    return floatingPointMean;
  }

  public void setFloatingPointMean(FloatingPointMean floatingPointMean) {
    this.floatingPointMean = floatingPointMean;
  }


  public CounterUpdate integer(SplitInt64 integer) {
    this.integer = integer;
    return this;
  }

  /**
   * Get integer
   * @return integer
   */
  @javax.annotation.Nullable
  public SplitInt64 getInteger() {
    return integer;
  }

  public void setInteger(SplitInt64 integer) {
    this.integer = integer;
  }


  public CounterUpdate integerGauge(IntegerGauge integerGauge) {
    this.integerGauge = integerGauge;
    return this;
  }

  /**
   * Get integerGauge
   * @return integerGauge
   */
  @javax.annotation.Nullable
  public IntegerGauge getIntegerGauge() {
    return integerGauge;
  }

  public void setIntegerGauge(IntegerGauge integerGauge) {
    this.integerGauge = integerGauge;
  }


  public CounterUpdate integerList(IntegerList integerList) {
    this.integerList = integerList;
    return this;
  }

  /**
   * Get integerList
   * @return integerList
   */
  @javax.annotation.Nullable
  public IntegerList getIntegerList() {
    return integerList;
  }

  public void setIntegerList(IntegerList integerList) {
    this.integerList = integerList;
  }


  public CounterUpdate integerMean(IntegerMean integerMean) {
    this.integerMean = integerMean;
    return this;
  }

  /**
   * Get integerMean
   * @return integerMean
   */
  @javax.annotation.Nullable
  public IntegerMean getIntegerMean() {
    return integerMean;
  }

  public void setIntegerMean(IntegerMean integerMean) {
    this.integerMean = integerMean;
  }


  public CounterUpdate internal(Object internal) {
    this.internal = internal;
    return this;
  }

  /**
   * Value for internally-defined counters used by the Dataflow service.
   * @return internal
   */
  @javax.annotation.Nullable
  public Object getInternal() {
    return internal;
  }

  public void setInternal(Object internal) {
    this.internal = internal;
  }


  public CounterUpdate nameAndKind(NameAndKind nameAndKind) {
    this.nameAndKind = nameAndKind;
    return this;
  }

  /**
   * Get nameAndKind
   * @return nameAndKind
   */
  @javax.annotation.Nullable
  public NameAndKind getNameAndKind() {
    return nameAndKind;
  }

  public void setNameAndKind(NameAndKind nameAndKind) {
    this.nameAndKind = nameAndKind;
  }


  public CounterUpdate shortId(String shortId) {
    this.shortId = shortId;
    return this;
  }

  /**
   * The service-generated short identifier for this counter. The short_id -&gt; (name, metadata) mapping is constant for the lifetime of a job.
   * @return shortId
   */
  @javax.annotation.Nullable
  public String getShortId() {
    return shortId;
  }

  public void setShortId(String shortId) {
    this.shortId = shortId;
  }


  public CounterUpdate stringList(StringList stringList) {
    this.stringList = stringList;
    return this;
  }

  /**
   * Get stringList
   * @return stringList
   */
  @javax.annotation.Nullable
  public StringList getStringList() {
    return stringList;
  }

  public void setStringList(StringList stringList) {
    this.stringList = stringList;
  }


  public CounterUpdate structuredNameAndMetadata(CounterStructuredNameAndMetadata structuredNameAndMetadata) {
    this.structuredNameAndMetadata = structuredNameAndMetadata;
    return this;
  }

  /**
   * Get structuredNameAndMetadata
   * @return structuredNameAndMetadata
   */
  @javax.annotation.Nullable
  public CounterStructuredNameAndMetadata getStructuredNameAndMetadata() {
    return structuredNameAndMetadata;
  }

  public void setStructuredNameAndMetadata(CounterStructuredNameAndMetadata structuredNameAndMetadata) {
    this.structuredNameAndMetadata = structuredNameAndMetadata;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CounterUpdate counterUpdate = (CounterUpdate) o;
    return Objects.equals(this._boolean, counterUpdate._boolean) &&
        Objects.equals(this.cumulative, counterUpdate.cumulative) &&
        Objects.equals(this.distribution, counterUpdate.distribution) &&
        Objects.equals(this.floatingPoint, counterUpdate.floatingPoint) &&
        Objects.equals(this.floatingPointList, counterUpdate.floatingPointList) &&
        Objects.equals(this.floatingPointMean, counterUpdate.floatingPointMean) &&
        Objects.equals(this.integer, counterUpdate.integer) &&
        Objects.equals(this.integerGauge, counterUpdate.integerGauge) &&
        Objects.equals(this.integerList, counterUpdate.integerList) &&
        Objects.equals(this.integerMean, counterUpdate.integerMean) &&
        Objects.equals(this.internal, counterUpdate.internal) &&
        Objects.equals(this.nameAndKind, counterUpdate.nameAndKind) &&
        Objects.equals(this.shortId, counterUpdate.shortId) &&
        Objects.equals(this.stringList, counterUpdate.stringList) &&
        Objects.equals(this.structuredNameAndMetadata, counterUpdate.structuredNameAndMetadata);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(_boolean, cumulative, distribution, floatingPoint, floatingPointList, floatingPointMean, integer, integerGauge, integerList, integerMean, internal, nameAndKind, shortId, stringList, structuredNameAndMetadata);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CounterUpdate {\n");
    sb.append("    _boolean: ").append(toIndentedString(_boolean)).append("\n");
    sb.append("    cumulative: ").append(toIndentedString(cumulative)).append("\n");
    sb.append("    distribution: ").append(toIndentedString(distribution)).append("\n");
    sb.append("    floatingPoint: ").append(toIndentedString(floatingPoint)).append("\n");
    sb.append("    floatingPointList: ").append(toIndentedString(floatingPointList)).append("\n");
    sb.append("    floatingPointMean: ").append(toIndentedString(floatingPointMean)).append("\n");
    sb.append("    integer: ").append(toIndentedString(integer)).append("\n");
    sb.append("    integerGauge: ").append(toIndentedString(integerGauge)).append("\n");
    sb.append("    integerList: ").append(toIndentedString(integerList)).append("\n");
    sb.append("    integerMean: ").append(toIndentedString(integerMean)).append("\n");
    sb.append("    internal: ").append(toIndentedString(internal)).append("\n");
    sb.append("    nameAndKind: ").append(toIndentedString(nameAndKind)).append("\n");
    sb.append("    shortId: ").append(toIndentedString(shortId)).append("\n");
    sb.append("    stringList: ").append(toIndentedString(stringList)).append("\n");
    sb.append("    structuredNameAndMetadata: ").append(toIndentedString(structuredNameAndMetadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("boolean");
    openapiFields.add("cumulative");
    openapiFields.add("distribution");
    openapiFields.add("floatingPoint");
    openapiFields.add("floatingPointList");
    openapiFields.add("floatingPointMean");
    openapiFields.add("integer");
    openapiFields.add("integerGauge");
    openapiFields.add("integerList");
    openapiFields.add("integerMean");
    openapiFields.add("internal");
    openapiFields.add("nameAndKind");
    openapiFields.add("shortId");
    openapiFields.add("stringList");
    openapiFields.add("structuredNameAndMetadata");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CounterUpdate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CounterUpdate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CounterUpdate is not found in the empty JSON string", CounterUpdate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CounterUpdate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CounterUpdate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `distribution`
      if (jsonObj.get("distribution") != null && !jsonObj.get("distribution").isJsonNull()) {
        DistributionUpdate.validateJsonElement(jsonObj.get("distribution"));
      }
      // validate the optional field `floatingPointList`
      if (jsonObj.get("floatingPointList") != null && !jsonObj.get("floatingPointList").isJsonNull()) {
        FloatingPointList.validateJsonElement(jsonObj.get("floatingPointList"));
      }
      // validate the optional field `floatingPointMean`
      if (jsonObj.get("floatingPointMean") != null && !jsonObj.get("floatingPointMean").isJsonNull()) {
        FloatingPointMean.validateJsonElement(jsonObj.get("floatingPointMean"));
      }
      // validate the optional field `integer`
      if (jsonObj.get("integer") != null && !jsonObj.get("integer").isJsonNull()) {
        SplitInt64.validateJsonElement(jsonObj.get("integer"));
      }
      // validate the optional field `integerGauge`
      if (jsonObj.get("integerGauge") != null && !jsonObj.get("integerGauge").isJsonNull()) {
        IntegerGauge.validateJsonElement(jsonObj.get("integerGauge"));
      }
      // validate the optional field `integerList`
      if (jsonObj.get("integerList") != null && !jsonObj.get("integerList").isJsonNull()) {
        IntegerList.validateJsonElement(jsonObj.get("integerList"));
      }
      // validate the optional field `integerMean`
      if (jsonObj.get("integerMean") != null && !jsonObj.get("integerMean").isJsonNull()) {
        IntegerMean.validateJsonElement(jsonObj.get("integerMean"));
      }
      // validate the optional field `nameAndKind`
      if (jsonObj.get("nameAndKind") != null && !jsonObj.get("nameAndKind").isJsonNull()) {
        NameAndKind.validateJsonElement(jsonObj.get("nameAndKind"));
      }
      if ((jsonObj.get("shortId") != null && !jsonObj.get("shortId").isJsonNull()) && !jsonObj.get("shortId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shortId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shortId").toString()));
      }
      // validate the optional field `stringList`
      if (jsonObj.get("stringList") != null && !jsonObj.get("stringList").isJsonNull()) {
        StringList.validateJsonElement(jsonObj.get("stringList"));
      }
      // validate the optional field `structuredNameAndMetadata`
      if (jsonObj.get("structuredNameAndMetadata") != null && !jsonObj.get("structuredNameAndMetadata").isJsonNull()) {
        CounterStructuredNameAndMetadata.validateJsonElement(jsonObj.get("structuredNameAndMetadata"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CounterUpdate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CounterUpdate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CounterUpdate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CounterUpdate.class));

       return (TypeAdapter<T>) new TypeAdapter<CounterUpdate>() {
           @Override
           public void write(JsonWriter out, CounterUpdate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CounterUpdate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CounterUpdate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CounterUpdate
   * @throws IOException if the JSON string is invalid with respect to CounterUpdate
   */
  public static CounterUpdate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CounterUpdate.class);
  }

  /**
   * Convert an instance of CounterUpdate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

