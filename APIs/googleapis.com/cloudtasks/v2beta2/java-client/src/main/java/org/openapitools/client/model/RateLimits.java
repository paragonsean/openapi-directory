/*
 * Cloud Tasks API
 * Manages the execution of large numbers of distributed requests.
 *
 * The version of the OpenAPI document: v2beta2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Rate limits. This message determines the maximum rate that tasks can be dispatched by a queue, regardless of whether the dispatch is a first task attempt or a retry. Note: The debugging command, RunTask, will run a task even if the queue has reached its RateLimits.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:06.175700-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RateLimits {
  public static final String SERIALIZED_NAME_MAX_BURST_SIZE = "maxBurstSize";
  @SerializedName(SERIALIZED_NAME_MAX_BURST_SIZE)
  private Integer maxBurstSize;

  public static final String SERIALIZED_NAME_MAX_CONCURRENT_TASKS = "maxConcurrentTasks";
  @SerializedName(SERIALIZED_NAME_MAX_CONCURRENT_TASKS)
  private Integer maxConcurrentTasks;

  public static final String SERIALIZED_NAME_MAX_TASKS_DISPATCHED_PER_SECOND = "maxTasksDispatchedPerSecond";
  @SerializedName(SERIALIZED_NAME_MAX_TASKS_DISPATCHED_PER_SECOND)
  private Double maxTasksDispatchedPerSecond;

  public RateLimits() {
  }

  public RateLimits maxBurstSize(Integer maxBurstSize) {
    this.maxBurstSize = maxBurstSize;
    return this;
  }

  /**
   * The max burst size. Max burst size limits how fast tasks in queue are processed when many tasks are in the queue and the rate is high. This field allows the queue to have a high rate so processing starts shortly after a task is enqueued, but still limits resource usage when many tasks are enqueued in a short period of time. The [token bucket](https://wikipedia.org/wiki/Token_Bucket) algorithm is used to control the rate of task dispatches. Each queue has a token bucket that holds tokens, up to the maximum specified by &#x60;max_burst_size&#x60;. Each time a task is dispatched, a token is removed from the bucket. Tasks will be dispatched until the queue&#39;s bucket runs out of tokens. The bucket will be continuously refilled with new tokens based on max_dispatches_per_second. The default value of &#x60;max_burst_size&#x60; is picked by Cloud Tasks based on the value of max_dispatches_per_second. The maximum value of &#x60;max_burst_size&#x60; is 500. For App Engine queues that were created or updated using &#x60;queue.yaml/xml&#x60;, &#x60;max_burst_size&#x60; is equal to [bucket_size](https://cloud.google.com/appengine/docs/standard/python/config/queueref#bucket_size). If UpdateQueue is called on a queue without explicitly setting a value for &#x60;max_burst_size&#x60;, &#x60;max_burst_size&#x60; value will get updated if UpdateQueue is updating max_dispatches_per_second. 
   * @return maxBurstSize
   */
  @javax.annotation.Nullable
  public Integer getMaxBurstSize() {
    return maxBurstSize;
  }

  public void setMaxBurstSize(Integer maxBurstSize) {
    this.maxBurstSize = maxBurstSize;
  }


  public RateLimits maxConcurrentTasks(Integer maxConcurrentTasks) {
    this.maxConcurrentTasks = maxConcurrentTasks;
    return this;
  }

  /**
   * The maximum number of concurrent tasks that Cloud Tasks allows to be dispatched for this queue. After this threshold has been reached, Cloud Tasks stops dispatching tasks until the number of concurrent requests decreases. If unspecified when the queue is created, Cloud Tasks will pick the default. The maximum allowed value is 5,000. This field is output only for pull queues and always -1, which indicates no limit. No other queue types can have &#x60;max_concurrent_tasks&#x60; set to -1. This field has the same meaning as [max_concurrent_requests in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#max_concurrent_requests).
   * @return maxConcurrentTasks
   */
  @javax.annotation.Nullable
  public Integer getMaxConcurrentTasks() {
    return maxConcurrentTasks;
  }

  public void setMaxConcurrentTasks(Integer maxConcurrentTasks) {
    this.maxConcurrentTasks = maxConcurrentTasks;
  }


  public RateLimits maxTasksDispatchedPerSecond(Double maxTasksDispatchedPerSecond) {
    this.maxTasksDispatchedPerSecond = maxTasksDispatchedPerSecond;
    return this;
  }

  /**
   * The maximum rate at which tasks are dispatched from this queue. If unspecified when the queue is created, Cloud Tasks will pick the default. * For App Engine queues, the maximum allowed value is 500. * This field is output only for pull queues. In addition to the &#x60;max_tasks_dispatched_per_second&#x60; limit, a maximum of 10 QPS of LeaseTasks requests are allowed per pull queue. This field has the same meaning as [rate in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#rate).
   * @return maxTasksDispatchedPerSecond
   */
  @javax.annotation.Nullable
  public Double getMaxTasksDispatchedPerSecond() {
    return maxTasksDispatchedPerSecond;
  }

  public void setMaxTasksDispatchedPerSecond(Double maxTasksDispatchedPerSecond) {
    this.maxTasksDispatchedPerSecond = maxTasksDispatchedPerSecond;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RateLimits rateLimits = (RateLimits) o;
    return Objects.equals(this.maxBurstSize, rateLimits.maxBurstSize) &&
        Objects.equals(this.maxConcurrentTasks, rateLimits.maxConcurrentTasks) &&
        Objects.equals(this.maxTasksDispatchedPerSecond, rateLimits.maxTasksDispatchedPerSecond);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxBurstSize, maxConcurrentTasks, maxTasksDispatchedPerSecond);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RateLimits {\n");
    sb.append("    maxBurstSize: ").append(toIndentedString(maxBurstSize)).append("\n");
    sb.append("    maxConcurrentTasks: ").append(toIndentedString(maxConcurrentTasks)).append("\n");
    sb.append("    maxTasksDispatchedPerSecond: ").append(toIndentedString(maxTasksDispatchedPerSecond)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxBurstSize");
    openapiFields.add("maxConcurrentTasks");
    openapiFields.add("maxTasksDispatchedPerSecond");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RateLimits
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RateLimits.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RateLimits is not found in the empty JSON string", RateLimits.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RateLimits.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RateLimits` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RateLimits.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RateLimits' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RateLimits> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RateLimits.class));

       return (TypeAdapter<T>) new TypeAdapter<RateLimits>() {
           @Override
           public void write(JsonWriter out, RateLimits value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RateLimits read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RateLimits given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RateLimits
   * @throws IOException if the JSON string is invalid with respect to RateLimits
   */
  public static RateLimits fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RateLimits.class);
  }

  /**
   * Convert an instance of RateLimits to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

