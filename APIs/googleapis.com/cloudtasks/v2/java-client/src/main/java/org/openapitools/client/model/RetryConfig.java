/*
 * Cloud Tasks API
 * Manages the execution of large numbers of distributed requests.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Retry config. These settings determine when a failed task attempt is retried.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:12.281691-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RetryConfig {
  public static final String SERIALIZED_NAME_MAX_ATTEMPTS = "maxAttempts";
  @SerializedName(SERIALIZED_NAME_MAX_ATTEMPTS)
  private Integer maxAttempts;

  public static final String SERIALIZED_NAME_MAX_BACKOFF = "maxBackoff";
  @SerializedName(SERIALIZED_NAME_MAX_BACKOFF)
  private String maxBackoff;

  public static final String SERIALIZED_NAME_MAX_DOUBLINGS = "maxDoublings";
  @SerializedName(SERIALIZED_NAME_MAX_DOUBLINGS)
  private Integer maxDoublings;

  public static final String SERIALIZED_NAME_MAX_RETRY_DURATION = "maxRetryDuration";
  @SerializedName(SERIALIZED_NAME_MAX_RETRY_DURATION)
  private String maxRetryDuration;

  public static final String SERIALIZED_NAME_MIN_BACKOFF = "minBackoff";
  @SerializedName(SERIALIZED_NAME_MIN_BACKOFF)
  private String minBackoff;

  public RetryConfig() {
  }

  public RetryConfig maxAttempts(Integer maxAttempts) {
    this.maxAttempts = maxAttempts;
    return this;
  }

  /**
   * Number of attempts per task. Cloud Tasks will attempt the task &#x60;max_attempts&#x60; times (that is, if the first attempt fails, then there will be &#x60;max_attempts - 1&#x60; retries). Must be &gt;&#x3D; -1. If unspecified when the queue is created, Cloud Tasks will pick the default. -1 indicates unlimited attempts. This field has the same meaning as [task_retry_limit in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
   * @return maxAttempts
   */
  @javax.annotation.Nullable
  public Integer getMaxAttempts() {
    return maxAttempts;
  }

  public void setMaxAttempts(Integer maxAttempts) {
    this.maxAttempts = maxAttempts;
  }


  public RetryConfig maxBackoff(String maxBackoff) {
    this.maxBackoff = maxBackoff;
    return this;
  }

  /**
   * A task will be scheduled for retry between min_backoff and max_backoff duration after it fails, if the queue&#39;s RetryConfig specifies that the task should be retried. If unspecified when the queue is created, Cloud Tasks will pick the default. The value must be given as a string that indicates the length of time (in seconds) followed by &#x60;s&#x60; (for \&quot;seconds\&quot;). For more information on the format, see the documentation for [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration). &#x60;max_backoff&#x60; will be truncated to the nearest second. This field has the same meaning as [max_backoff_seconds in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
   * @return maxBackoff
   */
  @javax.annotation.Nullable
  public String getMaxBackoff() {
    return maxBackoff;
  }

  public void setMaxBackoff(String maxBackoff) {
    this.maxBackoff = maxBackoff;
  }


  public RetryConfig maxDoublings(Integer maxDoublings) {
    this.maxDoublings = maxDoublings;
    return this;
  }

  /**
   * The time between retries will double &#x60;max_doublings&#x60; times. A task&#39;s retry interval starts at min_backoff, then doubles &#x60;max_doublings&#x60; times, then increases linearly, and finally retries at intervals of max_backoff up to max_attempts times. For example, if min_backoff is 10s, max_backoff is 300s, and &#x60;max_doublings&#x60; is 3, then the a task will first be retried in 10s. The retry interval will double three times, and then increase linearly by 2^3 * 10s. Finally, the task will retry at intervals of max_backoff until the task has been attempted max_attempts times. Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s, 300s, .... If unspecified when the queue is created, Cloud Tasks will pick the default. This field has the same meaning as [max_doublings in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
   * @return maxDoublings
   */
  @javax.annotation.Nullable
  public Integer getMaxDoublings() {
    return maxDoublings;
  }

  public void setMaxDoublings(Integer maxDoublings) {
    this.maxDoublings = maxDoublings;
  }


  public RetryConfig maxRetryDuration(String maxRetryDuration) {
    this.maxRetryDuration = maxRetryDuration;
    return this;
  }

  /**
   * If positive, &#x60;max_retry_duration&#x60; specifies the time limit for retrying a failed task, measured from when the task was first attempted. Once &#x60;max_retry_duration&#x60; time has passed *and* the task has been attempted max_attempts times, no further attempts will be made and the task will be deleted. If zero, then the task age is unlimited. If unspecified when the queue is created, Cloud Tasks will pick the default. The value must be given as a string that indicates the length of time (in seconds) followed by &#x60;s&#x60; (for \&quot;seconds\&quot;). For the maximum possible value or the format, see the documentation for [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration). &#x60;max_retry_duration&#x60; will be truncated to the nearest second. This field has the same meaning as [task_age_limit in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
   * @return maxRetryDuration
   */
  @javax.annotation.Nullable
  public String getMaxRetryDuration() {
    return maxRetryDuration;
  }

  public void setMaxRetryDuration(String maxRetryDuration) {
    this.maxRetryDuration = maxRetryDuration;
  }


  public RetryConfig minBackoff(String minBackoff) {
    this.minBackoff = minBackoff;
    return this;
  }

  /**
   * A task will be scheduled for retry between min_backoff and max_backoff duration after it fails, if the queue&#39;s RetryConfig specifies that the task should be retried. If unspecified when the queue is created, Cloud Tasks will pick the default. The value must be given as a string that indicates the length of time (in seconds) followed by &#x60;s&#x60; (for \&quot;seconds\&quot;). For more information on the format, see the documentation for [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration). &#x60;min_backoff&#x60; will be truncated to the nearest second. This field has the same meaning as [min_backoff_seconds in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
   * @return minBackoff
   */
  @javax.annotation.Nullable
  public String getMinBackoff() {
    return minBackoff;
  }

  public void setMinBackoff(String minBackoff) {
    this.minBackoff = minBackoff;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RetryConfig retryConfig = (RetryConfig) o;
    return Objects.equals(this.maxAttempts, retryConfig.maxAttempts) &&
        Objects.equals(this.maxBackoff, retryConfig.maxBackoff) &&
        Objects.equals(this.maxDoublings, retryConfig.maxDoublings) &&
        Objects.equals(this.maxRetryDuration, retryConfig.maxRetryDuration) &&
        Objects.equals(this.minBackoff, retryConfig.minBackoff);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxAttempts, maxBackoff, maxDoublings, maxRetryDuration, minBackoff);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RetryConfig {\n");
    sb.append("    maxAttempts: ").append(toIndentedString(maxAttempts)).append("\n");
    sb.append("    maxBackoff: ").append(toIndentedString(maxBackoff)).append("\n");
    sb.append("    maxDoublings: ").append(toIndentedString(maxDoublings)).append("\n");
    sb.append("    maxRetryDuration: ").append(toIndentedString(maxRetryDuration)).append("\n");
    sb.append("    minBackoff: ").append(toIndentedString(minBackoff)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxAttempts");
    openapiFields.add("maxBackoff");
    openapiFields.add("maxDoublings");
    openapiFields.add("maxRetryDuration");
    openapiFields.add("minBackoff");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RetryConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RetryConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RetryConfig is not found in the empty JSON string", RetryConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RetryConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RetryConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("maxBackoff") != null && !jsonObj.get("maxBackoff").isJsonNull()) && !jsonObj.get("maxBackoff").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxBackoff` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxBackoff").toString()));
      }
      if ((jsonObj.get("maxRetryDuration") != null && !jsonObj.get("maxRetryDuration").isJsonNull()) && !jsonObj.get("maxRetryDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxRetryDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxRetryDuration").toString()));
      }
      if ((jsonObj.get("minBackoff") != null && !jsonObj.get("minBackoff").isJsonNull()) && !jsonObj.get("minBackoff").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minBackoff` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minBackoff").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RetryConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RetryConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RetryConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RetryConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<RetryConfig>() {
           @Override
           public void write(JsonWriter out, RetryConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RetryConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RetryConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RetryConfig
   * @throws IOException if the JSON string is invalid with respect to RetryConfig
   */
  public static RetryConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RetryConfig.class);
  }

  /**
   * Convert an instance of RetryConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

