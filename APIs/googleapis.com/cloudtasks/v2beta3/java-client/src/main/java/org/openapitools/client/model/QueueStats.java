/*
 * Cloud Tasks API
 * Manages the execution of large numbers of distributed requests.
 *
 * The version of the OpenAPI document: v2beta3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Statistics for a queue.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:08.664586-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class QueueStats {
  public static final String SERIALIZED_NAME_CONCURRENT_DISPATCHES_COUNT = "concurrentDispatchesCount";
  @SerializedName(SERIALIZED_NAME_CONCURRENT_DISPATCHES_COUNT)
  private String concurrentDispatchesCount;

  public static final String SERIALIZED_NAME_EFFECTIVE_EXECUTION_RATE = "effectiveExecutionRate";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_EXECUTION_RATE)
  private Double effectiveExecutionRate;

  public static final String SERIALIZED_NAME_EXECUTED_LAST_MINUTE_COUNT = "executedLastMinuteCount";
  @SerializedName(SERIALIZED_NAME_EXECUTED_LAST_MINUTE_COUNT)
  private String executedLastMinuteCount;

  public static final String SERIALIZED_NAME_OLDEST_ESTIMATED_ARRIVAL_TIME = "oldestEstimatedArrivalTime";
  @SerializedName(SERIALIZED_NAME_OLDEST_ESTIMATED_ARRIVAL_TIME)
  private String oldestEstimatedArrivalTime;

  public static final String SERIALIZED_NAME_TASKS_COUNT = "tasksCount";
  @SerializedName(SERIALIZED_NAME_TASKS_COUNT)
  private String tasksCount;

  public QueueStats() {
  }

  public QueueStats(
     String concurrentDispatchesCount, 
     Double effectiveExecutionRate, 
     String executedLastMinuteCount, 
     String oldestEstimatedArrivalTime, 
     String tasksCount
  ) {
    this();
    this.concurrentDispatchesCount = concurrentDispatchesCount;
    this.effectiveExecutionRate = effectiveExecutionRate;
    this.executedLastMinuteCount = executedLastMinuteCount;
    this.oldestEstimatedArrivalTime = oldestEstimatedArrivalTime;
    this.tasksCount = tasksCount;
  }

  /**
   * Output only. The number of requests that the queue has dispatched but has not received a reply for yet.
   * @return concurrentDispatchesCount
   */
  @javax.annotation.Nullable
  public String getConcurrentDispatchesCount() {
    return concurrentDispatchesCount;
  }



  /**
   * Output only. The current maximum number of tasks per second executed by the queue. The maximum value of this variable is controlled by the RateLimits of the Queue. However, this value could be less to avoid overloading the endpoints tasks in the queue are targeting.
   * @return effectiveExecutionRate
   */
  @javax.annotation.Nullable
  public Double getEffectiveExecutionRate() {
    return effectiveExecutionRate;
  }



  /**
   * Output only. The number of tasks that the queue has dispatched and received a reply for during the last minute. This variable counts both successful and non-successful executions.
   * @return executedLastMinuteCount
   */
  @javax.annotation.Nullable
  public String getExecutedLastMinuteCount() {
    return executedLastMinuteCount;
  }



  /**
   * Output only. An estimation of the nearest time in the future where a task in the queue is scheduled to be executed.
   * @return oldestEstimatedArrivalTime
   */
  @javax.annotation.Nullable
  public String getOldestEstimatedArrivalTime() {
    return oldestEstimatedArrivalTime;
  }



  /**
   * Output only. An estimation of the number of tasks in the queue, that is, the tasks in the queue that haven&#39;t been executed, the tasks in the queue which the queue has dispatched but has not yet received a reply for, and the failed tasks that the queue is retrying.
   * @return tasksCount
   */
  @javax.annotation.Nullable
  public String getTasksCount() {
    return tasksCount;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QueueStats queueStats = (QueueStats) o;
    return Objects.equals(this.concurrentDispatchesCount, queueStats.concurrentDispatchesCount) &&
        Objects.equals(this.effectiveExecutionRate, queueStats.effectiveExecutionRate) &&
        Objects.equals(this.executedLastMinuteCount, queueStats.executedLastMinuteCount) &&
        Objects.equals(this.oldestEstimatedArrivalTime, queueStats.oldestEstimatedArrivalTime) &&
        Objects.equals(this.tasksCount, queueStats.tasksCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(concurrentDispatchesCount, effectiveExecutionRate, executedLastMinuteCount, oldestEstimatedArrivalTime, tasksCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QueueStats {\n");
    sb.append("    concurrentDispatchesCount: ").append(toIndentedString(concurrentDispatchesCount)).append("\n");
    sb.append("    effectiveExecutionRate: ").append(toIndentedString(effectiveExecutionRate)).append("\n");
    sb.append("    executedLastMinuteCount: ").append(toIndentedString(executedLastMinuteCount)).append("\n");
    sb.append("    oldestEstimatedArrivalTime: ").append(toIndentedString(oldestEstimatedArrivalTime)).append("\n");
    sb.append("    tasksCount: ").append(toIndentedString(tasksCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("concurrentDispatchesCount");
    openapiFields.add("effectiveExecutionRate");
    openapiFields.add("executedLastMinuteCount");
    openapiFields.add("oldestEstimatedArrivalTime");
    openapiFields.add("tasksCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to QueueStats
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!QueueStats.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in QueueStats is not found in the empty JSON string", QueueStats.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!QueueStats.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `QueueStats` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("concurrentDispatchesCount") != null && !jsonObj.get("concurrentDispatchesCount").isJsonNull()) && !jsonObj.get("concurrentDispatchesCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `concurrentDispatchesCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("concurrentDispatchesCount").toString()));
      }
      if ((jsonObj.get("executedLastMinuteCount") != null && !jsonObj.get("executedLastMinuteCount").isJsonNull()) && !jsonObj.get("executedLastMinuteCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `executedLastMinuteCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("executedLastMinuteCount").toString()));
      }
      if ((jsonObj.get("oldestEstimatedArrivalTime") != null && !jsonObj.get("oldestEstimatedArrivalTime").isJsonNull()) && !jsonObj.get("oldestEstimatedArrivalTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `oldestEstimatedArrivalTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("oldestEstimatedArrivalTime").toString()));
      }
      if ((jsonObj.get("tasksCount") != null && !jsonObj.get("tasksCount").isJsonNull()) && !jsonObj.get("tasksCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tasksCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tasksCount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QueueStats.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QueueStats' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QueueStats> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QueueStats.class));

       return (TypeAdapter<T>) new TypeAdapter<QueueStats>() {
           @Override
           public void write(JsonWriter out, QueueStats value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public QueueStats read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of QueueStats given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of QueueStats
   * @throws IOException if the JSON string is invalid with respect to QueueStats
   */
  public static QueueStats fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QueueStats.class);
  }

  /**
   * Convert an instance of QueueStats to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

