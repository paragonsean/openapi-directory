/*
 * Cloud Tasks API
 * Manages the execution of large numbers of distributed requests.
 *
 * The version of the OpenAPI document: v2beta3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AppEngineHttpQueue;
import org.openapitools.client.model.HttpTarget;
import org.openapitools.client.model.QueueStats;
import org.openapitools.client.model.RateLimits;
import org.openapitools.client.model.RetryConfig;
import org.openapitools.client.model.StackdriverLoggingConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A queue is a container of related tasks. Queues are configured to manage how those tasks are dispatched. Configurable properties include rate limits, retry options, queue types, and others.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:08.664586-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Queue {
  public static final String SERIALIZED_NAME_APP_ENGINE_HTTP_QUEUE = "appEngineHttpQueue";
  @SerializedName(SERIALIZED_NAME_APP_ENGINE_HTTP_QUEUE)
  private AppEngineHttpQueue appEngineHttpQueue;

  public static final String SERIALIZED_NAME_HTTP_TARGET = "httpTarget";
  @SerializedName(SERIALIZED_NAME_HTTP_TARGET)
  private HttpTarget httpTarget;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PURGE_TIME = "purgeTime";
  @SerializedName(SERIALIZED_NAME_PURGE_TIME)
  private String purgeTime;

  public static final String SERIALIZED_NAME_RATE_LIMITS = "rateLimits";
  @SerializedName(SERIALIZED_NAME_RATE_LIMITS)
  private RateLimits rateLimits;

  public static final String SERIALIZED_NAME_RETRY_CONFIG = "retryConfig";
  @SerializedName(SERIALIZED_NAME_RETRY_CONFIG)
  private RetryConfig retryConfig;

  public static final String SERIALIZED_NAME_STACKDRIVER_LOGGING_CONFIG = "stackdriverLoggingConfig";
  @SerializedName(SERIALIZED_NAME_STACKDRIVER_LOGGING_CONFIG)
  private StackdriverLoggingConfig stackdriverLoggingConfig;

  /**
   * Output only. The state of the queue. &#x60;state&#x60; can only be changed by called PauseQueue, ResumeQueue, or uploading [queue.yaml/xml](https://cloud.google.com/appengine/docs/python/config/queueref). UpdateQueue cannot be used to change &#x60;state&#x60;.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    RUNNING("RUNNING"),
    
    PAUSED("PAUSED"),
    
    DISABLED("DISABLED");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_STATS = "stats";
  @SerializedName(SERIALIZED_NAME_STATS)
  private QueueStats stats;

  public static final String SERIALIZED_NAME_TASK_TTL = "taskTtl";
  @SerializedName(SERIALIZED_NAME_TASK_TTL)
  private String taskTtl;

  public static final String SERIALIZED_NAME_TOMBSTONE_TTL = "tombstoneTtl";
  @SerializedName(SERIALIZED_NAME_TOMBSTONE_TTL)
  private String tombstoneTtl;

  /**
   * Immutable. The type of a queue (push or pull). &#x60;Queue.type&#x60; is an immutable property of the queue that is set at the queue creation time. When left unspecified, the default value of &#x60;PUSH&#x60; is selected.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TYPE_UNSPECIFIED("TYPE_UNSPECIFIED"),
    
    PULL("PULL"),
    
    PUSH("PUSH");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public Queue() {
  }

  public Queue appEngineHttpQueue(AppEngineHttpQueue appEngineHttpQueue) {
    this.appEngineHttpQueue = appEngineHttpQueue;
    return this;
  }

  /**
   * Get appEngineHttpQueue
   * @return appEngineHttpQueue
   */
  @javax.annotation.Nullable
  public AppEngineHttpQueue getAppEngineHttpQueue() {
    return appEngineHttpQueue;
  }

  public void setAppEngineHttpQueue(AppEngineHttpQueue appEngineHttpQueue) {
    this.appEngineHttpQueue = appEngineHttpQueue;
  }


  public Queue httpTarget(HttpTarget httpTarget) {
    this.httpTarget = httpTarget;
    return this;
  }

  /**
   * Get httpTarget
   * @return httpTarget
   */
  @javax.annotation.Nullable
  public HttpTarget getHttpTarget() {
    return httpTarget;
  }

  public void setHttpTarget(HttpTarget httpTarget) {
    this.httpTarget = httpTarget;
  }


  public Queue name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Caller-specified and required in CreateQueue, after which it becomes output only. The queue name. The queue name must have the following format: &#x60;projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID&#x60; * &#x60;PROJECT_ID&#x60; can contain letters ([A-Za-z]), numbers ([0-9]), hyphens (-), colons (:), or periods (.). For more information, see [Identifying projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects) * &#x60;LOCATION_ID&#x60; is the canonical ID for the queue&#39;s location. The list of available locations can be obtained by calling ListLocations. For more information, see https://cloud.google.com/about/locations/. * &#x60;QUEUE_ID&#x60; can contain letters ([A-Za-z]), numbers ([0-9]), or hyphens (-). The maximum length is 100 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Queue purgeTime(String purgeTime) {
    this.purgeTime = purgeTime;
    return this;
  }

  /**
   * Output only. The last time this queue was purged. All tasks that were created before this time were purged. A queue can be purged using PurgeQueue, the [App Engine Task Queue SDK, or the Cloud Console](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/deleting-tasks-and-queues#purging_all_tasks_from_a_queue). Purge time will be truncated to the nearest microsecond. Purge time will be unset if the queue has never been purged.
   * @return purgeTime
   */
  @javax.annotation.Nullable
  public String getPurgeTime() {
    return purgeTime;
  }

  public void setPurgeTime(String purgeTime) {
    this.purgeTime = purgeTime;
  }


  public Queue rateLimits(RateLimits rateLimits) {
    this.rateLimits = rateLimits;
    return this;
  }

  /**
   * Get rateLimits
   * @return rateLimits
   */
  @javax.annotation.Nullable
  public RateLimits getRateLimits() {
    return rateLimits;
  }

  public void setRateLimits(RateLimits rateLimits) {
    this.rateLimits = rateLimits;
  }


  public Queue retryConfig(RetryConfig retryConfig) {
    this.retryConfig = retryConfig;
    return this;
  }

  /**
   * Get retryConfig
   * @return retryConfig
   */
  @javax.annotation.Nullable
  public RetryConfig getRetryConfig() {
    return retryConfig;
  }

  public void setRetryConfig(RetryConfig retryConfig) {
    this.retryConfig = retryConfig;
  }


  public Queue stackdriverLoggingConfig(StackdriverLoggingConfig stackdriverLoggingConfig) {
    this.stackdriverLoggingConfig = stackdriverLoggingConfig;
    return this;
  }

  /**
   * Get stackdriverLoggingConfig
   * @return stackdriverLoggingConfig
   */
  @javax.annotation.Nullable
  public StackdriverLoggingConfig getStackdriverLoggingConfig() {
    return stackdriverLoggingConfig;
  }

  public void setStackdriverLoggingConfig(StackdriverLoggingConfig stackdriverLoggingConfig) {
    this.stackdriverLoggingConfig = stackdriverLoggingConfig;
  }


  public Queue state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * Output only. The state of the queue. &#x60;state&#x60; can only be changed by called PauseQueue, ResumeQueue, or uploading [queue.yaml/xml](https://cloud.google.com/appengine/docs/python/config/queueref). UpdateQueue cannot be used to change &#x60;state&#x60;.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public Queue stats(QueueStats stats) {
    this.stats = stats;
    return this;
  }

  /**
   * Get stats
   * @return stats
   */
  @javax.annotation.Nullable
  public QueueStats getStats() {
    return stats;
  }

  public void setStats(QueueStats stats) {
    this.stats = stats;
  }


  public Queue taskTtl(String taskTtl) {
    this.taskTtl = taskTtl;
    return this;
  }

  /**
   * The maximum amount of time that a task will be retained in this queue. After a task has lived for &#x60;task_ttl&#x60;, the task will be deleted regardless of whether it was dispatched or not. The minimum value is 10 days. The maximum value is 10 years. The value must be given as a string that indicates the length of time (in seconds) followed by &#x60;s&#x60; (for \&quot;seconds\&quot;). For more information on the format, see the documentation for [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration). Queues created by Cloud Tasks have a default &#x60;task_ttl&#x60; of 31 days. . Queues created by queue.yaml/xml have a fixed &#x60;task_ttl&#x60; of the maximum duration, because there is a [storage quota](https://cloud.google.com/appengine/quotas#Task_Queue) for these queues.
   * @return taskTtl
   */
  @javax.annotation.Nullable
  public String getTaskTtl() {
    return taskTtl;
  }

  public void setTaskTtl(String taskTtl) {
    this.taskTtl = taskTtl;
  }


  public Queue tombstoneTtl(String tombstoneTtl) {
    this.tombstoneTtl = tombstoneTtl;
    return this;
  }

  /**
   * The task tombstone time to live (TTL). After a task is deleted or executed, the task&#39;s tombstone is retained for the length of time specified by &#x60;tombstone_ttl&#x60;. The tombstone is used by task de-duplication; another task with the same name can&#39;t be created until the tombstone has expired. For more information about task de-duplication, see the documentation for CreateTaskRequest. The minimum value is 1 hour. The maximum value is 9 days. The value must be given as a string that indicates the length of time (in seconds) followed by &#x60;s&#x60; (for \&quot;seconds\&quot;). For more information on the format, see the documentation for [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration). Queues created by Cloud Tasks have a default &#x60;tombstone_ttl&#x60; of 1 hour.
   * @return tombstoneTtl
   */
  @javax.annotation.Nullable
  public String getTombstoneTtl() {
    return tombstoneTtl;
  }

  public void setTombstoneTtl(String tombstoneTtl) {
    this.tombstoneTtl = tombstoneTtl;
  }


  public Queue type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Immutable. The type of a queue (push or pull). &#x60;Queue.type&#x60; is an immutable property of the queue that is set at the queue creation time. When left unspecified, the default value of &#x60;PUSH&#x60; is selected.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Queue queue = (Queue) o;
    return Objects.equals(this.appEngineHttpQueue, queue.appEngineHttpQueue) &&
        Objects.equals(this.httpTarget, queue.httpTarget) &&
        Objects.equals(this.name, queue.name) &&
        Objects.equals(this.purgeTime, queue.purgeTime) &&
        Objects.equals(this.rateLimits, queue.rateLimits) &&
        Objects.equals(this.retryConfig, queue.retryConfig) &&
        Objects.equals(this.stackdriverLoggingConfig, queue.stackdriverLoggingConfig) &&
        Objects.equals(this.state, queue.state) &&
        Objects.equals(this.stats, queue.stats) &&
        Objects.equals(this.taskTtl, queue.taskTtl) &&
        Objects.equals(this.tombstoneTtl, queue.tombstoneTtl) &&
        Objects.equals(this.type, queue.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appEngineHttpQueue, httpTarget, name, purgeTime, rateLimits, retryConfig, stackdriverLoggingConfig, state, stats, taskTtl, tombstoneTtl, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Queue {\n");
    sb.append("    appEngineHttpQueue: ").append(toIndentedString(appEngineHttpQueue)).append("\n");
    sb.append("    httpTarget: ").append(toIndentedString(httpTarget)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    purgeTime: ").append(toIndentedString(purgeTime)).append("\n");
    sb.append("    rateLimits: ").append(toIndentedString(rateLimits)).append("\n");
    sb.append("    retryConfig: ").append(toIndentedString(retryConfig)).append("\n");
    sb.append("    stackdriverLoggingConfig: ").append(toIndentedString(stackdriverLoggingConfig)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stats: ").append(toIndentedString(stats)).append("\n");
    sb.append("    taskTtl: ").append(toIndentedString(taskTtl)).append("\n");
    sb.append("    tombstoneTtl: ").append(toIndentedString(tombstoneTtl)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("appEngineHttpQueue");
    openapiFields.add("httpTarget");
    openapiFields.add("name");
    openapiFields.add("purgeTime");
    openapiFields.add("rateLimits");
    openapiFields.add("retryConfig");
    openapiFields.add("stackdriverLoggingConfig");
    openapiFields.add("state");
    openapiFields.add("stats");
    openapiFields.add("taskTtl");
    openapiFields.add("tombstoneTtl");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Queue
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Queue.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Queue is not found in the empty JSON string", Queue.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Queue.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Queue` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `appEngineHttpQueue`
      if (jsonObj.get("appEngineHttpQueue") != null && !jsonObj.get("appEngineHttpQueue").isJsonNull()) {
        AppEngineHttpQueue.validateJsonElement(jsonObj.get("appEngineHttpQueue"));
      }
      // validate the optional field `httpTarget`
      if (jsonObj.get("httpTarget") != null && !jsonObj.get("httpTarget").isJsonNull()) {
        HttpTarget.validateJsonElement(jsonObj.get("httpTarget"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("purgeTime") != null && !jsonObj.get("purgeTime").isJsonNull()) && !jsonObj.get("purgeTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `purgeTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("purgeTime").toString()));
      }
      // validate the optional field `rateLimits`
      if (jsonObj.get("rateLimits") != null && !jsonObj.get("rateLimits").isJsonNull()) {
        RateLimits.validateJsonElement(jsonObj.get("rateLimits"));
      }
      // validate the optional field `retryConfig`
      if (jsonObj.get("retryConfig") != null && !jsonObj.get("retryConfig").isJsonNull()) {
        RetryConfig.validateJsonElement(jsonObj.get("retryConfig"));
      }
      // validate the optional field `stackdriverLoggingConfig`
      if (jsonObj.get("stackdriverLoggingConfig") != null && !jsonObj.get("stackdriverLoggingConfig").isJsonNull()) {
        StackdriverLoggingConfig.validateJsonElement(jsonObj.get("stackdriverLoggingConfig"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      // validate the optional field `stats`
      if (jsonObj.get("stats") != null && !jsonObj.get("stats").isJsonNull()) {
        QueueStats.validateJsonElement(jsonObj.get("stats"));
      }
      if ((jsonObj.get("taskTtl") != null && !jsonObj.get("taskTtl").isJsonNull()) && !jsonObj.get("taskTtl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taskTtl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taskTtl").toString()));
      }
      if ((jsonObj.get("tombstoneTtl") != null && !jsonObj.get("tombstoneTtl").isJsonNull()) && !jsonObj.get("tombstoneTtl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tombstoneTtl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tombstoneTtl").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Queue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Queue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Queue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Queue.class));

       return (TypeAdapter<T>) new TypeAdapter<Queue>() {
           @Override
           public void write(JsonWriter out, Queue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Queue read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Queue given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Queue
   * @throws IOException if the JSON string is invalid with respect to Queue
   */
  public static Queue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Queue.class);
  }

  /**
   * Convert an instance of Queue to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

