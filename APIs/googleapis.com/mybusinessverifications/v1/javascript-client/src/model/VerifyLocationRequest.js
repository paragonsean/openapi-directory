/**
 * My Business Verifications API
 * The My Business Verifications API provides an interface for taking verifications related actions for locations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ServiceBusinessContext from './ServiceBusinessContext';
import VerificationToken from './VerificationToken';

/**
 * The VerifyLocationRequest model module.
 * @module model/VerifyLocationRequest
 * @version v1
 */
class VerifyLocationRequest {
    /**
     * Constructs a new <code>VerifyLocationRequest</code>.
     * Request message for Verifications.VerifyLocation.
     * @alias module:model/VerifyLocationRequest
     */
    constructor() { 
        
        VerifyLocationRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>VerifyLocationRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/VerifyLocationRequest} obj Optional instance to populate.
     * @return {module:model/VerifyLocationRequest} The populated <code>VerifyLocationRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new VerifyLocationRequest();

            if (data.hasOwnProperty('context')) {
                obj['context'] = ServiceBusinessContext.constructFromObject(data['context']);
            }
            if (data.hasOwnProperty('emailAddress')) {
                obj['emailAddress'] = ApiClient.convertToType(data['emailAddress'], 'String');
            }
            if (data.hasOwnProperty('languageCode')) {
                obj['languageCode'] = ApiClient.convertToType(data['languageCode'], 'String');
            }
            if (data.hasOwnProperty('mailerContact')) {
                obj['mailerContact'] = ApiClient.convertToType(data['mailerContact'], 'String');
            }
            if (data.hasOwnProperty('method')) {
                obj['method'] = ApiClient.convertToType(data['method'], 'String');
            }
            if (data.hasOwnProperty('phoneNumber')) {
                obj['phoneNumber'] = ApiClient.convertToType(data['phoneNumber'], 'String');
            }
            if (data.hasOwnProperty('token')) {
                obj['token'] = VerificationToken.constructFromObject(data['token']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>VerifyLocationRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>VerifyLocationRequest</code>.
     */
    static validateJSON(data) {
        // validate the optional field `context`
        if (data['context']) { // data not null
          ServiceBusinessContext.validateJSON(data['context']);
        }
        // ensure the json data is a string
        if (data['emailAddress'] && !(typeof data['emailAddress'] === 'string' || data['emailAddress'] instanceof String)) {
            throw new Error("Expected the field `emailAddress` to be a primitive type in the JSON string but got " + data['emailAddress']);
        }
        // ensure the json data is a string
        if (data['languageCode'] && !(typeof data['languageCode'] === 'string' || data['languageCode'] instanceof String)) {
            throw new Error("Expected the field `languageCode` to be a primitive type in the JSON string but got " + data['languageCode']);
        }
        // ensure the json data is a string
        if (data['mailerContact'] && !(typeof data['mailerContact'] === 'string' || data['mailerContact'] instanceof String)) {
            throw new Error("Expected the field `mailerContact` to be a primitive type in the JSON string but got " + data['mailerContact']);
        }
        // ensure the json data is a string
        if (data['method'] && !(typeof data['method'] === 'string' || data['method'] instanceof String)) {
            throw new Error("Expected the field `method` to be a primitive type in the JSON string but got " + data['method']);
        }
        // ensure the json data is a string
        if (data['phoneNumber'] && !(typeof data['phoneNumber'] === 'string' || data['phoneNumber'] instanceof String)) {
            throw new Error("Expected the field `phoneNumber` to be a primitive type in the JSON string but got " + data['phoneNumber']);
        }
        // validate the optional field `token`
        if (data['token']) { // data not null
          VerificationToken.validateJSON(data['token']);
        }

        return true;
    }


}



/**
 * @member {module:model/ServiceBusinessContext} context
 */
VerifyLocationRequest.prototype['context'] = undefined;

/**
 * Optional. The input for EMAIL method. Email address where the PIN should be sent to. An email address is accepted only if it is one of the addresses provided by FetchVerificationOptions. If the EmailVerificationData has is_user_name_editable set to true, the client may specify a different user name (local-part) but must match the domain name.
 * @member {String} emailAddress
 */
VerifyLocationRequest.prototype['emailAddress'] = undefined;

/**
 * Optional. The BCP 47 language code representing the language that is to be used for the verification process.
 * @member {String} languageCode
 */
VerifyLocationRequest.prototype['languageCode'] = undefined;

/**
 * Optional. The input for ADDRESS method. Contact name the mail should be sent to.
 * @member {String} mailerContact
 */
VerifyLocationRequest.prototype['mailerContact'] = undefined;

/**
 * Required. Verification method.
 * @member {module:model/VerifyLocationRequest.MethodEnum} method
 */
VerifyLocationRequest.prototype['method'] = undefined;

/**
 * Optional. The input for PHONE_CALL/SMS method The phone number that should be called or be sent SMS to. It must be one of the phone numbers in the eligible options.
 * @member {String} phoneNumber
 */
VerifyLocationRequest.prototype['phoneNumber'] = undefined;

/**
 * @member {module:model/VerificationToken} token
 */
VerifyLocationRequest.prototype['token'] = undefined;





/**
 * Allowed values for the <code>method</code> property.
 * @enum {String}
 * @readonly
 */
VerifyLocationRequest['MethodEnum'] = {

    /**
     * value: "VERIFICATION_METHOD_UNSPECIFIED"
     * @const
     */
    "VERIFICATION_METHOD_UNSPECIFIED": "VERIFICATION_METHOD_UNSPECIFIED",

    /**
     * value: "ADDRESS"
     * @const
     */
    "ADDRESS": "ADDRESS",

    /**
     * value: "EMAIL"
     * @const
     */
    "EMAIL": "EMAIL",

    /**
     * value: "PHONE_CALL"
     * @const
     */
    "PHONE_CALL": "PHONE_CALL",

    /**
     * value: "SMS"
     * @const
     */
    "SMS": "SMS",

    /**
     * value: "AUTO"
     * @const
     */
    "AUTO": "AUTO",

    /**
     * value: "VETTED_PARTNER"
     * @const
     */
    "VETTED_PARTNER": "VETTED_PARTNER"
};



export default VerifyLocationRequest;

