/*
 * Sensitive Data Protection (DLP)
 * Discover and protect your sensitive data. A fully managed service designed to help you discover, classify, and protect your valuable data assets with ease.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GooglePrivacyDlpV2CustomInfoType;
import org.openapitools.client.model.GooglePrivacyDlpV2FindingLimits;
import org.openapitools.client.model.GooglePrivacyDlpV2InfoType;
import org.openapitools.client.model.GooglePrivacyDlpV2InfoTypeLikelihood;
import org.openapitools.client.model.GooglePrivacyDlpV2InspectionRuleSet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration description of the scanning process. When used with redactContent only info_types and min_likelihood are currently used.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:39.298775-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GooglePrivacyDlpV2InspectConfig {
  /**
   * Gets or Sets contentOptions
   */
  @JsonAdapter(ContentOptionsEnum.Adapter.class)
  public enum ContentOptionsEnum {
    UNSPECIFIED("CONTENT_UNSPECIFIED"),
    
    TEXT("CONTENT_TEXT"),
    
    IMAGE("CONTENT_IMAGE");

    private String value;

    ContentOptionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContentOptionsEnum fromValue(String value) {
      for (ContentOptionsEnum b : ContentOptionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ContentOptionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentOptionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentOptionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ContentOptionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ContentOptionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONTENT_OPTIONS = "contentOptions";
  @SerializedName(SERIALIZED_NAME_CONTENT_OPTIONS)
  private List<ContentOptionsEnum> contentOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_CUSTOM_INFO_TYPES = "customInfoTypes";
  @SerializedName(SERIALIZED_NAME_CUSTOM_INFO_TYPES)
  private List<GooglePrivacyDlpV2CustomInfoType> customInfoTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDE_INFO_TYPES = "excludeInfoTypes";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_INFO_TYPES)
  private Boolean excludeInfoTypes;

  public static final String SERIALIZED_NAME_INCLUDE_QUOTE = "includeQuote";
  @SerializedName(SERIALIZED_NAME_INCLUDE_QUOTE)
  private Boolean includeQuote;

  public static final String SERIALIZED_NAME_INFO_TYPES = "infoTypes";
  @SerializedName(SERIALIZED_NAME_INFO_TYPES)
  private List<GooglePrivacyDlpV2InfoType> infoTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_LIMITS = "limits";
  @SerializedName(SERIALIZED_NAME_LIMITS)
  private GooglePrivacyDlpV2FindingLimits limits;

  /**
   * Only returns findings equal to or above this threshold. The default is POSSIBLE. In general, the highest likelihood setting yields the fewest findings in results and the lowest chance of a false positive. For more information, see [Match likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
   */
  @JsonAdapter(MinLikelihoodEnum.Adapter.class)
  public enum MinLikelihoodEnum {
    LIKELIHOOD_UNSPECIFIED("LIKELIHOOD_UNSPECIFIED"),
    
    VERY_UNLIKELY("VERY_UNLIKELY"),
    
    UNLIKELY("UNLIKELY"),
    
    POSSIBLE("POSSIBLE"),
    
    LIKELY("LIKELY"),
    
    VERY_LIKELY("VERY_LIKELY");

    private String value;

    MinLikelihoodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MinLikelihoodEnum fromValue(String value) {
      for (MinLikelihoodEnum b : MinLikelihoodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MinLikelihoodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MinLikelihoodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MinLikelihoodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MinLikelihoodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MinLikelihoodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MIN_LIKELIHOOD = "minLikelihood";
  @SerializedName(SERIALIZED_NAME_MIN_LIKELIHOOD)
  private MinLikelihoodEnum minLikelihood;

  public static final String SERIALIZED_NAME_MIN_LIKELIHOOD_PER_INFO_TYPE = "minLikelihoodPerInfoType";
  @SerializedName(SERIALIZED_NAME_MIN_LIKELIHOOD_PER_INFO_TYPE)
  private List<GooglePrivacyDlpV2InfoTypeLikelihood> minLikelihoodPerInfoType = new ArrayList<>();

  public static final String SERIALIZED_NAME_RULE_SET = "ruleSet";
  @SerializedName(SERIALIZED_NAME_RULE_SET)
  private List<GooglePrivacyDlpV2InspectionRuleSet> ruleSet = new ArrayList<>();

  public GooglePrivacyDlpV2InspectConfig() {
  }

  public GooglePrivacyDlpV2InspectConfig contentOptions(List<ContentOptionsEnum> contentOptions) {
    this.contentOptions = contentOptions;
    return this;
  }

  public GooglePrivacyDlpV2InspectConfig addContentOptionsItem(ContentOptionsEnum contentOptionsItem) {
    if (this.contentOptions == null) {
      this.contentOptions = new ArrayList<>();
    }
    this.contentOptions.add(contentOptionsItem);
    return this;
  }

  /**
   * Deprecated and unused.
   * @return contentOptions
   */
  @javax.annotation.Nullable
  public List<ContentOptionsEnum> getContentOptions() {
    return contentOptions;
  }

  public void setContentOptions(List<ContentOptionsEnum> contentOptions) {
    this.contentOptions = contentOptions;
  }


  public GooglePrivacyDlpV2InspectConfig customInfoTypes(List<GooglePrivacyDlpV2CustomInfoType> customInfoTypes) {
    this.customInfoTypes = customInfoTypes;
    return this;
  }

  public GooglePrivacyDlpV2InspectConfig addCustomInfoTypesItem(GooglePrivacyDlpV2CustomInfoType customInfoTypesItem) {
    if (this.customInfoTypes == null) {
      this.customInfoTypes = new ArrayList<>();
    }
    this.customInfoTypes.add(customInfoTypesItem);
    return this;
  }

  /**
   * CustomInfoTypes provided by the user. See https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes to learn more.
   * @return customInfoTypes
   */
  @javax.annotation.Nullable
  public List<GooglePrivacyDlpV2CustomInfoType> getCustomInfoTypes() {
    return customInfoTypes;
  }

  public void setCustomInfoTypes(List<GooglePrivacyDlpV2CustomInfoType> customInfoTypes) {
    this.customInfoTypes = customInfoTypes;
  }


  public GooglePrivacyDlpV2InspectConfig excludeInfoTypes(Boolean excludeInfoTypes) {
    this.excludeInfoTypes = excludeInfoTypes;
    return this;
  }

  /**
   * When true, excludes type information of the findings. This is not used for data profiling.
   * @return excludeInfoTypes
   */
  @javax.annotation.Nullable
  public Boolean getExcludeInfoTypes() {
    return excludeInfoTypes;
  }

  public void setExcludeInfoTypes(Boolean excludeInfoTypes) {
    this.excludeInfoTypes = excludeInfoTypes;
  }


  public GooglePrivacyDlpV2InspectConfig includeQuote(Boolean includeQuote) {
    this.includeQuote = includeQuote;
    return this;
  }

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote. This is not used for data profiling.
   * @return includeQuote
   */
  @javax.annotation.Nullable
  public Boolean getIncludeQuote() {
    return includeQuote;
  }

  public void setIncludeQuote(Boolean includeQuote) {
    this.includeQuote = includeQuote;
  }


  public GooglePrivacyDlpV2InspectConfig infoTypes(List<GooglePrivacyDlpV2InfoType> infoTypes) {
    this.infoTypes = infoTypes;
    return this;
  }

  public GooglePrivacyDlpV2InspectConfig addInfoTypesItem(GooglePrivacyDlpV2InfoType infoTypesItem) {
    if (this.infoTypes == null) {
      this.infoTypes = new ArrayList<>();
    }
    this.infoTypes.add(infoTypesItem);
    return this;
  }

  /**
   * Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose a default list of detectors to run, which may change over time. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.
   * @return infoTypes
   */
  @javax.annotation.Nullable
  public List<GooglePrivacyDlpV2InfoType> getInfoTypes() {
    return infoTypes;
  }

  public void setInfoTypes(List<GooglePrivacyDlpV2InfoType> infoTypes) {
    this.infoTypes = infoTypes;
  }


  public GooglePrivacyDlpV2InspectConfig limits(GooglePrivacyDlpV2FindingLimits limits) {
    this.limits = limits;
    return this;
  }

  /**
   * Get limits
   * @return limits
   */
  @javax.annotation.Nullable
  public GooglePrivacyDlpV2FindingLimits getLimits() {
    return limits;
  }

  public void setLimits(GooglePrivacyDlpV2FindingLimits limits) {
    this.limits = limits;
  }


  public GooglePrivacyDlpV2InspectConfig minLikelihood(MinLikelihoodEnum minLikelihood) {
    this.minLikelihood = minLikelihood;
    return this;
  }

  /**
   * Only returns findings equal to or above this threshold. The default is POSSIBLE. In general, the highest likelihood setting yields the fewest findings in results and the lowest chance of a false positive. For more information, see [Match likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
   * @return minLikelihood
   */
  @javax.annotation.Nullable
  public MinLikelihoodEnum getMinLikelihood() {
    return minLikelihood;
  }

  public void setMinLikelihood(MinLikelihoodEnum minLikelihood) {
    this.minLikelihood = minLikelihood;
  }


  public GooglePrivacyDlpV2InspectConfig minLikelihoodPerInfoType(List<GooglePrivacyDlpV2InfoTypeLikelihood> minLikelihoodPerInfoType) {
    this.minLikelihoodPerInfoType = minLikelihoodPerInfoType;
    return this;
  }

  public GooglePrivacyDlpV2InspectConfig addMinLikelihoodPerInfoTypeItem(GooglePrivacyDlpV2InfoTypeLikelihood minLikelihoodPerInfoTypeItem) {
    if (this.minLikelihoodPerInfoType == null) {
      this.minLikelihoodPerInfoType = new ArrayList<>();
    }
    this.minLikelihoodPerInfoType.add(minLikelihoodPerInfoTypeItem);
    return this;
  }

  /**
   * Minimum likelihood per infotype. For each infotype, a user can specify a minimum likelihood. The system only returns a finding if its likelihood is above this threshold. If this field is not set, the system uses the InspectConfig min_likelihood.
   * @return minLikelihoodPerInfoType
   */
  @javax.annotation.Nullable
  public List<GooglePrivacyDlpV2InfoTypeLikelihood> getMinLikelihoodPerInfoType() {
    return minLikelihoodPerInfoType;
  }

  public void setMinLikelihoodPerInfoType(List<GooglePrivacyDlpV2InfoTypeLikelihood> minLikelihoodPerInfoType) {
    this.minLikelihoodPerInfoType = minLikelihoodPerInfoType;
  }


  public GooglePrivacyDlpV2InspectConfig ruleSet(List<GooglePrivacyDlpV2InspectionRuleSet> ruleSet) {
    this.ruleSet = ruleSet;
    return this;
  }

  public GooglePrivacyDlpV2InspectConfig addRuleSetItem(GooglePrivacyDlpV2InspectionRuleSet ruleSetItem) {
    if (this.ruleSet == null) {
      this.ruleSet = new ArrayList<>();
    }
    this.ruleSet.add(ruleSetItem);
    return this;
  }

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type.
   * @return ruleSet
   */
  @javax.annotation.Nullable
  public List<GooglePrivacyDlpV2InspectionRuleSet> getRuleSet() {
    return ruleSet;
  }

  public void setRuleSet(List<GooglePrivacyDlpV2InspectionRuleSet> ruleSet) {
    this.ruleSet = ruleSet;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GooglePrivacyDlpV2InspectConfig googlePrivacyDlpV2InspectConfig = (GooglePrivacyDlpV2InspectConfig) o;
    return Objects.equals(this.contentOptions, googlePrivacyDlpV2InspectConfig.contentOptions) &&
        Objects.equals(this.customInfoTypes, googlePrivacyDlpV2InspectConfig.customInfoTypes) &&
        Objects.equals(this.excludeInfoTypes, googlePrivacyDlpV2InspectConfig.excludeInfoTypes) &&
        Objects.equals(this.includeQuote, googlePrivacyDlpV2InspectConfig.includeQuote) &&
        Objects.equals(this.infoTypes, googlePrivacyDlpV2InspectConfig.infoTypes) &&
        Objects.equals(this.limits, googlePrivacyDlpV2InspectConfig.limits) &&
        Objects.equals(this.minLikelihood, googlePrivacyDlpV2InspectConfig.minLikelihood) &&
        Objects.equals(this.minLikelihoodPerInfoType, googlePrivacyDlpV2InspectConfig.minLikelihoodPerInfoType) &&
        Objects.equals(this.ruleSet, googlePrivacyDlpV2InspectConfig.ruleSet);
  }

  @Override
  public int hashCode() {
    return Objects.hash(contentOptions, customInfoTypes, excludeInfoTypes, includeQuote, infoTypes, limits, minLikelihood, minLikelihoodPerInfoType, ruleSet);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GooglePrivacyDlpV2InspectConfig {\n");
    sb.append("    contentOptions: ").append(toIndentedString(contentOptions)).append("\n");
    sb.append("    customInfoTypes: ").append(toIndentedString(customInfoTypes)).append("\n");
    sb.append("    excludeInfoTypes: ").append(toIndentedString(excludeInfoTypes)).append("\n");
    sb.append("    includeQuote: ").append(toIndentedString(includeQuote)).append("\n");
    sb.append("    infoTypes: ").append(toIndentedString(infoTypes)).append("\n");
    sb.append("    limits: ").append(toIndentedString(limits)).append("\n");
    sb.append("    minLikelihood: ").append(toIndentedString(minLikelihood)).append("\n");
    sb.append("    minLikelihoodPerInfoType: ").append(toIndentedString(minLikelihoodPerInfoType)).append("\n");
    sb.append("    ruleSet: ").append(toIndentedString(ruleSet)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("contentOptions");
    openapiFields.add("customInfoTypes");
    openapiFields.add("excludeInfoTypes");
    openapiFields.add("includeQuote");
    openapiFields.add("infoTypes");
    openapiFields.add("limits");
    openapiFields.add("minLikelihood");
    openapiFields.add("minLikelihoodPerInfoType");
    openapiFields.add("ruleSet");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GooglePrivacyDlpV2InspectConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GooglePrivacyDlpV2InspectConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GooglePrivacyDlpV2InspectConfig is not found in the empty JSON string", GooglePrivacyDlpV2InspectConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GooglePrivacyDlpV2InspectConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GooglePrivacyDlpV2InspectConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("contentOptions") != null && !jsonObj.get("contentOptions").isJsonNull() && !jsonObj.get("contentOptions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentOptions` to be an array in the JSON string but got `%s`", jsonObj.get("contentOptions").toString()));
      }
      if (jsonObj.get("customInfoTypes") != null && !jsonObj.get("customInfoTypes").isJsonNull()) {
        JsonArray jsonArraycustomInfoTypes = jsonObj.getAsJsonArray("customInfoTypes");
        if (jsonArraycustomInfoTypes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("customInfoTypes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `customInfoTypes` to be an array in the JSON string but got `%s`", jsonObj.get("customInfoTypes").toString()));
          }

          // validate the optional field `customInfoTypes` (array)
          for (int i = 0; i < jsonArraycustomInfoTypes.size(); i++) {
            GooglePrivacyDlpV2CustomInfoType.validateJsonElement(jsonArraycustomInfoTypes.get(i));
          };
        }
      }
      if (jsonObj.get("infoTypes") != null && !jsonObj.get("infoTypes").isJsonNull()) {
        JsonArray jsonArrayinfoTypes = jsonObj.getAsJsonArray("infoTypes");
        if (jsonArrayinfoTypes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("infoTypes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `infoTypes` to be an array in the JSON string but got `%s`", jsonObj.get("infoTypes").toString()));
          }

          // validate the optional field `infoTypes` (array)
          for (int i = 0; i < jsonArrayinfoTypes.size(); i++) {
            GooglePrivacyDlpV2InfoType.validateJsonElement(jsonArrayinfoTypes.get(i));
          };
        }
      }
      // validate the optional field `limits`
      if (jsonObj.get("limits") != null && !jsonObj.get("limits").isJsonNull()) {
        GooglePrivacyDlpV2FindingLimits.validateJsonElement(jsonObj.get("limits"));
      }
      if ((jsonObj.get("minLikelihood") != null && !jsonObj.get("minLikelihood").isJsonNull()) && !jsonObj.get("minLikelihood").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minLikelihood` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minLikelihood").toString()));
      }
      // validate the optional field `minLikelihood`
      if (jsonObj.get("minLikelihood") != null && !jsonObj.get("minLikelihood").isJsonNull()) {
        MinLikelihoodEnum.validateJsonElement(jsonObj.get("minLikelihood"));
      }
      if (jsonObj.get("minLikelihoodPerInfoType") != null && !jsonObj.get("minLikelihoodPerInfoType").isJsonNull()) {
        JsonArray jsonArrayminLikelihoodPerInfoType = jsonObj.getAsJsonArray("minLikelihoodPerInfoType");
        if (jsonArrayminLikelihoodPerInfoType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("minLikelihoodPerInfoType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `minLikelihoodPerInfoType` to be an array in the JSON string but got `%s`", jsonObj.get("minLikelihoodPerInfoType").toString()));
          }

          // validate the optional field `minLikelihoodPerInfoType` (array)
          for (int i = 0; i < jsonArrayminLikelihoodPerInfoType.size(); i++) {
            GooglePrivacyDlpV2InfoTypeLikelihood.validateJsonElement(jsonArrayminLikelihoodPerInfoType.get(i));
          };
        }
      }
      if (jsonObj.get("ruleSet") != null && !jsonObj.get("ruleSet").isJsonNull()) {
        JsonArray jsonArrayruleSet = jsonObj.getAsJsonArray("ruleSet");
        if (jsonArrayruleSet != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ruleSet").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ruleSet` to be an array in the JSON string but got `%s`", jsonObj.get("ruleSet").toString()));
          }

          // validate the optional field `ruleSet` (array)
          for (int i = 0; i < jsonArrayruleSet.size(); i++) {
            GooglePrivacyDlpV2InspectionRuleSet.validateJsonElement(jsonArrayruleSet.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GooglePrivacyDlpV2InspectConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GooglePrivacyDlpV2InspectConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GooglePrivacyDlpV2InspectConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GooglePrivacyDlpV2InspectConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GooglePrivacyDlpV2InspectConfig>() {
           @Override
           public void write(JsonWriter out, GooglePrivacyDlpV2InspectConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GooglePrivacyDlpV2InspectConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GooglePrivacyDlpV2InspectConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GooglePrivacyDlpV2InspectConfig
   * @throws IOException if the JSON string is invalid with respect to GooglePrivacyDlpV2InspectConfig
   */
  public static GooglePrivacyDlpV2InspectConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GooglePrivacyDlpV2InspectConfig.class);
  }

  /**
   * Convert an instance of GooglePrivacyDlpV2InspectConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

