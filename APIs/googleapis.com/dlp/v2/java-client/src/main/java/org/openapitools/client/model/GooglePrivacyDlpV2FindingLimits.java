/*
 * Sensitive Data Protection (DLP)
 * Discover and protect your sensitive data. A fully managed service designed to help you discover, classify, and protect your valuable data assets with ease.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GooglePrivacyDlpV2InfoTypeLimit;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration to control the number of findings returned for inspection. This is not used for de-identification or data profiling. When redacting sensitive data from images, finding limits don&#39;t apply. They can cause unexpected or inconsistent results, where only some data is redacted. Don&#39;t include finding limits in RedactImage requests. Otherwise, Cloud DLP returns an error.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:39.298775-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GooglePrivacyDlpV2FindingLimits {
  public static final String SERIALIZED_NAME_MAX_FINDINGS_PER_INFO_TYPE = "maxFindingsPerInfoType";
  @SerializedName(SERIALIZED_NAME_MAX_FINDINGS_PER_INFO_TYPE)
  private List<GooglePrivacyDlpV2InfoTypeLimit> maxFindingsPerInfoType = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAX_FINDINGS_PER_ITEM = "maxFindingsPerItem";
  @SerializedName(SERIALIZED_NAME_MAX_FINDINGS_PER_ITEM)
  private Integer maxFindingsPerItem;

  public static final String SERIALIZED_NAME_MAX_FINDINGS_PER_REQUEST = "maxFindingsPerRequest";
  @SerializedName(SERIALIZED_NAME_MAX_FINDINGS_PER_REQUEST)
  private Integer maxFindingsPerRequest;

  public GooglePrivacyDlpV2FindingLimits() {
  }

  public GooglePrivacyDlpV2FindingLimits maxFindingsPerInfoType(List<GooglePrivacyDlpV2InfoTypeLimit> maxFindingsPerInfoType) {
    this.maxFindingsPerInfoType = maxFindingsPerInfoType;
    return this;
  }

  public GooglePrivacyDlpV2FindingLimits addMaxFindingsPerInfoTypeItem(GooglePrivacyDlpV2InfoTypeLimit maxFindingsPerInfoTypeItem) {
    if (this.maxFindingsPerInfoType == null) {
      this.maxFindingsPerInfoType = new ArrayList<>();
    }
    this.maxFindingsPerInfoType.add(maxFindingsPerInfoTypeItem);
    return this;
  }

  /**
   * Configuration of findings limit given for specified infoTypes.
   * @return maxFindingsPerInfoType
   */
  @javax.annotation.Nullable
  public List<GooglePrivacyDlpV2InfoTypeLimit> getMaxFindingsPerInfoType() {
    return maxFindingsPerInfoType;
  }

  public void setMaxFindingsPerInfoType(List<GooglePrivacyDlpV2InfoTypeLimit> maxFindingsPerInfoType) {
    this.maxFindingsPerInfoType = maxFindingsPerInfoType;
  }


  public GooglePrivacyDlpV2FindingLimits maxFindingsPerItem(Integer maxFindingsPerItem) {
    this.maxFindingsPerItem = maxFindingsPerItem;
    return this;
  }

  /**
   * Max number of findings that are returned for each item scanned. When set within an InspectContentRequest, this field is ignored. This value isn&#39;t a hard limit. If the number of findings for an item reaches this limit, the inspection of that item ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns for the item can be multiple times higher than this value.
   * @return maxFindingsPerItem
   */
  @javax.annotation.Nullable
  public Integer getMaxFindingsPerItem() {
    return maxFindingsPerItem;
  }

  public void setMaxFindingsPerItem(Integer maxFindingsPerItem) {
    this.maxFindingsPerItem = maxFindingsPerItem;
  }


  public GooglePrivacyDlpV2FindingLimits maxFindingsPerRequest(Integer maxFindingsPerRequest) {
    this.maxFindingsPerRequest = maxFindingsPerRequest;
    return this;
  }

  /**
   * Max number of findings that are returned per request or job. If you set this field in an InspectContentRequest, the resulting maximum value is the value that you set or 3,000, whichever is lower. This value isn&#39;t a hard limit. If an inspection reaches this limit, the inspection ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns can be multiple times higher than this value.
   * @return maxFindingsPerRequest
   */
  @javax.annotation.Nullable
  public Integer getMaxFindingsPerRequest() {
    return maxFindingsPerRequest;
  }

  public void setMaxFindingsPerRequest(Integer maxFindingsPerRequest) {
    this.maxFindingsPerRequest = maxFindingsPerRequest;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GooglePrivacyDlpV2FindingLimits googlePrivacyDlpV2FindingLimits = (GooglePrivacyDlpV2FindingLimits) o;
    return Objects.equals(this.maxFindingsPerInfoType, googlePrivacyDlpV2FindingLimits.maxFindingsPerInfoType) &&
        Objects.equals(this.maxFindingsPerItem, googlePrivacyDlpV2FindingLimits.maxFindingsPerItem) &&
        Objects.equals(this.maxFindingsPerRequest, googlePrivacyDlpV2FindingLimits.maxFindingsPerRequest);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxFindingsPerInfoType, maxFindingsPerItem, maxFindingsPerRequest);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GooglePrivacyDlpV2FindingLimits {\n");
    sb.append("    maxFindingsPerInfoType: ").append(toIndentedString(maxFindingsPerInfoType)).append("\n");
    sb.append("    maxFindingsPerItem: ").append(toIndentedString(maxFindingsPerItem)).append("\n");
    sb.append("    maxFindingsPerRequest: ").append(toIndentedString(maxFindingsPerRequest)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxFindingsPerInfoType");
    openapiFields.add("maxFindingsPerItem");
    openapiFields.add("maxFindingsPerRequest");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GooglePrivacyDlpV2FindingLimits
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GooglePrivacyDlpV2FindingLimits.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GooglePrivacyDlpV2FindingLimits is not found in the empty JSON string", GooglePrivacyDlpV2FindingLimits.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GooglePrivacyDlpV2FindingLimits.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GooglePrivacyDlpV2FindingLimits` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("maxFindingsPerInfoType") != null && !jsonObj.get("maxFindingsPerInfoType").isJsonNull()) {
        JsonArray jsonArraymaxFindingsPerInfoType = jsonObj.getAsJsonArray("maxFindingsPerInfoType");
        if (jsonArraymaxFindingsPerInfoType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("maxFindingsPerInfoType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `maxFindingsPerInfoType` to be an array in the JSON string but got `%s`", jsonObj.get("maxFindingsPerInfoType").toString()));
          }

          // validate the optional field `maxFindingsPerInfoType` (array)
          for (int i = 0; i < jsonArraymaxFindingsPerInfoType.size(); i++) {
            GooglePrivacyDlpV2InfoTypeLimit.validateJsonElement(jsonArraymaxFindingsPerInfoType.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GooglePrivacyDlpV2FindingLimits.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GooglePrivacyDlpV2FindingLimits' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GooglePrivacyDlpV2FindingLimits> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GooglePrivacyDlpV2FindingLimits.class));

       return (TypeAdapter<T>) new TypeAdapter<GooglePrivacyDlpV2FindingLimits>() {
           @Override
           public void write(JsonWriter out, GooglePrivacyDlpV2FindingLimits value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GooglePrivacyDlpV2FindingLimits read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GooglePrivacyDlpV2FindingLimits given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GooglePrivacyDlpV2FindingLimits
   * @throws IOException if the JSON string is invalid with respect to GooglePrivacyDlpV2FindingLimits
   */
  public static GooglePrivacyDlpV2FindingLimits fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GooglePrivacyDlpV2FindingLimits.class);
  }

  /**
   * Convert an instance of GooglePrivacyDlpV2FindingLimits to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

