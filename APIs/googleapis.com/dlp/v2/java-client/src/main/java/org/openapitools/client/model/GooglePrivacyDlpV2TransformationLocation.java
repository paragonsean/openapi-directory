/*
 * Sensitive Data Protection (DLP)
 * Discover and protect your sensitive data. A fully managed service designed to help you discover, classify, and protect your valuable data assets with ease.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GooglePrivacyDlpV2RecordTransformation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies the location of a transformation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:39.298775-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GooglePrivacyDlpV2TransformationLocation {
  /**
   * Information about the functionality of the container where this finding occurred, if available.
   */
  @JsonAdapter(ContainerTypeEnum.Adapter.class)
  public enum ContainerTypeEnum {
    UNKNOWN_CONTAINER("TRANSFORM_UNKNOWN_CONTAINER"),
    
    BODY("TRANSFORM_BODY"),
    
    METADATA("TRANSFORM_METADATA"),
    
    TABLE("TRANSFORM_TABLE");

    private String value;

    ContainerTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContainerTypeEnum fromValue(String value) {
      for (ContainerTypeEnum b : ContainerTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ContainerTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContainerTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContainerTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ContainerTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ContainerTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONTAINER_TYPE = "containerType";
  @SerializedName(SERIALIZED_NAME_CONTAINER_TYPE)
  private ContainerTypeEnum containerType;

  public static final String SERIALIZED_NAME_FINDING_ID = "findingId";
  @SerializedName(SERIALIZED_NAME_FINDING_ID)
  private String findingId;

  public static final String SERIALIZED_NAME_RECORD_TRANSFORMATION = "recordTransformation";
  @SerializedName(SERIALIZED_NAME_RECORD_TRANSFORMATION)
  private GooglePrivacyDlpV2RecordTransformation recordTransformation;

  public GooglePrivacyDlpV2TransformationLocation() {
  }

  public GooglePrivacyDlpV2TransformationLocation containerType(ContainerTypeEnum containerType) {
    this.containerType = containerType;
    return this;
  }

  /**
   * Information about the functionality of the container where this finding occurred, if available.
   * @return containerType
   */
  @javax.annotation.Nullable
  public ContainerTypeEnum getContainerType() {
    return containerType;
  }

  public void setContainerType(ContainerTypeEnum containerType) {
    this.containerType = containerType;
  }


  public GooglePrivacyDlpV2TransformationLocation findingId(String findingId) {
    this.findingId = findingId;
    return this;
  }

  /**
   * For infotype transformations, link to the corresponding findings ID so that location information does not need to be duplicated. Each findings ID correlates to an entry in the findings output table, this table only gets created when users specify to save findings (add the save findings action to the request).
   * @return findingId
   */
  @javax.annotation.Nullable
  public String getFindingId() {
    return findingId;
  }

  public void setFindingId(String findingId) {
    this.findingId = findingId;
  }


  public GooglePrivacyDlpV2TransformationLocation recordTransformation(GooglePrivacyDlpV2RecordTransformation recordTransformation) {
    this.recordTransformation = recordTransformation;
    return this;
  }

  /**
   * Get recordTransformation
   * @return recordTransformation
   */
  @javax.annotation.Nullable
  public GooglePrivacyDlpV2RecordTransformation getRecordTransformation() {
    return recordTransformation;
  }

  public void setRecordTransformation(GooglePrivacyDlpV2RecordTransformation recordTransformation) {
    this.recordTransformation = recordTransformation;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GooglePrivacyDlpV2TransformationLocation googlePrivacyDlpV2TransformationLocation = (GooglePrivacyDlpV2TransformationLocation) o;
    return Objects.equals(this.containerType, googlePrivacyDlpV2TransformationLocation.containerType) &&
        Objects.equals(this.findingId, googlePrivacyDlpV2TransformationLocation.findingId) &&
        Objects.equals(this.recordTransformation, googlePrivacyDlpV2TransformationLocation.recordTransformation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(containerType, findingId, recordTransformation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GooglePrivacyDlpV2TransformationLocation {\n");
    sb.append("    containerType: ").append(toIndentedString(containerType)).append("\n");
    sb.append("    findingId: ").append(toIndentedString(findingId)).append("\n");
    sb.append("    recordTransformation: ").append(toIndentedString(recordTransformation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("containerType");
    openapiFields.add("findingId");
    openapiFields.add("recordTransformation");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GooglePrivacyDlpV2TransformationLocation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GooglePrivacyDlpV2TransformationLocation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GooglePrivacyDlpV2TransformationLocation is not found in the empty JSON string", GooglePrivacyDlpV2TransformationLocation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GooglePrivacyDlpV2TransformationLocation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GooglePrivacyDlpV2TransformationLocation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("containerType") != null && !jsonObj.get("containerType").isJsonNull()) && !jsonObj.get("containerType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("containerType").toString()));
      }
      // validate the optional field `containerType`
      if (jsonObj.get("containerType") != null && !jsonObj.get("containerType").isJsonNull()) {
        ContainerTypeEnum.validateJsonElement(jsonObj.get("containerType"));
      }
      if ((jsonObj.get("findingId") != null && !jsonObj.get("findingId").isJsonNull()) && !jsonObj.get("findingId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `findingId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("findingId").toString()));
      }
      // validate the optional field `recordTransformation`
      if (jsonObj.get("recordTransformation") != null && !jsonObj.get("recordTransformation").isJsonNull()) {
        GooglePrivacyDlpV2RecordTransformation.validateJsonElement(jsonObj.get("recordTransformation"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GooglePrivacyDlpV2TransformationLocation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GooglePrivacyDlpV2TransformationLocation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GooglePrivacyDlpV2TransformationLocation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GooglePrivacyDlpV2TransformationLocation.class));

       return (TypeAdapter<T>) new TypeAdapter<GooglePrivacyDlpV2TransformationLocation>() {
           @Override
           public void write(JsonWriter out, GooglePrivacyDlpV2TransformationLocation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GooglePrivacyDlpV2TransformationLocation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GooglePrivacyDlpV2TransformationLocation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GooglePrivacyDlpV2TransformationLocation
   * @throws IOException if the JSON string is invalid with respect to GooglePrivacyDlpV2TransformationLocation
   */
  public static GooglePrivacyDlpV2TransformationLocation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GooglePrivacyDlpV2TransformationLocation.class);
  }

  /**
   * Convert an instance of GooglePrivacyDlpV2TransformationLocation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

