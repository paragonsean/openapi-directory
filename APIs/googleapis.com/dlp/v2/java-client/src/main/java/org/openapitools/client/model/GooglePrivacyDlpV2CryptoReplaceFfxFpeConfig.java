/*
 * Sensitive Data Protection (DLP)
 * Discover and protect your sensitive data. A fully managed service designed to help you discover, classify, and protect your valuable data assets with ease.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GooglePrivacyDlpV2CryptoKey;
import org.openapitools.client.model.GooglePrivacyDlpV2FieldId;
import org.openapitools.client.model.GooglePrivacyDlpV2InfoType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the &#x60;ReidentifyContent&#x60; API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/sensitive-data-protection/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:39.298775-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets.
   */
  @JsonAdapter(CommonAlphabetEnum.Adapter.class)
  public enum CommonAlphabetEnum {
    FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED("FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED"),
    
    NUMERIC("NUMERIC"),
    
    HEXADECIMAL("HEXADECIMAL"),
    
    UPPER_CASE_ALPHA_NUMERIC("UPPER_CASE_ALPHA_NUMERIC"),
    
    ALPHA_NUMERIC("ALPHA_NUMERIC");

    private String value;

    CommonAlphabetEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CommonAlphabetEnum fromValue(String value) {
      for (CommonAlphabetEnum b : CommonAlphabetEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CommonAlphabetEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CommonAlphabetEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CommonAlphabetEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CommonAlphabetEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CommonAlphabetEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMMON_ALPHABET = "commonAlphabet";
  @SerializedName(SERIALIZED_NAME_COMMON_ALPHABET)
  private CommonAlphabetEnum commonAlphabet;

  public static final String SERIALIZED_NAME_CONTEXT = "context";
  @SerializedName(SERIALIZED_NAME_CONTEXT)
  private GooglePrivacyDlpV2FieldId context;

  public static final String SERIALIZED_NAME_CRYPTO_KEY = "cryptoKey";
  @SerializedName(SERIALIZED_NAME_CRYPTO_KEY)
  private GooglePrivacyDlpV2CryptoKey cryptoKey;

  public static final String SERIALIZED_NAME_CUSTOM_ALPHABET = "customAlphabet";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ALPHABET)
  private String customAlphabet;

  public static final String SERIALIZED_NAME_RADIX = "radix";
  @SerializedName(SERIALIZED_NAME_RADIX)
  private Integer radix;

  public static final String SERIALIZED_NAME_SURROGATE_INFO_TYPE = "surrogateInfoType";
  @SerializedName(SERIALIZED_NAME_SURROGATE_INFO_TYPE)
  private GooglePrivacyDlpV2InfoType surrogateInfoType;

  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig() {
  }

  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig commonAlphabet(CommonAlphabetEnum commonAlphabet) {
    this.commonAlphabet = commonAlphabet;
    return this;
  }

  /**
   * Common alphabets.
   * @return commonAlphabet
   */
  @javax.annotation.Nullable
  public CommonAlphabetEnum getCommonAlphabet() {
    return commonAlphabet;
  }

  public void setCommonAlphabet(CommonAlphabetEnum commonAlphabet) {
    this.commonAlphabet = commonAlphabet;
  }


  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig context(GooglePrivacyDlpV2FieldId context) {
    this.context = context;
    return this;
  }

  /**
   * Get context
   * @return context
   */
  @javax.annotation.Nullable
  public GooglePrivacyDlpV2FieldId getContext() {
    return context;
  }

  public void setContext(GooglePrivacyDlpV2FieldId context) {
    this.context = context;
  }


  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig cryptoKey(GooglePrivacyDlpV2CryptoKey cryptoKey) {
    this.cryptoKey = cryptoKey;
    return this;
  }

  /**
   * Get cryptoKey
   * @return cryptoKey
   */
  @javax.annotation.Nullable
  public GooglePrivacyDlpV2CryptoKey getCryptoKey() {
    return cryptoKey;
  }

  public void setCryptoKey(GooglePrivacyDlpV2CryptoKey cryptoKey) {
    this.cryptoKey = cryptoKey;
  }


  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig customAlphabet(String customAlphabet) {
    this.customAlphabet = customAlphabet;
    return this;
  }

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~&#x60;!@#$%^&amp;*()_-+&#x3D;{[}]|\\:;\&quot;&#39;&lt;,&gt;.?/
   * @return customAlphabet
   */
  @javax.annotation.Nullable
  public String getCustomAlphabet() {
    return customAlphabet;
  }

  public void setCustomAlphabet(String customAlphabet) {
    this.customAlphabet = customAlphabet;
  }


  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig radix(Integer radix) {
    this.radix = radix;
    return this;
  }

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   * @return radix
   */
  @javax.annotation.Nullable
  public Integer getRadix() {
    return radix;
  }

  public void setRadix(Integer radix) {
    this.radix = radix;
  }


  public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig surrogateInfoType(GooglePrivacyDlpV2InfoType surrogateInfoType) {
    this.surrogateInfoType = surrogateInfoType;
    return this;
  }

  /**
   * Get surrogateInfoType
   * @return surrogateInfoType
   */
  @javax.annotation.Nullable
  public GooglePrivacyDlpV2InfoType getSurrogateInfoType() {
    return surrogateInfoType;
  }

  public void setSurrogateInfoType(GooglePrivacyDlpV2InfoType surrogateInfoType) {
    this.surrogateInfoType = surrogateInfoType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig googlePrivacyDlpV2CryptoReplaceFfxFpeConfig = (GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig) o;
    return Objects.equals(this.commonAlphabet, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.commonAlphabet) &&
        Objects.equals(this.context, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.context) &&
        Objects.equals(this.cryptoKey, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.cryptoKey) &&
        Objects.equals(this.customAlphabet, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.customAlphabet) &&
        Objects.equals(this.radix, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.radix) &&
        Objects.equals(this.surrogateInfoType, googlePrivacyDlpV2CryptoReplaceFfxFpeConfig.surrogateInfoType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(commonAlphabet, context, cryptoKey, customAlphabet, radix, surrogateInfoType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig {\n");
    sb.append("    commonAlphabet: ").append(toIndentedString(commonAlphabet)).append("\n");
    sb.append("    context: ").append(toIndentedString(context)).append("\n");
    sb.append("    cryptoKey: ").append(toIndentedString(cryptoKey)).append("\n");
    sb.append("    customAlphabet: ").append(toIndentedString(customAlphabet)).append("\n");
    sb.append("    radix: ").append(toIndentedString(radix)).append("\n");
    sb.append("    surrogateInfoType: ").append(toIndentedString(surrogateInfoType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("commonAlphabet");
    openapiFields.add("context");
    openapiFields.add("cryptoKey");
    openapiFields.add("customAlphabet");
    openapiFields.add("radix");
    openapiFields.add("surrogateInfoType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig is not found in the empty JSON string", GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("commonAlphabet") != null && !jsonObj.get("commonAlphabet").isJsonNull()) && !jsonObj.get("commonAlphabet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commonAlphabet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commonAlphabet").toString()));
      }
      // validate the optional field `commonAlphabet`
      if (jsonObj.get("commonAlphabet") != null && !jsonObj.get("commonAlphabet").isJsonNull()) {
        CommonAlphabetEnum.validateJsonElement(jsonObj.get("commonAlphabet"));
      }
      // validate the optional field `context`
      if (jsonObj.get("context") != null && !jsonObj.get("context").isJsonNull()) {
        GooglePrivacyDlpV2FieldId.validateJsonElement(jsonObj.get("context"));
      }
      // validate the optional field `cryptoKey`
      if (jsonObj.get("cryptoKey") != null && !jsonObj.get("cryptoKey").isJsonNull()) {
        GooglePrivacyDlpV2CryptoKey.validateJsonElement(jsonObj.get("cryptoKey"));
      }
      if ((jsonObj.get("customAlphabet") != null && !jsonObj.get("customAlphabet").isJsonNull()) && !jsonObj.get("customAlphabet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customAlphabet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customAlphabet").toString()));
      }
      // validate the optional field `surrogateInfoType`
      if (jsonObj.get("surrogateInfoType") != null && !jsonObj.get("surrogateInfoType").isJsonNull()) {
        GooglePrivacyDlpV2InfoType.validateJsonElement(jsonObj.get("surrogateInfoType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig>() {
           @Override
           public void write(JsonWriter out, GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig
   * @throws IOException if the JSON string is invalid with respect to GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig
   */
  public static GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig.class);
  }

  /**
   * Convert an instance of GooglePrivacyDlpV2CryptoReplaceFfxFpeConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

