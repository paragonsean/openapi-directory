/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig;
import org.openapitools.client.model.GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig;
import org.openapitools.client.model.GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity;
import org.openapitools.client.model.GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation;
import org.openapitools.client.model.GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:30.041358-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs {
  public static final String SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS = "additionalExperiments";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_EXPERIMENTS)
  private List<String> additionalExperiments = new ArrayList<>();

  public static final String SERIALIZED_NAME_AVAILABLE_AT_FORECAST_COLUMNS = "availableAtForecastColumns";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_AT_FORECAST_COLUMNS)
  private List<String> availableAtForecastColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTEXT_WINDOW = "contextWindow";
  @SerializedName(SERIALIZED_NAME_CONTEXT_WINDOW)
  private String contextWindow;

  public static final String SERIALIZED_NAME_DATA_GRANULARITY = "dataGranularity";
  @SerializedName(SERIALIZED_NAME_DATA_GRANULARITY)
  private GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity dataGranularity;

  public static final String SERIALIZED_NAME_EXPORT_EVALUATED_DATA_ITEMS_CONFIG = "exportEvaluatedDataItemsConfig";
  @SerializedName(SERIALIZED_NAME_EXPORT_EVALUATED_DATA_ITEMS_CONFIG)
  private GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig exportEvaluatedDataItemsConfig;

  public static final String SERIALIZED_NAME_FORECAST_HORIZON = "forecastHorizon";
  @SerializedName(SERIALIZED_NAME_FORECAST_HORIZON)
  private String forecastHorizon;

  public static final String SERIALIZED_NAME_HIERARCHY_CONFIG = "hierarchyConfig";
  @SerializedName(SERIALIZED_NAME_HIERARCHY_CONFIG)
  private GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig hierarchyConfig;

  public static final String SERIALIZED_NAME_HOLIDAY_REGIONS = "holidayRegions";
  @SerializedName(SERIALIZED_NAME_HOLIDAY_REGIONS)
  private List<String> holidayRegions = new ArrayList<>();

  public static final String SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE = "optimizationObjective";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE)
  private String optimizationObjective;

  public static final String SERIALIZED_NAME_QUANTILES = "quantiles";
  @SerializedName(SERIALIZED_NAME_QUANTILES)
  private List<Double> quantiles = new ArrayList<>();

  public static final String SERIALIZED_NAME_TARGET_COLUMN = "targetColumn";
  @SerializedName(SERIALIZED_NAME_TARGET_COLUMN)
  private String targetColumn;

  public static final String SERIALIZED_NAME_TIME_COLUMN = "timeColumn";
  @SerializedName(SERIALIZED_NAME_TIME_COLUMN)
  private String timeColumn;

  public static final String SERIALIZED_NAME_TIME_SERIES_ATTRIBUTE_COLUMNS = "timeSeriesAttributeColumns";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_ATTRIBUTE_COLUMNS)
  private List<String> timeSeriesAttributeColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_TIME_SERIES_IDENTIFIER_COLUMN = "timeSeriesIdentifierColumn";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_IDENTIFIER_COLUMN)
  private String timeSeriesIdentifierColumn;

  public static final String SERIALIZED_NAME_TRAIN_BUDGET_MILLI_NODE_HOURS = "trainBudgetMilliNodeHours";
  @SerializedName(SERIALIZED_NAME_TRAIN_BUDGET_MILLI_NODE_HOURS)
  private String trainBudgetMilliNodeHours;

  public static final String SERIALIZED_NAME_TRANSFORMATIONS = "transformations";
  @SerializedName(SERIALIZED_NAME_TRANSFORMATIONS)
  private List<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation> transformations = new ArrayList<>();

  public static final String SERIALIZED_NAME_UNAVAILABLE_AT_FORECAST_COLUMNS = "unavailableAtForecastColumns";
  @SerializedName(SERIALIZED_NAME_UNAVAILABLE_AT_FORECAST_COLUMNS)
  private List<String> unavailableAtForecastColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_VALIDATION_OPTIONS = "validationOptions";
  @SerializedName(SERIALIZED_NAME_VALIDATION_OPTIONS)
  private String validationOptions;

  public static final String SERIALIZED_NAME_WEIGHT_COLUMN = "weightColumn";
  @SerializedName(SERIALIZED_NAME_WEIGHT_COLUMN)
  private String weightColumn;

  public static final String SERIALIZED_NAME_WINDOW_CONFIG = "windowConfig";
  @SerializedName(SERIALIZED_NAME_WINDOW_CONFIG)
  private GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig windowConfig;

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs() {
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs additionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addAdditionalExperimentsItem(String additionalExperimentsItem) {
    if (this.additionalExperiments == null) {
      this.additionalExperiments = new ArrayList<>();
    }
    this.additionalExperiments.add(additionalExperimentsItem);
    return this;
  }

  /**
   * Additional experiment flags for the time series forcasting training.
   * @return additionalExperiments
   */
  @javax.annotation.Nullable
  public List<String> getAdditionalExperiments() {
    return additionalExperiments;
  }

  public void setAdditionalExperiments(List<String> additionalExperiments) {
    this.additionalExperiments = additionalExperiments;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs availableAtForecastColumns(List<String> availableAtForecastColumns) {
    this.availableAtForecastColumns = availableAtForecastColumns;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addAvailableAtForecastColumnsItem(String availableAtForecastColumnsItem) {
    if (this.availableAtForecastColumns == null) {
      this.availableAtForecastColumns = new ArrayList<>();
    }
    this.availableAtForecastColumns.add(availableAtForecastColumnsItem);
    return this;
  }

  /**
   * Names of columns that are available and provided when a forecast is requested. These columns contain information for the given entity (identified by the time_series_identifier_column column) that is known at forecast. For example, predicted weather for a specific day.
   * @return availableAtForecastColumns
   */
  @javax.annotation.Nullable
  public List<String> getAvailableAtForecastColumns() {
    return availableAtForecastColumns;
  }

  public void setAvailableAtForecastColumns(List<String> availableAtForecastColumns) {
    this.availableAtForecastColumns = availableAtForecastColumns;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs contextWindow(String contextWindow) {
    this.contextWindow = contextWindow;
    return this;
  }

  /**
   * The amount of time into the past training and prediction data is used for model training and prediction respectively. Expressed in number of units defined by the &#x60;data_granularity&#x60; field.
   * @return contextWindow
   */
  @javax.annotation.Nullable
  public String getContextWindow() {
    return contextWindow;
  }

  public void setContextWindow(String contextWindow) {
    this.contextWindow = contextWindow;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs dataGranularity(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity dataGranularity) {
    this.dataGranularity = dataGranularity;
    return this;
  }

  /**
   * Get dataGranularity
   * @return dataGranularity
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity getDataGranularity() {
    return dataGranularity;
  }

  public void setDataGranularity(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity dataGranularity) {
    this.dataGranularity = dataGranularity;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs exportEvaluatedDataItemsConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig exportEvaluatedDataItemsConfig) {
    this.exportEvaluatedDataItemsConfig = exportEvaluatedDataItemsConfig;
    return this;
  }

  /**
   * Get exportEvaluatedDataItemsConfig
   * @return exportEvaluatedDataItemsConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig getExportEvaluatedDataItemsConfig() {
    return exportEvaluatedDataItemsConfig;
  }

  public void setExportEvaluatedDataItemsConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig exportEvaluatedDataItemsConfig) {
    this.exportEvaluatedDataItemsConfig = exportEvaluatedDataItemsConfig;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs forecastHorizon(String forecastHorizon) {
    this.forecastHorizon = forecastHorizon;
    return this;
  }

  /**
   * The amount of time into the future for which forecasted values for the target are returned. Expressed in number of units defined by the &#x60;data_granularity&#x60; field.
   * @return forecastHorizon
   */
  @javax.annotation.Nullable
  public String getForecastHorizon() {
    return forecastHorizon;
  }

  public void setForecastHorizon(String forecastHorizon) {
    this.forecastHorizon = forecastHorizon;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs hierarchyConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig hierarchyConfig) {
    this.hierarchyConfig = hierarchyConfig;
    return this;
  }

  /**
   * Get hierarchyConfig
   * @return hierarchyConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig getHierarchyConfig() {
    return hierarchyConfig;
  }

  public void setHierarchyConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig hierarchyConfig) {
    this.hierarchyConfig = hierarchyConfig;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs holidayRegions(List<String> holidayRegions) {
    this.holidayRegions = holidayRegions;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addHolidayRegionsItem(String holidayRegionsItem) {
    if (this.holidayRegions == null) {
      this.holidayRegions = new ArrayList<>();
    }
    this.holidayRegions.add(holidayRegionsItem);
    return this;
  }

  /**
   * The geographical region based on which the holiday effect is applied in modeling by adding holiday categorical array feature that include all holidays matching the date. This option only allowed when data_granularity is day. By default, holiday effect modeling is disabled. To turn it on, specify the holiday region using this option.
   * @return holidayRegions
   */
  @javax.annotation.Nullable
  public List<String> getHolidayRegions() {
    return holidayRegions;
  }

  public void setHolidayRegions(List<String> holidayRegions) {
    this.holidayRegions = holidayRegions;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs optimizationObjective(String optimizationObjective) {
    this.optimizationObjective = optimizationObjective;
    return this;
  }

  /**
   * Objective function the model is optimizing towards. The training process creates a model that optimizes the value of the objective function over the validation set. The supported optimization objectives: * \&quot;minimize-rmse\&quot; (default) - Minimize root-mean-squared error (RMSE). * \&quot;minimize-mae\&quot; - Minimize mean-absolute error (MAE). * \&quot;minimize-rmsle\&quot; - Minimize root-mean-squared log error (RMSLE). * \&quot;minimize-rmspe\&quot; - Minimize root-mean-squared percentage error (RMSPE). * \&quot;minimize-wape-mae\&quot; - Minimize the combination of weighted absolute percentage error (WAPE) and mean-absolute-error (MAE). * \&quot;minimize-quantile-loss\&quot; - Minimize the quantile loss at the quantiles defined in &#x60;quantiles&#x60;. * \&quot;minimize-mape\&quot; - Minimize the mean absolute percentage error.
   * @return optimizationObjective
   */
  @javax.annotation.Nullable
  public String getOptimizationObjective() {
    return optimizationObjective;
  }

  public void setOptimizationObjective(String optimizationObjective) {
    this.optimizationObjective = optimizationObjective;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs quantiles(List<Double> quantiles) {
    this.quantiles = quantiles;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addQuantilesItem(Double quantilesItem) {
    if (this.quantiles == null) {
      this.quantiles = new ArrayList<>();
    }
    this.quantiles.add(quantilesItem);
    return this;
  }

  /**
   * Quantiles to use for minimize-quantile-loss &#x60;optimization_objective&#x60;. Up to 5 quantiles are allowed of values between 0 and 1, exclusive. Required if the value of optimization_objective is minimize-quantile-loss. Represents the percent quantiles to use for that objective. Quantiles must be unique.
   * @return quantiles
   */
  @javax.annotation.Nullable
  public List<Double> getQuantiles() {
    return quantiles;
  }

  public void setQuantiles(List<Double> quantiles) {
    this.quantiles = quantiles;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs targetColumn(String targetColumn) {
    this.targetColumn = targetColumn;
    return this;
  }

  /**
   * The name of the column that the Model is to predict values for. This column must be unavailable at forecast.
   * @return targetColumn
   */
  @javax.annotation.Nullable
  public String getTargetColumn() {
    return targetColumn;
  }

  public void setTargetColumn(String targetColumn) {
    this.targetColumn = targetColumn;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs timeColumn(String timeColumn) {
    this.timeColumn = timeColumn;
    return this;
  }

  /**
   * The name of the column that identifies time order in the time series. This column must be available at forecast.
   * @return timeColumn
   */
  @javax.annotation.Nullable
  public String getTimeColumn() {
    return timeColumn;
  }

  public void setTimeColumn(String timeColumn) {
    this.timeColumn = timeColumn;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs timeSeriesAttributeColumns(List<String> timeSeriesAttributeColumns) {
    this.timeSeriesAttributeColumns = timeSeriesAttributeColumns;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addTimeSeriesAttributeColumnsItem(String timeSeriesAttributeColumnsItem) {
    if (this.timeSeriesAttributeColumns == null) {
      this.timeSeriesAttributeColumns = new ArrayList<>();
    }
    this.timeSeriesAttributeColumns.add(timeSeriesAttributeColumnsItem);
    return this;
  }

  /**
   * Column names that should be used as attribute columns. The value of these columns does not vary as a function of time. For example, store ID or item color.
   * @return timeSeriesAttributeColumns
   */
  @javax.annotation.Nullable
  public List<String> getTimeSeriesAttributeColumns() {
    return timeSeriesAttributeColumns;
  }

  public void setTimeSeriesAttributeColumns(List<String> timeSeriesAttributeColumns) {
    this.timeSeriesAttributeColumns = timeSeriesAttributeColumns;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs timeSeriesIdentifierColumn(String timeSeriesIdentifierColumn) {
    this.timeSeriesIdentifierColumn = timeSeriesIdentifierColumn;
    return this;
  }

  /**
   * The name of the column that identifies the time series.
   * @return timeSeriesIdentifierColumn
   */
  @javax.annotation.Nullable
  public String getTimeSeriesIdentifierColumn() {
    return timeSeriesIdentifierColumn;
  }

  public void setTimeSeriesIdentifierColumn(String timeSeriesIdentifierColumn) {
    this.timeSeriesIdentifierColumn = timeSeriesIdentifierColumn;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs trainBudgetMilliNodeHours(String trainBudgetMilliNodeHours) {
    this.trainBudgetMilliNodeHours = trainBudgetMilliNodeHours;
    return this;
  }

  /**
   * Required. The train budget of creating this model, expressed in milli node hours i.e. 1,000 value in this field means 1 node hour. The training cost of the model will not exceed this budget. The final cost will be attempted to be close to the budget, though may end up being (even) noticeably smaller - at the backend&#39;s discretion. This especially may happen when further model training ceases to provide any improvements. If the budget is set to a value known to be insufficient to train a model for the given dataset, the training won&#39;t be attempted and will error. The train budget must be between 1,000 and 72,000 milli node hours, inclusive.
   * @return trainBudgetMilliNodeHours
   */
  @javax.annotation.Nullable
  public String getTrainBudgetMilliNodeHours() {
    return trainBudgetMilliNodeHours;
  }

  public void setTrainBudgetMilliNodeHours(String trainBudgetMilliNodeHours) {
    this.trainBudgetMilliNodeHours = trainBudgetMilliNodeHours;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs transformations(List<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation> transformations) {
    this.transformations = transformations;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addTransformationsItem(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation transformationsItem) {
    if (this.transformations == null) {
      this.transformations = new ArrayList<>();
    }
    this.transformations.add(transformationsItem);
    return this;
  }

  /**
   * Each transformation will apply transform function to given input column. And the result will be used for training. When creating transformation for BigQuery Struct column, the column should be flattened using \&quot;.\&quot; as the delimiter.
   * @return transformations
   */
  @javax.annotation.Nullable
  public List<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation> getTransformations() {
    return transformations;
  }

  public void setTransformations(List<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation> transformations) {
    this.transformations = transformations;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs unavailableAtForecastColumns(List<String> unavailableAtForecastColumns) {
    this.unavailableAtForecastColumns = unavailableAtForecastColumns;
    return this;
  }

  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs addUnavailableAtForecastColumnsItem(String unavailableAtForecastColumnsItem) {
    if (this.unavailableAtForecastColumns == null) {
      this.unavailableAtForecastColumns = new ArrayList<>();
    }
    this.unavailableAtForecastColumns.add(unavailableAtForecastColumnsItem);
    return this;
  }

  /**
   * Names of columns that are unavailable when a forecast is requested. This column contains information for the given entity (identified by the time_series_identifier_column) that is unknown before the forecast For example, actual weather on a given day.
   * @return unavailableAtForecastColumns
   */
  @javax.annotation.Nullable
  public List<String> getUnavailableAtForecastColumns() {
    return unavailableAtForecastColumns;
  }

  public void setUnavailableAtForecastColumns(List<String> unavailableAtForecastColumns) {
    this.unavailableAtForecastColumns = unavailableAtForecastColumns;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs validationOptions(String validationOptions) {
    this.validationOptions = validationOptions;
    return this;
  }

  /**
   * Validation options for the data validation component. The available options are: * \&quot;fail-pipeline\&quot; - default, will validate against the validation and fail the pipeline if it fails. * \&quot;ignore-validation\&quot; - ignore the results of the validation and continue
   * @return validationOptions
   */
  @javax.annotation.Nullable
  public String getValidationOptions() {
    return validationOptions;
  }

  public void setValidationOptions(String validationOptions) {
    this.validationOptions = validationOptions;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs weightColumn(String weightColumn) {
    this.weightColumn = weightColumn;
    return this;
  }

  /**
   * Column name that should be used as the weight column. Higher values in this column give more importance to the row during model training. The column must have numeric values between 0 and 10000 inclusively; 0 means the row is ignored for training. If weight column field is not set, then all rows are assumed to have equal weight of 1. This column must be available at forecast.
   * @return weightColumn
   */
  @javax.annotation.Nullable
  public String getWeightColumn() {
    return weightColumn;
  }

  public void setWeightColumn(String weightColumn) {
    this.weightColumn = weightColumn;
  }


  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs windowConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig windowConfig) {
    this.windowConfig = windowConfig;
    return this;
  }

  /**
   * Get windowConfig
   * @return windowConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig getWindowConfig() {
    return windowConfig;
  }

  public void setWindowConfig(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig windowConfig) {
    this.windowConfig = windowConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs = (GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs) o;
    return Objects.equals(this.additionalExperiments, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.additionalExperiments) &&
        Objects.equals(this.availableAtForecastColumns, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.availableAtForecastColumns) &&
        Objects.equals(this.contextWindow, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.contextWindow) &&
        Objects.equals(this.dataGranularity, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.dataGranularity) &&
        Objects.equals(this.exportEvaluatedDataItemsConfig, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.exportEvaluatedDataItemsConfig) &&
        Objects.equals(this.forecastHorizon, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.forecastHorizon) &&
        Objects.equals(this.hierarchyConfig, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.hierarchyConfig) &&
        Objects.equals(this.holidayRegions, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.holidayRegions) &&
        Objects.equals(this.optimizationObjective, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.optimizationObjective) &&
        Objects.equals(this.quantiles, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.quantiles) &&
        Objects.equals(this.targetColumn, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.targetColumn) &&
        Objects.equals(this.timeColumn, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.timeColumn) &&
        Objects.equals(this.timeSeriesAttributeColumns, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.timeSeriesAttributeColumns) &&
        Objects.equals(this.timeSeriesIdentifierColumn, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.timeSeriesIdentifierColumn) &&
        Objects.equals(this.trainBudgetMilliNodeHours, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.trainBudgetMilliNodeHours) &&
        Objects.equals(this.transformations, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.transformations) &&
        Objects.equals(this.unavailableAtForecastColumns, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.unavailableAtForecastColumns) &&
        Objects.equals(this.validationOptions, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.validationOptions) &&
        Objects.equals(this.weightColumn, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.weightColumn) &&
        Objects.equals(this.windowConfig, googleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.windowConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalExperiments, availableAtForecastColumns, contextWindow, dataGranularity, exportEvaluatedDataItemsConfig, forecastHorizon, hierarchyConfig, holidayRegions, optimizationObjective, quantiles, targetColumn, timeColumn, timeSeriesAttributeColumns, timeSeriesIdentifierColumn, trainBudgetMilliNodeHours, transformations, unavailableAtForecastColumns, validationOptions, weightColumn, windowConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs {\n");
    sb.append("    additionalExperiments: ").append(toIndentedString(additionalExperiments)).append("\n");
    sb.append("    availableAtForecastColumns: ").append(toIndentedString(availableAtForecastColumns)).append("\n");
    sb.append("    contextWindow: ").append(toIndentedString(contextWindow)).append("\n");
    sb.append("    dataGranularity: ").append(toIndentedString(dataGranularity)).append("\n");
    sb.append("    exportEvaluatedDataItemsConfig: ").append(toIndentedString(exportEvaluatedDataItemsConfig)).append("\n");
    sb.append("    forecastHorizon: ").append(toIndentedString(forecastHorizon)).append("\n");
    sb.append("    hierarchyConfig: ").append(toIndentedString(hierarchyConfig)).append("\n");
    sb.append("    holidayRegions: ").append(toIndentedString(holidayRegions)).append("\n");
    sb.append("    optimizationObjective: ").append(toIndentedString(optimizationObjective)).append("\n");
    sb.append("    quantiles: ").append(toIndentedString(quantiles)).append("\n");
    sb.append("    targetColumn: ").append(toIndentedString(targetColumn)).append("\n");
    sb.append("    timeColumn: ").append(toIndentedString(timeColumn)).append("\n");
    sb.append("    timeSeriesAttributeColumns: ").append(toIndentedString(timeSeriesAttributeColumns)).append("\n");
    sb.append("    timeSeriesIdentifierColumn: ").append(toIndentedString(timeSeriesIdentifierColumn)).append("\n");
    sb.append("    trainBudgetMilliNodeHours: ").append(toIndentedString(trainBudgetMilliNodeHours)).append("\n");
    sb.append("    transformations: ").append(toIndentedString(transformations)).append("\n");
    sb.append("    unavailableAtForecastColumns: ").append(toIndentedString(unavailableAtForecastColumns)).append("\n");
    sb.append("    validationOptions: ").append(toIndentedString(validationOptions)).append("\n");
    sb.append("    weightColumn: ").append(toIndentedString(weightColumn)).append("\n");
    sb.append("    windowConfig: ").append(toIndentedString(windowConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("additionalExperiments");
    openapiFields.add("availableAtForecastColumns");
    openapiFields.add("contextWindow");
    openapiFields.add("dataGranularity");
    openapiFields.add("exportEvaluatedDataItemsConfig");
    openapiFields.add("forecastHorizon");
    openapiFields.add("hierarchyConfig");
    openapiFields.add("holidayRegions");
    openapiFields.add("optimizationObjective");
    openapiFields.add("quantiles");
    openapiFields.add("targetColumn");
    openapiFields.add("timeColumn");
    openapiFields.add("timeSeriesAttributeColumns");
    openapiFields.add("timeSeriesIdentifierColumn");
    openapiFields.add("trainBudgetMilliNodeHours");
    openapiFields.add("transformations");
    openapiFields.add("unavailableAtForecastColumns");
    openapiFields.add("validationOptions");
    openapiFields.add("weightColumn");
    openapiFields.add("windowConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs is not found in the empty JSON string", GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("additionalExperiments") != null && !jsonObj.get("additionalExperiments").isJsonNull() && !jsonObj.get("additionalExperiments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `additionalExperiments` to be an array in the JSON string but got `%s`", jsonObj.get("additionalExperiments").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("availableAtForecastColumns") != null && !jsonObj.get("availableAtForecastColumns").isJsonNull() && !jsonObj.get("availableAtForecastColumns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableAtForecastColumns` to be an array in the JSON string but got `%s`", jsonObj.get("availableAtForecastColumns").toString()));
      }
      if ((jsonObj.get("contextWindow") != null && !jsonObj.get("contextWindow").isJsonNull()) && !jsonObj.get("contextWindow").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contextWindow` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contextWindow").toString()));
      }
      // validate the optional field `dataGranularity`
      if (jsonObj.get("dataGranularity") != null && !jsonObj.get("dataGranularity").isJsonNull()) {
        GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsGranularity.validateJsonElement(jsonObj.get("dataGranularity"));
      }
      // validate the optional field `exportEvaluatedDataItemsConfig`
      if (jsonObj.get("exportEvaluatedDataItemsConfig") != null && !jsonObj.get("exportEvaluatedDataItemsConfig").isJsonNull()) {
        GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionExportEvaluatedDataItemsConfig.validateJsonElement(jsonObj.get("exportEvaluatedDataItemsConfig"));
      }
      if ((jsonObj.get("forecastHorizon") != null && !jsonObj.get("forecastHorizon").isJsonNull()) && !jsonObj.get("forecastHorizon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forecastHorizon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forecastHorizon").toString()));
      }
      // validate the optional field `hierarchyConfig`
      if (jsonObj.get("hierarchyConfig") != null && !jsonObj.get("hierarchyConfig").isJsonNull()) {
        GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionHierarchyConfig.validateJsonElement(jsonObj.get("hierarchyConfig"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("holidayRegions") != null && !jsonObj.get("holidayRegions").isJsonNull() && !jsonObj.get("holidayRegions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `holidayRegions` to be an array in the JSON string but got `%s`", jsonObj.get("holidayRegions").toString()));
      }
      if ((jsonObj.get("optimizationObjective") != null && !jsonObj.get("optimizationObjective").isJsonNull()) && !jsonObj.get("optimizationObjective").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizationObjective` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizationObjective").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("quantiles") != null && !jsonObj.get("quantiles").isJsonNull() && !jsonObj.get("quantiles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `quantiles` to be an array in the JSON string but got `%s`", jsonObj.get("quantiles").toString()));
      }
      if ((jsonObj.get("targetColumn") != null && !jsonObj.get("targetColumn").isJsonNull()) && !jsonObj.get("targetColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("targetColumn").toString()));
      }
      if ((jsonObj.get("timeColumn") != null && !jsonObj.get("timeColumn").isJsonNull()) && !jsonObj.get("timeColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeColumn").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("timeSeriesAttributeColumns") != null && !jsonObj.get("timeSeriesAttributeColumns").isJsonNull() && !jsonObj.get("timeSeriesAttributeColumns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesAttributeColumns` to be an array in the JSON string but got `%s`", jsonObj.get("timeSeriesAttributeColumns").toString()));
      }
      if ((jsonObj.get("timeSeriesIdentifierColumn") != null && !jsonObj.get("timeSeriesIdentifierColumn").isJsonNull()) && !jsonObj.get("timeSeriesIdentifierColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesIdentifierColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeSeriesIdentifierColumn").toString()));
      }
      if ((jsonObj.get("trainBudgetMilliNodeHours") != null && !jsonObj.get("trainBudgetMilliNodeHours").isJsonNull()) && !jsonObj.get("trainBudgetMilliNodeHours").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trainBudgetMilliNodeHours` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trainBudgetMilliNodeHours").toString()));
      }
      if (jsonObj.get("transformations") != null && !jsonObj.get("transformations").isJsonNull()) {
        JsonArray jsonArraytransformations = jsonObj.getAsJsonArray("transformations");
        if (jsonArraytransformations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transformations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transformations` to be an array in the JSON string but got `%s`", jsonObj.get("transformations").toString()));
          }

          // validate the optional field `transformations` (array)
          for (int i = 0; i < jsonArraytransformations.size(); i++) {
            GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputsTransformation.validateJsonElement(jsonArraytransformations.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("unavailableAtForecastColumns") != null && !jsonObj.get("unavailableAtForecastColumns").isJsonNull() && !jsonObj.get("unavailableAtForecastColumns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `unavailableAtForecastColumns` to be an array in the JSON string but got `%s`", jsonObj.get("unavailableAtForecastColumns").toString()));
      }
      if ((jsonObj.get("validationOptions") != null && !jsonObj.get("validationOptions").isJsonNull()) && !jsonObj.get("validationOptions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `validationOptions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("validationOptions").toString()));
      }
      if ((jsonObj.get("weightColumn") != null && !jsonObj.get("weightColumn").isJsonNull()) && !jsonObj.get("weightColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `weightColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("weightColumn").toString()));
      }
      // validate the optional field `windowConfig`
      if (jsonObj.get("windowConfig") != null && !jsonObj.get("windowConfig").isJsonNull()) {
        GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionWindowConfig.validateJsonElement(jsonObj.get("windowConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs>() {
           @Override
           public void write(JsonWriter out, GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs
   */
  public static GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs.class);
  }

  /**
   * Convert an instance of GoogleCloudAiplatformV1beta1SchemaTrainingjobDefinitionSeq2SeqPlusForecastingInputs to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

