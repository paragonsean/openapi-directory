/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.GoogleCloudAiplatformV1GcsSource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the location from where we import data into a Dataset, together with the labels that will be applied to the DataItems and the Annotations.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:33.164817-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudAiplatformV1ImportDataConfig {
  public static final String SERIALIZED_NAME_ANNOTATION_LABELS = "annotationLabels";
  @SerializedName(SERIALIZED_NAME_ANNOTATION_LABELS)
  private Map<String, String> annotationLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_DATA_ITEM_LABELS = "dataItemLabels";
  @SerializedName(SERIALIZED_NAME_DATA_ITEM_LABELS)
  private Map<String, String> dataItemLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_GCS_SOURCE = "gcsSource";
  @SerializedName(SERIALIZED_NAME_GCS_SOURCE)
  private GoogleCloudAiplatformV1GcsSource gcsSource;

  public static final String SERIALIZED_NAME_IMPORT_SCHEMA_URI = "importSchemaUri";
  @SerializedName(SERIALIZED_NAME_IMPORT_SCHEMA_URI)
  private String importSchemaUri;

  public GoogleCloudAiplatformV1ImportDataConfig() {
  }

  public GoogleCloudAiplatformV1ImportDataConfig annotationLabels(Map<String, String> annotationLabels) {
    this.annotationLabels = annotationLabels;
    return this;
  }

  public GoogleCloudAiplatformV1ImportDataConfig putAnnotationLabelsItem(String key, String annotationLabelsItem) {
    if (this.annotationLabels == null) {
      this.annotationLabels = new HashMap<>();
    }
    this.annotationLabels.put(key, annotationLabelsItem);
    return this;
  }

  /**
   * Labels that will be applied to newly imported Annotations. If two Annotations are identical, one of them will be deduped. Two Annotations are considered identical if their payload, payload_schema_uri and all of their labels are the same. These labels will be overridden by Annotation labels specified inside index file referenced by import_schema_uri, e.g. jsonl file.
   * @return annotationLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getAnnotationLabels() {
    return annotationLabels;
  }

  public void setAnnotationLabels(Map<String, String> annotationLabels) {
    this.annotationLabels = annotationLabels;
  }


  public GoogleCloudAiplatformV1ImportDataConfig dataItemLabels(Map<String, String> dataItemLabels) {
    this.dataItemLabels = dataItemLabels;
    return this;
  }

  public GoogleCloudAiplatformV1ImportDataConfig putDataItemLabelsItem(String key, String dataItemLabelsItem) {
    if (this.dataItemLabels == null) {
      this.dataItemLabels = new HashMap<>();
    }
    this.dataItemLabels.put(key, dataItemLabelsItem);
    return this;
  }

  /**
   * Labels that will be applied to newly imported DataItems. If an identical DataItem as one being imported already exists in the Dataset, then these labels will be appended to these of the already existing one, and if labels with identical key is imported before, the old label value will be overwritten. If two DataItems are identical in the same import data operation, the labels will be combined and if key collision happens in this case, one of the values will be picked randomly. Two DataItems are considered identical if their content bytes are identical (e.g. image bytes or pdf bytes). These labels will be overridden by Annotation labels specified inside index file referenced by import_schema_uri, e.g. jsonl file.
   * @return dataItemLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getDataItemLabels() {
    return dataItemLabels;
  }

  public void setDataItemLabels(Map<String, String> dataItemLabels) {
    this.dataItemLabels = dataItemLabels;
  }


  public GoogleCloudAiplatformV1ImportDataConfig gcsSource(GoogleCloudAiplatformV1GcsSource gcsSource) {
    this.gcsSource = gcsSource;
    return this;
  }

  /**
   * Get gcsSource
   * @return gcsSource
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1GcsSource getGcsSource() {
    return gcsSource;
  }

  public void setGcsSource(GoogleCloudAiplatformV1GcsSource gcsSource) {
    this.gcsSource = gcsSource;
  }


  public GoogleCloudAiplatformV1ImportDataConfig importSchemaUri(String importSchemaUri) {
    this.importSchemaUri = importSchemaUri;
    return this;
  }

  /**
   * Required. Points to a YAML file stored on Google Cloud Storage describing the import format. Validation will be done against the schema. The schema is defined as an [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
   * @return importSchemaUri
   */
  @javax.annotation.Nullable
  public String getImportSchemaUri() {
    return importSchemaUri;
  }

  public void setImportSchemaUri(String importSchemaUri) {
    this.importSchemaUri = importSchemaUri;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudAiplatformV1ImportDataConfig googleCloudAiplatformV1ImportDataConfig = (GoogleCloudAiplatformV1ImportDataConfig) o;
    return Objects.equals(this.annotationLabels, googleCloudAiplatformV1ImportDataConfig.annotationLabels) &&
        Objects.equals(this.dataItemLabels, googleCloudAiplatformV1ImportDataConfig.dataItemLabels) &&
        Objects.equals(this.gcsSource, googleCloudAiplatformV1ImportDataConfig.gcsSource) &&
        Objects.equals(this.importSchemaUri, googleCloudAiplatformV1ImportDataConfig.importSchemaUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationLabels, dataItemLabels, gcsSource, importSchemaUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudAiplatformV1ImportDataConfig {\n");
    sb.append("    annotationLabels: ").append(toIndentedString(annotationLabels)).append("\n");
    sb.append("    dataItemLabels: ").append(toIndentedString(dataItemLabels)).append("\n");
    sb.append("    gcsSource: ").append(toIndentedString(gcsSource)).append("\n");
    sb.append("    importSchemaUri: ").append(toIndentedString(importSchemaUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotationLabels");
    openapiFields.add("dataItemLabels");
    openapiFields.add("gcsSource");
    openapiFields.add("importSchemaUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudAiplatformV1ImportDataConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudAiplatformV1ImportDataConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudAiplatformV1ImportDataConfig is not found in the empty JSON string", GoogleCloudAiplatformV1ImportDataConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudAiplatformV1ImportDataConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudAiplatformV1ImportDataConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `gcsSource`
      if (jsonObj.get("gcsSource") != null && !jsonObj.get("gcsSource").isJsonNull()) {
        GoogleCloudAiplatformV1GcsSource.validateJsonElement(jsonObj.get("gcsSource"));
      }
      if ((jsonObj.get("importSchemaUri") != null && !jsonObj.get("importSchemaUri").isJsonNull()) && !jsonObj.get("importSchemaUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `importSchemaUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("importSchemaUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudAiplatformV1ImportDataConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudAiplatformV1ImportDataConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudAiplatformV1ImportDataConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudAiplatformV1ImportDataConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudAiplatformV1ImportDataConfig>() {
           @Override
           public void write(JsonWriter out, GoogleCloudAiplatformV1ImportDataConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudAiplatformV1ImportDataConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudAiplatformV1ImportDataConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudAiplatformV1ImportDataConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudAiplatformV1ImportDataConfig
   */
  public static GoogleCloudAiplatformV1ImportDataConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudAiplatformV1ImportDataConfig.class);
  }

  /**
   * Convert an instance of GoogleCloudAiplatformV1ImportDataConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

