/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration for ConvexAutomatedStoppingSpec. When there are enough completed trials (configured by min_measurement_count), for pending trials with enough measurements and steps, the policy first computes an overestimate of the objective value at max_num_steps according to the slope of the incomplete objective value curve. No prediction can be made if the curve is completely flat. If the overestimation is worse than the best objective value of the completed trials, this pending trial will be early-stopped, but a last measurement will be added to the pending trial with max_num_steps and predicted objective value from the autoregression model.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:33.164817-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec {
  public static final String SERIALIZED_NAME_LEARNING_RATE_PARAMETER_NAME = "learningRateParameterName";
  @SerializedName(SERIALIZED_NAME_LEARNING_RATE_PARAMETER_NAME)
  private String learningRateParameterName;

  public static final String SERIALIZED_NAME_MAX_STEP_COUNT = "maxStepCount";
  @SerializedName(SERIALIZED_NAME_MAX_STEP_COUNT)
  private String maxStepCount;

  public static final String SERIALIZED_NAME_MIN_MEASUREMENT_COUNT = "minMeasurementCount";
  @SerializedName(SERIALIZED_NAME_MIN_MEASUREMENT_COUNT)
  private String minMeasurementCount;

  public static final String SERIALIZED_NAME_MIN_STEP_COUNT = "minStepCount";
  @SerializedName(SERIALIZED_NAME_MIN_STEP_COUNT)
  private String minStepCount;

  public static final String SERIALIZED_NAME_UPDATE_ALL_STOPPED_TRIALS = "updateAllStoppedTrials";
  @SerializedName(SERIALIZED_NAME_UPDATE_ALL_STOPPED_TRIALS)
  private Boolean updateAllStoppedTrials;

  public static final String SERIALIZED_NAME_USE_ELAPSED_DURATION = "useElapsedDuration";
  @SerializedName(SERIALIZED_NAME_USE_ELAPSED_DURATION)
  private Boolean useElapsedDuration;

  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec() {
  }

  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec learningRateParameterName(String learningRateParameterName) {
    this.learningRateParameterName = learningRateParameterName;
    return this;
  }

  /**
   * The hyper-parameter name used in the tuning job that stands for learning rate. Leave it blank if learning rate is not in a parameter in tuning. The learning_rate is used to estimate the objective value of the ongoing trial.
   * @return learningRateParameterName
   */
  @javax.annotation.Nullable
  public String getLearningRateParameterName() {
    return learningRateParameterName;
  }

  public void setLearningRateParameterName(String learningRateParameterName) {
    this.learningRateParameterName = learningRateParameterName;
  }


  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec maxStepCount(String maxStepCount) {
    this.maxStepCount = maxStepCount;
    return this;
  }

  /**
   * Steps used in predicting the final objective for early stopped trials. In general, it&#39;s set to be the same as the defined steps in training / tuning. If not defined, it will learn it from the completed trials. When use_steps is false, this field is set to the maximum elapsed seconds.
   * @return maxStepCount
   */
  @javax.annotation.Nullable
  public String getMaxStepCount() {
    return maxStepCount;
  }

  public void setMaxStepCount(String maxStepCount) {
    this.maxStepCount = maxStepCount;
  }


  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec minMeasurementCount(String minMeasurementCount) {
    this.minMeasurementCount = minMeasurementCount;
    return this;
  }

  /**
   * The minimal number of measurements in a Trial. Early-stopping checks will not trigger if less than min_measurement_count+1 completed trials or pending trials with less than min_measurement_count measurements. If not defined, the default value is 5.
   * @return minMeasurementCount
   */
  @javax.annotation.Nullable
  public String getMinMeasurementCount() {
    return minMeasurementCount;
  }

  public void setMinMeasurementCount(String minMeasurementCount) {
    this.minMeasurementCount = minMeasurementCount;
  }


  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec minStepCount(String minStepCount) {
    this.minStepCount = minStepCount;
    return this;
  }

  /**
   * Minimum number of steps for a trial to complete. Trials which do not have a measurement with step_count &gt; min_step_count won&#39;t be considered for early stopping. It&#39;s ok to set it to 0, and a trial can be early stopped at any stage. By default, min_step_count is set to be one-tenth of the max_step_count. When use_elapsed_duration is true, this field is set to the minimum elapsed seconds.
   * @return minStepCount
   */
  @javax.annotation.Nullable
  public String getMinStepCount() {
    return minStepCount;
  }

  public void setMinStepCount(String minStepCount) {
    this.minStepCount = minStepCount;
  }


  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec updateAllStoppedTrials(Boolean updateAllStoppedTrials) {
    this.updateAllStoppedTrials = updateAllStoppedTrials;
    return this;
  }

  /**
   * ConvexAutomatedStoppingSpec by default only updates the trials that needs to be early stopped using a newly trained auto-regressive model. When this flag is set to True, all stopped trials from the beginning are potentially updated in terms of their &#x60;final_measurement&#x60;. Also, note that the training logic of autoregressive models is different in this case. Enabling this option has shown better results and this may be the default option in the future.
   * @return updateAllStoppedTrials
   */
  @javax.annotation.Nullable
  public Boolean getUpdateAllStoppedTrials() {
    return updateAllStoppedTrials;
  }

  public void setUpdateAllStoppedTrials(Boolean updateAllStoppedTrials) {
    this.updateAllStoppedTrials = updateAllStoppedTrials;
  }


  public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec useElapsedDuration(Boolean useElapsedDuration) {
    this.useElapsedDuration = useElapsedDuration;
    return this;
  }

  /**
   * This bool determines whether or not the rule is applied based on elapsed_secs or steps. If use_elapsed_duration&#x3D;&#x3D;false, the early stopping decision is made according to the predicted objective values according to the target steps. If use_elapsed_duration&#x3D;&#x3D;true, elapsed_secs is used instead of steps. Also, in this case, the parameters max_num_steps and min_num_steps are overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
   * @return useElapsedDuration
   */
  @javax.annotation.Nullable
  public Boolean getUseElapsedDuration() {
    return useElapsedDuration;
  }

  public void setUseElapsedDuration(Boolean useElapsedDuration) {
    this.useElapsedDuration = useElapsedDuration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec = (GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec) o;
    return Objects.equals(this.learningRateParameterName, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.learningRateParameterName) &&
        Objects.equals(this.maxStepCount, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.maxStepCount) &&
        Objects.equals(this.minMeasurementCount, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.minMeasurementCount) &&
        Objects.equals(this.minStepCount, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.minStepCount) &&
        Objects.equals(this.updateAllStoppedTrials, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.updateAllStoppedTrials) &&
        Objects.equals(this.useElapsedDuration, googleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.useElapsedDuration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(learningRateParameterName, maxStepCount, minMeasurementCount, minStepCount, updateAllStoppedTrials, useElapsedDuration);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec {\n");
    sb.append("    learningRateParameterName: ").append(toIndentedString(learningRateParameterName)).append("\n");
    sb.append("    maxStepCount: ").append(toIndentedString(maxStepCount)).append("\n");
    sb.append("    minMeasurementCount: ").append(toIndentedString(minMeasurementCount)).append("\n");
    sb.append("    minStepCount: ").append(toIndentedString(minStepCount)).append("\n");
    sb.append("    updateAllStoppedTrials: ").append(toIndentedString(updateAllStoppedTrials)).append("\n");
    sb.append("    useElapsedDuration: ").append(toIndentedString(useElapsedDuration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("learningRateParameterName");
    openapiFields.add("maxStepCount");
    openapiFields.add("minMeasurementCount");
    openapiFields.add("minStepCount");
    openapiFields.add("updateAllStoppedTrials");
    openapiFields.add("useElapsedDuration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec is not found in the empty JSON string", GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("learningRateParameterName") != null && !jsonObj.get("learningRateParameterName").isJsonNull()) && !jsonObj.get("learningRateParameterName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `learningRateParameterName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("learningRateParameterName").toString()));
      }
      if ((jsonObj.get("maxStepCount") != null && !jsonObj.get("maxStepCount").isJsonNull()) && !jsonObj.get("maxStepCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxStepCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxStepCount").toString()));
      }
      if ((jsonObj.get("minMeasurementCount") != null && !jsonObj.get("minMeasurementCount").isJsonNull()) && !jsonObj.get("minMeasurementCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minMeasurementCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minMeasurementCount").toString()));
      }
      if ((jsonObj.get("minStepCount") != null && !jsonObj.get("minStepCount").isJsonNull()) && !jsonObj.get("minStepCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minStepCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minStepCount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec>() {
           @Override
           public void write(JsonWriter out, GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
   */
  public static GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.class);
  }

  /**
   * Convert an instance of GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

