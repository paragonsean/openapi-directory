/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GoogleCloudAiplatformV1ExportFilterSplit;
import org.openapitools.client.model.GoogleCloudAiplatformV1ExportFractionSplit;
import org.openapitools.client.model.GoogleCloudAiplatformV1GcsDestination;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes what part of the Dataset is to be exported, the destination of the export and how to export.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:33.164817-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudAiplatformV1ExportDataConfig {
  public static final String SERIALIZED_NAME_ANNOTATION_SCHEMA_URI = "annotationSchemaUri";
  @SerializedName(SERIALIZED_NAME_ANNOTATION_SCHEMA_URI)
  private String annotationSchemaUri;

  public static final String SERIALIZED_NAME_ANNOTATIONS_FILTER = "annotationsFilter";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS_FILTER)
  private String annotationsFilter;

  /**
   * Indicates the usage of the exported files.
   */
  @JsonAdapter(ExportUseEnum.Adapter.class)
  public enum ExportUseEnum {
    EXPORT_USE_UNSPECIFIED("EXPORT_USE_UNSPECIFIED"),
    
    CUSTOM_CODE_TRAINING("CUSTOM_CODE_TRAINING");

    private String value;

    ExportUseEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExportUseEnum fromValue(String value) {
      for (ExportUseEnum b : ExportUseEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExportUseEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExportUseEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExportUseEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExportUseEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExportUseEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXPORT_USE = "exportUse";
  @SerializedName(SERIALIZED_NAME_EXPORT_USE)
  private ExportUseEnum exportUse;

  public static final String SERIALIZED_NAME_FILTER_SPLIT = "filterSplit";
  @SerializedName(SERIALIZED_NAME_FILTER_SPLIT)
  private GoogleCloudAiplatformV1ExportFilterSplit filterSplit;

  public static final String SERIALIZED_NAME_FRACTION_SPLIT = "fractionSplit";
  @SerializedName(SERIALIZED_NAME_FRACTION_SPLIT)
  private GoogleCloudAiplatformV1ExportFractionSplit fractionSplit;

  public static final String SERIALIZED_NAME_GCS_DESTINATION = "gcsDestination";
  @SerializedName(SERIALIZED_NAME_GCS_DESTINATION)
  private GoogleCloudAiplatformV1GcsDestination gcsDestination;

  public static final String SERIALIZED_NAME_SAVED_QUERY_ID = "savedQueryId";
  @SerializedName(SERIALIZED_NAME_SAVED_QUERY_ID)
  private String savedQueryId;

  public GoogleCloudAiplatformV1ExportDataConfig() {
  }

  public GoogleCloudAiplatformV1ExportDataConfig annotationSchemaUri(String annotationSchemaUri) {
    this.annotationSchemaUri = annotationSchemaUri;
    return this;
  }

  /**
   * The Cloud Storage URI that points to a YAML file describing the annotation schema. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). The schema files that can be used here are found in gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the chosen schema must be consistent with metadata of the Dataset specified by dataset_id. Only used for custom training data export use cases. Only applicable to Datasets that have DataItems and Annotations. Only Annotations that both match this schema and belong to DataItems not ignored by the split method are used in respectively training, validation or test role, depending on the role of the DataItem they are on. When used in conjunction with annotations_filter, the Annotations used for training are filtered by both annotations_filter and annotation_schema_uri.
   * @return annotationSchemaUri
   */
  @javax.annotation.Nullable
  public String getAnnotationSchemaUri() {
    return annotationSchemaUri;
  }

  public void setAnnotationSchemaUri(String annotationSchemaUri) {
    this.annotationSchemaUri = annotationSchemaUri;
  }


  public GoogleCloudAiplatformV1ExportDataConfig annotationsFilter(String annotationsFilter) {
    this.annotationsFilter = annotationsFilter;
    return this;
  }

  /**
   * An expression for filtering what part of the Dataset is to be exported. Only Annotations that match this filter will be exported. The filter syntax is the same as in ListAnnotations.
   * @return annotationsFilter
   */
  @javax.annotation.Nullable
  public String getAnnotationsFilter() {
    return annotationsFilter;
  }

  public void setAnnotationsFilter(String annotationsFilter) {
    this.annotationsFilter = annotationsFilter;
  }


  public GoogleCloudAiplatformV1ExportDataConfig exportUse(ExportUseEnum exportUse) {
    this.exportUse = exportUse;
    return this;
  }

  /**
   * Indicates the usage of the exported files.
   * @return exportUse
   */
  @javax.annotation.Nullable
  public ExportUseEnum getExportUse() {
    return exportUse;
  }

  public void setExportUse(ExportUseEnum exportUse) {
    this.exportUse = exportUse;
  }


  public GoogleCloudAiplatformV1ExportDataConfig filterSplit(GoogleCloudAiplatformV1ExportFilterSplit filterSplit) {
    this.filterSplit = filterSplit;
    return this;
  }

  /**
   * Get filterSplit
   * @return filterSplit
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1ExportFilterSplit getFilterSplit() {
    return filterSplit;
  }

  public void setFilterSplit(GoogleCloudAiplatformV1ExportFilterSplit filterSplit) {
    this.filterSplit = filterSplit;
  }


  public GoogleCloudAiplatformV1ExportDataConfig fractionSplit(GoogleCloudAiplatformV1ExportFractionSplit fractionSplit) {
    this.fractionSplit = fractionSplit;
    return this;
  }

  /**
   * Get fractionSplit
   * @return fractionSplit
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1ExportFractionSplit getFractionSplit() {
    return fractionSplit;
  }

  public void setFractionSplit(GoogleCloudAiplatformV1ExportFractionSplit fractionSplit) {
    this.fractionSplit = fractionSplit;
  }


  public GoogleCloudAiplatformV1ExportDataConfig gcsDestination(GoogleCloudAiplatformV1GcsDestination gcsDestination) {
    this.gcsDestination = gcsDestination;
    return this;
  }

  /**
   * Get gcsDestination
   * @return gcsDestination
   */
  @javax.annotation.Nullable
  public GoogleCloudAiplatformV1GcsDestination getGcsDestination() {
    return gcsDestination;
  }

  public void setGcsDestination(GoogleCloudAiplatformV1GcsDestination gcsDestination) {
    this.gcsDestination = gcsDestination;
  }


  public GoogleCloudAiplatformV1ExportDataConfig savedQueryId(String savedQueryId) {
    this.savedQueryId = savedQueryId;
    return this;
  }

  /**
   * The ID of a SavedQuery (annotation set) under the Dataset specified by dataset_id used for filtering Annotations for training. Only used for custom training data export use cases. Only applicable to Datasets that have SavedQueries. Only Annotations that are associated with this SavedQuery are used in respectively training. When used in conjunction with annotations_filter, the Annotations used for training are filtered by both saved_query_id and annotations_filter. Only one of saved_query_id and annotation_schema_uri should be specified as both of them represent the same thing: problem type.
   * @return savedQueryId
   */
  @javax.annotation.Nullable
  public String getSavedQueryId() {
    return savedQueryId;
  }

  public void setSavedQueryId(String savedQueryId) {
    this.savedQueryId = savedQueryId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudAiplatformV1ExportDataConfig googleCloudAiplatformV1ExportDataConfig = (GoogleCloudAiplatformV1ExportDataConfig) o;
    return Objects.equals(this.annotationSchemaUri, googleCloudAiplatformV1ExportDataConfig.annotationSchemaUri) &&
        Objects.equals(this.annotationsFilter, googleCloudAiplatformV1ExportDataConfig.annotationsFilter) &&
        Objects.equals(this.exportUse, googleCloudAiplatformV1ExportDataConfig.exportUse) &&
        Objects.equals(this.filterSplit, googleCloudAiplatformV1ExportDataConfig.filterSplit) &&
        Objects.equals(this.fractionSplit, googleCloudAiplatformV1ExportDataConfig.fractionSplit) &&
        Objects.equals(this.gcsDestination, googleCloudAiplatformV1ExportDataConfig.gcsDestination) &&
        Objects.equals(this.savedQueryId, googleCloudAiplatformV1ExportDataConfig.savedQueryId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationSchemaUri, annotationsFilter, exportUse, filterSplit, fractionSplit, gcsDestination, savedQueryId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudAiplatformV1ExportDataConfig {\n");
    sb.append("    annotationSchemaUri: ").append(toIndentedString(annotationSchemaUri)).append("\n");
    sb.append("    annotationsFilter: ").append(toIndentedString(annotationsFilter)).append("\n");
    sb.append("    exportUse: ").append(toIndentedString(exportUse)).append("\n");
    sb.append("    filterSplit: ").append(toIndentedString(filterSplit)).append("\n");
    sb.append("    fractionSplit: ").append(toIndentedString(fractionSplit)).append("\n");
    sb.append("    gcsDestination: ").append(toIndentedString(gcsDestination)).append("\n");
    sb.append("    savedQueryId: ").append(toIndentedString(savedQueryId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotationSchemaUri");
    openapiFields.add("annotationsFilter");
    openapiFields.add("exportUse");
    openapiFields.add("filterSplit");
    openapiFields.add("fractionSplit");
    openapiFields.add("gcsDestination");
    openapiFields.add("savedQueryId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudAiplatformV1ExportDataConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudAiplatformV1ExportDataConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudAiplatformV1ExportDataConfig is not found in the empty JSON string", GoogleCloudAiplatformV1ExportDataConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudAiplatformV1ExportDataConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudAiplatformV1ExportDataConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("annotationSchemaUri") != null && !jsonObj.get("annotationSchemaUri").isJsonNull()) && !jsonObj.get("annotationSchemaUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotationSchemaUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotationSchemaUri").toString()));
      }
      if ((jsonObj.get("annotationsFilter") != null && !jsonObj.get("annotationsFilter").isJsonNull()) && !jsonObj.get("annotationsFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotationsFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotationsFilter").toString()));
      }
      if ((jsonObj.get("exportUse") != null && !jsonObj.get("exportUse").isJsonNull()) && !jsonObj.get("exportUse").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exportUse` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exportUse").toString()));
      }
      // validate the optional field `exportUse`
      if (jsonObj.get("exportUse") != null && !jsonObj.get("exportUse").isJsonNull()) {
        ExportUseEnum.validateJsonElement(jsonObj.get("exportUse"));
      }
      // validate the optional field `filterSplit`
      if (jsonObj.get("filterSplit") != null && !jsonObj.get("filterSplit").isJsonNull()) {
        GoogleCloudAiplatformV1ExportFilterSplit.validateJsonElement(jsonObj.get("filterSplit"));
      }
      // validate the optional field `fractionSplit`
      if (jsonObj.get("fractionSplit") != null && !jsonObj.get("fractionSplit").isJsonNull()) {
        GoogleCloudAiplatformV1ExportFractionSplit.validateJsonElement(jsonObj.get("fractionSplit"));
      }
      // validate the optional field `gcsDestination`
      if (jsonObj.get("gcsDestination") != null && !jsonObj.get("gcsDestination").isJsonNull()) {
        GoogleCloudAiplatformV1GcsDestination.validateJsonElement(jsonObj.get("gcsDestination"));
      }
      if ((jsonObj.get("savedQueryId") != null && !jsonObj.get("savedQueryId").isJsonNull()) && !jsonObj.get("savedQueryId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `savedQueryId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("savedQueryId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudAiplatformV1ExportDataConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudAiplatformV1ExportDataConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudAiplatformV1ExportDataConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudAiplatformV1ExportDataConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudAiplatformV1ExportDataConfig>() {
           @Override
           public void write(JsonWriter out, GoogleCloudAiplatformV1ExportDataConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudAiplatformV1ExportDataConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudAiplatformV1ExportDataConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudAiplatformV1ExportDataConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudAiplatformV1ExportDataConfig
   */
  public static GoogleCloudAiplatformV1ExportDataConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudAiplatformV1ExportDataConfig.class);
  }

  /**
   * Convert an instance of GoogleCloudAiplatformV1ExportDataConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

