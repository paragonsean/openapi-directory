/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Attribution that explains a particular prediction output.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:33.164817-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudAiplatformV1Attribution {
  public static final String SERIALIZED_NAME_APPROXIMATION_ERROR = "approximationError";
  @SerializedName(SERIALIZED_NAME_APPROXIMATION_ERROR)
  private Double approximationError;

  public static final String SERIALIZED_NAME_BASELINE_OUTPUT_VALUE = "baselineOutputValue";
  @SerializedName(SERIALIZED_NAME_BASELINE_OUTPUT_VALUE)
  private Double baselineOutputValue;

  public static final String SERIALIZED_NAME_FEATURE_ATTRIBUTIONS = "featureAttributions";
  @SerializedName(SERIALIZED_NAME_FEATURE_ATTRIBUTIONS)
  private Object featureAttributions = null;

  public static final String SERIALIZED_NAME_INSTANCE_OUTPUT_VALUE = "instanceOutputValue";
  @SerializedName(SERIALIZED_NAME_INSTANCE_OUTPUT_VALUE)
  private Double instanceOutputValue;

  public static final String SERIALIZED_NAME_OUTPUT_DISPLAY_NAME = "outputDisplayName";
  @SerializedName(SERIALIZED_NAME_OUTPUT_DISPLAY_NAME)
  private String outputDisplayName;

  public static final String SERIALIZED_NAME_OUTPUT_INDEX = "outputIndex";
  @SerializedName(SERIALIZED_NAME_OUTPUT_INDEX)
  private List<Integer> outputIndex = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_NAME = "outputName";
  @SerializedName(SERIALIZED_NAME_OUTPUT_NAME)
  private String outputName;

  public GoogleCloudAiplatformV1Attribution() {
  }

  public GoogleCloudAiplatformV1Attribution(
     Double approximationError, 
     Double baselineOutputValue, 
     Object featureAttributions, 
     Double instanceOutputValue, 
     String outputDisplayName, 
     List<Integer> outputIndex, 
     String outputName
  ) {
    this();
    this.approximationError = approximationError;
    this.baselineOutputValue = baselineOutputValue;
    this.featureAttributions = featureAttributions;
    this.instanceOutputValue = instanceOutputValue;
    this.outputDisplayName = outputDisplayName;
    this.outputIndex = outputIndex;
    this.outputName = outputName;
  }

  /**
   * Output only. Error of feature_attributions caused by approximation used in the explanation method. Lower value means more precise attributions. * For Sampled Shapley attribution, increasing path_count might reduce the error. * For Integrated Gradients attribution, increasing step_count might reduce the error. * For XRAI attribution, increasing step_count might reduce the error. See [this introduction](/vertex-ai/docs/explainable-ai/overview) for more information.
   * @return approximationError
   */
  @javax.annotation.Nullable
  public Double getApproximationError() {
    return approximationError;
  }



  /**
   * Output only. Model predicted output if the input instance is constructed from the baselines of all the features defined in ExplanationMetadata.inputs. The field name of the output is determined by the key in ExplanationMetadata.outputs. If the Model&#39;s predicted output has multiple dimensions (rank &gt; 1), this is the value in the output located by output_index. If there are multiple baselines, their output values are averaged.
   * @return baselineOutputValue
   */
  @javax.annotation.Nullable
  public Double getBaselineOutputValue() {
    return baselineOutputValue;
  }



  /**
   * Output only. Attributions of each explained feature. Features are extracted from the prediction instances according to explanation metadata for inputs. The value is a struct, whose keys are the name of the feature. The values are how much the feature in the instance contributed to the predicted result. The format of the value is determined by the feature&#39;s input format: * If the feature is a scalar value, the attribution value is a floating number. * If the feature is an array of scalar values, the attribution value is an array. * If the feature is a struct, the attribution value is a struct. The keys in the attribution value struct are the same as the keys in the feature struct. The formats of the values in the attribution struct are determined by the formats of the values in the feature struct. The ExplanationMetadata.feature_attributions_schema_uri field, pointed to by the ExplanationSpec field of the Endpoint.deployed_models object, points to the schema file that describes the features and their attribution values (if it is populated).
   * @return featureAttributions
   */
  @javax.annotation.Nullable
  public Object getFeatureAttributions() {
    return featureAttributions;
  }



  /**
   * Output only. Model predicted output on the corresponding explanation instance. The field name of the output is determined by the key in ExplanationMetadata.outputs. If the Model predicted output has multiple dimensions, this is the value in the output located by output_index.
   * @return instanceOutputValue
   */
  @javax.annotation.Nullable
  public Double getInstanceOutputValue() {
    return instanceOutputValue;
  }



  /**
   * Output only. The display name of the output identified by output_index. For example, the predicted class name by a multi-classification Model. This field is only populated iff the Model predicts display names as a separate field along with the explained output. The predicted display name must has the same shape of the explained output, and can be located using output_index.
   * @return outputDisplayName
   */
  @javax.annotation.Nullable
  public String getOutputDisplayName() {
    return outputDisplayName;
  }



  /**
   * Output only. The index that locates the explained prediction output. If the prediction output is a scalar value, output_index is not populated. If the prediction output has multiple dimensions, the length of the output_index list is the same as the number of dimensions of the output. The i-th element in output_index is the element index of the i-th dimension of the output vector. Indices start from 0.
   * @return outputIndex
   */
  @javax.annotation.Nullable
  public List<Integer> getOutputIndex() {
    return outputIndex;
  }



  /**
   * Output only. Name of the explain output. Specified as the key in ExplanationMetadata.outputs.
   * @return outputName
   */
  @javax.annotation.Nullable
  public String getOutputName() {
    return outputName;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudAiplatformV1Attribution googleCloudAiplatformV1Attribution = (GoogleCloudAiplatformV1Attribution) o;
    return Objects.equals(this.approximationError, googleCloudAiplatformV1Attribution.approximationError) &&
        Objects.equals(this.baselineOutputValue, googleCloudAiplatformV1Attribution.baselineOutputValue) &&
        Objects.equals(this.featureAttributions, googleCloudAiplatformV1Attribution.featureAttributions) &&
        Objects.equals(this.instanceOutputValue, googleCloudAiplatformV1Attribution.instanceOutputValue) &&
        Objects.equals(this.outputDisplayName, googleCloudAiplatformV1Attribution.outputDisplayName) &&
        Objects.equals(this.outputIndex, googleCloudAiplatformV1Attribution.outputIndex) &&
        Objects.equals(this.outputName, googleCloudAiplatformV1Attribution.outputName);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(approximationError, baselineOutputValue, featureAttributions, instanceOutputValue, outputDisplayName, outputIndex, outputName);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudAiplatformV1Attribution {\n");
    sb.append("    approximationError: ").append(toIndentedString(approximationError)).append("\n");
    sb.append("    baselineOutputValue: ").append(toIndentedString(baselineOutputValue)).append("\n");
    sb.append("    featureAttributions: ").append(toIndentedString(featureAttributions)).append("\n");
    sb.append("    instanceOutputValue: ").append(toIndentedString(instanceOutputValue)).append("\n");
    sb.append("    outputDisplayName: ").append(toIndentedString(outputDisplayName)).append("\n");
    sb.append("    outputIndex: ").append(toIndentedString(outputIndex)).append("\n");
    sb.append("    outputName: ").append(toIndentedString(outputName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("approximationError");
    openapiFields.add("baselineOutputValue");
    openapiFields.add("featureAttributions");
    openapiFields.add("instanceOutputValue");
    openapiFields.add("outputDisplayName");
    openapiFields.add("outputIndex");
    openapiFields.add("outputName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudAiplatformV1Attribution
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudAiplatformV1Attribution.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudAiplatformV1Attribution is not found in the empty JSON string", GoogleCloudAiplatformV1Attribution.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudAiplatformV1Attribution.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudAiplatformV1Attribution` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("outputDisplayName") != null && !jsonObj.get("outputDisplayName").isJsonNull()) && !jsonObj.get("outputDisplayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputDisplayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputDisplayName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("outputIndex") != null && !jsonObj.get("outputIndex").isJsonNull() && !jsonObj.get("outputIndex").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputIndex` to be an array in the JSON string but got `%s`", jsonObj.get("outputIndex").toString()));
      }
      if ((jsonObj.get("outputName") != null && !jsonObj.get("outputName").isJsonNull()) && !jsonObj.get("outputName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudAiplatformV1Attribution.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudAiplatformV1Attribution' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudAiplatformV1Attribution> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudAiplatformV1Attribution.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudAiplatformV1Attribution>() {
           @Override
           public void write(JsonWriter out, GoogleCloudAiplatformV1Attribution value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudAiplatformV1Attribution read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudAiplatformV1Attribution given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudAiplatformV1Attribution
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudAiplatformV1Attribution
   */
  public static GoogleCloudAiplatformV1Attribution fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudAiplatformV1Attribution.class);
  }

  /**
   * Convert an instance of GoogleCloudAiplatformV1Attribution to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

