/*
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CloudAiNlLlmProtoServiceRaiResult;
import org.openapitools.client.model.LearningGenaiRecitationRecitationResult;
import org.openapitools.client.model.LearningGenaiRootClassifierOutputSummary;
import org.openapitools.client.model.LearningGenaiRootCodeyOutput;
import org.openapitools.client.model.LearningGenaiRootFilterMetadata;
import org.openapitools.client.model.LearningGenaiRootGroundingMetadata;
import org.openapitools.client.model.LearningGenaiRootRAIOutput;
import org.openapitools.client.model.LearningGenaiRootScore;
import org.openapitools.client.model.NlpSaftLangIdResult;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LINT.IfChange This metadata contains additional information required for debugging.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:33.164817-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LearningServingLlmMessageMetadata {
  public static final String SERIALIZED_NAME_CLASSIFIER_SUMMARY = "classifierSummary";
  @SerializedName(SERIALIZED_NAME_CLASSIFIER_SUMMARY)
  private LearningGenaiRootClassifierOutputSummary classifierSummary;

  public static final String SERIALIZED_NAME_CODEY_OUTPUT = "codeyOutput";
  @SerializedName(SERIALIZED_NAME_CODEY_OUTPUT)
  private LearningGenaiRootCodeyOutput codeyOutput;

  public static final String SERIALIZED_NAME_CURRENT_STREAM_TEXT_LENGTH = "currentStreamTextLength";
  @SerializedName(SERIALIZED_NAME_CURRENT_STREAM_TEXT_LENGTH)
  private Integer currentStreamTextLength;

  public static final String SERIALIZED_NAME_DELETED = "deleted";
  @SerializedName(SERIALIZED_NAME_DELETED)
  private Boolean deleted;

  public static final String SERIALIZED_NAME_FILTER_META = "filterMeta";
  @SerializedName(SERIALIZED_NAME_FILTER_META)
  private List<LearningGenaiRootFilterMetadata> filterMeta = new ArrayList<>();

  public static final String SERIALIZED_NAME_FINAL_MESSAGE_SCORE = "finalMessageScore";
  @SerializedName(SERIALIZED_NAME_FINAL_MESSAGE_SCORE)
  private LearningGenaiRootScore finalMessageScore;

  /**
   * NOT YET IMPLEMENTED.
   */
  @JsonAdapter(FinishReasonEnum.Adapter.class)
  public enum FinishReasonEnum {
    UNSPECIFIED("UNSPECIFIED"),
    
    RETURN("RETURN"),
    
    STOP("STOP"),
    
    MAX_TOKENS("MAX_TOKENS"),
    
    FILTER("FILTER");

    private String value;

    FinishReasonEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FinishReasonEnum fromValue(String value) {
      for (FinishReasonEnum b : FinishReasonEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FinishReasonEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FinishReasonEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FinishReasonEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FinishReasonEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FinishReasonEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FINISH_REASON = "finishReason";
  @SerializedName(SERIALIZED_NAME_FINISH_REASON)
  private FinishReasonEnum finishReason;

  public static final String SERIALIZED_NAME_GROUNDING_METADATA = "groundingMetadata";
  @SerializedName(SERIALIZED_NAME_GROUNDING_METADATA)
  private LearningGenaiRootGroundingMetadata groundingMetadata;

  public static final String SERIALIZED_NAME_IS_CODE = "isCode";
  @SerializedName(SERIALIZED_NAME_IS_CODE)
  private Boolean isCode;

  public static final String SERIALIZED_NAME_IS_FALLBACK = "isFallback";
  @SerializedName(SERIALIZED_NAME_IS_FALLBACK)
  private Boolean isFallback;

  public static final String SERIALIZED_NAME_LANGID_RESULT = "langidResult";
  @SerializedName(SERIALIZED_NAME_LANGID_RESULT)
  private NlpSaftLangIdResult langidResult;

  public static final String SERIALIZED_NAME_LANGUAGE = "language";
  @SerializedName(SERIALIZED_NAME_LANGUAGE)
  private String language;

  public static final String SERIALIZED_NAME_LM_PREFIX = "lmPrefix";
  @SerializedName(SERIALIZED_NAME_LM_PREFIX)
  private String lmPrefix;

  public static final String SERIALIZED_NAME_ORIGINAL_TEXT = "originalText";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_TEXT)
  private String originalText;

  public static final String SERIALIZED_NAME_PER_STREAM_DECODED_TOKEN_COUNT = "perStreamDecodedTokenCount";
  @SerializedName(SERIALIZED_NAME_PER_STREAM_DECODED_TOKEN_COUNT)
  private Integer perStreamDecodedTokenCount;

  public static final String SERIALIZED_NAME_RAI_OUTPUTS = "raiOutputs";
  @SerializedName(SERIALIZED_NAME_RAI_OUTPUTS)
  private List<LearningGenaiRootRAIOutput> raiOutputs = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECITATION_RESULT = "recitationResult";
  @SerializedName(SERIALIZED_NAME_RECITATION_RESULT)
  private LearningGenaiRecitationRecitationResult recitationResult;

  public static final String SERIALIZED_NAME_RETURN_TOKEN_COUNT = "returnTokenCount";
  @SerializedName(SERIALIZED_NAME_RETURN_TOKEN_COUNT)
  private Integer returnTokenCount;

  public static final String SERIALIZED_NAME_SCORES = "scores";
  @SerializedName(SERIALIZED_NAME_SCORES)
  private List<LearningGenaiRootScore> scores = new ArrayList<>();

  public static final String SERIALIZED_NAME_STREAM_TERMINATED = "streamTerminated";
  @SerializedName(SERIALIZED_NAME_STREAM_TERMINATED)
  private Boolean streamTerminated;

  public static final String SERIALIZED_NAME_TOTAL_DECODED_TOKEN_COUNT = "totalDecodedTokenCount";
  @SerializedName(SERIALIZED_NAME_TOTAL_DECODED_TOKEN_COUNT)
  private Integer totalDecodedTokenCount;

  public static final String SERIALIZED_NAME_TRANSLATED_USER_PROMPTS = "translatedUserPrompts";
  @SerializedName(SERIALIZED_NAME_TRANSLATED_USER_PROMPTS)
  private List<String> translatedUserPrompts = new ArrayList<>();

  public static final String SERIALIZED_NAME_VERTEX_RAI_RESULT = "vertexRaiResult";
  @SerializedName(SERIALIZED_NAME_VERTEX_RAI_RESULT)
  private CloudAiNlLlmProtoServiceRaiResult vertexRaiResult;

  public LearningServingLlmMessageMetadata() {
  }

  public LearningServingLlmMessageMetadata classifierSummary(LearningGenaiRootClassifierOutputSummary classifierSummary) {
    this.classifierSummary = classifierSummary;
    return this;
  }

  /**
   * Get classifierSummary
   * @return classifierSummary
   */
  @javax.annotation.Nullable
  public LearningGenaiRootClassifierOutputSummary getClassifierSummary() {
    return classifierSummary;
  }

  public void setClassifierSummary(LearningGenaiRootClassifierOutputSummary classifierSummary) {
    this.classifierSummary = classifierSummary;
  }


  public LearningServingLlmMessageMetadata codeyOutput(LearningGenaiRootCodeyOutput codeyOutput) {
    this.codeyOutput = codeyOutput;
    return this;
  }

  /**
   * Get codeyOutput
   * @return codeyOutput
   */
  @javax.annotation.Nullable
  public LearningGenaiRootCodeyOutput getCodeyOutput() {
    return codeyOutput;
  }

  public void setCodeyOutput(LearningGenaiRootCodeyOutput codeyOutput) {
    this.codeyOutput = codeyOutput;
  }


  public LearningServingLlmMessageMetadata currentStreamTextLength(Integer currentStreamTextLength) {
    this.currentStreamTextLength = currentStreamTextLength;
    return this;
  }

  /**
   * Get currentStreamTextLength
   * @return currentStreamTextLength
   */
  @javax.annotation.Nullable
  public Integer getCurrentStreamTextLength() {
    return currentStreamTextLength;
  }

  public void setCurrentStreamTextLength(Integer currentStreamTextLength) {
    this.currentStreamTextLength = currentStreamTextLength;
  }


  public LearningServingLlmMessageMetadata deleted(Boolean deleted) {
    this.deleted = deleted;
    return this;
  }

  /**
   * Whether the corresponding message has been deleted.
   * @return deleted
   */
  @javax.annotation.Nullable
  public Boolean getDeleted() {
    return deleted;
  }

  public void setDeleted(Boolean deleted) {
    this.deleted = deleted;
  }


  public LearningServingLlmMessageMetadata filterMeta(List<LearningGenaiRootFilterMetadata> filterMeta) {
    this.filterMeta = filterMeta;
    return this;
  }

  public LearningServingLlmMessageMetadata addFilterMetaItem(LearningGenaiRootFilterMetadata filterMetaItem) {
    if (this.filterMeta == null) {
      this.filterMeta = new ArrayList<>();
    }
    this.filterMeta.add(filterMetaItem);
    return this;
  }

  /**
   * Metadata for filters that triggered.
   * @return filterMeta
   */
  @javax.annotation.Nullable
  public List<LearningGenaiRootFilterMetadata> getFilterMeta() {
    return filterMeta;
  }

  public void setFilterMeta(List<LearningGenaiRootFilterMetadata> filterMeta) {
    this.filterMeta = filterMeta;
  }


  public LearningServingLlmMessageMetadata finalMessageScore(LearningGenaiRootScore finalMessageScore) {
    this.finalMessageScore = finalMessageScore;
    return this;
  }

  /**
   * Get finalMessageScore
   * @return finalMessageScore
   */
  @javax.annotation.Nullable
  public LearningGenaiRootScore getFinalMessageScore() {
    return finalMessageScore;
  }

  public void setFinalMessageScore(LearningGenaiRootScore finalMessageScore) {
    this.finalMessageScore = finalMessageScore;
  }


  public LearningServingLlmMessageMetadata finishReason(FinishReasonEnum finishReason) {
    this.finishReason = finishReason;
    return this;
  }

  /**
   * NOT YET IMPLEMENTED.
   * @return finishReason
   */
  @javax.annotation.Nullable
  public FinishReasonEnum getFinishReason() {
    return finishReason;
  }

  public void setFinishReason(FinishReasonEnum finishReason) {
    this.finishReason = finishReason;
  }


  public LearningServingLlmMessageMetadata groundingMetadata(LearningGenaiRootGroundingMetadata groundingMetadata) {
    this.groundingMetadata = groundingMetadata;
    return this;
  }

  /**
   * Get groundingMetadata
   * @return groundingMetadata
   */
  @javax.annotation.Nullable
  public LearningGenaiRootGroundingMetadata getGroundingMetadata() {
    return groundingMetadata;
  }

  public void setGroundingMetadata(LearningGenaiRootGroundingMetadata groundingMetadata) {
    this.groundingMetadata = groundingMetadata;
  }


  public LearningServingLlmMessageMetadata isCode(Boolean isCode) {
    this.isCode = isCode;
    return this;
  }

  /**
   * Applies to streaming response message only. Whether the message is a code.
   * @return isCode
   */
  @javax.annotation.Nullable
  public Boolean getIsCode() {
    return isCode;
  }

  public void setIsCode(Boolean isCode) {
    this.isCode = isCode;
  }


  public LearningServingLlmMessageMetadata isFallback(Boolean isFallback) {
    this.isFallback = isFallback;
    return this;
  }

  /**
   * Applies to Response message only. Indicates whether the message is a fallback and the response would have otherwise been empty.
   * @return isFallback
   */
  @javax.annotation.Nullable
  public Boolean getIsFallback() {
    return isFallback;
  }

  public void setIsFallback(Boolean isFallback) {
    this.isFallback = isFallback;
  }


  public LearningServingLlmMessageMetadata langidResult(NlpSaftLangIdResult langidResult) {
    this.langidResult = langidResult;
    return this;
  }

  /**
   * Get langidResult
   * @return langidResult
   */
  @javax.annotation.Nullable
  public NlpSaftLangIdResult getLangidResult() {
    return langidResult;
  }

  public void setLangidResult(NlpSaftLangIdResult langidResult) {
    this.langidResult = langidResult;
  }


  public LearningServingLlmMessageMetadata language(String language) {
    this.language = language;
    return this;
  }

  /**
   * Detected language.
   * @return language
   */
  @javax.annotation.Nullable
  public String getLanguage() {
    return language;
  }

  public void setLanguage(String language) {
    this.language = language;
  }


  public LearningServingLlmMessageMetadata lmPrefix(String lmPrefix) {
    this.lmPrefix = lmPrefix;
    return this;
  }

  /**
   * The LM prefix used to generate this response.
   * @return lmPrefix
   */
  @javax.annotation.Nullable
  public String getLmPrefix() {
    return lmPrefix;
  }

  public void setLmPrefix(String lmPrefix) {
    this.lmPrefix = lmPrefix;
  }


  public LearningServingLlmMessageMetadata originalText(String originalText) {
    this.originalText = originalText;
    return this;
  }

  /**
   * The original text generated by LLM. This is the raw output for debugging purposes.
   * @return originalText
   */
  @javax.annotation.Nullable
  public String getOriginalText() {
    return originalText;
  }

  public void setOriginalText(String originalText) {
    this.originalText = originalText;
  }


  public LearningServingLlmMessageMetadata perStreamDecodedTokenCount(Integer perStreamDecodedTokenCount) {
    this.perStreamDecodedTokenCount = perStreamDecodedTokenCount;
    return this;
  }

  /**
   * NOT YET IMPLEMENTED. Applies to streaming only. Number of tokens decoded / emitted by the model as part of this stream. This may be different from token_count, which contains number of tokens returned in this response after any response rewriting / truncation.
   * @return perStreamDecodedTokenCount
   */
  @javax.annotation.Nullable
  public Integer getPerStreamDecodedTokenCount() {
    return perStreamDecodedTokenCount;
  }

  public void setPerStreamDecodedTokenCount(Integer perStreamDecodedTokenCount) {
    this.perStreamDecodedTokenCount = perStreamDecodedTokenCount;
  }


  public LearningServingLlmMessageMetadata raiOutputs(List<LearningGenaiRootRAIOutput> raiOutputs) {
    this.raiOutputs = raiOutputs;
    return this;
  }

  public LearningServingLlmMessageMetadata addRaiOutputsItem(LearningGenaiRootRAIOutput raiOutputsItem) {
    if (this.raiOutputs == null) {
      this.raiOutputs = new ArrayList<>();
    }
    this.raiOutputs.add(raiOutputsItem);
    return this;
  }

  /**
   * Results of running RAI on the query or this response candidate. One output per rai_config. It will be populated regardless of whether the threshold is exceeded or not.
   * @return raiOutputs
   */
  @javax.annotation.Nullable
  public List<LearningGenaiRootRAIOutput> getRaiOutputs() {
    return raiOutputs;
  }

  public void setRaiOutputs(List<LearningGenaiRootRAIOutput> raiOutputs) {
    this.raiOutputs = raiOutputs;
  }


  public LearningServingLlmMessageMetadata recitationResult(LearningGenaiRecitationRecitationResult recitationResult) {
    this.recitationResult = recitationResult;
    return this;
  }

  /**
   * Get recitationResult
   * @return recitationResult
   */
  @javax.annotation.Nullable
  public LearningGenaiRecitationRecitationResult getRecitationResult() {
    return recitationResult;
  }

  public void setRecitationResult(LearningGenaiRecitationRecitationResult recitationResult) {
    this.recitationResult = recitationResult;
  }


  public LearningServingLlmMessageMetadata returnTokenCount(Integer returnTokenCount) {
    this.returnTokenCount = returnTokenCount;
    return this;
  }

  /**
   * NOT YET IMPLEMENTED. Number of tokens returned as part of this candidate.
   * @return returnTokenCount
   */
  @javax.annotation.Nullable
  public Integer getReturnTokenCount() {
    return returnTokenCount;
  }

  public void setReturnTokenCount(Integer returnTokenCount) {
    this.returnTokenCount = returnTokenCount;
  }


  public LearningServingLlmMessageMetadata scores(List<LearningGenaiRootScore> scores) {
    this.scores = scores;
    return this;
  }

  public LearningServingLlmMessageMetadata addScoresItem(LearningGenaiRootScore scoresItem) {
    if (this.scores == null) {
      this.scores = new ArrayList<>();
    }
    this.scores.add(scoresItem);
    return this;
  }

  /**
   * All the different scores for a message are logged here.
   * @return scores
   */
  @javax.annotation.Nullable
  public List<LearningGenaiRootScore> getScores() {
    return scores;
  }

  public void setScores(List<LearningGenaiRootScore> scores) {
    this.scores = scores;
  }


  public LearningServingLlmMessageMetadata streamTerminated(Boolean streamTerminated) {
    this.streamTerminated = streamTerminated;
    return this;
  }

  /**
   * Whether the response is terminated during streaming return. Only used for streaming requests.
   * @return streamTerminated
   */
  @javax.annotation.Nullable
  public Boolean getStreamTerminated() {
    return streamTerminated;
  }

  public void setStreamTerminated(Boolean streamTerminated) {
    this.streamTerminated = streamTerminated;
  }


  public LearningServingLlmMessageMetadata totalDecodedTokenCount(Integer totalDecodedTokenCount) {
    this.totalDecodedTokenCount = totalDecodedTokenCount;
    return this;
  }

  /**
   * NOT YET IMPLEMENTED. Aggregated number of total tokens decoded so far. For streaming, this is sum of all the tokens decoded so far i.e. aggregated count.
   * @return totalDecodedTokenCount
   */
  @javax.annotation.Nullable
  public Integer getTotalDecodedTokenCount() {
    return totalDecodedTokenCount;
  }

  public void setTotalDecodedTokenCount(Integer totalDecodedTokenCount) {
    this.totalDecodedTokenCount = totalDecodedTokenCount;
  }


  public LearningServingLlmMessageMetadata translatedUserPrompts(List<String> translatedUserPrompts) {
    this.translatedUserPrompts = translatedUserPrompts;
    return this;
  }

  public LearningServingLlmMessageMetadata addTranslatedUserPromptsItem(String translatedUserPromptsItem) {
    if (this.translatedUserPrompts == null) {
      this.translatedUserPrompts = new ArrayList<>();
    }
    this.translatedUserPrompts.add(translatedUserPromptsItem);
    return this;
  }

  /**
   * Translated user-prompt used for RAI post processing. This is for internal processing only. We will translate in pre-processor and pass the translated text to the post processor using this field. It will be empty if non of the signals requested need translation.
   * @return translatedUserPrompts
   */
  @javax.annotation.Nullable
  public List<String> getTranslatedUserPrompts() {
    return translatedUserPrompts;
  }

  public void setTranslatedUserPrompts(List<String> translatedUserPrompts) {
    this.translatedUserPrompts = translatedUserPrompts;
  }


  public LearningServingLlmMessageMetadata vertexRaiResult(CloudAiNlLlmProtoServiceRaiResult vertexRaiResult) {
    this.vertexRaiResult = vertexRaiResult;
    return this;
  }

  /**
   * Get vertexRaiResult
   * @return vertexRaiResult
   */
  @javax.annotation.Nullable
  public CloudAiNlLlmProtoServiceRaiResult getVertexRaiResult() {
    return vertexRaiResult;
  }

  public void setVertexRaiResult(CloudAiNlLlmProtoServiceRaiResult vertexRaiResult) {
    this.vertexRaiResult = vertexRaiResult;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LearningServingLlmMessageMetadata learningServingLlmMessageMetadata = (LearningServingLlmMessageMetadata) o;
    return Objects.equals(this.classifierSummary, learningServingLlmMessageMetadata.classifierSummary) &&
        Objects.equals(this.codeyOutput, learningServingLlmMessageMetadata.codeyOutput) &&
        Objects.equals(this.currentStreamTextLength, learningServingLlmMessageMetadata.currentStreamTextLength) &&
        Objects.equals(this.deleted, learningServingLlmMessageMetadata.deleted) &&
        Objects.equals(this.filterMeta, learningServingLlmMessageMetadata.filterMeta) &&
        Objects.equals(this.finalMessageScore, learningServingLlmMessageMetadata.finalMessageScore) &&
        Objects.equals(this.finishReason, learningServingLlmMessageMetadata.finishReason) &&
        Objects.equals(this.groundingMetadata, learningServingLlmMessageMetadata.groundingMetadata) &&
        Objects.equals(this.isCode, learningServingLlmMessageMetadata.isCode) &&
        Objects.equals(this.isFallback, learningServingLlmMessageMetadata.isFallback) &&
        Objects.equals(this.langidResult, learningServingLlmMessageMetadata.langidResult) &&
        Objects.equals(this.language, learningServingLlmMessageMetadata.language) &&
        Objects.equals(this.lmPrefix, learningServingLlmMessageMetadata.lmPrefix) &&
        Objects.equals(this.originalText, learningServingLlmMessageMetadata.originalText) &&
        Objects.equals(this.perStreamDecodedTokenCount, learningServingLlmMessageMetadata.perStreamDecodedTokenCount) &&
        Objects.equals(this.raiOutputs, learningServingLlmMessageMetadata.raiOutputs) &&
        Objects.equals(this.recitationResult, learningServingLlmMessageMetadata.recitationResult) &&
        Objects.equals(this.returnTokenCount, learningServingLlmMessageMetadata.returnTokenCount) &&
        Objects.equals(this.scores, learningServingLlmMessageMetadata.scores) &&
        Objects.equals(this.streamTerminated, learningServingLlmMessageMetadata.streamTerminated) &&
        Objects.equals(this.totalDecodedTokenCount, learningServingLlmMessageMetadata.totalDecodedTokenCount) &&
        Objects.equals(this.translatedUserPrompts, learningServingLlmMessageMetadata.translatedUserPrompts) &&
        Objects.equals(this.vertexRaiResult, learningServingLlmMessageMetadata.vertexRaiResult);
  }

  @Override
  public int hashCode() {
    return Objects.hash(classifierSummary, codeyOutput, currentStreamTextLength, deleted, filterMeta, finalMessageScore, finishReason, groundingMetadata, isCode, isFallback, langidResult, language, lmPrefix, originalText, perStreamDecodedTokenCount, raiOutputs, recitationResult, returnTokenCount, scores, streamTerminated, totalDecodedTokenCount, translatedUserPrompts, vertexRaiResult);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LearningServingLlmMessageMetadata {\n");
    sb.append("    classifierSummary: ").append(toIndentedString(classifierSummary)).append("\n");
    sb.append("    codeyOutput: ").append(toIndentedString(codeyOutput)).append("\n");
    sb.append("    currentStreamTextLength: ").append(toIndentedString(currentStreamTextLength)).append("\n");
    sb.append("    deleted: ").append(toIndentedString(deleted)).append("\n");
    sb.append("    filterMeta: ").append(toIndentedString(filterMeta)).append("\n");
    sb.append("    finalMessageScore: ").append(toIndentedString(finalMessageScore)).append("\n");
    sb.append("    finishReason: ").append(toIndentedString(finishReason)).append("\n");
    sb.append("    groundingMetadata: ").append(toIndentedString(groundingMetadata)).append("\n");
    sb.append("    isCode: ").append(toIndentedString(isCode)).append("\n");
    sb.append("    isFallback: ").append(toIndentedString(isFallback)).append("\n");
    sb.append("    langidResult: ").append(toIndentedString(langidResult)).append("\n");
    sb.append("    language: ").append(toIndentedString(language)).append("\n");
    sb.append("    lmPrefix: ").append(toIndentedString(lmPrefix)).append("\n");
    sb.append("    originalText: ").append(toIndentedString(originalText)).append("\n");
    sb.append("    perStreamDecodedTokenCount: ").append(toIndentedString(perStreamDecodedTokenCount)).append("\n");
    sb.append("    raiOutputs: ").append(toIndentedString(raiOutputs)).append("\n");
    sb.append("    recitationResult: ").append(toIndentedString(recitationResult)).append("\n");
    sb.append("    returnTokenCount: ").append(toIndentedString(returnTokenCount)).append("\n");
    sb.append("    scores: ").append(toIndentedString(scores)).append("\n");
    sb.append("    streamTerminated: ").append(toIndentedString(streamTerminated)).append("\n");
    sb.append("    totalDecodedTokenCount: ").append(toIndentedString(totalDecodedTokenCount)).append("\n");
    sb.append("    translatedUserPrompts: ").append(toIndentedString(translatedUserPrompts)).append("\n");
    sb.append("    vertexRaiResult: ").append(toIndentedString(vertexRaiResult)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("classifierSummary");
    openapiFields.add("codeyOutput");
    openapiFields.add("currentStreamTextLength");
    openapiFields.add("deleted");
    openapiFields.add("filterMeta");
    openapiFields.add("finalMessageScore");
    openapiFields.add("finishReason");
    openapiFields.add("groundingMetadata");
    openapiFields.add("isCode");
    openapiFields.add("isFallback");
    openapiFields.add("langidResult");
    openapiFields.add("language");
    openapiFields.add("lmPrefix");
    openapiFields.add("originalText");
    openapiFields.add("perStreamDecodedTokenCount");
    openapiFields.add("raiOutputs");
    openapiFields.add("recitationResult");
    openapiFields.add("returnTokenCount");
    openapiFields.add("scores");
    openapiFields.add("streamTerminated");
    openapiFields.add("totalDecodedTokenCount");
    openapiFields.add("translatedUserPrompts");
    openapiFields.add("vertexRaiResult");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LearningServingLlmMessageMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LearningServingLlmMessageMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LearningServingLlmMessageMetadata is not found in the empty JSON string", LearningServingLlmMessageMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LearningServingLlmMessageMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LearningServingLlmMessageMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `classifierSummary`
      if (jsonObj.get("classifierSummary") != null && !jsonObj.get("classifierSummary").isJsonNull()) {
        LearningGenaiRootClassifierOutputSummary.validateJsonElement(jsonObj.get("classifierSummary"));
      }
      // validate the optional field `codeyOutput`
      if (jsonObj.get("codeyOutput") != null && !jsonObj.get("codeyOutput").isJsonNull()) {
        LearningGenaiRootCodeyOutput.validateJsonElement(jsonObj.get("codeyOutput"));
      }
      if (jsonObj.get("filterMeta") != null && !jsonObj.get("filterMeta").isJsonNull()) {
        JsonArray jsonArrayfilterMeta = jsonObj.getAsJsonArray("filterMeta");
        if (jsonArrayfilterMeta != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filterMeta").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filterMeta` to be an array in the JSON string but got `%s`", jsonObj.get("filterMeta").toString()));
          }

          // validate the optional field `filterMeta` (array)
          for (int i = 0; i < jsonArrayfilterMeta.size(); i++) {
            LearningGenaiRootFilterMetadata.validateJsonElement(jsonArrayfilterMeta.get(i));
          };
        }
      }
      // validate the optional field `finalMessageScore`
      if (jsonObj.get("finalMessageScore") != null && !jsonObj.get("finalMessageScore").isJsonNull()) {
        LearningGenaiRootScore.validateJsonElement(jsonObj.get("finalMessageScore"));
      }
      if ((jsonObj.get("finishReason") != null && !jsonObj.get("finishReason").isJsonNull()) && !jsonObj.get("finishReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `finishReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("finishReason").toString()));
      }
      // validate the optional field `finishReason`
      if (jsonObj.get("finishReason") != null && !jsonObj.get("finishReason").isJsonNull()) {
        FinishReasonEnum.validateJsonElement(jsonObj.get("finishReason"));
      }
      // validate the optional field `groundingMetadata`
      if (jsonObj.get("groundingMetadata") != null && !jsonObj.get("groundingMetadata").isJsonNull()) {
        LearningGenaiRootGroundingMetadata.validateJsonElement(jsonObj.get("groundingMetadata"));
      }
      // validate the optional field `langidResult`
      if (jsonObj.get("langidResult") != null && !jsonObj.get("langidResult").isJsonNull()) {
        NlpSaftLangIdResult.validateJsonElement(jsonObj.get("langidResult"));
      }
      if ((jsonObj.get("language") != null && !jsonObj.get("language").isJsonNull()) && !jsonObj.get("language").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `language` to be a primitive type in the JSON string but got `%s`", jsonObj.get("language").toString()));
      }
      if ((jsonObj.get("lmPrefix") != null && !jsonObj.get("lmPrefix").isJsonNull()) && !jsonObj.get("lmPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lmPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lmPrefix").toString()));
      }
      if ((jsonObj.get("originalText") != null && !jsonObj.get("originalText").isJsonNull()) && !jsonObj.get("originalText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalText").toString()));
      }
      if (jsonObj.get("raiOutputs") != null && !jsonObj.get("raiOutputs").isJsonNull()) {
        JsonArray jsonArrayraiOutputs = jsonObj.getAsJsonArray("raiOutputs");
        if (jsonArrayraiOutputs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("raiOutputs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `raiOutputs` to be an array in the JSON string but got `%s`", jsonObj.get("raiOutputs").toString()));
          }

          // validate the optional field `raiOutputs` (array)
          for (int i = 0; i < jsonArrayraiOutputs.size(); i++) {
            LearningGenaiRootRAIOutput.validateJsonElement(jsonArrayraiOutputs.get(i));
          };
        }
      }
      // validate the optional field `recitationResult`
      if (jsonObj.get("recitationResult") != null && !jsonObj.get("recitationResult").isJsonNull()) {
        LearningGenaiRecitationRecitationResult.validateJsonElement(jsonObj.get("recitationResult"));
      }
      if (jsonObj.get("scores") != null && !jsonObj.get("scores").isJsonNull()) {
        JsonArray jsonArrayscores = jsonObj.getAsJsonArray("scores");
        if (jsonArrayscores != null) {
          // ensure the json data is an array
          if (!jsonObj.get("scores").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `scores` to be an array in the JSON string but got `%s`", jsonObj.get("scores").toString()));
          }

          // validate the optional field `scores` (array)
          for (int i = 0; i < jsonArrayscores.size(); i++) {
            LearningGenaiRootScore.validateJsonElement(jsonArrayscores.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("translatedUserPrompts") != null && !jsonObj.get("translatedUserPrompts").isJsonNull() && !jsonObj.get("translatedUserPrompts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `translatedUserPrompts` to be an array in the JSON string but got `%s`", jsonObj.get("translatedUserPrompts").toString()));
      }
      // validate the optional field `vertexRaiResult`
      if (jsonObj.get("vertexRaiResult") != null && !jsonObj.get("vertexRaiResult").isJsonNull()) {
        CloudAiNlLlmProtoServiceRaiResult.validateJsonElement(jsonObj.get("vertexRaiResult"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LearningServingLlmMessageMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LearningServingLlmMessageMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LearningServingLlmMessageMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LearningServingLlmMessageMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<LearningServingLlmMessageMetadata>() {
           @Override
           public void write(JsonWriter out, LearningServingLlmMessageMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LearningServingLlmMessageMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LearningServingLlmMessageMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LearningServingLlmMessageMetadata
   * @throws IOException if the JSON string is invalid with respect to LearningServingLlmMessageMetadata
   */
  public static LearningServingLlmMessageMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LearningServingLlmMessageMetadata.class);
  }

  /**
   * Convert an instance of LearningServingLlmMessageMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

