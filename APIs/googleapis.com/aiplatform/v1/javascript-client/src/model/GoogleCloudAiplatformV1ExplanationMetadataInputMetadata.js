/**
 * Vertex AI API
 * Train high-quality custom machine learning models with minimal machine learning expertise and effort.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain from './GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain';
import GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization from './GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization';

/**
 * The GoogleCloudAiplatformV1ExplanationMetadataInputMetadata model module.
 * @module model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadata
 * @version v1
 */
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadata {
    /**
     * Constructs a new <code>GoogleCloudAiplatformV1ExplanationMetadataInputMetadata</code>.
     * Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
     * @alias module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadata
     */
    constructor() { 
        
        GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>GoogleCloudAiplatformV1ExplanationMetadataInputMetadata</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadata} obj Optional instance to populate.
     * @return {module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadata} The populated <code>GoogleCloudAiplatformV1ExplanationMetadataInputMetadata</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new GoogleCloudAiplatformV1ExplanationMetadataInputMetadata();

            if (data.hasOwnProperty('denseShapeTensorName')) {
                obj['denseShapeTensorName'] = ApiClient.convertToType(data['denseShapeTensorName'], 'String');
            }
            if (data.hasOwnProperty('encodedBaselines')) {
                obj['encodedBaselines'] = ApiClient.convertToType(data['encodedBaselines'], [Object]);
            }
            if (data.hasOwnProperty('encodedTensorName')) {
                obj['encodedTensorName'] = ApiClient.convertToType(data['encodedTensorName'], 'String');
            }
            if (data.hasOwnProperty('encoding')) {
                obj['encoding'] = ApiClient.convertToType(data['encoding'], 'String');
            }
            if (data.hasOwnProperty('featureValueDomain')) {
                obj['featureValueDomain'] = GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain.constructFromObject(data['featureValueDomain']);
            }
            if (data.hasOwnProperty('groupName')) {
                obj['groupName'] = ApiClient.convertToType(data['groupName'], 'String');
            }
            if (data.hasOwnProperty('indexFeatureMapping')) {
                obj['indexFeatureMapping'] = ApiClient.convertToType(data['indexFeatureMapping'], ['String']);
            }
            if (data.hasOwnProperty('indicesTensorName')) {
                obj['indicesTensorName'] = ApiClient.convertToType(data['indicesTensorName'], 'String');
            }
            if (data.hasOwnProperty('inputBaselines')) {
                obj['inputBaselines'] = ApiClient.convertToType(data['inputBaselines'], [Object]);
            }
            if (data.hasOwnProperty('inputTensorName')) {
                obj['inputTensorName'] = ApiClient.convertToType(data['inputTensorName'], 'String');
            }
            if (data.hasOwnProperty('modality')) {
                obj['modality'] = ApiClient.convertToType(data['modality'], 'String');
            }
            if (data.hasOwnProperty('visualization')) {
                obj['visualization'] = GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization.constructFromObject(data['visualization']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>GoogleCloudAiplatformV1ExplanationMetadataInputMetadata</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>GoogleCloudAiplatformV1ExplanationMetadataInputMetadata</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['denseShapeTensorName'] && !(typeof data['denseShapeTensorName'] === 'string' || data['denseShapeTensorName'] instanceof String)) {
            throw new Error("Expected the field `denseShapeTensorName` to be a primitive type in the JSON string but got " + data['denseShapeTensorName']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['encodedBaselines'])) {
            throw new Error("Expected the field `encodedBaselines` to be an array in the JSON data but got " + data['encodedBaselines']);
        }
        // ensure the json data is a string
        if (data['encodedTensorName'] && !(typeof data['encodedTensorName'] === 'string' || data['encodedTensorName'] instanceof String)) {
            throw new Error("Expected the field `encodedTensorName` to be a primitive type in the JSON string but got " + data['encodedTensorName']);
        }
        // ensure the json data is a string
        if (data['encoding'] && !(typeof data['encoding'] === 'string' || data['encoding'] instanceof String)) {
            throw new Error("Expected the field `encoding` to be a primitive type in the JSON string but got " + data['encoding']);
        }
        // validate the optional field `featureValueDomain`
        if (data['featureValueDomain']) { // data not null
          GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain.validateJSON(data['featureValueDomain']);
        }
        // ensure the json data is a string
        if (data['groupName'] && !(typeof data['groupName'] === 'string' || data['groupName'] instanceof String)) {
            throw new Error("Expected the field `groupName` to be a primitive type in the JSON string but got " + data['groupName']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['indexFeatureMapping'])) {
            throw new Error("Expected the field `indexFeatureMapping` to be an array in the JSON data but got " + data['indexFeatureMapping']);
        }
        // ensure the json data is a string
        if (data['indicesTensorName'] && !(typeof data['indicesTensorName'] === 'string' || data['indicesTensorName'] instanceof String)) {
            throw new Error("Expected the field `indicesTensorName` to be a primitive type in the JSON string but got " + data['indicesTensorName']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['inputBaselines'])) {
            throw new Error("Expected the field `inputBaselines` to be an array in the JSON data but got " + data['inputBaselines']);
        }
        // ensure the json data is a string
        if (data['inputTensorName'] && !(typeof data['inputTensorName'] === 'string' || data['inputTensorName'] instanceof String)) {
            throw new Error("Expected the field `inputTensorName` to be a primitive type in the JSON string but got " + data['inputTensorName']);
        }
        // ensure the json data is a string
        if (data['modality'] && !(typeof data['modality'] === 'string' || data['modality'] instanceof String)) {
            throw new Error("Expected the field `modality` to be a primitive type in the JSON string but got " + data['modality']);
        }
        // validate the optional field `visualization`
        if (data['visualization']) { // data not null
          GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization.validateJSON(data['visualization']);
        }

        return true;
    }


}



/**
 * Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
 * @member {String} denseShapeTensorName
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['denseShapeTensorName'] = undefined;

/**
 * A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
 * @member {Array.<Object>} encodedBaselines
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['encodedBaselines'] = undefined;

/**
 * Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
 * @member {String} encodedTensorName
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['encodedTensorName'] = undefined;

/**
 * Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
 * @member {module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.EncodingEnum} encoding
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['encoding'] = undefined;

/**
 * @member {module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain} featureValueDomain
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['featureValueDomain'] = undefined;

/**
 * Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
 * @member {String} groupName
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['groupName'] = undefined;

/**
 * A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
 * @member {Array.<String>} indexFeatureMapping
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['indexFeatureMapping'] = undefined;

/**
 * Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
 * @member {String} indicesTensorName
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['indicesTensorName'] = undefined;

/**
 * Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature's input in the instance[]. The schema of any single instance may be specified via Endpoint's DeployedModels' Model's PredictSchemata's instance_schema_uri.
 * @member {Array.<Object>} inputBaselines
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['inputBaselines'] = undefined;

/**
 * Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
 * @member {String} inputTensorName
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['inputTensorName'] = undefined;

/**
 * Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
 * @member {String} modality
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['modality'] = undefined;

/**
 * @member {module:model/GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization} visualization
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.prototype['visualization'] = undefined;





/**
 * Allowed values for the <code>encoding</code> property.
 * @enum {String}
 * @readonly
 */
GoogleCloudAiplatformV1ExplanationMetadataInputMetadata['EncodingEnum'] = {

    /**
     * value: "ENCODING_UNSPECIFIED"
     * @const
     */
    "ENCODING_UNSPECIFIED": "ENCODING_UNSPECIFIED",

    /**
     * value: "IDENTITY"
     * @const
     */
    "IDENTITY": "IDENTITY",

    /**
     * value: "BAG_OF_FEATURES"
     * @const
     */
    "BAG_OF_FEATURES": "BAG_OF_FEATURES",

    /**
     * value: "BAG_OF_FEATURES_SPARSE"
     * @const
     */
    "BAG_OF_FEATURES_SPARSE": "BAG_OF_FEATURES_SPARSE",

    /**
     * value: "INDICATOR"
     * @const
     */
    "INDICATOR": "INDICATOR",

    /**
     * value: "COMBINED_EMBEDDING"
     * @const
     */
    "COMBINED_EMBEDDING": "COMBINED_EMBEDDING",

    /**
     * value: "CONCAT_EMBEDDING"
     * @const
     */
    "CONCAT_EMBEDDING": "CONCAT_EMBEDDING"
};



export default GoogleCloudAiplatformV1ExplanationMetadataInputMetadata;

