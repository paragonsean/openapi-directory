# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class NetworkConfig(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, connect_mode: str=None, ip_addresses: List[str]=None, modes: List[str]=None, network: str=None, reserved_ip_range: str=None):
        """NetworkConfig - a model defined in OpenAPI

        :param connect_mode: The connect_mode of this NetworkConfig.
        :param ip_addresses: The ip_addresses of this NetworkConfig.
        :param modes: The modes of this NetworkConfig.
        :param network: The network of this NetworkConfig.
        :param reserved_ip_range: The reserved_ip_range of this NetworkConfig.
        """
        self.openapi_types = {
            'connect_mode': str,
            'ip_addresses': List[str],
            'modes': List[str],
            'network': str,
            'reserved_ip_range': str
        }

        self.attribute_map = {
            'connect_mode': 'connectMode',
            'ip_addresses': 'ipAddresses',
            'modes': 'modes',
            'network': 'network',
            'reserved_ip_range': 'reservedIpRange'
        }

        self._connect_mode = connect_mode
        self._ip_addresses = ip_addresses
        self._modes = modes
        self._network = network
        self._reserved_ip_range = reserved_ip_range

    @classmethod
    def from_dict(cls, dikt: dict) -> 'NetworkConfig':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The NetworkConfig of this NetworkConfig.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def connect_mode(self):
        """Gets the connect_mode of this NetworkConfig.

        The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING.

        :return: The connect_mode of this NetworkConfig.
        :rtype: str
        """
        return self._connect_mode

    @connect_mode.setter
    def connect_mode(self, connect_mode):
        """Sets the connect_mode of this NetworkConfig.

        The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING.

        :param connect_mode: The connect_mode of this NetworkConfig.
        :type connect_mode: str
        """
        allowed_values = ["CONNECT_MODE_UNSPECIFIED", "DIRECT_PEERING", "PRIVATE_SERVICE_ACCESS"]  # noqa: E501
        if connect_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `connect_mode` ({0}), must be one of {1}"
                .format(connect_mode, allowed_values)
            )

        self._connect_mode = connect_mode

    @property
    def ip_addresses(self):
        """Gets the ip_addresses of this NetworkConfig.

        Output only. IPv4 addresses in the format `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.

        :return: The ip_addresses of this NetworkConfig.
        :rtype: List[str]
        """
        return self._ip_addresses

    @ip_addresses.setter
    def ip_addresses(self, ip_addresses):
        """Sets the ip_addresses of this NetworkConfig.

        Output only. IPv4 addresses in the format `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.

        :param ip_addresses: The ip_addresses of this NetworkConfig.
        :type ip_addresses: List[str]
        """

        self._ip_addresses = ip_addresses

    @property
    def modes(self):
        """Gets the modes of this NetworkConfig.

        Internet protocol versions for which the instance has IP addresses assigned. For this version, only MODE_IPV4 is supported.

        :return: The modes of this NetworkConfig.
        :rtype: List[str]
        """
        return self._modes

    @modes.setter
    def modes(self, modes):
        """Sets the modes of this NetworkConfig.

        Internet protocol versions for which the instance has IP addresses assigned. For this version, only MODE_IPV4 is supported.

        :param modes: The modes of this NetworkConfig.
        :type modes: List[str]
        """
        allowed_values = ["ADDRESS_MODE_UNSPECIFIED", "MODE_IPV4"]  # noqa: E501
        if not set(modes).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `modes` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(modes) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._modes = modes

    @property
    def network(self):
        """Gets the network of this NetworkConfig.

        The name of the Google Compute Engine [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected.

        :return: The network of this NetworkConfig.
        :rtype: str
        """
        return self._network

    @network.setter
    def network(self, network):
        """Sets the network of this NetworkConfig.

        The name of the Google Compute Engine [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected.

        :param network: The network of this NetworkConfig.
        :type network: str
        """

        self._network = network

    @property
    def reserved_ip_range(self):
        """Gets the reserved_ip_range of this NetworkConfig.

        Optional, reserved_ip_range can have one of the following two types of values. * CIDR range value when using DIRECT_PEERING connect mode. * [Allocated IP address range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address) when using PRIVATE_SERVICE_ACCESS connect mode. When the name of an allocated IP address range is specified, it must be one of the ranges associated with the private service access connection. When specified as a direct CIDR value, it must be a /29 CIDR block for Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for Enterprise tier in one of the [internal IP address ranges](https://www.arin.net/reference/research/statistics/address_filters/) that identifies the range of IP addresses reserved for this instance. For example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The range you specify can't overlap with either existing subnets or assigned IP address ranges for other Filestore instances in the selected VPC network.

        :return: The reserved_ip_range of this NetworkConfig.
        :rtype: str
        """
        return self._reserved_ip_range

    @reserved_ip_range.setter
    def reserved_ip_range(self, reserved_ip_range):
        """Sets the reserved_ip_range of this NetworkConfig.

        Optional, reserved_ip_range can have one of the following two types of values. * CIDR range value when using DIRECT_PEERING connect mode. * [Allocated IP address range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address) when using PRIVATE_SERVICE_ACCESS connect mode. When the name of an allocated IP address range is specified, it must be one of the ranges associated with the private service access connection. When specified as a direct CIDR value, it must be a /29 CIDR block for Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for Enterprise tier in one of the [internal IP address ranges](https://www.arin.net/reference/research/statistics/address_filters/) that identifies the range of IP addresses reserved for this instance. For example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The range you specify can't overlap with either existing subnets or assigned IP address ranges for other Filestore instances in the selected VPC network.

        :param reserved_ip_range: The reserved_ip_range of this NetworkConfig.
        :type reserved_ip_range: str
        """

        self._reserved_ip_range = reserved_ip_range
