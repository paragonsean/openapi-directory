/**
 * Cloud Filestore API
 * The Cloud Filestore API is used for creating and managing cloud file servers.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The NetworkConfig model module.
 * @module model/NetworkConfig
 * @version v1beta1
 */
class NetworkConfig {
    /**
     * Constructs a new <code>NetworkConfig</code>.
     * Network configuration for the instance.
     * @alias module:model/NetworkConfig
     */
    constructor() { 
        
        NetworkConfig.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>NetworkConfig</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/NetworkConfig} obj Optional instance to populate.
     * @return {module:model/NetworkConfig} The populated <code>NetworkConfig</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new NetworkConfig();

            if (data.hasOwnProperty('connectMode')) {
                obj['connectMode'] = ApiClient.convertToType(data['connectMode'], 'String');
            }
            if (data.hasOwnProperty('ipAddresses')) {
                obj['ipAddresses'] = ApiClient.convertToType(data['ipAddresses'], ['String']);
            }
            if (data.hasOwnProperty('modes')) {
                obj['modes'] = ApiClient.convertToType(data['modes'], ['String']);
            }
            if (data.hasOwnProperty('network')) {
                obj['network'] = ApiClient.convertToType(data['network'], 'String');
            }
            if (data.hasOwnProperty('reservedIpRange')) {
                obj['reservedIpRange'] = ApiClient.convertToType(data['reservedIpRange'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>NetworkConfig</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>NetworkConfig</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['connectMode'] && !(typeof data['connectMode'] === 'string' || data['connectMode'] instanceof String)) {
            throw new Error("Expected the field `connectMode` to be a primitive type in the JSON string but got " + data['connectMode']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['ipAddresses'])) {
            throw new Error("Expected the field `ipAddresses` to be an array in the JSON data but got " + data['ipAddresses']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['modes'])) {
            throw new Error("Expected the field `modes` to be an array in the JSON data but got " + data['modes']);
        }
        // ensure the json data is a string
        if (data['network'] && !(typeof data['network'] === 'string' || data['network'] instanceof String)) {
            throw new Error("Expected the field `network` to be a primitive type in the JSON string but got " + data['network']);
        }
        // ensure the json data is a string
        if (data['reservedIpRange'] && !(typeof data['reservedIpRange'] === 'string' || data['reservedIpRange'] instanceof String)) {
            throw new Error("Expected the field `reservedIpRange` to be a primitive type in the JSON string but got " + data['reservedIpRange']);
        }

        return true;
    }


}



/**
 * The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING.
 * @member {module:model/NetworkConfig.ConnectModeEnum} connectMode
 */
NetworkConfig.prototype['connectMode'] = undefined;

/**
 * Output only. IPv4 addresses in the format `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.
 * @member {Array.<String>} ipAddresses
 */
NetworkConfig.prototype['ipAddresses'] = undefined;

/**
 * Internet protocol versions for which the instance has IP addresses assigned. For this version, only MODE_IPV4 is supported.
 * @member {Array.<module:model/NetworkConfig.ModesEnum>} modes
 */
NetworkConfig.prototype['modes'] = undefined;

/**
 * The name of the Google Compute Engine [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected.
 * @member {String} network
 */
NetworkConfig.prototype['network'] = undefined;

/**
 * Optional, reserved_ip_range can have one of the following two types of values. * CIDR range value when using DIRECT_PEERING connect mode. * [Allocated IP address range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address) when using PRIVATE_SERVICE_ACCESS connect mode. When the name of an allocated IP address range is specified, it must be one of the ranges associated with the private service access connection. When specified as a direct CIDR value, it must be a /29 CIDR block for Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for Enterprise tier in one of the [internal IP address ranges](https://www.arin.net/reference/research/statistics/address_filters/) that identifies the range of IP addresses reserved for this instance. For example, 10.0.0.0/29, 192.168.0.0/24, or 192.168.0.0/26, respectively. The range you specify can't overlap with either existing subnets or assigned IP address ranges for other Filestore instances in the selected VPC network.
 * @member {String} reservedIpRange
 */
NetworkConfig.prototype['reservedIpRange'] = undefined;





/**
 * Allowed values for the <code>connectMode</code> property.
 * @enum {String}
 * @readonly
 */
NetworkConfig['ConnectModeEnum'] = {

    /**
     * value: "CONNECT_MODE_UNSPECIFIED"
     * @const
     */
    "CONNECT_MODE_UNSPECIFIED": "CONNECT_MODE_UNSPECIFIED",

    /**
     * value: "DIRECT_PEERING"
     * @const
     */
    "DIRECT_PEERING": "DIRECT_PEERING",

    /**
     * value: "PRIVATE_SERVICE_ACCESS"
     * @const
     */
    "PRIVATE_SERVICE_ACCESS": "PRIVATE_SERVICE_ACCESS"
};


/**
 * Allowed values for the <code>modes</code> property.
 * @enum {String}
 * @readonly
 */
NetworkConfig['ModesEnum'] = {

    /**
     * value: "ADDRESS_MODE_UNSPECIFIED"
     * @const
     */
    "ADDRESS_MODE_UNSPECIFIED": "ADDRESS_MODE_UNSPECIFIED",

    /**
     * value: "MODE_IPV4"
     * @const
     */
    "MODE_IPV4": "MODE_IPV4"
};



export default NetworkConfig;

