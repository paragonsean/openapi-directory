/*
 * Cloud Filestore API
 * The Cloud Filestore API is used for creating and managing cloud file servers.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Network configuration for the instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:18.454461-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NetworkConfig {
  /**
   * The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING.
   */
  @JsonAdapter(ConnectModeEnum.Adapter.class)
  public enum ConnectModeEnum {
    CONNECT_MODE_UNSPECIFIED("CONNECT_MODE_UNSPECIFIED"),
    
    DIRECT_PEERING("DIRECT_PEERING"),
    
    PRIVATE_SERVICE_ACCESS("PRIVATE_SERVICE_ACCESS");

    private String value;

    ConnectModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConnectModeEnum fromValue(String value) {
      for (ConnectModeEnum b : ConnectModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConnectModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConnectModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConnectModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConnectModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ConnectModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONNECT_MODE = "connectMode";
  @SerializedName(SERIALIZED_NAME_CONNECT_MODE)
  private ConnectModeEnum connectMode;

  public static final String SERIALIZED_NAME_IP_ADDRESSES = "ipAddresses";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESSES)
  private List<String> ipAddresses = new ArrayList<>();

  /**
   * Gets or Sets modes
   */
  @JsonAdapter(ModesEnum.Adapter.class)
  public enum ModesEnum {
    ADDRESS_MODE_UNSPECIFIED("ADDRESS_MODE_UNSPECIFIED"),
    
    MODE_IPV4("MODE_IPV4");

    private String value;

    ModesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModesEnum fromValue(String value) {
      for (ModesEnum b : ModesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ModesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ModesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ModesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MODES = "modes";
  @SerializedName(SERIALIZED_NAME_MODES)
  private List<ModesEnum> modes = new ArrayList<>();

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_RESERVED_IP_RANGE = "reservedIpRange";
  @SerializedName(SERIALIZED_NAME_RESERVED_IP_RANGE)
  private String reservedIpRange;

  public NetworkConfig() {
  }

  public NetworkConfig(
     List<String> ipAddresses
  ) {
    this();
    this.ipAddresses = ipAddresses;
  }

  public NetworkConfig connectMode(ConnectModeEnum connectMode) {
    this.connectMode = connectMode;
    return this;
  }

  /**
   * The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING.
   * @return connectMode
   */
  @javax.annotation.Nullable
  public ConnectModeEnum getConnectMode() {
    return connectMode;
  }

  public void setConnectMode(ConnectModeEnum connectMode) {
    this.connectMode = connectMode;
  }


  /**
   * Output only. IPv4 addresses in the format &#x60;{octet1}.{octet2}.{octet3}.{octet4}&#x60; or IPv6 addresses in the format &#x60;{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}&#x60;.
   * @return ipAddresses
   */
  @javax.annotation.Nullable
  public List<String> getIpAddresses() {
    return ipAddresses;
  }



  public NetworkConfig modes(List<ModesEnum> modes) {
    this.modes = modes;
    return this;
  }

  public NetworkConfig addModesItem(ModesEnum modesItem) {
    if (this.modes == null) {
      this.modes = new ArrayList<>();
    }
    this.modes.add(modesItem);
    return this;
  }

  /**
   * Internet protocol versions for which the instance has IP addresses assigned. For this version, only MODE_IPV4 is supported.
   * @return modes
   */
  @javax.annotation.Nullable
  public List<ModesEnum> getModes() {
    return modes;
  }

  public void setModes(List<ModesEnum> modes) {
    this.modes = modes;
  }


  public NetworkConfig network(String network) {
    this.network = network;
    return this;
  }

  /**
   * The name of the Google Compute Engine [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public NetworkConfig reservedIpRange(String reservedIpRange) {
    this.reservedIpRange = reservedIpRange;
    return this;
  }

  /**
   * Optional, reserved_ip_range can have one of the following two types of values. * CIDR range value when using DIRECT_PEERING connect mode. * [Allocated IP address range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address) when using PRIVATE_SERVICE_ACCESS connect mode. When the name of an allocated IP address range is specified, it must be one of the ranges associated with the private service access connection. When specified as a direct CIDR value, it must be a /29 CIDR block for Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for Enterprise tier in one of the [internal IP address ranges](https://www.arin.net/reference/research/statistics/address_filters/) that identifies the range of IP addresses reserved for this instance. For example, 10.0.0.0/29, 192.168.0.0/24, or 192.168.0.0/26, respectively. The range you specify can&#39;t overlap with either existing subnets or assigned IP address ranges for other Filestore instances in the selected VPC network.
   * @return reservedIpRange
   */
  @javax.annotation.Nullable
  public String getReservedIpRange() {
    return reservedIpRange;
  }

  public void setReservedIpRange(String reservedIpRange) {
    this.reservedIpRange = reservedIpRange;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NetworkConfig networkConfig = (NetworkConfig) o;
    return Objects.equals(this.connectMode, networkConfig.connectMode) &&
        Objects.equals(this.ipAddresses, networkConfig.ipAddresses) &&
        Objects.equals(this.modes, networkConfig.modes) &&
        Objects.equals(this.network, networkConfig.network) &&
        Objects.equals(this.reservedIpRange, networkConfig.reservedIpRange);
  }

  @Override
  public int hashCode() {
    return Objects.hash(connectMode, ipAddresses, modes, network, reservedIpRange);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NetworkConfig {\n");
    sb.append("    connectMode: ").append(toIndentedString(connectMode)).append("\n");
    sb.append("    ipAddresses: ").append(toIndentedString(ipAddresses)).append("\n");
    sb.append("    modes: ").append(toIndentedString(modes)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    reservedIpRange: ").append(toIndentedString(reservedIpRange)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("connectMode");
    openapiFields.add("ipAddresses");
    openapiFields.add("modes");
    openapiFields.add("network");
    openapiFields.add("reservedIpRange");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NetworkConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NetworkConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NetworkConfig is not found in the empty JSON string", NetworkConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NetworkConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NetworkConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("connectMode") != null && !jsonObj.get("connectMode").isJsonNull()) && !jsonObj.get("connectMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectMode").toString()));
      }
      // validate the optional field `connectMode`
      if (jsonObj.get("connectMode") != null && !jsonObj.get("connectMode").isJsonNull()) {
        ConnectModeEnum.validateJsonElement(jsonObj.get("connectMode"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ipAddresses") != null && !jsonObj.get("ipAddresses").isJsonNull() && !jsonObj.get("ipAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("ipAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("modes") != null && !jsonObj.get("modes").isJsonNull() && !jsonObj.get("modes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `modes` to be an array in the JSON string but got `%s`", jsonObj.get("modes").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("reservedIpRange") != null && !jsonObj.get("reservedIpRange").isJsonNull()) && !jsonObj.get("reservedIpRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reservedIpRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reservedIpRange").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NetworkConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NetworkConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NetworkConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NetworkConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<NetworkConfig>() {
           @Override
           public void write(JsonWriter out, NetworkConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NetworkConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NetworkConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NetworkConfig
   * @throws IOException if the JSON string is invalid with respect to NetworkConfig
   */
  public static NetworkConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NetworkConfig.class);
  }

  /**
   * Convert an instance of NetworkConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

