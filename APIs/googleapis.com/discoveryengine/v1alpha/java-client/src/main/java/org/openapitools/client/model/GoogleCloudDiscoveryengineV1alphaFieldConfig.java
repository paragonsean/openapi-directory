/*
 * Discovery Engine API
 * Discovery Engine API.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configurations for fields of a schema. For example, configuring a field is indexable, or searchable.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:39.358631-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudDiscoveryengineV1alphaFieldConfig {
  /**
   * If completable_option is COMPLETABLE_ENABLED, field values are directly used and returned as suggestions for Autocomplete in CompletionService.CompleteQuery. If completable_option is unset, the server behavior defaults to COMPLETABLE_DISABLED for fields that support setting completable options, which are just &#x60;string&#x60; fields. For those fields that do not support setting completable options, the server will skip completable option setting, and setting completable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   */
  @JsonAdapter(CompletableOptionEnum.Adapter.class)
  public enum CompletableOptionEnum {
    OPTION_UNSPECIFIED("COMPLETABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("COMPLETABLE_ENABLED"),
    
    DISABLED("COMPLETABLE_DISABLED");

    private String value;

    CompletableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CompletableOptionEnum fromValue(String value) {
      for (CompletableOptionEnum b : CompletableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CompletableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CompletableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CompletableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CompletableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CompletableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMPLETABLE_OPTION = "completableOption";
  @SerializedName(SERIALIZED_NAME_COMPLETABLE_OPTION)
  private CompletableOptionEnum completableOption;

  /**
   * If dynamic_facetable_option is DYNAMIC_FACETABLE_ENABLED, field values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if FieldConfig.indexable_option is INDEXABLE_DISABLED. Otherwise, an &#x60;INVALID_ARGUMENT&#x60; error will be returned. If dynamic_facetable_option is unset, the server behavior defaults to DYNAMIC_FACETABLE_DISABLED for fields that support setting dynamic facetable options. For those fields that do not support setting dynamic facetable options, such as &#x60;object&#x60; and &#x60;boolean&#x60;, the server will skip dynamic facetable option setting, and setting dynamic_facetable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   */
  @JsonAdapter(DynamicFacetableOptionEnum.Adapter.class)
  public enum DynamicFacetableOptionEnum {
    OPTION_UNSPECIFIED("DYNAMIC_FACETABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("DYNAMIC_FACETABLE_ENABLED"),
    
    DISABLED("DYNAMIC_FACETABLE_DISABLED");

    private String value;

    DynamicFacetableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DynamicFacetableOptionEnum fromValue(String value) {
      for (DynamicFacetableOptionEnum b : DynamicFacetableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DynamicFacetableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DynamicFacetableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DynamicFacetableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DynamicFacetableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DynamicFacetableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DYNAMIC_FACETABLE_OPTION = "dynamicFacetableOption";
  @SerializedName(SERIALIZED_NAME_DYNAMIC_FACETABLE_OPTION)
  private DynamicFacetableOptionEnum dynamicFacetableOption;

  public static final String SERIALIZED_NAME_FIELD_PATH = "fieldPath";
  @SerializedName(SERIALIZED_NAME_FIELD_PATH)
  private String fieldPath;

  /**
   * Output only. Raw type of the field.
   */
  @JsonAdapter(FieldTypeEnum.Adapter.class)
  public enum FieldTypeEnum {
    FIELD_TYPE_UNSPECIFIED("FIELD_TYPE_UNSPECIFIED"),
    
    OBJECT("OBJECT"),
    
    STRING("STRING"),
    
    NUMBER("NUMBER"),
    
    INTEGER("INTEGER"),
    
    BOOLEAN("BOOLEAN"),
    
    GEOLOCATION("GEOLOCATION"),
    
    DATETIME("DATETIME");

    private String value;

    FieldTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FieldTypeEnum fromValue(String value) {
      for (FieldTypeEnum b : FieldTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FieldTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FieldTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FieldTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FieldTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FieldTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FIELD_TYPE = "fieldType";
  @SerializedName(SERIALIZED_NAME_FIELD_TYPE)
  private FieldTypeEnum fieldType;

  /**
   * If indexable_option is INDEXABLE_ENABLED, field values are indexed so that it can be filtered or faceted in SearchService.Search. If indexable_option is unset, the server behavior defaults to INDEXABLE_DISABLED for fields that support setting indexable options. For those fields that do not support setting indexable options, such as &#x60;object&#x60; and &#x60;boolean&#x60; and key properties, the server will skip indexable_option setting, and setting indexable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   */
  @JsonAdapter(IndexableOptionEnum.Adapter.class)
  public enum IndexableOptionEnum {
    OPTION_UNSPECIFIED("INDEXABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("INDEXABLE_ENABLED"),
    
    DISABLED("INDEXABLE_DISABLED");

    private String value;

    IndexableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IndexableOptionEnum fromValue(String value) {
      for (IndexableOptionEnum b : IndexableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IndexableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IndexableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IndexableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IndexableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IndexableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INDEXABLE_OPTION = "indexableOption";
  @SerializedName(SERIALIZED_NAME_INDEXABLE_OPTION)
  private IndexableOptionEnum indexableOption;

  public static final String SERIALIZED_NAME_KEY_PROPERTY_TYPE = "keyPropertyType";
  @SerializedName(SERIALIZED_NAME_KEY_PROPERTY_TYPE)
  private String keyPropertyType;

  /**
   * If recs_filterable_option is FILTERABLE_ENABLED, field values are filterable by filter expression in RecommendationService.Recommend. If FILTERABLE_ENABLED but the field type is numerical, field values are not filterable by text queries in RecommendationService.Recommend. Only textual fields are supported. If recs_filterable_option is unset, the default setting is FILTERABLE_DISABLED for fields that support setting filterable options. When a field set to [FILTERABLE_DISABLED] is filtered, a warning is generated and an empty result is returned.
   */
  @JsonAdapter(RecsFilterableOptionEnum.Adapter.class)
  public enum RecsFilterableOptionEnum {
    OPTION_UNSPECIFIED("FILTERABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("FILTERABLE_ENABLED"),
    
    DISABLED("FILTERABLE_DISABLED");

    private String value;

    RecsFilterableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RecsFilterableOptionEnum fromValue(String value) {
      for (RecsFilterableOptionEnum b : RecsFilterableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RecsFilterableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RecsFilterableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RecsFilterableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RecsFilterableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RecsFilterableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RECS_FILTERABLE_OPTION = "recsFilterableOption";
  @SerializedName(SERIALIZED_NAME_RECS_FILTERABLE_OPTION)
  private RecsFilterableOptionEnum recsFilterableOption;

  /**
   * If retrievable_option is RETRIEVABLE_ENABLED, field values are included in the search results. If retrievable_option is unset, the server behavior defaults to RETRIEVABLE_DISABLED for fields that support setting retrievable options. For those fields that do not support setting retrievable options, such as &#x60;object&#x60; and &#x60;boolean&#x60;, the server will skip retrievable option setting, and setting retrievable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   */
  @JsonAdapter(RetrievableOptionEnum.Adapter.class)
  public enum RetrievableOptionEnum {
    OPTION_UNSPECIFIED("RETRIEVABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("RETRIEVABLE_ENABLED"),
    
    DISABLED("RETRIEVABLE_DISABLED");

    private String value;

    RetrievableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RetrievableOptionEnum fromValue(String value) {
      for (RetrievableOptionEnum b : RetrievableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RetrievableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RetrievableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RetrievableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RetrievableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RetrievableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RETRIEVABLE_OPTION = "retrievableOption";
  @SerializedName(SERIALIZED_NAME_RETRIEVABLE_OPTION)
  private RetrievableOptionEnum retrievableOption;

  /**
   * If searchable_option is SEARCHABLE_ENABLED, field values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but field type is numerical, field values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical fields. If searchable_option is unset, the server behavior defaults to SEARCHABLE_DISABLED for fields that support setting searchable options. Only &#x60;string&#x60; fields that have no key property mapping support setting searchable_option. For those fields that do not support setting searchable options, the server will skip searchable option setting, and setting searchable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   */
  @JsonAdapter(SearchableOptionEnum.Adapter.class)
  public enum SearchableOptionEnum {
    OPTION_UNSPECIFIED("SEARCHABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("SEARCHABLE_ENABLED"),
    
    DISABLED("SEARCHABLE_DISABLED");

    private String value;

    SearchableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SearchableOptionEnum fromValue(String value) {
      for (SearchableOptionEnum b : SearchableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SearchableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SearchableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SearchableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SearchableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SearchableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEARCHABLE_OPTION = "searchableOption";
  @SerializedName(SERIALIZED_NAME_SEARCHABLE_OPTION)
  private SearchableOptionEnum searchableOption;

  public GoogleCloudDiscoveryengineV1alphaFieldConfig() {
  }

  public GoogleCloudDiscoveryengineV1alphaFieldConfig(
     FieldTypeEnum fieldType, 
     String keyPropertyType
  ) {
    this();
    this.fieldType = fieldType;
    this.keyPropertyType = keyPropertyType;
  }

  public GoogleCloudDiscoveryengineV1alphaFieldConfig completableOption(CompletableOptionEnum completableOption) {
    this.completableOption = completableOption;
    return this;
  }

  /**
   * If completable_option is COMPLETABLE_ENABLED, field values are directly used and returned as suggestions for Autocomplete in CompletionService.CompleteQuery. If completable_option is unset, the server behavior defaults to COMPLETABLE_DISABLED for fields that support setting completable options, which are just &#x60;string&#x60; fields. For those fields that do not support setting completable options, the server will skip completable option setting, and setting completable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   * @return completableOption
   */
  @javax.annotation.Nullable
  public CompletableOptionEnum getCompletableOption() {
    return completableOption;
  }

  public void setCompletableOption(CompletableOptionEnum completableOption) {
    this.completableOption = completableOption;
  }


  public GoogleCloudDiscoveryengineV1alphaFieldConfig dynamicFacetableOption(DynamicFacetableOptionEnum dynamicFacetableOption) {
    this.dynamicFacetableOption = dynamicFacetableOption;
    return this;
  }

  /**
   * If dynamic_facetable_option is DYNAMIC_FACETABLE_ENABLED, field values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if FieldConfig.indexable_option is INDEXABLE_DISABLED. Otherwise, an &#x60;INVALID_ARGUMENT&#x60; error will be returned. If dynamic_facetable_option is unset, the server behavior defaults to DYNAMIC_FACETABLE_DISABLED for fields that support setting dynamic facetable options. For those fields that do not support setting dynamic facetable options, such as &#x60;object&#x60; and &#x60;boolean&#x60;, the server will skip dynamic facetable option setting, and setting dynamic_facetable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   * @return dynamicFacetableOption
   */
  @javax.annotation.Nullable
  public DynamicFacetableOptionEnum getDynamicFacetableOption() {
    return dynamicFacetableOption;
  }

  public void setDynamicFacetableOption(DynamicFacetableOptionEnum dynamicFacetableOption) {
    this.dynamicFacetableOption = dynamicFacetableOption;
  }


  public GoogleCloudDiscoveryengineV1alphaFieldConfig fieldPath(String fieldPath) {
    this.fieldPath = fieldPath;
    return this;
  }

  /**
   * Required. Field path of the schema field. For example: &#x60;title&#x60;, &#x60;description&#x60;, &#x60;release_info.release_year&#x60;.
   * @return fieldPath
   */
  @javax.annotation.Nullable
  public String getFieldPath() {
    return fieldPath;
  }

  public void setFieldPath(String fieldPath) {
    this.fieldPath = fieldPath;
  }


  /**
   * Output only. Raw type of the field.
   * @return fieldType
   */
  @javax.annotation.Nullable
  public FieldTypeEnum getFieldType() {
    return fieldType;
  }



  public GoogleCloudDiscoveryengineV1alphaFieldConfig indexableOption(IndexableOptionEnum indexableOption) {
    this.indexableOption = indexableOption;
    return this;
  }

  /**
   * If indexable_option is INDEXABLE_ENABLED, field values are indexed so that it can be filtered or faceted in SearchService.Search. If indexable_option is unset, the server behavior defaults to INDEXABLE_DISABLED for fields that support setting indexable options. For those fields that do not support setting indexable options, such as &#x60;object&#x60; and &#x60;boolean&#x60; and key properties, the server will skip indexable_option setting, and setting indexable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   * @return indexableOption
   */
  @javax.annotation.Nullable
  public IndexableOptionEnum getIndexableOption() {
    return indexableOption;
  }

  public void setIndexableOption(IndexableOptionEnum indexableOption) {
    this.indexableOption = indexableOption;
  }


  /**
   * Output only. Type of the key property that this field is mapped to. Empty string if this is not annotated as mapped to a key property. Example types are &#x60;title&#x60;, &#x60;description&#x60;. Full list is defined by &#x60;keyPropertyMapping&#x60; in the schema field annotation. If the schema field has a &#x60;KeyPropertyMapping&#x60; annotation, &#x60;indexable_option&#x60; and &#x60;searchable_option&#x60; of this field cannot be modified.
   * @return keyPropertyType
   */
  @javax.annotation.Nullable
  public String getKeyPropertyType() {
    return keyPropertyType;
  }



  public GoogleCloudDiscoveryengineV1alphaFieldConfig recsFilterableOption(RecsFilterableOptionEnum recsFilterableOption) {
    this.recsFilterableOption = recsFilterableOption;
    return this;
  }

  /**
   * If recs_filterable_option is FILTERABLE_ENABLED, field values are filterable by filter expression in RecommendationService.Recommend. If FILTERABLE_ENABLED but the field type is numerical, field values are not filterable by text queries in RecommendationService.Recommend. Only textual fields are supported. If recs_filterable_option is unset, the default setting is FILTERABLE_DISABLED for fields that support setting filterable options. When a field set to [FILTERABLE_DISABLED] is filtered, a warning is generated and an empty result is returned.
   * @return recsFilterableOption
   */
  @javax.annotation.Nullable
  public RecsFilterableOptionEnum getRecsFilterableOption() {
    return recsFilterableOption;
  }

  public void setRecsFilterableOption(RecsFilterableOptionEnum recsFilterableOption) {
    this.recsFilterableOption = recsFilterableOption;
  }


  public GoogleCloudDiscoveryengineV1alphaFieldConfig retrievableOption(RetrievableOptionEnum retrievableOption) {
    this.retrievableOption = retrievableOption;
    return this;
  }

  /**
   * If retrievable_option is RETRIEVABLE_ENABLED, field values are included in the search results. If retrievable_option is unset, the server behavior defaults to RETRIEVABLE_DISABLED for fields that support setting retrievable options. For those fields that do not support setting retrievable options, such as &#x60;object&#x60; and &#x60;boolean&#x60;, the server will skip retrievable option setting, and setting retrievable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   * @return retrievableOption
   */
  @javax.annotation.Nullable
  public RetrievableOptionEnum getRetrievableOption() {
    return retrievableOption;
  }

  public void setRetrievableOption(RetrievableOptionEnum retrievableOption) {
    this.retrievableOption = retrievableOption;
  }


  public GoogleCloudDiscoveryengineV1alphaFieldConfig searchableOption(SearchableOptionEnum searchableOption) {
    this.searchableOption = searchableOption;
    return this;
  }

  /**
   * If searchable_option is SEARCHABLE_ENABLED, field values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but field type is numerical, field values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical fields. If searchable_option is unset, the server behavior defaults to SEARCHABLE_DISABLED for fields that support setting searchable options. Only &#x60;string&#x60; fields that have no key property mapping support setting searchable_option. For those fields that do not support setting searchable options, the server will skip searchable option setting, and setting searchable_option for those fields will throw &#x60;INVALID_ARGUMENT&#x60; error.
   * @return searchableOption
   */
  @javax.annotation.Nullable
  public SearchableOptionEnum getSearchableOption() {
    return searchableOption;
  }

  public void setSearchableOption(SearchableOptionEnum searchableOption) {
    this.searchableOption = searchableOption;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudDiscoveryengineV1alphaFieldConfig googleCloudDiscoveryengineV1alphaFieldConfig = (GoogleCloudDiscoveryengineV1alphaFieldConfig) o;
    return Objects.equals(this.completableOption, googleCloudDiscoveryengineV1alphaFieldConfig.completableOption) &&
        Objects.equals(this.dynamicFacetableOption, googleCloudDiscoveryengineV1alphaFieldConfig.dynamicFacetableOption) &&
        Objects.equals(this.fieldPath, googleCloudDiscoveryengineV1alphaFieldConfig.fieldPath) &&
        Objects.equals(this.fieldType, googleCloudDiscoveryengineV1alphaFieldConfig.fieldType) &&
        Objects.equals(this.indexableOption, googleCloudDiscoveryengineV1alphaFieldConfig.indexableOption) &&
        Objects.equals(this.keyPropertyType, googleCloudDiscoveryengineV1alphaFieldConfig.keyPropertyType) &&
        Objects.equals(this.recsFilterableOption, googleCloudDiscoveryengineV1alphaFieldConfig.recsFilterableOption) &&
        Objects.equals(this.retrievableOption, googleCloudDiscoveryengineV1alphaFieldConfig.retrievableOption) &&
        Objects.equals(this.searchableOption, googleCloudDiscoveryengineV1alphaFieldConfig.searchableOption);
  }

  @Override
  public int hashCode() {
    return Objects.hash(completableOption, dynamicFacetableOption, fieldPath, fieldType, indexableOption, keyPropertyType, recsFilterableOption, retrievableOption, searchableOption);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudDiscoveryengineV1alphaFieldConfig {\n");
    sb.append("    completableOption: ").append(toIndentedString(completableOption)).append("\n");
    sb.append("    dynamicFacetableOption: ").append(toIndentedString(dynamicFacetableOption)).append("\n");
    sb.append("    fieldPath: ").append(toIndentedString(fieldPath)).append("\n");
    sb.append("    fieldType: ").append(toIndentedString(fieldType)).append("\n");
    sb.append("    indexableOption: ").append(toIndentedString(indexableOption)).append("\n");
    sb.append("    keyPropertyType: ").append(toIndentedString(keyPropertyType)).append("\n");
    sb.append("    recsFilterableOption: ").append(toIndentedString(recsFilterableOption)).append("\n");
    sb.append("    retrievableOption: ").append(toIndentedString(retrievableOption)).append("\n");
    sb.append("    searchableOption: ").append(toIndentedString(searchableOption)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("completableOption");
    openapiFields.add("dynamicFacetableOption");
    openapiFields.add("fieldPath");
    openapiFields.add("fieldType");
    openapiFields.add("indexableOption");
    openapiFields.add("keyPropertyType");
    openapiFields.add("recsFilterableOption");
    openapiFields.add("retrievableOption");
    openapiFields.add("searchableOption");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudDiscoveryengineV1alphaFieldConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudDiscoveryengineV1alphaFieldConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudDiscoveryengineV1alphaFieldConfig is not found in the empty JSON string", GoogleCloudDiscoveryengineV1alphaFieldConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudDiscoveryengineV1alphaFieldConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudDiscoveryengineV1alphaFieldConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("completableOption") != null && !jsonObj.get("completableOption").isJsonNull()) && !jsonObj.get("completableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completableOption").toString()));
      }
      // validate the optional field `completableOption`
      if (jsonObj.get("completableOption") != null && !jsonObj.get("completableOption").isJsonNull()) {
        CompletableOptionEnum.validateJsonElement(jsonObj.get("completableOption"));
      }
      if ((jsonObj.get("dynamicFacetableOption") != null && !jsonObj.get("dynamicFacetableOption").isJsonNull()) && !jsonObj.get("dynamicFacetableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dynamicFacetableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dynamicFacetableOption").toString()));
      }
      // validate the optional field `dynamicFacetableOption`
      if (jsonObj.get("dynamicFacetableOption") != null && !jsonObj.get("dynamicFacetableOption").isJsonNull()) {
        DynamicFacetableOptionEnum.validateJsonElement(jsonObj.get("dynamicFacetableOption"));
      }
      if ((jsonObj.get("fieldPath") != null && !jsonObj.get("fieldPath").isJsonNull()) && !jsonObj.get("fieldPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fieldPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fieldPath").toString()));
      }
      if ((jsonObj.get("fieldType") != null && !jsonObj.get("fieldType").isJsonNull()) && !jsonObj.get("fieldType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fieldType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fieldType").toString()));
      }
      // validate the optional field `fieldType`
      if (jsonObj.get("fieldType") != null && !jsonObj.get("fieldType").isJsonNull()) {
        FieldTypeEnum.validateJsonElement(jsonObj.get("fieldType"));
      }
      if ((jsonObj.get("indexableOption") != null && !jsonObj.get("indexableOption").isJsonNull()) && !jsonObj.get("indexableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `indexableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("indexableOption").toString()));
      }
      // validate the optional field `indexableOption`
      if (jsonObj.get("indexableOption") != null && !jsonObj.get("indexableOption").isJsonNull()) {
        IndexableOptionEnum.validateJsonElement(jsonObj.get("indexableOption"));
      }
      if ((jsonObj.get("keyPropertyType") != null && !jsonObj.get("keyPropertyType").isJsonNull()) && !jsonObj.get("keyPropertyType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keyPropertyType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keyPropertyType").toString()));
      }
      if ((jsonObj.get("recsFilterableOption") != null && !jsonObj.get("recsFilterableOption").isJsonNull()) && !jsonObj.get("recsFilterableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recsFilterableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recsFilterableOption").toString()));
      }
      // validate the optional field `recsFilterableOption`
      if (jsonObj.get("recsFilterableOption") != null && !jsonObj.get("recsFilterableOption").isJsonNull()) {
        RecsFilterableOptionEnum.validateJsonElement(jsonObj.get("recsFilterableOption"));
      }
      if ((jsonObj.get("retrievableOption") != null && !jsonObj.get("retrievableOption").isJsonNull()) && !jsonObj.get("retrievableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retrievableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retrievableOption").toString()));
      }
      // validate the optional field `retrievableOption`
      if (jsonObj.get("retrievableOption") != null && !jsonObj.get("retrievableOption").isJsonNull()) {
        RetrievableOptionEnum.validateJsonElement(jsonObj.get("retrievableOption"));
      }
      if ((jsonObj.get("searchableOption") != null && !jsonObj.get("searchableOption").isJsonNull()) && !jsonObj.get("searchableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchableOption").toString()));
      }
      // validate the optional field `searchableOption`
      if (jsonObj.get("searchableOption") != null && !jsonObj.get("searchableOption").isJsonNull()) {
        SearchableOptionEnum.validateJsonElement(jsonObj.get("searchableOption"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudDiscoveryengineV1alphaFieldConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudDiscoveryengineV1alphaFieldConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudDiscoveryengineV1alphaFieldConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudDiscoveryengineV1alphaFieldConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudDiscoveryengineV1alphaFieldConfig>() {
           @Override
           public void write(JsonWriter out, GoogleCloudDiscoveryengineV1alphaFieldConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudDiscoveryengineV1alphaFieldConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudDiscoveryengineV1alphaFieldConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudDiscoveryengineV1alphaFieldConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudDiscoveryengineV1alphaFieldConfig
   */
  public static GoogleCloudDiscoveryengineV1alphaFieldConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudDiscoveryengineV1alphaFieldConfig.class);
  }

  /**
   * Convert an instance of GoogleCloudDiscoveryengineV1alphaFieldConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

