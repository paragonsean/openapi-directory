/*
 * Discovery Engine API
 * Discovery Engine API.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A facet specification to perform faceted search.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:39.358631-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec {
  public static final String SERIALIZED_NAME_ENABLE_DYNAMIC_POSITION = "enableDynamicPosition";
  @SerializedName(SERIALIZED_NAME_ENABLE_DYNAMIC_POSITION)
  private Boolean enableDynamicPosition;

  public static final String SERIALIZED_NAME_EXCLUDED_FILTER_KEYS = "excludedFilterKeys";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_FILTER_KEYS)
  private List<String> excludedFilterKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_FACET_KEY = "facetKey";
  @SerializedName(SERIALIZED_NAME_FACET_KEY)
  private GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey facetKey;

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec() {
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec enableDynamicPosition(Boolean enableDynamicPosition) {
    this.enableDynamicPosition = enableDynamicPosition;
    return this;
  }

  /**
   * Enables dynamic position for this facet. If set to true, the position of this facet among all facets in the response is determined automatically. If dynamic facets are enabled, it is ordered together. If set to false, the position of this facet in the response is the same as in the request, and it is ranked before the facets with dynamic position enable and all dynamic facets. For example, you may always want to have rating facet returned in the response, but it&#39;s not necessarily to always display the rating facet at the top. In that case, you can set enable_dynamic_position to true so that the position of rating facet in response is determined automatically. Another example, assuming you have the following facets in the request: * \&quot;rating\&quot;, enable_dynamic_position &#x3D; true * \&quot;price\&quot;, enable_dynamic_position &#x3D; false * \&quot;brands\&quot;, enable_dynamic_position &#x3D; false And also you have a dynamic facets enabled, which generates a facet &#x60;gender&#x60;. Then the final order of the facets in the response can be (\&quot;price\&quot;, \&quot;brands\&quot;, \&quot;rating\&quot;, \&quot;gender\&quot;) or (\&quot;price\&quot;, \&quot;brands\&quot;, \&quot;gender\&quot;, \&quot;rating\&quot;) depends on how API orders \&quot;gender\&quot; and \&quot;rating\&quot; facets. However, notice that \&quot;price\&quot; and \&quot;brands\&quot; are always ranked at first and second position because their enable_dynamic_position is false.
   * @return enableDynamicPosition
   */
  @javax.annotation.Nullable
  public Boolean getEnableDynamicPosition() {
    return enableDynamicPosition;
  }

  public void setEnableDynamicPosition(Boolean enableDynamicPosition) {
    this.enableDynamicPosition = enableDynamicPosition;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec excludedFilterKeys(List<String> excludedFilterKeys) {
    this.excludedFilterKeys = excludedFilterKeys;
    return this;
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec addExcludedFilterKeysItem(String excludedFilterKeysItem) {
    if (this.excludedFilterKeys == null) {
      this.excludedFilterKeys = new ArrayList<>();
    }
    this.excludedFilterKeys.add(excludedFilterKeysItem);
    return this;
  }

  /**
   * List of keys to exclude when faceting. By default, FacetKey.key is not excluded from the filter unless it is listed in this field. Listing a facet key in this field allows its values to appear as facet results, even when they are filtered out of search results. Using this field does not affect what search results are returned. For example, suppose there are 100 documents with the color facet \&quot;Red\&quot; and 200 documents with the color facet \&quot;Blue\&quot;. A query containing the filter \&quot;color:ANY(\&quot;Red\&quot;)\&quot; and having \&quot;color\&quot; as FacetKey.key would by default return only \&quot;Red\&quot; documents in the search results, and also return \&quot;Red\&quot; with count 100 as the only color facet. Although there are also blue documents available, \&quot;Blue\&quot; would not be shown as an available facet value. If \&quot;color\&quot; is listed in \&quot;excludedFilterKeys\&quot;, then the query returns the facet values \&quot;Red\&quot; with count 100 and \&quot;Blue\&quot; with count 200, because the \&quot;color\&quot; key is now excluded from the filter. Because this field doesn&#39;t affect search results, the search results are still correctly filtered to return only \&quot;Red\&quot; documents. A maximum of 100 values are allowed. Otherwise, an &#x60;INVALID_ARGUMENT&#x60; error is returned.
   * @return excludedFilterKeys
   */
  @javax.annotation.Nullable
  public List<String> getExcludedFilterKeys() {
    return excludedFilterKeys;
  }

  public void setExcludedFilterKeys(List<String> excludedFilterKeys) {
    this.excludedFilterKeys = excludedFilterKeys;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec facetKey(GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey facetKey) {
    this.facetKey = facetKey;
    return this;
  }

  /**
   * Get facetKey
   * @return facetKey
   */
  @javax.annotation.Nullable
  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey getFacetKey() {
    return facetKey;
  }

  public void setFacetKey(GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey facetKey) {
    this.facetKey = facetKey;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec limit(Integer limit) {
    this.limit = limit;
    return this;
  }

  /**
   * Maximum of facet values that should be returned for this facet. If unspecified, defaults to 20. The maximum allowed value is 300. Values above 300 are coerced to 300. If this field is negative, an &#x60;INVALID_ARGUMENT&#x60; is returned.
   * @return limit
   */
  @javax.annotation.Nullable
  public Integer getLimit() {
    return limit;
  }

  public void setLimit(Integer limit) {
    this.limit = limit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec googleCloudDiscoveryengineV1alphaSearchRequestFacetSpec = (GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec) o;
    return Objects.equals(this.enableDynamicPosition, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.enableDynamicPosition) &&
        Objects.equals(this.excludedFilterKeys, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.excludedFilterKeys) &&
        Objects.equals(this.facetKey, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.facetKey) &&
        Objects.equals(this.limit, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.limit);
  }

  @Override
  public int hashCode() {
    return Objects.hash(enableDynamicPosition, excludedFilterKeys, facetKey, limit);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec {\n");
    sb.append("    enableDynamicPosition: ").append(toIndentedString(enableDynamicPosition)).append("\n");
    sb.append("    excludedFilterKeys: ").append(toIndentedString(excludedFilterKeys)).append("\n");
    sb.append("    facetKey: ").append(toIndentedString(facetKey)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("enableDynamicPosition");
    openapiFields.add("excludedFilterKeys");
    openapiFields.add("facetKey");
    openapiFields.add("limit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec is not found in the empty JSON string", GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedFilterKeys") != null && !jsonObj.get("excludedFilterKeys").isJsonNull() && !jsonObj.get("excludedFilterKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedFilterKeys` to be an array in the JSON string but got `%s`", jsonObj.get("excludedFilterKeys").toString()));
      }
      // validate the optional field `facetKey`
      if (jsonObj.get("facetKey") != null && !jsonObj.get("facetKey").isJsonNull()) {
        GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.validateJsonElement(jsonObj.get("facetKey"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec>() {
           @Override
           public void write(JsonWriter out, GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec
   */
  public static GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.class);
  }

  /**
   * Convert an instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

