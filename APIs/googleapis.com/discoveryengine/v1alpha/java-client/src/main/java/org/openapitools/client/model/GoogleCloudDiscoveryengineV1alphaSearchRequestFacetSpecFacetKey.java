/*
 * Discovery Engine API
 * Discovery Engine API.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleCloudDiscoveryengineV1alphaInterval;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies how a facet is computed.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:39.358631-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey {
  public static final String SERIALIZED_NAME_CASE_INSENSITIVE = "caseInsensitive";
  @SerializedName(SERIALIZED_NAME_CASE_INSENSITIVE)
  private Boolean caseInsensitive;

  public static final String SERIALIZED_NAME_CONTAINS = "contains";
  @SerializedName(SERIALIZED_NAME_CONTAINS)
  private List<String> contains = new ArrayList<>();

  public static final String SERIALIZED_NAME_INTERVALS = "intervals";
  @SerializedName(SERIALIZED_NAME_INTERVALS)
  private List<GoogleCloudDiscoveryengineV1alphaInterval> intervals = new ArrayList<>();

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_ORDER_BY = "orderBy";
  @SerializedName(SERIALIZED_NAME_ORDER_BY)
  private String orderBy;

  public static final String SERIALIZED_NAME_PREFIXES = "prefixes";
  @SerializedName(SERIALIZED_NAME_PREFIXES)
  private List<String> prefixes = new ArrayList<>();

  public static final String SERIALIZED_NAME_RESTRICTED_VALUES = "restrictedValues";
  @SerializedName(SERIALIZED_NAME_RESTRICTED_VALUES)
  private List<String> restrictedValues = new ArrayList<>();

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey() {
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey caseInsensitive(Boolean caseInsensitive) {
    this.caseInsensitive = caseInsensitive;
    return this;
  }

  /**
   * True to make facet keys case insensitive when getting faceting values with prefixes or contains; false otherwise.
   * @return caseInsensitive
   */
  @javax.annotation.Nullable
  public Boolean getCaseInsensitive() {
    return caseInsensitive;
  }

  public void setCaseInsensitive(Boolean caseInsensitive) {
    this.caseInsensitive = caseInsensitive;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey contains(List<String> contains) {
    this.contains = contains;
    return this;
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey addContainsItem(String containsItem) {
    if (this.contains == null) {
      this.contains = new ArrayList<>();
    }
    this.contains.add(containsItem);
    return this;
  }

  /**
   * Only get facet values that contains the given strings. For example, suppose \&quot;category\&quot; has three values \&quot;Action &gt; 2022\&quot;, \&quot;Action &gt; 2021\&quot; and \&quot;Sci-Fi &gt; 2022\&quot;. If set \&quot;contains\&quot; to \&quot;2022\&quot;, the \&quot;category\&quot; facet only contains \&quot;Action &gt; 2022\&quot; and \&quot;Sci-Fi &gt; 2022\&quot;. Only supported on textual fields. Maximum is 10.
   * @return contains
   */
  @javax.annotation.Nullable
  public List<String> getContains() {
    return contains;
  }

  public void setContains(List<String> contains) {
    this.contains = contains;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey intervals(List<GoogleCloudDiscoveryengineV1alphaInterval> intervals) {
    this.intervals = intervals;
    return this;
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey addIntervalsItem(GoogleCloudDiscoveryengineV1alphaInterval intervalsItem) {
    if (this.intervals == null) {
      this.intervals = new ArrayList<>();
    }
    this.intervals.add(intervalsItem);
    return this;
  }

  /**
   * Set only if values should be bucketed into intervals. Must be set for facets with numerical values. Must not be set for facet with text values. Maximum number of intervals is 30.
   * @return intervals
   */
  @javax.annotation.Nullable
  public List<GoogleCloudDiscoveryengineV1alphaInterval> getIntervals() {
    return intervals;
  }

  public void setIntervals(List<GoogleCloudDiscoveryengineV1alphaInterval> intervals) {
    this.intervals = intervals;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey key(String key) {
    this.key = key;
    return this;
  }

  /**
   * Required. Supported textual and numerical facet keys in Document object, over which the facet values are computed. Facet key is case-sensitive.
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey orderBy(String orderBy) {
    this.orderBy = orderBy;
    return this;
  }

  /**
   * The order in which documents are returned. Allowed values are: * \&quot;count desc\&quot;, which means order by SearchResponse.Facet.values.count descending. * \&quot;value desc\&quot;, which means order by SearchResponse.Facet.values.value descending. Only applies to textual facets. If not set, textual values are sorted in [natural order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical intervals are sorted in the order given by FacetSpec.FacetKey.intervals.
   * @return orderBy
   */
  @javax.annotation.Nullable
  public String getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(String orderBy) {
    this.orderBy = orderBy;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey prefixes(List<String> prefixes) {
    this.prefixes = prefixes;
    return this;
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey addPrefixesItem(String prefixesItem) {
    if (this.prefixes == null) {
      this.prefixes = new ArrayList<>();
    }
    this.prefixes.add(prefixesItem);
    return this;
  }

  /**
   * Only get facet values that start with the given string prefix. For example, suppose \&quot;category\&quot; has three values \&quot;Action &gt; 2022\&quot;, \&quot;Action &gt; 2021\&quot; and \&quot;Sci-Fi &gt; 2022\&quot;. If set \&quot;prefixes\&quot; to \&quot;Action\&quot;, the \&quot;category\&quot; facet only contains \&quot;Action &gt; 2022\&quot; and \&quot;Action &gt; 2021\&quot;. Only supported on textual fields. Maximum is 10.
   * @return prefixes
   */
  @javax.annotation.Nullable
  public List<String> getPrefixes() {
    return prefixes;
  }

  public void setPrefixes(List<String> prefixes) {
    this.prefixes = prefixes;
  }


  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey restrictedValues(List<String> restrictedValues) {
    this.restrictedValues = restrictedValues;
    return this;
  }

  public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey addRestrictedValuesItem(String restrictedValuesItem) {
    if (this.restrictedValues == null) {
      this.restrictedValues = new ArrayList<>();
    }
    this.restrictedValues.add(restrictedValuesItem);
    return this;
  }

  /**
   * Only get facet for the given restricted values. Only supported on textual fields. For example, suppose \&quot;category\&quot; has three values \&quot;Action &gt; 2022\&quot;, \&quot;Action &gt; 2021\&quot; and \&quot;Sci-Fi &gt; 2022\&quot;. If set \&quot;restricted_values\&quot; to \&quot;Action &gt; 2022\&quot;, the \&quot;category\&quot; facet only contains \&quot;Action &gt; 2022\&quot;. Only supported on textual fields. Maximum is 10.
   * @return restrictedValues
   */
  @javax.annotation.Nullable
  public List<String> getRestrictedValues() {
    return restrictedValues;
  }

  public void setRestrictedValues(List<String> restrictedValues) {
    this.restrictedValues = restrictedValues;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey = (GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey) o;
    return Objects.equals(this.caseInsensitive, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.caseInsensitive) &&
        Objects.equals(this.contains, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.contains) &&
        Objects.equals(this.intervals, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.intervals) &&
        Objects.equals(this.key, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.key) &&
        Objects.equals(this.orderBy, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.orderBy) &&
        Objects.equals(this.prefixes, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.prefixes) &&
        Objects.equals(this.restrictedValues, googleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.restrictedValues);
  }

  @Override
  public int hashCode() {
    return Objects.hash(caseInsensitive, contains, intervals, key, orderBy, prefixes, restrictedValues);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey {\n");
    sb.append("    caseInsensitive: ").append(toIndentedString(caseInsensitive)).append("\n");
    sb.append("    contains: ").append(toIndentedString(contains)).append("\n");
    sb.append("    intervals: ").append(toIndentedString(intervals)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    orderBy: ").append(toIndentedString(orderBy)).append("\n");
    sb.append("    prefixes: ").append(toIndentedString(prefixes)).append("\n");
    sb.append("    restrictedValues: ").append(toIndentedString(restrictedValues)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("caseInsensitive");
    openapiFields.add("contains");
    openapiFields.add("intervals");
    openapiFields.add("key");
    openapiFields.add("orderBy");
    openapiFields.add("prefixes");
    openapiFields.add("restrictedValues");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey is not found in the empty JSON string", GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("contains") != null && !jsonObj.get("contains").isJsonNull() && !jsonObj.get("contains").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `contains` to be an array in the JSON string but got `%s`", jsonObj.get("contains").toString()));
      }
      if (jsonObj.get("intervals") != null && !jsonObj.get("intervals").isJsonNull()) {
        JsonArray jsonArrayintervals = jsonObj.getAsJsonArray("intervals");
        if (jsonArrayintervals != null) {
          // ensure the json data is an array
          if (!jsonObj.get("intervals").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `intervals` to be an array in the JSON string but got `%s`", jsonObj.get("intervals").toString()));
          }

          // validate the optional field `intervals` (array)
          for (int i = 0; i < jsonArrayintervals.size(); i++) {
            GoogleCloudDiscoveryengineV1alphaInterval.validateJsonElement(jsonArrayintervals.get(i));
          };
        }
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("orderBy") != null && !jsonObj.get("orderBy").isJsonNull()) && !jsonObj.get("orderBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderBy").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("prefixes") != null && !jsonObj.get("prefixes").isJsonNull() && !jsonObj.get("prefixes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefixes` to be an array in the JSON string but got `%s`", jsonObj.get("prefixes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("restrictedValues") != null && !jsonObj.get("restrictedValues").isJsonNull() && !jsonObj.get("restrictedValues").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `restrictedValues` to be an array in the JSON string but got `%s`", jsonObj.get("restrictedValues").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey>() {
           @Override
           public void write(JsonWriter out, GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey
   */
  public static GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.class);
  }

  /**
   * Convert an instance of GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

