/**
 * Remote Build Execution API
 * Supplies a Remote Execution API service for tools such as bazel.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The BuildBazelRemoteExecutionV2Digest model module.
 * @module model/BuildBazelRemoteExecutionV2Digest
 * @version v1alpha
 */
class BuildBazelRemoteExecutionV2Digest {
    /**
     * Constructs a new <code>BuildBazelRemoteExecutionV2Digest</code>.
     * A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the &#x60;hash&#x60; field is correctly specified but &#x60;size_bytes&#x60; is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a &#x60;Digest&#x60; is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
     * @alias module:model/BuildBazelRemoteExecutionV2Digest
     */
    constructor() { 
        
        BuildBazelRemoteExecutionV2Digest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>BuildBazelRemoteExecutionV2Digest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/BuildBazelRemoteExecutionV2Digest} obj Optional instance to populate.
     * @return {module:model/BuildBazelRemoteExecutionV2Digest} The populated <code>BuildBazelRemoteExecutionV2Digest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new BuildBazelRemoteExecutionV2Digest();

            if (data.hasOwnProperty('hash')) {
                obj['hash'] = ApiClient.convertToType(data['hash'], 'String');
            }
            if (data.hasOwnProperty('sizeBytes')) {
                obj['sizeBytes'] = ApiClient.convertToType(data['sizeBytes'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>BuildBazelRemoteExecutionV2Digest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>BuildBazelRemoteExecutionV2Digest</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['hash'] && !(typeof data['hash'] === 'string' || data['hash'] instanceof String)) {
            throw new Error("Expected the field `hash` to be a primitive type in the JSON string but got " + data['hash']);
        }
        // ensure the json data is a string
        if (data['sizeBytes'] && !(typeof data['sizeBytes'] === 'string' || data['sizeBytes'] instanceof String)) {
            throw new Error("Expected the field `sizeBytes` to be a primitive type in the JSON string but got " + data['sizeBytes']);
        }

        return true;
    }


}



/**
 * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters long.
 * @member {String} hash
 */
BuildBazelRemoteExecutionV2Digest.prototype['hash'] = undefined;

/**
 * The size of the blob, in bytes.
 * @member {String} sizeBytes
 */
BuildBazelRemoteExecutionV2Digest.prototype['sizeBytes'] = undefined;






export default BuildBazelRemoteExecutionV2Digest;

