/*
 * Remote Build Execution API
 * Supplies a Remote Execution API service for tools such as bazel.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the &#x60;hash&#x60; field is correctly specified but &#x60;size_bytes&#x60; is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a &#x60;Digest&#x60; is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:16.147037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildBazelRemoteExecutionV2Digest {
  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_SIZE_BYTES = "sizeBytes";
  @SerializedName(SERIALIZED_NAME_SIZE_BYTES)
  private String sizeBytes;

  public BuildBazelRemoteExecutionV2Digest() {
  }

  public BuildBazelRemoteExecutionV2Digest hash(String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters long.
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  public void setHash(String hash) {
    this.hash = hash;
  }


  public BuildBazelRemoteExecutionV2Digest sizeBytes(String sizeBytes) {
    this.sizeBytes = sizeBytes;
    return this;
  }

  /**
   * The size of the blob, in bytes.
   * @return sizeBytes
   */
  @javax.annotation.Nullable
  public String getSizeBytes() {
    return sizeBytes;
  }

  public void setSizeBytes(String sizeBytes) {
    this.sizeBytes = sizeBytes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BuildBazelRemoteExecutionV2Digest buildBazelRemoteExecutionV2Digest = (BuildBazelRemoteExecutionV2Digest) o;
    return Objects.equals(this.hash, buildBazelRemoteExecutionV2Digest.hash) &&
        Objects.equals(this.sizeBytes, buildBazelRemoteExecutionV2Digest.sizeBytes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(hash, sizeBytes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BuildBazelRemoteExecutionV2Digest {\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    sizeBytes: ").append(toIndentedString(sizeBytes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("hash");
    openapiFields.add("sizeBytes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BuildBazelRemoteExecutionV2Digest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BuildBazelRemoteExecutionV2Digest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BuildBazelRemoteExecutionV2Digest is not found in the empty JSON string", BuildBazelRemoteExecutionV2Digest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BuildBazelRemoteExecutionV2Digest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BuildBazelRemoteExecutionV2Digest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      if ((jsonObj.get("sizeBytes") != null && !jsonObj.get("sizeBytes").isJsonNull()) && !jsonObj.get("sizeBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sizeBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sizeBytes").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BuildBazelRemoteExecutionV2Digest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BuildBazelRemoteExecutionV2Digest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BuildBazelRemoteExecutionV2Digest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BuildBazelRemoteExecutionV2Digest.class));

       return (TypeAdapter<T>) new TypeAdapter<BuildBazelRemoteExecutionV2Digest>() {
           @Override
           public void write(JsonWriter out, BuildBazelRemoteExecutionV2Digest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BuildBazelRemoteExecutionV2Digest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BuildBazelRemoteExecutionV2Digest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BuildBazelRemoteExecutionV2Digest
   * @throws IOException if the JSON string is invalid with respect to BuildBazelRemoteExecutionV2Digest
   */
  public static BuildBazelRemoteExecutionV2Digest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BuildBazelRemoteExecutionV2Digest.class);
  }

  /**
   * Convert an instance of BuildBazelRemoteExecutionV2Digest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

