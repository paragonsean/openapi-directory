/*
 * Remote Build Execution API
 * Supplies a Remote Execution API service for tools such as bazel.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig;
import org.openapitools.client.model.GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines the configuration to be used for creating workers in the worker pool.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:16.147037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig {
  public static final String SERIALIZED_NAME_ACCELERATOR = "accelerator";
  @SerializedName(SERIALIZED_NAME_ACCELERATOR)
  private GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig accelerator;

  public static final String SERIALIZED_NAME_ATTACHED_DISKS = "attachedDisks";
  @SerializedName(SERIALIZED_NAME_ATTACHED_DISKS)
  private GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks attachedDisks;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private String diskSizeGb;

  public static final String SERIALIZED_NAME_DISK_TYPE = "diskType";
  @SerializedName(SERIALIZED_NAME_DISK_TYPE)
  private String diskType;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_MAX_CONCURRENT_ACTIONS = "maxConcurrentActions";
  @SerializedName(SERIALIZED_NAME_MAX_CONCURRENT_ACTIONS)
  private String maxConcurrentActions;

  public static final String SERIALIZED_NAME_MIN_CPU_PLATFORM = "minCpuPlatform";
  @SerializedName(SERIALIZED_NAME_MIN_CPU_PLATFORM)
  private String minCpuPlatform;

  public static final String SERIALIZED_NAME_NETWORK_ACCESS = "networkAccess";
  @SerializedName(SERIALIZED_NAME_NETWORK_ACCESS)
  private String networkAccess;

  public static final String SERIALIZED_NAME_RESERVED = "reserved";
  @SerializedName(SERIALIZED_NAME_RESERVED)
  private Boolean reserved;

  public static final String SERIALIZED_NAME_SOLE_TENANT_NODE_TYPE = "soleTenantNodeType";
  @SerializedName(SERIALIZED_NAME_SOLE_TENANT_NODE_TYPE)
  private String soleTenantNodeType;

  public static final String SERIALIZED_NAME_USER_SERVICE_ACCOUNTS = "userServiceAccounts";
  @SerializedName(SERIALIZED_NAME_USER_SERVICE_ACCOUNTS)
  private List<String> userServiceAccounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_VM_IMAGE = "vmImage";
  @SerializedName(SERIALIZED_NAME_VM_IMAGE)
  private String vmImage;

  public static final String SERIALIZED_NAME_ZONES = "zones";
  @SerializedName(SERIALIZED_NAME_ZONES)
  private List<String> zones = new ArrayList<>();

  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig() {
  }

  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig accelerator(GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig accelerator) {
    this.accelerator = accelerator;
    return this;
  }

  /**
   * Get accelerator
   * @return accelerator
   */
  @javax.annotation.Nullable
  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig getAccelerator() {
    return accelerator;
  }

  public void setAccelerator(GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig accelerator) {
    this.accelerator = accelerator;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig attachedDisks(GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks attachedDisks) {
    this.attachedDisks = attachedDisks;
    return this;
  }

  /**
   * Get attachedDisks
   * @return attachedDisks
   */
  @javax.annotation.Nullable
  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks getAttachedDisks() {
    return attachedDisks;
  }

  public void setAttachedDisks(GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks attachedDisks) {
    this.attachedDisks = attachedDisks;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig diskSizeGb(String diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Required. Size of the disk attached to the worker, in GB. See https://cloud.google.com/compute/docs/disks/
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public String getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(String diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig diskType(String diskType) {
    this.diskType = diskType;
    return this;
  }

  /**
   * Required. Disk Type to use for the worker. See [Storage options](https://cloud.google.com/compute/docs/disks/#introduction). Currently only &#x60;pd-standard&#x60; and &#x60;pd-ssd&#x60; are supported.
   * @return diskType
   */
  @javax.annotation.Nullable
  public String getDiskType() {
    return diskType;
  }

  public void setDiskType(String diskType) {
    this.diskType = diskType;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels associated with the workers. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International letters are permitted. Label keys must start with a letter. Label values are optional. There can not be more than 64 labels per resource.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Required. Machine type of the worker, such as &#x60;e2-standard-2&#x60;. See https://cloud.google.com/compute/docs/machine-types for a list of supported machine types. Note that &#x60;f1-micro&#x60; and &#x60;g1-small&#x60; are not yet supported.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig maxConcurrentActions(String maxConcurrentActions) {
    this.maxConcurrentActions = maxConcurrentActions;
    return this;
  }

  /**
   * The maximum number of actions a worker can execute concurrently.
   * @return maxConcurrentActions
   */
  @javax.annotation.Nullable
  public String getMaxConcurrentActions() {
    return maxConcurrentActions;
  }

  public void setMaxConcurrentActions(String maxConcurrentActions) {
    this.maxConcurrentActions = maxConcurrentActions;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig minCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
    return this;
  }

  /**
   * Minimum CPU platform to use when creating the worker. See [CPU Platforms](https://cloud.google.com/compute/docs/cpu-platforms).
   * @return minCpuPlatform
   */
  @javax.annotation.Nullable
  public String getMinCpuPlatform() {
    return minCpuPlatform;
  }

  public void setMinCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig networkAccess(String networkAccess) {
    this.networkAccess = networkAccess;
    return this;
  }

  /**
   * Determines the type of network access granted to workers. Possible values: - \&quot;public\&quot;: Workers can connect to the public internet. - \&quot;private\&quot;: Workers can only connect to Google APIs and services. - \&quot;restricted-private\&quot;: Workers can only connect to Google APIs that are reachable through &#x60;restricted.googleapis.com&#x60; (&#x60;199.36.153.4/30&#x60;).
   * @return networkAccess
   */
  @javax.annotation.Nullable
  public String getNetworkAccess() {
    return networkAccess;
  }

  public void setNetworkAccess(String networkAccess) {
    this.networkAccess = networkAccess;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig reserved(Boolean reserved) {
    this.reserved = reserved;
    return this;
  }

  /**
   * Determines whether the worker is reserved (equivalent to a Compute Engine on-demand VM and therefore won&#39;t be preempted). See [Preemptible VMs](https://cloud.google.com/preemptible-vms/) for more details.
   * @return reserved
   */
  @javax.annotation.Nullable
  public Boolean getReserved() {
    return reserved;
  }

  public void setReserved(Boolean reserved) {
    this.reserved = reserved;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig soleTenantNodeType(String soleTenantNodeType) {
    this.soleTenantNodeType = soleTenantNodeType;
    return this;
  }

  /**
   * The node type name to be used for sole-tenant nodes.
   * @return soleTenantNodeType
   */
  @javax.annotation.Nullable
  public String getSoleTenantNodeType() {
    return soleTenantNodeType;
  }

  public void setSoleTenantNodeType(String soleTenantNodeType) {
    this.soleTenantNodeType = soleTenantNodeType;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig userServiceAccounts(List<String> userServiceAccounts) {
    this.userServiceAccounts = userServiceAccounts;
    return this;
  }

  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig addUserServiceAccountsItem(String userServiceAccountsItem) {
    if (this.userServiceAccounts == null) {
      this.userServiceAccounts = new ArrayList<>();
    }
    this.userServiceAccounts.add(userServiceAccountsItem);
    return this;
  }

  /**
   * Optional. List of user service accounts. The last service account in the list is what the user code will run as. The rest of the service accounts constitute the impersonation chain. For example, if len(user_service_accounts) &#x3D;&#x3D; 2 and if the VM&#39;s service account is RBE&#39;s P4SA, then RBE&#39;S P4SA should be granted the Service Account Token Creator role on user_service_accounts[0] and user_service_accounts[0] should be granted the Service Account Token Creator role on user_service_accounts[1].
   * @return userServiceAccounts
   */
  @javax.annotation.Nullable
  public List<String> getUserServiceAccounts() {
    return userServiceAccounts;
  }

  public void setUserServiceAccounts(List<String> userServiceAccounts) {
    this.userServiceAccounts = userServiceAccounts;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig vmImage(String vmImage) {
    this.vmImage = vmImage;
    return this;
  }

  /**
   * The name of the image used by each VM.
   * @return vmImage
   */
  @javax.annotation.Nullable
  public String getVmImage() {
    return vmImage;
  }

  public void setVmImage(String vmImage) {
    this.vmImage = vmImage;
  }


  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig zones(List<String> zones) {
    this.zones = zones;
    return this;
  }

  public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig addZonesItem(String zonesItem) {
    if (this.zones == null) {
      this.zones = new ArrayList<>();
    }
    this.zones.add(zonesItem);
    return this;
  }

  /**
   * Optional. Zones in the region where the pool VMs should be. Leave empty for no restrictions.
   * @return zones
   */
  @javax.annotation.Nullable
  public List<String> getZones() {
    return zones;
  }

  public void setZones(List<String> zones) {
    this.zones = zones;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig = (GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig) o;
    return Objects.equals(this.accelerator, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.accelerator) &&
        Objects.equals(this.attachedDisks, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.attachedDisks) &&
        Objects.equals(this.diskSizeGb, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.diskSizeGb) &&
        Objects.equals(this.diskType, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.diskType) &&
        Objects.equals(this.labels, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.labels) &&
        Objects.equals(this.machineType, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.machineType) &&
        Objects.equals(this.maxConcurrentActions, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.maxConcurrentActions) &&
        Objects.equals(this.minCpuPlatform, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.minCpuPlatform) &&
        Objects.equals(this.networkAccess, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.networkAccess) &&
        Objects.equals(this.reserved, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.reserved) &&
        Objects.equals(this.soleTenantNodeType, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.soleTenantNodeType) &&
        Objects.equals(this.userServiceAccounts, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.userServiceAccounts) &&
        Objects.equals(this.vmImage, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.vmImage) &&
        Objects.equals(this.zones, googleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.zones);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accelerator, attachedDisks, diskSizeGb, diskType, labels, machineType, maxConcurrentActions, minCpuPlatform, networkAccess, reserved, soleTenantNodeType, userServiceAccounts, vmImage, zones);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig {\n");
    sb.append("    accelerator: ").append(toIndentedString(accelerator)).append("\n");
    sb.append("    attachedDisks: ").append(toIndentedString(attachedDisks)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    diskType: ").append(toIndentedString(diskType)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    maxConcurrentActions: ").append(toIndentedString(maxConcurrentActions)).append("\n");
    sb.append("    minCpuPlatform: ").append(toIndentedString(minCpuPlatform)).append("\n");
    sb.append("    networkAccess: ").append(toIndentedString(networkAccess)).append("\n");
    sb.append("    reserved: ").append(toIndentedString(reserved)).append("\n");
    sb.append("    soleTenantNodeType: ").append(toIndentedString(soleTenantNodeType)).append("\n");
    sb.append("    userServiceAccounts: ").append(toIndentedString(userServiceAccounts)).append("\n");
    sb.append("    vmImage: ").append(toIndentedString(vmImage)).append("\n");
    sb.append("    zones: ").append(toIndentedString(zones)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accelerator");
    openapiFields.add("attachedDisks");
    openapiFields.add("diskSizeGb");
    openapiFields.add("diskType");
    openapiFields.add("labels");
    openapiFields.add("machineType");
    openapiFields.add("maxConcurrentActions");
    openapiFields.add("minCpuPlatform");
    openapiFields.add("networkAccess");
    openapiFields.add("reserved");
    openapiFields.add("soleTenantNodeType");
    openapiFields.add("userServiceAccounts");
    openapiFields.add("vmImage");
    openapiFields.add("zones");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig is not found in the empty JSON string", GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `accelerator`
      if (jsonObj.get("accelerator") != null && !jsonObj.get("accelerator").isJsonNull()) {
        GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig.validateJsonElement(jsonObj.get("accelerator"));
      }
      // validate the optional field `attachedDisks`
      if (jsonObj.get("attachedDisks") != null && !jsonObj.get("attachedDisks").isJsonNull()) {
        GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks.validateJsonElement(jsonObj.get("attachedDisks"));
      }
      if ((jsonObj.get("diskSizeGb") != null && !jsonObj.get("diskSizeGb").isJsonNull()) && !jsonObj.get("diskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskSizeGb").toString()));
      }
      if ((jsonObj.get("diskType") != null && !jsonObj.get("diskType").isJsonNull()) && !jsonObj.get("diskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskType").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("maxConcurrentActions") != null && !jsonObj.get("maxConcurrentActions").isJsonNull()) && !jsonObj.get("maxConcurrentActions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxConcurrentActions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxConcurrentActions").toString()));
      }
      if ((jsonObj.get("minCpuPlatform") != null && !jsonObj.get("minCpuPlatform").isJsonNull()) && !jsonObj.get("minCpuPlatform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minCpuPlatform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minCpuPlatform").toString()));
      }
      if ((jsonObj.get("networkAccess") != null && !jsonObj.get("networkAccess").isJsonNull()) && !jsonObj.get("networkAccess").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkAccess` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkAccess").toString()));
      }
      if ((jsonObj.get("soleTenantNodeType") != null && !jsonObj.get("soleTenantNodeType").isJsonNull()) && !jsonObj.get("soleTenantNodeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `soleTenantNodeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("soleTenantNodeType").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("userServiceAccounts") != null && !jsonObj.get("userServiceAccounts").isJsonNull() && !jsonObj.get("userServiceAccounts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `userServiceAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("userServiceAccounts").toString()));
      }
      if ((jsonObj.get("vmImage") != null && !jsonObj.get("vmImage").isJsonNull()) && !jsonObj.get("vmImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmImage").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("zones") != null && !jsonObj.get("zones").isJsonNull() && !jsonObj.get("zones").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `zones` to be an array in the JSON string but got `%s`", jsonObj.get("zones").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig>() {
           @Override
           public void write(JsonWriter out, GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig
   */
  public static GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig.class);
  }

  /**
   * Convert an instance of GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

