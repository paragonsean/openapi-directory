/*
 * Remote Build Execution API
 * Supplies a Remote Execution API service for tools such as bazel.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BuildBazelRemoteExecutionV2Digest;
import org.openapitools.client.model.BuildBazelRemoteExecutionV2ExecutedActionMetadata;
import org.openapitools.client.model.BuildBazelRemoteExecutionV2OutputDirectory;
import org.openapitools.client.model.BuildBazelRemoteExecutionV2OutputFile;
import org.openapitools.client.model.BuildBazelRemoteExecutionV2OutputSymlink;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An ActionResult represents the result of an Action being run. It is advised that at least one field (for example &#x60;ActionResult.execution_metadata.Worker&#x60;) have a non-default value, to ensure that the serialized value is non-empty, which can then be used as a basic data sanity check.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:16.147037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildBazelRemoteExecutionV2ActionResult {
  public static final String SERIALIZED_NAME_EXECUTION_METADATA = "executionMetadata";
  @SerializedName(SERIALIZED_NAME_EXECUTION_METADATA)
  private BuildBazelRemoteExecutionV2ExecutedActionMetadata executionMetadata;

  public static final String SERIALIZED_NAME_EXIT_CODE = "exitCode";
  @SerializedName(SERIALIZED_NAME_EXIT_CODE)
  private Integer exitCode;

  public static final String SERIALIZED_NAME_OUTPUT_DIRECTORIES = "outputDirectories";
  @SerializedName(SERIALIZED_NAME_OUTPUT_DIRECTORIES)
  private List<BuildBazelRemoteExecutionV2OutputDirectory> outputDirectories = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_DIRECTORY_SYMLINKS = "outputDirectorySymlinks";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_OUTPUT_DIRECTORY_SYMLINKS)
  private List<BuildBazelRemoteExecutionV2OutputSymlink> outputDirectorySymlinks = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_FILE_SYMLINKS = "outputFileSymlinks";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_OUTPUT_FILE_SYMLINKS)
  private List<BuildBazelRemoteExecutionV2OutputSymlink> outputFileSymlinks = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_FILES = "outputFiles";
  @SerializedName(SERIALIZED_NAME_OUTPUT_FILES)
  private List<BuildBazelRemoteExecutionV2OutputFile> outputFiles = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_SYMLINKS = "outputSymlinks";
  @SerializedName(SERIALIZED_NAME_OUTPUT_SYMLINKS)
  private List<BuildBazelRemoteExecutionV2OutputSymlink> outputSymlinks = new ArrayList<>();

  public static final String SERIALIZED_NAME_STDERR_DIGEST = "stderrDigest";
  @SerializedName(SERIALIZED_NAME_STDERR_DIGEST)
  private BuildBazelRemoteExecutionV2Digest stderrDigest;

  public static final String SERIALIZED_NAME_STDERR_RAW = "stderrRaw";
  @SerializedName(SERIALIZED_NAME_STDERR_RAW)
  private byte[] stderrRaw;

  public static final String SERIALIZED_NAME_STDOUT_DIGEST = "stdoutDigest";
  @SerializedName(SERIALIZED_NAME_STDOUT_DIGEST)
  private BuildBazelRemoteExecutionV2Digest stdoutDigest;

  public static final String SERIALIZED_NAME_STDOUT_RAW = "stdoutRaw";
  @SerializedName(SERIALIZED_NAME_STDOUT_RAW)
  private byte[] stdoutRaw;

  public BuildBazelRemoteExecutionV2ActionResult() {
  }

  public BuildBazelRemoteExecutionV2ActionResult executionMetadata(BuildBazelRemoteExecutionV2ExecutedActionMetadata executionMetadata) {
    this.executionMetadata = executionMetadata;
    return this;
  }

  /**
   * Get executionMetadata
   * @return executionMetadata
   */
  @javax.annotation.Nullable
  public BuildBazelRemoteExecutionV2ExecutedActionMetadata getExecutionMetadata() {
    return executionMetadata;
  }

  public void setExecutionMetadata(BuildBazelRemoteExecutionV2ExecutedActionMetadata executionMetadata) {
    this.executionMetadata = executionMetadata;
  }


  public BuildBazelRemoteExecutionV2ActionResult exitCode(Integer exitCode) {
    this.exitCode = exitCode;
    return this;
  }

  /**
   * The exit code of the command.
   * @return exitCode
   */
  @javax.annotation.Nullable
  public Integer getExitCode() {
    return exitCode;
  }

  public void setExitCode(Integer exitCode) {
    this.exitCode = exitCode;
  }


  public BuildBazelRemoteExecutionV2ActionResult outputDirectories(List<BuildBazelRemoteExecutionV2OutputDirectory> outputDirectories) {
    this.outputDirectories = outputDirectories;
    return this;
  }

  public BuildBazelRemoteExecutionV2ActionResult addOutputDirectoriesItem(BuildBazelRemoteExecutionV2OutputDirectory outputDirectoriesItem) {
    if (this.outputDirectories == null) {
      this.outputDirectories = new ArrayList<>();
    }
    this.outputDirectories.add(outputDirectoriesItem);
    return this;
  }

  /**
   * The output directories of the action. For each output directory requested in the &#x60;output_directories&#x60; or &#x60;output_paths&#x60; field of the Action, if the corresponding directory existed after the action completed, a single entry will be present in the output list, which will contain the digest of a Tree message containing the directory tree, and the path equal exactly to the corresponding Action output_directories member. As an example, suppose the Action had an output directory &#x60;a/b/dir&#x60; and the execution produced the following contents in &#x60;a/b/dir&#x60;: a file named &#x60;bar&#x60; and a directory named &#x60;foo&#x60; with an executable file named &#x60;baz&#x60;. Then, output_directory will contain (hashes shortened for readability): &#x60;&#x60;&#x60;json // OutputDirectory proto: { path: \&quot;a/b/dir\&quot; tree_digest: { hash: \&quot;4a73bc9d03...\&quot;, size: 55 } } // Tree proto with hash \&quot;4a73bc9d03...\&quot; and size 55: { root: { files: [ { name: \&quot;bar\&quot;, digest: { hash: \&quot;4a73bc9d03...\&quot;, size: 65534 } } ], directories: [ { name: \&quot;foo\&quot;, digest: { hash: \&quot;4cf2eda940...\&quot;, size: 43 } } ] } children : { // (Directory proto with hash \&quot;4cf2eda940...\&quot; and size 43) files: [ { name: \&quot;baz\&quot;, digest: { hash: \&quot;b2c941073e...\&quot;, size: 1294, }, is_executable: true } ] } } &#x60;&#x60;&#x60; If an output of the same name as listed in &#x60;output_files&#x60; of the Command was found in &#x60;output_directories&#x60;, but was not a directory, the server will return a FAILED_PRECONDITION.
   * @return outputDirectories
   */
  @javax.annotation.Nullable
  public List<BuildBazelRemoteExecutionV2OutputDirectory> getOutputDirectories() {
    return outputDirectories;
  }

  public void setOutputDirectories(List<BuildBazelRemoteExecutionV2OutputDirectory> outputDirectories) {
    this.outputDirectories = outputDirectories;
  }


  @Deprecated
  public BuildBazelRemoteExecutionV2ActionResult outputDirectorySymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputDirectorySymlinks) {
    this.outputDirectorySymlinks = outputDirectorySymlinks;
    return this;
  }

  public BuildBazelRemoteExecutionV2ActionResult addOutputDirectorySymlinksItem(BuildBazelRemoteExecutionV2OutputSymlink outputDirectorySymlinksItem) {
    if (this.outputDirectorySymlinks == null) {
      this.outputDirectorySymlinks = new ArrayList<>();
    }
    this.outputDirectorySymlinks.add(outputDirectorySymlinksItem);
    return this;
  }

  /**
   * The output directories of the action that are symbolic links to other directories. Those may be links to other output directories, or input directories, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. For each output directory requested in the &#x60;output_directories&#x60; field of the Action, if the directory existed after the action completed, a single entry will be present either in this field, or in the &#x60;output_directories&#x60; field, if the directory was not a symbolic link. If an output of the same name was found, but was a symbolic link to a file instead of a directory, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted. DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API should still populate this field in addition to &#x60;output_symlinks&#x60;.
   * @return outputDirectorySymlinks
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<BuildBazelRemoteExecutionV2OutputSymlink> getOutputDirectorySymlinks() {
    return outputDirectorySymlinks;
  }

  @Deprecated
  public void setOutputDirectorySymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputDirectorySymlinks) {
    this.outputDirectorySymlinks = outputDirectorySymlinks;
  }


  @Deprecated
  public BuildBazelRemoteExecutionV2ActionResult outputFileSymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputFileSymlinks) {
    this.outputFileSymlinks = outputFileSymlinks;
    return this;
  }

  public BuildBazelRemoteExecutionV2ActionResult addOutputFileSymlinksItem(BuildBazelRemoteExecutionV2OutputSymlink outputFileSymlinksItem) {
    if (this.outputFileSymlinks == null) {
      this.outputFileSymlinks = new ArrayList<>();
    }
    this.outputFileSymlinks.add(outputFileSymlinksItem);
    return this;
  }

  /**
   * The output files of the action that are symbolic links to other files. Those may be links to other output files, or input files, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. For each output file requested in the &#x60;output_files&#x60; or &#x60;output_paths&#x60; field of the Action, if the corresponding file existed after the action completed, a single entry will be present either in this field, or in the &#x60;output_files&#x60; field, if the file was not a symbolic link. If an output symbolic link of the same name as listed in &#x60;output_files&#x60; of the Command was found, but its target type was not a regular file, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted. DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API should still populate this field in addition to &#x60;output_symlinks&#x60;.
   * @return outputFileSymlinks
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<BuildBazelRemoteExecutionV2OutputSymlink> getOutputFileSymlinks() {
    return outputFileSymlinks;
  }

  @Deprecated
  public void setOutputFileSymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputFileSymlinks) {
    this.outputFileSymlinks = outputFileSymlinks;
  }


  public BuildBazelRemoteExecutionV2ActionResult outputFiles(List<BuildBazelRemoteExecutionV2OutputFile> outputFiles) {
    this.outputFiles = outputFiles;
    return this;
  }

  public BuildBazelRemoteExecutionV2ActionResult addOutputFilesItem(BuildBazelRemoteExecutionV2OutputFile outputFilesItem) {
    if (this.outputFiles == null) {
      this.outputFiles = new ArrayList<>();
    }
    this.outputFiles.add(outputFilesItem);
    return this;
  }

  /**
   * The output files of the action. For each output file requested in the &#x60;output_files&#x60; or &#x60;output_paths&#x60; field of the Action, if the corresponding file existed after the action completed, a single entry will be present either in this field, or the &#x60;output_file_symlinks&#x60; field if the file was a symbolic link to another file (&#x60;output_symlinks&#x60; field after v2.1). If an output listed in &#x60;output_files&#x60; was found, but was a directory rather than a regular file, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted.
   * @return outputFiles
   */
  @javax.annotation.Nullable
  public List<BuildBazelRemoteExecutionV2OutputFile> getOutputFiles() {
    return outputFiles;
  }

  public void setOutputFiles(List<BuildBazelRemoteExecutionV2OutputFile> outputFiles) {
    this.outputFiles = outputFiles;
  }


  public BuildBazelRemoteExecutionV2ActionResult outputSymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputSymlinks) {
    this.outputSymlinks = outputSymlinks;
    return this;
  }

  public BuildBazelRemoteExecutionV2ActionResult addOutputSymlinksItem(BuildBazelRemoteExecutionV2OutputSymlink outputSymlinksItem) {
    if (this.outputSymlinks == null) {
      this.outputSymlinks = new ArrayList<>();
    }
    this.outputSymlinks.add(outputSymlinksItem);
    return this;
  }

  /**
   * New in v2.1: this field will only be populated if the command &#x60;output_paths&#x60; field was used, and not the pre v2.1 &#x60;output_files&#x60; or &#x60;output_directories&#x60; fields. The output paths of the action that are symbolic links to other paths. Those may be links to other outputs, or inputs, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. A single entry for each output requested in &#x60;output_paths&#x60; field of the Action, if the corresponding path existed after the action completed and was a symbolic link. If the action does not produce a requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted.
   * @return outputSymlinks
   */
  @javax.annotation.Nullable
  public List<BuildBazelRemoteExecutionV2OutputSymlink> getOutputSymlinks() {
    return outputSymlinks;
  }

  public void setOutputSymlinks(List<BuildBazelRemoteExecutionV2OutputSymlink> outputSymlinks) {
    this.outputSymlinks = outputSymlinks;
  }


  public BuildBazelRemoteExecutionV2ActionResult stderrDigest(BuildBazelRemoteExecutionV2Digest stderrDigest) {
    this.stderrDigest = stderrDigest;
    return this;
  }

  /**
   * Get stderrDigest
   * @return stderrDigest
   */
  @javax.annotation.Nullable
  public BuildBazelRemoteExecutionV2Digest getStderrDigest() {
    return stderrDigest;
  }

  public void setStderrDigest(BuildBazelRemoteExecutionV2Digest stderrDigest) {
    this.stderrDigest = stderrDigest;
  }


  public BuildBazelRemoteExecutionV2ActionResult stderrRaw(byte[] stderrRaw) {
    this.stderrRaw = stderrRaw;
    return this;
  }

  /**
   * The standard error buffer of the action. The server SHOULD NOT inline stderr unless requested by the client in the GetActionResultRequest message. The server MAY omit inlining, even if requested, and MUST do so if inlining would cause the response to exceed message size limits. Clients SHOULD NOT populate this field when uploading to the cache.
   * @return stderrRaw
   */
  @javax.annotation.Nullable
  public byte[] getStderrRaw() {
    return stderrRaw;
  }

  public void setStderrRaw(byte[] stderrRaw) {
    this.stderrRaw = stderrRaw;
  }


  public BuildBazelRemoteExecutionV2ActionResult stdoutDigest(BuildBazelRemoteExecutionV2Digest stdoutDigest) {
    this.stdoutDigest = stdoutDigest;
    return this;
  }

  /**
   * Get stdoutDigest
   * @return stdoutDigest
   */
  @javax.annotation.Nullable
  public BuildBazelRemoteExecutionV2Digest getStdoutDigest() {
    return stdoutDigest;
  }

  public void setStdoutDigest(BuildBazelRemoteExecutionV2Digest stdoutDigest) {
    this.stdoutDigest = stdoutDigest;
  }


  public BuildBazelRemoteExecutionV2ActionResult stdoutRaw(byte[] stdoutRaw) {
    this.stdoutRaw = stdoutRaw;
    return this;
  }

  /**
   * The standard output buffer of the action. The server SHOULD NOT inline stdout unless requested by the client in the GetActionResultRequest message. The server MAY omit inlining, even if requested, and MUST do so if inlining would cause the response to exceed message size limits. Clients SHOULD NOT populate this field when uploading to the cache.
   * @return stdoutRaw
   */
  @javax.annotation.Nullable
  public byte[] getStdoutRaw() {
    return stdoutRaw;
  }

  public void setStdoutRaw(byte[] stdoutRaw) {
    this.stdoutRaw = stdoutRaw;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BuildBazelRemoteExecutionV2ActionResult buildBazelRemoteExecutionV2ActionResult = (BuildBazelRemoteExecutionV2ActionResult) o;
    return Objects.equals(this.executionMetadata, buildBazelRemoteExecutionV2ActionResult.executionMetadata) &&
        Objects.equals(this.exitCode, buildBazelRemoteExecutionV2ActionResult.exitCode) &&
        Objects.equals(this.outputDirectories, buildBazelRemoteExecutionV2ActionResult.outputDirectories) &&
        Objects.equals(this.outputDirectorySymlinks, buildBazelRemoteExecutionV2ActionResult.outputDirectorySymlinks) &&
        Objects.equals(this.outputFileSymlinks, buildBazelRemoteExecutionV2ActionResult.outputFileSymlinks) &&
        Objects.equals(this.outputFiles, buildBazelRemoteExecutionV2ActionResult.outputFiles) &&
        Objects.equals(this.outputSymlinks, buildBazelRemoteExecutionV2ActionResult.outputSymlinks) &&
        Objects.equals(this.stderrDigest, buildBazelRemoteExecutionV2ActionResult.stderrDigest) &&
        Arrays.equals(this.stderrRaw, buildBazelRemoteExecutionV2ActionResult.stderrRaw) &&
        Objects.equals(this.stdoutDigest, buildBazelRemoteExecutionV2ActionResult.stdoutDigest) &&
        Arrays.equals(this.stdoutRaw, buildBazelRemoteExecutionV2ActionResult.stdoutRaw);
  }

  @Override
  public int hashCode() {
    return Objects.hash(executionMetadata, exitCode, outputDirectories, outputDirectorySymlinks, outputFileSymlinks, outputFiles, outputSymlinks, stderrDigest, Arrays.hashCode(stderrRaw), stdoutDigest, Arrays.hashCode(stdoutRaw));
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BuildBazelRemoteExecutionV2ActionResult {\n");
    sb.append("    executionMetadata: ").append(toIndentedString(executionMetadata)).append("\n");
    sb.append("    exitCode: ").append(toIndentedString(exitCode)).append("\n");
    sb.append("    outputDirectories: ").append(toIndentedString(outputDirectories)).append("\n");
    sb.append("    outputDirectorySymlinks: ").append(toIndentedString(outputDirectorySymlinks)).append("\n");
    sb.append("    outputFileSymlinks: ").append(toIndentedString(outputFileSymlinks)).append("\n");
    sb.append("    outputFiles: ").append(toIndentedString(outputFiles)).append("\n");
    sb.append("    outputSymlinks: ").append(toIndentedString(outputSymlinks)).append("\n");
    sb.append("    stderrDigest: ").append(toIndentedString(stderrDigest)).append("\n");
    sb.append("    stderrRaw: ").append(toIndentedString(stderrRaw)).append("\n");
    sb.append("    stdoutDigest: ").append(toIndentedString(stdoutDigest)).append("\n");
    sb.append("    stdoutRaw: ").append(toIndentedString(stdoutRaw)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("executionMetadata");
    openapiFields.add("exitCode");
    openapiFields.add("outputDirectories");
    openapiFields.add("outputDirectorySymlinks");
    openapiFields.add("outputFileSymlinks");
    openapiFields.add("outputFiles");
    openapiFields.add("outputSymlinks");
    openapiFields.add("stderrDigest");
    openapiFields.add("stderrRaw");
    openapiFields.add("stdoutDigest");
    openapiFields.add("stdoutRaw");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BuildBazelRemoteExecutionV2ActionResult
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BuildBazelRemoteExecutionV2ActionResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BuildBazelRemoteExecutionV2ActionResult is not found in the empty JSON string", BuildBazelRemoteExecutionV2ActionResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BuildBazelRemoteExecutionV2ActionResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BuildBazelRemoteExecutionV2ActionResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `executionMetadata`
      if (jsonObj.get("executionMetadata") != null && !jsonObj.get("executionMetadata").isJsonNull()) {
        BuildBazelRemoteExecutionV2ExecutedActionMetadata.validateJsonElement(jsonObj.get("executionMetadata"));
      }
      if (jsonObj.get("outputDirectories") != null && !jsonObj.get("outputDirectories").isJsonNull()) {
        JsonArray jsonArrayoutputDirectories = jsonObj.getAsJsonArray("outputDirectories");
        if (jsonArrayoutputDirectories != null) {
          // ensure the json data is an array
          if (!jsonObj.get("outputDirectories").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `outputDirectories` to be an array in the JSON string but got `%s`", jsonObj.get("outputDirectories").toString()));
          }

          // validate the optional field `outputDirectories` (array)
          for (int i = 0; i < jsonArrayoutputDirectories.size(); i++) {
            BuildBazelRemoteExecutionV2OutputDirectory.validateJsonElement(jsonArrayoutputDirectories.get(i));
          };
        }
      }
      if (jsonObj.get("outputDirectorySymlinks") != null && !jsonObj.get("outputDirectorySymlinks").isJsonNull()) {
        JsonArray jsonArrayoutputDirectorySymlinks = jsonObj.getAsJsonArray("outputDirectorySymlinks");
        if (jsonArrayoutputDirectorySymlinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("outputDirectorySymlinks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `outputDirectorySymlinks` to be an array in the JSON string but got `%s`", jsonObj.get("outputDirectorySymlinks").toString()));
          }

          // validate the optional field `outputDirectorySymlinks` (array)
          for (int i = 0; i < jsonArrayoutputDirectorySymlinks.size(); i++) {
            BuildBazelRemoteExecutionV2OutputSymlink.validateJsonElement(jsonArrayoutputDirectorySymlinks.get(i));
          };
        }
      }
      if (jsonObj.get("outputFileSymlinks") != null && !jsonObj.get("outputFileSymlinks").isJsonNull()) {
        JsonArray jsonArrayoutputFileSymlinks = jsonObj.getAsJsonArray("outputFileSymlinks");
        if (jsonArrayoutputFileSymlinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("outputFileSymlinks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `outputFileSymlinks` to be an array in the JSON string but got `%s`", jsonObj.get("outputFileSymlinks").toString()));
          }

          // validate the optional field `outputFileSymlinks` (array)
          for (int i = 0; i < jsonArrayoutputFileSymlinks.size(); i++) {
            BuildBazelRemoteExecutionV2OutputSymlink.validateJsonElement(jsonArrayoutputFileSymlinks.get(i));
          };
        }
      }
      if (jsonObj.get("outputFiles") != null && !jsonObj.get("outputFiles").isJsonNull()) {
        JsonArray jsonArrayoutputFiles = jsonObj.getAsJsonArray("outputFiles");
        if (jsonArrayoutputFiles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("outputFiles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `outputFiles` to be an array in the JSON string but got `%s`", jsonObj.get("outputFiles").toString()));
          }

          // validate the optional field `outputFiles` (array)
          for (int i = 0; i < jsonArrayoutputFiles.size(); i++) {
            BuildBazelRemoteExecutionV2OutputFile.validateJsonElement(jsonArrayoutputFiles.get(i));
          };
        }
      }
      if (jsonObj.get("outputSymlinks") != null && !jsonObj.get("outputSymlinks").isJsonNull()) {
        JsonArray jsonArrayoutputSymlinks = jsonObj.getAsJsonArray("outputSymlinks");
        if (jsonArrayoutputSymlinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("outputSymlinks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `outputSymlinks` to be an array in the JSON string but got `%s`", jsonObj.get("outputSymlinks").toString()));
          }

          // validate the optional field `outputSymlinks` (array)
          for (int i = 0; i < jsonArrayoutputSymlinks.size(); i++) {
            BuildBazelRemoteExecutionV2OutputSymlink.validateJsonElement(jsonArrayoutputSymlinks.get(i));
          };
        }
      }
      // validate the optional field `stderrDigest`
      if (jsonObj.get("stderrDigest") != null && !jsonObj.get("stderrDigest").isJsonNull()) {
        BuildBazelRemoteExecutionV2Digest.validateJsonElement(jsonObj.get("stderrDigest"));
      }
      // validate the optional field `stdoutDigest`
      if (jsonObj.get("stdoutDigest") != null && !jsonObj.get("stdoutDigest").isJsonNull()) {
        BuildBazelRemoteExecutionV2Digest.validateJsonElement(jsonObj.get("stdoutDigest"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BuildBazelRemoteExecutionV2ActionResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BuildBazelRemoteExecutionV2ActionResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BuildBazelRemoteExecutionV2ActionResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BuildBazelRemoteExecutionV2ActionResult.class));

       return (TypeAdapter<T>) new TypeAdapter<BuildBazelRemoteExecutionV2ActionResult>() {
           @Override
           public void write(JsonWriter out, BuildBazelRemoteExecutionV2ActionResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BuildBazelRemoteExecutionV2ActionResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BuildBazelRemoteExecutionV2ActionResult given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BuildBazelRemoteExecutionV2ActionResult
   * @throws IOException if the JSON string is invalid with respect to BuildBazelRemoteExecutionV2ActionResult
   */
  public static BuildBazelRemoteExecutionV2ActionResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BuildBazelRemoteExecutionV2ActionResult.class);
  }

  /**
   * Convert an instance of BuildBazelRemoteExecutionV2ActionResult to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

