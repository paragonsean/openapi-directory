/*
 * Remote Build Execution API
 * Supplies a Remote Execution API service for tools such as bazel.
 *
 * The version of the OpenAPI document: v1alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ExecutedActionMetadata contains details about a completed execution.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:16.147037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildBazelRemoteExecutionV2ExecutedActionMetadata {
  public static final String SERIALIZED_NAME_AUXILIARY_METADATA = "auxiliaryMetadata";
  @SerializedName(SERIALIZED_NAME_AUXILIARY_METADATA)
  private List<Map<String, Object>> auxiliaryMetadata = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXECUTION_COMPLETED_TIMESTAMP = "executionCompletedTimestamp";
  @SerializedName(SERIALIZED_NAME_EXECUTION_COMPLETED_TIMESTAMP)
  private String executionCompletedTimestamp;

  public static final String SERIALIZED_NAME_EXECUTION_START_TIMESTAMP = "executionStartTimestamp";
  @SerializedName(SERIALIZED_NAME_EXECUTION_START_TIMESTAMP)
  private String executionStartTimestamp;

  public static final String SERIALIZED_NAME_INPUT_FETCH_COMPLETED_TIMESTAMP = "inputFetchCompletedTimestamp";
  @SerializedName(SERIALIZED_NAME_INPUT_FETCH_COMPLETED_TIMESTAMP)
  private String inputFetchCompletedTimestamp;

  public static final String SERIALIZED_NAME_INPUT_FETCH_START_TIMESTAMP = "inputFetchStartTimestamp";
  @SerializedName(SERIALIZED_NAME_INPUT_FETCH_START_TIMESTAMP)
  private String inputFetchStartTimestamp;

  public static final String SERIALIZED_NAME_OUTPUT_UPLOAD_COMPLETED_TIMESTAMP = "outputUploadCompletedTimestamp";
  @SerializedName(SERIALIZED_NAME_OUTPUT_UPLOAD_COMPLETED_TIMESTAMP)
  private String outputUploadCompletedTimestamp;

  public static final String SERIALIZED_NAME_OUTPUT_UPLOAD_START_TIMESTAMP = "outputUploadStartTimestamp";
  @SerializedName(SERIALIZED_NAME_OUTPUT_UPLOAD_START_TIMESTAMP)
  private String outputUploadStartTimestamp;

  public static final String SERIALIZED_NAME_QUEUED_TIMESTAMP = "queuedTimestamp";
  @SerializedName(SERIALIZED_NAME_QUEUED_TIMESTAMP)
  private String queuedTimestamp;

  public static final String SERIALIZED_NAME_VIRTUAL_EXECUTION_DURATION = "virtualExecutionDuration";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_EXECUTION_DURATION)
  private String virtualExecutionDuration;

  public static final String SERIALIZED_NAME_WORKER = "worker";
  @SerializedName(SERIALIZED_NAME_WORKER)
  private String worker;

  public static final String SERIALIZED_NAME_WORKER_COMPLETED_TIMESTAMP = "workerCompletedTimestamp";
  @SerializedName(SERIALIZED_NAME_WORKER_COMPLETED_TIMESTAMP)
  private String workerCompletedTimestamp;

  public static final String SERIALIZED_NAME_WORKER_START_TIMESTAMP = "workerStartTimestamp";
  @SerializedName(SERIALIZED_NAME_WORKER_START_TIMESTAMP)
  private String workerStartTimestamp;

  public BuildBazelRemoteExecutionV2ExecutedActionMetadata() {
  }

  public BuildBazelRemoteExecutionV2ExecutedActionMetadata auxiliaryMetadata(List<Map<String, Object>> auxiliaryMetadata) {
    this.auxiliaryMetadata = auxiliaryMetadata;
    return this;
  }

  public BuildBazelRemoteExecutionV2ExecutedActionMetadata addAuxiliaryMetadataItem(Map<String, Object> auxiliaryMetadataItem) {
    if (this.auxiliaryMetadata == null) {
      this.auxiliaryMetadata = new ArrayList<>();
    }
    this.auxiliaryMetadata.add(auxiliaryMetadataItem);
    return this;
  }

  /**
   * Details that are specific to the kind of worker used. For example, on POSIX-like systems this could contain a message with getrusage(2) statistics.
   * @return auxiliaryMetadata
   */
  @javax.annotation.Nullable
  public List<Map<String, Object>> getAuxiliaryMetadata() {
    return auxiliaryMetadata;
  }

  public void setAuxiliaryMetadata(List<Map<String, Object>> auxiliaryMetadata) {
    this.auxiliaryMetadata = auxiliaryMetadata;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata executionCompletedTimestamp(String executionCompletedTimestamp) {
    this.executionCompletedTimestamp = executionCompletedTimestamp;
    return this;
  }

  /**
   * When the worker completed executing the action command.
   * @return executionCompletedTimestamp
   */
  @javax.annotation.Nullable
  public String getExecutionCompletedTimestamp() {
    return executionCompletedTimestamp;
  }

  public void setExecutionCompletedTimestamp(String executionCompletedTimestamp) {
    this.executionCompletedTimestamp = executionCompletedTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata executionStartTimestamp(String executionStartTimestamp) {
    this.executionStartTimestamp = executionStartTimestamp;
    return this;
  }

  /**
   * When the worker started executing the action command.
   * @return executionStartTimestamp
   */
  @javax.annotation.Nullable
  public String getExecutionStartTimestamp() {
    return executionStartTimestamp;
  }

  public void setExecutionStartTimestamp(String executionStartTimestamp) {
    this.executionStartTimestamp = executionStartTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata inputFetchCompletedTimestamp(String inputFetchCompletedTimestamp) {
    this.inputFetchCompletedTimestamp = inputFetchCompletedTimestamp;
    return this;
  }

  /**
   * When the worker finished fetching action inputs.
   * @return inputFetchCompletedTimestamp
   */
  @javax.annotation.Nullable
  public String getInputFetchCompletedTimestamp() {
    return inputFetchCompletedTimestamp;
  }

  public void setInputFetchCompletedTimestamp(String inputFetchCompletedTimestamp) {
    this.inputFetchCompletedTimestamp = inputFetchCompletedTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata inputFetchStartTimestamp(String inputFetchStartTimestamp) {
    this.inputFetchStartTimestamp = inputFetchStartTimestamp;
    return this;
  }

  /**
   * When the worker started fetching action inputs.
   * @return inputFetchStartTimestamp
   */
  @javax.annotation.Nullable
  public String getInputFetchStartTimestamp() {
    return inputFetchStartTimestamp;
  }

  public void setInputFetchStartTimestamp(String inputFetchStartTimestamp) {
    this.inputFetchStartTimestamp = inputFetchStartTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata outputUploadCompletedTimestamp(String outputUploadCompletedTimestamp) {
    this.outputUploadCompletedTimestamp = outputUploadCompletedTimestamp;
    return this;
  }

  /**
   * When the worker finished uploading action outputs.
   * @return outputUploadCompletedTimestamp
   */
  @javax.annotation.Nullable
  public String getOutputUploadCompletedTimestamp() {
    return outputUploadCompletedTimestamp;
  }

  public void setOutputUploadCompletedTimestamp(String outputUploadCompletedTimestamp) {
    this.outputUploadCompletedTimestamp = outputUploadCompletedTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata outputUploadStartTimestamp(String outputUploadStartTimestamp) {
    this.outputUploadStartTimestamp = outputUploadStartTimestamp;
    return this;
  }

  /**
   * When the worker started uploading action outputs.
   * @return outputUploadStartTimestamp
   */
  @javax.annotation.Nullable
  public String getOutputUploadStartTimestamp() {
    return outputUploadStartTimestamp;
  }

  public void setOutputUploadStartTimestamp(String outputUploadStartTimestamp) {
    this.outputUploadStartTimestamp = outputUploadStartTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata queuedTimestamp(String queuedTimestamp) {
    this.queuedTimestamp = queuedTimestamp;
    return this;
  }

  /**
   * When was the action added to the queue.
   * @return queuedTimestamp
   */
  @javax.annotation.Nullable
  public String getQueuedTimestamp() {
    return queuedTimestamp;
  }

  public void setQueuedTimestamp(String queuedTimestamp) {
    this.queuedTimestamp = queuedTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata virtualExecutionDuration(String virtualExecutionDuration) {
    this.virtualExecutionDuration = virtualExecutionDuration;
    return this;
  }

  /**
   * New in v2.3: the amount of time the worker spent executing the action command, potentially computed using a worker-specific virtual clock. The virtual execution duration is only intended to cover the \&quot;execution\&quot; of the specified action and not time in queue nor any overheads before or after execution such as marshalling inputs/outputs. The server SHOULD avoid including time spent the client doesn&#39;t have control over, and MAY extend or reduce the execution duration to account for delays or speedups that occur during execution itself (e.g., lazily loading data from the Content Addressable Storage, live migration of virtual machines, emulation overhead). The method of timekeeping used to compute the virtual execution duration MUST be consistent with what is used to enforce the Action&#39;s &#x60;timeout&#x60;. There is no relationship between the virtual execution duration and the values of &#x60;execution_start_timestamp&#x60; and &#x60;execution_completed_timestamp&#x60;.
   * @return virtualExecutionDuration
   */
  @javax.annotation.Nullable
  public String getVirtualExecutionDuration() {
    return virtualExecutionDuration;
  }

  public void setVirtualExecutionDuration(String virtualExecutionDuration) {
    this.virtualExecutionDuration = virtualExecutionDuration;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata worker(String worker) {
    this.worker = worker;
    return this;
  }

  /**
   * The name of the worker which ran the execution.
   * @return worker
   */
  @javax.annotation.Nullable
  public String getWorker() {
    return worker;
  }

  public void setWorker(String worker) {
    this.worker = worker;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata workerCompletedTimestamp(String workerCompletedTimestamp) {
    this.workerCompletedTimestamp = workerCompletedTimestamp;
    return this;
  }

  /**
   * When the worker completed the action, including all stages.
   * @return workerCompletedTimestamp
   */
  @javax.annotation.Nullable
  public String getWorkerCompletedTimestamp() {
    return workerCompletedTimestamp;
  }

  public void setWorkerCompletedTimestamp(String workerCompletedTimestamp) {
    this.workerCompletedTimestamp = workerCompletedTimestamp;
  }


  public BuildBazelRemoteExecutionV2ExecutedActionMetadata workerStartTimestamp(String workerStartTimestamp) {
    this.workerStartTimestamp = workerStartTimestamp;
    return this;
  }

  /**
   * When the worker received the action.
   * @return workerStartTimestamp
   */
  @javax.annotation.Nullable
  public String getWorkerStartTimestamp() {
    return workerStartTimestamp;
  }

  public void setWorkerStartTimestamp(String workerStartTimestamp) {
    this.workerStartTimestamp = workerStartTimestamp;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BuildBazelRemoteExecutionV2ExecutedActionMetadata buildBazelRemoteExecutionV2ExecutedActionMetadata = (BuildBazelRemoteExecutionV2ExecutedActionMetadata) o;
    return Objects.equals(this.auxiliaryMetadata, buildBazelRemoteExecutionV2ExecutedActionMetadata.auxiliaryMetadata) &&
        Objects.equals(this.executionCompletedTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.executionCompletedTimestamp) &&
        Objects.equals(this.executionStartTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.executionStartTimestamp) &&
        Objects.equals(this.inputFetchCompletedTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.inputFetchCompletedTimestamp) &&
        Objects.equals(this.inputFetchStartTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.inputFetchStartTimestamp) &&
        Objects.equals(this.outputUploadCompletedTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.outputUploadCompletedTimestamp) &&
        Objects.equals(this.outputUploadStartTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.outputUploadStartTimestamp) &&
        Objects.equals(this.queuedTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.queuedTimestamp) &&
        Objects.equals(this.virtualExecutionDuration, buildBazelRemoteExecutionV2ExecutedActionMetadata.virtualExecutionDuration) &&
        Objects.equals(this.worker, buildBazelRemoteExecutionV2ExecutedActionMetadata.worker) &&
        Objects.equals(this.workerCompletedTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.workerCompletedTimestamp) &&
        Objects.equals(this.workerStartTimestamp, buildBazelRemoteExecutionV2ExecutedActionMetadata.workerStartTimestamp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(auxiliaryMetadata, executionCompletedTimestamp, executionStartTimestamp, inputFetchCompletedTimestamp, inputFetchStartTimestamp, outputUploadCompletedTimestamp, outputUploadStartTimestamp, queuedTimestamp, virtualExecutionDuration, worker, workerCompletedTimestamp, workerStartTimestamp);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BuildBazelRemoteExecutionV2ExecutedActionMetadata {\n");
    sb.append("    auxiliaryMetadata: ").append(toIndentedString(auxiliaryMetadata)).append("\n");
    sb.append("    executionCompletedTimestamp: ").append(toIndentedString(executionCompletedTimestamp)).append("\n");
    sb.append("    executionStartTimestamp: ").append(toIndentedString(executionStartTimestamp)).append("\n");
    sb.append("    inputFetchCompletedTimestamp: ").append(toIndentedString(inputFetchCompletedTimestamp)).append("\n");
    sb.append("    inputFetchStartTimestamp: ").append(toIndentedString(inputFetchStartTimestamp)).append("\n");
    sb.append("    outputUploadCompletedTimestamp: ").append(toIndentedString(outputUploadCompletedTimestamp)).append("\n");
    sb.append("    outputUploadStartTimestamp: ").append(toIndentedString(outputUploadStartTimestamp)).append("\n");
    sb.append("    queuedTimestamp: ").append(toIndentedString(queuedTimestamp)).append("\n");
    sb.append("    virtualExecutionDuration: ").append(toIndentedString(virtualExecutionDuration)).append("\n");
    sb.append("    worker: ").append(toIndentedString(worker)).append("\n");
    sb.append("    workerCompletedTimestamp: ").append(toIndentedString(workerCompletedTimestamp)).append("\n");
    sb.append("    workerStartTimestamp: ").append(toIndentedString(workerStartTimestamp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("auxiliaryMetadata");
    openapiFields.add("executionCompletedTimestamp");
    openapiFields.add("executionStartTimestamp");
    openapiFields.add("inputFetchCompletedTimestamp");
    openapiFields.add("inputFetchStartTimestamp");
    openapiFields.add("outputUploadCompletedTimestamp");
    openapiFields.add("outputUploadStartTimestamp");
    openapiFields.add("queuedTimestamp");
    openapiFields.add("virtualExecutionDuration");
    openapiFields.add("worker");
    openapiFields.add("workerCompletedTimestamp");
    openapiFields.add("workerStartTimestamp");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BuildBazelRemoteExecutionV2ExecutedActionMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BuildBazelRemoteExecutionV2ExecutedActionMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BuildBazelRemoteExecutionV2ExecutedActionMetadata is not found in the empty JSON string", BuildBazelRemoteExecutionV2ExecutedActionMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BuildBazelRemoteExecutionV2ExecutedActionMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BuildBazelRemoteExecutionV2ExecutedActionMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("auxiliaryMetadata") != null && !jsonObj.get("auxiliaryMetadata").isJsonNull() && !jsonObj.get("auxiliaryMetadata").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `auxiliaryMetadata` to be an array in the JSON string but got `%s`", jsonObj.get("auxiliaryMetadata").toString()));
      }
      if ((jsonObj.get("executionCompletedTimestamp") != null && !jsonObj.get("executionCompletedTimestamp").isJsonNull()) && !jsonObj.get("executionCompletedTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `executionCompletedTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("executionCompletedTimestamp").toString()));
      }
      if ((jsonObj.get("executionStartTimestamp") != null && !jsonObj.get("executionStartTimestamp").isJsonNull()) && !jsonObj.get("executionStartTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `executionStartTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("executionStartTimestamp").toString()));
      }
      if ((jsonObj.get("inputFetchCompletedTimestamp") != null && !jsonObj.get("inputFetchCompletedTimestamp").isJsonNull()) && !jsonObj.get("inputFetchCompletedTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inputFetchCompletedTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inputFetchCompletedTimestamp").toString()));
      }
      if ((jsonObj.get("inputFetchStartTimestamp") != null && !jsonObj.get("inputFetchStartTimestamp").isJsonNull()) && !jsonObj.get("inputFetchStartTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inputFetchStartTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inputFetchStartTimestamp").toString()));
      }
      if ((jsonObj.get("outputUploadCompletedTimestamp") != null && !jsonObj.get("outputUploadCompletedTimestamp").isJsonNull()) && !jsonObj.get("outputUploadCompletedTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputUploadCompletedTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputUploadCompletedTimestamp").toString()));
      }
      if ((jsonObj.get("outputUploadStartTimestamp") != null && !jsonObj.get("outputUploadStartTimestamp").isJsonNull()) && !jsonObj.get("outputUploadStartTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputUploadStartTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputUploadStartTimestamp").toString()));
      }
      if ((jsonObj.get("queuedTimestamp") != null && !jsonObj.get("queuedTimestamp").isJsonNull()) && !jsonObj.get("queuedTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queuedTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queuedTimestamp").toString()));
      }
      if ((jsonObj.get("virtualExecutionDuration") != null && !jsonObj.get("virtualExecutionDuration").isJsonNull()) && !jsonObj.get("virtualExecutionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `virtualExecutionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("virtualExecutionDuration").toString()));
      }
      if ((jsonObj.get("worker") != null && !jsonObj.get("worker").isJsonNull()) && !jsonObj.get("worker").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `worker` to be a primitive type in the JSON string but got `%s`", jsonObj.get("worker").toString()));
      }
      if ((jsonObj.get("workerCompletedTimestamp") != null && !jsonObj.get("workerCompletedTimestamp").isJsonNull()) && !jsonObj.get("workerCompletedTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerCompletedTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerCompletedTimestamp").toString()));
      }
      if ((jsonObj.get("workerStartTimestamp") != null && !jsonObj.get("workerStartTimestamp").isJsonNull()) && !jsonObj.get("workerStartTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerStartTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerStartTimestamp").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BuildBazelRemoteExecutionV2ExecutedActionMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BuildBazelRemoteExecutionV2ExecutedActionMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BuildBazelRemoteExecutionV2ExecutedActionMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BuildBazelRemoteExecutionV2ExecutedActionMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<BuildBazelRemoteExecutionV2ExecutedActionMetadata>() {
           @Override
           public void write(JsonWriter out, BuildBazelRemoteExecutionV2ExecutedActionMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BuildBazelRemoteExecutionV2ExecutedActionMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BuildBazelRemoteExecutionV2ExecutedActionMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BuildBazelRemoteExecutionV2ExecutedActionMetadata
   * @throws IOException if the JSON string is invalid with respect to BuildBazelRemoteExecutionV2ExecutedActionMetadata
   */
  public static BuildBazelRemoteExecutionV2ExecutedActionMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BuildBazelRemoteExecutionV2ExecutedActionMetadata.class);
  }

  /**
   * Convert an instance of BuildBazelRemoteExecutionV2ExecutedActionMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

