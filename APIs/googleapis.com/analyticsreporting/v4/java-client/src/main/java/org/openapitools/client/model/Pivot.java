/*
 * Analytics Reporting API
 * Accesses Analytics report data.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Dimension;
import org.openapitools.client.model.DimensionFilterClause;
import org.openapitools.client.model.Metric;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Pivot describes the pivot section in the request. The Pivot helps rearrange the information in the table for certain reports by pivoting your data on a second dimension.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:33.190781-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Pivot {
  public static final String SERIALIZED_NAME_DIMENSION_FILTER_CLAUSES = "dimensionFilterClauses";
  @SerializedName(SERIALIZED_NAME_DIMENSION_FILTER_CLAUSES)
  private List<DimensionFilterClause> dimensionFilterClauses = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIMENSIONS = "dimensions";
  @SerializedName(SERIALIZED_NAME_DIMENSIONS)
  private List<Dimension> dimensions = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAX_GROUP_COUNT = "maxGroupCount";
  @SerializedName(SERIALIZED_NAME_MAX_GROUP_COUNT)
  private Integer maxGroupCount;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<Metric> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_GROUP = "startGroup";
  @SerializedName(SERIALIZED_NAME_START_GROUP)
  private Integer startGroup;

  public Pivot() {
  }

  public Pivot dimensionFilterClauses(List<DimensionFilterClause> dimensionFilterClauses) {
    this.dimensionFilterClauses = dimensionFilterClauses;
    return this;
  }

  public Pivot addDimensionFilterClausesItem(DimensionFilterClause dimensionFilterClausesItem) {
    if (this.dimensionFilterClauses == null) {
      this.dimensionFilterClauses = new ArrayList<>();
    }
    this.dimensionFilterClauses.add(dimensionFilterClausesItem);
    return this;
  }

  /**
   * DimensionFilterClauses are logically combined with an &#x60;AND&#x60; operator: only data that is included by all these DimensionFilterClauses contributes to the values in this pivot region. Dimension filters can be used to restrict the columns shown in the pivot region. For example if you have &#x60;ga:browser&#x60; as the requested dimension in the pivot region, and you specify key filters to restrict &#x60;ga:browser&#x60; to only \&quot;IE\&quot; or \&quot;Firefox\&quot;, then only those two browsers would show up as columns.
   * @return dimensionFilterClauses
   */
  @javax.annotation.Nullable
  public List<DimensionFilterClause> getDimensionFilterClauses() {
    return dimensionFilterClauses;
  }

  public void setDimensionFilterClauses(List<DimensionFilterClause> dimensionFilterClauses) {
    this.dimensionFilterClauses = dimensionFilterClauses;
  }


  public Pivot dimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
    return this;
  }

  public Pivot addDimensionsItem(Dimension dimensionsItem) {
    if (this.dimensions == null) {
      this.dimensions = new ArrayList<>();
    }
    this.dimensions.add(dimensionsItem);
    return this;
  }

  /**
   * A list of dimensions to show as pivot columns. A Pivot can have a maximum of 4 dimensions. Pivot dimensions are part of the restriction on the total number of dimensions allowed in the request.
   * @return dimensions
   */
  @javax.annotation.Nullable
  public List<Dimension> getDimensions() {
    return dimensions;
  }

  public void setDimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
  }


  public Pivot maxGroupCount(Integer maxGroupCount) {
    this.maxGroupCount = maxGroupCount;
    return this;
  }

  /**
   * Specifies the maximum number of groups to return. The default value is 10, also the maximum value is 1,000.
   * @return maxGroupCount
   */
  @javax.annotation.Nullable
  public Integer getMaxGroupCount() {
    return maxGroupCount;
  }

  public void setMaxGroupCount(Integer maxGroupCount) {
    this.maxGroupCount = maxGroupCount;
  }


  public Pivot metrics(List<Metric> metrics) {
    this.metrics = metrics;
    return this;
  }

  public Pivot addMetricsItem(Metric metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

  /**
   * The pivot metrics. Pivot metrics are part of the restriction on total number of metrics allowed in the request.
   * @return metrics
   */
  @javax.annotation.Nullable
  public List<Metric> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<Metric> metrics) {
    this.metrics = metrics;
  }


  public Pivot startGroup(Integer startGroup) {
    this.startGroup = startGroup;
    return this;
  }

  /**
   * If k metrics were requested, then the response will contain some data-dependent multiple of k columns in the report. E.g., if you pivoted on the dimension &#x60;ga:browser&#x60; then you&#39;d get k columns for \&quot;Firefox\&quot;, k columns for \&quot;IE\&quot;, k columns for \&quot;Chrome\&quot;, etc. The ordering of the groups of columns is determined by descending order of \&quot;total\&quot; for the first of the k values. Ties are broken by lexicographic ordering of the first pivot dimension, then lexicographic ordering of the second pivot dimension, and so on. E.g., if the totals for the first value for Firefox, IE, and Chrome were 8, 2, 8, respectively, the order of columns would be Chrome, Firefox, IE. The following let you choose which of the groups of k columns are included in the response.
   * @return startGroup
   */
  @javax.annotation.Nullable
  public Integer getStartGroup() {
    return startGroup;
  }

  public void setStartGroup(Integer startGroup) {
    this.startGroup = startGroup;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Pivot pivot = (Pivot) o;
    return Objects.equals(this.dimensionFilterClauses, pivot.dimensionFilterClauses) &&
        Objects.equals(this.dimensions, pivot.dimensions) &&
        Objects.equals(this.maxGroupCount, pivot.maxGroupCount) &&
        Objects.equals(this.metrics, pivot.metrics) &&
        Objects.equals(this.startGroup, pivot.startGroup);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dimensionFilterClauses, dimensions, maxGroupCount, metrics, startGroup);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Pivot {\n");
    sb.append("    dimensionFilterClauses: ").append(toIndentedString(dimensionFilterClauses)).append("\n");
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("    maxGroupCount: ").append(toIndentedString(maxGroupCount)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    startGroup: ").append(toIndentedString(startGroup)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dimensionFilterClauses");
    openapiFields.add("dimensions");
    openapiFields.add("maxGroupCount");
    openapiFields.add("metrics");
    openapiFields.add("startGroup");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Pivot
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Pivot.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Pivot is not found in the empty JSON string", Pivot.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Pivot.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Pivot` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("dimensionFilterClauses") != null && !jsonObj.get("dimensionFilterClauses").isJsonNull()) {
        JsonArray jsonArraydimensionFilterClauses = jsonObj.getAsJsonArray("dimensionFilterClauses");
        if (jsonArraydimensionFilterClauses != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensionFilterClauses").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensionFilterClauses` to be an array in the JSON string but got `%s`", jsonObj.get("dimensionFilterClauses").toString()));
          }

          // validate the optional field `dimensionFilterClauses` (array)
          for (int i = 0; i < jsonArraydimensionFilterClauses.size(); i++) {
            DimensionFilterClause.validateJsonElement(jsonArraydimensionFilterClauses.get(i));
          };
        }
      }
      if (jsonObj.get("dimensions") != null && !jsonObj.get("dimensions").isJsonNull()) {
        JsonArray jsonArraydimensions = jsonObj.getAsJsonArray("dimensions");
        if (jsonArraydimensions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensions` to be an array in the JSON string but got `%s`", jsonObj.get("dimensions").toString()));
          }

          // validate the optional field `dimensions` (array)
          for (int i = 0; i < jsonArraydimensions.size(); i++) {
            Dimension.validateJsonElement(jsonArraydimensions.get(i));
          };
        }
      }
      if (jsonObj.get("metrics") != null && !jsonObj.get("metrics").isJsonNull()) {
        JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
        if (jsonArraymetrics != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metrics").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
          }

          // validate the optional field `metrics` (array)
          for (int i = 0; i < jsonArraymetrics.size(); i++) {
            Metric.validateJsonElement(jsonArraymetrics.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Pivot.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Pivot' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Pivot> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Pivot.class));

       return (TypeAdapter<T>) new TypeAdapter<Pivot>() {
           @Override
           public void write(JsonWriter out, Pivot value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Pivot read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Pivot given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Pivot
   * @throws IOException if the JSON string is invalid with respect to Pivot
   */
  public static Pivot fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Pivot.class);
  }

  /**
   * Convert an instance of Pivot to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

