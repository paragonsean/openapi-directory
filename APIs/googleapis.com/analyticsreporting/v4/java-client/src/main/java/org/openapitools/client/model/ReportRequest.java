/*
 * Analytics Reporting API
 * Accesses Analytics report data.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CohortGroup;
import org.openapitools.client.model.DateRange;
import org.openapitools.client.model.Dimension;
import org.openapitools.client.model.DimensionFilterClause;
import org.openapitools.client.model.Metric;
import org.openapitools.client.model.MetricFilterClause;
import org.openapitools.client.model.OrderBy;
import org.openapitools.client.model.Pivot;
import org.openapitools.client.model.Segment;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The main request class which specifies the Reporting API request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:33.190781-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReportRequest {
  public static final String SERIALIZED_NAME_COHORT_GROUP = "cohortGroup";
  @SerializedName(SERIALIZED_NAME_COHORT_GROUP)
  private CohortGroup cohortGroup;

  public static final String SERIALIZED_NAME_DATE_RANGES = "dateRanges";
  @SerializedName(SERIALIZED_NAME_DATE_RANGES)
  private List<DateRange> dateRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIMENSION_FILTER_CLAUSES = "dimensionFilterClauses";
  @SerializedName(SERIALIZED_NAME_DIMENSION_FILTER_CLAUSES)
  private List<DimensionFilterClause> dimensionFilterClauses = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIMENSIONS = "dimensions";
  @SerializedName(SERIALIZED_NAME_DIMENSIONS)
  private List<Dimension> dimensions = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTERS_EXPRESSION = "filtersExpression";
  @SerializedName(SERIALIZED_NAME_FILTERS_EXPRESSION)
  private String filtersExpression;

  public static final String SERIALIZED_NAME_HIDE_TOTALS = "hideTotals";
  @SerializedName(SERIALIZED_NAME_HIDE_TOTALS)
  private Boolean hideTotals;

  public static final String SERIALIZED_NAME_HIDE_VALUE_RANGES = "hideValueRanges";
  @SerializedName(SERIALIZED_NAME_HIDE_VALUE_RANGES)
  private Boolean hideValueRanges;

  public static final String SERIALIZED_NAME_INCLUDE_EMPTY_ROWS = "includeEmptyRows";
  @SerializedName(SERIALIZED_NAME_INCLUDE_EMPTY_ROWS)
  private Boolean includeEmptyRows;

  public static final String SERIALIZED_NAME_METRIC_FILTER_CLAUSES = "metricFilterClauses";
  @SerializedName(SERIALIZED_NAME_METRIC_FILTER_CLAUSES)
  private List<MetricFilterClause> metricFilterClauses = new ArrayList<>();

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<Metric> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_ORDER_BYS = "orderBys";
  @SerializedName(SERIALIZED_NAME_ORDER_BYS)
  private List<OrderBy> orderBys = new ArrayList<>();

  public static final String SERIALIZED_NAME_PAGE_SIZE = "pageSize";
  @SerializedName(SERIALIZED_NAME_PAGE_SIZE)
  private Integer pageSize;

  public static final String SERIALIZED_NAME_PAGE_TOKEN = "pageToken";
  @SerializedName(SERIALIZED_NAME_PAGE_TOKEN)
  private String pageToken;

  public static final String SERIALIZED_NAME_PIVOTS = "pivots";
  @SerializedName(SERIALIZED_NAME_PIVOTS)
  private List<Pivot> pivots = new ArrayList<>();

  /**
   * The desired report [sample](https://support.google.com/analytics/answer/2637192) size. If the the &#x60;samplingLevel&#x60; field is unspecified the &#x60;DEFAULT&#x60; sampling level is used. Every [ReportRequest](#ReportRequest) within a &#x60;batchGet&#x60; method must contain the same &#x60;samplingLevel&#x60; definition. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
   */
  @JsonAdapter(SamplingLevelEnum.Adapter.class)
  public enum SamplingLevelEnum {
    SAMPLING_UNSPECIFIED("SAMPLING_UNSPECIFIED"),
    
    DEFAULT("DEFAULT"),
    
    SMALL("SMALL"),
    
    LARGE("LARGE");

    private String value;

    SamplingLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SamplingLevelEnum fromValue(String value) {
      for (SamplingLevelEnum b : SamplingLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SamplingLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SamplingLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SamplingLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SamplingLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SamplingLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SAMPLING_LEVEL = "samplingLevel";
  @SerializedName(SERIALIZED_NAME_SAMPLING_LEVEL)
  private SamplingLevelEnum samplingLevel;

  public static final String SERIALIZED_NAME_SEGMENTS = "segments";
  @SerializedName(SERIALIZED_NAME_SEGMENTS)
  private List<Segment> segments = new ArrayList<>();

  public static final String SERIALIZED_NAME_VIEW_ID = "viewId";
  @SerializedName(SERIALIZED_NAME_VIEW_ID)
  private String viewId;

  public ReportRequest() {
  }

  public ReportRequest cohortGroup(CohortGroup cohortGroup) {
    this.cohortGroup = cohortGroup;
    return this;
  }

  /**
   * Get cohortGroup
   * @return cohortGroup
   */
  @javax.annotation.Nullable
  public CohortGroup getCohortGroup() {
    return cohortGroup;
  }

  public void setCohortGroup(CohortGroup cohortGroup) {
    this.cohortGroup = cohortGroup;
  }


  public ReportRequest dateRanges(List<DateRange> dateRanges) {
    this.dateRanges = dateRanges;
    return this;
  }

  public ReportRequest addDateRangesItem(DateRange dateRangesItem) {
    if (this.dateRanges == null) {
      this.dateRanges = new ArrayList<>();
    }
    this.dateRanges.add(dateRangesItem);
    return this;
  }

  /**
   * Date ranges in the request. The request can have a maximum of 2 date ranges. The response will contain a set of metric values for each combination of the dimensions for each date range in the request. So, if there are two date ranges, there will be two set of metric values, one for the original date range and one for the second date range. The &#x60;reportRequest.dateRanges&#x60; field should not be specified for cohorts or Lifetime value requests. If a date range is not provided, the default date range is (startDate: current date - 7 days, endDate: current date - 1 day). Every [ReportRequest](#ReportRequest) within a &#x60;batchGet&#x60; method must contain the same &#x60;dateRanges&#x60; definition.
   * @return dateRanges
   */
  @javax.annotation.Nullable
  public List<DateRange> getDateRanges() {
    return dateRanges;
  }

  public void setDateRanges(List<DateRange> dateRanges) {
    this.dateRanges = dateRanges;
  }


  public ReportRequest dimensionFilterClauses(List<DimensionFilterClause> dimensionFilterClauses) {
    this.dimensionFilterClauses = dimensionFilterClauses;
    return this;
  }

  public ReportRequest addDimensionFilterClausesItem(DimensionFilterClause dimensionFilterClausesItem) {
    if (this.dimensionFilterClauses == null) {
      this.dimensionFilterClauses = new ArrayList<>();
    }
    this.dimensionFilterClauses.add(dimensionFilterClausesItem);
    return this;
  }

  /**
   * The dimension filter clauses for filtering Dimension Values. They are logically combined with the &#x60;AND&#x60; operator. Note that filtering occurs before any dimensions are aggregated, so that the returned metrics represent the total for only the relevant dimensions.
   * @return dimensionFilterClauses
   */
  @javax.annotation.Nullable
  public List<DimensionFilterClause> getDimensionFilterClauses() {
    return dimensionFilterClauses;
  }

  public void setDimensionFilterClauses(List<DimensionFilterClause> dimensionFilterClauses) {
    this.dimensionFilterClauses = dimensionFilterClauses;
  }


  public ReportRequest dimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
    return this;
  }

  public ReportRequest addDimensionsItem(Dimension dimensionsItem) {
    if (this.dimensions == null) {
      this.dimensions = new ArrayList<>();
    }
    this.dimensions.add(dimensionsItem);
    return this;
  }

  /**
   * The dimensions requested. Requests can have a total of 9 dimensions.
   * @return dimensions
   */
  @javax.annotation.Nullable
  public List<Dimension> getDimensions() {
    return dimensions;
  }

  public void setDimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
  }


  public ReportRequest filtersExpression(String filtersExpression) {
    this.filtersExpression = filtersExpression;
    return this;
  }

  /**
   * Dimension or metric filters that restrict the data returned for your request. To use the &#x60;filtersExpression&#x60;, supply a dimension or metric on which to filter, followed by the filter expression. For example, the following expression selects &#x60;ga:browser&#x60; dimension which starts with Firefox; &#x60;ga:browser&#x3D;~^Firefox&#x60;. For more information on dimensions and metric filters, see [Filters reference](https://developers.google.com/analytics/devguides/reporting/core/v3/reference#filters).
   * @return filtersExpression
   */
  @javax.annotation.Nullable
  public String getFiltersExpression() {
    return filtersExpression;
  }

  public void setFiltersExpression(String filtersExpression) {
    this.filtersExpression = filtersExpression;
  }


  public ReportRequest hideTotals(Boolean hideTotals) {
    this.hideTotals = hideTotals;
    return this;
  }

  /**
   * If set to true, hides the total of all metrics for all the matching rows, for every date range. The default false and will return the totals.
   * @return hideTotals
   */
  @javax.annotation.Nullable
  public Boolean getHideTotals() {
    return hideTotals;
  }

  public void setHideTotals(Boolean hideTotals) {
    this.hideTotals = hideTotals;
  }


  public ReportRequest hideValueRanges(Boolean hideValueRanges) {
    this.hideValueRanges = hideValueRanges;
    return this;
  }

  /**
   * If set to true, hides the minimum and maximum across all matching rows. The default is false and the value ranges are returned.
   * @return hideValueRanges
   */
  @javax.annotation.Nullable
  public Boolean getHideValueRanges() {
    return hideValueRanges;
  }

  public void setHideValueRanges(Boolean hideValueRanges) {
    this.hideValueRanges = hideValueRanges;
  }


  public ReportRequest includeEmptyRows(Boolean includeEmptyRows) {
    this.includeEmptyRows = includeEmptyRows;
    return this;
  }

  /**
   * If set to false, the response does not include rows if all the retrieved metrics are equal to zero. The default is false which will exclude these rows.
   * @return includeEmptyRows
   */
  @javax.annotation.Nullable
  public Boolean getIncludeEmptyRows() {
    return includeEmptyRows;
  }

  public void setIncludeEmptyRows(Boolean includeEmptyRows) {
    this.includeEmptyRows = includeEmptyRows;
  }


  public ReportRequest metricFilterClauses(List<MetricFilterClause> metricFilterClauses) {
    this.metricFilterClauses = metricFilterClauses;
    return this;
  }

  public ReportRequest addMetricFilterClausesItem(MetricFilterClause metricFilterClausesItem) {
    if (this.metricFilterClauses == null) {
      this.metricFilterClauses = new ArrayList<>();
    }
    this.metricFilterClauses.add(metricFilterClausesItem);
    return this;
  }

  /**
   * The metric filter clauses. They are logically combined with the &#x60;AND&#x60; operator. Metric filters look at only the first date range and not the comparing date range. Note that filtering on metrics occurs after the metrics are aggregated.
   * @return metricFilterClauses
   */
  @javax.annotation.Nullable
  public List<MetricFilterClause> getMetricFilterClauses() {
    return metricFilterClauses;
  }

  public void setMetricFilterClauses(List<MetricFilterClause> metricFilterClauses) {
    this.metricFilterClauses = metricFilterClauses;
  }


  public ReportRequest metrics(List<Metric> metrics) {
    this.metrics = metrics;
    return this;
  }

  public ReportRequest addMetricsItem(Metric metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

  /**
   * The metrics requested. Requests must specify at least one metric. Requests can have a total of 10 metrics.
   * @return metrics
   */
  @javax.annotation.Nullable
  public List<Metric> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<Metric> metrics) {
    this.metrics = metrics;
  }


  public ReportRequest orderBys(List<OrderBy> orderBys) {
    this.orderBys = orderBys;
    return this;
  }

  public ReportRequest addOrderBysItem(OrderBy orderBysItem) {
    if (this.orderBys == null) {
      this.orderBys = new ArrayList<>();
    }
    this.orderBys.add(orderBysItem);
    return this;
  }

  /**
   * Sort order on output rows. To compare two rows, the elements of the following are applied in order until a difference is found. All date ranges in the output get the same row order.
   * @return orderBys
   */
  @javax.annotation.Nullable
  public List<OrderBy> getOrderBys() {
    return orderBys;
  }

  public void setOrderBys(List<OrderBy> orderBys) {
    this.orderBys = orderBys;
  }


  public ReportRequest pageSize(Integer pageSize) {
    this.pageSize = pageSize;
    return this;
  }

  /**
   * Page size is for paging and specifies the maximum number of returned rows. Page size should be &gt;&#x3D; 0. A query returns the default of 1,000 rows. The Analytics Core Reporting API returns a maximum of 100,000 rows per request, no matter how many you ask for. It can also return fewer rows than requested, if there aren&#39;t as many dimension segments as you expect. For instance, there are fewer than 300 possible values for &#x60;ga:country&#x60;, so when segmenting only by country, you can&#39;t get more than 300 rows, even if you set &#x60;pageSize&#x60; to a higher value.
   * @return pageSize
   */
  @javax.annotation.Nullable
  public Integer getPageSize() {
    return pageSize;
  }

  public void setPageSize(Integer pageSize) {
    this.pageSize = pageSize;
  }


  public ReportRequest pageToken(String pageToken) {
    this.pageToken = pageToken;
    return this;
  }

  /**
   * A continuation token to get the next page of the results. Adding this to the request will return the rows after the pageToken. The pageToken should be the value returned in the nextPageToken parameter in the response to the GetReports request.
   * @return pageToken
   */
  @javax.annotation.Nullable
  public String getPageToken() {
    return pageToken;
  }

  public void setPageToken(String pageToken) {
    this.pageToken = pageToken;
  }


  public ReportRequest pivots(List<Pivot> pivots) {
    this.pivots = pivots;
    return this;
  }

  public ReportRequest addPivotsItem(Pivot pivotsItem) {
    if (this.pivots == null) {
      this.pivots = new ArrayList<>();
    }
    this.pivots.add(pivotsItem);
    return this;
  }

  /**
   * The pivot definitions. Requests can have a maximum of 2 pivots.
   * @return pivots
   */
  @javax.annotation.Nullable
  public List<Pivot> getPivots() {
    return pivots;
  }

  public void setPivots(List<Pivot> pivots) {
    this.pivots = pivots;
  }


  public ReportRequest samplingLevel(SamplingLevelEnum samplingLevel) {
    this.samplingLevel = samplingLevel;
    return this;
  }

  /**
   * The desired report [sample](https://support.google.com/analytics/answer/2637192) size. If the the &#x60;samplingLevel&#x60; field is unspecified the &#x60;DEFAULT&#x60; sampling level is used. Every [ReportRequest](#ReportRequest) within a &#x60;batchGet&#x60; method must contain the same &#x60;samplingLevel&#x60; definition. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
   * @return samplingLevel
   */
  @javax.annotation.Nullable
  public SamplingLevelEnum getSamplingLevel() {
    return samplingLevel;
  }

  public void setSamplingLevel(SamplingLevelEnum samplingLevel) {
    this.samplingLevel = samplingLevel;
  }


  public ReportRequest segments(List<Segment> segments) {
    this.segments = segments;
    return this;
  }

  public ReportRequest addSegmentsItem(Segment segmentsItem) {
    if (this.segments == null) {
      this.segments = new ArrayList<>();
    }
    this.segments.add(segmentsItem);
    return this;
  }

  /**
   * Segment the data returned for the request. A segment definition helps look at a subset of the segment request. A request can contain up to four segments. Every [ReportRequest](#ReportRequest) within a &#x60;batchGet&#x60; method must contain the same &#x60;segments&#x60; definition. Requests with segments must have the &#x60;ga:segment&#x60; dimension.
   * @return segments
   */
  @javax.annotation.Nullable
  public List<Segment> getSegments() {
    return segments;
  }

  public void setSegments(List<Segment> segments) {
    this.segments = segments;
  }


  public ReportRequest viewId(String viewId) {
    this.viewId = viewId;
    return this;
  }

  /**
   * The Analytics [view ID](https://support.google.com/analytics/answer/1009618) from which to retrieve data. Every [ReportRequest](#ReportRequest) within a &#x60;batchGet&#x60; method must contain the same &#x60;viewId&#x60;.
   * @return viewId
   */
  @javax.annotation.Nullable
  public String getViewId() {
    return viewId;
  }

  public void setViewId(String viewId) {
    this.viewId = viewId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReportRequest reportRequest = (ReportRequest) o;
    return Objects.equals(this.cohortGroup, reportRequest.cohortGroup) &&
        Objects.equals(this.dateRanges, reportRequest.dateRanges) &&
        Objects.equals(this.dimensionFilterClauses, reportRequest.dimensionFilterClauses) &&
        Objects.equals(this.dimensions, reportRequest.dimensions) &&
        Objects.equals(this.filtersExpression, reportRequest.filtersExpression) &&
        Objects.equals(this.hideTotals, reportRequest.hideTotals) &&
        Objects.equals(this.hideValueRanges, reportRequest.hideValueRanges) &&
        Objects.equals(this.includeEmptyRows, reportRequest.includeEmptyRows) &&
        Objects.equals(this.metricFilterClauses, reportRequest.metricFilterClauses) &&
        Objects.equals(this.metrics, reportRequest.metrics) &&
        Objects.equals(this.orderBys, reportRequest.orderBys) &&
        Objects.equals(this.pageSize, reportRequest.pageSize) &&
        Objects.equals(this.pageToken, reportRequest.pageToken) &&
        Objects.equals(this.pivots, reportRequest.pivots) &&
        Objects.equals(this.samplingLevel, reportRequest.samplingLevel) &&
        Objects.equals(this.segments, reportRequest.segments) &&
        Objects.equals(this.viewId, reportRequest.viewId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cohortGroup, dateRanges, dimensionFilterClauses, dimensions, filtersExpression, hideTotals, hideValueRanges, includeEmptyRows, metricFilterClauses, metrics, orderBys, pageSize, pageToken, pivots, samplingLevel, segments, viewId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReportRequest {\n");
    sb.append("    cohortGroup: ").append(toIndentedString(cohortGroup)).append("\n");
    sb.append("    dateRanges: ").append(toIndentedString(dateRanges)).append("\n");
    sb.append("    dimensionFilterClauses: ").append(toIndentedString(dimensionFilterClauses)).append("\n");
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("    filtersExpression: ").append(toIndentedString(filtersExpression)).append("\n");
    sb.append("    hideTotals: ").append(toIndentedString(hideTotals)).append("\n");
    sb.append("    hideValueRanges: ").append(toIndentedString(hideValueRanges)).append("\n");
    sb.append("    includeEmptyRows: ").append(toIndentedString(includeEmptyRows)).append("\n");
    sb.append("    metricFilterClauses: ").append(toIndentedString(metricFilterClauses)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    orderBys: ").append(toIndentedString(orderBys)).append("\n");
    sb.append("    pageSize: ").append(toIndentedString(pageSize)).append("\n");
    sb.append("    pageToken: ").append(toIndentedString(pageToken)).append("\n");
    sb.append("    pivots: ").append(toIndentedString(pivots)).append("\n");
    sb.append("    samplingLevel: ").append(toIndentedString(samplingLevel)).append("\n");
    sb.append("    segments: ").append(toIndentedString(segments)).append("\n");
    sb.append("    viewId: ").append(toIndentedString(viewId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cohortGroup");
    openapiFields.add("dateRanges");
    openapiFields.add("dimensionFilterClauses");
    openapiFields.add("dimensions");
    openapiFields.add("filtersExpression");
    openapiFields.add("hideTotals");
    openapiFields.add("hideValueRanges");
    openapiFields.add("includeEmptyRows");
    openapiFields.add("metricFilterClauses");
    openapiFields.add("metrics");
    openapiFields.add("orderBys");
    openapiFields.add("pageSize");
    openapiFields.add("pageToken");
    openapiFields.add("pivots");
    openapiFields.add("samplingLevel");
    openapiFields.add("segments");
    openapiFields.add("viewId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReportRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReportRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReportRequest is not found in the empty JSON string", ReportRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReportRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReportRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `cohortGroup`
      if (jsonObj.get("cohortGroup") != null && !jsonObj.get("cohortGroup").isJsonNull()) {
        CohortGroup.validateJsonElement(jsonObj.get("cohortGroup"));
      }
      if (jsonObj.get("dateRanges") != null && !jsonObj.get("dateRanges").isJsonNull()) {
        JsonArray jsonArraydateRanges = jsonObj.getAsJsonArray("dateRanges");
        if (jsonArraydateRanges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dateRanges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dateRanges` to be an array in the JSON string but got `%s`", jsonObj.get("dateRanges").toString()));
          }

          // validate the optional field `dateRanges` (array)
          for (int i = 0; i < jsonArraydateRanges.size(); i++) {
            DateRange.validateJsonElement(jsonArraydateRanges.get(i));
          };
        }
      }
      if (jsonObj.get("dimensionFilterClauses") != null && !jsonObj.get("dimensionFilterClauses").isJsonNull()) {
        JsonArray jsonArraydimensionFilterClauses = jsonObj.getAsJsonArray("dimensionFilterClauses");
        if (jsonArraydimensionFilterClauses != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensionFilterClauses").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensionFilterClauses` to be an array in the JSON string but got `%s`", jsonObj.get("dimensionFilterClauses").toString()));
          }

          // validate the optional field `dimensionFilterClauses` (array)
          for (int i = 0; i < jsonArraydimensionFilterClauses.size(); i++) {
            DimensionFilterClause.validateJsonElement(jsonArraydimensionFilterClauses.get(i));
          };
        }
      }
      if (jsonObj.get("dimensions") != null && !jsonObj.get("dimensions").isJsonNull()) {
        JsonArray jsonArraydimensions = jsonObj.getAsJsonArray("dimensions");
        if (jsonArraydimensions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensions` to be an array in the JSON string but got `%s`", jsonObj.get("dimensions").toString()));
          }

          // validate the optional field `dimensions` (array)
          for (int i = 0; i < jsonArraydimensions.size(); i++) {
            Dimension.validateJsonElement(jsonArraydimensions.get(i));
          };
        }
      }
      if ((jsonObj.get("filtersExpression") != null && !jsonObj.get("filtersExpression").isJsonNull()) && !jsonObj.get("filtersExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filtersExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filtersExpression").toString()));
      }
      if (jsonObj.get("metricFilterClauses") != null && !jsonObj.get("metricFilterClauses").isJsonNull()) {
        JsonArray jsonArraymetricFilterClauses = jsonObj.getAsJsonArray("metricFilterClauses");
        if (jsonArraymetricFilterClauses != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metricFilterClauses").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metricFilterClauses` to be an array in the JSON string but got `%s`", jsonObj.get("metricFilterClauses").toString()));
          }

          // validate the optional field `metricFilterClauses` (array)
          for (int i = 0; i < jsonArraymetricFilterClauses.size(); i++) {
            MetricFilterClause.validateJsonElement(jsonArraymetricFilterClauses.get(i));
          };
        }
      }
      if (jsonObj.get("metrics") != null && !jsonObj.get("metrics").isJsonNull()) {
        JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
        if (jsonArraymetrics != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metrics").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
          }

          // validate the optional field `metrics` (array)
          for (int i = 0; i < jsonArraymetrics.size(); i++) {
            Metric.validateJsonElement(jsonArraymetrics.get(i));
          };
        }
      }
      if (jsonObj.get("orderBys") != null && !jsonObj.get("orderBys").isJsonNull()) {
        JsonArray jsonArrayorderBys = jsonObj.getAsJsonArray("orderBys");
        if (jsonArrayorderBys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("orderBys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `orderBys` to be an array in the JSON string but got `%s`", jsonObj.get("orderBys").toString()));
          }

          // validate the optional field `orderBys` (array)
          for (int i = 0; i < jsonArrayorderBys.size(); i++) {
            OrderBy.validateJsonElement(jsonArrayorderBys.get(i));
          };
        }
      }
      if ((jsonObj.get("pageToken") != null && !jsonObj.get("pageToken").isJsonNull()) && !jsonObj.get("pageToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pageToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pageToken").toString()));
      }
      if (jsonObj.get("pivots") != null && !jsonObj.get("pivots").isJsonNull()) {
        JsonArray jsonArraypivots = jsonObj.getAsJsonArray("pivots");
        if (jsonArraypivots != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pivots").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pivots` to be an array in the JSON string but got `%s`", jsonObj.get("pivots").toString()));
          }

          // validate the optional field `pivots` (array)
          for (int i = 0; i < jsonArraypivots.size(); i++) {
            Pivot.validateJsonElement(jsonArraypivots.get(i));
          };
        }
      }
      if ((jsonObj.get("samplingLevel") != null && !jsonObj.get("samplingLevel").isJsonNull()) && !jsonObj.get("samplingLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `samplingLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("samplingLevel").toString()));
      }
      // validate the optional field `samplingLevel`
      if (jsonObj.get("samplingLevel") != null && !jsonObj.get("samplingLevel").isJsonNull()) {
        SamplingLevelEnum.validateJsonElement(jsonObj.get("samplingLevel"));
      }
      if (jsonObj.get("segments") != null && !jsonObj.get("segments").isJsonNull()) {
        JsonArray jsonArraysegments = jsonObj.getAsJsonArray("segments");
        if (jsonArraysegments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("segments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `segments` to be an array in the JSON string but got `%s`", jsonObj.get("segments").toString()));
          }

          // validate the optional field `segments` (array)
          for (int i = 0; i < jsonArraysegments.size(); i++) {
            Segment.validateJsonElement(jsonArraysegments.get(i));
          };
        }
      }
      if ((jsonObj.get("viewId") != null && !jsonObj.get("viewId").isJsonNull()) && !jsonObj.get("viewId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `viewId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("viewId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReportRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReportRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReportRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReportRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ReportRequest>() {
           @Override
           public void write(JsonWriter out, ReportRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReportRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReportRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReportRequest
   * @throws IOException if the JSON string is invalid with respect to ReportRequest
   */
  public static ReportRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReportRequest.class);
  }

  /**
   * Convert an instance of ReportRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

