# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class SegmentMetricFilter(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, comparison_value: str=None, max_comparison_value: str=None, metric_name: str=None, operator: str=None, scope: str=None):
        """SegmentMetricFilter - a model defined in OpenAPI

        :param comparison_value: The comparison_value of this SegmentMetricFilter.
        :param max_comparison_value: The max_comparison_value of this SegmentMetricFilter.
        :param metric_name: The metric_name of this SegmentMetricFilter.
        :param operator: The operator of this SegmentMetricFilter.
        :param scope: The scope of this SegmentMetricFilter.
        """
        self.openapi_types = {
            'comparison_value': str,
            'max_comparison_value': str,
            'metric_name': str,
            'operator': str,
            'scope': str
        }

        self.attribute_map = {
            'comparison_value': 'comparisonValue',
            'max_comparison_value': 'maxComparisonValue',
            'metric_name': 'metricName',
            'operator': 'operator',
            'scope': 'scope'
        }

        self._comparison_value = comparison_value
        self._max_comparison_value = max_comparison_value
        self._metric_name = metric_name
        self._operator = operator
        self._scope = scope

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SegmentMetricFilter':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SegmentMetricFilter of this SegmentMetricFilter.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def comparison_value(self):
        """Gets the comparison_value of this SegmentMetricFilter.

        The value to compare against. If the operator is `BETWEEN`, this value is treated as minimum comparison value.

        :return: The comparison_value of this SegmentMetricFilter.
        :rtype: str
        """
        return self._comparison_value

    @comparison_value.setter
    def comparison_value(self, comparison_value):
        """Sets the comparison_value of this SegmentMetricFilter.

        The value to compare against. If the operator is `BETWEEN`, this value is treated as minimum comparison value.

        :param comparison_value: The comparison_value of this SegmentMetricFilter.
        :type comparison_value: str
        """

        self._comparison_value = comparison_value

    @property
    def max_comparison_value(self):
        """Gets the max_comparison_value of this SegmentMetricFilter.

        Max comparison value is only used for `BETWEEN` operator.

        :return: The max_comparison_value of this SegmentMetricFilter.
        :rtype: str
        """
        return self._max_comparison_value

    @max_comparison_value.setter
    def max_comparison_value(self, max_comparison_value):
        """Sets the max_comparison_value of this SegmentMetricFilter.

        Max comparison value is only used for `BETWEEN` operator.

        :param max_comparison_value: The max_comparison_value of this SegmentMetricFilter.
        :type max_comparison_value: str
        """

        self._max_comparison_value = max_comparison_value

    @property
    def metric_name(self):
        """Gets the metric_name of this SegmentMetricFilter.

        The metric that will be filtered on. A `metricFilter` must contain a metric name.

        :return: The metric_name of this SegmentMetricFilter.
        :rtype: str
        """
        return self._metric_name

    @metric_name.setter
    def metric_name(self, metric_name):
        """Sets the metric_name of this SegmentMetricFilter.

        The metric that will be filtered on. A `metricFilter` must contain a metric name.

        :param metric_name: The metric_name of this SegmentMetricFilter.
        :type metric_name: str
        """

        self._metric_name = metric_name

    @property
    def operator(self):
        """Gets the operator of this SegmentMetricFilter.

        Specifies is the operation to perform to compare the metric. The default is `EQUAL`.

        :return: The operator of this SegmentMetricFilter.
        :rtype: str
        """
        return self._operator

    @operator.setter
    def operator(self, operator):
        """Sets the operator of this SegmentMetricFilter.

        Specifies is the operation to perform to compare the metric. The default is `EQUAL`.

        :param operator: The operator of this SegmentMetricFilter.
        :type operator: str
        """
        allowed_values = ["UNSPECIFIED_OPERATOR", "LESS_THAN", "GREATER_THAN", "EQUAL", "BETWEEN"]  # noqa: E501
        if operator not in allowed_values:
            raise ValueError(
                "Invalid value for `operator` ({0}), must be one of {1}"
                .format(operator, allowed_values)
            )

        self._operator = operator

    @property
    def scope(self):
        """Gets the scope of this SegmentMetricFilter.

        Scope for a metric defines the level at which that metric is defined. The specified metric scope must be equal to or greater than its primary scope as defined in the data model. The primary scope is defined by if the segment is selecting users or sessions.

        :return: The scope of this SegmentMetricFilter.
        :rtype: str
        """
        return self._scope

    @scope.setter
    def scope(self, scope):
        """Sets the scope of this SegmentMetricFilter.

        Scope for a metric defines the level at which that metric is defined. The specified metric scope must be equal to or greater than its primary scope as defined in the data model. The primary scope is defined by if the segment is selecting users or sessions.

        :param scope: The scope of this SegmentMetricFilter.
        :type scope: str
        """
        allowed_values = ["UNSPECIFIED_SCOPE", "PRODUCT", "HIT", "SESSION", "USER"]  # noqa: E501
        if scope not in allowed_values:
            raise ValueError(
                "Invalid value for `scope` ({0}), must be one of {1}"
                .format(scope, allowed_values)
            )

        self._scope = scope
