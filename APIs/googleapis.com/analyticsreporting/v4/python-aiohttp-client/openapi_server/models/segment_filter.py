# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.sequence_segment import SequenceSegment
from openapi_server.models.simple_segment import SimpleSegment
from openapi_server import util


class SegmentFilter(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, _not: bool=None, sequence_segment: SequenceSegment=None, simple_segment: SimpleSegment=None):
        """SegmentFilter - a model defined in OpenAPI

        :param _not: The _not of this SegmentFilter.
        :param sequence_segment: The sequence_segment of this SegmentFilter.
        :param simple_segment: The simple_segment of this SegmentFilter.
        """
        self.openapi_types = {
            '_not': bool,
            'sequence_segment': SequenceSegment,
            'simple_segment': SimpleSegment
        }

        self.attribute_map = {
            '_not': 'not',
            'sequence_segment': 'sequenceSegment',
            'simple_segment': 'simpleSegment'
        }

        self.__not = _not
        self._sequence_segment = sequence_segment
        self._simple_segment = simple_segment

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SegmentFilter':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SegmentFilter of this SegmentFilter.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def _not(self):
        """Gets the _not of this SegmentFilter.

        If true, match the complement of simple or sequence segment. For example, to match all visits not from \"New York\", we can define the segment as follows: \"sessionSegment\": { \"segmentFilters\": [{ \"simpleSegment\" :{ \"orFiltersForSegment\": [{ \"segmentFilterClauses\":[{ \"dimensionFilter\": { \"dimensionName\": \"ga:city\", \"expressions\": [\"New York\"] } }] }] }, \"not\": \"True\" }] },

        :return: The _not of this SegmentFilter.
        :rtype: bool
        """
        return self.__not

    @_not.setter
    def _not(self, _not):
        """Sets the _not of this SegmentFilter.

        If true, match the complement of simple or sequence segment. For example, to match all visits not from \"New York\", we can define the segment as follows: \"sessionSegment\": { \"segmentFilters\": [{ \"simpleSegment\" :{ \"orFiltersForSegment\": [{ \"segmentFilterClauses\":[{ \"dimensionFilter\": { \"dimensionName\": \"ga:city\", \"expressions\": [\"New York\"] } }] }] }, \"not\": \"True\" }] },

        :param _not: The _not of this SegmentFilter.
        :type _not: bool
        """

        self.__not = _not

    @property
    def sequence_segment(self):
        """Gets the sequence_segment of this SegmentFilter.


        :return: The sequence_segment of this SegmentFilter.
        :rtype: SequenceSegment
        """
        return self._sequence_segment

    @sequence_segment.setter
    def sequence_segment(self, sequence_segment):
        """Sets the sequence_segment of this SegmentFilter.


        :param sequence_segment: The sequence_segment of this SegmentFilter.
        :type sequence_segment: SequenceSegment
        """

        self._sequence_segment = sequence_segment

    @property
    def simple_segment(self):
        """Gets the simple_segment of this SegmentFilter.


        :return: The simple_segment of this SegmentFilter.
        :rtype: SimpleSegment
        """
        return self._simple_segment

    @simple_segment.setter
    def simple_segment(self, simple_segment):
        """Sets the simple_segment of this SegmentFilter.


        :param simple_segment: The simple_segment of this SegmentFilter.
        :type simple_segment: SimpleSegment
        """

        self._simple_segment = simple_segment
