/**
 * Fitness API
 * The Fitness API for managing users' fitness tracking data.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAggregateRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAggregateRequest::OAIAggregateRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAggregateRequest::OAIAggregateRequest() {
    this->initializeModel();
}

OAIAggregateRequest::~OAIAggregateRequest() {}

void OAIAggregateRequest::initializeModel() {

    m_aggregate_by_isSet = false;
    m_aggregate_by_isValid = false;

    m_bucket_by_activity_segment_isSet = false;
    m_bucket_by_activity_segment_isValid = false;

    m_bucket_by_activity_type_isSet = false;
    m_bucket_by_activity_type_isValid = false;

    m_bucket_by_session_isSet = false;
    m_bucket_by_session_isValid = false;

    m_bucket_by_time_isSet = false;
    m_bucket_by_time_isValid = false;

    m_end_time_millis_isSet = false;
    m_end_time_millis_isValid = false;

    m_filtered_data_quality_standard_isSet = false;
    m_filtered_data_quality_standard_isValid = false;

    m_start_time_millis_isSet = false;
    m_start_time_millis_isValid = false;
}

void OAIAggregateRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAggregateRequest::fromJsonObject(QJsonObject json) {

    m_aggregate_by_isValid = ::OpenAPI::fromJsonValue(m_aggregate_by, json[QString("aggregateBy")]);
    m_aggregate_by_isSet = !json[QString("aggregateBy")].isNull() && m_aggregate_by_isValid;

    m_bucket_by_activity_segment_isValid = ::OpenAPI::fromJsonValue(m_bucket_by_activity_segment, json[QString("bucketByActivitySegment")]);
    m_bucket_by_activity_segment_isSet = !json[QString("bucketByActivitySegment")].isNull() && m_bucket_by_activity_segment_isValid;

    m_bucket_by_activity_type_isValid = ::OpenAPI::fromJsonValue(m_bucket_by_activity_type, json[QString("bucketByActivityType")]);
    m_bucket_by_activity_type_isSet = !json[QString("bucketByActivityType")].isNull() && m_bucket_by_activity_type_isValid;

    m_bucket_by_session_isValid = ::OpenAPI::fromJsonValue(m_bucket_by_session, json[QString("bucketBySession")]);
    m_bucket_by_session_isSet = !json[QString("bucketBySession")].isNull() && m_bucket_by_session_isValid;

    m_bucket_by_time_isValid = ::OpenAPI::fromJsonValue(m_bucket_by_time, json[QString("bucketByTime")]);
    m_bucket_by_time_isSet = !json[QString("bucketByTime")].isNull() && m_bucket_by_time_isValid;

    m_end_time_millis_isValid = ::OpenAPI::fromJsonValue(m_end_time_millis, json[QString("endTimeMillis")]);
    m_end_time_millis_isSet = !json[QString("endTimeMillis")].isNull() && m_end_time_millis_isValid;

    m_filtered_data_quality_standard_isValid = ::OpenAPI::fromJsonValue(m_filtered_data_quality_standard, json[QString("filteredDataQualityStandard")]);
    m_filtered_data_quality_standard_isSet = !json[QString("filteredDataQualityStandard")].isNull() && m_filtered_data_quality_standard_isValid;

    m_start_time_millis_isValid = ::OpenAPI::fromJsonValue(m_start_time_millis, json[QString("startTimeMillis")]);
    m_start_time_millis_isSet = !json[QString("startTimeMillis")].isNull() && m_start_time_millis_isValid;
}

QString OAIAggregateRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAggregateRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_aggregate_by.size() > 0) {
        obj.insert(QString("aggregateBy"), ::OpenAPI::toJsonValue(m_aggregate_by));
    }
    if (m_bucket_by_activity_segment.isSet()) {
        obj.insert(QString("bucketByActivitySegment"), ::OpenAPI::toJsonValue(m_bucket_by_activity_segment));
    }
    if (m_bucket_by_activity_type.isSet()) {
        obj.insert(QString("bucketByActivityType"), ::OpenAPI::toJsonValue(m_bucket_by_activity_type));
    }
    if (m_bucket_by_session.isSet()) {
        obj.insert(QString("bucketBySession"), ::OpenAPI::toJsonValue(m_bucket_by_session));
    }
    if (m_bucket_by_time.isSet()) {
        obj.insert(QString("bucketByTime"), ::OpenAPI::toJsonValue(m_bucket_by_time));
    }
    if (m_end_time_millis_isSet) {
        obj.insert(QString("endTimeMillis"), ::OpenAPI::toJsonValue(m_end_time_millis));
    }
    if (m_filtered_data_quality_standard.size() > 0) {
        obj.insert(QString("filteredDataQualityStandard"), ::OpenAPI::toJsonValue(m_filtered_data_quality_standard));
    }
    if (m_start_time_millis_isSet) {
        obj.insert(QString("startTimeMillis"), ::OpenAPI::toJsonValue(m_start_time_millis));
    }
    return obj;
}

QList<OAIAggregateBy> OAIAggregateRequest::getAggregateBy() const {
    return m_aggregate_by;
}
void OAIAggregateRequest::setAggregateBy(const QList<OAIAggregateBy> &aggregate_by) {
    m_aggregate_by = aggregate_by;
    m_aggregate_by_isSet = true;
}

bool OAIAggregateRequest::is_aggregate_by_Set() const{
    return m_aggregate_by_isSet;
}

bool OAIAggregateRequest::is_aggregate_by_Valid() const{
    return m_aggregate_by_isValid;
}

OAIBucketByActivity OAIAggregateRequest::getBucketByActivitySegment() const {
    return m_bucket_by_activity_segment;
}
void OAIAggregateRequest::setBucketByActivitySegment(const OAIBucketByActivity &bucket_by_activity_segment) {
    m_bucket_by_activity_segment = bucket_by_activity_segment;
    m_bucket_by_activity_segment_isSet = true;
}

bool OAIAggregateRequest::is_bucket_by_activity_segment_Set() const{
    return m_bucket_by_activity_segment_isSet;
}

bool OAIAggregateRequest::is_bucket_by_activity_segment_Valid() const{
    return m_bucket_by_activity_segment_isValid;
}

OAIBucketByActivity OAIAggregateRequest::getBucketByActivityType() const {
    return m_bucket_by_activity_type;
}
void OAIAggregateRequest::setBucketByActivityType(const OAIBucketByActivity &bucket_by_activity_type) {
    m_bucket_by_activity_type = bucket_by_activity_type;
    m_bucket_by_activity_type_isSet = true;
}

bool OAIAggregateRequest::is_bucket_by_activity_type_Set() const{
    return m_bucket_by_activity_type_isSet;
}

bool OAIAggregateRequest::is_bucket_by_activity_type_Valid() const{
    return m_bucket_by_activity_type_isValid;
}

OAIBucketBySession OAIAggregateRequest::getBucketBySession() const {
    return m_bucket_by_session;
}
void OAIAggregateRequest::setBucketBySession(const OAIBucketBySession &bucket_by_session) {
    m_bucket_by_session = bucket_by_session;
    m_bucket_by_session_isSet = true;
}

bool OAIAggregateRequest::is_bucket_by_session_Set() const{
    return m_bucket_by_session_isSet;
}

bool OAIAggregateRequest::is_bucket_by_session_Valid() const{
    return m_bucket_by_session_isValid;
}

OAIBucketByTime OAIAggregateRequest::getBucketByTime() const {
    return m_bucket_by_time;
}
void OAIAggregateRequest::setBucketByTime(const OAIBucketByTime &bucket_by_time) {
    m_bucket_by_time = bucket_by_time;
    m_bucket_by_time_isSet = true;
}

bool OAIAggregateRequest::is_bucket_by_time_Set() const{
    return m_bucket_by_time_isSet;
}

bool OAIAggregateRequest::is_bucket_by_time_Valid() const{
    return m_bucket_by_time_isValid;
}

QString OAIAggregateRequest::getEndTimeMillis() const {
    return m_end_time_millis;
}
void OAIAggregateRequest::setEndTimeMillis(const QString &end_time_millis) {
    m_end_time_millis = end_time_millis;
    m_end_time_millis_isSet = true;
}

bool OAIAggregateRequest::is_end_time_millis_Set() const{
    return m_end_time_millis_isSet;
}

bool OAIAggregateRequest::is_end_time_millis_Valid() const{
    return m_end_time_millis_isValid;
}

QList<QString> OAIAggregateRequest::getFilteredDataQualityStandard() const {
    return m_filtered_data_quality_standard;
}
void OAIAggregateRequest::setFilteredDataQualityStandard(const QList<QString> &filtered_data_quality_standard) {
    m_filtered_data_quality_standard = filtered_data_quality_standard;
    m_filtered_data_quality_standard_isSet = true;
}

bool OAIAggregateRequest::is_filtered_data_quality_standard_Set() const{
    return m_filtered_data_quality_standard_isSet;
}

bool OAIAggregateRequest::is_filtered_data_quality_standard_Valid() const{
    return m_filtered_data_quality_standard_isValid;
}

QString OAIAggregateRequest::getStartTimeMillis() const {
    return m_start_time_millis;
}
void OAIAggregateRequest::setStartTimeMillis(const QString &start_time_millis) {
    m_start_time_millis = start_time_millis;
    m_start_time_millis_isSet = true;
}

bool OAIAggregateRequest::is_start_time_millis_Set() const{
    return m_start_time_millis_isSet;
}

bool OAIAggregateRequest::is_start_time_millis_Valid() const{
    return m_start_time_millis_isValid;
}

bool OAIAggregateRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_aggregate_by.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_by_activity_segment.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_by_activity_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_by_session.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_by_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_time_millis_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_filtered_data_quality_standard.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_time_millis_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAggregateRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
