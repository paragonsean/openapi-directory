/**
 * Fitness API
 * The Fitness API for managing users' fitness tracking data.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AggregateBy from './AggregateBy';
import BucketByActivity from './BucketByActivity';
import BucketBySession from './BucketBySession';
import BucketByTime from './BucketByTime';

/**
 * The AggregateRequest model module.
 * @module model/AggregateRequest
 * @version v1
 */
class AggregateRequest {
    /**
     * Constructs a new <code>AggregateRequest</code>.
     * Next id: 10
     * @alias module:model/AggregateRequest
     */
    constructor() { 
        
        AggregateRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>AggregateRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/AggregateRequest} obj Optional instance to populate.
     * @return {module:model/AggregateRequest} The populated <code>AggregateRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new AggregateRequest();

            if (data.hasOwnProperty('aggregateBy')) {
                obj['aggregateBy'] = ApiClient.convertToType(data['aggregateBy'], [AggregateBy]);
            }
            if (data.hasOwnProperty('bucketByActivitySegment')) {
                obj['bucketByActivitySegment'] = BucketByActivity.constructFromObject(data['bucketByActivitySegment']);
            }
            if (data.hasOwnProperty('bucketByActivityType')) {
                obj['bucketByActivityType'] = BucketByActivity.constructFromObject(data['bucketByActivityType']);
            }
            if (data.hasOwnProperty('bucketBySession')) {
                obj['bucketBySession'] = BucketBySession.constructFromObject(data['bucketBySession']);
            }
            if (data.hasOwnProperty('bucketByTime')) {
                obj['bucketByTime'] = BucketByTime.constructFromObject(data['bucketByTime']);
            }
            if (data.hasOwnProperty('endTimeMillis')) {
                obj['endTimeMillis'] = ApiClient.convertToType(data['endTimeMillis'], 'String');
            }
            if (data.hasOwnProperty('filteredDataQualityStandard')) {
                obj['filteredDataQualityStandard'] = ApiClient.convertToType(data['filteredDataQualityStandard'], ['String']);
            }
            if (data.hasOwnProperty('startTimeMillis')) {
                obj['startTimeMillis'] = ApiClient.convertToType(data['startTimeMillis'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>AggregateRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>AggregateRequest</code>.
     */
    static validateJSON(data) {
        if (data['aggregateBy']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['aggregateBy'])) {
                throw new Error("Expected the field `aggregateBy` to be an array in the JSON data but got " + data['aggregateBy']);
            }
            // validate the optional field `aggregateBy` (array)
            for (const item of data['aggregateBy']) {
                AggregateBy.validateJSON(item);
            };
        }
        // validate the optional field `bucketByActivitySegment`
        if (data['bucketByActivitySegment']) { // data not null
          BucketByActivity.validateJSON(data['bucketByActivitySegment']);
        }
        // validate the optional field `bucketByActivityType`
        if (data['bucketByActivityType']) { // data not null
          BucketByActivity.validateJSON(data['bucketByActivityType']);
        }
        // validate the optional field `bucketBySession`
        if (data['bucketBySession']) { // data not null
          BucketBySession.validateJSON(data['bucketBySession']);
        }
        // validate the optional field `bucketByTime`
        if (data['bucketByTime']) { // data not null
          BucketByTime.validateJSON(data['bucketByTime']);
        }
        // ensure the json data is a string
        if (data['endTimeMillis'] && !(typeof data['endTimeMillis'] === 'string' || data['endTimeMillis'] instanceof String)) {
            throw new Error("Expected the field `endTimeMillis` to be a primitive type in the JSON string but got " + data['endTimeMillis']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['filteredDataQualityStandard'])) {
            throw new Error("Expected the field `filteredDataQualityStandard` to be an array in the JSON data but got " + data['filteredDataQualityStandard']);
        }
        // ensure the json data is a string
        if (data['startTimeMillis'] && !(typeof data['startTimeMillis'] === 'string' || data['startTimeMillis'] instanceof String)) {
            throw new Error("Expected the field `startTimeMillis` to be a primitive type in the JSON string but got " + data['startTimeMillis']);
        }

        return true;
    }


}



/**
 * The specification of data to be aggregated. At least one aggregateBy spec must be provided. All data that is specified will be aggregated using the same bucketing criteria. There will be one dataset in the response for every aggregateBy spec.
 * @member {Array.<module:model/AggregateBy>} aggregateBy
 */
AggregateRequest.prototype['aggregateBy'] = undefined;

/**
 * @member {module:model/BucketByActivity} bucketByActivitySegment
 */
AggregateRequest.prototype['bucketByActivitySegment'] = undefined;

/**
 * @member {module:model/BucketByActivity} bucketByActivityType
 */
AggregateRequest.prototype['bucketByActivityType'] = undefined;

/**
 * @member {module:model/BucketBySession} bucketBySession
 */
AggregateRequest.prototype['bucketBySession'] = undefined;

/**
 * @member {module:model/BucketByTime} bucketByTime
 */
AggregateRequest.prototype['bucketByTime'] = undefined;

/**
 * The end of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive. The maximum allowed difference between start_time_millis // and end_time_millis is 7776000000 (roughly 90 days).
 * @member {String} endTimeMillis
 */
AggregateRequest.prototype['endTimeMillis'] = undefined;

/**
 * DO NOT POPULATE THIS FIELD. It is ignored.
 * @member {Array.<module:model/AggregateRequest.FilteredDataQualityStandardEnum>} filteredDataQualityStandard
 */
AggregateRequest.prototype['filteredDataQualityStandard'] = undefined;

/**
 * The start of a window of time. Data that intersects with this time window will be aggregated. The time is in milliseconds since epoch, inclusive.
 * @member {String} startTimeMillis
 */
AggregateRequest.prototype['startTimeMillis'] = undefined;





/**
 * Allowed values for the <code>filteredDataQualityStandard</code> property.
 * @enum {String}
 * @readonly
 */
AggregateRequest['FilteredDataQualityStandardEnum'] = {

    /**
     * value: "dataQualityUnknown"
     * @const
     */
    "dataQualityUnknown": "dataQualityUnknown",

    /**
     * value: "dataQualityBloodPressureEsh2002"
     * @const
     */
    "dataQualityBloodPressureEsh2002": "dataQualityBloodPressureEsh2002",

    /**
     * value: "dataQualityBloodPressureEsh2010"
     * @const
     */
    "dataQualityBloodPressureEsh2010": "dataQualityBloodPressureEsh2010",

    /**
     * value: "dataQualityBloodPressureAami"
     * @const
     */
    "dataQualityBloodPressureAami": "dataQualityBloodPressureAami",

    /**
     * value: "dataQualityBloodPressureBhsAA"
     * @const
     */
    "dataQualityBloodPressureBhsAA": "dataQualityBloodPressureBhsAA",

    /**
     * value: "dataQualityBloodPressureBhsAB"
     * @const
     */
    "dataQualityBloodPressureBhsAB": "dataQualityBloodPressureBhsAB",

    /**
     * value: "dataQualityBloodPressureBhsBA"
     * @const
     */
    "dataQualityBloodPressureBhsBA": "dataQualityBloodPressureBhsBA",

    /**
     * value: "dataQualityBloodPressureBhsBB"
     * @const
     */
    "dataQualityBloodPressureBhsBB": "dataQualityBloodPressureBhsBB",

    /**
     * value: "dataQualityBloodGlucoseIso151972003"
     * @const
     */
    "dataQualityBloodGlucoseIso151972003": "dataQualityBloodGlucoseIso151972003",

    /**
     * value: "dataQualityBloodGlucoseIso151972013"
     * @const
     */
    "dataQualityBloodGlucoseIso151972013": "dataQualityBloodGlucoseIso151972013"
};



export default AggregateRequest;

