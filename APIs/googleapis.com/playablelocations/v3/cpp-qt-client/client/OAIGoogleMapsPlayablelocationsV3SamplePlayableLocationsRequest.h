/**
 * Playable Locations API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest.h
 *
 *  Life of a query: - When a game starts in a new location, your game server issues a SamplePlayableLocations request. The request specifies the S2 cell, and contains one or more \&quot;criteria\&quot; for filtering: - Criterion 0: i locations for long-lived bases, or level 0 monsters, or... - Criterion 1: j locations for short-lived bases, or level 1 monsters, ... - Criterion 2: k locations for random objects. - etc (up to 5 criterion may be specified). &#x60;PlayableLocationList&#x60; will then contain mutually exclusive lists of &#x60;PlayableLocation&#x60; objects that satisfy each of the criteria. Think of it as a collection of real-world locations that you can then associate with your game state. Note: These points are impermanent in nature. E.g, parks can close, and places can be removed. The response specifies how long you can expect the playable locations to last. Once they expire, you should query the &#x60;samplePlayableLocations&#x60; API again to get a fresh view of the real world.
 */

#ifndef OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest_H
#define OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest_H

#include <QJsonObject>

#include "OAIGoogleMapsPlayablelocationsV3SampleAreaFilter.h"
#include "OAIGoogleMapsPlayablelocationsV3SampleCriterion.h"
#include <QList>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {
class OAIGoogleMapsPlayablelocationsV3SampleAreaFilter;
class OAIGoogleMapsPlayablelocationsV3SampleCriterion;

class OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest : public OAIObject {
public:
    OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest();
    OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest(QString json);
    ~OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    OAIGoogleMapsPlayablelocationsV3SampleAreaFilter getAreaFilter() const;
    void setAreaFilter(const OAIGoogleMapsPlayablelocationsV3SampleAreaFilter &area_filter);
    bool is_area_filter_Set() const;
    bool is_area_filter_Valid() const;

    QList<OAIGoogleMapsPlayablelocationsV3SampleCriterion> getCriteria() const;
    void setCriteria(const QList<OAIGoogleMapsPlayablelocationsV3SampleCriterion> &criteria);
    bool is_criteria_Set() const;
    bool is_criteria_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    OAIGoogleMapsPlayablelocationsV3SampleAreaFilter m_area_filter;
    bool m_area_filter_isSet;
    bool m_area_filter_isValid;

    QList<OAIGoogleMapsPlayablelocationsV3SampleCriterion> m_criteria;
    bool m_criteria_isSet;
    bool m_criteria_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest)

#endif // OAIGoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest_H
