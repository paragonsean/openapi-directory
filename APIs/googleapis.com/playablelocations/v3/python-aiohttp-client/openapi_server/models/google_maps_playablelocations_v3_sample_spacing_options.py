# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class GoogleMapsPlayablelocationsV3SampleSpacingOptions(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, min_spacing_meters: float=None, point_type: str=None):
        """GoogleMapsPlayablelocationsV3SampleSpacingOptions - a model defined in OpenAPI

        :param min_spacing_meters: The min_spacing_meters of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        :param point_type: The point_type of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        """
        self.openapi_types = {
            'min_spacing_meters': float,
            'point_type': str
        }

        self.attribute_map = {
            'min_spacing_meters': 'minSpacingMeters',
            'point_type': 'pointType'
        }

        self._min_spacing_meters = min_spacing_meters
        self._point_type = point_type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'GoogleMapsPlayablelocationsV3SampleSpacingOptions':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The GoogleMapsPlayablelocationsV3SampleSpacingOptions of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def min_spacing_meters(self):
        """Gets the min_spacing_meters of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.

        Required. The minimum spacing between any two playable locations, measured in meters. The minimum value is 30. The maximum value is 1000. Inputs will be rounded up to the next 10 meter interval. The default value is 200m. Set this field to remove tight clusters of playable locations. Note: The spacing is a greedy algorithm. It optimizes for selecting the highest ranking locations first, not to maximize the number of locations selected. Consider the following scenario: * Rank: A: 2, B: 1, C: 3. * Distance: A--200m--B--200m--C If spacing=250, it will pick the highest ranked location [B], not [A, C]. Note: Spacing works within the game object type itself, as well as the previous ones. Suppose three game object types, each with the following spacing: * X: 400m, Y: undefined, Z: 200m. 1. Add locations for X, within 400m of each other. 2. Add locations for Y, without any spacing. 3. Finally, add locations for Z within 200m of each other as well X and Y. The distance diagram between those locations end up as: * From->To. * X->X: 400m * Y->X, Y->Y: unspecified. * Z->X, Z->Y, Z->Z: 200m.

        :return: The min_spacing_meters of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        :rtype: float
        """
        return self._min_spacing_meters

    @min_spacing_meters.setter
    def min_spacing_meters(self, min_spacing_meters):
        """Sets the min_spacing_meters of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.

        Required. The minimum spacing between any two playable locations, measured in meters. The minimum value is 30. The maximum value is 1000. Inputs will be rounded up to the next 10 meter interval. The default value is 200m. Set this field to remove tight clusters of playable locations. Note: The spacing is a greedy algorithm. It optimizes for selecting the highest ranking locations first, not to maximize the number of locations selected. Consider the following scenario: * Rank: A: 2, B: 1, C: 3. * Distance: A--200m--B--200m--C If spacing=250, it will pick the highest ranked location [B], not [A, C]. Note: Spacing works within the game object type itself, as well as the previous ones. Suppose three game object types, each with the following spacing: * X: 400m, Y: undefined, Z: 200m. 1. Add locations for X, within 400m of each other. 2. Add locations for Y, without any spacing. 3. Finally, add locations for Z within 200m of each other as well X and Y. The distance diagram between those locations end up as: * From->To. * X->X: 400m * Y->X, Y->Y: unspecified. * Z->X, Z->Y, Z->Z: 200m.

        :param min_spacing_meters: The min_spacing_meters of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        :type min_spacing_meters: float
        """

        self._min_spacing_meters = min_spacing_meters

    @property
    def point_type(self):
        """Gets the point_type of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.

        Specifies whether the minimum spacing constraint applies to the center-point or to the snapped point of playable locations. The default value is `CENTER_POINT`. If a snapped point is not available for a playable location, its center-point is used instead. Set this to the point type used in your game.

        :return: The point_type of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        :rtype: str
        """
        return self._point_type

    @point_type.setter
    def point_type(self, point_type):
        """Sets the point_type of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.

        Specifies whether the minimum spacing constraint applies to the center-point or to the snapped point of playable locations. The default value is `CENTER_POINT`. If a snapped point is not available for a playable location, its center-point is used instead. Set this to the point type used in your game.

        :param point_type: The point_type of this GoogleMapsPlayablelocationsV3SampleSpacingOptions.
        :type point_type: str
        """
        allowed_values = ["POINT_TYPE_UNSPECIFIED", "CENTER_POINT", "SNAPPED_POINT"]  # noqa: E501
        if point_type not in allowed_values:
            raise ValueError(
                "Invalid value for `point_type` ({0}), must be one of {1}"
                .format(point_type, allowed_values)
            )

        self._point_type = point_type
