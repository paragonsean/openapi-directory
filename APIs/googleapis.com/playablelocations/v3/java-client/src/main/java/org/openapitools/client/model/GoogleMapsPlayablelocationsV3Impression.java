/*
 * Playable Locations API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Encapsulates impression event details.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:14.298779-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleMapsPlayablelocationsV3Impression {
  public static final String SERIALIZED_NAME_GAME_OBJECT_TYPE = "gameObjectType";
  @SerializedName(SERIALIZED_NAME_GAME_OBJECT_TYPE)
  private Integer gameObjectType;

  /**
   * Required. The type of impression event.
   */
  @JsonAdapter(ImpressionTypeEnum.Adapter.class)
  public enum ImpressionTypeEnum {
    IMPRESSION_TYPE_UNSPECIFIED("IMPRESSION_TYPE_UNSPECIFIED"),
    
    PRESENTED("PRESENTED"),
    
    INTERACTED("INTERACTED");

    private String value;

    ImpressionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ImpressionTypeEnum fromValue(String value) {
      for (ImpressionTypeEnum b : ImpressionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ImpressionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ImpressionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ImpressionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ImpressionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ImpressionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IMPRESSION_TYPE = "impressionType";
  @SerializedName(SERIALIZED_NAME_IMPRESSION_TYPE)
  private ImpressionTypeEnum impressionType;

  public static final String SERIALIZED_NAME_LOCATION_NAME = "locationName";
  @SerializedName(SERIALIZED_NAME_LOCATION_NAME)
  private String locationName;

  public GoogleMapsPlayablelocationsV3Impression() {
  }

  public GoogleMapsPlayablelocationsV3Impression gameObjectType(Integer gameObjectType) {
    this.gameObjectType = gameObjectType;
    return this;
  }

  /**
   * An arbitrary, developer-defined type identifier for each type of game object used in your game. Since players interact with differ types of game objects in different ways, this field allows you to segregate impression data by type for analysis. You should assign a unique &#x60;game_object_type&#x60; ID to represent a distinct type of game object in your game. For example, 1&#x3D;monster location, 2&#x3D;powerup location.
   * @return gameObjectType
   */
  @javax.annotation.Nullable
  public Integer getGameObjectType() {
    return gameObjectType;
  }

  public void setGameObjectType(Integer gameObjectType) {
    this.gameObjectType = gameObjectType;
  }


  public GoogleMapsPlayablelocationsV3Impression impressionType(ImpressionTypeEnum impressionType) {
    this.impressionType = impressionType;
    return this;
  }

  /**
   * Required. The type of impression event.
   * @return impressionType
   */
  @javax.annotation.Nullable
  public ImpressionTypeEnum getImpressionType() {
    return impressionType;
  }

  public void setImpressionType(ImpressionTypeEnum impressionType) {
    this.impressionType = impressionType;
  }


  public GoogleMapsPlayablelocationsV3Impression locationName(String locationName) {
    this.locationName = locationName;
    return this;
  }

  /**
   * Required. The name of the playable location.
   * @return locationName
   */
  @javax.annotation.Nullable
  public String getLocationName() {
    return locationName;
  }

  public void setLocationName(String locationName) {
    this.locationName = locationName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleMapsPlayablelocationsV3Impression googleMapsPlayablelocationsV3Impression = (GoogleMapsPlayablelocationsV3Impression) o;
    return Objects.equals(this.gameObjectType, googleMapsPlayablelocationsV3Impression.gameObjectType) &&
        Objects.equals(this.impressionType, googleMapsPlayablelocationsV3Impression.impressionType) &&
        Objects.equals(this.locationName, googleMapsPlayablelocationsV3Impression.locationName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gameObjectType, impressionType, locationName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleMapsPlayablelocationsV3Impression {\n");
    sb.append("    gameObjectType: ").append(toIndentedString(gameObjectType)).append("\n");
    sb.append("    impressionType: ").append(toIndentedString(impressionType)).append("\n");
    sb.append("    locationName: ").append(toIndentedString(locationName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("gameObjectType");
    openapiFields.add("impressionType");
    openapiFields.add("locationName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleMapsPlayablelocationsV3Impression
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleMapsPlayablelocationsV3Impression.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleMapsPlayablelocationsV3Impression is not found in the empty JSON string", GoogleMapsPlayablelocationsV3Impression.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleMapsPlayablelocationsV3Impression.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleMapsPlayablelocationsV3Impression` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("impressionType") != null && !jsonObj.get("impressionType").isJsonNull()) && !jsonObj.get("impressionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `impressionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("impressionType").toString()));
      }
      // validate the optional field `impressionType`
      if (jsonObj.get("impressionType") != null && !jsonObj.get("impressionType").isJsonNull()) {
        ImpressionTypeEnum.validateJsonElement(jsonObj.get("impressionType"));
      }
      if ((jsonObj.get("locationName") != null && !jsonObj.get("locationName").isJsonNull()) && !jsonObj.get("locationName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locationName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locationName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleMapsPlayablelocationsV3Impression.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleMapsPlayablelocationsV3Impression' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleMapsPlayablelocationsV3Impression> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleMapsPlayablelocationsV3Impression.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleMapsPlayablelocationsV3Impression>() {
           @Override
           public void write(JsonWriter out, GoogleMapsPlayablelocationsV3Impression value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleMapsPlayablelocationsV3Impression read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleMapsPlayablelocationsV3Impression given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleMapsPlayablelocationsV3Impression
   * @throws IOException if the JSON string is invalid with respect to GoogleMapsPlayablelocationsV3Impression
   */
  public static GoogleMapsPlayablelocationsV3Impression fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleMapsPlayablelocationsV3Impression.class);
  }

  /**
   * Convert an instance of GoogleMapsPlayablelocationsV3Impression to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

