# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.basic_authentication import BasicAuthentication
from openapi_server.models.ping_config import PingConfig
from openapi_server.models.response_status_code import ResponseStatusCode
from openapi_server import util


class HttpCheck(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, accepted_response_status_codes: List[ResponseStatusCode]=None, auth_info: BasicAuthentication=None, body: str=None, content_type: str=None, custom_content_type: str=None, headers: Dict[str, str]=None, mask_headers: bool=None, path: str=None, ping_config: PingConfig=None, port: int=None, request_method: str=None, use_ssl: bool=None, validate_ssl: bool=None):
        """HttpCheck - a model defined in OpenAPI

        :param accepted_response_status_codes: The accepted_response_status_codes of this HttpCheck.
        :param auth_info: The auth_info of this HttpCheck.
        :param body: The body of this HttpCheck.
        :param content_type: The content_type of this HttpCheck.
        :param custom_content_type: The custom_content_type of this HttpCheck.
        :param headers: The headers of this HttpCheck.
        :param mask_headers: The mask_headers of this HttpCheck.
        :param path: The path of this HttpCheck.
        :param ping_config: The ping_config of this HttpCheck.
        :param port: The port of this HttpCheck.
        :param request_method: The request_method of this HttpCheck.
        :param use_ssl: The use_ssl of this HttpCheck.
        :param validate_ssl: The validate_ssl of this HttpCheck.
        """
        self.openapi_types = {
            'accepted_response_status_codes': List[ResponseStatusCode],
            'auth_info': BasicAuthentication,
            'body': str,
            'content_type': str,
            'custom_content_type': str,
            'headers': Dict[str, str],
            'mask_headers': bool,
            'path': str,
            'ping_config': PingConfig,
            'port': int,
            'request_method': str,
            'use_ssl': bool,
            'validate_ssl': bool
        }

        self.attribute_map = {
            'accepted_response_status_codes': 'acceptedResponseStatusCodes',
            'auth_info': 'authInfo',
            'body': 'body',
            'content_type': 'contentType',
            'custom_content_type': 'customContentType',
            'headers': 'headers',
            'mask_headers': 'maskHeaders',
            'path': 'path',
            'ping_config': 'pingConfig',
            'port': 'port',
            'request_method': 'requestMethod',
            'use_ssl': 'useSsl',
            'validate_ssl': 'validateSsl'
        }

        self._accepted_response_status_codes = accepted_response_status_codes
        self._auth_info = auth_info
        self._body = body
        self._content_type = content_type
        self._custom_content_type = custom_content_type
        self._headers = headers
        self._mask_headers = mask_headers
        self._path = path
        self._ping_config = ping_config
        self._port = port
        self._request_method = request_method
        self._use_ssl = use_ssl
        self._validate_ssl = validate_ssl

    @classmethod
    def from_dict(cls, dikt: dict) -> 'HttpCheck':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The HttpCheck of this HttpCheck.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def accepted_response_status_codes(self):
        """Gets the accepted_response_status_codes of this HttpCheck.

        If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.

        :return: The accepted_response_status_codes of this HttpCheck.
        :rtype: List[ResponseStatusCode]
        """
        return self._accepted_response_status_codes

    @accepted_response_status_codes.setter
    def accepted_response_status_codes(self, accepted_response_status_codes):
        """Sets the accepted_response_status_codes of this HttpCheck.

        If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.

        :param accepted_response_status_codes: The accepted_response_status_codes of this HttpCheck.
        :type accepted_response_status_codes: List[ResponseStatusCode]
        """

        self._accepted_response_status_codes = accepted_response_status_codes

    @property
    def auth_info(self):
        """Gets the auth_info of this HttpCheck.


        :return: The auth_info of this HttpCheck.
        :rtype: BasicAuthentication
        """
        return self._auth_info

    @auth_info.setter
    def auth_info(self, auth_info):
        """Sets the auth_info of this HttpCheck.


        :param auth_info: The auth_info of this HttpCheck.
        :type auth_info: BasicAuthentication
        """

        self._auth_info = auth_info

    @property
    def body(self):
        """Gets the body of this HttpCheck.

        The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.

        :return: The body of this HttpCheck.
        :rtype: str
        """
        return self._body

    @body.setter
    def body(self, body):
        """Sets the body of this HttpCheck.

        The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.

        :param body: The body of this HttpCheck.
        :type body: str
        """

        self._body = body

    @property
    def content_type(self):
        """Gets the content_type of this HttpCheck.

        The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a \"Content-Type\" header is provided via headers field. The content_type field should be used instead.

        :return: The content_type of this HttpCheck.
        :rtype: str
        """
        return self._content_type

    @content_type.setter
    def content_type(self, content_type):
        """Sets the content_type of this HttpCheck.

        The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a \"Content-Type\" header is provided via headers field. The content_type field should be used instead.

        :param content_type: The content_type of this HttpCheck.
        :type content_type: str
        """
        allowed_values = ["TYPE_UNSPECIFIED", "URL_ENCODED", "USER_PROVIDED"]  # noqa: E501
        if content_type not in allowed_values:
            raise ValueError(
                "Invalid value for `content_type` ({0}), must be one of {1}"
                .format(content_type, allowed_values)
            )

        self._content_type = content_type

    @property
    def custom_content_type(self):
        """Gets the custom_content_type of this HttpCheck.

        A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.

        :return: The custom_content_type of this HttpCheck.
        :rtype: str
        """
        return self._custom_content_type

    @custom_content_type.setter
    def custom_content_type(self, custom_content_type):
        """Sets the custom_content_type of this HttpCheck.

        A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.

        :param custom_content_type: The custom_content_type of this HttpCheck.
        :type custom_content_type: str
        """

        self._custom_content_type = custom_content_type

    @property
    def headers(self):
        """Gets the headers of this HttpCheck.

        The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.

        :return: The headers of this HttpCheck.
        :rtype: Dict[str, str]
        """
        return self._headers

    @headers.setter
    def headers(self, headers):
        """Sets the headers of this HttpCheck.

        The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.

        :param headers: The headers of this HttpCheck.
        :type headers: Dict[str, str]
        """

        self._headers = headers

    @property
    def mask_headers(self):
        """Gets the mask_headers of this HttpCheck.

        Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.

        :return: The mask_headers of this HttpCheck.
        :rtype: bool
        """
        return self._mask_headers

    @mask_headers.setter
    def mask_headers(self, mask_headers):
        """Sets the mask_headers of this HttpCheck.

        Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.

        :param mask_headers: The mask_headers of this HttpCheck.
        :type mask_headers: bool
        """

        self._mask_headers = mask_headers

    @property
    def path(self):
        """Gets the path of this HttpCheck.

        Optional (defaults to \"/\"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with \"/\", a \"/\" will be prepended automatically.

        :return: The path of this HttpCheck.
        :rtype: str
        """
        return self._path

    @path.setter
    def path(self, path):
        """Sets the path of this HttpCheck.

        Optional (defaults to \"/\"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with \"/\", a \"/\" will be prepended automatically.

        :param path: The path of this HttpCheck.
        :type path: str
        """

        self._path = path

    @property
    def ping_config(self):
        """Gets the ping_config of this HttpCheck.


        :return: The ping_config of this HttpCheck.
        :rtype: PingConfig
        """
        return self._ping_config

    @ping_config.setter
    def ping_config(self, ping_config):
        """Sets the ping_config of this HttpCheck.


        :param ping_config: The ping_config of this HttpCheck.
        :type ping_config: PingConfig
        """

        self._ping_config = ping_config

    @property
    def port(self):
        """Gets the port of this HttpCheck.

        Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.

        :return: The port of this HttpCheck.
        :rtype: int
        """
        return self._port

    @port.setter
    def port(self, port):
        """Sets the port of this HttpCheck.

        Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.

        :param port: The port of this HttpCheck.
        :type port: int
        """

        self._port = port

    @property
    def request_method(self):
        """Gets the request_method of this HttpCheck.

        The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.

        :return: The request_method of this HttpCheck.
        :rtype: str
        """
        return self._request_method

    @request_method.setter
    def request_method(self, request_method):
        """Sets the request_method of this HttpCheck.

        The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.

        :param request_method: The request_method of this HttpCheck.
        :type request_method: str
        """
        allowed_values = ["METHOD_UNSPECIFIED", "GET", "POST"]  # noqa: E501
        if request_method not in allowed_values:
            raise ValueError(
                "Invalid value for `request_method` ({0}), must be one of {1}"
                .format(request_method, allowed_values)
            )

        self._request_method = request_method

    @property
    def use_ssl(self):
        """Gets the use_ssl of this HttpCheck.

        If true, use HTTPS instead of HTTP to run the check.

        :return: The use_ssl of this HttpCheck.
        :rtype: bool
        """
        return self._use_ssl

    @use_ssl.setter
    def use_ssl(self, use_ssl):
        """Sets the use_ssl of this HttpCheck.

        If true, use HTTPS instead of HTTP to run the check.

        :param use_ssl: The use_ssl of this HttpCheck.
        :type use_ssl: bool
        """

        self._use_ssl = use_ssl

    @property
    def validate_ssl(self):
        """Gets the validate_ssl of this HttpCheck.

        Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.

        :return: The validate_ssl of this HttpCheck.
        :rtype: bool
        """
        return self._validate_ssl

    @validate_ssl.setter
    def validate_ssl(self, validate_ssl):
        """Sets the validate_ssl of this HttpCheck.

        Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.

        :param validate_ssl: The validate_ssl of this HttpCheck.
        :type validate_ssl: bool
        """

        self._validate_ssl = validate_ssl
