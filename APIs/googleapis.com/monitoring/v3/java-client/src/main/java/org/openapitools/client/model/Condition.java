/*
 * Cloud Monitoring API
 * Manages your Cloud Monitoring data and configurations.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.LogMatch;
import org.openapitools.client.model.MetricAbsence;
import org.openapitools.client.model.MetricThreshold;
import org.openapitools.client.model.MonitoringQueryLanguageCondition;
import org.openapitools.client.model.PrometheusQueryLanguageCondition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:42.831469-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Condition {
  public static final String SERIALIZED_NAME_CONDITION_ABSENT = "conditionAbsent";
  @SerializedName(SERIALIZED_NAME_CONDITION_ABSENT)
  private MetricAbsence conditionAbsent;

  public static final String SERIALIZED_NAME_CONDITION_MATCHED_LOG = "conditionMatchedLog";
  @SerializedName(SERIALIZED_NAME_CONDITION_MATCHED_LOG)
  private LogMatch conditionMatchedLog;

  public static final String SERIALIZED_NAME_CONDITION_MONITORING_QUERY_LANGUAGE = "conditionMonitoringQueryLanguage";
  @SerializedName(SERIALIZED_NAME_CONDITION_MONITORING_QUERY_LANGUAGE)
  private MonitoringQueryLanguageCondition conditionMonitoringQueryLanguage;

  public static final String SERIALIZED_NAME_CONDITION_PROMETHEUS_QUERY_LANGUAGE = "conditionPrometheusQueryLanguage";
  @SerializedName(SERIALIZED_NAME_CONDITION_PROMETHEUS_QUERY_LANGUAGE)
  private PrometheusQueryLanguageCondition conditionPrometheusQueryLanguage;

  public static final String SERIALIZED_NAME_CONDITION_THRESHOLD = "conditionThreshold";
  @SerializedName(SERIALIZED_NAME_CONDITION_THRESHOLD)
  private MetricThreshold conditionThreshold;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public Condition() {
  }

  public Condition conditionAbsent(MetricAbsence conditionAbsent) {
    this.conditionAbsent = conditionAbsent;
    return this;
  }

  /**
   * Get conditionAbsent
   * @return conditionAbsent
   */
  @javax.annotation.Nullable
  public MetricAbsence getConditionAbsent() {
    return conditionAbsent;
  }

  public void setConditionAbsent(MetricAbsence conditionAbsent) {
    this.conditionAbsent = conditionAbsent;
  }


  public Condition conditionMatchedLog(LogMatch conditionMatchedLog) {
    this.conditionMatchedLog = conditionMatchedLog;
    return this;
  }

  /**
   * Get conditionMatchedLog
   * @return conditionMatchedLog
   */
  @javax.annotation.Nullable
  public LogMatch getConditionMatchedLog() {
    return conditionMatchedLog;
  }

  public void setConditionMatchedLog(LogMatch conditionMatchedLog) {
    this.conditionMatchedLog = conditionMatchedLog;
  }


  public Condition conditionMonitoringQueryLanguage(MonitoringQueryLanguageCondition conditionMonitoringQueryLanguage) {
    this.conditionMonitoringQueryLanguage = conditionMonitoringQueryLanguage;
    return this;
  }

  /**
   * Get conditionMonitoringQueryLanguage
   * @return conditionMonitoringQueryLanguage
   */
  @javax.annotation.Nullable
  public MonitoringQueryLanguageCondition getConditionMonitoringQueryLanguage() {
    return conditionMonitoringQueryLanguage;
  }

  public void setConditionMonitoringQueryLanguage(MonitoringQueryLanguageCondition conditionMonitoringQueryLanguage) {
    this.conditionMonitoringQueryLanguage = conditionMonitoringQueryLanguage;
  }


  public Condition conditionPrometheusQueryLanguage(PrometheusQueryLanguageCondition conditionPrometheusQueryLanguage) {
    this.conditionPrometheusQueryLanguage = conditionPrometheusQueryLanguage;
    return this;
  }

  /**
   * Get conditionPrometheusQueryLanguage
   * @return conditionPrometheusQueryLanguage
   */
  @javax.annotation.Nullable
  public PrometheusQueryLanguageCondition getConditionPrometheusQueryLanguage() {
    return conditionPrometheusQueryLanguage;
  }

  public void setConditionPrometheusQueryLanguage(PrometheusQueryLanguageCondition conditionPrometheusQueryLanguage) {
    this.conditionPrometheusQueryLanguage = conditionPrometheusQueryLanguage;
  }


  public Condition conditionThreshold(MetricThreshold conditionThreshold) {
    this.conditionThreshold = conditionThreshold;
    return this;
  }

  /**
   * Get conditionThreshold
   * @return conditionThreshold
   */
  @javax.annotation.Nullable
  public MetricThreshold getConditionThreshold() {
    return conditionThreshold;
  }

  public void setConditionThreshold(MetricThreshold conditionThreshold) {
    this.conditionThreshold = conditionThreshold;
  }


  public Condition displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don&#39;t use the same display name for multiple conditions in the same policy.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public Condition name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Condition condition = (Condition) o;
    return Objects.equals(this.conditionAbsent, condition.conditionAbsent) &&
        Objects.equals(this.conditionMatchedLog, condition.conditionMatchedLog) &&
        Objects.equals(this.conditionMonitoringQueryLanguage, condition.conditionMonitoringQueryLanguage) &&
        Objects.equals(this.conditionPrometheusQueryLanguage, condition.conditionPrometheusQueryLanguage) &&
        Objects.equals(this.conditionThreshold, condition.conditionThreshold) &&
        Objects.equals(this.displayName, condition.displayName) &&
        Objects.equals(this.name, condition.name);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conditionAbsent, conditionMatchedLog, conditionMonitoringQueryLanguage, conditionPrometheusQueryLanguage, conditionThreshold, displayName, name);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Condition {\n");
    sb.append("    conditionAbsent: ").append(toIndentedString(conditionAbsent)).append("\n");
    sb.append("    conditionMatchedLog: ").append(toIndentedString(conditionMatchedLog)).append("\n");
    sb.append("    conditionMonitoringQueryLanguage: ").append(toIndentedString(conditionMonitoringQueryLanguage)).append("\n");
    sb.append("    conditionPrometheusQueryLanguage: ").append(toIndentedString(conditionPrometheusQueryLanguage)).append("\n");
    sb.append("    conditionThreshold: ").append(toIndentedString(conditionThreshold)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("conditionAbsent");
    openapiFields.add("conditionMatchedLog");
    openapiFields.add("conditionMonitoringQueryLanguage");
    openapiFields.add("conditionPrometheusQueryLanguage");
    openapiFields.add("conditionThreshold");
    openapiFields.add("displayName");
    openapiFields.add("name");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Condition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Condition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Condition is not found in the empty JSON string", Condition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Condition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Condition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `conditionAbsent`
      if (jsonObj.get("conditionAbsent") != null && !jsonObj.get("conditionAbsent").isJsonNull()) {
        MetricAbsence.validateJsonElement(jsonObj.get("conditionAbsent"));
      }
      // validate the optional field `conditionMatchedLog`
      if (jsonObj.get("conditionMatchedLog") != null && !jsonObj.get("conditionMatchedLog").isJsonNull()) {
        LogMatch.validateJsonElement(jsonObj.get("conditionMatchedLog"));
      }
      // validate the optional field `conditionMonitoringQueryLanguage`
      if (jsonObj.get("conditionMonitoringQueryLanguage") != null && !jsonObj.get("conditionMonitoringQueryLanguage").isJsonNull()) {
        MonitoringQueryLanguageCondition.validateJsonElement(jsonObj.get("conditionMonitoringQueryLanguage"));
      }
      // validate the optional field `conditionPrometheusQueryLanguage`
      if (jsonObj.get("conditionPrometheusQueryLanguage") != null && !jsonObj.get("conditionPrometheusQueryLanguage").isJsonNull()) {
        PrometheusQueryLanguageCondition.validateJsonElement(jsonObj.get("conditionPrometheusQueryLanguage"));
      }
      // validate the optional field `conditionThreshold`
      if (jsonObj.get("conditionThreshold") != null && !jsonObj.get("conditionThreshold").isJsonNull()) {
        MetricThreshold.validateJsonElement(jsonObj.get("conditionThreshold"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Condition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Condition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Condition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Condition.class));

       return (TypeAdapter<T>) new TypeAdapter<Condition>() {
           @Override
           public void write(JsonWriter out, Condition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Condition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Condition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Condition
   * @throws IOException if the JSON string is invalid with respect to Condition
   */
  public static Condition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Condition.class);
  }

  /**
   * Convert an instance of Condition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

