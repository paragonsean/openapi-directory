/*
 * Cloud Monitoring API
 * Manages your Cloud Monitoring data and configurations.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ContentMatcher;
import org.openapitools.client.model.HttpCheck;
import org.openapitools.client.model.InternalChecker;
import org.openapitools.client.model.MonitoredResource;
import org.openapitools.client.model.ResourceGroup;
import org.openapitools.client.model.SyntheticMonitorTarget;
import org.openapitools.client.model.TcpCheck;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This message configures which resources and services to monitor for availability.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:42.831469-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UptimeCheckConfig {
  /**
   * The type of checkers to use to execute the Uptime check.
   */
  @JsonAdapter(CheckerTypeEnum.Adapter.class)
  public enum CheckerTypeEnum {
    CHECKER_TYPE_UNSPECIFIED("CHECKER_TYPE_UNSPECIFIED"),
    
    STATIC_IP_CHECKERS("STATIC_IP_CHECKERS"),
    
    VPC_CHECKERS("VPC_CHECKERS");

    private String value;

    CheckerTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CheckerTypeEnum fromValue(String value) {
      for (CheckerTypeEnum b : CheckerTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CheckerTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CheckerTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CheckerTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CheckerTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CheckerTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CHECKER_TYPE = "checkerType";
  @SerializedName(SERIALIZED_NAME_CHECKER_TYPE)
  private CheckerTypeEnum checkerType;

  public static final String SERIALIZED_NAME_CONTENT_MATCHERS = "contentMatchers";
  @SerializedName(SERIALIZED_NAME_CONTENT_MATCHERS)
  private List<ContentMatcher> contentMatchers = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_HTTP_CHECK = "httpCheck";
  @SerializedName(SERIALIZED_NAME_HTTP_CHECK)
  private HttpCheck httpCheck;

  public static final String SERIALIZED_NAME_INTERNAL_CHECKERS = "internalCheckers";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_INTERNAL_CHECKERS)
  private List<InternalChecker> internalCheckers = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_INTERNAL = "isInternal";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_IS_INTERNAL)
  private Boolean isInternal;

  public static final String SERIALIZED_NAME_MONITORED_RESOURCE = "monitoredResource";
  @SerializedName(SERIALIZED_NAME_MONITORED_RESOURCE)
  private MonitoredResource monitoredResource;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PERIOD = "period";
  @SerializedName(SERIALIZED_NAME_PERIOD)
  private String period;

  public static final String SERIALIZED_NAME_RESOURCE_GROUP = "resourceGroup";
  @SerializedName(SERIALIZED_NAME_RESOURCE_GROUP)
  private ResourceGroup resourceGroup;

  /**
   * Gets or Sets selectedRegions
   */
  @JsonAdapter(SelectedRegionsEnum.Adapter.class)
  public enum SelectedRegionsEnum {
    REGION_UNSPECIFIED("REGION_UNSPECIFIED"),
    
    USA("USA"),
    
    EUROPE("EUROPE"),
    
    SOUTH_AMERICA("SOUTH_AMERICA"),
    
    ASIA_PACIFIC("ASIA_PACIFIC"),
    
    USA_OREGON("USA_OREGON"),
    
    USA_IOWA("USA_IOWA"),
    
    USA_VIRGINIA("USA_VIRGINIA");

    private String value;

    SelectedRegionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SelectedRegionsEnum fromValue(String value) {
      for (SelectedRegionsEnum b : SelectedRegionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SelectedRegionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SelectedRegionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SelectedRegionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SelectedRegionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SelectedRegionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SELECTED_REGIONS = "selectedRegions";
  @SerializedName(SERIALIZED_NAME_SELECTED_REGIONS)
  private List<SelectedRegionsEnum> selectedRegions = new ArrayList<>();

  public static final String SERIALIZED_NAME_SYNTHETIC_MONITOR = "syntheticMonitor";
  @SerializedName(SERIALIZED_NAME_SYNTHETIC_MONITOR)
  private SyntheticMonitorTarget syntheticMonitor;

  public static final String SERIALIZED_NAME_TCP_CHECK = "tcpCheck";
  @SerializedName(SERIALIZED_NAME_TCP_CHECK)
  private TcpCheck tcpCheck;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private String timeout;

  public static final String SERIALIZED_NAME_USER_LABELS = "userLabels";
  @SerializedName(SERIALIZED_NAME_USER_LABELS)
  private Map<String, String> userLabels = new HashMap<>();

  public UptimeCheckConfig() {
  }

  public UptimeCheckConfig checkerType(CheckerTypeEnum checkerType) {
    this.checkerType = checkerType;
    return this;
  }

  /**
   * The type of checkers to use to execute the Uptime check.
   * @return checkerType
   */
  @javax.annotation.Nullable
  public CheckerTypeEnum getCheckerType() {
    return checkerType;
  }

  public void setCheckerType(CheckerTypeEnum checkerType) {
    this.checkerType = checkerType;
  }


  public UptimeCheckConfig contentMatchers(List<ContentMatcher> contentMatchers) {
    this.contentMatchers = contentMatchers;
    return this;
  }

  public UptimeCheckConfig addContentMatchersItem(ContentMatcher contentMatchersItem) {
    if (this.contentMatchers == null) {
      this.contentMatchers = new ArrayList<>();
    }
    this.contentMatchers.add(contentMatchersItem);
    return this;
  }

  /**
   * The content that is expected to appear in the data returned by the target server against which the check is run. Currently, only the first entry in the content_matchers list is supported, and additional entries will be ignored. This field is optional and should only be specified if a content match is required as part of the/ Uptime check.
   * @return contentMatchers
   */
  @javax.annotation.Nullable
  public List<ContentMatcher> getContentMatchers() {
    return contentMatchers;
  }

  public void setContentMatchers(List<ContentMatcher> contentMatchers) {
    this.contentMatchers = contentMatchers;
  }


  public UptimeCheckConfig displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * A human-friendly name for the Uptime check configuration. The display name should be unique within a Cloud Monitoring Workspace in order to make it easier to identify; however, uniqueness is not enforced. Required.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public UptimeCheckConfig httpCheck(HttpCheck httpCheck) {
    this.httpCheck = httpCheck;
    return this;
  }

  /**
   * Get httpCheck
   * @return httpCheck
   */
  @javax.annotation.Nullable
  public HttpCheck getHttpCheck() {
    return httpCheck;
  }

  public void setHttpCheck(HttpCheck httpCheck) {
    this.httpCheck = httpCheck;
  }


  @Deprecated
  public UptimeCheckConfig internalCheckers(List<InternalChecker> internalCheckers) {
    this.internalCheckers = internalCheckers;
    return this;
  }

  public UptimeCheckConfig addInternalCheckersItem(InternalChecker internalCheckersItem) {
    if (this.internalCheckers == null) {
      this.internalCheckers = new ArrayList<>();
    }
    this.internalCheckers.add(internalCheckersItem);
    return this;
  }

  /**
   * The internal checkers that this check will egress from. If is_internal is true and this list is empty, the check will egress from all the InternalCheckers configured for the project that owns this UptimeCheckConfig.
   * @return internalCheckers
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<InternalChecker> getInternalCheckers() {
    return internalCheckers;
  }

  @Deprecated
  public void setInternalCheckers(List<InternalChecker> internalCheckers) {
    this.internalCheckers = internalCheckers;
  }


  @Deprecated
  public UptimeCheckConfig isInternal(Boolean isInternal) {
    this.isInternal = isInternal;
    return this;
  }

  /**
   * If this is true, then checks are made only from the &#39;internal_checkers&#39;. If it is false, then checks are made only from the &#39;selected_regions&#39;. It is an error to provide &#39;selected_regions&#39; when is_internal is true, or to provide &#39;internal_checkers&#39; when is_internal is false.
   * @return isInternal
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getIsInternal() {
    return isInternal;
  }

  @Deprecated
  public void setIsInternal(Boolean isInternal) {
    this.isInternal = isInternal;
  }


  public UptimeCheckConfig monitoredResource(MonitoredResource monitoredResource) {
    this.monitoredResource = monitoredResource;
    return this;
  }

  /**
   * Get monitoredResource
   * @return monitoredResource
   */
  @javax.annotation.Nullable
  public MonitoredResource getMonitoredResource() {
    return monitoredResource;
  }

  public void setMonitoredResource(MonitoredResource monitoredResource) {
    this.monitoredResource = monitoredResource;
  }


  public UptimeCheckConfig name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Identifier. A unique resource name for this Uptime check configuration. The format is: projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID] [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime check.This field should be omitted when creating the Uptime check configuration; on create, the resource name is assigned by the server and included in the response.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public UptimeCheckConfig period(String period) {
    this.period = period;
    return this;
  }

  /**
   * How often, in seconds, the Uptime check is performed. Currently, the only supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes), and 900s (15 minutes). Optional, defaults to 60s.
   * @return period
   */
  @javax.annotation.Nullable
  public String getPeriod() {
    return period;
  }

  public void setPeriod(String period) {
    this.period = period;
  }


  public UptimeCheckConfig resourceGroup(ResourceGroup resourceGroup) {
    this.resourceGroup = resourceGroup;
    return this;
  }

  /**
   * Get resourceGroup
   * @return resourceGroup
   */
  @javax.annotation.Nullable
  public ResourceGroup getResourceGroup() {
    return resourceGroup;
  }

  public void setResourceGroup(ResourceGroup resourceGroup) {
    this.resourceGroup = resourceGroup;
  }


  public UptimeCheckConfig selectedRegions(List<SelectedRegionsEnum> selectedRegions) {
    this.selectedRegions = selectedRegions;
    return this;
  }

  public UptimeCheckConfig addSelectedRegionsItem(SelectedRegionsEnum selectedRegionsItem) {
    if (this.selectedRegions == null) {
      this.selectedRegions = new ArrayList<>();
    }
    this.selectedRegions.add(selectedRegionsItem);
    return this;
  }

  /**
   * The list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions must be provided to include a minimum of 3 locations. Not specifying this field will result in Uptime checks running from all available regions.
   * @return selectedRegions
   */
  @javax.annotation.Nullable
  public List<SelectedRegionsEnum> getSelectedRegions() {
    return selectedRegions;
  }

  public void setSelectedRegions(List<SelectedRegionsEnum> selectedRegions) {
    this.selectedRegions = selectedRegions;
  }


  public UptimeCheckConfig syntheticMonitor(SyntheticMonitorTarget syntheticMonitor) {
    this.syntheticMonitor = syntheticMonitor;
    return this;
  }

  /**
   * Get syntheticMonitor
   * @return syntheticMonitor
   */
  @javax.annotation.Nullable
  public SyntheticMonitorTarget getSyntheticMonitor() {
    return syntheticMonitor;
  }

  public void setSyntheticMonitor(SyntheticMonitorTarget syntheticMonitor) {
    this.syntheticMonitor = syntheticMonitor;
  }


  public UptimeCheckConfig tcpCheck(TcpCheck tcpCheck) {
    this.tcpCheck = tcpCheck;
    return this;
  }

  /**
   * Get tcpCheck
   * @return tcpCheck
   */
  @javax.annotation.Nullable
  public TcpCheck getTcpCheck() {
    return tcpCheck;
  }

  public void setTcpCheck(TcpCheck tcpCheck) {
    this.tcpCheck = tcpCheck;
  }


  public UptimeCheckConfig timeout(String timeout) {
    this.timeout = timeout;
    return this;
  }

  /**
   * The maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). Required.
   * @return timeout
   */
  @javax.annotation.Nullable
  public String getTimeout() {
    return timeout;
  }

  public void setTimeout(String timeout) {
    this.timeout = timeout;
  }


  public UptimeCheckConfig userLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
    return this;
  }

  public UptimeCheckConfig putUserLabelsItem(String key, String userLabelsItem) {
    if (this.userLabels == null) {
      this.userLabels = new HashMap<>();
    }
    this.userLabels.put(key, userLabelsItem);
    return this;
  }

  /**
   * User-supplied key/value data to be used for organizing and identifying the UptimeCheckConfig objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
   * @return userLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getUserLabels() {
    return userLabels;
  }

  public void setUserLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UptimeCheckConfig uptimeCheckConfig = (UptimeCheckConfig) o;
    return Objects.equals(this.checkerType, uptimeCheckConfig.checkerType) &&
        Objects.equals(this.contentMatchers, uptimeCheckConfig.contentMatchers) &&
        Objects.equals(this.displayName, uptimeCheckConfig.displayName) &&
        Objects.equals(this.httpCheck, uptimeCheckConfig.httpCheck) &&
        Objects.equals(this.internalCheckers, uptimeCheckConfig.internalCheckers) &&
        Objects.equals(this.isInternal, uptimeCheckConfig.isInternal) &&
        Objects.equals(this.monitoredResource, uptimeCheckConfig.monitoredResource) &&
        Objects.equals(this.name, uptimeCheckConfig.name) &&
        Objects.equals(this.period, uptimeCheckConfig.period) &&
        Objects.equals(this.resourceGroup, uptimeCheckConfig.resourceGroup) &&
        Objects.equals(this.selectedRegions, uptimeCheckConfig.selectedRegions) &&
        Objects.equals(this.syntheticMonitor, uptimeCheckConfig.syntheticMonitor) &&
        Objects.equals(this.tcpCheck, uptimeCheckConfig.tcpCheck) &&
        Objects.equals(this.timeout, uptimeCheckConfig.timeout) &&
        Objects.equals(this.userLabels, uptimeCheckConfig.userLabels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(checkerType, contentMatchers, displayName, httpCheck, internalCheckers, isInternal, monitoredResource, name, period, resourceGroup, selectedRegions, syntheticMonitor, tcpCheck, timeout, userLabels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UptimeCheckConfig {\n");
    sb.append("    checkerType: ").append(toIndentedString(checkerType)).append("\n");
    sb.append("    contentMatchers: ").append(toIndentedString(contentMatchers)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    httpCheck: ").append(toIndentedString(httpCheck)).append("\n");
    sb.append("    internalCheckers: ").append(toIndentedString(internalCheckers)).append("\n");
    sb.append("    isInternal: ").append(toIndentedString(isInternal)).append("\n");
    sb.append("    monitoredResource: ").append(toIndentedString(monitoredResource)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    period: ").append(toIndentedString(period)).append("\n");
    sb.append("    resourceGroup: ").append(toIndentedString(resourceGroup)).append("\n");
    sb.append("    selectedRegions: ").append(toIndentedString(selectedRegions)).append("\n");
    sb.append("    syntheticMonitor: ").append(toIndentedString(syntheticMonitor)).append("\n");
    sb.append("    tcpCheck: ").append(toIndentedString(tcpCheck)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    userLabels: ").append(toIndentedString(userLabels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("checkerType");
    openapiFields.add("contentMatchers");
    openapiFields.add("displayName");
    openapiFields.add("httpCheck");
    openapiFields.add("internalCheckers");
    openapiFields.add("isInternal");
    openapiFields.add("monitoredResource");
    openapiFields.add("name");
    openapiFields.add("period");
    openapiFields.add("resourceGroup");
    openapiFields.add("selectedRegions");
    openapiFields.add("syntheticMonitor");
    openapiFields.add("tcpCheck");
    openapiFields.add("timeout");
    openapiFields.add("userLabels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UptimeCheckConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UptimeCheckConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UptimeCheckConfig is not found in the empty JSON string", UptimeCheckConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UptimeCheckConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UptimeCheckConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("checkerType") != null && !jsonObj.get("checkerType").isJsonNull()) && !jsonObj.get("checkerType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkerType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkerType").toString()));
      }
      // validate the optional field `checkerType`
      if (jsonObj.get("checkerType") != null && !jsonObj.get("checkerType").isJsonNull()) {
        CheckerTypeEnum.validateJsonElement(jsonObj.get("checkerType"));
      }
      if (jsonObj.get("contentMatchers") != null && !jsonObj.get("contentMatchers").isJsonNull()) {
        JsonArray jsonArraycontentMatchers = jsonObj.getAsJsonArray("contentMatchers");
        if (jsonArraycontentMatchers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("contentMatchers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `contentMatchers` to be an array in the JSON string but got `%s`", jsonObj.get("contentMatchers").toString()));
          }

          // validate the optional field `contentMatchers` (array)
          for (int i = 0; i < jsonArraycontentMatchers.size(); i++) {
            ContentMatcher.validateJsonElement(jsonArraycontentMatchers.get(i));
          };
        }
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // validate the optional field `httpCheck`
      if (jsonObj.get("httpCheck") != null && !jsonObj.get("httpCheck").isJsonNull()) {
        HttpCheck.validateJsonElement(jsonObj.get("httpCheck"));
      }
      if (jsonObj.get("internalCheckers") != null && !jsonObj.get("internalCheckers").isJsonNull()) {
        JsonArray jsonArrayinternalCheckers = jsonObj.getAsJsonArray("internalCheckers");
        if (jsonArrayinternalCheckers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("internalCheckers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `internalCheckers` to be an array in the JSON string but got `%s`", jsonObj.get("internalCheckers").toString()));
          }

          // validate the optional field `internalCheckers` (array)
          for (int i = 0; i < jsonArrayinternalCheckers.size(); i++) {
            InternalChecker.validateJsonElement(jsonArrayinternalCheckers.get(i));
          };
        }
      }
      // validate the optional field `monitoredResource`
      if (jsonObj.get("monitoredResource") != null && !jsonObj.get("monitoredResource").isJsonNull()) {
        MonitoredResource.validateJsonElement(jsonObj.get("monitoredResource"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("period") != null && !jsonObj.get("period").isJsonNull()) && !jsonObj.get("period").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `period` to be a primitive type in the JSON string but got `%s`", jsonObj.get("period").toString()));
      }
      // validate the optional field `resourceGroup`
      if (jsonObj.get("resourceGroup") != null && !jsonObj.get("resourceGroup").isJsonNull()) {
        ResourceGroup.validateJsonElement(jsonObj.get("resourceGroup"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("selectedRegions") != null && !jsonObj.get("selectedRegions").isJsonNull() && !jsonObj.get("selectedRegions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `selectedRegions` to be an array in the JSON string but got `%s`", jsonObj.get("selectedRegions").toString()));
      }
      // validate the optional field `syntheticMonitor`
      if (jsonObj.get("syntheticMonitor") != null && !jsonObj.get("syntheticMonitor").isJsonNull()) {
        SyntheticMonitorTarget.validateJsonElement(jsonObj.get("syntheticMonitor"));
      }
      // validate the optional field `tcpCheck`
      if (jsonObj.get("tcpCheck") != null && !jsonObj.get("tcpCheck").isJsonNull()) {
        TcpCheck.validateJsonElement(jsonObj.get("tcpCheck"));
      }
      if ((jsonObj.get("timeout") != null && !jsonObj.get("timeout").isJsonNull()) && !jsonObj.get("timeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeout").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UptimeCheckConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UptimeCheckConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UptimeCheckConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UptimeCheckConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<UptimeCheckConfig>() {
           @Override
           public void write(JsonWriter out, UptimeCheckConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UptimeCheckConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UptimeCheckConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UptimeCheckConfig
   * @throws IOException if the JSON string is invalid with respect to UptimeCheckConfig
   */
  public static UptimeCheckConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UptimeCheckConfig.class);
  }

  /**
   * Convert an instance of UptimeCheckConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

