/*
 * Cloud Monitoring API
 * Manages your Cloud Monitoring data and configurations.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.BasicAuthentication;
import org.openapitools.client.model.PingConfig;
import org.openapitools.client.model.ResponseStatusCode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information involved in an HTTP/HTTPS Uptime check request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:42.831469-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HttpCheck {
  public static final String SERIALIZED_NAME_ACCEPTED_RESPONSE_STATUS_CODES = "acceptedResponseStatusCodes";
  @SerializedName(SERIALIZED_NAME_ACCEPTED_RESPONSE_STATUS_CODES)
  private List<ResponseStatusCode> acceptedResponseStatusCodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTH_INFO = "authInfo";
  @SerializedName(SERIALIZED_NAME_AUTH_INFO)
  private BasicAuthentication authInfo;

  public static final String SERIALIZED_NAME_BODY = "body";
  @SerializedName(SERIALIZED_NAME_BODY)
  private byte[] body;

  /**
   * The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a \&quot;Content-Type\&quot; header is provided via headers field. The content_type field should be used instead.
   */
  @JsonAdapter(ContentTypeEnum.Adapter.class)
  public enum ContentTypeEnum {
    TYPE_UNSPECIFIED("TYPE_UNSPECIFIED"),
    
    URL_ENCODED("URL_ENCODED"),
    
    USER_PROVIDED("USER_PROVIDED");

    private String value;

    ContentTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContentTypeEnum fromValue(String value) {
      for (ContentTypeEnum b : ContentTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ContentTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ContentTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ContentTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONTENT_TYPE = "contentType";
  @SerializedName(SERIALIZED_NAME_CONTENT_TYPE)
  private ContentTypeEnum contentType;

  public static final String SERIALIZED_NAME_CUSTOM_CONTENT_TYPE = "customContentType";
  @SerializedName(SERIALIZED_NAME_CUSTOM_CONTENT_TYPE)
  private String customContentType;

  public static final String SERIALIZED_NAME_HEADERS = "headers";
  @SerializedName(SERIALIZED_NAME_HEADERS)
  private Map<String, String> headers = new HashMap<>();

  public static final String SERIALIZED_NAME_MASK_HEADERS = "maskHeaders";
  @SerializedName(SERIALIZED_NAME_MASK_HEADERS)
  private Boolean maskHeaders;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  public static final String SERIALIZED_NAME_PING_CONFIG = "pingConfig";
  @SerializedName(SERIALIZED_NAME_PING_CONFIG)
  private PingConfig pingConfig;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Integer port;

  /**
   * The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
   */
  @JsonAdapter(RequestMethodEnum.Adapter.class)
  public enum RequestMethodEnum {
    METHOD_UNSPECIFIED("METHOD_UNSPECIFIED"),
    
    GET("GET"),
    
    POST("POST");

    private String value;

    RequestMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RequestMethodEnum fromValue(String value) {
      for (RequestMethodEnum b : RequestMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RequestMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RequestMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RequestMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RequestMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RequestMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REQUEST_METHOD = "requestMethod";
  @SerializedName(SERIALIZED_NAME_REQUEST_METHOD)
  private RequestMethodEnum requestMethod;

  public static final String SERIALIZED_NAME_USE_SSL = "useSsl";
  @SerializedName(SERIALIZED_NAME_USE_SSL)
  private Boolean useSsl;

  public static final String SERIALIZED_NAME_VALIDATE_SSL = "validateSsl";
  @SerializedName(SERIALIZED_NAME_VALIDATE_SSL)
  private Boolean validateSsl;

  public HttpCheck() {
  }

  public HttpCheck acceptedResponseStatusCodes(List<ResponseStatusCode> acceptedResponseStatusCodes) {
    this.acceptedResponseStatusCodes = acceptedResponseStatusCodes;
    return this;
  }

  public HttpCheck addAcceptedResponseStatusCodesItem(ResponseStatusCode acceptedResponseStatusCodesItem) {
    if (this.acceptedResponseStatusCodes == null) {
      this.acceptedResponseStatusCodes = new ArrayList<>();
    }
    this.acceptedResponseStatusCodes.add(acceptedResponseStatusCodesItem);
    return this;
  }

  /**
   * If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
   * @return acceptedResponseStatusCodes
   */
  @javax.annotation.Nullable
  public List<ResponseStatusCode> getAcceptedResponseStatusCodes() {
    return acceptedResponseStatusCodes;
  }

  public void setAcceptedResponseStatusCodes(List<ResponseStatusCode> acceptedResponseStatusCodes) {
    this.acceptedResponseStatusCodes = acceptedResponseStatusCodes;
  }


  public HttpCheck authInfo(BasicAuthentication authInfo) {
    this.authInfo = authInfo;
    return this;
  }

  /**
   * Get authInfo
   * @return authInfo
   */
  @javax.annotation.Nullable
  public BasicAuthentication getAuthInfo() {
    return authInfo;
  }

  public void setAuthInfo(BasicAuthentication authInfo) {
    this.authInfo = authInfo;
  }


  public HttpCheck body(byte[] body) {
    this.body = body;
    return this;
  }

  /**
   * The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren&#39;t used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
   * @return body
   */
  @javax.annotation.Nullable
  public byte[] getBody() {
    return body;
  }

  public void setBody(byte[] body) {
    this.body = body;
  }


  public HttpCheck contentType(ContentTypeEnum contentType) {
    this.contentType = contentType;
    return this;
  }

  /**
   * The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a \&quot;Content-Type\&quot; header is provided via headers field. The content_type field should be used instead.
   * @return contentType
   */
  @javax.annotation.Nullable
  public ContentTypeEnum getContentType() {
    return contentType;
  }

  public void setContentType(ContentTypeEnum contentType) {
    this.contentType = contentType;
  }


  public HttpCheck customContentType(String customContentType) {
    this.customContentType = customContentType;
    return this;
  }

  /**
   * A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
   * @return customContentType
   */
  @javax.annotation.Nullable
  public String getCustomContentType() {
    return customContentType;
  }

  public void setCustomContentType(String customContentType) {
    this.customContentType = customContentType;
  }


  public HttpCheck headers(Map<String, String> headers) {
    this.headers = headers;
    return this;
  }

  public HttpCheck putHeadersItem(String key, String headersItem) {
    if (this.headers == null) {
      this.headers = new HashMap<>();
    }
    this.headers.put(key, headersItem);
    return this;
  }

  /**
   * The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
   * @return headers
   */
  @javax.annotation.Nullable
  public Map<String, String> getHeaders() {
    return headers;
  }

  public void setHeaders(Map<String, String> headers) {
    this.headers = headers;
  }


  public HttpCheck maskHeaders(Boolean maskHeaders) {
    this.maskHeaders = maskHeaders;
    return this;
  }

  /**
   * Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
   * @return maskHeaders
   */
  @javax.annotation.Nullable
  public Boolean getMaskHeaders() {
    return maskHeaders;
  }

  public void setMaskHeaders(Boolean maskHeaders) {
    this.maskHeaders = maskHeaders;
  }


  public HttpCheck path(String path) {
    this.path = path;
    return this;
  }

  /**
   * Optional (defaults to \&quot;/\&quot;). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with \&quot;/\&quot;, a \&quot;/\&quot; will be prepended automatically.
   * @return path
   */
  @javax.annotation.Nullable
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public HttpCheck pingConfig(PingConfig pingConfig) {
    this.pingConfig = pingConfig;
    return this;
  }

  /**
   * Get pingConfig
   * @return pingConfig
   */
  @javax.annotation.Nullable
  public PingConfig getPingConfig() {
    return pingConfig;
  }

  public void setPingConfig(PingConfig pingConfig) {
    this.pingConfig = pingConfig;
  }


  public HttpCheck port(Integer port) {
    this.port = port;
    return this;
  }

  /**
   * Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
   * @return port
   */
  @javax.annotation.Nullable
  public Integer getPort() {
    return port;
  }

  public void setPort(Integer port) {
    this.port = port;
  }


  public HttpCheck requestMethod(RequestMethodEnum requestMethod) {
    this.requestMethod = requestMethod;
    return this;
  }

  /**
   * The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
   * @return requestMethod
   */
  @javax.annotation.Nullable
  public RequestMethodEnum getRequestMethod() {
    return requestMethod;
  }

  public void setRequestMethod(RequestMethodEnum requestMethod) {
    this.requestMethod = requestMethod;
  }


  public HttpCheck useSsl(Boolean useSsl) {
    this.useSsl = useSsl;
    return this;
  }

  /**
   * If true, use HTTPS instead of HTTP to run the check.
   * @return useSsl
   */
  @javax.annotation.Nullable
  public Boolean getUseSsl() {
    return useSsl;
  }

  public void setUseSsl(Boolean useSsl) {
    this.useSsl = useSsl;
  }


  public HttpCheck validateSsl(Boolean validateSsl) {
    this.validateSsl = validateSsl;
    return this;
  }

  /**
   * Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
   * @return validateSsl
   */
  @javax.annotation.Nullable
  public Boolean getValidateSsl() {
    return validateSsl;
  }

  public void setValidateSsl(Boolean validateSsl) {
    this.validateSsl = validateSsl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HttpCheck httpCheck = (HttpCheck) o;
    return Objects.equals(this.acceptedResponseStatusCodes, httpCheck.acceptedResponseStatusCodes) &&
        Objects.equals(this.authInfo, httpCheck.authInfo) &&
        Arrays.equals(this.body, httpCheck.body) &&
        Objects.equals(this.contentType, httpCheck.contentType) &&
        Objects.equals(this.customContentType, httpCheck.customContentType) &&
        Objects.equals(this.headers, httpCheck.headers) &&
        Objects.equals(this.maskHeaders, httpCheck.maskHeaders) &&
        Objects.equals(this.path, httpCheck.path) &&
        Objects.equals(this.pingConfig, httpCheck.pingConfig) &&
        Objects.equals(this.port, httpCheck.port) &&
        Objects.equals(this.requestMethod, httpCheck.requestMethod) &&
        Objects.equals(this.useSsl, httpCheck.useSsl) &&
        Objects.equals(this.validateSsl, httpCheck.validateSsl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedResponseStatusCodes, authInfo, Arrays.hashCode(body), contentType, customContentType, headers, maskHeaders, path, pingConfig, port, requestMethod, useSsl, validateSsl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HttpCheck {\n");
    sb.append("    acceptedResponseStatusCodes: ").append(toIndentedString(acceptedResponseStatusCodes)).append("\n");
    sb.append("    authInfo: ").append(toIndentedString(authInfo)).append("\n");
    sb.append("    body: ").append(toIndentedString(body)).append("\n");
    sb.append("    contentType: ").append(toIndentedString(contentType)).append("\n");
    sb.append("    customContentType: ").append(toIndentedString(customContentType)).append("\n");
    sb.append("    headers: ").append(toIndentedString(headers)).append("\n");
    sb.append("    maskHeaders: ").append(toIndentedString(maskHeaders)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    pingConfig: ").append(toIndentedString(pingConfig)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    requestMethod: ").append(toIndentedString(requestMethod)).append("\n");
    sb.append("    useSsl: ").append(toIndentedString(useSsl)).append("\n");
    sb.append("    validateSsl: ").append(toIndentedString(validateSsl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceptedResponseStatusCodes");
    openapiFields.add("authInfo");
    openapiFields.add("body");
    openapiFields.add("contentType");
    openapiFields.add("customContentType");
    openapiFields.add("headers");
    openapiFields.add("maskHeaders");
    openapiFields.add("path");
    openapiFields.add("pingConfig");
    openapiFields.add("port");
    openapiFields.add("requestMethod");
    openapiFields.add("useSsl");
    openapiFields.add("validateSsl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HttpCheck
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HttpCheck.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HttpCheck is not found in the empty JSON string", HttpCheck.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HttpCheck.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HttpCheck` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("acceptedResponseStatusCodes") != null && !jsonObj.get("acceptedResponseStatusCodes").isJsonNull()) {
        JsonArray jsonArrayacceptedResponseStatusCodes = jsonObj.getAsJsonArray("acceptedResponseStatusCodes");
        if (jsonArrayacceptedResponseStatusCodes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("acceptedResponseStatusCodes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `acceptedResponseStatusCodes` to be an array in the JSON string but got `%s`", jsonObj.get("acceptedResponseStatusCodes").toString()));
          }

          // validate the optional field `acceptedResponseStatusCodes` (array)
          for (int i = 0; i < jsonArrayacceptedResponseStatusCodes.size(); i++) {
            ResponseStatusCode.validateJsonElement(jsonArrayacceptedResponseStatusCodes.get(i));
          };
        }
      }
      // validate the optional field `authInfo`
      if (jsonObj.get("authInfo") != null && !jsonObj.get("authInfo").isJsonNull()) {
        BasicAuthentication.validateJsonElement(jsonObj.get("authInfo"));
      }
      if ((jsonObj.get("contentType") != null && !jsonObj.get("contentType").isJsonNull()) && !jsonObj.get("contentType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentType").toString()));
      }
      // validate the optional field `contentType`
      if (jsonObj.get("contentType") != null && !jsonObj.get("contentType").isJsonNull()) {
        ContentTypeEnum.validateJsonElement(jsonObj.get("contentType"));
      }
      if ((jsonObj.get("customContentType") != null && !jsonObj.get("customContentType").isJsonNull()) && !jsonObj.get("customContentType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customContentType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customContentType").toString()));
      }
      if ((jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) && !jsonObj.get("path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("path").toString()));
      }
      // validate the optional field `pingConfig`
      if (jsonObj.get("pingConfig") != null && !jsonObj.get("pingConfig").isJsonNull()) {
        PingConfig.validateJsonElement(jsonObj.get("pingConfig"));
      }
      if ((jsonObj.get("requestMethod") != null && !jsonObj.get("requestMethod").isJsonNull()) && !jsonObj.get("requestMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestMethod").toString()));
      }
      // validate the optional field `requestMethod`
      if (jsonObj.get("requestMethod") != null && !jsonObj.get("requestMethod").isJsonNull()) {
        RequestMethodEnum.validateJsonElement(jsonObj.get("requestMethod"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HttpCheck.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HttpCheck' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HttpCheck> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HttpCheck.class));

       return (TypeAdapter<T>) new TypeAdapter<HttpCheck>() {
           @Override
           public void write(JsonWriter out, HttpCheck value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HttpCheck read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HttpCheck given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HttpCheck
   * @throws IOException if the JSON string is invalid with respect to HttpCheck
   */
  public static HttpCheck fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HttpCheck.class);
  }

  /**
   * Convert an instance of HttpCheck to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

