/*
 * Cloud Monitoring API
 * Manages your Cloud Monitoring data and configurations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties that determine how the title and content are styled
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:39.941966-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TextStyle {
  public static final String SERIALIZED_NAME_BACKGROUND_COLOR = "backgroundColor";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_COLOR)
  private String backgroundColor;

  /**
   * Font sizes for both the title and content. The title will still be larger relative to the content.
   */
  @JsonAdapter(FontSizeEnum.Adapter.class)
  public enum FontSizeEnum {
    FONT_SIZE_UNSPECIFIED("FONT_SIZE_UNSPECIFIED"),
    
    FS_EXTRA_SMALL("FS_EXTRA_SMALL"),
    
    FS_SMALL("FS_SMALL"),
    
    FS_MEDIUM("FS_MEDIUM"),
    
    FS_LARGE("FS_LARGE"),
    
    FS_EXTRA_LARGE("FS_EXTRA_LARGE");

    private String value;

    FontSizeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FontSizeEnum fromValue(String value) {
      for (FontSizeEnum b : FontSizeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FontSizeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FontSizeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FontSizeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FontSizeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FontSizeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FONT_SIZE = "fontSize";
  @SerializedName(SERIALIZED_NAME_FONT_SIZE)
  private FontSizeEnum fontSize;

  /**
   * The horizontal alignment of both the title and content
   */
  @JsonAdapter(HorizontalAlignmentEnum.Adapter.class)
  public enum HorizontalAlignmentEnum {
    HORIZONTAL_ALIGNMENT_UNSPECIFIED("HORIZONTAL_ALIGNMENT_UNSPECIFIED"),
    
    H_LEFT("H_LEFT"),
    
    H_CENTER("H_CENTER"),
    
    H_RIGHT("H_RIGHT");

    private String value;

    HorizontalAlignmentEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HorizontalAlignmentEnum fromValue(String value) {
      for (HorizontalAlignmentEnum b : HorizontalAlignmentEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HorizontalAlignmentEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HorizontalAlignmentEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HorizontalAlignmentEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HorizontalAlignmentEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HorizontalAlignmentEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HORIZONTAL_ALIGNMENT = "horizontalAlignment";
  @SerializedName(SERIALIZED_NAME_HORIZONTAL_ALIGNMENT)
  private HorizontalAlignmentEnum horizontalAlignment;

  /**
   * The amount of padding around the widget
   */
  @JsonAdapter(PaddingEnum.Adapter.class)
  public enum PaddingEnum {
    PADDING_SIZE_UNSPECIFIED("PADDING_SIZE_UNSPECIFIED"),
    
    P_EXTRA_SMALL("P_EXTRA_SMALL"),
    
    P_SMALL("P_SMALL"),
    
    P_MEDIUM("P_MEDIUM"),
    
    P_LARGE("P_LARGE"),
    
    P_EXTRA_LARGE("P_EXTRA_LARGE");

    private String value;

    PaddingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PaddingEnum fromValue(String value) {
      for (PaddingEnum b : PaddingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PaddingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PaddingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PaddingEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PaddingEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PaddingEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PADDING = "padding";
  @SerializedName(SERIALIZED_NAME_PADDING)
  private PaddingEnum padding;

  /**
   * The pointer location for this widget (also sometimes called a \&quot;tail\&quot;)
   */
  @JsonAdapter(PointerLocationEnum.Adapter.class)
  public enum PointerLocationEnum {
    POINTER_LOCATION_UNSPECIFIED("POINTER_LOCATION_UNSPECIFIED"),
    
    PL_TOP("PL_TOP"),
    
    PL_RIGHT("PL_RIGHT"),
    
    PL_BOTTOM("PL_BOTTOM"),
    
    PL_LEFT("PL_LEFT"),
    
    PL_TOP_LEFT("PL_TOP_LEFT"),
    
    PL_TOP_RIGHT("PL_TOP_RIGHT"),
    
    PL_RIGHT_TOP("PL_RIGHT_TOP"),
    
    PL_RIGHT_BOTTOM("PL_RIGHT_BOTTOM"),
    
    PL_BOTTOM_RIGHT("PL_BOTTOM_RIGHT"),
    
    PL_BOTTOM_LEFT("PL_BOTTOM_LEFT"),
    
    PL_LEFT_BOTTOM("PL_LEFT_BOTTOM"),
    
    PL_LEFT_TOP("PL_LEFT_TOP");

    private String value;

    PointerLocationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PointerLocationEnum fromValue(String value) {
      for (PointerLocationEnum b : PointerLocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PointerLocationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PointerLocationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PointerLocationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PointerLocationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PointerLocationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_POINTER_LOCATION = "pointerLocation";
  @SerializedName(SERIALIZED_NAME_POINTER_LOCATION)
  private PointerLocationEnum pointerLocation;

  public static final String SERIALIZED_NAME_TEXT_COLOR = "textColor";
  @SerializedName(SERIALIZED_NAME_TEXT_COLOR)
  private String textColor;

  /**
   * The vertical alignment of both the title and content
   */
  @JsonAdapter(VerticalAlignmentEnum.Adapter.class)
  public enum VerticalAlignmentEnum {
    VERTICAL_ALIGNMENT_UNSPECIFIED("VERTICAL_ALIGNMENT_UNSPECIFIED"),
    
    V_TOP("V_TOP"),
    
    V_CENTER("V_CENTER"),
    
    V_BOTTOM("V_BOTTOM");

    private String value;

    VerticalAlignmentEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VerticalAlignmentEnum fromValue(String value) {
      for (VerticalAlignmentEnum b : VerticalAlignmentEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VerticalAlignmentEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VerticalAlignmentEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VerticalAlignmentEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VerticalAlignmentEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VerticalAlignmentEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VERTICAL_ALIGNMENT = "verticalAlignment";
  @SerializedName(SERIALIZED_NAME_VERTICAL_ALIGNMENT)
  private VerticalAlignmentEnum verticalAlignment;

  public TextStyle() {
  }

  public TextStyle backgroundColor(String backgroundColor) {
    this.backgroundColor = backgroundColor;
    return this;
  }

  /**
   * The background color as a hex string. \&quot;#RRGGBB\&quot; or \&quot;#RGB\&quot;
   * @return backgroundColor
   */
  @javax.annotation.Nullable
  public String getBackgroundColor() {
    return backgroundColor;
  }

  public void setBackgroundColor(String backgroundColor) {
    this.backgroundColor = backgroundColor;
  }


  public TextStyle fontSize(FontSizeEnum fontSize) {
    this.fontSize = fontSize;
    return this;
  }

  /**
   * Font sizes for both the title and content. The title will still be larger relative to the content.
   * @return fontSize
   */
  @javax.annotation.Nullable
  public FontSizeEnum getFontSize() {
    return fontSize;
  }

  public void setFontSize(FontSizeEnum fontSize) {
    this.fontSize = fontSize;
  }


  public TextStyle horizontalAlignment(HorizontalAlignmentEnum horizontalAlignment) {
    this.horizontalAlignment = horizontalAlignment;
    return this;
  }

  /**
   * The horizontal alignment of both the title and content
   * @return horizontalAlignment
   */
  @javax.annotation.Nullable
  public HorizontalAlignmentEnum getHorizontalAlignment() {
    return horizontalAlignment;
  }

  public void setHorizontalAlignment(HorizontalAlignmentEnum horizontalAlignment) {
    this.horizontalAlignment = horizontalAlignment;
  }


  public TextStyle padding(PaddingEnum padding) {
    this.padding = padding;
    return this;
  }

  /**
   * The amount of padding around the widget
   * @return padding
   */
  @javax.annotation.Nullable
  public PaddingEnum getPadding() {
    return padding;
  }

  public void setPadding(PaddingEnum padding) {
    this.padding = padding;
  }


  public TextStyle pointerLocation(PointerLocationEnum pointerLocation) {
    this.pointerLocation = pointerLocation;
    return this;
  }

  /**
   * The pointer location for this widget (also sometimes called a \&quot;tail\&quot;)
   * @return pointerLocation
   */
  @javax.annotation.Nullable
  public PointerLocationEnum getPointerLocation() {
    return pointerLocation;
  }

  public void setPointerLocation(PointerLocationEnum pointerLocation) {
    this.pointerLocation = pointerLocation;
  }


  public TextStyle textColor(String textColor) {
    this.textColor = textColor;
    return this;
  }

  /**
   * The text color as a hex string. \&quot;#RRGGBB\&quot; or \&quot;#RGB\&quot;
   * @return textColor
   */
  @javax.annotation.Nullable
  public String getTextColor() {
    return textColor;
  }

  public void setTextColor(String textColor) {
    this.textColor = textColor;
  }


  public TextStyle verticalAlignment(VerticalAlignmentEnum verticalAlignment) {
    this.verticalAlignment = verticalAlignment;
    return this;
  }

  /**
   * The vertical alignment of both the title and content
   * @return verticalAlignment
   */
  @javax.annotation.Nullable
  public VerticalAlignmentEnum getVerticalAlignment() {
    return verticalAlignment;
  }

  public void setVerticalAlignment(VerticalAlignmentEnum verticalAlignment) {
    this.verticalAlignment = verticalAlignment;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TextStyle textStyle = (TextStyle) o;
    return Objects.equals(this.backgroundColor, textStyle.backgroundColor) &&
        Objects.equals(this.fontSize, textStyle.fontSize) &&
        Objects.equals(this.horizontalAlignment, textStyle.horizontalAlignment) &&
        Objects.equals(this.padding, textStyle.padding) &&
        Objects.equals(this.pointerLocation, textStyle.pointerLocation) &&
        Objects.equals(this.textColor, textStyle.textColor) &&
        Objects.equals(this.verticalAlignment, textStyle.verticalAlignment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backgroundColor, fontSize, horizontalAlignment, padding, pointerLocation, textColor, verticalAlignment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TextStyle {\n");
    sb.append("    backgroundColor: ").append(toIndentedString(backgroundColor)).append("\n");
    sb.append("    fontSize: ").append(toIndentedString(fontSize)).append("\n");
    sb.append("    horizontalAlignment: ").append(toIndentedString(horizontalAlignment)).append("\n");
    sb.append("    padding: ").append(toIndentedString(padding)).append("\n");
    sb.append("    pointerLocation: ").append(toIndentedString(pointerLocation)).append("\n");
    sb.append("    textColor: ").append(toIndentedString(textColor)).append("\n");
    sb.append("    verticalAlignment: ").append(toIndentedString(verticalAlignment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("backgroundColor");
    openapiFields.add("fontSize");
    openapiFields.add("horizontalAlignment");
    openapiFields.add("padding");
    openapiFields.add("pointerLocation");
    openapiFields.add("textColor");
    openapiFields.add("verticalAlignment");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TextStyle
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TextStyle.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TextStyle is not found in the empty JSON string", TextStyle.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TextStyle.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TextStyle` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("backgroundColor") != null && !jsonObj.get("backgroundColor").isJsonNull()) && !jsonObj.get("backgroundColor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backgroundColor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backgroundColor").toString()));
      }
      if ((jsonObj.get("fontSize") != null && !jsonObj.get("fontSize").isJsonNull()) && !jsonObj.get("fontSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fontSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fontSize").toString()));
      }
      // validate the optional field `fontSize`
      if (jsonObj.get("fontSize") != null && !jsonObj.get("fontSize").isJsonNull()) {
        FontSizeEnum.validateJsonElement(jsonObj.get("fontSize"));
      }
      if ((jsonObj.get("horizontalAlignment") != null && !jsonObj.get("horizontalAlignment").isJsonNull()) && !jsonObj.get("horizontalAlignment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `horizontalAlignment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("horizontalAlignment").toString()));
      }
      // validate the optional field `horizontalAlignment`
      if (jsonObj.get("horizontalAlignment") != null && !jsonObj.get("horizontalAlignment").isJsonNull()) {
        HorizontalAlignmentEnum.validateJsonElement(jsonObj.get("horizontalAlignment"));
      }
      if ((jsonObj.get("padding") != null && !jsonObj.get("padding").isJsonNull()) && !jsonObj.get("padding").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `padding` to be a primitive type in the JSON string but got `%s`", jsonObj.get("padding").toString()));
      }
      // validate the optional field `padding`
      if (jsonObj.get("padding") != null && !jsonObj.get("padding").isJsonNull()) {
        PaddingEnum.validateJsonElement(jsonObj.get("padding"));
      }
      if ((jsonObj.get("pointerLocation") != null && !jsonObj.get("pointerLocation").isJsonNull()) && !jsonObj.get("pointerLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pointerLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pointerLocation").toString()));
      }
      // validate the optional field `pointerLocation`
      if (jsonObj.get("pointerLocation") != null && !jsonObj.get("pointerLocation").isJsonNull()) {
        PointerLocationEnum.validateJsonElement(jsonObj.get("pointerLocation"));
      }
      if ((jsonObj.get("textColor") != null && !jsonObj.get("textColor").isJsonNull()) && !jsonObj.get("textColor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `textColor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("textColor").toString()));
      }
      if ((jsonObj.get("verticalAlignment") != null && !jsonObj.get("verticalAlignment").isJsonNull()) && !jsonObj.get("verticalAlignment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `verticalAlignment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("verticalAlignment").toString()));
      }
      // validate the optional field `verticalAlignment`
      if (jsonObj.get("verticalAlignment") != null && !jsonObj.get("verticalAlignment").isJsonNull()) {
        VerticalAlignmentEnum.validateJsonElement(jsonObj.get("verticalAlignment"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TextStyle.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TextStyle' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TextStyle> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TextStyle.class));

       return (TypeAdapter<T>) new TypeAdapter<TextStyle>() {
           @Override
           public void write(JsonWriter out, TextStyle value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TextStyle read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TextStyle given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TextStyle
   * @throws IOException if the JSON string is invalid with respect to TextStyle
   */
  public static TextStyle fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TextStyle.class);
  }

  /**
   * Convert an instance of TextStyle to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

