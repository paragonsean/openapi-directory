/**
 * Cloud TPU API
 * TPU API provides customers with access to Google TPU technology.
 *
 * The version of the OpenAPI document: v2alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINode.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINode::OAINode(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINode::OAINode() {
    this->initializeModel();
}

OAINode::~OAINode() {}

void OAINode::initializeModel() {

    m_accelerator_config_isSet = false;
    m_accelerator_config_isValid = false;

    m_accelerator_type_isSet = false;
    m_accelerator_type_isValid = false;

    m_api_version_isSet = false;
    m_api_version_isValid = false;

    m_autocheckpoint_enabled_isSet = false;
    m_autocheckpoint_enabled_isValid = false;

    m_boot_disk_config_isSet = false;
    m_boot_disk_config_isValid = false;

    m_cidr_block_isSet = false;
    m_cidr_block_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_data_disks_isSet = false;
    m_data_disks_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_health_isSet = false;
    m_health_isValid = false;

    m_health_description_isSet = false;
    m_health_description_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_multislice_node_isSet = false;
    m_multislice_node_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_network_config_isSet = false;
    m_network_config_isValid = false;

    m_network_endpoints_isSet = false;
    m_network_endpoints_isValid = false;

    m_queued_resource_isSet = false;
    m_queued_resource_isValid = false;

    m_runtime_version_isSet = false;
    m_runtime_version_isValid = false;

    m_scheduling_config_isSet = false;
    m_scheduling_config_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_shielded_instance_config_isSet = false;
    m_shielded_instance_config_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_symptoms_isSet = false;
    m_symptoms_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAINode::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINode::fromJsonObject(QJsonObject json) {

    m_accelerator_config_isValid = ::OpenAPI::fromJsonValue(m_accelerator_config, json[QString("acceleratorConfig")]);
    m_accelerator_config_isSet = !json[QString("acceleratorConfig")].isNull() && m_accelerator_config_isValid;

    m_accelerator_type_isValid = ::OpenAPI::fromJsonValue(m_accelerator_type, json[QString("acceleratorType")]);
    m_accelerator_type_isSet = !json[QString("acceleratorType")].isNull() && m_accelerator_type_isValid;

    m_api_version_isValid = ::OpenAPI::fromJsonValue(m_api_version, json[QString("apiVersion")]);
    m_api_version_isSet = !json[QString("apiVersion")].isNull() && m_api_version_isValid;

    m_autocheckpoint_enabled_isValid = ::OpenAPI::fromJsonValue(m_autocheckpoint_enabled, json[QString("autocheckpointEnabled")]);
    m_autocheckpoint_enabled_isSet = !json[QString("autocheckpointEnabled")].isNull() && m_autocheckpoint_enabled_isValid;

    m_boot_disk_config_isValid = ::OpenAPI::fromJsonValue(m_boot_disk_config, json[QString("bootDiskConfig")]);
    m_boot_disk_config_isSet = !json[QString("bootDiskConfig")].isNull() && m_boot_disk_config_isValid;

    m_cidr_block_isValid = ::OpenAPI::fromJsonValue(m_cidr_block, json[QString("cidrBlock")]);
    m_cidr_block_isSet = !json[QString("cidrBlock")].isNull() && m_cidr_block_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_data_disks_isValid = ::OpenAPI::fromJsonValue(m_data_disks, json[QString("dataDisks")]);
    m_data_disks_isSet = !json[QString("dataDisks")].isNull() && m_data_disks_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("description")]);
    m_description_isSet = !json[QString("description")].isNull() && m_description_isValid;

    m_health_isValid = ::OpenAPI::fromJsonValue(m_health, json[QString("health")]);
    m_health_isSet = !json[QString("health")].isNull() && m_health_isValid;

    m_health_description_isValid = ::OpenAPI::fromJsonValue(m_health_description, json[QString("healthDescription")]);
    m_health_description_isSet = !json[QString("healthDescription")].isNull() && m_health_description_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_multislice_node_isValid = ::OpenAPI::fromJsonValue(m_multislice_node, json[QString("multisliceNode")]);
    m_multislice_node_isSet = !json[QString("multisliceNode")].isNull() && m_multislice_node_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_network_config_isValid = ::OpenAPI::fromJsonValue(m_network_config, json[QString("networkConfig")]);
    m_network_config_isSet = !json[QString("networkConfig")].isNull() && m_network_config_isValid;

    m_network_endpoints_isValid = ::OpenAPI::fromJsonValue(m_network_endpoints, json[QString("networkEndpoints")]);
    m_network_endpoints_isSet = !json[QString("networkEndpoints")].isNull() && m_network_endpoints_isValid;

    m_queued_resource_isValid = ::OpenAPI::fromJsonValue(m_queued_resource, json[QString("queuedResource")]);
    m_queued_resource_isSet = !json[QString("queuedResource")].isNull() && m_queued_resource_isValid;

    m_runtime_version_isValid = ::OpenAPI::fromJsonValue(m_runtime_version, json[QString("runtimeVersion")]);
    m_runtime_version_isSet = !json[QString("runtimeVersion")].isNull() && m_runtime_version_isValid;

    m_scheduling_config_isValid = ::OpenAPI::fromJsonValue(m_scheduling_config, json[QString("schedulingConfig")]);
    m_scheduling_config_isSet = !json[QString("schedulingConfig")].isNull() && m_scheduling_config_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_shielded_instance_config_isValid = ::OpenAPI::fromJsonValue(m_shielded_instance_config, json[QString("shieldedInstanceConfig")]);
    m_shielded_instance_config_isSet = !json[QString("shieldedInstanceConfig")].isNull() && m_shielded_instance_config_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_symptoms_isValid = ::OpenAPI::fromJsonValue(m_symptoms, json[QString("symptoms")]);
    m_symptoms_isSet = !json[QString("symptoms")].isNull() && m_symptoms_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;
}

QString OAINode::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINode::asJsonObject() const {
    QJsonObject obj;
    if (m_accelerator_config.isSet()) {
        obj.insert(QString("acceleratorConfig"), ::OpenAPI::toJsonValue(m_accelerator_config));
    }
    if (m_accelerator_type_isSet) {
        obj.insert(QString("acceleratorType"), ::OpenAPI::toJsonValue(m_accelerator_type));
    }
    if (m_api_version_isSet) {
        obj.insert(QString("apiVersion"), ::OpenAPI::toJsonValue(m_api_version));
    }
    if (m_autocheckpoint_enabled_isSet) {
        obj.insert(QString("autocheckpointEnabled"), ::OpenAPI::toJsonValue(m_autocheckpoint_enabled));
    }
    if (m_boot_disk_config.isSet()) {
        obj.insert(QString("bootDiskConfig"), ::OpenAPI::toJsonValue(m_boot_disk_config));
    }
    if (m_cidr_block_isSet) {
        obj.insert(QString("cidrBlock"), ::OpenAPI::toJsonValue(m_cidr_block));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_data_disks.size() > 0) {
        obj.insert(QString("dataDisks"), ::OpenAPI::toJsonValue(m_data_disks));
    }
    if (m_description_isSet) {
        obj.insert(QString("description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_health_isSet) {
        obj.insert(QString("health"), ::OpenAPI::toJsonValue(m_health));
    }
    if (m_health_description_isSet) {
        obj.insert(QString("healthDescription"), ::OpenAPI::toJsonValue(m_health_description));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_metadata.size() > 0) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_multislice_node_isSet) {
        obj.insert(QString("multisliceNode"), ::OpenAPI::toJsonValue(m_multislice_node));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_network_config.isSet()) {
        obj.insert(QString("networkConfig"), ::OpenAPI::toJsonValue(m_network_config));
    }
    if (m_network_endpoints.size() > 0) {
        obj.insert(QString("networkEndpoints"), ::OpenAPI::toJsonValue(m_network_endpoints));
    }
    if (m_queued_resource_isSet) {
        obj.insert(QString("queuedResource"), ::OpenAPI::toJsonValue(m_queued_resource));
    }
    if (m_runtime_version_isSet) {
        obj.insert(QString("runtimeVersion"), ::OpenAPI::toJsonValue(m_runtime_version));
    }
    if (m_scheduling_config.isSet()) {
        obj.insert(QString("schedulingConfig"), ::OpenAPI::toJsonValue(m_scheduling_config));
    }
    if (m_service_account.isSet()) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_shielded_instance_config.isSet()) {
        obj.insert(QString("shieldedInstanceConfig"), ::OpenAPI::toJsonValue(m_shielded_instance_config));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_symptoms.size() > 0) {
        obj.insert(QString("symptoms"), ::OpenAPI::toJsonValue(m_symptoms));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

OAIAcceleratorConfig OAINode::getAcceleratorConfig() const {
    return m_accelerator_config;
}
void OAINode::setAcceleratorConfig(const OAIAcceleratorConfig &accelerator_config) {
    m_accelerator_config = accelerator_config;
    m_accelerator_config_isSet = true;
}

bool OAINode::is_accelerator_config_Set() const{
    return m_accelerator_config_isSet;
}

bool OAINode::is_accelerator_config_Valid() const{
    return m_accelerator_config_isValid;
}

QString OAINode::getAcceleratorType() const {
    return m_accelerator_type;
}
void OAINode::setAcceleratorType(const QString &accelerator_type) {
    m_accelerator_type = accelerator_type;
    m_accelerator_type_isSet = true;
}

bool OAINode::is_accelerator_type_Set() const{
    return m_accelerator_type_isSet;
}

bool OAINode::is_accelerator_type_Valid() const{
    return m_accelerator_type_isValid;
}

QString OAINode::getApiVersion() const {
    return m_api_version;
}
void OAINode::setApiVersion(const QString &api_version) {
    m_api_version = api_version;
    m_api_version_isSet = true;
}

bool OAINode::is_api_version_Set() const{
    return m_api_version_isSet;
}

bool OAINode::is_api_version_Valid() const{
    return m_api_version_isValid;
}

bool OAINode::isAutocheckpointEnabled() const {
    return m_autocheckpoint_enabled;
}
void OAINode::setAutocheckpointEnabled(const bool &autocheckpoint_enabled) {
    m_autocheckpoint_enabled = autocheckpoint_enabled;
    m_autocheckpoint_enabled_isSet = true;
}

bool OAINode::is_autocheckpoint_enabled_Set() const{
    return m_autocheckpoint_enabled_isSet;
}

bool OAINode::is_autocheckpoint_enabled_Valid() const{
    return m_autocheckpoint_enabled_isValid;
}

OAIBootDiskConfig OAINode::getBootDiskConfig() const {
    return m_boot_disk_config;
}
void OAINode::setBootDiskConfig(const OAIBootDiskConfig &boot_disk_config) {
    m_boot_disk_config = boot_disk_config;
    m_boot_disk_config_isSet = true;
}

bool OAINode::is_boot_disk_config_Set() const{
    return m_boot_disk_config_isSet;
}

bool OAINode::is_boot_disk_config_Valid() const{
    return m_boot_disk_config_isValid;
}

QString OAINode::getCidrBlock() const {
    return m_cidr_block;
}
void OAINode::setCidrBlock(const QString &cidr_block) {
    m_cidr_block = cidr_block;
    m_cidr_block_isSet = true;
}

bool OAINode::is_cidr_block_Set() const{
    return m_cidr_block_isSet;
}

bool OAINode::is_cidr_block_Valid() const{
    return m_cidr_block_isValid;
}

QString OAINode::getCreateTime() const {
    return m_create_time;
}
void OAINode::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAINode::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAINode::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QList<OAIAttachedDisk> OAINode::getDataDisks() const {
    return m_data_disks;
}
void OAINode::setDataDisks(const QList<OAIAttachedDisk> &data_disks) {
    m_data_disks = data_disks;
    m_data_disks_isSet = true;
}

bool OAINode::is_data_disks_Set() const{
    return m_data_disks_isSet;
}

bool OAINode::is_data_disks_Valid() const{
    return m_data_disks_isValid;
}

QString OAINode::getDescription() const {
    return m_description;
}
void OAINode::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAINode::is_description_Set() const{
    return m_description_isSet;
}

bool OAINode::is_description_Valid() const{
    return m_description_isValid;
}

QString OAINode::getHealth() const {
    return m_health;
}
void OAINode::setHealth(const QString &health) {
    m_health = health;
    m_health_isSet = true;
}

bool OAINode::is_health_Set() const{
    return m_health_isSet;
}

bool OAINode::is_health_Valid() const{
    return m_health_isValid;
}

QString OAINode::getHealthDescription() const {
    return m_health_description;
}
void OAINode::setHealthDescription(const QString &health_description) {
    m_health_description = health_description;
    m_health_description_isSet = true;
}

bool OAINode::is_health_description_Set() const{
    return m_health_description_isSet;
}

bool OAINode::is_health_description_Valid() const{
    return m_health_description_isValid;
}

QString OAINode::getId() const {
    return m_id;
}
void OAINode::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAINode::is_id_Set() const{
    return m_id_isSet;
}

bool OAINode::is_id_Valid() const{
    return m_id_isValid;
}

QMap<QString, QString> OAINode::getLabels() const {
    return m_labels;
}
void OAINode::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAINode::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAINode::is_labels_Valid() const{
    return m_labels_isValid;
}

QMap<QString, QString> OAINode::getMetadata() const {
    return m_metadata;
}
void OAINode::setMetadata(const QMap<QString, QString> &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAINode::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAINode::is_metadata_Valid() const{
    return m_metadata_isValid;
}

bool OAINode::isMultisliceNode() const {
    return m_multislice_node;
}
void OAINode::setMultisliceNode(const bool &multislice_node) {
    m_multislice_node = multislice_node;
    m_multislice_node_isSet = true;
}

bool OAINode::is_multislice_node_Set() const{
    return m_multislice_node_isSet;
}

bool OAINode::is_multislice_node_Valid() const{
    return m_multislice_node_isValid;
}

QString OAINode::getName() const {
    return m_name;
}
void OAINode::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAINode::is_name_Set() const{
    return m_name_isSet;
}

bool OAINode::is_name_Valid() const{
    return m_name_isValid;
}

OAINetworkConfig OAINode::getNetworkConfig() const {
    return m_network_config;
}
void OAINode::setNetworkConfig(const OAINetworkConfig &network_config) {
    m_network_config = network_config;
    m_network_config_isSet = true;
}

bool OAINode::is_network_config_Set() const{
    return m_network_config_isSet;
}

bool OAINode::is_network_config_Valid() const{
    return m_network_config_isValid;
}

QList<OAINetworkEndpoint> OAINode::getNetworkEndpoints() const {
    return m_network_endpoints;
}
void OAINode::setNetworkEndpoints(const QList<OAINetworkEndpoint> &network_endpoints) {
    m_network_endpoints = network_endpoints;
    m_network_endpoints_isSet = true;
}

bool OAINode::is_network_endpoints_Set() const{
    return m_network_endpoints_isSet;
}

bool OAINode::is_network_endpoints_Valid() const{
    return m_network_endpoints_isValid;
}

QString OAINode::getQueuedResource() const {
    return m_queued_resource;
}
void OAINode::setQueuedResource(const QString &queued_resource) {
    m_queued_resource = queued_resource;
    m_queued_resource_isSet = true;
}

bool OAINode::is_queued_resource_Set() const{
    return m_queued_resource_isSet;
}

bool OAINode::is_queued_resource_Valid() const{
    return m_queued_resource_isValid;
}

QString OAINode::getRuntimeVersion() const {
    return m_runtime_version;
}
void OAINode::setRuntimeVersion(const QString &runtime_version) {
    m_runtime_version = runtime_version;
    m_runtime_version_isSet = true;
}

bool OAINode::is_runtime_version_Set() const{
    return m_runtime_version_isSet;
}

bool OAINode::is_runtime_version_Valid() const{
    return m_runtime_version_isValid;
}

OAISchedulingConfig OAINode::getSchedulingConfig() const {
    return m_scheduling_config;
}
void OAINode::setSchedulingConfig(const OAISchedulingConfig &scheduling_config) {
    m_scheduling_config = scheduling_config;
    m_scheduling_config_isSet = true;
}

bool OAINode::is_scheduling_config_Set() const{
    return m_scheduling_config_isSet;
}

bool OAINode::is_scheduling_config_Valid() const{
    return m_scheduling_config_isValid;
}

OAIServiceAccount OAINode::getServiceAccount() const {
    return m_service_account;
}
void OAINode::setServiceAccount(const OAIServiceAccount &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAINode::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAINode::is_service_account_Valid() const{
    return m_service_account_isValid;
}

OAIShieldedInstanceConfig OAINode::getShieldedInstanceConfig() const {
    return m_shielded_instance_config;
}
void OAINode::setShieldedInstanceConfig(const OAIShieldedInstanceConfig &shielded_instance_config) {
    m_shielded_instance_config = shielded_instance_config;
    m_shielded_instance_config_isSet = true;
}

bool OAINode::is_shielded_instance_config_Set() const{
    return m_shielded_instance_config_isSet;
}

bool OAINode::is_shielded_instance_config_Valid() const{
    return m_shielded_instance_config_isValid;
}

QString OAINode::getState() const {
    return m_state;
}
void OAINode::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAINode::is_state_Set() const{
    return m_state_isSet;
}

bool OAINode::is_state_Valid() const{
    return m_state_isValid;
}

QList<OAISymptom> OAINode::getSymptoms() const {
    return m_symptoms;
}
void OAINode::setSymptoms(const QList<OAISymptom> &symptoms) {
    m_symptoms = symptoms;
    m_symptoms_isSet = true;
}

bool OAINode::is_symptoms_Set() const{
    return m_symptoms_isSet;
}

bool OAINode::is_symptoms_Valid() const{
    return m_symptoms_isValid;
}

QList<QString> OAINode::getTags() const {
    return m_tags;
}
void OAINode::setTags(const QList<QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAINode::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAINode::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAINode::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accelerator_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_accelerator_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_api_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_autocheckpoint_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_boot_disk_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cidr_block_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_disks.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_multislice_node_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_endpoints.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_queued_resource_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_runtime_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduling_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_shielded_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_symptoms.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINode::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
