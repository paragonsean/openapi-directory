/**
 * Anthos On-Prem API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVmwareNodeConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVmwareNodeConfig::OAIVmwareNodeConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVmwareNodeConfig::OAIVmwareNodeConfig() {
    this->initializeModel();
}

OAIVmwareNodeConfig::~OAIVmwareNodeConfig() {}

void OAIVmwareNodeConfig::initializeModel() {

    m_boot_disk_size_gb_isSet = false;
    m_boot_disk_size_gb_isValid = false;

    m_cpus_isSet = false;
    m_cpus_isValid = false;

    m_enable_load_balancer_isSet = false;
    m_enable_load_balancer_isValid = false;

    m_image_isSet = false;
    m_image_isValid = false;

    m_image_type_isSet = false;
    m_image_type_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_memory_mb_isSet = false;
    m_memory_mb_isValid = false;

    m_replicas_isSet = false;
    m_replicas_isValid = false;

    m_taints_isSet = false;
    m_taints_isValid = false;

    m_vsphere_config_isSet = false;
    m_vsphere_config_isValid = false;
}

void OAIVmwareNodeConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVmwareNodeConfig::fromJsonObject(QJsonObject json) {

    m_boot_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_boot_disk_size_gb, json[QString("bootDiskSizeGb")]);
    m_boot_disk_size_gb_isSet = !json[QString("bootDiskSizeGb")].isNull() && m_boot_disk_size_gb_isValid;

    m_cpus_isValid = ::OpenAPI::fromJsonValue(m_cpus, json[QString("cpus")]);
    m_cpus_isSet = !json[QString("cpus")].isNull() && m_cpus_isValid;

    m_enable_load_balancer_isValid = ::OpenAPI::fromJsonValue(m_enable_load_balancer, json[QString("enableLoadBalancer")]);
    m_enable_load_balancer_isSet = !json[QString("enableLoadBalancer")].isNull() && m_enable_load_balancer_isValid;

    m_image_isValid = ::OpenAPI::fromJsonValue(m_image, json[QString("image")]);
    m_image_isSet = !json[QString("image")].isNull() && m_image_isValid;

    m_image_type_isValid = ::OpenAPI::fromJsonValue(m_image_type, json[QString("imageType")]);
    m_image_type_isSet = !json[QString("imageType")].isNull() && m_image_type_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_memory_mb_isValid = ::OpenAPI::fromJsonValue(m_memory_mb, json[QString("memoryMb")]);
    m_memory_mb_isSet = !json[QString("memoryMb")].isNull() && m_memory_mb_isValid;

    m_replicas_isValid = ::OpenAPI::fromJsonValue(m_replicas, json[QString("replicas")]);
    m_replicas_isSet = !json[QString("replicas")].isNull() && m_replicas_isValid;

    m_taints_isValid = ::OpenAPI::fromJsonValue(m_taints, json[QString("taints")]);
    m_taints_isSet = !json[QString("taints")].isNull() && m_taints_isValid;

    m_vsphere_config_isValid = ::OpenAPI::fromJsonValue(m_vsphere_config, json[QString("vsphereConfig")]);
    m_vsphere_config_isSet = !json[QString("vsphereConfig")].isNull() && m_vsphere_config_isValid;
}

QString OAIVmwareNodeConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVmwareNodeConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_boot_disk_size_gb_isSet) {
        obj.insert(QString("bootDiskSizeGb"), ::OpenAPI::toJsonValue(m_boot_disk_size_gb));
    }
    if (m_cpus_isSet) {
        obj.insert(QString("cpus"), ::OpenAPI::toJsonValue(m_cpus));
    }
    if (m_enable_load_balancer_isSet) {
        obj.insert(QString("enableLoadBalancer"), ::OpenAPI::toJsonValue(m_enable_load_balancer));
    }
    if (m_image_isSet) {
        obj.insert(QString("image"), ::OpenAPI::toJsonValue(m_image));
    }
    if (m_image_type_isSet) {
        obj.insert(QString("imageType"), ::OpenAPI::toJsonValue(m_image_type));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_memory_mb_isSet) {
        obj.insert(QString("memoryMb"), ::OpenAPI::toJsonValue(m_memory_mb));
    }
    if (m_replicas_isSet) {
        obj.insert(QString("replicas"), ::OpenAPI::toJsonValue(m_replicas));
    }
    if (m_taints.size() > 0) {
        obj.insert(QString("taints"), ::OpenAPI::toJsonValue(m_taints));
    }
    if (m_vsphere_config.isSet()) {
        obj.insert(QString("vsphereConfig"), ::OpenAPI::toJsonValue(m_vsphere_config));
    }
    return obj;
}

QString OAIVmwareNodeConfig::getBootDiskSizeGb() const {
    return m_boot_disk_size_gb;
}
void OAIVmwareNodeConfig::setBootDiskSizeGb(const QString &boot_disk_size_gb) {
    m_boot_disk_size_gb = boot_disk_size_gb;
    m_boot_disk_size_gb_isSet = true;
}

bool OAIVmwareNodeConfig::is_boot_disk_size_gb_Set() const{
    return m_boot_disk_size_gb_isSet;
}

bool OAIVmwareNodeConfig::is_boot_disk_size_gb_Valid() const{
    return m_boot_disk_size_gb_isValid;
}

QString OAIVmwareNodeConfig::getCpus() const {
    return m_cpus;
}
void OAIVmwareNodeConfig::setCpus(const QString &cpus) {
    m_cpus = cpus;
    m_cpus_isSet = true;
}

bool OAIVmwareNodeConfig::is_cpus_Set() const{
    return m_cpus_isSet;
}

bool OAIVmwareNodeConfig::is_cpus_Valid() const{
    return m_cpus_isValid;
}

bool OAIVmwareNodeConfig::isEnableLoadBalancer() const {
    return m_enable_load_balancer;
}
void OAIVmwareNodeConfig::setEnableLoadBalancer(const bool &enable_load_balancer) {
    m_enable_load_balancer = enable_load_balancer;
    m_enable_load_balancer_isSet = true;
}

bool OAIVmwareNodeConfig::is_enable_load_balancer_Set() const{
    return m_enable_load_balancer_isSet;
}

bool OAIVmwareNodeConfig::is_enable_load_balancer_Valid() const{
    return m_enable_load_balancer_isValid;
}

QString OAIVmwareNodeConfig::getImage() const {
    return m_image;
}
void OAIVmwareNodeConfig::setImage(const QString &image) {
    m_image = image;
    m_image_isSet = true;
}

bool OAIVmwareNodeConfig::is_image_Set() const{
    return m_image_isSet;
}

bool OAIVmwareNodeConfig::is_image_Valid() const{
    return m_image_isValid;
}

QString OAIVmwareNodeConfig::getImageType() const {
    return m_image_type;
}
void OAIVmwareNodeConfig::setImageType(const QString &image_type) {
    m_image_type = image_type;
    m_image_type_isSet = true;
}

bool OAIVmwareNodeConfig::is_image_type_Set() const{
    return m_image_type_isSet;
}

bool OAIVmwareNodeConfig::is_image_type_Valid() const{
    return m_image_type_isValid;
}

QMap<QString, QString> OAIVmwareNodeConfig::getLabels() const {
    return m_labels;
}
void OAIVmwareNodeConfig::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIVmwareNodeConfig::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIVmwareNodeConfig::is_labels_Valid() const{
    return m_labels_isValid;
}

QString OAIVmwareNodeConfig::getMemoryMb() const {
    return m_memory_mb;
}
void OAIVmwareNodeConfig::setMemoryMb(const QString &memory_mb) {
    m_memory_mb = memory_mb;
    m_memory_mb_isSet = true;
}

bool OAIVmwareNodeConfig::is_memory_mb_Set() const{
    return m_memory_mb_isSet;
}

bool OAIVmwareNodeConfig::is_memory_mb_Valid() const{
    return m_memory_mb_isValid;
}

QString OAIVmwareNodeConfig::getReplicas() const {
    return m_replicas;
}
void OAIVmwareNodeConfig::setReplicas(const QString &replicas) {
    m_replicas = replicas;
    m_replicas_isSet = true;
}

bool OAIVmwareNodeConfig::is_replicas_Set() const{
    return m_replicas_isSet;
}

bool OAIVmwareNodeConfig::is_replicas_Valid() const{
    return m_replicas_isValid;
}

QList<OAINodeTaint> OAIVmwareNodeConfig::getTaints() const {
    return m_taints;
}
void OAIVmwareNodeConfig::setTaints(const QList<OAINodeTaint> &taints) {
    m_taints = taints;
    m_taints_isSet = true;
}

bool OAIVmwareNodeConfig::is_taints_Set() const{
    return m_taints_isSet;
}

bool OAIVmwareNodeConfig::is_taints_Valid() const{
    return m_taints_isValid;
}

OAIVmwareVsphereConfig OAIVmwareNodeConfig::getVsphereConfig() const {
    return m_vsphere_config;
}
void OAIVmwareNodeConfig::setVsphereConfig(const OAIVmwareVsphereConfig &vsphere_config) {
    m_vsphere_config = vsphere_config;
    m_vsphere_config_isSet = true;
}

bool OAIVmwareNodeConfig::is_vsphere_config_Set() const{
    return m_vsphere_config_isSet;
}

bool OAIVmwareNodeConfig::is_vsphere_config_Valid() const{
    return m_vsphere_config_isValid;
}

bool OAIVmwareNodeConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_boot_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpus_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_load_balancer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_mb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_replicas_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_taints.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_vsphere_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVmwareNodeConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
