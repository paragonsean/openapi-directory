/*
 * Anthos On-Prem API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.NodeTaint;
import org.openapitools.client.model.VmwareVsphereConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters that describe the configuration of all nodes within a given node pool.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:14.708243-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VmwareNodeConfig {
  public static final String SERIALIZED_NAME_BOOT_DISK_SIZE_GB = "bootDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_SIZE_GB)
  private String bootDiskSizeGb;

  public static final String SERIALIZED_NAME_CPUS = "cpus";
  @SerializedName(SERIALIZED_NAME_CPUS)
  private String cpus;

  public static final String SERIALIZED_NAME_ENABLE_LOAD_BALANCER = "enableLoadBalancer";
  @SerializedName(SERIALIZED_NAME_ENABLE_LOAD_BALANCER)
  private Boolean enableLoadBalancer;

  public static final String SERIALIZED_NAME_IMAGE = "image";
  @SerializedName(SERIALIZED_NAME_IMAGE)
  private String image;

  public static final String SERIALIZED_NAME_IMAGE_TYPE = "imageType";
  @SerializedName(SERIALIZED_NAME_IMAGE_TYPE)
  private String imageType;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MEMORY_MB = "memoryMb";
  @SerializedName(SERIALIZED_NAME_MEMORY_MB)
  private String memoryMb;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private String replicas;

  public static final String SERIALIZED_NAME_TAINTS = "taints";
  @SerializedName(SERIALIZED_NAME_TAINTS)
  private List<NodeTaint> taints = new ArrayList<>();

  public static final String SERIALIZED_NAME_VSPHERE_CONFIG = "vsphereConfig";
  @SerializedName(SERIALIZED_NAME_VSPHERE_CONFIG)
  private VmwareVsphereConfig vsphereConfig;

  public VmwareNodeConfig() {
  }

  public VmwareNodeConfig bootDiskSizeGb(String bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
    return this;
  }

  /**
   * VMware disk size to be used during creation.
   * @return bootDiskSizeGb
   */
  @javax.annotation.Nullable
  public String getBootDiskSizeGb() {
    return bootDiskSizeGb;
  }

  public void setBootDiskSizeGb(String bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
  }


  public VmwareNodeConfig cpus(String cpus) {
    this.cpus = cpus;
    return this;
  }

  /**
   * The number of CPUs for each node in the node pool.
   * @return cpus
   */
  @javax.annotation.Nullable
  public String getCpus() {
    return cpus;
  }

  public void setCpus(String cpus) {
    this.cpus = cpus;
  }


  public VmwareNodeConfig enableLoadBalancer(Boolean enableLoadBalancer) {
    this.enableLoadBalancer = enableLoadBalancer;
    return this;
  }

  /**
   * Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.
   * @return enableLoadBalancer
   */
  @javax.annotation.Nullable
  public Boolean getEnableLoadBalancer() {
    return enableLoadBalancer;
  }

  public void setEnableLoadBalancer(Boolean enableLoadBalancer) {
    this.enableLoadBalancer = enableLoadBalancer;
  }


  public VmwareNodeConfig image(String image) {
    this.image = image;
    return this;
  }

  /**
   * The OS image name in vCenter, only valid when using Windows.
   * @return image
   */
  @javax.annotation.Nullable
  public String getImage() {
    return image;
  }

  public void setImage(String image) {
    this.image = image;
  }


  public VmwareNodeConfig imageType(String imageType) {
    this.imageType = imageType;
    return this;
  }

  /**
   * Required. The OS image to be used for each node in a node pool. Currently &#x60;cos&#x60;, &#x60;ubuntu&#x60;, &#x60;ubuntu_containerd&#x60; and &#x60;windows&#x60; are supported.
   * @return imageType
   */
  @javax.annotation.Nullable
  public String getImageType() {
    return imageType;
  }

  public void setImageType(String imageType) {
    this.imageType = imageType;
  }


  public VmwareNodeConfig labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public VmwareNodeConfig putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public VmwareNodeConfig memoryMb(String memoryMb) {
    this.memoryMb = memoryMb;
    return this;
  }

  /**
   * The megabytes of memory for each node in the node pool.
   * @return memoryMb
   */
  @javax.annotation.Nullable
  public String getMemoryMb() {
    return memoryMb;
  }

  public void setMemoryMb(String memoryMb) {
    this.memoryMb = memoryMb;
  }


  public VmwareNodeConfig replicas(String replicas) {
    this.replicas = replicas;
    return this;
  }

  /**
   * The number of nodes in the node pool.
   * @return replicas
   */
  @javax.annotation.Nullable
  public String getReplicas() {
    return replicas;
  }

  public void setReplicas(String replicas) {
    this.replicas = replicas;
  }


  public VmwareNodeConfig taints(List<NodeTaint> taints) {
    this.taints = taints;
    return this;
  }

  public VmwareNodeConfig addTaintsItem(NodeTaint taintsItem) {
    if (this.taints == null) {
      this.taints = new ArrayList<>();
    }
    this.taints.add(taintsItem);
    return this;
  }

  /**
   * The initial taints assigned to nodes of this node pool.
   * @return taints
   */
  @javax.annotation.Nullable
  public List<NodeTaint> getTaints() {
    return taints;
  }

  public void setTaints(List<NodeTaint> taints) {
    this.taints = taints;
  }


  public VmwareNodeConfig vsphereConfig(VmwareVsphereConfig vsphereConfig) {
    this.vsphereConfig = vsphereConfig;
    return this;
  }

  /**
   * Get vsphereConfig
   * @return vsphereConfig
   */
  @javax.annotation.Nullable
  public VmwareVsphereConfig getVsphereConfig() {
    return vsphereConfig;
  }

  public void setVsphereConfig(VmwareVsphereConfig vsphereConfig) {
    this.vsphereConfig = vsphereConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VmwareNodeConfig vmwareNodeConfig = (VmwareNodeConfig) o;
    return Objects.equals(this.bootDiskSizeGb, vmwareNodeConfig.bootDiskSizeGb) &&
        Objects.equals(this.cpus, vmwareNodeConfig.cpus) &&
        Objects.equals(this.enableLoadBalancer, vmwareNodeConfig.enableLoadBalancer) &&
        Objects.equals(this.image, vmwareNodeConfig.image) &&
        Objects.equals(this.imageType, vmwareNodeConfig.imageType) &&
        Objects.equals(this.labels, vmwareNodeConfig.labels) &&
        Objects.equals(this.memoryMb, vmwareNodeConfig.memoryMb) &&
        Objects.equals(this.replicas, vmwareNodeConfig.replicas) &&
        Objects.equals(this.taints, vmwareNodeConfig.taints) &&
        Objects.equals(this.vsphereConfig, vmwareNodeConfig.vsphereConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bootDiskSizeGb, cpus, enableLoadBalancer, image, imageType, labels, memoryMb, replicas, taints, vsphereConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VmwareNodeConfig {\n");
    sb.append("    bootDiskSizeGb: ").append(toIndentedString(bootDiskSizeGb)).append("\n");
    sb.append("    cpus: ").append(toIndentedString(cpus)).append("\n");
    sb.append("    enableLoadBalancer: ").append(toIndentedString(enableLoadBalancer)).append("\n");
    sb.append("    image: ").append(toIndentedString(image)).append("\n");
    sb.append("    imageType: ").append(toIndentedString(imageType)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    memoryMb: ").append(toIndentedString(memoryMb)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    taints: ").append(toIndentedString(taints)).append("\n");
    sb.append("    vsphereConfig: ").append(toIndentedString(vsphereConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bootDiskSizeGb");
    openapiFields.add("cpus");
    openapiFields.add("enableLoadBalancer");
    openapiFields.add("image");
    openapiFields.add("imageType");
    openapiFields.add("labels");
    openapiFields.add("memoryMb");
    openapiFields.add("replicas");
    openapiFields.add("taints");
    openapiFields.add("vsphereConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VmwareNodeConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VmwareNodeConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VmwareNodeConfig is not found in the empty JSON string", VmwareNodeConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VmwareNodeConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VmwareNodeConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bootDiskSizeGb") != null && !jsonObj.get("bootDiskSizeGb").isJsonNull()) && !jsonObj.get("bootDiskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskSizeGb").toString()));
      }
      if ((jsonObj.get("cpus") != null && !jsonObj.get("cpus").isJsonNull()) && !jsonObj.get("cpus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpus").toString()));
      }
      if ((jsonObj.get("image") != null && !jsonObj.get("image").isJsonNull()) && !jsonObj.get("image").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `image` to be a primitive type in the JSON string but got `%s`", jsonObj.get("image").toString()));
      }
      if ((jsonObj.get("imageType") != null && !jsonObj.get("imageType").isJsonNull()) && !jsonObj.get("imageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageType").toString()));
      }
      if ((jsonObj.get("memoryMb") != null && !jsonObj.get("memoryMb").isJsonNull()) && !jsonObj.get("memoryMb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memoryMb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memoryMb").toString()));
      }
      if ((jsonObj.get("replicas") != null && !jsonObj.get("replicas").isJsonNull()) && !jsonObj.get("replicas").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicas` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replicas").toString()));
      }
      if (jsonObj.get("taints") != null && !jsonObj.get("taints").isJsonNull()) {
        JsonArray jsonArraytaints = jsonObj.getAsJsonArray("taints");
        if (jsonArraytaints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("taints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `taints` to be an array in the JSON string but got `%s`", jsonObj.get("taints").toString()));
          }

          // validate the optional field `taints` (array)
          for (int i = 0; i < jsonArraytaints.size(); i++) {
            NodeTaint.validateJsonElement(jsonArraytaints.get(i));
          };
        }
      }
      // validate the optional field `vsphereConfig`
      if (jsonObj.get("vsphereConfig") != null && !jsonObj.get("vsphereConfig").isJsonNull()) {
        VmwareVsphereConfig.validateJsonElement(jsonObj.get("vsphereConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VmwareNodeConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VmwareNodeConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VmwareNodeConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VmwareNodeConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<VmwareNodeConfig>() {
           @Override
           public void write(JsonWriter out, VmwareNodeConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VmwareNodeConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VmwareNodeConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VmwareNodeConfig
   * @throws IOException if the JSON string is invalid with respect to VmwareNodeConfig
   */
  public static VmwareNodeConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VmwareNodeConfig.class);
  }

  /**
   * Convert an instance of VmwareNodeConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

