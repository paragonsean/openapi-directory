/*
 * Cloud Healthcare API
 * Manage, store, and access healthcare data in Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.FhirNotificationConfig;
import org.openapitools.client.model.NotificationConfig;
import org.openapitools.client.model.StreamConfig;
import org.openapitools.client.model.ValidationConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a FHIR store.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:13.605175-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FhirStore {
  /**
   * Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
   */
  @JsonAdapter(ComplexDataTypeReferenceParsingEnum.Adapter.class)
  public enum ComplexDataTypeReferenceParsingEnum {
    COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED("COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED"),
    
    DISABLED("DISABLED"),
    
    ENABLED("ENABLED");

    private String value;

    ComplexDataTypeReferenceParsingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ComplexDataTypeReferenceParsingEnum fromValue(String value) {
      for (ComplexDataTypeReferenceParsingEnum b : ComplexDataTypeReferenceParsingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ComplexDataTypeReferenceParsingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ComplexDataTypeReferenceParsingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ComplexDataTypeReferenceParsingEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ComplexDataTypeReferenceParsingEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ComplexDataTypeReferenceParsingEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMPLEX_DATA_TYPE_REFERENCE_PARSING = "complexDataTypeReferenceParsing";
  @SerializedName(SERIALIZED_NAME_COMPLEX_DATA_TYPE_REFERENCE_PARSING)
  private ComplexDataTypeReferenceParsingEnum complexDataTypeReferenceParsing;

  public static final String SERIALIZED_NAME_DEFAULT_SEARCH_HANDLING_STRICT = "defaultSearchHandlingStrict";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SEARCH_HANDLING_STRICT)
  private Boolean defaultSearchHandlingStrict;

  public static final String SERIALIZED_NAME_DISABLE_REFERENTIAL_INTEGRITY = "disableReferentialIntegrity";
  @SerializedName(SERIALIZED_NAME_DISABLE_REFERENTIAL_INTEGRITY)
  private Boolean disableReferentialIntegrity;

  public static final String SERIALIZED_NAME_DISABLE_RESOURCE_VERSIONING = "disableResourceVersioning";
  @SerializedName(SERIALIZED_NAME_DISABLE_RESOURCE_VERSIONING)
  private Boolean disableResourceVersioning;

  public static final String SERIALIZED_NAME_ENABLE_UPDATE_CREATE = "enableUpdateCreate";
  @SerializedName(SERIALIZED_NAME_ENABLE_UPDATE_CREATE)
  private Boolean enableUpdateCreate;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NOTIFICATION_CONFIG = "notificationConfig";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_CONFIG)
  private NotificationConfig notificationConfig;

  public static final String SERIALIZED_NAME_NOTIFICATION_CONFIGS = "notificationConfigs";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_CONFIGS)
  private List<FhirNotificationConfig> notificationConfigs = new ArrayList<>();

  public static final String SERIALIZED_NAME_STREAM_CONFIGS = "streamConfigs";
  @SerializedName(SERIALIZED_NAME_STREAM_CONFIGS)
  private List<StreamConfig> streamConfigs = new ArrayList<>();

  public static final String SERIALIZED_NAME_VALIDATION_CONFIG = "validationConfig";
  @SerializedName(SERIALIZED_NAME_VALIDATION_CONFIG)
  private ValidationConfig validationConfig;

  /**
   * Required. Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
   */
  @JsonAdapter(VersionEnum.Adapter.class)
  public enum VersionEnum {
    VERSION_UNSPECIFIED("VERSION_UNSPECIFIED"),
    
    DSTU2("DSTU2"),
    
    STU3("STU3"),
    
    R4("R4");

    private String value;

    VersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VersionEnum fromValue(String value) {
      for (VersionEnum b : VersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private VersionEnum version;

  public FhirStore() {
  }

  public FhirStore complexDataTypeReferenceParsing(ComplexDataTypeReferenceParsingEnum complexDataTypeReferenceParsing) {
    this.complexDataTypeReferenceParsing = complexDataTypeReferenceParsing;
    return this;
  }

  /**
   * Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
   * @return complexDataTypeReferenceParsing
   */
  @javax.annotation.Nullable
  public ComplexDataTypeReferenceParsingEnum getComplexDataTypeReferenceParsing() {
    return complexDataTypeReferenceParsing;
  }

  public void setComplexDataTypeReferenceParsing(ComplexDataTypeReferenceParsingEnum complexDataTypeReferenceParsing) {
    this.complexDataTypeReferenceParsing = complexDataTypeReferenceParsing;
  }


  public FhirStore defaultSearchHandlingStrict(Boolean defaultSearchHandlingStrict) {
    this.defaultSearchHandlingStrict = defaultSearchHandlingStrict;
    return this;
  }

  /**
   * If true, overrides the default search behavior for this FHIR store to &#x60;handling&#x3D;strict&#x60; which returns an error for unrecognized search parameters. If false, uses the FHIR specification default &#x60;handling&#x3D;lenient&#x60; which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header &#x60;Prefer: handling&#x3D;strict&#x60; or &#x60;Prefer: handling&#x3D;lenient&#x60;.
   * @return defaultSearchHandlingStrict
   */
  @javax.annotation.Nullable
  public Boolean getDefaultSearchHandlingStrict() {
    return defaultSearchHandlingStrict;
  }

  public void setDefaultSearchHandlingStrict(Boolean defaultSearchHandlingStrict) {
    this.defaultSearchHandlingStrict = defaultSearchHandlingStrict;
  }


  public FhirStore disableReferentialIntegrity(Boolean disableReferentialIntegrity) {
    this.disableReferentialIntegrity = disableReferentialIntegrity;
    return this;
  }

  /**
   * Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.
   * @return disableReferentialIntegrity
   */
  @javax.annotation.Nullable
  public Boolean getDisableReferentialIntegrity() {
    return disableReferentialIntegrity;
  }

  public void setDisableReferentialIntegrity(Boolean disableReferentialIntegrity) {
    this.disableReferentialIntegrity = disableReferentialIntegrity;
  }


  public FhirStore disableResourceVersioning(Boolean disableResourceVersioning) {
    this.disableResourceVersioning = disableResourceVersioning;
    return this;
  }

  /**
   * Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.
   * @return disableResourceVersioning
   */
  @javax.annotation.Nullable
  public Boolean getDisableResourceVersioning() {
    return disableResourceVersioning;
  }

  public void setDisableResourceVersioning(Boolean disableResourceVersioning) {
    this.disableResourceVersioning = disableResourceVersioning;
  }


  public FhirStore enableUpdateCreate(Boolean enableUpdateCreate) {
    this.enableUpdateCreate = enableUpdateCreate;
    return this;
  }

  /**
   * Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.
   * @return enableUpdateCreate
   */
  @javax.annotation.Nullable
  public Boolean getEnableUpdateCreate() {
    return enableUpdateCreate;
  }

  public void setEnableUpdateCreate(Boolean enableUpdateCreate) {
    this.enableUpdateCreate = enableUpdateCreate;
  }


  public FhirStore labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public FhirStore putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public FhirStore name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Output only. Identifier. Resource name of the FHIR store, of the form &#x60;projects/{project_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public FhirStore notificationConfig(NotificationConfig notificationConfig) {
    this.notificationConfig = notificationConfig;
    return this;
  }

  /**
   * Get notificationConfig
   * @return notificationConfig
   */
  @javax.annotation.Nullable
  public NotificationConfig getNotificationConfig() {
    return notificationConfig;
  }

  public void setNotificationConfig(NotificationConfig notificationConfig) {
    this.notificationConfig = notificationConfig;
  }


  public FhirStore notificationConfigs(List<FhirNotificationConfig> notificationConfigs) {
    this.notificationConfigs = notificationConfigs;
    return this;
  }

  public FhirStore addNotificationConfigsItem(FhirNotificationConfig notificationConfigsItem) {
    if (this.notificationConfigs == null) {
      this.notificationConfigs = new ArrayList<>();
    }
    this.notificationConfigs.add(notificationConfigsItem);
    return this;
  }

  /**
   * Specifies where and whether to send notifications upon changes to a FHIR store.
   * @return notificationConfigs
   */
  @javax.annotation.Nullable
  public List<FhirNotificationConfig> getNotificationConfigs() {
    return notificationConfigs;
  }

  public void setNotificationConfigs(List<FhirNotificationConfig> notificationConfigs) {
    this.notificationConfigs = notificationConfigs;
  }


  public FhirStore streamConfigs(List<StreamConfig> streamConfigs) {
    this.streamConfigs = streamConfigs;
    return this;
  }

  public FhirStore addStreamConfigsItem(StreamConfig streamConfigsItem) {
    if (this.streamConfigs == null) {
      this.streamConfigs = new ArrayList<>();
    }
    this.streamConfigs.add(streamConfigsItem);
    return this;
  }

  /**
   * A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [&#x60;bigquery.dataEditor&#x60;](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
   * @return streamConfigs
   */
  @javax.annotation.Nullable
  public List<StreamConfig> getStreamConfigs() {
    return streamConfigs;
  }

  public void setStreamConfigs(List<StreamConfig> streamConfigs) {
    this.streamConfigs = streamConfigs;
  }


  public FhirStore validationConfig(ValidationConfig validationConfig) {
    this.validationConfig = validationConfig;
    return this;
  }

  /**
   * Get validationConfig
   * @return validationConfig
   */
  @javax.annotation.Nullable
  public ValidationConfig getValidationConfig() {
    return validationConfig;
  }

  public void setValidationConfig(ValidationConfig validationConfig) {
    this.validationConfig = validationConfig;
  }


  public FhirStore version(VersionEnum version) {
    this.version = version;
    return this;
  }

  /**
   * Required. Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
   * @return version
   */
  @javax.annotation.Nullable
  public VersionEnum getVersion() {
    return version;
  }

  public void setVersion(VersionEnum version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FhirStore fhirStore = (FhirStore) o;
    return Objects.equals(this.complexDataTypeReferenceParsing, fhirStore.complexDataTypeReferenceParsing) &&
        Objects.equals(this.defaultSearchHandlingStrict, fhirStore.defaultSearchHandlingStrict) &&
        Objects.equals(this.disableReferentialIntegrity, fhirStore.disableReferentialIntegrity) &&
        Objects.equals(this.disableResourceVersioning, fhirStore.disableResourceVersioning) &&
        Objects.equals(this.enableUpdateCreate, fhirStore.enableUpdateCreate) &&
        Objects.equals(this.labels, fhirStore.labels) &&
        Objects.equals(this.name, fhirStore.name) &&
        Objects.equals(this.notificationConfig, fhirStore.notificationConfig) &&
        Objects.equals(this.notificationConfigs, fhirStore.notificationConfigs) &&
        Objects.equals(this.streamConfigs, fhirStore.streamConfigs) &&
        Objects.equals(this.validationConfig, fhirStore.validationConfig) &&
        Objects.equals(this.version, fhirStore.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(complexDataTypeReferenceParsing, defaultSearchHandlingStrict, disableReferentialIntegrity, disableResourceVersioning, enableUpdateCreate, labels, name, notificationConfig, notificationConfigs, streamConfigs, validationConfig, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FhirStore {\n");
    sb.append("    complexDataTypeReferenceParsing: ").append(toIndentedString(complexDataTypeReferenceParsing)).append("\n");
    sb.append("    defaultSearchHandlingStrict: ").append(toIndentedString(defaultSearchHandlingStrict)).append("\n");
    sb.append("    disableReferentialIntegrity: ").append(toIndentedString(disableReferentialIntegrity)).append("\n");
    sb.append("    disableResourceVersioning: ").append(toIndentedString(disableResourceVersioning)).append("\n");
    sb.append("    enableUpdateCreate: ").append(toIndentedString(enableUpdateCreate)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notificationConfig: ").append(toIndentedString(notificationConfig)).append("\n");
    sb.append("    notificationConfigs: ").append(toIndentedString(notificationConfigs)).append("\n");
    sb.append("    streamConfigs: ").append(toIndentedString(streamConfigs)).append("\n");
    sb.append("    validationConfig: ").append(toIndentedString(validationConfig)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("complexDataTypeReferenceParsing");
    openapiFields.add("defaultSearchHandlingStrict");
    openapiFields.add("disableReferentialIntegrity");
    openapiFields.add("disableResourceVersioning");
    openapiFields.add("enableUpdateCreate");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("notificationConfig");
    openapiFields.add("notificationConfigs");
    openapiFields.add("streamConfigs");
    openapiFields.add("validationConfig");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FhirStore
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FhirStore.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FhirStore is not found in the empty JSON string", FhirStore.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FhirStore.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FhirStore` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("complexDataTypeReferenceParsing") != null && !jsonObj.get("complexDataTypeReferenceParsing").isJsonNull()) && !jsonObj.get("complexDataTypeReferenceParsing").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `complexDataTypeReferenceParsing` to be a primitive type in the JSON string but got `%s`", jsonObj.get("complexDataTypeReferenceParsing").toString()));
      }
      // validate the optional field `complexDataTypeReferenceParsing`
      if (jsonObj.get("complexDataTypeReferenceParsing") != null && !jsonObj.get("complexDataTypeReferenceParsing").isJsonNull()) {
        ComplexDataTypeReferenceParsingEnum.validateJsonElement(jsonObj.get("complexDataTypeReferenceParsing"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `notificationConfig`
      if (jsonObj.get("notificationConfig") != null && !jsonObj.get("notificationConfig").isJsonNull()) {
        NotificationConfig.validateJsonElement(jsonObj.get("notificationConfig"));
      }
      if (jsonObj.get("notificationConfigs") != null && !jsonObj.get("notificationConfigs").isJsonNull()) {
        JsonArray jsonArraynotificationConfigs = jsonObj.getAsJsonArray("notificationConfigs");
        if (jsonArraynotificationConfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("notificationConfigs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `notificationConfigs` to be an array in the JSON string but got `%s`", jsonObj.get("notificationConfigs").toString()));
          }

          // validate the optional field `notificationConfigs` (array)
          for (int i = 0; i < jsonArraynotificationConfigs.size(); i++) {
            FhirNotificationConfig.validateJsonElement(jsonArraynotificationConfigs.get(i));
          };
        }
      }
      if (jsonObj.get("streamConfigs") != null && !jsonObj.get("streamConfigs").isJsonNull()) {
        JsonArray jsonArraystreamConfigs = jsonObj.getAsJsonArray("streamConfigs");
        if (jsonArraystreamConfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("streamConfigs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `streamConfigs` to be an array in the JSON string but got `%s`", jsonObj.get("streamConfigs").toString()));
          }

          // validate the optional field `streamConfigs` (array)
          for (int i = 0; i < jsonArraystreamConfigs.size(); i++) {
            StreamConfig.validateJsonElement(jsonArraystreamConfigs.get(i));
          };
        }
      }
      // validate the optional field `validationConfig`
      if (jsonObj.get("validationConfig") != null && !jsonObj.get("validationConfig").isJsonNull()) {
        ValidationConfig.validateJsonElement(jsonObj.get("validationConfig"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      // validate the optional field `version`
      if (jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) {
        VersionEnum.validateJsonElement(jsonObj.get("version"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FhirStore.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FhirStore' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FhirStore> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FhirStore.class));

       return (TypeAdapter<T>) new TypeAdapter<FhirStore>() {
           @Override
           public void write(JsonWriter out, FhirStore value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FhirStore read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FhirStore given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FhirStore
   * @throws IOException if the JSON string is invalid with respect to FhirStore
   */
  public static FhirStore fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FhirStore.class);
  }

  /**
   * Convert an instance of FhirStore to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

