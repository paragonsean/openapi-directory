# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.tag_filter_list import TagFilterList
from openapi_server import util


class DicomConfig(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, filter_profile: str=None, keep_list: TagFilterList=None, remove_list: TagFilterList=None, skip_id_redaction: bool=None):
        """DicomConfig - a model defined in OpenAPI

        :param filter_profile: The filter_profile of this DicomConfig.
        :param keep_list: The keep_list of this DicomConfig.
        :param remove_list: The remove_list of this DicomConfig.
        :param skip_id_redaction: The skip_id_redaction of this DicomConfig.
        """
        self.openapi_types = {
            'filter_profile': str,
            'keep_list': TagFilterList,
            'remove_list': TagFilterList,
            'skip_id_redaction': bool
        }

        self.attribute_map = {
            'filter_profile': 'filterProfile',
            'keep_list': 'keepList',
            'remove_list': 'removeList',
            'skip_id_redaction': 'skipIdRedaction'
        }

        self._filter_profile = filter_profile
        self._keep_list = keep_list
        self._remove_list = remove_list
        self._skip_id_redaction = skip_id_redaction

    @classmethod
    def from_dict(cls, dikt: dict) -> 'DicomConfig':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The DicomConfig of this DicomConfig.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def filter_profile(self):
        """Gets the filter_profile of this DicomConfig.

        Tag filtering profile that determines which tags to keep/remove.

        :return: The filter_profile of this DicomConfig.
        :rtype: str
        """
        return self._filter_profile

    @filter_profile.setter
    def filter_profile(self, filter_profile):
        """Sets the filter_profile of this DicomConfig.

        Tag filtering profile that determines which tags to keep/remove.

        :param filter_profile: The filter_profile of this DicomConfig.
        :type filter_profile: str
        """
        allowed_values = ["TAG_FILTER_PROFILE_UNSPECIFIED", "MINIMAL_KEEP_LIST_PROFILE", "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE", "KEEP_ALL_PROFILE", "DEIDENTIFY_TAG_CONTENTS"]  # noqa: E501
        if filter_profile not in allowed_values:
            raise ValueError(
                "Invalid value for `filter_profile` ({0}), must be one of {1}"
                .format(filter_profile, allowed_values)
            )

        self._filter_profile = filter_profile

    @property
    def keep_list(self):
        """Gets the keep_list of this DicomConfig.


        :return: The keep_list of this DicomConfig.
        :rtype: TagFilterList
        """
        return self._keep_list

    @keep_list.setter
    def keep_list(self, keep_list):
        """Sets the keep_list of this DicomConfig.


        :param keep_list: The keep_list of this DicomConfig.
        :type keep_list: TagFilterList
        """

        self._keep_list = keep_list

    @property
    def remove_list(self):
        """Gets the remove_list of this DicomConfig.


        :return: The remove_list of this DicomConfig.
        :rtype: TagFilterList
        """
        return self._remove_list

    @remove_list.setter
    def remove_list(self, remove_list):
        """Sets the remove_list of this DicomConfig.


        :param remove_list: The remove_list of this DicomConfig.
        :type remove_list: TagFilterList
        """

        self._remove_list = remove_list

    @property
    def skip_id_redaction(self):
        """Gets the skip_id_redaction of this DicomConfig.

        If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: \"Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity.\" http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html

        :return: The skip_id_redaction of this DicomConfig.
        :rtype: bool
        """
        return self._skip_id_redaction

    @skip_id_redaction.setter
    def skip_id_redaction(self, skip_id_redaction):
        """Sets the skip_id_redaction of this DicomConfig.

        If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: \"Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity.\" http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html

        :param skip_id_redaction: The skip_id_redaction of this DicomConfig.
        :type skip_id_redaction: bool
        """

        self._skip_id_redaction = skip_id_redaction
