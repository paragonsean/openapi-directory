/*
 * Cloud Healthcare API
 * Manage, store, and access healthcare data in Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Attribute;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Maps a resource to the associated user and Attributes.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:11.528078-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UserDataMapping {
  public static final String SERIALIZED_NAME_ARCHIVE_TIME = "archiveTime";
  @SerializedName(SERIALIZED_NAME_ARCHIVE_TIME)
  private String archiveTime;

  public static final String SERIALIZED_NAME_ARCHIVED = "archived";
  @SerializedName(SERIALIZED_NAME_ARCHIVED)
  private Boolean archived;

  public static final String SERIALIZED_NAME_DATA_ID = "dataId";
  @SerializedName(SERIALIZED_NAME_DATA_ID)
  private String dataId;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RESOURCE_ATTRIBUTES = "resourceAttributes";
  @SerializedName(SERIALIZED_NAME_RESOURCE_ATTRIBUTES)
  private List<Attribute> resourceAttributes = new ArrayList<>();

  public static final String SERIALIZED_NAME_USER_ID = "userId";
  @SerializedName(SERIALIZED_NAME_USER_ID)
  private String userId;

  public UserDataMapping() {
  }

  public UserDataMapping(
     String archiveTime, 
     Boolean archived
  ) {
    this();
    this.archiveTime = archiveTime;
    this.archived = archived;
  }

  /**
   * Output only. Indicates the time when this mapping was archived.
   * @return archiveTime
   */
  @javax.annotation.Nullable
  public String getArchiveTime() {
    return archiveTime;
  }



  /**
   * Output only. Indicates whether this mapping is archived.
   * @return archived
   */
  @javax.annotation.Nullable
  public Boolean getArchived() {
    return archived;
  }



  public UserDataMapping dataId(String dataId) {
    this.dataId = dataId;
    return this;
  }

  /**
   * Required. A unique identifier for the mapped resource.
   * @return dataId
   */
  @javax.annotation.Nullable
  public String getDataId() {
    return dataId;
  }

  public void setDataId(String dataId) {
    this.dataId = dataId;
  }


  public UserDataMapping name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name of the User data mapping, of the form &#x60;projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/userDataMappings/{user_data_mapping_id}&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public UserDataMapping resourceAttributes(List<Attribute> resourceAttributes) {
    this.resourceAttributes = resourceAttributes;
    return this;
  }

  public UserDataMapping addResourceAttributesItem(Attribute resourceAttributesItem) {
    if (this.resourceAttributes == null) {
      this.resourceAttributes = new ArrayList<>();
    }
    this.resourceAttributes.add(resourceAttributesItem);
    return this;
  }

  /**
   * Attributes of the resource. Only explicitly set attributes are displayed here. Attribute definitions with defaults set implicitly apply to these User data mappings. Attributes listed here must be single valued, that is, exactly one value is specified for the field \&quot;values\&quot; in each Attribute.
   * @return resourceAttributes
   */
  @javax.annotation.Nullable
  public List<Attribute> getResourceAttributes() {
    return resourceAttributes;
  }

  public void setResourceAttributes(List<Attribute> resourceAttributes) {
    this.resourceAttributes = resourceAttributes;
  }


  public UserDataMapping userId(String userId) {
    this.userId = userId;
    return this;
  }

  /**
   * Required. User&#39;s UUID provided by the client.
   * @return userId
   */
  @javax.annotation.Nullable
  public String getUserId() {
    return userId;
  }

  public void setUserId(String userId) {
    this.userId = userId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UserDataMapping userDataMapping = (UserDataMapping) o;
    return Objects.equals(this.archiveTime, userDataMapping.archiveTime) &&
        Objects.equals(this.archived, userDataMapping.archived) &&
        Objects.equals(this.dataId, userDataMapping.dataId) &&
        Objects.equals(this.name, userDataMapping.name) &&
        Objects.equals(this.resourceAttributes, userDataMapping.resourceAttributes) &&
        Objects.equals(this.userId, userDataMapping.userId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(archiveTime, archived, dataId, name, resourceAttributes, userId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UserDataMapping {\n");
    sb.append("    archiveTime: ").append(toIndentedString(archiveTime)).append("\n");
    sb.append("    archived: ").append(toIndentedString(archived)).append("\n");
    sb.append("    dataId: ").append(toIndentedString(dataId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    resourceAttributes: ").append(toIndentedString(resourceAttributes)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("archiveTime");
    openapiFields.add("archived");
    openapiFields.add("dataId");
    openapiFields.add("name");
    openapiFields.add("resourceAttributes");
    openapiFields.add("userId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UserDataMapping
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UserDataMapping.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UserDataMapping is not found in the empty JSON string", UserDataMapping.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UserDataMapping.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UserDataMapping` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("archiveTime") != null && !jsonObj.get("archiveTime").isJsonNull()) && !jsonObj.get("archiveTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `archiveTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("archiveTime").toString()));
      }
      if ((jsonObj.get("dataId") != null && !jsonObj.get("dataId").isJsonNull()) && !jsonObj.get("dataId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataId").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("resourceAttributes") != null && !jsonObj.get("resourceAttributes").isJsonNull()) {
        JsonArray jsonArrayresourceAttributes = jsonObj.getAsJsonArray("resourceAttributes");
        if (jsonArrayresourceAttributes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("resourceAttributes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `resourceAttributes` to be an array in the JSON string but got `%s`", jsonObj.get("resourceAttributes").toString()));
          }

          // validate the optional field `resourceAttributes` (array)
          for (int i = 0; i < jsonArrayresourceAttributes.size(); i++) {
            Attribute.validateJsonElement(jsonArrayresourceAttributes.get(i));
          };
        }
      }
      if ((jsonObj.get("userId") != null && !jsonObj.get("userId").isJsonNull()) && !jsonObj.get("userId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UserDataMapping.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UserDataMapping' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UserDataMapping> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UserDataMapping.class));

       return (TypeAdapter<T>) new TypeAdapter<UserDataMapping>() {
           @Override
           public void write(JsonWriter out, UserDataMapping value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UserDataMapping read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UserDataMapping given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UserDataMapping
   * @throws IOException if the JSON string is invalid with respect to UserDataMapping
   */
  public static UserDataMapping fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UserDataMapping.class);
  }

  /**
   * Convert an instance of UserDataMapping to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

