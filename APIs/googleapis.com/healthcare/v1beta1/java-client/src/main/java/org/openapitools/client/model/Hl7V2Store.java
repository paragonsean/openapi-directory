/*
 * Cloud Healthcare API
 * Manage, store, and access healthcare data in Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Hl7V2NotificationConfig;
import org.openapitools.client.model.NotificationConfig;
import org.openapitools.client.model.ParserConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents an HL7v2 store.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:11.528078-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Hl7V2Store {
  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NOTIFICATION_CONFIG = "notificationConfig";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_CONFIG)
  private NotificationConfig notificationConfig;

  public static final String SERIALIZED_NAME_NOTIFICATION_CONFIGS = "notificationConfigs";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_CONFIGS)
  private List<Hl7V2NotificationConfig> notificationConfigs = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARSER_CONFIG = "parserConfig";
  @SerializedName(SERIALIZED_NAME_PARSER_CONFIG)
  private ParserConfig parserConfig;

  public static final String SERIALIZED_NAME_REJECT_DUPLICATE_MESSAGE = "rejectDuplicateMessage";
  @SerializedName(SERIALIZED_NAME_REJECT_DUPLICATE_MESSAGE)
  private Boolean rejectDuplicateMessage;

  public Hl7V2Store() {
  }

  public Hl7V2Store labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Hl7V2Store putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Hl7V2Store name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Identifier. Resource name of the HL7v2 store, of the form &#x60;projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/hl7V2Stores/{hl7v2_store_id}&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Hl7V2Store notificationConfig(NotificationConfig notificationConfig) {
    this.notificationConfig = notificationConfig;
    return this;
  }

  /**
   * Get notificationConfig
   * @return notificationConfig
   */
  @javax.annotation.Nullable
  public NotificationConfig getNotificationConfig() {
    return notificationConfig;
  }

  public void setNotificationConfig(NotificationConfig notificationConfig) {
    this.notificationConfig = notificationConfig;
  }


  public Hl7V2Store notificationConfigs(List<Hl7V2NotificationConfig> notificationConfigs) {
    this.notificationConfigs = notificationConfigs;
    return this;
  }

  public Hl7V2Store addNotificationConfigsItem(Hl7V2NotificationConfig notificationConfigsItem) {
    if (this.notificationConfigs == null) {
      this.notificationConfigs = new ArrayList<>();
    }
    this.notificationConfigs.add(notificationConfigsItem);
    return this;
  }

  /**
   * A list of notification configs. Each configuration uses a filter to determine whether to publish a message (both Ingest &amp; Create) on the corresponding notification destination. Only the message name is sent as part of the notification. Supplied by the client.
   * @return notificationConfigs
   */
  @javax.annotation.Nullable
  public List<Hl7V2NotificationConfig> getNotificationConfigs() {
    return notificationConfigs;
  }

  public void setNotificationConfigs(List<Hl7V2NotificationConfig> notificationConfigs) {
    this.notificationConfigs = notificationConfigs;
  }


  public Hl7V2Store parserConfig(ParserConfig parserConfig) {
    this.parserConfig = parserConfig;
    return this;
  }

  /**
   * Get parserConfig
   * @return parserConfig
   */
  @javax.annotation.Nullable
  public ParserConfig getParserConfig() {
    return parserConfig;
  }

  public void setParserConfig(ParserConfig parserConfig) {
    this.parserConfig = parserConfig;
  }


  public Hl7V2Store rejectDuplicateMessage(Boolean rejectDuplicateMessage) {
    this.rejectDuplicateMessage = rejectDuplicateMessage;
    return this;
  }

  /**
   * Determines whether to reject duplicate messages. A duplicate message is a message with the same raw bytes as a message that has already been ingested/created in this HL7v2 store. The default value is false, meaning that the store accepts the duplicate messages and it also returns the same ACK message in the IngestMessageResponse as has been returned previously. Note that only one resource is created in the store. When this field is set to true, CreateMessage/IngestMessage requests with a duplicate message will be rejected by the store, and IngestMessageErrorDetail returns a NACK message upon rejection.
   * @return rejectDuplicateMessage
   */
  @javax.annotation.Nullable
  public Boolean getRejectDuplicateMessage() {
    return rejectDuplicateMessage;
  }

  public void setRejectDuplicateMessage(Boolean rejectDuplicateMessage) {
    this.rejectDuplicateMessage = rejectDuplicateMessage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Hl7V2Store hl7V2Store = (Hl7V2Store) o;
    return Objects.equals(this.labels, hl7V2Store.labels) &&
        Objects.equals(this.name, hl7V2Store.name) &&
        Objects.equals(this.notificationConfig, hl7V2Store.notificationConfig) &&
        Objects.equals(this.notificationConfigs, hl7V2Store.notificationConfigs) &&
        Objects.equals(this.parserConfig, hl7V2Store.parserConfig) &&
        Objects.equals(this.rejectDuplicateMessage, hl7V2Store.rejectDuplicateMessage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(labels, name, notificationConfig, notificationConfigs, parserConfig, rejectDuplicateMessage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Hl7V2Store {\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notificationConfig: ").append(toIndentedString(notificationConfig)).append("\n");
    sb.append("    notificationConfigs: ").append(toIndentedString(notificationConfigs)).append("\n");
    sb.append("    parserConfig: ").append(toIndentedString(parserConfig)).append("\n");
    sb.append("    rejectDuplicateMessage: ").append(toIndentedString(rejectDuplicateMessage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("notificationConfig");
    openapiFields.add("notificationConfigs");
    openapiFields.add("parserConfig");
    openapiFields.add("rejectDuplicateMessage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Hl7V2Store
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Hl7V2Store.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Hl7V2Store is not found in the empty JSON string", Hl7V2Store.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Hl7V2Store.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Hl7V2Store` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `notificationConfig`
      if (jsonObj.get("notificationConfig") != null && !jsonObj.get("notificationConfig").isJsonNull()) {
        NotificationConfig.validateJsonElement(jsonObj.get("notificationConfig"));
      }
      if (jsonObj.get("notificationConfigs") != null && !jsonObj.get("notificationConfigs").isJsonNull()) {
        JsonArray jsonArraynotificationConfigs = jsonObj.getAsJsonArray("notificationConfigs");
        if (jsonArraynotificationConfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("notificationConfigs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `notificationConfigs` to be an array in the JSON string but got `%s`", jsonObj.get("notificationConfigs").toString()));
          }

          // validate the optional field `notificationConfigs` (array)
          for (int i = 0; i < jsonArraynotificationConfigs.size(); i++) {
            Hl7V2NotificationConfig.validateJsonElement(jsonArraynotificationConfigs.get(i));
          };
        }
      }
      // validate the optional field `parserConfig`
      if (jsonObj.get("parserConfig") != null && !jsonObj.get("parserConfig").isJsonNull()) {
        ParserConfig.validateJsonElement(jsonObj.get("parserConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Hl7V2Store.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Hl7V2Store' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Hl7V2Store> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Hl7V2Store.class));

       return (TypeAdapter<T>) new TypeAdapter<Hl7V2Store>() {
           @Override
           public void write(JsonWriter out, Hl7V2Store value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Hl7V2Store read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Hl7V2Store given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Hl7V2Store
   * @throws IOException if the JSON string is invalid with respect to Hl7V2Store
   */
  public static Hl7V2Store fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Hl7V2Store.class);
  }

  /**
   * Convert an instance of Hl7V2Store to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

