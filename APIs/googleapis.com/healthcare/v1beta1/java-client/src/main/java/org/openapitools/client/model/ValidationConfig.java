/*
 * Cloud Healthcare API
 * Manage, store, and access healthcare data in Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains the configuration for FHIR profiles and validation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:11.528078-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ValidationConfig {
  public static final String SERIALIZED_NAME_DISABLE_FHIRPATH_VALIDATION = "disableFhirpathValidation";
  @SerializedName(SERIALIZED_NAME_DISABLE_FHIRPATH_VALIDATION)
  private Boolean disableFhirpathValidation;

  public static final String SERIALIZED_NAME_DISABLE_PROFILE_VALIDATION = "disableProfileValidation";
  @SerializedName(SERIALIZED_NAME_DISABLE_PROFILE_VALIDATION)
  private Boolean disableProfileValidation;

  public static final String SERIALIZED_NAME_DISABLE_REFERENCE_TYPE_VALIDATION = "disableReferenceTypeValidation";
  @SerializedName(SERIALIZED_NAME_DISABLE_REFERENCE_TYPE_VALIDATION)
  private Boolean disableReferenceTypeValidation;

  public static final String SERIALIZED_NAME_DISABLE_REQUIRED_FIELD_VALIDATION = "disableRequiredFieldValidation";
  @SerializedName(SERIALIZED_NAME_DISABLE_REQUIRED_FIELD_VALIDATION)
  private Boolean disableRequiredFieldValidation;

  public static final String SERIALIZED_NAME_ENABLED_IMPLEMENTATION_GUIDES = "enabledImplementationGuides";
  @SerializedName(SERIALIZED_NAME_ENABLED_IMPLEMENTATION_GUIDES)
  private List<String> enabledImplementationGuides = new ArrayList<>();

  public ValidationConfig() {
  }

  public ValidationConfig disableFhirpathValidation(Boolean disableFhirpathValidation) {
    this.disableFhirpathValidation = disableFhirpathValidation;
    return this;
  }

  /**
   * Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
   * @return disableFhirpathValidation
   */
  @javax.annotation.Nullable
  public Boolean getDisableFhirpathValidation() {
    return disableFhirpathValidation;
  }

  public void setDisableFhirpathValidation(Boolean disableFhirpathValidation) {
    this.disableFhirpathValidation = disableFhirpathValidation;
  }


  public ValidationConfig disableProfileValidation(Boolean disableProfileValidation) {
    this.disableProfileValidation = disableProfileValidation;
    return this;
  }

  /**
   * Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
   * @return disableProfileValidation
   */
  @javax.annotation.Nullable
  public Boolean getDisableProfileValidation() {
    return disableProfileValidation;
  }

  public void setDisableProfileValidation(Boolean disableProfileValidation) {
    this.disableProfileValidation = disableProfileValidation;
  }


  public ValidationConfig disableReferenceTypeValidation(Boolean disableReferenceTypeValidation) {
    this.disableReferenceTypeValidation = disableReferenceTypeValidation;
    return this;
  }

  /**
   * Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
   * @return disableReferenceTypeValidation
   */
  @javax.annotation.Nullable
  public Boolean getDisableReferenceTypeValidation() {
    return disableReferenceTypeValidation;
  }

  public void setDisableReferenceTypeValidation(Boolean disableReferenceTypeValidation) {
    this.disableReferenceTypeValidation = disableReferenceTypeValidation;
  }


  public ValidationConfig disableRequiredFieldValidation(Boolean disableRequiredFieldValidation) {
    this.disableRequiredFieldValidation = disableRequiredFieldValidation;
    return this;
  }

  /**
   * Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
   * @return disableRequiredFieldValidation
   */
  @javax.annotation.Nullable
  public Boolean getDisableRequiredFieldValidation() {
    return disableRequiredFieldValidation;
  }

  public void setDisableRequiredFieldValidation(Boolean disableRequiredFieldValidation) {
    this.disableRequiredFieldValidation = disableRequiredFieldValidation;
  }


  public ValidationConfig enabledImplementationGuides(List<String> enabledImplementationGuides) {
    this.enabledImplementationGuides = enabledImplementationGuides;
    return this;
  }

  public ValidationConfig addEnabledImplementationGuidesItem(String enabledImplementationGuidesItem) {
    if (this.enabledImplementationGuides == null) {
      this.enabledImplementationGuides = new ArrayList<>();
    }
    this.enabledImplementationGuides.add(enabledImplementationGuidesItem);
    return this;
  }

  /**
   * A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set &#x60;enabled_implementation_guides&#x60; to &#x60;[\&quot;http://hl7.org/fhir/us/core/ImplementationGuide/ig\&quot;]&#x60;. If &#x60;enabled_implementation_guides&#x60; is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the &#x60;global&#x60; property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using \&quot;value\&quot; as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
   * @return enabledImplementationGuides
   */
  @javax.annotation.Nullable
  public List<String> getEnabledImplementationGuides() {
    return enabledImplementationGuides;
  }

  public void setEnabledImplementationGuides(List<String> enabledImplementationGuides) {
    this.enabledImplementationGuides = enabledImplementationGuides;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValidationConfig validationConfig = (ValidationConfig) o;
    return Objects.equals(this.disableFhirpathValidation, validationConfig.disableFhirpathValidation) &&
        Objects.equals(this.disableProfileValidation, validationConfig.disableProfileValidation) &&
        Objects.equals(this.disableReferenceTypeValidation, validationConfig.disableReferenceTypeValidation) &&
        Objects.equals(this.disableRequiredFieldValidation, validationConfig.disableRequiredFieldValidation) &&
        Objects.equals(this.enabledImplementationGuides, validationConfig.enabledImplementationGuides);
  }

  @Override
  public int hashCode() {
    return Objects.hash(disableFhirpathValidation, disableProfileValidation, disableReferenceTypeValidation, disableRequiredFieldValidation, enabledImplementationGuides);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValidationConfig {\n");
    sb.append("    disableFhirpathValidation: ").append(toIndentedString(disableFhirpathValidation)).append("\n");
    sb.append("    disableProfileValidation: ").append(toIndentedString(disableProfileValidation)).append("\n");
    sb.append("    disableReferenceTypeValidation: ").append(toIndentedString(disableReferenceTypeValidation)).append("\n");
    sb.append("    disableRequiredFieldValidation: ").append(toIndentedString(disableRequiredFieldValidation)).append("\n");
    sb.append("    enabledImplementationGuides: ").append(toIndentedString(enabledImplementationGuides)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("disableFhirpathValidation");
    openapiFields.add("disableProfileValidation");
    openapiFields.add("disableReferenceTypeValidation");
    openapiFields.add("disableRequiredFieldValidation");
    openapiFields.add("enabledImplementationGuides");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ValidationConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ValidationConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ValidationConfig is not found in the empty JSON string", ValidationConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ValidationConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ValidationConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("enabledImplementationGuides") != null && !jsonObj.get("enabledImplementationGuides").isJsonNull() && !jsonObj.get("enabledImplementationGuides").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `enabledImplementationGuides` to be an array in the JSON string but got `%s`", jsonObj.get("enabledImplementationGuides").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ValidationConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ValidationConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ValidationConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ValidationConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ValidationConfig>() {
           @Override
           public void write(JsonWriter out, ValidationConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ValidationConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ValidationConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ValidationConfig
   * @throws IOException if the JSON string is invalid with respect to ValidationConfig
   */
  public static ValidationConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ValidationConfig.class);
  }

  /**
   * Convert an instance of ValidationConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

