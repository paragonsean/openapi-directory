/*
 * Cloud Healthcare API
 * Manage, store, and access healthcare data in Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccessDeterminationLogConfig;
import org.openapitools.client.model.ConsentHeaderHandling;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:11.528078-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ConsentConfig {
  public static final String SERIALIZED_NAME_ACCESS_DETERMINATION_LOG_CONFIG = "accessDeterminationLogConfig";
  @SerializedName(SERIALIZED_NAME_ACCESS_DETERMINATION_LOG_CONFIG)
  private AccessDeterminationLogConfig accessDeterminationLogConfig;

  public static final String SERIALIZED_NAME_ACCESS_ENFORCED = "accessEnforced";
  @SerializedName(SERIALIZED_NAME_ACCESS_ENFORCED)
  private Boolean accessEnforced;

  public static final String SERIALIZED_NAME_CONSENT_HEADER_HANDLING = "consentHeaderHandling";
  @SerializedName(SERIALIZED_NAME_CONSENT_HEADER_HANDLING)
  private ConsentHeaderHandling consentHeaderHandling;

  public static final String SERIALIZED_NAME_ENFORCED_ADMIN_CONSENTS = "enforcedAdminConsents";
  @SerializedName(SERIALIZED_NAME_ENFORCED_ADMIN_CONSENTS)
  private List<String> enforcedAdminConsents = new ArrayList<>();

  /**
   * Required. Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
   */
  @JsonAdapter(VersionEnum.Adapter.class)
  public enum VersionEnum {
    CONSENT_ENFORCEMENT_VERSION_UNSPECIFIED("CONSENT_ENFORCEMENT_VERSION_UNSPECIFIED"),
    
    V1("V1");

    private String value;

    VersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VersionEnum fromValue(String value) {
      for (VersionEnum b : VersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private VersionEnum version;

  public ConsentConfig() {
  }

  public ConsentConfig accessDeterminationLogConfig(AccessDeterminationLogConfig accessDeterminationLogConfig) {
    this.accessDeterminationLogConfig = accessDeterminationLogConfig;
    return this;
  }

  /**
   * Get accessDeterminationLogConfig
   * @return accessDeterminationLogConfig
   */
  @javax.annotation.Nullable
  public AccessDeterminationLogConfig getAccessDeterminationLogConfig() {
    return accessDeterminationLogConfig;
  }

  public void setAccessDeterminationLogConfig(AccessDeterminationLogConfig accessDeterminationLogConfig) {
    this.accessDeterminationLogConfig = accessDeterminationLogConfig;
  }


  public ConsentConfig accessEnforced(Boolean accessEnforced) {
    this.accessEnforced = accessEnforced;
    return this;
  }

  /**
   * Optional. If set to true, when accessing FHIR resources, the consent headers will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
   * @return accessEnforced
   */
  @javax.annotation.Nullable
  public Boolean getAccessEnforced() {
    return accessEnforced;
  }

  public void setAccessEnforced(Boolean accessEnforced) {
    this.accessEnforced = accessEnforced;
  }


  public ConsentConfig consentHeaderHandling(ConsentHeaderHandling consentHeaderHandling) {
    this.consentHeaderHandling = consentHeaderHandling;
    return this;
  }

  /**
   * Get consentHeaderHandling
   * @return consentHeaderHandling
   */
  @javax.annotation.Nullable
  public ConsentHeaderHandling getConsentHeaderHandling() {
    return consentHeaderHandling;
  }

  public void setConsentHeaderHandling(ConsentHeaderHandling consentHeaderHandling) {
    this.consentHeaderHandling = consentHeaderHandling;
  }


  public ConsentConfig enforcedAdminConsents(List<String> enforcedAdminConsents) {
    this.enforcedAdminConsents = enforcedAdminConsents;
    return this;
  }

  public ConsentConfig addEnforcedAdminConsentsItem(String enforcedAdminConsentsItem) {
    if (this.enforcedAdminConsents == null) {
      this.enforcedAdminConsents = new ArrayList<>();
    }
    this.enforcedAdminConsents.add(enforcedAdminConsentsItem);
    return this;
  }

  /**
   * The versioned names of the enforced admin Consent resource(s), in the format &#x60;projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}&#x60;. For FHIR stores with &#x60;disable_resource_versioning&#x3D;true&#x60;, the format is &#x60;projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}&#x60;. This field can only be updated using ApplyAdminConsents.
   * @return enforcedAdminConsents
   */
  @javax.annotation.Nullable
  public List<String> getEnforcedAdminConsents() {
    return enforcedAdminConsents;
  }

  public void setEnforcedAdminConsents(List<String> enforcedAdminConsents) {
    this.enforcedAdminConsents = enforcedAdminConsents;
  }


  public ConsentConfig version(VersionEnum version) {
    this.version = version;
    return this;
  }

  /**
   * Required. Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
   * @return version
   */
  @javax.annotation.Nullable
  public VersionEnum getVersion() {
    return version;
  }

  public void setVersion(VersionEnum version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConsentConfig consentConfig = (ConsentConfig) o;
    return Objects.equals(this.accessDeterminationLogConfig, consentConfig.accessDeterminationLogConfig) &&
        Objects.equals(this.accessEnforced, consentConfig.accessEnforced) &&
        Objects.equals(this.consentHeaderHandling, consentConfig.consentHeaderHandling) &&
        Objects.equals(this.enforcedAdminConsents, consentConfig.enforcedAdminConsents) &&
        Objects.equals(this.version, consentConfig.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessDeterminationLogConfig, accessEnforced, consentHeaderHandling, enforcedAdminConsents, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConsentConfig {\n");
    sb.append("    accessDeterminationLogConfig: ").append(toIndentedString(accessDeterminationLogConfig)).append("\n");
    sb.append("    accessEnforced: ").append(toIndentedString(accessEnforced)).append("\n");
    sb.append("    consentHeaderHandling: ").append(toIndentedString(consentHeaderHandling)).append("\n");
    sb.append("    enforcedAdminConsents: ").append(toIndentedString(enforcedAdminConsents)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessDeterminationLogConfig");
    openapiFields.add("accessEnforced");
    openapiFields.add("consentHeaderHandling");
    openapiFields.add("enforcedAdminConsents");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConsentConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConsentConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConsentConfig is not found in the empty JSON string", ConsentConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConsentConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConsentConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `accessDeterminationLogConfig`
      if (jsonObj.get("accessDeterminationLogConfig") != null && !jsonObj.get("accessDeterminationLogConfig").isJsonNull()) {
        AccessDeterminationLogConfig.validateJsonElement(jsonObj.get("accessDeterminationLogConfig"));
      }
      // validate the optional field `consentHeaderHandling`
      if (jsonObj.get("consentHeaderHandling") != null && !jsonObj.get("consentHeaderHandling").isJsonNull()) {
        ConsentHeaderHandling.validateJsonElement(jsonObj.get("consentHeaderHandling"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("enforcedAdminConsents") != null && !jsonObj.get("enforcedAdminConsents").isJsonNull() && !jsonObj.get("enforcedAdminConsents").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `enforcedAdminConsents` to be an array in the JSON string but got `%s`", jsonObj.get("enforcedAdminConsents").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      // validate the optional field `version`
      if (jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) {
        VersionEnum.validateJsonElement(jsonObj.get("version"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConsentConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConsentConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConsentConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConsentConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ConsentConfig>() {
           @Override
           public void write(JsonWriter out, ConsentConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConsentConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConsentConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConsentConfig
   * @throws IOException if the JSON string is invalid with respect to ConsentConfig
   */
  public static ConsentConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConsentConfig.class);
  }

  /**
   * Convert an instance of ConsentConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

