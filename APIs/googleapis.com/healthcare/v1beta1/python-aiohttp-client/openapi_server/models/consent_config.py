# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.access_determination_log_config import AccessDeterminationLogConfig
from openapi_server.models.consent_header_handling import ConsentHeaderHandling
from openapi_server import util


class ConsentConfig(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, access_determination_log_config: AccessDeterminationLogConfig=None, access_enforced: bool=None, consent_header_handling: ConsentHeaderHandling=None, enforced_admin_consents: List[str]=None, version: str=None):
        """ConsentConfig - a model defined in OpenAPI

        :param access_determination_log_config: The access_determination_log_config of this ConsentConfig.
        :param access_enforced: The access_enforced of this ConsentConfig.
        :param consent_header_handling: The consent_header_handling of this ConsentConfig.
        :param enforced_admin_consents: The enforced_admin_consents of this ConsentConfig.
        :param version: The version of this ConsentConfig.
        """
        self.openapi_types = {
            'access_determination_log_config': AccessDeterminationLogConfig,
            'access_enforced': bool,
            'consent_header_handling': ConsentHeaderHandling,
            'enforced_admin_consents': List[str],
            'version': str
        }

        self.attribute_map = {
            'access_determination_log_config': 'accessDeterminationLogConfig',
            'access_enforced': 'accessEnforced',
            'consent_header_handling': 'consentHeaderHandling',
            'enforced_admin_consents': 'enforcedAdminConsents',
            'version': 'version'
        }

        self._access_determination_log_config = access_determination_log_config
        self._access_enforced = access_enforced
        self._consent_header_handling = consent_header_handling
        self._enforced_admin_consents = enforced_admin_consents
        self._version = version

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ConsentConfig':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ConsentConfig of this ConsentConfig.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def access_determination_log_config(self):
        """Gets the access_determination_log_config of this ConsentConfig.


        :return: The access_determination_log_config of this ConsentConfig.
        :rtype: AccessDeterminationLogConfig
        """
        return self._access_determination_log_config

    @access_determination_log_config.setter
    def access_determination_log_config(self, access_determination_log_config):
        """Sets the access_determination_log_config of this ConsentConfig.


        :param access_determination_log_config: The access_determination_log_config of this ConsentConfig.
        :type access_determination_log_config: AccessDeterminationLogConfig
        """

        self._access_determination_log_config = access_determination_log_config

    @property
    def access_enforced(self):
        """Gets the access_enforced of this ConsentConfig.

        Optional. If set to true, when accessing FHIR resources, the consent headers will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.

        :return: The access_enforced of this ConsentConfig.
        :rtype: bool
        """
        return self._access_enforced

    @access_enforced.setter
    def access_enforced(self, access_enforced):
        """Sets the access_enforced of this ConsentConfig.

        Optional. If set to true, when accessing FHIR resources, the consent headers will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.

        :param access_enforced: The access_enforced of this ConsentConfig.
        :type access_enforced: bool
        """

        self._access_enforced = access_enforced

    @property
    def consent_header_handling(self):
        """Gets the consent_header_handling of this ConsentConfig.


        :return: The consent_header_handling of this ConsentConfig.
        :rtype: ConsentHeaderHandling
        """
        return self._consent_header_handling

    @consent_header_handling.setter
    def consent_header_handling(self, consent_header_handling):
        """Sets the consent_header_handling of this ConsentConfig.


        :param consent_header_handling: The consent_header_handling of this ConsentConfig.
        :type consent_header_handling: ConsentHeaderHandling
        """

        self._consent_header_handling = consent_header_handling

    @property
    def enforced_admin_consents(self):
        """Gets the enforced_admin_consents of this ConsentConfig.

        The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.

        :return: The enforced_admin_consents of this ConsentConfig.
        :rtype: List[str]
        """
        return self._enforced_admin_consents

    @enforced_admin_consents.setter
    def enforced_admin_consents(self, enforced_admin_consents):
        """Sets the enforced_admin_consents of this ConsentConfig.

        The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.

        :param enforced_admin_consents: The enforced_admin_consents of this ConsentConfig.
        :type enforced_admin_consents: List[str]
        """

        self._enforced_admin_consents = enforced_admin_consents

    @property
    def version(self):
        """Gets the version of this ConsentConfig.

        Required. Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.

        :return: The version of this ConsentConfig.
        :rtype: str
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this ConsentConfig.

        Required. Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.

        :param version: The version of this ConsentConfig.
        :type version: str
        """
        allowed_values = ["CONSENT_ENFORCEMENT_VERSION_UNSPECIFIED", "V1"]  # noqa: E501
        if version not in allowed_values:
            raise ValueError(
                "Invalid value for `version` ({0}), must be one of {1}"
                .format(version, allowed_values)
            )

        self._version = version
