/**
 * Books API
 * The Google Books API allows clients to access the Google Books repository.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVolume_userInfo.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVolume_userInfo::OAIVolume_userInfo(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVolume_userInfo::OAIVolume_userInfo() {
    this->initializeModel();
}

OAIVolume_userInfo::~OAIVolume_userInfo() {}

void OAIVolume_userInfo::initializeModel() {

    m_acquired_time_isSet = false;
    m_acquired_time_isValid = false;

    m_acquisition_type_isSet = false;
    m_acquisition_type_isValid = false;

    m_copy_isSet = false;
    m_copy_isValid = false;

    m_entitlement_type_isSet = false;
    m_entitlement_type_isValid = false;

    m_family_sharing_isSet = false;
    m_family_sharing_isValid = false;

    m_is_family_shared_from_user_isSet = false;
    m_is_family_shared_from_user_isValid = false;

    m_is_family_shared_to_user_isSet = false;
    m_is_family_shared_to_user_isValid = false;

    m_is_family_sharing_allowed_isSet = false;
    m_is_family_sharing_allowed_isValid = false;

    m_is_family_sharing_disabled_by_fop_isSet = false;
    m_is_family_sharing_disabled_by_fop_isValid = false;

    m_is_in_my_books_isSet = false;
    m_is_in_my_books_isValid = false;

    m_is_preordered_isSet = false;
    m_is_preordered_isValid = false;

    m_is_purchased_isSet = false;
    m_is_purchased_isValid = false;

    m_is_uploaded_isSet = false;
    m_is_uploaded_isValid = false;

    m_reading_position_isSet = false;
    m_reading_position_isValid = false;

    m_rental_period_isSet = false;
    m_rental_period_isValid = false;

    m_rental_state_isSet = false;
    m_rental_state_isValid = false;

    m_review_isSet = false;
    m_review_isValid = false;

    m_updated_isSet = false;
    m_updated_isValid = false;

    m_user_uploaded_volume_info_isSet = false;
    m_user_uploaded_volume_info_isValid = false;
}

void OAIVolume_userInfo::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVolume_userInfo::fromJsonObject(QJsonObject json) {

    m_acquired_time_isValid = ::OpenAPI::fromJsonValue(m_acquired_time, json[QString("acquiredTime")]);
    m_acquired_time_isSet = !json[QString("acquiredTime")].isNull() && m_acquired_time_isValid;

    m_acquisition_type_isValid = ::OpenAPI::fromJsonValue(m_acquisition_type, json[QString("acquisitionType")]);
    m_acquisition_type_isSet = !json[QString("acquisitionType")].isNull() && m_acquisition_type_isValid;

    m_copy_isValid = ::OpenAPI::fromJsonValue(m_copy, json[QString("copy")]);
    m_copy_isSet = !json[QString("copy")].isNull() && m_copy_isValid;

    m_entitlement_type_isValid = ::OpenAPI::fromJsonValue(m_entitlement_type, json[QString("entitlementType")]);
    m_entitlement_type_isSet = !json[QString("entitlementType")].isNull() && m_entitlement_type_isValid;

    m_family_sharing_isValid = ::OpenAPI::fromJsonValue(m_family_sharing, json[QString("familySharing")]);
    m_family_sharing_isSet = !json[QString("familySharing")].isNull() && m_family_sharing_isValid;

    m_is_family_shared_from_user_isValid = ::OpenAPI::fromJsonValue(m_is_family_shared_from_user, json[QString("isFamilySharedFromUser")]);
    m_is_family_shared_from_user_isSet = !json[QString("isFamilySharedFromUser")].isNull() && m_is_family_shared_from_user_isValid;

    m_is_family_shared_to_user_isValid = ::OpenAPI::fromJsonValue(m_is_family_shared_to_user, json[QString("isFamilySharedToUser")]);
    m_is_family_shared_to_user_isSet = !json[QString("isFamilySharedToUser")].isNull() && m_is_family_shared_to_user_isValid;

    m_is_family_sharing_allowed_isValid = ::OpenAPI::fromJsonValue(m_is_family_sharing_allowed, json[QString("isFamilySharingAllowed")]);
    m_is_family_sharing_allowed_isSet = !json[QString("isFamilySharingAllowed")].isNull() && m_is_family_sharing_allowed_isValid;

    m_is_family_sharing_disabled_by_fop_isValid = ::OpenAPI::fromJsonValue(m_is_family_sharing_disabled_by_fop, json[QString("isFamilySharingDisabledByFop")]);
    m_is_family_sharing_disabled_by_fop_isSet = !json[QString("isFamilySharingDisabledByFop")].isNull() && m_is_family_sharing_disabled_by_fop_isValid;

    m_is_in_my_books_isValid = ::OpenAPI::fromJsonValue(m_is_in_my_books, json[QString("isInMyBooks")]);
    m_is_in_my_books_isSet = !json[QString("isInMyBooks")].isNull() && m_is_in_my_books_isValid;

    m_is_preordered_isValid = ::OpenAPI::fromJsonValue(m_is_preordered, json[QString("isPreordered")]);
    m_is_preordered_isSet = !json[QString("isPreordered")].isNull() && m_is_preordered_isValid;

    m_is_purchased_isValid = ::OpenAPI::fromJsonValue(m_is_purchased, json[QString("isPurchased")]);
    m_is_purchased_isSet = !json[QString("isPurchased")].isNull() && m_is_purchased_isValid;

    m_is_uploaded_isValid = ::OpenAPI::fromJsonValue(m_is_uploaded, json[QString("isUploaded")]);
    m_is_uploaded_isSet = !json[QString("isUploaded")].isNull() && m_is_uploaded_isValid;

    m_reading_position_isValid = ::OpenAPI::fromJsonValue(m_reading_position, json[QString("readingPosition")]);
    m_reading_position_isSet = !json[QString("readingPosition")].isNull() && m_reading_position_isValid;

    m_rental_period_isValid = ::OpenAPI::fromJsonValue(m_rental_period, json[QString("rentalPeriod")]);
    m_rental_period_isSet = !json[QString("rentalPeriod")].isNull() && m_rental_period_isValid;

    m_rental_state_isValid = ::OpenAPI::fromJsonValue(m_rental_state, json[QString("rentalState")]);
    m_rental_state_isSet = !json[QString("rentalState")].isNull() && m_rental_state_isValid;

    m_review_isValid = ::OpenAPI::fromJsonValue(m_review, json[QString("review")]);
    m_review_isSet = !json[QString("review")].isNull() && m_review_isValid;

    m_updated_isValid = ::OpenAPI::fromJsonValue(m_updated, json[QString("updated")]);
    m_updated_isSet = !json[QString("updated")].isNull() && m_updated_isValid;

    m_user_uploaded_volume_info_isValid = ::OpenAPI::fromJsonValue(m_user_uploaded_volume_info, json[QString("userUploadedVolumeInfo")]);
    m_user_uploaded_volume_info_isSet = !json[QString("userUploadedVolumeInfo")].isNull() && m_user_uploaded_volume_info_isValid;
}

QString OAIVolume_userInfo::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVolume_userInfo::asJsonObject() const {
    QJsonObject obj;
    if (m_acquired_time_isSet) {
        obj.insert(QString("acquiredTime"), ::OpenAPI::toJsonValue(m_acquired_time));
    }
    if (m_acquisition_type_isSet) {
        obj.insert(QString("acquisitionType"), ::OpenAPI::toJsonValue(m_acquisition_type));
    }
    if (m_copy.isSet()) {
        obj.insert(QString("copy"), ::OpenAPI::toJsonValue(m_copy));
    }
    if (m_entitlement_type_isSet) {
        obj.insert(QString("entitlementType"), ::OpenAPI::toJsonValue(m_entitlement_type));
    }
    if (m_family_sharing.isSet()) {
        obj.insert(QString("familySharing"), ::OpenAPI::toJsonValue(m_family_sharing));
    }
    if (m_is_family_shared_from_user_isSet) {
        obj.insert(QString("isFamilySharedFromUser"), ::OpenAPI::toJsonValue(m_is_family_shared_from_user));
    }
    if (m_is_family_shared_to_user_isSet) {
        obj.insert(QString("isFamilySharedToUser"), ::OpenAPI::toJsonValue(m_is_family_shared_to_user));
    }
    if (m_is_family_sharing_allowed_isSet) {
        obj.insert(QString("isFamilySharingAllowed"), ::OpenAPI::toJsonValue(m_is_family_sharing_allowed));
    }
    if (m_is_family_sharing_disabled_by_fop_isSet) {
        obj.insert(QString("isFamilySharingDisabledByFop"), ::OpenAPI::toJsonValue(m_is_family_sharing_disabled_by_fop));
    }
    if (m_is_in_my_books_isSet) {
        obj.insert(QString("isInMyBooks"), ::OpenAPI::toJsonValue(m_is_in_my_books));
    }
    if (m_is_preordered_isSet) {
        obj.insert(QString("isPreordered"), ::OpenAPI::toJsonValue(m_is_preordered));
    }
    if (m_is_purchased_isSet) {
        obj.insert(QString("isPurchased"), ::OpenAPI::toJsonValue(m_is_purchased));
    }
    if (m_is_uploaded_isSet) {
        obj.insert(QString("isUploaded"), ::OpenAPI::toJsonValue(m_is_uploaded));
    }
    if (m_reading_position.isSet()) {
        obj.insert(QString("readingPosition"), ::OpenAPI::toJsonValue(m_reading_position));
    }
    if (m_rental_period.isSet()) {
        obj.insert(QString("rentalPeriod"), ::OpenAPI::toJsonValue(m_rental_period));
    }
    if (m_rental_state_isSet) {
        obj.insert(QString("rentalState"), ::OpenAPI::toJsonValue(m_rental_state));
    }
    if (m_review.isSet()) {
        obj.insert(QString("review"), ::OpenAPI::toJsonValue(m_review));
    }
    if (m_updated_isSet) {
        obj.insert(QString("updated"), ::OpenAPI::toJsonValue(m_updated));
    }
    if (m_user_uploaded_volume_info.isSet()) {
        obj.insert(QString("userUploadedVolumeInfo"), ::OpenAPI::toJsonValue(m_user_uploaded_volume_info));
    }
    return obj;
}

QString OAIVolume_userInfo::getAcquiredTime() const {
    return m_acquired_time;
}
void OAIVolume_userInfo::setAcquiredTime(const QString &acquired_time) {
    m_acquired_time = acquired_time;
    m_acquired_time_isSet = true;
}

bool OAIVolume_userInfo::is_acquired_time_Set() const{
    return m_acquired_time_isSet;
}

bool OAIVolume_userInfo::is_acquired_time_Valid() const{
    return m_acquired_time_isValid;
}

qint32 OAIVolume_userInfo::getAcquisitionType() const {
    return m_acquisition_type;
}
void OAIVolume_userInfo::setAcquisitionType(const qint32 &acquisition_type) {
    m_acquisition_type = acquisition_type;
    m_acquisition_type_isSet = true;
}

bool OAIVolume_userInfo::is_acquisition_type_Set() const{
    return m_acquisition_type_isSet;
}

bool OAIVolume_userInfo::is_acquisition_type_Valid() const{
    return m_acquisition_type_isValid;
}

OAIVolume_userInfo_copy OAIVolume_userInfo::getCopy() const {
    return m_copy;
}
void OAIVolume_userInfo::setCopy(const OAIVolume_userInfo_copy &copy) {
    m_copy = copy;
    m_copy_isSet = true;
}

bool OAIVolume_userInfo::is_copy_Set() const{
    return m_copy_isSet;
}

bool OAIVolume_userInfo::is_copy_Valid() const{
    return m_copy_isValid;
}

qint32 OAIVolume_userInfo::getEntitlementType() const {
    return m_entitlement_type;
}
void OAIVolume_userInfo::setEntitlementType(const qint32 &entitlement_type) {
    m_entitlement_type = entitlement_type;
    m_entitlement_type_isSet = true;
}

bool OAIVolume_userInfo::is_entitlement_type_Set() const{
    return m_entitlement_type_isSet;
}

bool OAIVolume_userInfo::is_entitlement_type_Valid() const{
    return m_entitlement_type_isValid;
}

OAIVolume_userInfo_familySharing OAIVolume_userInfo::getFamilySharing() const {
    return m_family_sharing;
}
void OAIVolume_userInfo::setFamilySharing(const OAIVolume_userInfo_familySharing &family_sharing) {
    m_family_sharing = family_sharing;
    m_family_sharing_isSet = true;
}

bool OAIVolume_userInfo::is_family_sharing_Set() const{
    return m_family_sharing_isSet;
}

bool OAIVolume_userInfo::is_family_sharing_Valid() const{
    return m_family_sharing_isValid;
}

bool OAIVolume_userInfo::isIsFamilySharedFromUser() const {
    return m_is_family_shared_from_user;
}
void OAIVolume_userInfo::setIsFamilySharedFromUser(const bool &is_family_shared_from_user) {
    m_is_family_shared_from_user = is_family_shared_from_user;
    m_is_family_shared_from_user_isSet = true;
}

bool OAIVolume_userInfo::is_is_family_shared_from_user_Set() const{
    return m_is_family_shared_from_user_isSet;
}

bool OAIVolume_userInfo::is_is_family_shared_from_user_Valid() const{
    return m_is_family_shared_from_user_isValid;
}

bool OAIVolume_userInfo::isIsFamilySharedToUser() const {
    return m_is_family_shared_to_user;
}
void OAIVolume_userInfo::setIsFamilySharedToUser(const bool &is_family_shared_to_user) {
    m_is_family_shared_to_user = is_family_shared_to_user;
    m_is_family_shared_to_user_isSet = true;
}

bool OAIVolume_userInfo::is_is_family_shared_to_user_Set() const{
    return m_is_family_shared_to_user_isSet;
}

bool OAIVolume_userInfo::is_is_family_shared_to_user_Valid() const{
    return m_is_family_shared_to_user_isValid;
}

bool OAIVolume_userInfo::isIsFamilySharingAllowed() const {
    return m_is_family_sharing_allowed;
}
void OAIVolume_userInfo::setIsFamilySharingAllowed(const bool &is_family_sharing_allowed) {
    m_is_family_sharing_allowed = is_family_sharing_allowed;
    m_is_family_sharing_allowed_isSet = true;
}

bool OAIVolume_userInfo::is_is_family_sharing_allowed_Set() const{
    return m_is_family_sharing_allowed_isSet;
}

bool OAIVolume_userInfo::is_is_family_sharing_allowed_Valid() const{
    return m_is_family_sharing_allowed_isValid;
}

bool OAIVolume_userInfo::isIsFamilySharingDisabledByFop() const {
    return m_is_family_sharing_disabled_by_fop;
}
void OAIVolume_userInfo::setIsFamilySharingDisabledByFop(const bool &is_family_sharing_disabled_by_fop) {
    m_is_family_sharing_disabled_by_fop = is_family_sharing_disabled_by_fop;
    m_is_family_sharing_disabled_by_fop_isSet = true;
}

bool OAIVolume_userInfo::is_is_family_sharing_disabled_by_fop_Set() const{
    return m_is_family_sharing_disabled_by_fop_isSet;
}

bool OAIVolume_userInfo::is_is_family_sharing_disabled_by_fop_Valid() const{
    return m_is_family_sharing_disabled_by_fop_isValid;
}

bool OAIVolume_userInfo::isIsInMyBooks() const {
    return m_is_in_my_books;
}
void OAIVolume_userInfo::setIsInMyBooks(const bool &is_in_my_books) {
    m_is_in_my_books = is_in_my_books;
    m_is_in_my_books_isSet = true;
}

bool OAIVolume_userInfo::is_is_in_my_books_Set() const{
    return m_is_in_my_books_isSet;
}

bool OAIVolume_userInfo::is_is_in_my_books_Valid() const{
    return m_is_in_my_books_isValid;
}

bool OAIVolume_userInfo::isIsPreordered() const {
    return m_is_preordered;
}
void OAIVolume_userInfo::setIsPreordered(const bool &is_preordered) {
    m_is_preordered = is_preordered;
    m_is_preordered_isSet = true;
}

bool OAIVolume_userInfo::is_is_preordered_Set() const{
    return m_is_preordered_isSet;
}

bool OAIVolume_userInfo::is_is_preordered_Valid() const{
    return m_is_preordered_isValid;
}

bool OAIVolume_userInfo::isIsPurchased() const {
    return m_is_purchased;
}
void OAIVolume_userInfo::setIsPurchased(const bool &is_purchased) {
    m_is_purchased = is_purchased;
    m_is_purchased_isSet = true;
}

bool OAIVolume_userInfo::is_is_purchased_Set() const{
    return m_is_purchased_isSet;
}

bool OAIVolume_userInfo::is_is_purchased_Valid() const{
    return m_is_purchased_isValid;
}

bool OAIVolume_userInfo::isIsUploaded() const {
    return m_is_uploaded;
}
void OAIVolume_userInfo::setIsUploaded(const bool &is_uploaded) {
    m_is_uploaded = is_uploaded;
    m_is_uploaded_isSet = true;
}

bool OAIVolume_userInfo::is_is_uploaded_Set() const{
    return m_is_uploaded_isSet;
}

bool OAIVolume_userInfo::is_is_uploaded_Valid() const{
    return m_is_uploaded_isValid;
}

OAIReadingPosition OAIVolume_userInfo::getReadingPosition() const {
    return m_reading_position;
}
void OAIVolume_userInfo::setReadingPosition(const OAIReadingPosition &reading_position) {
    m_reading_position = reading_position;
    m_reading_position_isSet = true;
}

bool OAIVolume_userInfo::is_reading_position_Set() const{
    return m_reading_position_isSet;
}

bool OAIVolume_userInfo::is_reading_position_Valid() const{
    return m_reading_position_isValid;
}

OAIVolume_userInfo_rentalPeriod OAIVolume_userInfo::getRentalPeriod() const {
    return m_rental_period;
}
void OAIVolume_userInfo::setRentalPeriod(const OAIVolume_userInfo_rentalPeriod &rental_period) {
    m_rental_period = rental_period;
    m_rental_period_isSet = true;
}

bool OAIVolume_userInfo::is_rental_period_Set() const{
    return m_rental_period_isSet;
}

bool OAIVolume_userInfo::is_rental_period_Valid() const{
    return m_rental_period_isValid;
}

QString OAIVolume_userInfo::getRentalState() const {
    return m_rental_state;
}
void OAIVolume_userInfo::setRentalState(const QString &rental_state) {
    m_rental_state = rental_state;
    m_rental_state_isSet = true;
}

bool OAIVolume_userInfo::is_rental_state_Set() const{
    return m_rental_state_isSet;
}

bool OAIVolume_userInfo::is_rental_state_Valid() const{
    return m_rental_state_isValid;
}

OAIReview OAIVolume_userInfo::getReview() const {
    return m_review;
}
void OAIVolume_userInfo::setReview(const OAIReview &review) {
    m_review = review;
    m_review_isSet = true;
}

bool OAIVolume_userInfo::is_review_Set() const{
    return m_review_isSet;
}

bool OAIVolume_userInfo::is_review_Valid() const{
    return m_review_isValid;
}

QString OAIVolume_userInfo::getUpdated() const {
    return m_updated;
}
void OAIVolume_userInfo::setUpdated(const QString &updated) {
    m_updated = updated;
    m_updated_isSet = true;
}

bool OAIVolume_userInfo::is_updated_Set() const{
    return m_updated_isSet;
}

bool OAIVolume_userInfo::is_updated_Valid() const{
    return m_updated_isValid;
}

OAIVolume_userInfo_userUploadedVolumeInfo OAIVolume_userInfo::getUserUploadedVolumeInfo() const {
    return m_user_uploaded_volume_info;
}
void OAIVolume_userInfo::setUserUploadedVolumeInfo(const OAIVolume_userInfo_userUploadedVolumeInfo &user_uploaded_volume_info) {
    m_user_uploaded_volume_info = user_uploaded_volume_info;
    m_user_uploaded_volume_info_isSet = true;
}

bool OAIVolume_userInfo::is_user_uploaded_volume_info_Set() const{
    return m_user_uploaded_volume_info_isSet;
}

bool OAIVolume_userInfo::is_user_uploaded_volume_info_Valid() const{
    return m_user_uploaded_volume_info_isValid;
}

bool OAIVolume_userInfo::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_acquired_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_acquisition_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_copy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_entitlement_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_family_sharing.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_family_shared_from_user_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_family_shared_to_user_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_family_sharing_allowed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_family_sharing_disabled_by_fop_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_in_my_books_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_preordered_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_purchased_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_uploaded_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reading_position.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rental_period.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rental_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_review.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_uploaded_volume_info.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVolume_userInfo::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
