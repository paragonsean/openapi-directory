/*
 * Access Approval API
 * An API for controlling access to data by Google personnel.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.EnrolledService;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings on a Project/Folder/Organization related to Access Approval.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:17.320881-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AccessApprovalSettings {
  public static final String SERIALIZED_NAME_ACTIVE_KEY_VERSION = "activeKeyVersion";
  @SerializedName(SERIALIZED_NAME_ACTIVE_KEY_VERSION)
  private String activeKeyVersion;

  public static final String SERIALIZED_NAME_ANCESTOR_HAS_ACTIVE_KEY_VERSION = "ancestorHasActiveKeyVersion";
  @SerializedName(SERIALIZED_NAME_ANCESTOR_HAS_ACTIVE_KEY_VERSION)
  private Boolean ancestorHasActiveKeyVersion;

  public static final String SERIALIZED_NAME_ENROLLED_ANCESTOR = "enrolledAncestor";
  @SerializedName(SERIALIZED_NAME_ENROLLED_ANCESTOR)
  private Boolean enrolledAncestor;

  public static final String SERIALIZED_NAME_ENROLLED_SERVICES = "enrolledServices";
  @SerializedName(SERIALIZED_NAME_ENROLLED_SERVICES)
  private List<EnrolledService> enrolledServices = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVALID_KEY_VERSION = "invalidKeyVersion";
  @SerializedName(SERIALIZED_NAME_INVALID_KEY_VERSION)
  private Boolean invalidKeyVersion;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NOTIFICATION_EMAILS = "notificationEmails";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_EMAILS)
  private List<String> notificationEmails = new ArrayList<>();

  public static final String SERIALIZED_NAME_NOTIFICATION_PUBSUB_TOPIC = "notificationPubsubTopic";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_PUBSUB_TOPIC)
  private String notificationPubsubTopic;

  public static final String SERIALIZED_NAME_PREFER_NO_BROAD_APPROVAL_REQUESTS = "preferNoBroadApprovalRequests";
  @SerializedName(SERIALIZED_NAME_PREFER_NO_BROAD_APPROVAL_REQUESTS)
  private Boolean preferNoBroadApprovalRequests;

  public static final String SERIALIZED_NAME_PREFERRED_REQUEST_EXPIRATION_DAYS = "preferredRequestExpirationDays";
  @SerializedName(SERIALIZED_NAME_PREFERRED_REQUEST_EXPIRATION_DAYS)
  private Integer preferredRequestExpirationDays;

  public AccessApprovalSettings() {
  }

  public AccessApprovalSettings(
     Boolean ancestorHasActiveKeyVersion, 
     Boolean enrolledAncestor, 
     Boolean invalidKeyVersion
  ) {
    this();
    this.ancestorHasActiveKeyVersion = ancestorHasActiveKeyVersion;
    this.enrolledAncestor = enrolledAncestor;
    this.invalidKeyVersion = invalidKeyVersion;
  }

  public AccessApprovalSettings activeKeyVersion(String activeKeyVersion) {
    this.activeKeyVersion = activeKeyVersion;
    return this;
  }

  /**
   * The asymmetric crypto key version to use for signing approval requests. Empty active_key_version indicates that a Google-managed key should be used for signing. This property will be ignored if set by an ancestor of this resource, and new non-empty values may not be set.
   * @return activeKeyVersion
   */
  @javax.annotation.Nullable
  public String getActiveKeyVersion() {
    return activeKeyVersion;
  }

  public void setActiveKeyVersion(String activeKeyVersion) {
    this.activeKeyVersion = activeKeyVersion;
  }


  /**
   * Output only. This field is read only (not settable via UpdateAccessApprovalSettings method). If the field is true, that indicates that an ancestor of this Project or Folder has set active_key_version (this field will always be unset for the organization since organizations do not have ancestors).
   * @return ancestorHasActiveKeyVersion
   */
  @javax.annotation.Nullable
  public Boolean getAncestorHasActiveKeyVersion() {
    return ancestorHasActiveKeyVersion;
  }



  /**
   * Output only. This field is read only (not settable via UpdateAccessApprovalSettings method). If the field is true, that indicates that at least one service is enrolled for Access Approval in one or more ancestors of the Project or Folder (this field will always be unset for the organization since organizations do not have ancestors).
   * @return enrolledAncestor
   */
  @javax.annotation.Nullable
  public Boolean getEnrolledAncestor() {
    return enrolledAncestor;
  }



  public AccessApprovalSettings enrolledServices(List<EnrolledService> enrolledServices) {
    this.enrolledServices = enrolledServices;
    return this;
  }

  public AccessApprovalSettings addEnrolledServicesItem(EnrolledService enrolledServicesItem) {
    if (this.enrolledServices == null) {
      this.enrolledServices = new ArrayList<>();
    }
    this.enrolledServices.add(enrolledServicesItem);
    return this;
  }

  /**
   * A list of Google Cloud Services for which the given resource has Access Approval enrolled. Access requests for the resource given by name against any of these services contained here will be required to have explicit approval. If name refers to an organization, enrollment can be done for individual services. If name refers to a folder or project, enrollment can only be done on an all or nothing basis. If a cloud_product is repeated in this list, the first entry will be honored and all following entries will be discarded. A maximum of 10 enrolled services will be enforced, to be expanded as the set of supported services is expanded.
   * @return enrolledServices
   */
  @javax.annotation.Nullable
  public List<EnrolledService> getEnrolledServices() {
    return enrolledServices;
  }

  public void setEnrolledServices(List<EnrolledService> enrolledServices) {
    this.enrolledServices = enrolledServices;
  }


  /**
   * Output only. This field is read only (not settable via UpdateAccessApprovalSettings method). If the field is true, that indicates that there is some configuration issue with the active_key_version configured at this level in the resource hierarchy (e.g. it doesn&#39;t exist or the Access Approval service account doesn&#39;t have the correct permissions on it, etc.) This key version is not necessarily the effective key version at this level, as key versions are inherited top-down.
   * @return invalidKeyVersion
   */
  @javax.annotation.Nullable
  public Boolean getInvalidKeyVersion() {
    return invalidKeyVersion;
  }



  public AccessApprovalSettings name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The resource name of the settings. Format is one of: * \&quot;projects/{project}/accessApprovalSettings\&quot; * \&quot;folders/{folder}/accessApprovalSettings\&quot; * \&quot;organizations/{organization}/accessApprovalSettings\&quot;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public AccessApprovalSettings notificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
    return this;
  }

  public AccessApprovalSettings addNotificationEmailsItem(String notificationEmailsItem) {
    if (this.notificationEmails == null) {
      this.notificationEmails = new ArrayList<>();
    }
    this.notificationEmails.add(notificationEmailsItem);
    return this;
  }

  /**
   * A list of email addresses to which notifications relating to approval requests should be sent. Notifications relating to a resource will be sent to all emails in the settings of ancestor resources of that resource. A maximum of 50 email addresses are allowed.
   * @return notificationEmails
   */
  @javax.annotation.Nullable
  public List<String> getNotificationEmails() {
    return notificationEmails;
  }

  public void setNotificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
  }


  public AccessApprovalSettings notificationPubsubTopic(String notificationPubsubTopic) {
    this.notificationPubsubTopic = notificationPubsubTopic;
    return this;
  }

  /**
   * Optional. A pubsub topic to which notifications relating to approval requests should be sent.
   * @return notificationPubsubTopic
   */
  @javax.annotation.Nullable
  public String getNotificationPubsubTopic() {
    return notificationPubsubTopic;
  }

  public void setNotificationPubsubTopic(String notificationPubsubTopic) {
    this.notificationPubsubTopic = notificationPubsubTopic;
  }


  public AccessApprovalSettings preferNoBroadApprovalRequests(Boolean preferNoBroadApprovalRequests) {
    this.preferNoBroadApprovalRequests = preferNoBroadApprovalRequests;
    return this;
  }

  /**
   * This preference is communicated to Google personnel when sending an approval request but can be overridden if necessary.
   * @return preferNoBroadApprovalRequests
   */
  @javax.annotation.Nullable
  public Boolean getPreferNoBroadApprovalRequests() {
    return preferNoBroadApprovalRequests;
  }

  public void setPreferNoBroadApprovalRequests(Boolean preferNoBroadApprovalRequests) {
    this.preferNoBroadApprovalRequests = preferNoBroadApprovalRequests;
  }


  public AccessApprovalSettings preferredRequestExpirationDays(Integer preferredRequestExpirationDays) {
    this.preferredRequestExpirationDays = preferredRequestExpirationDays;
    return this;
  }

  /**
   * This preference is shared with Google personnel, but can be overridden if said personnel deems necessary. The approver ultimately can set the expiration at approval time.
   * @return preferredRequestExpirationDays
   */
  @javax.annotation.Nullable
  public Integer getPreferredRequestExpirationDays() {
    return preferredRequestExpirationDays;
  }

  public void setPreferredRequestExpirationDays(Integer preferredRequestExpirationDays) {
    this.preferredRequestExpirationDays = preferredRequestExpirationDays;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccessApprovalSettings accessApprovalSettings = (AccessApprovalSettings) o;
    return Objects.equals(this.activeKeyVersion, accessApprovalSettings.activeKeyVersion) &&
        Objects.equals(this.ancestorHasActiveKeyVersion, accessApprovalSettings.ancestorHasActiveKeyVersion) &&
        Objects.equals(this.enrolledAncestor, accessApprovalSettings.enrolledAncestor) &&
        Objects.equals(this.enrolledServices, accessApprovalSettings.enrolledServices) &&
        Objects.equals(this.invalidKeyVersion, accessApprovalSettings.invalidKeyVersion) &&
        Objects.equals(this.name, accessApprovalSettings.name) &&
        Objects.equals(this.notificationEmails, accessApprovalSettings.notificationEmails) &&
        Objects.equals(this.notificationPubsubTopic, accessApprovalSettings.notificationPubsubTopic) &&
        Objects.equals(this.preferNoBroadApprovalRequests, accessApprovalSettings.preferNoBroadApprovalRequests) &&
        Objects.equals(this.preferredRequestExpirationDays, accessApprovalSettings.preferredRequestExpirationDays);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeKeyVersion, ancestorHasActiveKeyVersion, enrolledAncestor, enrolledServices, invalidKeyVersion, name, notificationEmails, notificationPubsubTopic, preferNoBroadApprovalRequests, preferredRequestExpirationDays);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccessApprovalSettings {\n");
    sb.append("    activeKeyVersion: ").append(toIndentedString(activeKeyVersion)).append("\n");
    sb.append("    ancestorHasActiveKeyVersion: ").append(toIndentedString(ancestorHasActiveKeyVersion)).append("\n");
    sb.append("    enrolledAncestor: ").append(toIndentedString(enrolledAncestor)).append("\n");
    sb.append("    enrolledServices: ").append(toIndentedString(enrolledServices)).append("\n");
    sb.append("    invalidKeyVersion: ").append(toIndentedString(invalidKeyVersion)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notificationEmails: ").append(toIndentedString(notificationEmails)).append("\n");
    sb.append("    notificationPubsubTopic: ").append(toIndentedString(notificationPubsubTopic)).append("\n");
    sb.append("    preferNoBroadApprovalRequests: ").append(toIndentedString(preferNoBroadApprovalRequests)).append("\n");
    sb.append("    preferredRequestExpirationDays: ").append(toIndentedString(preferredRequestExpirationDays)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activeKeyVersion");
    openapiFields.add("ancestorHasActiveKeyVersion");
    openapiFields.add("enrolledAncestor");
    openapiFields.add("enrolledServices");
    openapiFields.add("invalidKeyVersion");
    openapiFields.add("name");
    openapiFields.add("notificationEmails");
    openapiFields.add("notificationPubsubTopic");
    openapiFields.add("preferNoBroadApprovalRequests");
    openapiFields.add("preferredRequestExpirationDays");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AccessApprovalSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AccessApprovalSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccessApprovalSettings is not found in the empty JSON string", AccessApprovalSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AccessApprovalSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AccessApprovalSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("activeKeyVersion") != null && !jsonObj.get("activeKeyVersion").isJsonNull()) && !jsonObj.get("activeKeyVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activeKeyVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activeKeyVersion").toString()));
      }
      if (jsonObj.get("enrolledServices") != null && !jsonObj.get("enrolledServices").isJsonNull()) {
        JsonArray jsonArrayenrolledServices = jsonObj.getAsJsonArray("enrolledServices");
        if (jsonArrayenrolledServices != null) {
          // ensure the json data is an array
          if (!jsonObj.get("enrolledServices").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `enrolledServices` to be an array in the JSON string but got `%s`", jsonObj.get("enrolledServices").toString()));
          }

          // validate the optional field `enrolledServices` (array)
          for (int i = 0; i < jsonArrayenrolledServices.size(); i++) {
            EnrolledService.validateJsonElement(jsonArrayenrolledServices.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("notificationEmails") != null && !jsonObj.get("notificationEmails").isJsonNull() && !jsonObj.get("notificationEmails").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `notificationEmails` to be an array in the JSON string but got `%s`", jsonObj.get("notificationEmails").toString()));
      }
      if ((jsonObj.get("notificationPubsubTopic") != null && !jsonObj.get("notificationPubsubTopic").isJsonNull()) && !jsonObj.get("notificationPubsubTopic").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `notificationPubsubTopic` to be a primitive type in the JSON string but got `%s`", jsonObj.get("notificationPubsubTopic").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccessApprovalSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccessApprovalSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccessApprovalSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccessApprovalSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<AccessApprovalSettings>() {
           @Override
           public void write(JsonWriter out, AccessApprovalSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AccessApprovalSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AccessApprovalSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AccessApprovalSettings
   * @throws IOException if the JSON string is invalid with respect to AccessApprovalSettings
   */
  public static AccessApprovalSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccessApprovalSettings.class);
  }

  /**
   * Convert an instance of AccessApprovalSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

