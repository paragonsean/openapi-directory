/**
 * Cloud Billing API
 * Allows developers to manage billing for their Google Cloud Platform projects programmatically.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPricingExpression.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPricingExpression::OAIPricingExpression(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPricingExpression::OAIPricingExpression() {
    this->initializeModel();
}

OAIPricingExpression::~OAIPricingExpression() {}

void OAIPricingExpression::initializeModel() {

    m_base_unit_isSet = false;
    m_base_unit_isValid = false;

    m_base_unit_conversion_factor_isSet = false;
    m_base_unit_conversion_factor_isValid = false;

    m_base_unit_description_isSet = false;
    m_base_unit_description_isValid = false;

    m_display_quantity_isSet = false;
    m_display_quantity_isValid = false;

    m_tiered_rates_isSet = false;
    m_tiered_rates_isValid = false;

    m_usage_unit_isSet = false;
    m_usage_unit_isValid = false;

    m_usage_unit_description_isSet = false;
    m_usage_unit_description_isValid = false;
}

void OAIPricingExpression::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPricingExpression::fromJsonObject(QJsonObject json) {

    m_base_unit_isValid = ::OpenAPI::fromJsonValue(m_base_unit, json[QString("baseUnit")]);
    m_base_unit_isSet = !json[QString("baseUnit")].isNull() && m_base_unit_isValid;

    m_base_unit_conversion_factor_isValid = ::OpenAPI::fromJsonValue(m_base_unit_conversion_factor, json[QString("baseUnitConversionFactor")]);
    m_base_unit_conversion_factor_isSet = !json[QString("baseUnitConversionFactor")].isNull() && m_base_unit_conversion_factor_isValid;

    m_base_unit_description_isValid = ::OpenAPI::fromJsonValue(m_base_unit_description, json[QString("baseUnitDescription")]);
    m_base_unit_description_isSet = !json[QString("baseUnitDescription")].isNull() && m_base_unit_description_isValid;

    m_display_quantity_isValid = ::OpenAPI::fromJsonValue(m_display_quantity, json[QString("displayQuantity")]);
    m_display_quantity_isSet = !json[QString("displayQuantity")].isNull() && m_display_quantity_isValid;

    m_tiered_rates_isValid = ::OpenAPI::fromJsonValue(m_tiered_rates, json[QString("tieredRates")]);
    m_tiered_rates_isSet = !json[QString("tieredRates")].isNull() && m_tiered_rates_isValid;

    m_usage_unit_isValid = ::OpenAPI::fromJsonValue(m_usage_unit, json[QString("usageUnit")]);
    m_usage_unit_isSet = !json[QString("usageUnit")].isNull() && m_usage_unit_isValid;

    m_usage_unit_description_isValid = ::OpenAPI::fromJsonValue(m_usage_unit_description, json[QString("usageUnitDescription")]);
    m_usage_unit_description_isSet = !json[QString("usageUnitDescription")].isNull() && m_usage_unit_description_isValid;
}

QString OAIPricingExpression::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPricingExpression::asJsonObject() const {
    QJsonObject obj;
    if (m_base_unit_isSet) {
        obj.insert(QString("baseUnit"), ::OpenAPI::toJsonValue(m_base_unit));
    }
    if (m_base_unit_conversion_factor_isSet) {
        obj.insert(QString("baseUnitConversionFactor"), ::OpenAPI::toJsonValue(m_base_unit_conversion_factor));
    }
    if (m_base_unit_description_isSet) {
        obj.insert(QString("baseUnitDescription"), ::OpenAPI::toJsonValue(m_base_unit_description));
    }
    if (m_display_quantity_isSet) {
        obj.insert(QString("displayQuantity"), ::OpenAPI::toJsonValue(m_display_quantity));
    }
    if (m_tiered_rates.size() > 0) {
        obj.insert(QString("tieredRates"), ::OpenAPI::toJsonValue(m_tiered_rates));
    }
    if (m_usage_unit_isSet) {
        obj.insert(QString("usageUnit"), ::OpenAPI::toJsonValue(m_usage_unit));
    }
    if (m_usage_unit_description_isSet) {
        obj.insert(QString("usageUnitDescription"), ::OpenAPI::toJsonValue(m_usage_unit_description));
    }
    return obj;
}

QString OAIPricingExpression::getBaseUnit() const {
    return m_base_unit;
}
void OAIPricingExpression::setBaseUnit(const QString &base_unit) {
    m_base_unit = base_unit;
    m_base_unit_isSet = true;
}

bool OAIPricingExpression::is_base_unit_Set() const{
    return m_base_unit_isSet;
}

bool OAIPricingExpression::is_base_unit_Valid() const{
    return m_base_unit_isValid;
}

double OAIPricingExpression::getBaseUnitConversionFactor() const {
    return m_base_unit_conversion_factor;
}
void OAIPricingExpression::setBaseUnitConversionFactor(const double &base_unit_conversion_factor) {
    m_base_unit_conversion_factor = base_unit_conversion_factor;
    m_base_unit_conversion_factor_isSet = true;
}

bool OAIPricingExpression::is_base_unit_conversion_factor_Set() const{
    return m_base_unit_conversion_factor_isSet;
}

bool OAIPricingExpression::is_base_unit_conversion_factor_Valid() const{
    return m_base_unit_conversion_factor_isValid;
}

QString OAIPricingExpression::getBaseUnitDescription() const {
    return m_base_unit_description;
}
void OAIPricingExpression::setBaseUnitDescription(const QString &base_unit_description) {
    m_base_unit_description = base_unit_description;
    m_base_unit_description_isSet = true;
}

bool OAIPricingExpression::is_base_unit_description_Set() const{
    return m_base_unit_description_isSet;
}

bool OAIPricingExpression::is_base_unit_description_Valid() const{
    return m_base_unit_description_isValid;
}

double OAIPricingExpression::getDisplayQuantity() const {
    return m_display_quantity;
}
void OAIPricingExpression::setDisplayQuantity(const double &display_quantity) {
    m_display_quantity = display_quantity;
    m_display_quantity_isSet = true;
}

bool OAIPricingExpression::is_display_quantity_Set() const{
    return m_display_quantity_isSet;
}

bool OAIPricingExpression::is_display_quantity_Valid() const{
    return m_display_quantity_isValid;
}

QList<OAITierRate> OAIPricingExpression::getTieredRates() const {
    return m_tiered_rates;
}
void OAIPricingExpression::setTieredRates(const QList<OAITierRate> &tiered_rates) {
    m_tiered_rates = tiered_rates;
    m_tiered_rates_isSet = true;
}

bool OAIPricingExpression::is_tiered_rates_Set() const{
    return m_tiered_rates_isSet;
}

bool OAIPricingExpression::is_tiered_rates_Valid() const{
    return m_tiered_rates_isValid;
}

QString OAIPricingExpression::getUsageUnit() const {
    return m_usage_unit;
}
void OAIPricingExpression::setUsageUnit(const QString &usage_unit) {
    m_usage_unit = usage_unit;
    m_usage_unit_isSet = true;
}

bool OAIPricingExpression::is_usage_unit_Set() const{
    return m_usage_unit_isSet;
}

bool OAIPricingExpression::is_usage_unit_Valid() const{
    return m_usage_unit_isValid;
}

QString OAIPricingExpression::getUsageUnitDescription() const {
    return m_usage_unit_description;
}
void OAIPricingExpression::setUsageUnitDescription(const QString &usage_unit_description) {
    m_usage_unit_description = usage_unit_description;
    m_usage_unit_description_isSet = true;
}

bool OAIPricingExpression::is_usage_unit_description_Set() const{
    return m_usage_unit_description_isSet;
}

bool OAIPricingExpression::is_usage_unit_description_Valid() const{
    return m_usage_unit_description_isValid;
}

bool OAIPricingExpression::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_base_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_base_unit_conversion_factor_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_base_unit_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_quantity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tiered_rates.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_usage_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_usage_unit_description_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPricingExpression::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
