# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class AggregationInfo(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, aggregation_count: int=None, aggregation_interval: str=None, aggregation_level: str=None):
        """AggregationInfo - a model defined in OpenAPI

        :param aggregation_count: The aggregation_count of this AggregationInfo.
        :param aggregation_interval: The aggregation_interval of this AggregationInfo.
        :param aggregation_level: The aggregation_level of this AggregationInfo.
        """
        self.openapi_types = {
            'aggregation_count': int,
            'aggregation_interval': str,
            'aggregation_level': str
        }

        self.attribute_map = {
            'aggregation_count': 'aggregationCount',
            'aggregation_interval': 'aggregationInterval',
            'aggregation_level': 'aggregationLevel'
        }

        self._aggregation_count = aggregation_count
        self._aggregation_interval = aggregation_interval
        self._aggregation_level = aggregation_level

    @classmethod
    def from_dict(cls, dikt: dict) -> 'AggregationInfo':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The AggregationInfo of this AggregationInfo.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def aggregation_count(self):
        """Gets the aggregation_count of this AggregationInfo.

        The number of intervals to aggregate over. Example: If aggregation_level is \"DAILY\" and aggregation_count is 14, aggregation will be over 14 days.

        :return: The aggregation_count of this AggregationInfo.
        :rtype: int
        """
        return self._aggregation_count

    @aggregation_count.setter
    def aggregation_count(self, aggregation_count):
        """Sets the aggregation_count of this AggregationInfo.

        The number of intervals to aggregate over. Example: If aggregation_level is \"DAILY\" and aggregation_count is 14, aggregation will be over 14 days.

        :param aggregation_count: The aggregation_count of this AggregationInfo.
        :type aggregation_count: int
        """

        self._aggregation_count = aggregation_count

    @property
    def aggregation_interval(self):
        """Gets the aggregation_interval of this AggregationInfo.


        :return: The aggregation_interval of this AggregationInfo.
        :rtype: str
        """
        return self._aggregation_interval

    @aggregation_interval.setter
    def aggregation_interval(self, aggregation_interval):
        """Sets the aggregation_interval of this AggregationInfo.


        :param aggregation_interval: The aggregation_interval of this AggregationInfo.
        :type aggregation_interval: str
        """
        allowed_values = ["AGGREGATION_INTERVAL_UNSPECIFIED", "DAILY", "MONTHLY"]  # noqa: E501
        if aggregation_interval not in allowed_values:
            raise ValueError(
                "Invalid value for `aggregation_interval` ({0}), must be one of {1}"
                .format(aggregation_interval, allowed_values)
            )

        self._aggregation_interval = aggregation_interval

    @property
    def aggregation_level(self):
        """Gets the aggregation_level of this AggregationInfo.


        :return: The aggregation_level of this AggregationInfo.
        :rtype: str
        """
        return self._aggregation_level

    @aggregation_level.setter
    def aggregation_level(self, aggregation_level):
        """Sets the aggregation_level of this AggregationInfo.


        :param aggregation_level: The aggregation_level of this AggregationInfo.
        :type aggregation_level: str
        """
        allowed_values = ["AGGREGATION_LEVEL_UNSPECIFIED", "ACCOUNT", "PROJECT"]  # noqa: E501
        if aggregation_level not in allowed_values:
            raise ValueError(
                "Invalid value for `aggregation_level` ({0}), must be one of {1}"
                .format(aggregation_level, allowed_values)
            )

        self._aggregation_level = aggregation_level
