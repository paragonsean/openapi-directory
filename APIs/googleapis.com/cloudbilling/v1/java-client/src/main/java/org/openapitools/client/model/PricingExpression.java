/*
 * Cloud Billing API
 * Allows developers to manage billing for their Google Cloud Platform projects programmatically.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.TierRate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Expresses a mathematical pricing formula. For Example:- &#x60;usage_unit: GBy&#x60; &#x60;tiered_rates:&#x60; &#x60;[start_usage_amount: 20, unit_price: $10]&#x60; &#x60;[start_usage_amount: 100, unit_price: $5]&#x60; The above expresses a pricing formula where the first 20GB is free, the next 80GB is priced at $10 per GB followed by $5 per GB for additional usage.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:16.458931-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PricingExpression {
  public static final String SERIALIZED_NAME_BASE_UNIT = "baseUnit";
  @SerializedName(SERIALIZED_NAME_BASE_UNIT)
  private String baseUnit;

  public static final String SERIALIZED_NAME_BASE_UNIT_CONVERSION_FACTOR = "baseUnitConversionFactor";
  @SerializedName(SERIALIZED_NAME_BASE_UNIT_CONVERSION_FACTOR)
  private Double baseUnitConversionFactor;

  public static final String SERIALIZED_NAME_BASE_UNIT_DESCRIPTION = "baseUnitDescription";
  @SerializedName(SERIALIZED_NAME_BASE_UNIT_DESCRIPTION)
  private String baseUnitDescription;

  public static final String SERIALIZED_NAME_DISPLAY_QUANTITY = "displayQuantity";
  @SerializedName(SERIALIZED_NAME_DISPLAY_QUANTITY)
  private Double displayQuantity;

  public static final String SERIALIZED_NAME_TIERED_RATES = "tieredRates";
  @SerializedName(SERIALIZED_NAME_TIERED_RATES)
  private List<TierRate> tieredRates = new ArrayList<>();

  public static final String SERIALIZED_NAME_USAGE_UNIT = "usageUnit";
  @SerializedName(SERIALIZED_NAME_USAGE_UNIT)
  private String usageUnit;

  public static final String SERIALIZED_NAME_USAGE_UNIT_DESCRIPTION = "usageUnitDescription";
  @SerializedName(SERIALIZED_NAME_USAGE_UNIT_DESCRIPTION)
  private String usageUnitDescription;

  public PricingExpression() {
  }

  public PricingExpression baseUnit(String baseUnit) {
    this.baseUnit = baseUnit;
    return this;
  }

  /**
   * The base unit for the SKU which is the unit used in usage exports. Example: \&quot;By\&quot;
   * @return baseUnit
   */
  @javax.annotation.Nullable
  public String getBaseUnit() {
    return baseUnit;
  }

  public void setBaseUnit(String baseUnit) {
    this.baseUnit = baseUnit;
  }


  public PricingExpression baseUnitConversionFactor(Double baseUnitConversionFactor) {
    this.baseUnitConversionFactor = baseUnitConversionFactor;
    return this;
  }

  /**
   * Conversion factor for converting from price per usage_unit to price per base_unit, and start_usage_amount to start_usage_amount in base_unit. unit_price / base_unit_conversion_factor &#x3D; price per base_unit. start_usage_amount * base_unit_conversion_factor &#x3D; start_usage_amount in base_unit.
   * @return baseUnitConversionFactor
   */
  @javax.annotation.Nullable
  public Double getBaseUnitConversionFactor() {
    return baseUnitConversionFactor;
  }

  public void setBaseUnitConversionFactor(Double baseUnitConversionFactor) {
    this.baseUnitConversionFactor = baseUnitConversionFactor;
  }


  public PricingExpression baseUnitDescription(String baseUnitDescription) {
    this.baseUnitDescription = baseUnitDescription;
    return this;
  }

  /**
   * The base unit in human readable form. Example: \&quot;byte\&quot;.
   * @return baseUnitDescription
   */
  @javax.annotation.Nullable
  public String getBaseUnitDescription() {
    return baseUnitDescription;
  }

  public void setBaseUnitDescription(String baseUnitDescription) {
    this.baseUnitDescription = baseUnitDescription;
  }


  public PricingExpression displayQuantity(Double displayQuantity) {
    this.displayQuantity = displayQuantity;
    return this;
  }

  /**
   * The recommended quantity of units for displaying pricing info. When displaying pricing info it is recommended to display: (unit_price * display_quantity) per display_quantity usage_unit. This field does not affect the pricing formula and is for display purposes only. Example: If the unit_price is \&quot;0.0001 USD\&quot;, the usage_unit is \&quot;GB\&quot; and the display_quantity is \&quot;1000\&quot; then the recommended way of displaying the pricing info is \&quot;0.10 USD per 1000 GB\&quot;
   * @return displayQuantity
   */
  @javax.annotation.Nullable
  public Double getDisplayQuantity() {
    return displayQuantity;
  }

  public void setDisplayQuantity(Double displayQuantity) {
    this.displayQuantity = displayQuantity;
  }


  public PricingExpression tieredRates(List<TierRate> tieredRates) {
    this.tieredRates = tieredRates;
    return this;
  }

  public PricingExpression addTieredRatesItem(TierRate tieredRatesItem) {
    if (this.tieredRates == null) {
      this.tieredRates = new ArrayList<>();
    }
    this.tieredRates.add(tieredRatesItem);
    return this;
  }

  /**
   * The list of tiered rates for this pricing. The total cost is computed by applying each of the tiered rates on usage. This repeated list is sorted by ascending order of start_usage_amount.
   * @return tieredRates
   */
  @javax.annotation.Nullable
  public List<TierRate> getTieredRates() {
    return tieredRates;
  }

  public void setTieredRates(List<TierRate> tieredRates) {
    this.tieredRates = tieredRates;
  }


  public PricingExpression usageUnit(String usageUnit) {
    this.usageUnit = usageUnit;
    return this;
  }

  /**
   * The short hand for unit of usage this pricing is specified in. Example: usage_unit of \&quot;GiBy\&quot; means that usage is specified in \&quot;Gibi Byte\&quot;.
   * @return usageUnit
   */
  @javax.annotation.Nullable
  public String getUsageUnit() {
    return usageUnit;
  }

  public void setUsageUnit(String usageUnit) {
    this.usageUnit = usageUnit;
  }


  public PricingExpression usageUnitDescription(String usageUnitDescription) {
    this.usageUnitDescription = usageUnitDescription;
    return this;
  }

  /**
   * The unit of usage in human readable form. Example: \&quot;gibi byte\&quot;.
   * @return usageUnitDescription
   */
  @javax.annotation.Nullable
  public String getUsageUnitDescription() {
    return usageUnitDescription;
  }

  public void setUsageUnitDescription(String usageUnitDescription) {
    this.usageUnitDescription = usageUnitDescription;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PricingExpression pricingExpression = (PricingExpression) o;
    return Objects.equals(this.baseUnit, pricingExpression.baseUnit) &&
        Objects.equals(this.baseUnitConversionFactor, pricingExpression.baseUnitConversionFactor) &&
        Objects.equals(this.baseUnitDescription, pricingExpression.baseUnitDescription) &&
        Objects.equals(this.displayQuantity, pricingExpression.displayQuantity) &&
        Objects.equals(this.tieredRates, pricingExpression.tieredRates) &&
        Objects.equals(this.usageUnit, pricingExpression.usageUnit) &&
        Objects.equals(this.usageUnitDescription, pricingExpression.usageUnitDescription);
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseUnit, baseUnitConversionFactor, baseUnitDescription, displayQuantity, tieredRates, usageUnit, usageUnitDescription);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PricingExpression {\n");
    sb.append("    baseUnit: ").append(toIndentedString(baseUnit)).append("\n");
    sb.append("    baseUnitConversionFactor: ").append(toIndentedString(baseUnitConversionFactor)).append("\n");
    sb.append("    baseUnitDescription: ").append(toIndentedString(baseUnitDescription)).append("\n");
    sb.append("    displayQuantity: ").append(toIndentedString(displayQuantity)).append("\n");
    sb.append("    tieredRates: ").append(toIndentedString(tieredRates)).append("\n");
    sb.append("    usageUnit: ").append(toIndentedString(usageUnit)).append("\n");
    sb.append("    usageUnitDescription: ").append(toIndentedString(usageUnitDescription)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("baseUnit");
    openapiFields.add("baseUnitConversionFactor");
    openapiFields.add("baseUnitDescription");
    openapiFields.add("displayQuantity");
    openapiFields.add("tieredRates");
    openapiFields.add("usageUnit");
    openapiFields.add("usageUnitDescription");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PricingExpression
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PricingExpression.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PricingExpression is not found in the empty JSON string", PricingExpression.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PricingExpression.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PricingExpression` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("baseUnit") != null && !jsonObj.get("baseUnit").isJsonNull()) && !jsonObj.get("baseUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseUnit").toString()));
      }
      if ((jsonObj.get("baseUnitDescription") != null && !jsonObj.get("baseUnitDescription").isJsonNull()) && !jsonObj.get("baseUnitDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseUnitDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseUnitDescription").toString()));
      }
      if (jsonObj.get("tieredRates") != null && !jsonObj.get("tieredRates").isJsonNull()) {
        JsonArray jsonArraytieredRates = jsonObj.getAsJsonArray("tieredRates");
        if (jsonArraytieredRates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tieredRates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tieredRates` to be an array in the JSON string but got `%s`", jsonObj.get("tieredRates").toString()));
          }

          // validate the optional field `tieredRates` (array)
          for (int i = 0; i < jsonArraytieredRates.size(); i++) {
            TierRate.validateJsonElement(jsonArraytieredRates.get(i));
          };
        }
      }
      if ((jsonObj.get("usageUnit") != null && !jsonObj.get("usageUnit").isJsonNull()) && !jsonObj.get("usageUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `usageUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("usageUnit").toString()));
      }
      if ((jsonObj.get("usageUnitDescription") != null && !jsonObj.get("usageUnitDescription").isJsonNull()) && !jsonObj.get("usageUnitDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `usageUnitDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("usageUnitDescription").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PricingExpression.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PricingExpression' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PricingExpression> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PricingExpression.class));

       return (TypeAdapter<T>) new TypeAdapter<PricingExpression>() {
           @Override
           public void write(JsonWriter out, PricingExpression value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PricingExpression read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PricingExpression given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PricingExpression
   * @throws IOException if the JSON string is invalid with respect to PricingExpression
   */
  public static PricingExpression fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PricingExpression.class);
  }

  /**
   * Convert an instance of PricingExpression to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

