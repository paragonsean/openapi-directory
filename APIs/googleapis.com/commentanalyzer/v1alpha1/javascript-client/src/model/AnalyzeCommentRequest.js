/**
 * Perspective Comment Analyzer API
 * The Perspective Comment Analyzer API provides information about the potential impact of a comment on a conversation (e.g. it can provide a score for the \"toxicity\" of a comment). Users can leverage the \"SuggestCommentScore\" method to submit corrections to improve Perspective over time. Users can set the \"doNotStore\" flag to ensure that all submitted comments are automatically deleted after scores are returned.
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AttributeParameters from './AttributeParameters';
import Context from './Context';
import TextEntry from './TextEntry';

/**
 * The AnalyzeCommentRequest model module.
 * @module model/AnalyzeCommentRequest
 * @version v1alpha1
 */
class AnalyzeCommentRequest {
    /**
     * Constructs a new <code>AnalyzeCommentRequest</code>.
     * The comment analysis request message. Next ID: 11
     * @alias module:model/AnalyzeCommentRequest
     */
    constructor() { 
        
        AnalyzeCommentRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>AnalyzeCommentRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/AnalyzeCommentRequest} obj Optional instance to populate.
     * @return {module:model/AnalyzeCommentRequest} The populated <code>AnalyzeCommentRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new AnalyzeCommentRequest();

            if (data.hasOwnProperty('clientToken')) {
                obj['clientToken'] = ApiClient.convertToType(data['clientToken'], 'String');
            }
            if (data.hasOwnProperty('comment')) {
                obj['comment'] = TextEntry.constructFromObject(data['comment']);
            }
            if (data.hasOwnProperty('communityId')) {
                obj['communityId'] = ApiClient.convertToType(data['communityId'], 'String');
            }
            if (data.hasOwnProperty('context')) {
                obj['context'] = Context.constructFromObject(data['context']);
            }
            if (data.hasOwnProperty('doNotStore')) {
                obj['doNotStore'] = ApiClient.convertToType(data['doNotStore'], 'Boolean');
            }
            if (data.hasOwnProperty('dropUnsupportedAttributes')) {
                obj['dropUnsupportedAttributes'] = ApiClient.convertToType(data['dropUnsupportedAttributes'], 'Boolean');
            }
            if (data.hasOwnProperty('languages')) {
                obj['languages'] = ApiClient.convertToType(data['languages'], ['String']);
            }
            if (data.hasOwnProperty('requestedAttributes')) {
                obj['requestedAttributes'] = ApiClient.convertToType(data['requestedAttributes'], {'String': AttributeParameters});
            }
            if (data.hasOwnProperty('sessionId')) {
                obj['sessionId'] = ApiClient.convertToType(data['sessionId'], 'String');
            }
            if (data.hasOwnProperty('spanAnnotations')) {
                obj['spanAnnotations'] = ApiClient.convertToType(data['spanAnnotations'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>AnalyzeCommentRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>AnalyzeCommentRequest</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['clientToken'] && !(typeof data['clientToken'] === 'string' || data['clientToken'] instanceof String)) {
            throw new Error("Expected the field `clientToken` to be a primitive type in the JSON string but got " + data['clientToken']);
        }
        // validate the optional field `comment`
        if (data['comment']) { // data not null
          TextEntry.validateJSON(data['comment']);
        }
        // ensure the json data is a string
        if (data['communityId'] && !(typeof data['communityId'] === 'string' || data['communityId'] instanceof String)) {
            throw new Error("Expected the field `communityId` to be a primitive type in the JSON string but got " + data['communityId']);
        }
        // validate the optional field `context`
        if (data['context']) { // data not null
          Context.validateJSON(data['context']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['languages'])) {
            throw new Error("Expected the field `languages` to be an array in the JSON data but got " + data['languages']);
        }
        // ensure the json data is a string
        if (data['sessionId'] && !(typeof data['sessionId'] === 'string' || data['sessionId'] instanceof String)) {
            throw new Error("Expected the field `sessionId` to be a primitive type in the JSON string but got " + data['sessionId']);
        }

        return true;
    }


}



/**
 * Opaque token that is echoed from the request to the response.
 * @member {String} clientToken
 */
AnalyzeCommentRequest.prototype['clientToken'] = undefined;

/**
 * @member {module:model/TextEntry} comment
 */
AnalyzeCommentRequest.prototype['comment'] = undefined;

/**
 * Optional identifier associating this AnalyzeCommentRequest with a particular client's community. Different communities may have different norms and rules. Specifying this value enables us to explore building community-specific models for clients.
 * @member {String} communityId
 */
AnalyzeCommentRequest.prototype['communityId'] = undefined;

/**
 * @member {module:model/Context} context
 */
AnalyzeCommentRequest.prototype['context'] = undefined;

/**
 * Do not store the comment or context sent in this request. By default, the service may store comments/context for debugging purposes.
 * @member {Boolean} doNotStore
 */
AnalyzeCommentRequest.prototype['doNotStore'] = undefined;

/**
 * If specified, any requested attribute that is requested but not supported for the language detected will be dropped from the returned scores instead of returning an error.
 * @member {Boolean} dropUnsupportedAttributes
 */
AnalyzeCommentRequest.prototype['dropUnsupportedAttributes'] = undefined;

/**
 * The language(s) of the comment and context. If none are specified, we attempt to automatically detect the language. Specifying multiple languages means the text contains multiple lanugages. Both ISO and BCP-47 language codes are accepted. The server returns an error if no language was specified and language detection fails. The server also returns an error if the languages (either specified by the caller, or auto-detected) are not *all* supported by the service.
 * @member {Array.<String>} languages
 */
AnalyzeCommentRequest.prototype['languages'] = undefined;

/**
 * Specification of requested attributes. The AttributeParameters serve as configuration for each associated attribute. The map keys are attribute names. The available attributes may be different on each RFE installation, and can be seen by calling ListAttributes (see above). For the prod installation, known as Perspective API, see https://developers.perspectiveapi.com/s/about-the-api-model-cards.
 * @member {Object.<String, module:model/AttributeParameters>} requestedAttributes
 */
AnalyzeCommentRequest.prototype['requestedAttributes'] = undefined;

/**
 * Session ID. Used to join related RPCs into a single session. For example, an interactive tool that calls both the AnalyzeComment and SuggestCommentScore RPCs should set all invocations of both RPCs to the same Session ID, typically a random 64-bit integer.
 * @member {String} sessionId
 */
AnalyzeCommentRequest.prototype['sessionId'] = undefined;

/**
 * An advisory parameter that will return span annotations if the model is capable of providing scores with sub-comment resolution. This will likely increase the size of the returned message.
 * @member {Boolean} spanAnnotations
 */
AnalyzeCommentRequest.prototype['spanAnnotations'] = undefined;






export default AnalyzeCommentRequest;

