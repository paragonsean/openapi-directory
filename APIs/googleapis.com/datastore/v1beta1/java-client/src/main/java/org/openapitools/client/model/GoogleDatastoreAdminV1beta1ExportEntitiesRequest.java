/*
 * Cloud Datastore API
 * Accesses the schemaless NoSQL database to provide fully managed, robust, scalable storage for your application. 
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.GoogleDatastoreAdminV1beta1EntityFilter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for google.datastore.admin.v1beta1.DatastoreAdmin.ExportEntities.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:27.176209-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleDatastoreAdminV1beta1ExportEntitiesRequest {
  public static final String SERIALIZED_NAME_ENTITY_FILTER = "entityFilter";
  @SerializedName(SERIALIZED_NAME_ENTITY_FILTER)
  private GoogleDatastoreAdminV1beta1EntityFilter entityFilter;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_OUTPUT_URL_PREFIX = "outputUrlPrefix";
  @SerializedName(SERIALIZED_NAME_OUTPUT_URL_PREFIX)
  private String outputUrlPrefix;

  public GoogleDatastoreAdminV1beta1ExportEntitiesRequest() {
  }

  public GoogleDatastoreAdminV1beta1ExportEntitiesRequest entityFilter(GoogleDatastoreAdminV1beta1EntityFilter entityFilter) {
    this.entityFilter = entityFilter;
    return this;
  }

  /**
   * Get entityFilter
   * @return entityFilter
   */
  @javax.annotation.Nullable
  public GoogleDatastoreAdminV1beta1EntityFilter getEntityFilter() {
    return entityFilter;
  }

  public void setEntityFilter(GoogleDatastoreAdminV1beta1EntityFilter entityFilter) {
    this.entityFilter = entityFilter;
  }


  public GoogleDatastoreAdminV1beta1ExportEntitiesRequest labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public GoogleDatastoreAdminV1beta1ExportEntitiesRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Client-assigned labels.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public GoogleDatastoreAdminV1beta1ExportEntitiesRequest outputUrlPrefix(String outputUrlPrefix) {
    this.outputUrlPrefix = outputUrlPrefix;
    return this;
  }

  /**
   * Location for the export metadata and data files. The full resource URL of the external storage location. Currently, only Google Cloud Storage is supported. So output_url_prefix should be of the form: &#x60;gs://BUCKET_NAME[/NAMESPACE_PATH]&#x60;, where &#x60;BUCKET_NAME&#x60; is the name of the Cloud Storage bucket and &#x60;NAMESPACE_PATH&#x60; is an optional Cloud Storage namespace path (this is not a Cloud Datastore namespace). For more information about Cloud Storage namespace paths, see [Object name considerations](https://cloud.google.com/storage/docs/naming#object-considerations). The resulting files will be nested deeper than the specified URL prefix. The final output URL will be provided in the google.datastore.admin.v1beta1.ExportEntitiesResponse.output_url field. That value should be used for subsequent ImportEntities operations. By nesting the data files deeper, the same Cloud Storage bucket can be used in multiple ExportEntities operations without conflict.
   * @return outputUrlPrefix
   */
  @javax.annotation.Nullable
  public String getOutputUrlPrefix() {
    return outputUrlPrefix;
  }

  public void setOutputUrlPrefix(String outputUrlPrefix) {
    this.outputUrlPrefix = outputUrlPrefix;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleDatastoreAdminV1beta1ExportEntitiesRequest googleDatastoreAdminV1beta1ExportEntitiesRequest = (GoogleDatastoreAdminV1beta1ExportEntitiesRequest) o;
    return Objects.equals(this.entityFilter, googleDatastoreAdminV1beta1ExportEntitiesRequest.entityFilter) &&
        Objects.equals(this.labels, googleDatastoreAdminV1beta1ExportEntitiesRequest.labels) &&
        Objects.equals(this.outputUrlPrefix, googleDatastoreAdminV1beta1ExportEntitiesRequest.outputUrlPrefix);
  }

  @Override
  public int hashCode() {
    return Objects.hash(entityFilter, labels, outputUrlPrefix);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleDatastoreAdminV1beta1ExportEntitiesRequest {\n");
    sb.append("    entityFilter: ").append(toIndentedString(entityFilter)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    outputUrlPrefix: ").append(toIndentedString(outputUrlPrefix)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("entityFilter");
    openapiFields.add("labels");
    openapiFields.add("outputUrlPrefix");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleDatastoreAdminV1beta1ExportEntitiesRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleDatastoreAdminV1beta1ExportEntitiesRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleDatastoreAdminV1beta1ExportEntitiesRequest is not found in the empty JSON string", GoogleDatastoreAdminV1beta1ExportEntitiesRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleDatastoreAdminV1beta1ExportEntitiesRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleDatastoreAdminV1beta1ExportEntitiesRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `entityFilter`
      if (jsonObj.get("entityFilter") != null && !jsonObj.get("entityFilter").isJsonNull()) {
        GoogleDatastoreAdminV1beta1EntityFilter.validateJsonElement(jsonObj.get("entityFilter"));
      }
      if ((jsonObj.get("outputUrlPrefix") != null && !jsonObj.get("outputUrlPrefix").isJsonNull()) && !jsonObj.get("outputUrlPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputUrlPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputUrlPrefix").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleDatastoreAdminV1beta1ExportEntitiesRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleDatastoreAdminV1beta1ExportEntitiesRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleDatastoreAdminV1beta1ExportEntitiesRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleDatastoreAdminV1beta1ExportEntitiesRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleDatastoreAdminV1beta1ExportEntitiesRequest>() {
           @Override
           public void write(JsonWriter out, GoogleDatastoreAdminV1beta1ExportEntitiesRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleDatastoreAdminV1beta1ExportEntitiesRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleDatastoreAdminV1beta1ExportEntitiesRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleDatastoreAdminV1beta1ExportEntitiesRequest
   * @throws IOException if the JSON string is invalid with respect to GoogleDatastoreAdminV1beta1ExportEntitiesRequest
   */
  public static GoogleDatastoreAdminV1beta1ExportEntitiesRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleDatastoreAdminV1beta1ExportEntitiesRequest.class);
  }

  /**
   * Convert an instance of GoogleDatastoreAdminV1beta1ExportEntitiesRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

