/*
 * Cloud Trace API
 * Sends application trace data to Cloud Trace for viewing. Trace data is collected for all App Engine applications by default. Trace data from other applications can be provided using this API. This library is used to interact with the Cloud Trace API directly. If you are looking to instrument your application for Cloud Trace, we recommend using OpenTelemetry. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A span represents a single timed event within a trace. Spans can be nested and form a trace tree. Often, a trace contains a root span that describes the end-to-end latency of an operation and, optionally, one or more subspans for its suboperations. Spans do not need to be contiguous. There may be gaps between spans in a trace.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:50.115386-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TraceSpan {
  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private String endTime;

  /**
   * Distinguishes between spans generated in a particular context. For example, two spans with the same name may be distinguished using &#x60;RPC_CLIENT&#x60; and &#x60;RPC_SERVER&#x60; to identify queueing latency associated with the span.
   */
  @JsonAdapter(KindEnum.Adapter.class)
  public enum KindEnum {
    SPAN_KIND_UNSPECIFIED("SPAN_KIND_UNSPECIFIED"),
    
    RPC_SERVER("RPC_SERVER"),
    
    RPC_CLIENT("RPC_CLIENT");

    private String value;

    KindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static KindEnum fromValue(String value) {
      for (KindEnum b : KindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<KindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final KindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public KindEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return KindEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      KindEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private KindEnum kind;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PARENT_SPAN_ID = "parentSpanId";
  @SerializedName(SERIALIZED_NAME_PARENT_SPAN_ID)
  private String parentSpanId;

  public static final String SERIALIZED_NAME_SPAN_ID = "spanId";
  @SerializedName(SERIALIZED_NAME_SPAN_ID)
  private String spanId;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  public TraceSpan() {
  }

  public TraceSpan endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * End time of the span in seconds and nanoseconds from the UNIX epoch.
   * @return endTime
   */
  @javax.annotation.Nullable
  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }


  public TraceSpan kind(KindEnum kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Distinguishes between spans generated in a particular context. For example, two spans with the same name may be distinguished using &#x60;RPC_CLIENT&#x60; and &#x60;RPC_SERVER&#x60; to identify queueing latency associated with the span.
   * @return kind
   */
  @javax.annotation.Nullable
  public KindEnum getKind() {
    return kind;
  }

  public void setKind(KindEnum kind) {
    this.kind = kind;
  }


  public TraceSpan labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public TraceSpan putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Collection of labels associated with the span. Label keys must be less than 128 bytes. Label values must be less than 16 kilobytes (10MB for &#x60;/stacktrace&#x60; values). Some predefined label keys exist, or you may create your own. When creating your own, we recommend the following formats: * &#x60;/category/product/key&#x60; for agents of well-known products (e.g. &#x60;/db/mongodb/read_size&#x60;). * &#x60;short_host/path/key&#x60; for domain-specific keys (e.g. &#x60;foo.com/myproduct/bar&#x60;) Predefined labels include: * &#x60;/agent&#x60; * &#x60;/component&#x60; * &#x60;/error/message&#x60; * &#x60;/error/name&#x60; * &#x60;/http/client_city&#x60; * &#x60;/http/client_country&#x60; * &#x60;/http/client_protocol&#x60; * &#x60;/http/client_region&#x60; * &#x60;/http/host&#x60; * &#x60;/http/method&#x60; * &#x60;/http/path&#x60; * &#x60;/http/redirected_url&#x60; * &#x60;/http/request/size&#x60; * &#x60;/http/response/size&#x60; * &#x60;/http/route&#x60; * &#x60;/http/status_code&#x60; * &#x60;/http/url&#x60; * &#x60;/http/user_agent&#x60; * &#x60;/pid&#x60; * &#x60;/stacktrace&#x60; * &#x60;/tid&#x60;
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public TraceSpan name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the span. Must be less than 128 bytes. The span name is sanitized and displayed in the Trace tool in the Google Cloud Platform Console. The name may be a method name or some other per-call site name. For the same executable and the same call point, a best practice is to use a consistent name, which makes it easier to correlate cross-trace spans.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TraceSpan parentSpanId(String parentSpanId) {
    this.parentSpanId = parentSpanId;
    return this;
  }

  /**
   * Optional. ID of the parent span, if any.
   * @return parentSpanId
   */
  @javax.annotation.Nullable
  public String getParentSpanId() {
    return parentSpanId;
  }

  public void setParentSpanId(String parentSpanId) {
    this.parentSpanId = parentSpanId;
  }


  public TraceSpan spanId(String spanId) {
    this.spanId = spanId;
    return this;
  }

  /**
   * Identifier for the span. Must be a 64-bit integer other than 0 and unique within a trace. For example, &#x60;2205310701640571284&#x60;.
   * @return spanId
   */
  @javax.annotation.Nullable
  public String getSpanId() {
    return spanId;
  }

  public void setSpanId(String spanId) {
    this.spanId = spanId;
  }


  public TraceSpan startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Start time of the span in seconds and nanoseconds from the UNIX epoch.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TraceSpan traceSpan = (TraceSpan) o;
    return Objects.equals(this.endTime, traceSpan.endTime) &&
        Objects.equals(this.kind, traceSpan.kind) &&
        Objects.equals(this.labels, traceSpan.labels) &&
        Objects.equals(this.name, traceSpan.name) &&
        Objects.equals(this.parentSpanId, traceSpan.parentSpanId) &&
        Objects.equals(this.spanId, traceSpan.spanId) &&
        Objects.equals(this.startTime, traceSpan.startTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(endTime, kind, labels, name, parentSpanId, spanId, startTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TraceSpan {\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    parentSpanId: ").append(toIndentedString(parentSpanId)).append("\n");
    sb.append("    spanId: ").append(toIndentedString(spanId)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("endTime");
    openapiFields.add("kind");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("parentSpanId");
    openapiFields.add("spanId");
    openapiFields.add("startTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TraceSpan
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TraceSpan.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TraceSpan is not found in the empty JSON string", TraceSpan.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TraceSpan.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TraceSpan` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) && !jsonObj.get("endTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endTime").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `kind`
      if (jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) {
        KindEnum.validateJsonElement(jsonObj.get("kind"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("parentSpanId") != null && !jsonObj.get("parentSpanId").isJsonNull()) && !jsonObj.get("parentSpanId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentSpanId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parentSpanId").toString()));
      }
      if ((jsonObj.get("spanId") != null && !jsonObj.get("spanId").isJsonNull()) && !jsonObj.get("spanId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spanId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spanId").toString()));
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TraceSpan.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TraceSpan' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TraceSpan> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TraceSpan.class));

       return (TypeAdapter<T>) new TypeAdapter<TraceSpan>() {
           @Override
           public void write(JsonWriter out, TraceSpan value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TraceSpan read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TraceSpan given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TraceSpan
   * @throws IOException if the JSON string is invalid with respect to TraceSpan
   */
  public static TraceSpan fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TraceSpan.class);
  }

  /**
   * Convert an instance of TraceSpan to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

