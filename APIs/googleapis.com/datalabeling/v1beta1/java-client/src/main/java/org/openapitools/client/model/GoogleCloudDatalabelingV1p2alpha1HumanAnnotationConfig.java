/*
 * Data Labeling API
 * Public API for Google Cloud AI Data Labeling Service.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration for how human labeling task should be done.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:41.492869-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig {
  public static final String SERIALIZED_NAME_ANNOTATED_DATASET_DESCRIPTION = "annotatedDatasetDescription";
  @SerializedName(SERIALIZED_NAME_ANNOTATED_DATASET_DESCRIPTION)
  private String annotatedDatasetDescription;

  public static final String SERIALIZED_NAME_ANNOTATED_DATASET_DISPLAY_NAME = "annotatedDatasetDisplayName";
  @SerializedName(SERIALIZED_NAME_ANNOTATED_DATASET_DISPLAY_NAME)
  private String annotatedDatasetDisplayName;

  public static final String SERIALIZED_NAME_CONTRIBUTOR_EMAILS = "contributorEmails";
  @SerializedName(SERIALIZED_NAME_CONTRIBUTOR_EMAILS)
  private List<String> contributorEmails = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTRUCTION = "instruction";
  @SerializedName(SERIALIZED_NAME_INSTRUCTION)
  private String instruction;

  public static final String SERIALIZED_NAME_LABEL_GROUP = "labelGroup";
  @SerializedName(SERIALIZED_NAME_LABEL_GROUP)
  private String labelGroup;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_QUESTION_DURATION = "questionDuration";
  @SerializedName(SERIALIZED_NAME_QUESTION_DURATION)
  private String questionDuration;

  public static final String SERIALIZED_NAME_REPLICA_COUNT = "replicaCount";
  @SerializedName(SERIALIZED_NAME_REPLICA_COUNT)
  private Integer replicaCount;

  public static final String SERIALIZED_NAME_USER_EMAIL_ADDRESS = "userEmailAddress";
  @SerializedName(SERIALIZED_NAME_USER_EMAIL_ADDRESS)
  private String userEmailAddress;

  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig() {
  }

  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig annotatedDatasetDescription(String annotatedDatasetDescription) {
    this.annotatedDatasetDescription = annotatedDatasetDescription;
    return this;
  }

  /**
   * Optional. A human-readable description for AnnotatedDataset. The description can be up to 10000 characters long.
   * @return annotatedDatasetDescription
   */
  @javax.annotation.Nullable
  public String getAnnotatedDatasetDescription() {
    return annotatedDatasetDescription;
  }

  public void setAnnotatedDatasetDescription(String annotatedDatasetDescription) {
    this.annotatedDatasetDescription = annotatedDatasetDescription;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig annotatedDatasetDisplayName(String annotatedDatasetDisplayName) {
    this.annotatedDatasetDisplayName = annotatedDatasetDisplayName;
    return this;
  }

  /**
   * Required. A human-readable name for AnnotatedDataset defined by users. Maximum of 64 characters .
   * @return annotatedDatasetDisplayName
   */
  @javax.annotation.Nullable
  public String getAnnotatedDatasetDisplayName() {
    return annotatedDatasetDisplayName;
  }

  public void setAnnotatedDatasetDisplayName(String annotatedDatasetDisplayName) {
    this.annotatedDatasetDisplayName = annotatedDatasetDisplayName;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig contributorEmails(List<String> contributorEmails) {
    this.contributorEmails = contributorEmails;
    return this;
  }

  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig addContributorEmailsItem(String contributorEmailsItem) {
    if (this.contributorEmails == null) {
      this.contributorEmails = new ArrayList<>();
    }
    this.contributorEmails.add(contributorEmailsItem);
    return this;
  }

  /**
   * Optional. If you want your own labeling contributors to manage and work on this labeling request, you can set these contributors here. We will give them access to the question types in crowdcompute. Note that these emails must be registered in crowdcompute worker UI: https://crowd-compute.appspot.com/
   * @return contributorEmails
   */
  @javax.annotation.Nullable
  public List<String> getContributorEmails() {
    return contributorEmails;
  }

  public void setContributorEmails(List<String> contributorEmails) {
    this.contributorEmails = contributorEmails;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig instruction(String instruction) {
    this.instruction = instruction;
    return this;
  }

  /**
   * Required. Instruction resource name.
   * @return instruction
   */
  @javax.annotation.Nullable
  public String getInstruction() {
    return instruction;
  }

  public void setInstruction(String instruction) {
    this.instruction = instruction;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig labelGroup(String labelGroup) {
    this.labelGroup = labelGroup;
    return this;
  }

  /**
   * Optional. A human-readable label used to logically group labeling tasks. This string must match the regular expression &#x60;[a-zA-Z\\\\d_-]{0,128}&#x60;.
   * @return labelGroup
   */
  @javax.annotation.Nullable
  public String getLabelGroup() {
    return labelGroup;
  }

  public void setLabelGroup(String labelGroup) {
    this.labelGroup = labelGroup;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Optional. The Language of this question, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US. Only need to set this when task is language related. For example, French text classification.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig questionDuration(String questionDuration) {
    this.questionDuration = questionDuration;
    return this;
  }

  /**
   * Optional. Maximum duration for contributors to answer a question. Maximum is 3600 seconds. Default is 3600 seconds.
   * @return questionDuration
   */
  @javax.annotation.Nullable
  public String getQuestionDuration() {
    return questionDuration;
  }

  public void setQuestionDuration(String questionDuration) {
    this.questionDuration = questionDuration;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig replicaCount(Integer replicaCount) {
    this.replicaCount = replicaCount;
    return this;
  }

  /**
   * Optional. Replication of questions. Each question will be sent to up to this number of contributors to label. Aggregated answers will be returned. Default is set to 1. For image related labeling, valid values are 1, 3, 5.
   * @return replicaCount
   */
  @javax.annotation.Nullable
  public Integer getReplicaCount() {
    return replicaCount;
  }

  public void setReplicaCount(Integer replicaCount) {
    this.replicaCount = replicaCount;
  }


  public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig userEmailAddress(String userEmailAddress) {
    this.userEmailAddress = userEmailAddress;
    return this;
  }

  /**
   * Email of the user who started the labeling task and should be notified by email. If empty no notification will be sent.
   * @return userEmailAddress
   */
  @javax.annotation.Nullable
  public String getUserEmailAddress() {
    return userEmailAddress;
  }

  public void setUserEmailAddress(String userEmailAddress) {
    this.userEmailAddress = userEmailAddress;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig = (GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig) o;
    return Objects.equals(this.annotatedDatasetDescription, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.annotatedDatasetDescription) &&
        Objects.equals(this.annotatedDatasetDisplayName, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.annotatedDatasetDisplayName) &&
        Objects.equals(this.contributorEmails, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.contributorEmails) &&
        Objects.equals(this.instruction, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.instruction) &&
        Objects.equals(this.labelGroup, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.labelGroup) &&
        Objects.equals(this.languageCode, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.languageCode) &&
        Objects.equals(this.questionDuration, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.questionDuration) &&
        Objects.equals(this.replicaCount, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.replicaCount) &&
        Objects.equals(this.userEmailAddress, googleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.userEmailAddress);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotatedDatasetDescription, annotatedDatasetDisplayName, contributorEmails, instruction, labelGroup, languageCode, questionDuration, replicaCount, userEmailAddress);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig {\n");
    sb.append("    annotatedDatasetDescription: ").append(toIndentedString(annotatedDatasetDescription)).append("\n");
    sb.append("    annotatedDatasetDisplayName: ").append(toIndentedString(annotatedDatasetDisplayName)).append("\n");
    sb.append("    contributorEmails: ").append(toIndentedString(contributorEmails)).append("\n");
    sb.append("    instruction: ").append(toIndentedString(instruction)).append("\n");
    sb.append("    labelGroup: ").append(toIndentedString(labelGroup)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    questionDuration: ").append(toIndentedString(questionDuration)).append("\n");
    sb.append("    replicaCount: ").append(toIndentedString(replicaCount)).append("\n");
    sb.append("    userEmailAddress: ").append(toIndentedString(userEmailAddress)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotatedDatasetDescription");
    openapiFields.add("annotatedDatasetDisplayName");
    openapiFields.add("contributorEmails");
    openapiFields.add("instruction");
    openapiFields.add("labelGroup");
    openapiFields.add("languageCode");
    openapiFields.add("questionDuration");
    openapiFields.add("replicaCount");
    openapiFields.add("userEmailAddress");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig is not found in the empty JSON string", GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("annotatedDatasetDescription") != null && !jsonObj.get("annotatedDatasetDescription").isJsonNull()) && !jsonObj.get("annotatedDatasetDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotatedDatasetDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotatedDatasetDescription").toString()));
      }
      if ((jsonObj.get("annotatedDatasetDisplayName") != null && !jsonObj.get("annotatedDatasetDisplayName").isJsonNull()) && !jsonObj.get("annotatedDatasetDisplayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotatedDatasetDisplayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotatedDatasetDisplayName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("contributorEmails") != null && !jsonObj.get("contributorEmails").isJsonNull() && !jsonObj.get("contributorEmails").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `contributorEmails` to be an array in the JSON string but got `%s`", jsonObj.get("contributorEmails").toString()));
      }
      if ((jsonObj.get("instruction") != null && !jsonObj.get("instruction").isJsonNull()) && !jsonObj.get("instruction").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instruction` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instruction").toString()));
      }
      if ((jsonObj.get("labelGroup") != null && !jsonObj.get("labelGroup").isJsonNull()) && !jsonObj.get("labelGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `labelGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("labelGroup").toString()));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      if ((jsonObj.get("questionDuration") != null && !jsonObj.get("questionDuration").isJsonNull()) && !jsonObj.get("questionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `questionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("questionDuration").toString()));
      }
      if ((jsonObj.get("userEmailAddress") != null && !jsonObj.get("userEmailAddress").isJsonNull()) && !jsonObj.get("userEmailAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userEmailAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userEmailAddress").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig>() {
           @Override
           public void write(JsonWriter out, GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig
   */
  public static GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig.class);
  }

  /**
   * Convert an instance of GoogleCloudDatalabelingV1p2alpha1HumanAnnotationConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

