/*
 * Network Connectivity API
 * This API enables connectivity with and between Google Cloud resources.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the cause of the error with structured details. Example of an error when contacting the \&quot;pubsub.googleapis.com\&quot; API when it is not enabled: { \&quot;reason\&quot;: \&quot;API_DISABLED\&quot; \&quot;domain\&quot;: \&quot;googleapis.com\&quot; \&quot;metadata\&quot;: { \&quot;resource\&quot;: \&quot;projects/123\&quot;, \&quot;service\&quot;: \&quot;pubsub.googleapis.com\&quot; } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { \&quot;reason\&quot;: \&quot;STOCKOUT\&quot; \&quot;domain\&quot;: \&quot;spanner.googleapis.com\&quot;, \&quot;metadata\&quot;: { \&quot;availableRegions\&quot;: \&quot;us-central1,us-east2\&quot; } }
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:51:11.077024-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleRpcErrorInfo {
  public static final String SERIALIZED_NAME_DOMAIN = "domain";
  @SerializedName(SERIALIZED_NAME_DOMAIN)
  private String domain;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_REASON = "reason";
  @SerializedName(SERIALIZED_NAME_REASON)
  private String reason;

  public GoogleRpcErrorInfo() {
  }

  public GoogleRpcErrorInfo domain(String domain) {
    this.domain = domain;
    return this;
  }

  /**
   * The logical grouping to which the \&quot;reason\&quot; belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: \&quot;pubsub.googleapis.com\&quot;. If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is \&quot;googleapis.com\&quot;.
   * @return domain
   */
  @javax.annotation.Nullable
  public String getDomain() {
    return domain;
  }

  public void setDomain(String domain) {
    this.domain = domain;
  }


  public GoogleRpcErrorInfo metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public GoogleRpcErrorInfo putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Additional structured details about this error. Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\&quot;instanceLimit\&quot;: \&quot;100/request\&quot;}, should be returned as, {\&quot;instanceLimitPerRequest\&quot;: \&quot;100\&quot;}, if the client exceeds the number of instances that can be created in a single (batch) request.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public GoogleRpcErrorInfo reason(String reason) {
    this.reason = reason;
    return this;
  }

  /**
   * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of &#x60;A-Z+[A-Z0-9]&#x60;, which represents UPPER_SNAKE_CASE.
   * @return reason
   */
  @javax.annotation.Nullable
  public String getReason() {
    return reason;
  }

  public void setReason(String reason) {
    this.reason = reason;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleRpcErrorInfo googleRpcErrorInfo = (GoogleRpcErrorInfo) o;
    return Objects.equals(this.domain, googleRpcErrorInfo.domain) &&
        Objects.equals(this.metadata, googleRpcErrorInfo.metadata) &&
        Objects.equals(this.reason, googleRpcErrorInfo.reason);
  }

  @Override
  public int hashCode() {
    return Objects.hash(domain, metadata, reason);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleRpcErrorInfo {\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("domain");
    openapiFields.add("metadata");
    openapiFields.add("reason");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleRpcErrorInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleRpcErrorInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleRpcErrorInfo is not found in the empty JSON string", GoogleRpcErrorInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleRpcErrorInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleRpcErrorInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("domain") != null && !jsonObj.get("domain").isJsonNull()) && !jsonObj.get("domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("domain").toString()));
      }
      if ((jsonObj.get("reason") != null && !jsonObj.get("reason").isJsonNull()) && !jsonObj.get("reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reason").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleRpcErrorInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleRpcErrorInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleRpcErrorInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleRpcErrorInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleRpcErrorInfo>() {
           @Override
           public void write(JsonWriter out, GoogleRpcErrorInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleRpcErrorInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleRpcErrorInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleRpcErrorInfo
   * @throws IOException if the JSON string is invalid with respect to GoogleRpcErrorInfo
   */
  public static GoogleRpcErrorInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleRpcErrorInfo.class);
  }

  /**
   * Convert an instance of GoogleRpcErrorInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

