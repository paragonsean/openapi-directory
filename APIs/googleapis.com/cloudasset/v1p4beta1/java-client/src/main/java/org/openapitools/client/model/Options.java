/*
 * Cloud Asset API
 * The cloud asset API manages the history and inventory of cloud resources.
 *
 * The version of the OpenAPI document: v1p4beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains request options.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:03.758447-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Options {
  public static final String SERIALIZED_NAME_ANALYZE_SERVICE_ACCOUNT_IMPERSONATION = "analyzeServiceAccountImpersonation";
  @SerializedName(SERIALIZED_NAME_ANALYZE_SERVICE_ACCOUNT_IMPERSONATION)
  private Boolean analyzeServiceAccountImpersonation;

  public static final String SERIALIZED_NAME_EXPAND_GROUPS = "expandGroups";
  @SerializedName(SERIALIZED_NAME_EXPAND_GROUPS)
  private Boolean expandGroups;

  public static final String SERIALIZED_NAME_EXPAND_RESOURCES = "expandResources";
  @SerializedName(SERIALIZED_NAME_EXPAND_RESOURCES)
  private Boolean expandResources;

  public static final String SERIALIZED_NAME_EXPAND_ROLES = "expandRoles";
  @SerializedName(SERIALIZED_NAME_EXPAND_ROLES)
  private Boolean expandRoles;

  public static final String SERIALIZED_NAME_OUTPUT_GROUP_EDGES = "outputGroupEdges";
  @SerializedName(SERIALIZED_NAME_OUTPUT_GROUP_EDGES)
  private Boolean outputGroupEdges;

  public static final String SERIALIZED_NAME_OUTPUT_RESOURCE_EDGES = "outputResourceEdges";
  @SerializedName(SERIALIZED_NAME_OUTPUT_RESOURCE_EDGES)
  private Boolean outputResourceEdges;

  public Options() {
  }

  public Options analyzeServiceAccountImpersonation(Boolean analyzeServiceAccountImpersonation) {
    this.analyzeServiceAccountImpersonation = analyzeServiceAccountImpersonation;
    return this;
  }

  /**
   * Optional. If true, the response will include access analysis from identities to resources via service account impersonation. This is a very expensive operation, because many derived queries will be executed. For example, if the request analyzes for which resources user A has permission P, and there&#39;s an IAM policy states user A has iam.serviceAccounts.getAccessToken permission to a service account SA, and there&#39;s another IAM policy states service account SA has permission P to a GCP folder F, then user A potentially has access to the GCP folder F. And those advanced analysis results will be included in AnalyzeIamPolicyResponse.service_account_impersonation_analysis. Another example, if the request analyzes for who has permission P to a GCP folder F, and there&#39;s an IAM policy states user A has iam.serviceAccounts.actAs permission to a service account SA, and there&#39;s another IAM policy states service account SA has permission P to the GCP folder F, then user A potentially has access to the GCP folder F. And those advanced analysis results will be included in AnalyzeIamPolicyResponse.service_account_impersonation_analysis. Default is false.
   * @return analyzeServiceAccountImpersonation
   */
  @javax.annotation.Nullable
  public Boolean getAnalyzeServiceAccountImpersonation() {
    return analyzeServiceAccountImpersonation;
  }

  public void setAnalyzeServiceAccountImpersonation(Boolean analyzeServiceAccountImpersonation) {
    this.analyzeServiceAccountImpersonation = analyzeServiceAccountImpersonation;
  }


  public Options expandGroups(Boolean expandGroups) {
    this.expandGroups = expandGroups;
    return this;
  }

  /**
   * Optional. If true, the identities section of the result will expand any Google groups appearing in an IAM policy binding. If identity_selector is specified, the identity in the result will be determined by the selector, and this flag will have no effect. Default is false.
   * @return expandGroups
   */
  @javax.annotation.Nullable
  public Boolean getExpandGroups() {
    return expandGroups;
  }

  public void setExpandGroups(Boolean expandGroups) {
    this.expandGroups = expandGroups;
  }


  public Options expandResources(Boolean expandResources) {
    this.expandResources = expandResources;
    return this;
  }

  /**
   * Optional. If true, the resource section of the result will expand any resource attached to an IAM policy to include resources lower in the resource hierarchy. For example, if the request analyzes for which resources user A has permission P, and the results include an IAM policy with P on a GCP folder, the results will also include resources in that folder with permission P. If resource_selector is specified, the resource section of the result will be determined by the selector, and this flag will have no effect. Default is false.
   * @return expandResources
   */
  @javax.annotation.Nullable
  public Boolean getExpandResources() {
    return expandResources;
  }

  public void setExpandResources(Boolean expandResources) {
    this.expandResources = expandResources;
  }


  public Options expandRoles(Boolean expandRoles) {
    this.expandRoles = expandRoles;
    return this;
  }

  /**
   * Optional. If true, the access section of result will expand any roles appearing in IAM policy bindings to include their permissions. If access_selector is specified, the access section of the result will be determined by the selector, and this flag will have no effect. Default is false.
   * @return expandRoles
   */
  @javax.annotation.Nullable
  public Boolean getExpandRoles() {
    return expandRoles;
  }

  public void setExpandRoles(Boolean expandRoles) {
    this.expandRoles = expandRoles;
  }


  public Options outputGroupEdges(Boolean outputGroupEdges) {
    this.outputGroupEdges = outputGroupEdges;
    return this;
  }

  /**
   * Optional. If true, the result will output group identity edges, starting from the binding&#39;s group members, to any expanded identities. Default is false.
   * @return outputGroupEdges
   */
  @javax.annotation.Nullable
  public Boolean getOutputGroupEdges() {
    return outputGroupEdges;
  }

  public void setOutputGroupEdges(Boolean outputGroupEdges) {
    this.outputGroupEdges = outputGroupEdges;
  }


  public Options outputResourceEdges(Boolean outputResourceEdges) {
    this.outputResourceEdges = outputResourceEdges;
    return this;
  }

  /**
   * Optional. If true, the result will output resource edges, starting from the policy attached resource, to any expanded resources. Default is false.
   * @return outputResourceEdges
   */
  @javax.annotation.Nullable
  public Boolean getOutputResourceEdges() {
    return outputResourceEdges;
  }

  public void setOutputResourceEdges(Boolean outputResourceEdges) {
    this.outputResourceEdges = outputResourceEdges;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Options options = (Options) o;
    return Objects.equals(this.analyzeServiceAccountImpersonation, options.analyzeServiceAccountImpersonation) &&
        Objects.equals(this.expandGroups, options.expandGroups) &&
        Objects.equals(this.expandResources, options.expandResources) &&
        Objects.equals(this.expandRoles, options.expandRoles) &&
        Objects.equals(this.outputGroupEdges, options.outputGroupEdges) &&
        Objects.equals(this.outputResourceEdges, options.outputResourceEdges);
  }

  @Override
  public int hashCode() {
    return Objects.hash(analyzeServiceAccountImpersonation, expandGroups, expandResources, expandRoles, outputGroupEdges, outputResourceEdges);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Options {\n");
    sb.append("    analyzeServiceAccountImpersonation: ").append(toIndentedString(analyzeServiceAccountImpersonation)).append("\n");
    sb.append("    expandGroups: ").append(toIndentedString(expandGroups)).append("\n");
    sb.append("    expandResources: ").append(toIndentedString(expandResources)).append("\n");
    sb.append("    expandRoles: ").append(toIndentedString(expandRoles)).append("\n");
    sb.append("    outputGroupEdges: ").append(toIndentedString(outputGroupEdges)).append("\n");
    sb.append("    outputResourceEdges: ").append(toIndentedString(outputResourceEdges)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("analyzeServiceAccountImpersonation");
    openapiFields.add("expandGroups");
    openapiFields.add("expandResources");
    openapiFields.add("expandRoles");
    openapiFields.add("outputGroupEdges");
    openapiFields.add("outputResourceEdges");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Options
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Options.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Options is not found in the empty JSON string", Options.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Options.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Options` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Options.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Options' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Options> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Options.class));

       return (TypeAdapter<T>) new TypeAdapter<Options>() {
           @Override
           public void write(JsonWriter out, Options value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Options read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Options given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Options
   * @throws IOException if the JSON string is invalid with respect to Options
   */
  public static Options fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Options.class);
  }

  /**
   * Convert an instance of Options to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

