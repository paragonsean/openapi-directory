/*
 * Cloud Asset API
 * The cloud asset API manages the history and inventory of cloud resources.
 *
 * The version of the OpenAPI document: v1p4beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &#x60;AccessPolicy&#x60; is a container for &#x60;AccessLevels&#x60; (which define the necessary attributes to use Google Cloud services) and &#x60;ServicePerimeters&#x60; (which define regions of services able to freely pass data within a perimeter). An access policy is globally visible within an organization, and the restrictions it specifies apply to all projects within an organization.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:03.758447-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleIdentityAccesscontextmanagerV1AccessPolicy {
  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PARENT = "parent";
  @SerializedName(SERIALIZED_NAME_PARENT)
  private String parent;

  public static final String SERIALIZED_NAME_SCOPES = "scopes";
  @SerializedName(SERIALIZED_NAME_SCOPES)
  private List<String> scopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public GoogleIdentityAccesscontextmanagerV1AccessPolicy() {
  }

  public GoogleIdentityAccesscontextmanagerV1AccessPolicy etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * Output only. An opaque identifier for the current version of the &#x60;AccessPolicy&#x60;. This will always be a strongly validated etag, meaning that two Access Polices will be identical if and only if their etags are identical. Clients should not expect this to be in any specific format.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public GoogleIdentityAccesscontextmanagerV1AccessPolicy name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Output only. Resource name of the &#x60;AccessPolicy&#x60;. Format: &#x60;accessPolicies/{access_policy}&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public GoogleIdentityAccesscontextmanagerV1AccessPolicy parent(String parent) {
    this.parent = parent;
    return this;
  }

  /**
   * Required. The parent of this &#x60;AccessPolicy&#x60; in the Cloud Resource Hierarchy. Currently immutable once created. Format: &#x60;organizations/{organization_id}&#x60;
   * @return parent
   */
  @javax.annotation.Nullable
  public String getParent() {
    return parent;
  }

  public void setParent(String parent) {
    this.parent = parent;
  }


  public GoogleIdentityAccesscontextmanagerV1AccessPolicy scopes(List<String> scopes) {
    this.scopes = scopes;
    return this;
  }

  public GoogleIdentityAccesscontextmanagerV1AccessPolicy addScopesItem(String scopesItem) {
    if (this.scopes == null) {
      this.scopes = new ArrayList<>();
    }
    this.scopes.add(scopesItem);
    return this;
  }

  /**
   * The scopes of a policy define which resources an ACM policy can restrict, and where ACM resources can be referenced. For example, a policy with scopes&#x3D;[\&quot;folders/123\&quot;] has the following behavior: - vpcsc perimeters can only restrict projects within folders/123 - access levels can only be referenced by resources within folders/123. If empty, there are no limitations on which resources can be restricted by an ACM policy, and there are no limitations on where ACM resources can be referenced. Only one policy can include a given scope (attempting to create a second policy which includes \&quot;folders/123\&quot; will result in an error). Currently, scopes cannot be modified after a policy is created. Currently, policies can only have a single scope. Format: list of &#x60;folders/{folder_number}&#x60; or &#x60;projects/{project_number}&#x60;
   * @return scopes
   */
  @javax.annotation.Nullable
  public List<String> getScopes() {
    return scopes;
  }

  public void setScopes(List<String> scopes) {
    this.scopes = scopes;
  }


  public GoogleIdentityAccesscontextmanagerV1AccessPolicy title(String title) {
    this.title = title;
    return this;
  }

  /**
   * Required. Human readable title. Does not affect behavior.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleIdentityAccesscontextmanagerV1AccessPolicy googleIdentityAccesscontextmanagerV1AccessPolicy = (GoogleIdentityAccesscontextmanagerV1AccessPolicy) o;
    return Objects.equals(this.etag, googleIdentityAccesscontextmanagerV1AccessPolicy.etag) &&
        Objects.equals(this.name, googleIdentityAccesscontextmanagerV1AccessPolicy.name) &&
        Objects.equals(this.parent, googleIdentityAccesscontextmanagerV1AccessPolicy.parent) &&
        Objects.equals(this.scopes, googleIdentityAccesscontextmanagerV1AccessPolicy.scopes) &&
        Objects.equals(this.title, googleIdentityAccesscontextmanagerV1AccessPolicy.title);
  }

  @Override
  public int hashCode() {
    return Objects.hash(etag, name, parent, scopes, title);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleIdentityAccesscontextmanagerV1AccessPolicy {\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    scopes: ").append(toIndentedString(scopes)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("etag");
    openapiFields.add("name");
    openapiFields.add("parent");
    openapiFields.add("scopes");
    openapiFields.add("title");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleIdentityAccesscontextmanagerV1AccessPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleIdentityAccesscontextmanagerV1AccessPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleIdentityAccesscontextmanagerV1AccessPolicy is not found in the empty JSON string", GoogleIdentityAccesscontextmanagerV1AccessPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleIdentityAccesscontextmanagerV1AccessPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleIdentityAccesscontextmanagerV1AccessPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("parent") != null && !jsonObj.get("parent").isJsonNull()) && !jsonObj.get("parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parent").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("scopes") != null && !jsonObj.get("scopes").isJsonNull() && !jsonObj.get("scopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `scopes` to be an array in the JSON string but got `%s`", jsonObj.get("scopes").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleIdentityAccesscontextmanagerV1AccessPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleIdentityAccesscontextmanagerV1AccessPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleIdentityAccesscontextmanagerV1AccessPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleIdentityAccesscontextmanagerV1AccessPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleIdentityAccesscontextmanagerV1AccessPolicy>() {
           @Override
           public void write(JsonWriter out, GoogleIdentityAccesscontextmanagerV1AccessPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleIdentityAccesscontextmanagerV1AccessPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleIdentityAccesscontextmanagerV1AccessPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleIdentityAccesscontextmanagerV1AccessPolicy
   * @throws IOException if the JSON string is invalid with respect to GoogleIdentityAccesscontextmanagerV1AccessPolicy
   */
  public static GoogleIdentityAccesscontextmanagerV1AccessPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleIdentityAccesscontextmanagerV1AccessPolicy.class);
  }

  /**
   * Convert an instance of GoogleIdentityAccesscontextmanagerV1AccessPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

