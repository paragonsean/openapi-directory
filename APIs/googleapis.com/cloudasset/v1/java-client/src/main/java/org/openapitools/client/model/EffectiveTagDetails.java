/*
 * Cloud Asset API
 * The Cloud Asset API manages the history and inventory of Google Cloud resources.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Tag;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The effective tags and the ancestor resources from which they were inherited.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:52.366195-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class EffectiveTagDetails {
  public static final String SERIALIZED_NAME_ATTACHED_RESOURCE = "attachedResource";
  @SerializedName(SERIALIZED_NAME_ATTACHED_RESOURCE)
  private String attachedResource;

  public static final String SERIALIZED_NAME_EFFECTIVE_TAGS = "effectiveTags";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_TAGS)
  private List<Tag> effectiveTags = new ArrayList<>();

  public EffectiveTagDetails() {
  }

  public EffectiveTagDetails attachedResource(String attachedResource) {
    this.attachedResource = attachedResource;
    return this;
  }

  /**
   * The [full resource name](https://cloud.google.com/asset-inventory/docs/resource-name-format) of the ancestor from which an effective_tag is inherited, according to [tag inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
   * @return attachedResource
   */
  @javax.annotation.Nullable
  public String getAttachedResource() {
    return attachedResource;
  }

  public void setAttachedResource(String attachedResource) {
    this.attachedResource = attachedResource;
  }


  public EffectiveTagDetails effectiveTags(List<Tag> effectiveTags) {
    this.effectiveTags = effectiveTags;
    return this;
  }

  public EffectiveTagDetails addEffectiveTagsItem(Tag effectiveTagsItem) {
    if (this.effectiveTags == null) {
      this.effectiveTags = new ArrayList<>();
    }
    this.effectiveTags.add(effectiveTagsItem);
    return this;
  }

  /**
   * The effective tags inherited from the attached_resource. Note that tags with the same key but different values may attach to resources at a different hierarchy levels. The lower hierarchy tag value will overwrite the higher hierarchy tag value of the same tag key. In this case, the tag value at the higher hierarchy level will be removed. For more information, see [tag inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
   * @return effectiveTags
   */
  @javax.annotation.Nullable
  public List<Tag> getEffectiveTags() {
    return effectiveTags;
  }

  public void setEffectiveTags(List<Tag> effectiveTags) {
    this.effectiveTags = effectiveTags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EffectiveTagDetails effectiveTagDetails = (EffectiveTagDetails) o;
    return Objects.equals(this.attachedResource, effectiveTagDetails.attachedResource) &&
        Objects.equals(this.effectiveTags, effectiveTagDetails.effectiveTags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attachedResource, effectiveTags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EffectiveTagDetails {\n");
    sb.append("    attachedResource: ").append(toIndentedString(attachedResource)).append("\n");
    sb.append("    effectiveTags: ").append(toIndentedString(effectiveTags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attachedResource");
    openapiFields.add("effectiveTags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EffectiveTagDetails
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EffectiveTagDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EffectiveTagDetails is not found in the empty JSON string", EffectiveTagDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EffectiveTagDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EffectiveTagDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("attachedResource") != null && !jsonObj.get("attachedResource").isJsonNull()) && !jsonObj.get("attachedResource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `attachedResource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("attachedResource").toString()));
      }
      if (jsonObj.get("effectiveTags") != null && !jsonObj.get("effectiveTags").isJsonNull()) {
        JsonArray jsonArrayeffectiveTags = jsonObj.getAsJsonArray("effectiveTags");
        if (jsonArrayeffectiveTags != null) {
          // ensure the json data is an array
          if (!jsonObj.get("effectiveTags").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `effectiveTags` to be an array in the JSON string but got `%s`", jsonObj.get("effectiveTags").toString()));
          }

          // validate the optional field `effectiveTags` (array)
          for (int i = 0; i < jsonArrayeffectiveTags.size(); i++) {
            Tag.validateJsonElement(jsonArrayeffectiveTags.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EffectiveTagDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EffectiveTagDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EffectiveTagDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EffectiveTagDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<EffectiveTagDetails>() {
           @Override
           public void write(JsonWriter out, EffectiveTagDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EffectiveTagDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EffectiveTagDetails given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EffectiveTagDetails
   * @throws IOException if the JSON string is invalid with respect to EffectiveTagDetails
   */
  public static EffectiveTagDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EffectiveTagDetails.class);
  }

  /**
   * Convert an instance of EffectiveTagDetails to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

