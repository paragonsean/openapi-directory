/*
 * Places API (New)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request proto for Search Nearby. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:29.736799-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleMapsPlacesV1SearchNearbyRequest {
  public static final String SERIALIZED_NAME_EXCLUDED_PRIMARY_TYPES = "excludedPrimaryTypes";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_PRIMARY_TYPES)
  private List<String> excludedPrimaryTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDED_TYPES = "excludedTypes";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_TYPES)
  private List<String> excludedTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INCLUDED_PRIMARY_TYPES = "includedPrimaryTypes";
  @SerializedName(SERIALIZED_NAME_INCLUDED_PRIMARY_TYPES)
  private List<String> includedPrimaryTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INCLUDED_TYPES = "includedTypes";
  @SerializedName(SERIALIZED_NAME_INCLUDED_TYPES)
  private List<String> includedTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_LOCATION_RESTRICTION = "locationRestriction";
  @SerializedName(SERIALIZED_NAME_LOCATION_RESTRICTION)
  private GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction locationRestriction;

  public static final String SERIALIZED_NAME_MAX_RESULT_COUNT = "maxResultCount";
  @SerializedName(SERIALIZED_NAME_MAX_RESULT_COUNT)
  private Integer maxResultCount;

  /**
   * How results will be ranked in the response.
   */
  @JsonAdapter(RankPreferenceEnum.Adapter.class)
  public enum RankPreferenceEnum {
    RANK_PREFERENCE_UNSPECIFIED("RANK_PREFERENCE_UNSPECIFIED"),
    
    DISTANCE("DISTANCE"),
    
    POPULARITY("POPULARITY");

    private String value;

    RankPreferenceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RankPreferenceEnum fromValue(String value) {
      for (RankPreferenceEnum b : RankPreferenceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RankPreferenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RankPreferenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RankPreferenceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RankPreferenceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RankPreferenceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RANK_PREFERENCE = "rankPreference";
  @SerializedName(SERIALIZED_NAME_RANK_PREFERENCE)
  private RankPreferenceEnum rankPreference;

  public static final String SERIALIZED_NAME_REGION_CODE = "regionCode";
  @SerializedName(SERIALIZED_NAME_REGION_CODE)
  private String regionCode;

  public GoogleMapsPlacesV1SearchNearbyRequest() {
  }

  public GoogleMapsPlacesV1SearchNearbyRequest excludedPrimaryTypes(List<String> excludedPrimaryTypes) {
    this.excludedPrimaryTypes = excludedPrimaryTypes;
    return this;
  }

  public GoogleMapsPlacesV1SearchNearbyRequest addExcludedPrimaryTypesItem(String excludedPrimaryTypesItem) {
    if (this.excludedPrimaryTypes == null) {
      this.excludedPrimaryTypes = new ArrayList<>();
    }
    this.excludedPrimaryTypes.add(excludedPrimaryTypesItem);
    return this;
  }

  /**
   * Excluded primary Place type (e.g. \&quot;restaurant\&quot; or \&quot;gas_station\&quot;) from https://developers.google.com/maps/documentation/places/web-service/place-types. Up to 50 types from [Table A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a) may be specified. If there are any conflicting primary types, i.e. a type appears in both included_primary_types and excluded_primary_types, an INVALID_ARGUMENT error is returned. If a Place type is specified with multiple type restrictions, only places that satisfy all of the restrictions are returned. For example, if we have {included_types &#x3D; [\&quot;restaurant\&quot;], excluded_primary_types &#x3D; [\&quot;restaurant\&quot;]}, the returned places provide \&quot;restaurant\&quot; related services but do not operate primarily as \&quot;restaurants\&quot;.
   * @return excludedPrimaryTypes
   */
  @javax.annotation.Nullable
  public List<String> getExcludedPrimaryTypes() {
    return excludedPrimaryTypes;
  }

  public void setExcludedPrimaryTypes(List<String> excludedPrimaryTypes) {
    this.excludedPrimaryTypes = excludedPrimaryTypes;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest excludedTypes(List<String> excludedTypes) {
    this.excludedTypes = excludedTypes;
    return this;
  }

  public GoogleMapsPlacesV1SearchNearbyRequest addExcludedTypesItem(String excludedTypesItem) {
    if (this.excludedTypes == null) {
      this.excludedTypes = new ArrayList<>();
    }
    this.excludedTypes.add(excludedTypesItem);
    return this;
  }

  /**
   * Excluded Place type (eg, \&quot;restaurant\&quot; or \&quot;gas_station\&quot;) from https://developers.google.com/maps/documentation/places/web-service/place-types. Up to 50 types from [Table A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a) may be specified. If the client provides both included_types (e.g. restaurant) and excluded_types (e.g. cafe), then the response should include places that are restaurant but not cafe. The response includes places that match at least one of the included_types and none of the excluded_types. If there are any conflicting types, i.e. a type appears in both included_types and excluded_types, an INVALID_ARGUMENT error is returned. If a Place type is specified with multiple type restrictions, only places that satisfy all of the restrictions are returned. For example, if we have {included_types &#x3D; [\&quot;restaurant\&quot;], excluded_primary_types &#x3D; [\&quot;restaurant\&quot;]}, the returned places provide \&quot;restaurant\&quot; related services but do not operate primarily as \&quot;restaurants\&quot;.
   * @return excludedTypes
   */
  @javax.annotation.Nullable
  public List<String> getExcludedTypes() {
    return excludedTypes;
  }

  public void setExcludedTypes(List<String> excludedTypes) {
    this.excludedTypes = excludedTypes;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest includedPrimaryTypes(List<String> includedPrimaryTypes) {
    this.includedPrimaryTypes = includedPrimaryTypes;
    return this;
  }

  public GoogleMapsPlacesV1SearchNearbyRequest addIncludedPrimaryTypesItem(String includedPrimaryTypesItem) {
    if (this.includedPrimaryTypes == null) {
      this.includedPrimaryTypes = new ArrayList<>();
    }
    this.includedPrimaryTypes.add(includedPrimaryTypesItem);
    return this;
  }

  /**
   * Included primary Place type (e.g. \&quot;restaurant\&quot; or \&quot;gas_station\&quot;) from https://developers.google.com/maps/documentation/places/web-service/place-types. A place can only have a single primary type from the supported types table associated with it. Up to 50 types from [Table A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a) may be specified. If there are any conflicting primary types, i.e. a type appears in both included_primary_types and excluded_primary_types, an INVALID_ARGUMENT error is returned. If a Place type is specified with multiple type restrictions, only places that satisfy all of the restrictions are returned. For example, if we have {included_types &#x3D; [\&quot;restaurant\&quot;], excluded_primary_types &#x3D; [\&quot;restaurant\&quot;]}, the returned places provide \&quot;restaurant\&quot; related services but do not operate primarily as \&quot;restaurants\&quot;.
   * @return includedPrimaryTypes
   */
  @javax.annotation.Nullable
  public List<String> getIncludedPrimaryTypes() {
    return includedPrimaryTypes;
  }

  public void setIncludedPrimaryTypes(List<String> includedPrimaryTypes) {
    this.includedPrimaryTypes = includedPrimaryTypes;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest includedTypes(List<String> includedTypes) {
    this.includedTypes = includedTypes;
    return this;
  }

  public GoogleMapsPlacesV1SearchNearbyRequest addIncludedTypesItem(String includedTypesItem) {
    if (this.includedTypes == null) {
      this.includedTypes = new ArrayList<>();
    }
    this.includedTypes.add(includedTypesItem);
    return this;
  }

  /**
   * Included Place type (eg, \&quot;restaurant\&quot; or \&quot;gas_station\&quot;) from https://developers.google.com/maps/documentation/places/web-service/place-types. Up to 50 types from [Table A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a) may be specified. If there are any conflicting types, i.e. a type appears in both included_types and excluded_types, an INVALID_ARGUMENT error is returned. If a Place type is specified with multiple type restrictions, only places that satisfy all of the restrictions are returned. For example, if we have {included_types &#x3D; [\&quot;restaurant\&quot;], excluded_primary_types &#x3D; [\&quot;restaurant\&quot;]}, the returned places provide \&quot;restaurant\&quot; related services but do not operate primarily as \&quot;restaurants\&quot;.
   * @return includedTypes
   */
  @javax.annotation.Nullable
  public List<String> getIncludedTypes() {
    return includedTypes;
  }

  public void setIncludedTypes(List<String> includedTypes) {
    this.includedTypes = includedTypes;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Place details will be displayed with the preferred language if available. If the language code is unspecified or unrecognized, place details of any language may be returned, with a preference for English if such details exist. Current list of supported languages: https://developers.google.com/maps/faq#languagesupport.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest locationRestriction(GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
    return this;
  }

  /**
   * Get locationRestriction
   * @return locationRestriction
   */
  @javax.annotation.Nullable
  public GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction getLocationRestriction() {
    return locationRestriction;
  }

  public void setLocationRestriction(GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest maxResultCount(Integer maxResultCount) {
    this.maxResultCount = maxResultCount;
    return this;
  }

  /**
   * Maximum number of results to return. It must be between 1 and 20 (default), inclusively. If the number is unset, it falls back to the upper limit. If the number is set to negative or exceeds the upper limit, an INVALID_ARGUMENT error is returned.
   * @return maxResultCount
   */
  @javax.annotation.Nullable
  public Integer getMaxResultCount() {
    return maxResultCount;
  }

  public void setMaxResultCount(Integer maxResultCount) {
    this.maxResultCount = maxResultCount;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest rankPreference(RankPreferenceEnum rankPreference) {
    this.rankPreference = rankPreference;
    return this;
  }

  /**
   * How results will be ranked in the response.
   * @return rankPreference
   */
  @javax.annotation.Nullable
  public RankPreferenceEnum getRankPreference() {
    return rankPreference;
  }

  public void setRankPreference(RankPreferenceEnum rankPreference) {
    this.rankPreference = rankPreference;
  }


  public GoogleMapsPlacesV1SearchNearbyRequest regionCode(String regionCode) {
    this.regionCode = regionCode;
    return this;
  }

  /**
   * The Unicode country/region code (CLDR) of the location where the request is coming from. This parameter is used to display the place details, like region-specific place name, if available. The parameter can affect results based on applicable law. For more information, see https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html. Note that 3-digit region codes are not currently supported.
   * @return regionCode
   */
  @javax.annotation.Nullable
  public String getRegionCode() {
    return regionCode;
  }

  public void setRegionCode(String regionCode) {
    this.regionCode = regionCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleMapsPlacesV1SearchNearbyRequest googleMapsPlacesV1SearchNearbyRequest = (GoogleMapsPlacesV1SearchNearbyRequest) o;
    return Objects.equals(this.excludedPrimaryTypes, googleMapsPlacesV1SearchNearbyRequest.excludedPrimaryTypes) &&
        Objects.equals(this.excludedTypes, googleMapsPlacesV1SearchNearbyRequest.excludedTypes) &&
        Objects.equals(this.includedPrimaryTypes, googleMapsPlacesV1SearchNearbyRequest.includedPrimaryTypes) &&
        Objects.equals(this.includedTypes, googleMapsPlacesV1SearchNearbyRequest.includedTypes) &&
        Objects.equals(this.languageCode, googleMapsPlacesV1SearchNearbyRequest.languageCode) &&
        Objects.equals(this.locationRestriction, googleMapsPlacesV1SearchNearbyRequest.locationRestriction) &&
        Objects.equals(this.maxResultCount, googleMapsPlacesV1SearchNearbyRequest.maxResultCount) &&
        Objects.equals(this.rankPreference, googleMapsPlacesV1SearchNearbyRequest.rankPreference) &&
        Objects.equals(this.regionCode, googleMapsPlacesV1SearchNearbyRequest.regionCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(excludedPrimaryTypes, excludedTypes, includedPrimaryTypes, includedTypes, languageCode, locationRestriction, maxResultCount, rankPreference, regionCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleMapsPlacesV1SearchNearbyRequest {\n");
    sb.append("    excludedPrimaryTypes: ").append(toIndentedString(excludedPrimaryTypes)).append("\n");
    sb.append("    excludedTypes: ").append(toIndentedString(excludedTypes)).append("\n");
    sb.append("    includedPrimaryTypes: ").append(toIndentedString(includedPrimaryTypes)).append("\n");
    sb.append("    includedTypes: ").append(toIndentedString(includedTypes)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    locationRestriction: ").append(toIndentedString(locationRestriction)).append("\n");
    sb.append("    maxResultCount: ").append(toIndentedString(maxResultCount)).append("\n");
    sb.append("    rankPreference: ").append(toIndentedString(rankPreference)).append("\n");
    sb.append("    regionCode: ").append(toIndentedString(regionCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("excludedPrimaryTypes");
    openapiFields.add("excludedTypes");
    openapiFields.add("includedPrimaryTypes");
    openapiFields.add("includedTypes");
    openapiFields.add("languageCode");
    openapiFields.add("locationRestriction");
    openapiFields.add("maxResultCount");
    openapiFields.add("rankPreference");
    openapiFields.add("regionCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleMapsPlacesV1SearchNearbyRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleMapsPlacesV1SearchNearbyRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleMapsPlacesV1SearchNearbyRequest is not found in the empty JSON string", GoogleMapsPlacesV1SearchNearbyRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleMapsPlacesV1SearchNearbyRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleMapsPlacesV1SearchNearbyRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedPrimaryTypes") != null && !jsonObj.get("excludedPrimaryTypes").isJsonNull() && !jsonObj.get("excludedPrimaryTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedPrimaryTypes` to be an array in the JSON string but got `%s`", jsonObj.get("excludedPrimaryTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedTypes") != null && !jsonObj.get("excludedTypes").isJsonNull() && !jsonObj.get("excludedTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedTypes` to be an array in the JSON string but got `%s`", jsonObj.get("excludedTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("includedPrimaryTypes") != null && !jsonObj.get("includedPrimaryTypes").isJsonNull() && !jsonObj.get("includedPrimaryTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `includedPrimaryTypes` to be an array in the JSON string but got `%s`", jsonObj.get("includedPrimaryTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("includedTypes") != null && !jsonObj.get("includedTypes").isJsonNull() && !jsonObj.get("includedTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `includedTypes` to be an array in the JSON string but got `%s`", jsonObj.get("includedTypes").toString()));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      // validate the optional field `locationRestriction`
      if (jsonObj.get("locationRestriction") != null && !jsonObj.get("locationRestriction").isJsonNull()) {
        GoogleMapsPlacesV1SearchNearbyRequestLocationRestriction.validateJsonElement(jsonObj.get("locationRestriction"));
      }
      if ((jsonObj.get("rankPreference") != null && !jsonObj.get("rankPreference").isJsonNull()) && !jsonObj.get("rankPreference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rankPreference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rankPreference").toString()));
      }
      // validate the optional field `rankPreference`
      if (jsonObj.get("rankPreference") != null && !jsonObj.get("rankPreference").isJsonNull()) {
        RankPreferenceEnum.validateJsonElement(jsonObj.get("rankPreference"));
      }
      if ((jsonObj.get("regionCode") != null && !jsonObj.get("regionCode").isJsonNull()) && !jsonObj.get("regionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `regionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("regionCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleMapsPlacesV1SearchNearbyRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleMapsPlacesV1SearchNearbyRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleMapsPlacesV1SearchNearbyRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleMapsPlacesV1SearchNearbyRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleMapsPlacesV1SearchNearbyRequest>() {
           @Override
           public void write(JsonWriter out, GoogleMapsPlacesV1SearchNearbyRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleMapsPlacesV1SearchNearbyRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleMapsPlacesV1SearchNearbyRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleMapsPlacesV1SearchNearbyRequest
   * @throws IOException if the JSON string is invalid with respect to GoogleMapsPlacesV1SearchNearbyRequest
   */
  public static GoogleMapsPlacesV1SearchNearbyRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleMapsPlacesV1SearchNearbyRequest.class);
  }

  /**
   * Convert an instance of GoogleMapsPlacesV1SearchNearbyRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

