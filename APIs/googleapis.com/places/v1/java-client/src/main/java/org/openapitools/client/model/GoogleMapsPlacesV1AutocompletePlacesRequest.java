/*
 * Places API (New)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias;
import org.openapitools.client.model.GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction;
import org.openapitools.client.model.GoogleTypeLatLng;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request proto for AutocompletePlaces.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:29.736799-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleMapsPlacesV1AutocompletePlacesRequest {
  public static final String SERIALIZED_NAME_INCLUDE_QUERY_PREDICTIONS = "includeQueryPredictions";
  @SerializedName(SERIALIZED_NAME_INCLUDE_QUERY_PREDICTIONS)
  private Boolean includeQueryPredictions;

  public static final String SERIALIZED_NAME_INCLUDED_PRIMARY_TYPES = "includedPrimaryTypes";
  @SerializedName(SERIALIZED_NAME_INCLUDED_PRIMARY_TYPES)
  private List<String> includedPrimaryTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INCLUDED_REGION_CODES = "includedRegionCodes";
  @SerializedName(SERIALIZED_NAME_INCLUDED_REGION_CODES)
  private List<String> includedRegionCodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INPUT = "input";
  @SerializedName(SERIALIZED_NAME_INPUT)
  private String input;

  public static final String SERIALIZED_NAME_INPUT_OFFSET = "inputOffset";
  @SerializedName(SERIALIZED_NAME_INPUT_OFFSET)
  private Integer inputOffset;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_LOCATION_BIAS = "locationBias";
  @SerializedName(SERIALIZED_NAME_LOCATION_BIAS)
  private GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias locationBias;

  public static final String SERIALIZED_NAME_LOCATION_RESTRICTION = "locationRestriction";
  @SerializedName(SERIALIZED_NAME_LOCATION_RESTRICTION)
  private GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction locationRestriction;

  public static final String SERIALIZED_NAME_ORIGIN = "origin";
  @SerializedName(SERIALIZED_NAME_ORIGIN)
  private GoogleTypeLatLng origin;

  public static final String SERIALIZED_NAME_REGION_CODE = "regionCode";
  @SerializedName(SERIALIZED_NAME_REGION_CODE)
  private String regionCode;

  public static final String SERIALIZED_NAME_SESSION_TOKEN = "sessionToken";
  @SerializedName(SERIALIZED_NAME_SESSION_TOKEN)
  private String sessionToken;

  public GoogleMapsPlacesV1AutocompletePlacesRequest() {
  }

  public GoogleMapsPlacesV1AutocompletePlacesRequest includeQueryPredictions(Boolean includeQueryPredictions) {
    this.includeQueryPredictions = includeQueryPredictions;
    return this;
  }

  /**
   * Optional. If true, the response will include both Place and query predictions. Otherwise the response will only return Place predictions.
   * @return includeQueryPredictions
   */
  @javax.annotation.Nullable
  public Boolean getIncludeQueryPredictions() {
    return includeQueryPredictions;
  }

  public void setIncludeQueryPredictions(Boolean includeQueryPredictions) {
    this.includeQueryPredictions = includeQueryPredictions;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest includedPrimaryTypes(List<String> includedPrimaryTypes) {
    this.includedPrimaryTypes = includedPrimaryTypes;
    return this;
  }

  public GoogleMapsPlacesV1AutocompletePlacesRequest addIncludedPrimaryTypesItem(String includedPrimaryTypesItem) {
    if (this.includedPrimaryTypes == null) {
      this.includedPrimaryTypes = new ArrayList<>();
    }
    this.includedPrimaryTypes.add(includedPrimaryTypesItem);
    return this;
  }

  /**
   * Optional. Included primary Place type (for example, \&quot;restaurant\&quot; or \&quot;gas_station\&quot;) from https://developers.google.com/maps/documentation/places/web-service/place-types. A Place is only returned if its primary type is included in this list. Up to 5 values can be specified. If no types are specified, all Place types are returned.
   * @return includedPrimaryTypes
   */
  @javax.annotation.Nullable
  public List<String> getIncludedPrimaryTypes() {
    return includedPrimaryTypes;
  }

  public void setIncludedPrimaryTypes(List<String> includedPrimaryTypes) {
    this.includedPrimaryTypes = includedPrimaryTypes;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest includedRegionCodes(List<String> includedRegionCodes) {
    this.includedRegionCodes = includedRegionCodes;
    return this;
  }

  public GoogleMapsPlacesV1AutocompletePlacesRequest addIncludedRegionCodesItem(String includedRegionCodesItem) {
    if (this.includedRegionCodes == null) {
      this.includedRegionCodes = new ArrayList<>();
    }
    this.includedRegionCodes.add(includedRegionCodesItem);
    return this;
  }

  /**
   * Optional. Only include results in the specified regions, specified as up to 15 CLDR two-character region codes. An empty set will not restrict the results. If both &#x60;location_restriction&#x60; and &#x60;included_region_codes&#x60; are set, the results will be located in the area of intersection.
   * @return includedRegionCodes
   */
  @javax.annotation.Nullable
  public List<String> getIncludedRegionCodes() {
    return includedRegionCodes;
  }

  public void setIncludedRegionCodes(List<String> includedRegionCodes) {
    this.includedRegionCodes = includedRegionCodes;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest input(String input) {
    this.input = input;
    return this;
  }

  /**
   * Required. The text string on which to search.
   * @return input
   */
  @javax.annotation.Nullable
  public String getInput() {
    return input;
  }

  public void setInput(String input) {
    this.input = input;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest inputOffset(Integer inputOffset) {
    this.inputOffset = inputOffset;
    return this;
  }

  /**
   * Optional. A zero-based Unicode character offset of &#x60;input&#x60; indicating the cursor position in &#x60;input&#x60;. The cursor position may influence what predictions are returned. If empty, defaults to the length of &#x60;input&#x60;.
   * @return inputOffset
   */
  @javax.annotation.Nullable
  public Integer getInputOffset() {
    return inputOffset;
  }

  public void setInputOffset(Integer inputOffset) {
    this.inputOffset = inputOffset;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Optional. The language in which to return results. Defaults to en-US. The results may be in mixed languages if the language used in &#x60;input&#x60; is different from &#x60;language_code&#x60; or if the returned Place does not have a translation from the local language to &#x60;language_code&#x60;.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest locationBias(GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias locationBias) {
    this.locationBias = locationBias;
    return this;
  }

  /**
   * Get locationBias
   * @return locationBias
   */
  @javax.annotation.Nullable
  public GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias getLocationBias() {
    return locationBias;
  }

  public void setLocationBias(GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias locationBias) {
    this.locationBias = locationBias;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest locationRestriction(GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
    return this;
  }

  /**
   * Get locationRestriction
   * @return locationRestriction
   */
  @javax.annotation.Nullable
  public GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction getLocationRestriction() {
    return locationRestriction;
  }

  public void setLocationRestriction(GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest origin(GoogleTypeLatLng origin) {
    this.origin = origin;
    return this;
  }

  /**
   * Get origin
   * @return origin
   */
  @javax.annotation.Nullable
  public GoogleTypeLatLng getOrigin() {
    return origin;
  }

  public void setOrigin(GoogleTypeLatLng origin) {
    this.origin = origin;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest regionCode(String regionCode) {
    this.regionCode = regionCode;
    return this;
  }

  /**
   * Optional. The region code, specified as a CLDR two-character region code. This affects address formatting, result ranking, and may influence what results are returned. This does not restrict results to the specified region. To restrict results to a region, use &#x60;region_code_restriction&#x60;.
   * @return regionCode
   */
  @javax.annotation.Nullable
  public String getRegionCode() {
    return regionCode;
  }

  public void setRegionCode(String regionCode) {
    this.regionCode = regionCode;
  }


  public GoogleMapsPlacesV1AutocompletePlacesRequest sessionToken(String sessionToken) {
    this.sessionToken = sessionToken;
    return this;
  }

  /**
   * Optional. A string which identifies an Autocomplete session for billing purposes. Must be a URL and filename safe base64 string with at most 36 ASCII characters in length. Otherwise an INVALID_ARGUMENT error is returned. The session begins when the user starts typing a query, and concludes when they select a place and a call to Place Details or Address Validation is made. Each session can have multiple queries, followed by one Place Details or Address Validation request. The credentials used for each request within a session must belong to the same Google Cloud Console project. Once a session has concluded, the token is no longer valid; your app must generate a fresh token for each session. If the &#x60;session_token&#x60; parameter is omitted, or if you reuse a session token, the session is charged as if no session token was provided (each request is billed separately). We recommend the following guidelines: * Use session tokens for all Place Autocomplete calls. * Generate a fresh token for each session. Using a version 4 UUID is recommended. * Ensure that the credentials used for all Place Autocomplete, Place Details, and Address Validation requests within a session belong to the same Cloud Console project. * Be sure to pass a unique session token for each new session. Using the same token for more than one session will result in each request being billed individually.
   * @return sessionToken
   */
  @javax.annotation.Nullable
  public String getSessionToken() {
    return sessionToken;
  }

  public void setSessionToken(String sessionToken) {
    this.sessionToken = sessionToken;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleMapsPlacesV1AutocompletePlacesRequest googleMapsPlacesV1AutocompletePlacesRequest = (GoogleMapsPlacesV1AutocompletePlacesRequest) o;
    return Objects.equals(this.includeQueryPredictions, googleMapsPlacesV1AutocompletePlacesRequest.includeQueryPredictions) &&
        Objects.equals(this.includedPrimaryTypes, googleMapsPlacesV1AutocompletePlacesRequest.includedPrimaryTypes) &&
        Objects.equals(this.includedRegionCodes, googleMapsPlacesV1AutocompletePlacesRequest.includedRegionCodes) &&
        Objects.equals(this.input, googleMapsPlacesV1AutocompletePlacesRequest.input) &&
        Objects.equals(this.inputOffset, googleMapsPlacesV1AutocompletePlacesRequest.inputOffset) &&
        Objects.equals(this.languageCode, googleMapsPlacesV1AutocompletePlacesRequest.languageCode) &&
        Objects.equals(this.locationBias, googleMapsPlacesV1AutocompletePlacesRequest.locationBias) &&
        Objects.equals(this.locationRestriction, googleMapsPlacesV1AutocompletePlacesRequest.locationRestriction) &&
        Objects.equals(this.origin, googleMapsPlacesV1AutocompletePlacesRequest.origin) &&
        Objects.equals(this.regionCode, googleMapsPlacesV1AutocompletePlacesRequest.regionCode) &&
        Objects.equals(this.sessionToken, googleMapsPlacesV1AutocompletePlacesRequest.sessionToken);
  }

  @Override
  public int hashCode() {
    return Objects.hash(includeQueryPredictions, includedPrimaryTypes, includedRegionCodes, input, inputOffset, languageCode, locationBias, locationRestriction, origin, regionCode, sessionToken);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleMapsPlacesV1AutocompletePlacesRequest {\n");
    sb.append("    includeQueryPredictions: ").append(toIndentedString(includeQueryPredictions)).append("\n");
    sb.append("    includedPrimaryTypes: ").append(toIndentedString(includedPrimaryTypes)).append("\n");
    sb.append("    includedRegionCodes: ").append(toIndentedString(includedRegionCodes)).append("\n");
    sb.append("    input: ").append(toIndentedString(input)).append("\n");
    sb.append("    inputOffset: ").append(toIndentedString(inputOffset)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    locationBias: ").append(toIndentedString(locationBias)).append("\n");
    sb.append("    locationRestriction: ").append(toIndentedString(locationRestriction)).append("\n");
    sb.append("    origin: ").append(toIndentedString(origin)).append("\n");
    sb.append("    regionCode: ").append(toIndentedString(regionCode)).append("\n");
    sb.append("    sessionToken: ").append(toIndentedString(sessionToken)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("includeQueryPredictions");
    openapiFields.add("includedPrimaryTypes");
    openapiFields.add("includedRegionCodes");
    openapiFields.add("input");
    openapiFields.add("inputOffset");
    openapiFields.add("languageCode");
    openapiFields.add("locationBias");
    openapiFields.add("locationRestriction");
    openapiFields.add("origin");
    openapiFields.add("regionCode");
    openapiFields.add("sessionToken");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleMapsPlacesV1AutocompletePlacesRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleMapsPlacesV1AutocompletePlacesRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleMapsPlacesV1AutocompletePlacesRequest is not found in the empty JSON string", GoogleMapsPlacesV1AutocompletePlacesRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleMapsPlacesV1AutocompletePlacesRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleMapsPlacesV1AutocompletePlacesRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("includedPrimaryTypes") != null && !jsonObj.get("includedPrimaryTypes").isJsonNull() && !jsonObj.get("includedPrimaryTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `includedPrimaryTypes` to be an array in the JSON string but got `%s`", jsonObj.get("includedPrimaryTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("includedRegionCodes") != null && !jsonObj.get("includedRegionCodes").isJsonNull() && !jsonObj.get("includedRegionCodes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `includedRegionCodes` to be an array in the JSON string but got `%s`", jsonObj.get("includedRegionCodes").toString()));
      }
      if ((jsonObj.get("input") != null && !jsonObj.get("input").isJsonNull()) && !jsonObj.get("input").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `input` to be a primitive type in the JSON string but got `%s`", jsonObj.get("input").toString()));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      // validate the optional field `locationBias`
      if (jsonObj.get("locationBias") != null && !jsonObj.get("locationBias").isJsonNull()) {
        GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias.validateJsonElement(jsonObj.get("locationBias"));
      }
      // validate the optional field `locationRestriction`
      if (jsonObj.get("locationRestriction") != null && !jsonObj.get("locationRestriction").isJsonNull()) {
        GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction.validateJsonElement(jsonObj.get("locationRestriction"));
      }
      // validate the optional field `origin`
      if (jsonObj.get("origin") != null && !jsonObj.get("origin").isJsonNull()) {
        GoogleTypeLatLng.validateJsonElement(jsonObj.get("origin"));
      }
      if ((jsonObj.get("regionCode") != null && !jsonObj.get("regionCode").isJsonNull()) && !jsonObj.get("regionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `regionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("regionCode").toString()));
      }
      if ((jsonObj.get("sessionToken") != null && !jsonObj.get("sessionToken").isJsonNull()) && !jsonObj.get("sessionToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sessionToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sessionToken").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleMapsPlacesV1AutocompletePlacesRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleMapsPlacesV1AutocompletePlacesRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleMapsPlacesV1AutocompletePlacesRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleMapsPlacesV1AutocompletePlacesRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleMapsPlacesV1AutocompletePlacesRequest>() {
           @Override
           public void write(JsonWriter out, GoogleMapsPlacesV1AutocompletePlacesRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleMapsPlacesV1AutocompletePlacesRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleMapsPlacesV1AutocompletePlacesRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleMapsPlacesV1AutocompletePlacesRequest
   * @throws IOException if the JSON string is invalid with respect to GoogleMapsPlacesV1AutocompletePlacesRequest
   */
  public static GoogleMapsPlacesV1AutocompletePlacesRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleMapsPlacesV1AutocompletePlacesRequest.class);
  }

  /**
   * Convert an instance of GoogleMapsPlacesV1AutocompletePlacesRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

