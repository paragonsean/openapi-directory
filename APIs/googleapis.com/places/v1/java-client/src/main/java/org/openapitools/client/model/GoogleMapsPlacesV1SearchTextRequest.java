/*
 * Places API (New)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleMapsPlacesV1SearchTextRequestLocationBias;
import org.openapitools.client.model.GoogleMapsPlacesV1SearchTextRequestLocationRestriction;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request proto for SearchText. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:29.736799-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleMapsPlacesV1SearchTextRequest {
  public static final String SERIALIZED_NAME_INCLUDED_TYPE = "includedType";
  @SerializedName(SERIALIZED_NAME_INCLUDED_TYPE)
  private String includedType;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_LOCATION_BIAS = "locationBias";
  @SerializedName(SERIALIZED_NAME_LOCATION_BIAS)
  private GoogleMapsPlacesV1SearchTextRequestLocationBias locationBias;

  public static final String SERIALIZED_NAME_LOCATION_RESTRICTION = "locationRestriction";
  @SerializedName(SERIALIZED_NAME_LOCATION_RESTRICTION)
  private GoogleMapsPlacesV1SearchTextRequestLocationRestriction locationRestriction;

  public static final String SERIALIZED_NAME_MAX_RESULT_COUNT = "maxResultCount";
  @SerializedName(SERIALIZED_NAME_MAX_RESULT_COUNT)
  private Integer maxResultCount;

  public static final String SERIALIZED_NAME_MIN_RATING = "minRating";
  @SerializedName(SERIALIZED_NAME_MIN_RATING)
  private Double minRating;

  public static final String SERIALIZED_NAME_OPEN_NOW = "openNow";
  @SerializedName(SERIALIZED_NAME_OPEN_NOW)
  private Boolean openNow;

  /**
   * Gets or Sets priceLevels
   */
  @JsonAdapter(PriceLevelsEnum.Adapter.class)
  public enum PriceLevelsEnum {
    UNSPECIFIED("PRICE_LEVEL_UNSPECIFIED"),
    
    FREE("PRICE_LEVEL_FREE"),
    
    INEXPENSIVE("PRICE_LEVEL_INEXPENSIVE"),
    
    MODERATE("PRICE_LEVEL_MODERATE"),
    
    EXPENSIVE("PRICE_LEVEL_EXPENSIVE"),
    
    VERY_EXPENSIVE("PRICE_LEVEL_VERY_EXPENSIVE");

    private String value;

    PriceLevelsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PriceLevelsEnum fromValue(String value) {
      for (PriceLevelsEnum b : PriceLevelsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PriceLevelsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PriceLevelsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PriceLevelsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PriceLevelsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PriceLevelsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRICE_LEVELS = "priceLevels";
  @SerializedName(SERIALIZED_NAME_PRICE_LEVELS)
  private List<PriceLevelsEnum> priceLevels = new ArrayList<>();

  /**
   * How results will be ranked in the response.
   */
  @JsonAdapter(RankPreferenceEnum.Adapter.class)
  public enum RankPreferenceEnum {
    RANK_PREFERENCE_UNSPECIFIED("RANK_PREFERENCE_UNSPECIFIED"),
    
    DISTANCE("DISTANCE"),
    
    RELEVANCE("RELEVANCE");

    private String value;

    RankPreferenceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RankPreferenceEnum fromValue(String value) {
      for (RankPreferenceEnum b : RankPreferenceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RankPreferenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RankPreferenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RankPreferenceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RankPreferenceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RankPreferenceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RANK_PREFERENCE = "rankPreference";
  @SerializedName(SERIALIZED_NAME_RANK_PREFERENCE)
  private RankPreferenceEnum rankPreference;

  public static final String SERIALIZED_NAME_REGION_CODE = "regionCode";
  @SerializedName(SERIALIZED_NAME_REGION_CODE)
  private String regionCode;

  public static final String SERIALIZED_NAME_STRICT_TYPE_FILTERING = "strictTypeFiltering";
  @SerializedName(SERIALIZED_NAME_STRICT_TYPE_FILTERING)
  private Boolean strictTypeFiltering;

  public static final String SERIALIZED_NAME_TEXT_QUERY = "textQuery";
  @SerializedName(SERIALIZED_NAME_TEXT_QUERY)
  private String textQuery;

  public GoogleMapsPlacesV1SearchTextRequest() {
  }

  public GoogleMapsPlacesV1SearchTextRequest includedType(String includedType) {
    this.includedType = includedType;
    return this;
  }

  /**
   * The requested place type. Full list of types supported: https://developers.google.com/maps/documentation/places/web-service/place-types. Only support one included type.
   * @return includedType
   */
  @javax.annotation.Nullable
  public String getIncludedType() {
    return includedType;
  }

  public void setIncludedType(String includedType) {
    this.includedType = includedType;
  }


  public GoogleMapsPlacesV1SearchTextRequest languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Place details will be displayed with the preferred language if available. If the language code is unspecified or unrecognized, place details of any language may be returned, with a preference for English if such details exist. Current list of supported languages: https://developers.google.com/maps/faq#languagesupport.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public GoogleMapsPlacesV1SearchTextRequest locationBias(GoogleMapsPlacesV1SearchTextRequestLocationBias locationBias) {
    this.locationBias = locationBias;
    return this;
  }

  /**
   * Get locationBias
   * @return locationBias
   */
  @javax.annotation.Nullable
  public GoogleMapsPlacesV1SearchTextRequestLocationBias getLocationBias() {
    return locationBias;
  }

  public void setLocationBias(GoogleMapsPlacesV1SearchTextRequestLocationBias locationBias) {
    this.locationBias = locationBias;
  }


  public GoogleMapsPlacesV1SearchTextRequest locationRestriction(GoogleMapsPlacesV1SearchTextRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
    return this;
  }

  /**
   * Get locationRestriction
   * @return locationRestriction
   */
  @javax.annotation.Nullable
  public GoogleMapsPlacesV1SearchTextRequestLocationRestriction getLocationRestriction() {
    return locationRestriction;
  }

  public void setLocationRestriction(GoogleMapsPlacesV1SearchTextRequestLocationRestriction locationRestriction) {
    this.locationRestriction = locationRestriction;
  }


  public GoogleMapsPlacesV1SearchTextRequest maxResultCount(Integer maxResultCount) {
    this.maxResultCount = maxResultCount;
    return this;
  }

  /**
   * Maximum number of results to return. It must be between 1 and 20, inclusively. The default is 20. If the number is unset, it falls back to the upper limit. If the number is set to negative or exceeds the upper limit, an INVALID_ARGUMENT error is returned.
   * @return maxResultCount
   */
  @javax.annotation.Nullable
  public Integer getMaxResultCount() {
    return maxResultCount;
  }

  public void setMaxResultCount(Integer maxResultCount) {
    this.maxResultCount = maxResultCount;
  }


  public GoogleMapsPlacesV1SearchTextRequest minRating(Double minRating) {
    this.minRating = minRating;
    return this;
  }

  /**
   * Filter out results whose average user rating is strictly less than this limit. A valid value must be a float between 0 and 5 (inclusively) at a 0.5 cadence i.e. [0, 0.5, 1.0, ... , 5.0] inclusively. The input rating will round up to the nearest 0.5(ceiling). For instance, a rating of 0.6 will eliminate all results with a less than 1.0 rating.
   * @return minRating
   */
  @javax.annotation.Nullable
  public Double getMinRating() {
    return minRating;
  }

  public void setMinRating(Double minRating) {
    this.minRating = minRating;
  }


  public GoogleMapsPlacesV1SearchTextRequest openNow(Boolean openNow) {
    this.openNow = openNow;
    return this;
  }

  /**
   * Used to restrict the search to places that are currently open. The default is false.
   * @return openNow
   */
  @javax.annotation.Nullable
  public Boolean getOpenNow() {
    return openNow;
  }

  public void setOpenNow(Boolean openNow) {
    this.openNow = openNow;
  }


  public GoogleMapsPlacesV1SearchTextRequest priceLevels(List<PriceLevelsEnum> priceLevels) {
    this.priceLevels = priceLevels;
    return this;
  }

  public GoogleMapsPlacesV1SearchTextRequest addPriceLevelsItem(PriceLevelsEnum priceLevelsItem) {
    if (this.priceLevels == null) {
      this.priceLevels = new ArrayList<>();
    }
    this.priceLevels.add(priceLevelsItem);
    return this;
  }

  /**
   * Used to restrict the search to places that are marked as certain price levels. Users can choose any combinations of price levels. Default to select all price levels.
   * @return priceLevels
   */
  @javax.annotation.Nullable
  public List<PriceLevelsEnum> getPriceLevels() {
    return priceLevels;
  }

  public void setPriceLevels(List<PriceLevelsEnum> priceLevels) {
    this.priceLevels = priceLevels;
  }


  public GoogleMapsPlacesV1SearchTextRequest rankPreference(RankPreferenceEnum rankPreference) {
    this.rankPreference = rankPreference;
    return this;
  }

  /**
   * How results will be ranked in the response.
   * @return rankPreference
   */
  @javax.annotation.Nullable
  public RankPreferenceEnum getRankPreference() {
    return rankPreference;
  }

  public void setRankPreference(RankPreferenceEnum rankPreference) {
    this.rankPreference = rankPreference;
  }


  public GoogleMapsPlacesV1SearchTextRequest regionCode(String regionCode) {
    this.regionCode = regionCode;
    return this;
  }

  /**
   * The Unicode country/region code (CLDR) of the location where the request is coming from. This parameter is used to display the place details, like region-specific place name, if available. The parameter can affect results based on applicable law. For more information, see https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html. Note that 3-digit region codes are not currently supported.
   * @return regionCode
   */
  @javax.annotation.Nullable
  public String getRegionCode() {
    return regionCode;
  }

  public void setRegionCode(String regionCode) {
    this.regionCode = regionCode;
  }


  public GoogleMapsPlacesV1SearchTextRequest strictTypeFiltering(Boolean strictTypeFiltering) {
    this.strictTypeFiltering = strictTypeFiltering;
    return this;
  }

  /**
   * Used to set strict type filtering for included_type. If set to true, only results of the same type will be returned. Default to false.
   * @return strictTypeFiltering
   */
  @javax.annotation.Nullable
  public Boolean getStrictTypeFiltering() {
    return strictTypeFiltering;
  }

  public void setStrictTypeFiltering(Boolean strictTypeFiltering) {
    this.strictTypeFiltering = strictTypeFiltering;
  }


  public GoogleMapsPlacesV1SearchTextRequest textQuery(String textQuery) {
    this.textQuery = textQuery;
    return this;
  }

  /**
   * Required. The text query for textual search.
   * @return textQuery
   */
  @javax.annotation.Nullable
  public String getTextQuery() {
    return textQuery;
  }

  public void setTextQuery(String textQuery) {
    this.textQuery = textQuery;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleMapsPlacesV1SearchTextRequest googleMapsPlacesV1SearchTextRequest = (GoogleMapsPlacesV1SearchTextRequest) o;
    return Objects.equals(this.includedType, googleMapsPlacesV1SearchTextRequest.includedType) &&
        Objects.equals(this.languageCode, googleMapsPlacesV1SearchTextRequest.languageCode) &&
        Objects.equals(this.locationBias, googleMapsPlacesV1SearchTextRequest.locationBias) &&
        Objects.equals(this.locationRestriction, googleMapsPlacesV1SearchTextRequest.locationRestriction) &&
        Objects.equals(this.maxResultCount, googleMapsPlacesV1SearchTextRequest.maxResultCount) &&
        Objects.equals(this.minRating, googleMapsPlacesV1SearchTextRequest.minRating) &&
        Objects.equals(this.openNow, googleMapsPlacesV1SearchTextRequest.openNow) &&
        Objects.equals(this.priceLevels, googleMapsPlacesV1SearchTextRequest.priceLevels) &&
        Objects.equals(this.rankPreference, googleMapsPlacesV1SearchTextRequest.rankPreference) &&
        Objects.equals(this.regionCode, googleMapsPlacesV1SearchTextRequest.regionCode) &&
        Objects.equals(this.strictTypeFiltering, googleMapsPlacesV1SearchTextRequest.strictTypeFiltering) &&
        Objects.equals(this.textQuery, googleMapsPlacesV1SearchTextRequest.textQuery);
  }

  @Override
  public int hashCode() {
    return Objects.hash(includedType, languageCode, locationBias, locationRestriction, maxResultCount, minRating, openNow, priceLevels, rankPreference, regionCode, strictTypeFiltering, textQuery);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleMapsPlacesV1SearchTextRequest {\n");
    sb.append("    includedType: ").append(toIndentedString(includedType)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    locationBias: ").append(toIndentedString(locationBias)).append("\n");
    sb.append("    locationRestriction: ").append(toIndentedString(locationRestriction)).append("\n");
    sb.append("    maxResultCount: ").append(toIndentedString(maxResultCount)).append("\n");
    sb.append("    minRating: ").append(toIndentedString(minRating)).append("\n");
    sb.append("    openNow: ").append(toIndentedString(openNow)).append("\n");
    sb.append("    priceLevels: ").append(toIndentedString(priceLevels)).append("\n");
    sb.append("    rankPreference: ").append(toIndentedString(rankPreference)).append("\n");
    sb.append("    regionCode: ").append(toIndentedString(regionCode)).append("\n");
    sb.append("    strictTypeFiltering: ").append(toIndentedString(strictTypeFiltering)).append("\n");
    sb.append("    textQuery: ").append(toIndentedString(textQuery)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("includedType");
    openapiFields.add("languageCode");
    openapiFields.add("locationBias");
    openapiFields.add("locationRestriction");
    openapiFields.add("maxResultCount");
    openapiFields.add("minRating");
    openapiFields.add("openNow");
    openapiFields.add("priceLevels");
    openapiFields.add("rankPreference");
    openapiFields.add("regionCode");
    openapiFields.add("strictTypeFiltering");
    openapiFields.add("textQuery");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleMapsPlacesV1SearchTextRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleMapsPlacesV1SearchTextRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleMapsPlacesV1SearchTextRequest is not found in the empty JSON string", GoogleMapsPlacesV1SearchTextRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleMapsPlacesV1SearchTextRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleMapsPlacesV1SearchTextRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("includedType") != null && !jsonObj.get("includedType").isJsonNull()) && !jsonObj.get("includedType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `includedType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("includedType").toString()));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      // validate the optional field `locationBias`
      if (jsonObj.get("locationBias") != null && !jsonObj.get("locationBias").isJsonNull()) {
        GoogleMapsPlacesV1SearchTextRequestLocationBias.validateJsonElement(jsonObj.get("locationBias"));
      }
      // validate the optional field `locationRestriction`
      if (jsonObj.get("locationRestriction") != null && !jsonObj.get("locationRestriction").isJsonNull()) {
        GoogleMapsPlacesV1SearchTextRequestLocationRestriction.validateJsonElement(jsonObj.get("locationRestriction"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("priceLevels") != null && !jsonObj.get("priceLevels").isJsonNull() && !jsonObj.get("priceLevels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceLevels` to be an array in the JSON string but got `%s`", jsonObj.get("priceLevels").toString()));
      }
      if ((jsonObj.get("rankPreference") != null && !jsonObj.get("rankPreference").isJsonNull()) && !jsonObj.get("rankPreference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rankPreference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rankPreference").toString()));
      }
      // validate the optional field `rankPreference`
      if (jsonObj.get("rankPreference") != null && !jsonObj.get("rankPreference").isJsonNull()) {
        RankPreferenceEnum.validateJsonElement(jsonObj.get("rankPreference"));
      }
      if ((jsonObj.get("regionCode") != null && !jsonObj.get("regionCode").isJsonNull()) && !jsonObj.get("regionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `regionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("regionCode").toString()));
      }
      if ((jsonObj.get("textQuery") != null && !jsonObj.get("textQuery").isJsonNull()) && !jsonObj.get("textQuery").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `textQuery` to be a primitive type in the JSON string but got `%s`", jsonObj.get("textQuery").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleMapsPlacesV1SearchTextRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleMapsPlacesV1SearchTextRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleMapsPlacesV1SearchTextRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleMapsPlacesV1SearchTextRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleMapsPlacesV1SearchTextRequest>() {
           @Override
           public void write(JsonWriter out, GoogleMapsPlacesV1SearchTextRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleMapsPlacesV1SearchTextRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleMapsPlacesV1SearchTextRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleMapsPlacesV1SearchTextRequest
   * @throws IOException if the JSON string is invalid with respect to GoogleMapsPlacesV1SearchTextRequest
   */
  public static GoogleMapsPlacesV1SearchTextRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleMapsPlacesV1SearchTextRequest.class);
  }

  /**
   * Convert an instance of GoogleMapsPlacesV1SearchTextRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

