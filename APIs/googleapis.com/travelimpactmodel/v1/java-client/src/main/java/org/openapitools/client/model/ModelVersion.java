/*
 * Travel Impact Model API
 * Travel Impact Model API lets you query travel carbon emission estimates.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Travel Impact Model version. For more information about the model versioning see https://github.com/google/travel-impact-model/#versioning.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:06.209182-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ModelVersion {
  public static final String SERIALIZED_NAME_DATED = "dated";
  @SerializedName(SERIALIZED_NAME_DATED)
  private String dated;

  public static final String SERIALIZED_NAME_MAJOR = "major";
  @SerializedName(SERIALIZED_NAME_MAJOR)
  private Integer major;

  public static final String SERIALIZED_NAME_MINOR = "minor";
  @SerializedName(SERIALIZED_NAME_MINOR)
  private Integer minor;

  public static final String SERIALIZED_NAME_PATCH = "patch";
  @SerializedName(SERIALIZED_NAME_PATCH)
  private Integer patch;

  public ModelVersion() {
  }

  public ModelVersion dated(String dated) {
    this.dated = dated;
    return this;
  }

  /**
   * Dated versions: Model datasets are recreated with refreshed input data but no change to the algorithms regularly.
   * @return dated
   */
  @javax.annotation.Nullable
  public String getDated() {
    return dated;
  }

  public void setDated(String dated) {
    this.dated = dated;
  }


  public ModelVersion major(Integer major) {
    this.major = major;
    return this;
  }

  /**
   * Major versions: Major changes to methodology (e.g. adding new data sources to the model that lead to major output changes). Such changes will be infrequent and announced well in advance. Might involve API version changes, which will respect guidelines in https://cloud.google.com/endpoints/docs/openapi/versioning-an-api#backwards-incompatible
   * @return major
   */
  @javax.annotation.Nullable
  public Integer getMajor() {
    return major;
  }

  public void setMajor(Integer major) {
    this.major = major;
  }


  public ModelVersion minor(Integer minor) {
    this.minor = minor;
    return this;
  }

  /**
   * Minor versions: Changes to the model that, while being consistent across schema versions, change the model parameters or implementation.
   * @return minor
   */
  @javax.annotation.Nullable
  public Integer getMinor() {
    return minor;
  }

  public void setMinor(Integer minor) {
    this.minor = minor;
  }


  public ModelVersion patch(Integer patch) {
    this.patch = patch;
    return this;
  }

  /**
   * Patch versions: Implementation changes meant to address bugs or inaccuracies in the model implementation.
   * @return patch
   */
  @javax.annotation.Nullable
  public Integer getPatch() {
    return patch;
  }

  public void setPatch(Integer patch) {
    this.patch = patch;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelVersion modelVersion = (ModelVersion) o;
    return Objects.equals(this.dated, modelVersion.dated) &&
        Objects.equals(this.major, modelVersion.major) &&
        Objects.equals(this.minor, modelVersion.minor) &&
        Objects.equals(this.patch, modelVersion.patch);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dated, major, minor, patch);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ModelVersion {\n");
    sb.append("    dated: ").append(toIndentedString(dated)).append("\n");
    sb.append("    major: ").append(toIndentedString(major)).append("\n");
    sb.append("    minor: ").append(toIndentedString(minor)).append("\n");
    sb.append("    patch: ").append(toIndentedString(patch)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dated");
    openapiFields.add("major");
    openapiFields.add("minor");
    openapiFields.add("patch");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ModelVersion
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ModelVersion.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ModelVersion is not found in the empty JSON string", ModelVersion.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ModelVersion.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ModelVersion` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("dated") != null && !jsonObj.get("dated").isJsonNull()) && !jsonObj.get("dated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dated").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ModelVersion.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ModelVersion' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ModelVersion> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ModelVersion.class));

       return (TypeAdapter<T>) new TypeAdapter<ModelVersion>() {
           @Override
           public void write(JsonWriter out, ModelVersion value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ModelVersion read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ModelVersion given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ModelVersion
   * @throws IOException if the JSON string is invalid with respect to ModelVersion
   */
  public static ModelVersion fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ModelVersion.class);
  }

  /**
   * Convert an instance of ModelVersion to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

