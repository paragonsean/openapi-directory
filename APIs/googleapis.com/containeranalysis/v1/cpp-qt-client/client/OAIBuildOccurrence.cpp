/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBuildOccurrence.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIBuildOccurrence::OAIBuildOccurrence(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIBuildOccurrence::OAIBuildOccurrence() {
    this->initializeModel();
}

OAIBuildOccurrence::~OAIBuildOccurrence() {}

void OAIBuildOccurrence::initializeModel() {

    m_in_toto_slsa_provenance_v1_isSet = false;
    m_in_toto_slsa_provenance_v1_isValid = false;

    m_intoto_provenance_isSet = false;
    m_intoto_provenance_isValid = false;

    m_intoto_statement_isSet = false;
    m_intoto_statement_isValid = false;

    m_provenance_isSet = false;
    m_provenance_isValid = false;

    m_provenance_bytes_isSet = false;
    m_provenance_bytes_isValid = false;
}

void OAIBuildOccurrence::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIBuildOccurrence::fromJsonObject(QJsonObject json) {

    m_in_toto_slsa_provenance_v1_isValid = ::OpenAPI::fromJsonValue(m_in_toto_slsa_provenance_v1, json[QString("inTotoSlsaProvenanceV1")]);
    m_in_toto_slsa_provenance_v1_isSet = !json[QString("inTotoSlsaProvenanceV1")].isNull() && m_in_toto_slsa_provenance_v1_isValid;

    m_intoto_provenance_isValid = ::OpenAPI::fromJsonValue(m_intoto_provenance, json[QString("intotoProvenance")]);
    m_intoto_provenance_isSet = !json[QString("intotoProvenance")].isNull() && m_intoto_provenance_isValid;

    m_intoto_statement_isValid = ::OpenAPI::fromJsonValue(m_intoto_statement, json[QString("intotoStatement")]);
    m_intoto_statement_isSet = !json[QString("intotoStatement")].isNull() && m_intoto_statement_isValid;

    m_provenance_isValid = ::OpenAPI::fromJsonValue(m_provenance, json[QString("provenance")]);
    m_provenance_isSet = !json[QString("provenance")].isNull() && m_provenance_isValid;

    m_provenance_bytes_isValid = ::OpenAPI::fromJsonValue(m_provenance_bytes, json[QString("provenanceBytes")]);
    m_provenance_bytes_isSet = !json[QString("provenanceBytes")].isNull() && m_provenance_bytes_isValid;
}

QString OAIBuildOccurrence::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIBuildOccurrence::asJsonObject() const {
    QJsonObject obj;
    if (m_in_toto_slsa_provenance_v1.isSet()) {
        obj.insert(QString("inTotoSlsaProvenanceV1"), ::OpenAPI::toJsonValue(m_in_toto_slsa_provenance_v1));
    }
    if (m_intoto_provenance.isSet()) {
        obj.insert(QString("intotoProvenance"), ::OpenAPI::toJsonValue(m_intoto_provenance));
    }
    if (m_intoto_statement.isSet()) {
        obj.insert(QString("intotoStatement"), ::OpenAPI::toJsonValue(m_intoto_statement));
    }
    if (m_provenance.isSet()) {
        obj.insert(QString("provenance"), ::OpenAPI::toJsonValue(m_provenance));
    }
    if (m_provenance_bytes_isSet) {
        obj.insert(QString("provenanceBytes"), ::OpenAPI::toJsonValue(m_provenance_bytes));
    }
    return obj;
}

OAIInTotoSlsaProvenanceV1 OAIBuildOccurrence::getInTotoSlsaProvenanceV1() const {
    return m_in_toto_slsa_provenance_v1;
}
void OAIBuildOccurrence::setInTotoSlsaProvenanceV1(const OAIInTotoSlsaProvenanceV1 &in_toto_slsa_provenance_v1) {
    m_in_toto_slsa_provenance_v1 = in_toto_slsa_provenance_v1;
    m_in_toto_slsa_provenance_v1_isSet = true;
}

bool OAIBuildOccurrence::is_in_toto_slsa_provenance_v1_Set() const{
    return m_in_toto_slsa_provenance_v1_isSet;
}

bool OAIBuildOccurrence::is_in_toto_slsa_provenance_v1_Valid() const{
    return m_in_toto_slsa_provenance_v1_isValid;
}

OAIInTotoProvenance OAIBuildOccurrence::getIntotoProvenance() const {
    return m_intoto_provenance;
}
void OAIBuildOccurrence::setIntotoProvenance(const OAIInTotoProvenance &intoto_provenance) {
    m_intoto_provenance = intoto_provenance;
    m_intoto_provenance_isSet = true;
}

bool OAIBuildOccurrence::is_intoto_provenance_Set() const{
    return m_intoto_provenance_isSet;
}

bool OAIBuildOccurrence::is_intoto_provenance_Valid() const{
    return m_intoto_provenance_isValid;
}

OAIInTotoStatement OAIBuildOccurrence::getIntotoStatement() const {
    return m_intoto_statement;
}
void OAIBuildOccurrence::setIntotoStatement(const OAIInTotoStatement &intoto_statement) {
    m_intoto_statement = intoto_statement;
    m_intoto_statement_isSet = true;
}

bool OAIBuildOccurrence::is_intoto_statement_Set() const{
    return m_intoto_statement_isSet;
}

bool OAIBuildOccurrence::is_intoto_statement_Valid() const{
    return m_intoto_statement_isValid;
}

OAIBuildProvenance OAIBuildOccurrence::getProvenance() const {
    return m_provenance;
}
void OAIBuildOccurrence::setProvenance(const OAIBuildProvenance &provenance) {
    m_provenance = provenance;
    m_provenance_isSet = true;
}

bool OAIBuildOccurrence::is_provenance_Set() const{
    return m_provenance_isSet;
}

bool OAIBuildOccurrence::is_provenance_Valid() const{
    return m_provenance_isValid;
}

QString OAIBuildOccurrence::getProvenanceBytes() const {
    return m_provenance_bytes;
}
void OAIBuildOccurrence::setProvenanceBytes(const QString &provenance_bytes) {
    m_provenance_bytes = provenance_bytes;
    m_provenance_bytes_isSet = true;
}

bool OAIBuildOccurrence::is_provenance_bytes_Set() const{
    return m_provenance_bytes_isSet;
}

bool OAIBuildOccurrence::is_provenance_bytes_Valid() const{
    return m_provenance_bytes_isValid;
}

bool OAIBuildOccurrence::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_in_toto_slsa_provenance_v1.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_intoto_provenance.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_intoto_statement.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_provenance.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_provenance_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIBuildOccurrence::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
