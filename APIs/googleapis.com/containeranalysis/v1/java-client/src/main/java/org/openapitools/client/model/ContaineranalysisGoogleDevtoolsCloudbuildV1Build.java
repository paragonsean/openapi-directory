/*
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1BuildWarning;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1Results;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1Secret;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1Source;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance;
import org.openapitools.client.model.ContaineranalysisGoogleDevtoolsCloudbuildV1TimeSpan;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A build resource in the Cloud Build API. At a high level, a &#x60;Build&#x60; describes where to find source code, how to build it (for example, the builder image to run on the source), and where to store the built artifacts. Fields can include the following variables, which will be expanded when the build is created: - $PROJECT_ID: the project ID of the build. - $PROJECT_NUMBER: the project number of the build. - $LOCATION: the location/region of the build. - $BUILD_ID: the autogenerated ID of the build. - $REPO_NAME: the source repository name specified by RepoSource. - $BRANCH_NAME: the branch name specified by RepoSource. - $TAG_NAME: the tag name specified by RepoSource. - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or resolved from the specified branch or tag. - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:38.234919-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ContaineranalysisGoogleDevtoolsCloudbuildV1Build {
  public static final String SERIALIZED_NAME_APPROVAL = "approval";
  @SerializedName(SERIALIZED_NAME_APPROVAL)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval approval;

  public static final String SERIALIZED_NAME_ARTIFACTS = "artifacts";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts artifacts;

  public static final String SERIALIZED_NAME_AVAILABLE_SECRETS = "availableSecrets";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_SECRETS)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets availableSecrets;

  public static final String SERIALIZED_NAME_BUILD_TRIGGER_ID = "buildTriggerId";
  @SerializedName(SERIALIZED_NAME_BUILD_TRIGGER_ID)
  private String buildTriggerId;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_FAILURE_INFO = "failureInfo";
  @SerializedName(SERIALIZED_NAME_FAILURE_INFO)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo failureInfo;

  public static final String SERIALIZED_NAME_FINISH_TIME = "finishTime";
  @SerializedName(SERIALIZED_NAME_FINISH_TIME)
  private String finishTime;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMAGES = "images";
  @SerializedName(SERIALIZED_NAME_IMAGES)
  private List<String> images = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOG_URL = "logUrl";
  @SerializedName(SERIALIZED_NAME_LOG_URL)
  private String logUrl;

  public static final String SERIALIZED_NAME_LOGS_BUCKET = "logsBucket";
  @SerializedName(SERIALIZED_NAME_LOGS_BUCKET)
  private String logsBucket;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions options;

  public static final String SERIALIZED_NAME_PROJECT_ID = "projectId";
  @SerializedName(SERIALIZED_NAME_PROJECT_ID)
  private String projectId;

  public static final String SERIALIZED_NAME_QUEUE_TTL = "queueTtl";
  @SerializedName(SERIALIZED_NAME_QUEUE_TTL)
  private String queueTtl;

  public static final String SERIALIZED_NAME_RESULTS = "results";
  @SerializedName(SERIALIZED_NAME_RESULTS)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1Results results;

  public static final String SERIALIZED_NAME_SECRETS = "secrets";
  @SerializedName(SERIALIZED_NAME_SECRETS)
  private List<ContaineranalysisGoogleDevtoolsCloudbuildV1Secret> secrets = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1Source source;

  public static final String SERIALIZED_NAME_SOURCE_PROVENANCE = "sourceProvenance";
  @SerializedName(SERIALIZED_NAME_SOURCE_PROVENANCE)
  private ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance sourceProvenance;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  /**
   * Output only. Status of the build.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    STATUS_UNKNOWN("STATUS_UNKNOWN"),
    
    PENDING("PENDING"),
    
    QUEUED("QUEUED"),
    
    WORKING("WORKING"),
    
    SUCCESS("SUCCESS"),
    
    FAILURE("FAILURE"),
    
    INTERNAL_ERROR("INTERNAL_ERROR"),
    
    TIMEOUT("TIMEOUT"),
    
    CANCELLED("CANCELLED"),
    
    EXPIRED("EXPIRED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_STATUS_DETAIL = "statusDetail";
  @SerializedName(SERIALIZED_NAME_STATUS_DETAIL)
  private String statusDetail;

  public static final String SERIALIZED_NAME_STEPS = "steps";
  @SerializedName(SERIALIZED_NAME_STEPS)
  private List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep> steps = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBSTITUTIONS = "substitutions";
  @SerializedName(SERIALIZED_NAME_SUBSTITUTIONS)
  private Map<String, String> substitutions = new HashMap<>();

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private String timeout;

  public static final String SERIALIZED_NAME_TIMING = "timing";
  @SerializedName(SERIALIZED_NAME_TIMING)
  private Map<String, ContaineranalysisGoogleDevtoolsCloudbuildV1TimeSpan> timing = new HashMap<>();

  public static final String SERIALIZED_NAME_WARNINGS = "warnings";
  @SerializedName(SERIALIZED_NAME_WARNINGS)
  private List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildWarning> warnings = new ArrayList<>();

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build() {
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build(
     String buildTriggerId, 
     String createTime, 
     String finishTime, 
     String id, 
     String logUrl, 
     String name, 
     String projectId, 
     String startTime, 
     StatusEnum status, 
     String statusDetail, 
     Map<String, ContaineranalysisGoogleDevtoolsCloudbuildV1TimeSpan> timing, 
     List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildWarning> warnings
  ) {
    this();
    this.buildTriggerId = buildTriggerId;
    this.createTime = createTime;
    this.finishTime = finishTime;
    this.id = id;
    this.logUrl = logUrl;
    this.name = name;
    this.projectId = projectId;
    this.startTime = startTime;
    this.status = status;
    this.statusDetail = statusDetail;
    this.timing = timing;
    this.warnings = warnings;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build approval(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval approval) {
    this.approval = approval;
    return this;
  }

  /**
   * Get approval
   * @return approval
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval getApproval() {
    return approval;
  }

  public void setApproval(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval approval) {
    this.approval = approval;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build artifacts(ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts artifacts) {
    this.artifacts = artifacts;
    return this;
  }

  /**
   * Get artifacts
   * @return artifacts
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts getArtifacts() {
    return artifacts;
  }

  public void setArtifacts(ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts artifacts) {
    this.artifacts = artifacts;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build availableSecrets(ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets availableSecrets) {
    this.availableSecrets = availableSecrets;
    return this;
  }

  /**
   * Get availableSecrets
   * @return availableSecrets
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets getAvailableSecrets() {
    return availableSecrets;
  }

  public void setAvailableSecrets(ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets availableSecrets) {
    this.availableSecrets = availableSecrets;
  }


  /**
   * Output only. The ID of the &#x60;BuildTrigger&#x60; that triggered this build, if it was triggered automatically.
   * @return buildTriggerId
   */
  @javax.annotation.Nullable
  public String getBuildTriggerId() {
    return buildTriggerId;
  }



  /**
   * Output only. Time at which the request to create the build was received.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build failureInfo(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo failureInfo) {
    this.failureInfo = failureInfo;
    return this;
  }

  /**
   * Get failureInfo
   * @return failureInfo
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo getFailureInfo() {
    return failureInfo;
  }

  public void setFailureInfo(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo failureInfo) {
    this.failureInfo = failureInfo;
  }


  /**
   * Output only. Time at which execution of the build was finished. The difference between finish_time and start_time is the duration of the build&#39;s execution.
   * @return finishTime
   */
  @javax.annotation.Nullable
  public String getFinishTime() {
    return finishTime;
  }



  /**
   * Output only. Unique identifier of the build.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build images(List<String> images) {
    this.images = images;
    return this;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build addImagesItem(String imagesItem) {
    if (this.images == null) {
      this.images = new ArrayList<>();
    }
    this.images.add(imagesItem);
    return this;
  }

  /**
   * A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account&#39;s credentials. The digests of the pushed images will be stored in the &#x60;Build&#x60; resource&#39;s results field. If any of the images fail to be pushed, the build status is marked &#x60;FAILURE&#x60;.
   * @return images
   */
  @javax.annotation.Nullable
  public List<String> getImages() {
    return images;
  }

  public void setImages(List<String> images) {
    this.images = images;
  }


  /**
   * Output only. URL to logs for this build in Google Cloud Console.
   * @return logUrl
   */
  @javax.annotation.Nullable
  public String getLogUrl() {
    return logUrl;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build logsBucket(String logsBucket) {
    this.logsBucket = logsBucket;
    return this;
  }

  /**
   * Cloud Storage bucket where logs should be written (see [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)). Logs file names will be of the format &#x60;${logs_bucket}/log-${build_id}.txt&#x60;.
   * @return logsBucket
   */
  @javax.annotation.Nullable
  public String getLogsBucket() {
    return logsBucket;
  }

  public void setLogsBucket(String logsBucket) {
    this.logsBucket = logsBucket;
  }


  /**
   * Output only. The &#39;Build&#39; name with format: &#x60;projects/{project}/locations/{location}/builds/{build}&#x60;, where {build} is a unique identifier generated by the service.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build options(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions options) {
    this.options = options;
    return this;
  }

  /**
   * Get options
   * @return options
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions getOptions() {
    return options;
  }

  public void setOptions(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions options) {
    this.options = options;
  }


  /**
   * Output only. ID of the project.
   * @return projectId
   */
  @javax.annotation.Nullable
  public String getProjectId() {
    return projectId;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build queueTtl(String queueTtl) {
    this.queueTtl = queueTtl;
    return this;
  }

  /**
   * TTL in queue for this build. If provided and the build is enqueued longer than this value, the build will expire and the build status will be &#x60;EXPIRED&#x60;. The TTL starts ticking from create_time.
   * @return queueTtl
   */
  @javax.annotation.Nullable
  public String getQueueTtl() {
    return queueTtl;
  }

  public void setQueueTtl(String queueTtl) {
    this.queueTtl = queueTtl;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build results(ContaineranalysisGoogleDevtoolsCloudbuildV1Results results) {
    this.results = results;
    return this;
  }

  /**
   * Get results
   * @return results
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1Results getResults() {
    return results;
  }

  public void setResults(ContaineranalysisGoogleDevtoolsCloudbuildV1Results results) {
    this.results = results;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build secrets(List<ContaineranalysisGoogleDevtoolsCloudbuildV1Secret> secrets) {
    this.secrets = secrets;
    return this;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build addSecretsItem(ContaineranalysisGoogleDevtoolsCloudbuildV1Secret secretsItem) {
    if (this.secrets == null) {
      this.secrets = new ArrayList<>();
    }
    this.secrets.add(secretsItem);
    return this;
  }

  /**
   * Secrets to decrypt using Cloud Key Management Service. Note: Secret Manager is the recommended technique for managing sensitive data with Cloud Build. Use &#x60;available_secrets&#x60; to configure builds to access secrets from Secret Manager. For instructions, see: https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets
   * @return secrets
   */
  @javax.annotation.Nullable
  public List<ContaineranalysisGoogleDevtoolsCloudbuildV1Secret> getSecrets() {
    return secrets;
  }

  public void setSecrets(List<ContaineranalysisGoogleDevtoolsCloudbuildV1Secret> secrets) {
    this.secrets = secrets;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * IAM service account whose credentials will be used at build runtime. Must be of the format &#x60;projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}&#x60;. ACCOUNT can be email address or uniqueId of the service account. 
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build source(ContaineranalysisGoogleDevtoolsCloudbuildV1Source source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1Source getSource() {
    return source;
  }

  public void setSource(ContaineranalysisGoogleDevtoolsCloudbuildV1Source source) {
    this.source = source;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build sourceProvenance(ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance sourceProvenance) {
    this.sourceProvenance = sourceProvenance;
    return this;
  }

  /**
   * Get sourceProvenance
   * @return sourceProvenance
   */
  @javax.annotation.Nullable
  public ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance getSourceProvenance() {
    return sourceProvenance;
  }

  public void setSourceProvenance(ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance sourceProvenance) {
    this.sourceProvenance = sourceProvenance;
  }


  /**
   * Output only. Time at which execution of the build was started.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }



  /**
   * Output only. Status of the build.
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }



  /**
   * Output only. Customer-readable message about the current status.
   * @return statusDetail
   */
  @javax.annotation.Nullable
  public String getStatusDetail() {
    return statusDetail;
  }



  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build steps(List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep> steps) {
    this.steps = steps;
    return this;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build addStepsItem(ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep stepsItem) {
    if (this.steps == null) {
      this.steps = new ArrayList<>();
    }
    this.steps.add(stepsItem);
    return this;
  }

  /**
   * Required. The operations to be performed on the workspace.
   * @return steps
   */
  @javax.annotation.Nullable
  public List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep> getSteps() {
    return steps;
  }

  public void setSteps(List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep> steps) {
    this.steps = steps;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build substitutions(Map<String, String> substitutions) {
    this.substitutions = substitutions;
    return this;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build putSubstitutionsItem(String key, String substitutionsItem) {
    if (this.substitutions == null) {
      this.substitutions = new HashMap<>();
    }
    this.substitutions.put(key, substitutionsItem);
    return this;
  }

  /**
   * Substitutions data for &#x60;Build&#x60; resource.
   * @return substitutions
   */
  @javax.annotation.Nullable
  public Map<String, String> getSubstitutions() {
    return substitutions;
  }

  public void setSubstitutions(Map<String, String> substitutions) {
    this.substitutions = substitutions;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Tags for annotation of a &#x60;Build&#x60;. These are not docker tags.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }


  public ContaineranalysisGoogleDevtoolsCloudbuildV1Build timeout(String timeout) {
    this.timeout = timeout;
    return this;
  }

  /**
   * Amount of time that this build should be allowed to run, to second granularity. If this amount of time elapses, work on the build will cease and the build status will be &#x60;TIMEOUT&#x60;. &#x60;timeout&#x60; starts ticking from &#x60;startTime&#x60;. Default time is 60 minutes.
   * @return timeout
   */
  @javax.annotation.Nullable
  public String getTimeout() {
    return timeout;
  }

  public void setTimeout(String timeout) {
    this.timeout = timeout;
  }


  /**
   * Output only. Stores timing information for phases of the build. Valid keys are: * BUILD: time to execute all build steps. * PUSH: time to push all artifacts including docker images and non docker artifacts. * FETCHSOURCE: time to fetch source. * SETUPBUILD: time to set up build. If the build does not specify source or images, these keys will not be included.
   * @return timing
   */
  @javax.annotation.Nullable
  public Map<String, ContaineranalysisGoogleDevtoolsCloudbuildV1TimeSpan> getTiming() {
    return timing;
  }



  /**
   * Output only. Non-fatal problems encountered during the execution of the build.
   * @return warnings
   */
  @javax.annotation.Nullable
  public List<ContaineranalysisGoogleDevtoolsCloudbuildV1BuildWarning> getWarnings() {
    return warnings;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ContaineranalysisGoogleDevtoolsCloudbuildV1Build containeranalysisGoogleDevtoolsCloudbuildV1Build = (ContaineranalysisGoogleDevtoolsCloudbuildV1Build) o;
    return Objects.equals(this.approval, containeranalysisGoogleDevtoolsCloudbuildV1Build.approval) &&
        Objects.equals(this.artifacts, containeranalysisGoogleDevtoolsCloudbuildV1Build.artifacts) &&
        Objects.equals(this.availableSecrets, containeranalysisGoogleDevtoolsCloudbuildV1Build.availableSecrets) &&
        Objects.equals(this.buildTriggerId, containeranalysisGoogleDevtoolsCloudbuildV1Build.buildTriggerId) &&
        Objects.equals(this.createTime, containeranalysisGoogleDevtoolsCloudbuildV1Build.createTime) &&
        Objects.equals(this.failureInfo, containeranalysisGoogleDevtoolsCloudbuildV1Build.failureInfo) &&
        Objects.equals(this.finishTime, containeranalysisGoogleDevtoolsCloudbuildV1Build.finishTime) &&
        Objects.equals(this.id, containeranalysisGoogleDevtoolsCloudbuildV1Build.id) &&
        Objects.equals(this.images, containeranalysisGoogleDevtoolsCloudbuildV1Build.images) &&
        Objects.equals(this.logUrl, containeranalysisGoogleDevtoolsCloudbuildV1Build.logUrl) &&
        Objects.equals(this.logsBucket, containeranalysisGoogleDevtoolsCloudbuildV1Build.logsBucket) &&
        Objects.equals(this.name, containeranalysisGoogleDevtoolsCloudbuildV1Build.name) &&
        Objects.equals(this.options, containeranalysisGoogleDevtoolsCloudbuildV1Build.options) &&
        Objects.equals(this.projectId, containeranalysisGoogleDevtoolsCloudbuildV1Build.projectId) &&
        Objects.equals(this.queueTtl, containeranalysisGoogleDevtoolsCloudbuildV1Build.queueTtl) &&
        Objects.equals(this.results, containeranalysisGoogleDevtoolsCloudbuildV1Build.results) &&
        Objects.equals(this.secrets, containeranalysisGoogleDevtoolsCloudbuildV1Build.secrets) &&
        Objects.equals(this.serviceAccount, containeranalysisGoogleDevtoolsCloudbuildV1Build.serviceAccount) &&
        Objects.equals(this.source, containeranalysisGoogleDevtoolsCloudbuildV1Build.source) &&
        Objects.equals(this.sourceProvenance, containeranalysisGoogleDevtoolsCloudbuildV1Build.sourceProvenance) &&
        Objects.equals(this.startTime, containeranalysisGoogleDevtoolsCloudbuildV1Build.startTime) &&
        Objects.equals(this.status, containeranalysisGoogleDevtoolsCloudbuildV1Build.status) &&
        Objects.equals(this.statusDetail, containeranalysisGoogleDevtoolsCloudbuildV1Build.statusDetail) &&
        Objects.equals(this.steps, containeranalysisGoogleDevtoolsCloudbuildV1Build.steps) &&
        Objects.equals(this.substitutions, containeranalysisGoogleDevtoolsCloudbuildV1Build.substitutions) &&
        Objects.equals(this.tags, containeranalysisGoogleDevtoolsCloudbuildV1Build.tags) &&
        Objects.equals(this.timeout, containeranalysisGoogleDevtoolsCloudbuildV1Build.timeout) &&
        Objects.equals(this.timing, containeranalysisGoogleDevtoolsCloudbuildV1Build.timing) &&
        Objects.equals(this.warnings, containeranalysisGoogleDevtoolsCloudbuildV1Build.warnings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(approval, artifacts, availableSecrets, buildTriggerId, createTime, failureInfo, finishTime, id, images, logUrl, logsBucket, name, options, projectId, queueTtl, results, secrets, serviceAccount, source, sourceProvenance, startTime, status, statusDetail, steps, substitutions, tags, timeout, timing, warnings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ContaineranalysisGoogleDevtoolsCloudbuildV1Build {\n");
    sb.append("    approval: ").append(toIndentedString(approval)).append("\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    availableSecrets: ").append(toIndentedString(availableSecrets)).append("\n");
    sb.append("    buildTriggerId: ").append(toIndentedString(buildTriggerId)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    failureInfo: ").append(toIndentedString(failureInfo)).append("\n");
    sb.append("    finishTime: ").append(toIndentedString(finishTime)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    images: ").append(toIndentedString(images)).append("\n");
    sb.append("    logUrl: ").append(toIndentedString(logUrl)).append("\n");
    sb.append("    logsBucket: ").append(toIndentedString(logsBucket)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    projectId: ").append(toIndentedString(projectId)).append("\n");
    sb.append("    queueTtl: ").append(toIndentedString(queueTtl)).append("\n");
    sb.append("    results: ").append(toIndentedString(results)).append("\n");
    sb.append("    secrets: ").append(toIndentedString(secrets)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    sourceProvenance: ").append(toIndentedString(sourceProvenance)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusDetail: ").append(toIndentedString(statusDetail)).append("\n");
    sb.append("    steps: ").append(toIndentedString(steps)).append("\n");
    sb.append("    substitutions: ").append(toIndentedString(substitutions)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    timing: ").append(toIndentedString(timing)).append("\n");
    sb.append("    warnings: ").append(toIndentedString(warnings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("approval");
    openapiFields.add("artifacts");
    openapiFields.add("availableSecrets");
    openapiFields.add("buildTriggerId");
    openapiFields.add("createTime");
    openapiFields.add("failureInfo");
    openapiFields.add("finishTime");
    openapiFields.add("id");
    openapiFields.add("images");
    openapiFields.add("logUrl");
    openapiFields.add("logsBucket");
    openapiFields.add("name");
    openapiFields.add("options");
    openapiFields.add("projectId");
    openapiFields.add("queueTtl");
    openapiFields.add("results");
    openapiFields.add("secrets");
    openapiFields.add("serviceAccount");
    openapiFields.add("source");
    openapiFields.add("sourceProvenance");
    openapiFields.add("startTime");
    openapiFields.add("status");
    openapiFields.add("statusDetail");
    openapiFields.add("steps");
    openapiFields.add("substitutions");
    openapiFields.add("tags");
    openapiFields.add("timeout");
    openapiFields.add("timing");
    openapiFields.add("warnings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ContaineranalysisGoogleDevtoolsCloudbuildV1Build
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ContaineranalysisGoogleDevtoolsCloudbuildV1Build.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ContaineranalysisGoogleDevtoolsCloudbuildV1Build is not found in the empty JSON string", ContaineranalysisGoogleDevtoolsCloudbuildV1Build.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ContaineranalysisGoogleDevtoolsCloudbuildV1Build.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ContaineranalysisGoogleDevtoolsCloudbuildV1Build` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `approval`
      if (jsonObj.get("approval") != null && !jsonObj.get("approval").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1BuildApproval.validateJsonElement(jsonObj.get("approval"));
      }
      // validate the optional field `artifacts`
      if (jsonObj.get("artifacts") != null && !jsonObj.get("artifacts").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1Artifacts.validateJsonElement(jsonObj.get("artifacts"));
      }
      // validate the optional field `availableSecrets`
      if (jsonObj.get("availableSecrets") != null && !jsonObj.get("availableSecrets").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1Secrets.validateJsonElement(jsonObj.get("availableSecrets"));
      }
      if ((jsonObj.get("buildTriggerId") != null && !jsonObj.get("buildTriggerId").isJsonNull()) && !jsonObj.get("buildTriggerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buildTriggerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buildTriggerId").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      // validate the optional field `failureInfo`
      if (jsonObj.get("failureInfo") != null && !jsonObj.get("failureInfo").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1BuildFailureInfo.validateJsonElement(jsonObj.get("failureInfo"));
      }
      if ((jsonObj.get("finishTime") != null && !jsonObj.get("finishTime").isJsonNull()) && !jsonObj.get("finishTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `finishTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("finishTime").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("images") != null && !jsonObj.get("images").isJsonNull() && !jsonObj.get("images").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `images` to be an array in the JSON string but got `%s`", jsonObj.get("images").toString()));
      }
      if ((jsonObj.get("logUrl") != null && !jsonObj.get("logUrl").isJsonNull()) && !jsonObj.get("logUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logUrl").toString()));
      }
      if ((jsonObj.get("logsBucket") != null && !jsonObj.get("logsBucket").isJsonNull()) && !jsonObj.get("logsBucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logsBucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logsBucket").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `options`
      if (jsonObj.get("options") != null && !jsonObj.get("options").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1BuildOptions.validateJsonElement(jsonObj.get("options"));
      }
      if ((jsonObj.get("projectId") != null && !jsonObj.get("projectId").isJsonNull()) && !jsonObj.get("projectId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projectId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projectId").toString()));
      }
      if ((jsonObj.get("queueTtl") != null && !jsonObj.get("queueTtl").isJsonNull()) && !jsonObj.get("queueTtl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queueTtl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queueTtl").toString()));
      }
      // validate the optional field `results`
      if (jsonObj.get("results") != null && !jsonObj.get("results").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1Results.validateJsonElement(jsonObj.get("results"));
      }
      if (jsonObj.get("secrets") != null && !jsonObj.get("secrets").isJsonNull()) {
        JsonArray jsonArraysecrets = jsonObj.getAsJsonArray("secrets");
        if (jsonArraysecrets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secrets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secrets` to be an array in the JSON string but got `%s`", jsonObj.get("secrets").toString()));
          }

          // validate the optional field `secrets` (array)
          for (int i = 0; i < jsonArraysecrets.size(); i++) {
            ContaineranalysisGoogleDevtoolsCloudbuildV1Secret.validateJsonElement(jsonArraysecrets.get(i));
          };
        }
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1Source.validateJsonElement(jsonObj.get("source"));
      }
      // validate the optional field `sourceProvenance`
      if (jsonObj.get("sourceProvenance") != null && !jsonObj.get("sourceProvenance").isJsonNull()) {
        ContaineranalysisGoogleDevtoolsCloudbuildV1SourceProvenance.validateJsonElement(jsonObj.get("sourceProvenance"));
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("statusDetail") != null && !jsonObj.get("statusDetail").isJsonNull()) && !jsonObj.get("statusDetail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statusDetail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statusDetail").toString()));
      }
      if (jsonObj.get("steps") != null && !jsonObj.get("steps").isJsonNull()) {
        JsonArray jsonArraysteps = jsonObj.getAsJsonArray("steps");
        if (jsonArraysteps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("steps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `steps` to be an array in the JSON string but got `%s`", jsonObj.get("steps").toString()));
          }

          // validate the optional field `steps` (array)
          for (int i = 0; i < jsonArraysteps.size(); i++) {
            ContaineranalysisGoogleDevtoolsCloudbuildV1BuildStep.validateJsonElement(jsonArraysteps.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if ((jsonObj.get("timeout") != null && !jsonObj.get("timeout").isJsonNull()) && !jsonObj.get("timeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeout").toString()));
      }
      if (jsonObj.get("warnings") != null && !jsonObj.get("warnings").isJsonNull()) {
        JsonArray jsonArraywarnings = jsonObj.getAsJsonArray("warnings");
        if (jsonArraywarnings != null) {
          // ensure the json data is an array
          if (!jsonObj.get("warnings").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `warnings` to be an array in the JSON string but got `%s`", jsonObj.get("warnings").toString()));
          }

          // validate the optional field `warnings` (array)
          for (int i = 0; i < jsonArraywarnings.size(); i++) {
            ContaineranalysisGoogleDevtoolsCloudbuildV1BuildWarning.validateJsonElement(jsonArraywarnings.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ContaineranalysisGoogleDevtoolsCloudbuildV1Build.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ContaineranalysisGoogleDevtoolsCloudbuildV1Build' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ContaineranalysisGoogleDevtoolsCloudbuildV1Build> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ContaineranalysisGoogleDevtoolsCloudbuildV1Build.class));

       return (TypeAdapter<T>) new TypeAdapter<ContaineranalysisGoogleDevtoolsCloudbuildV1Build>() {
           @Override
           public void write(JsonWriter out, ContaineranalysisGoogleDevtoolsCloudbuildV1Build value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ContaineranalysisGoogleDevtoolsCloudbuildV1Build read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ContaineranalysisGoogleDevtoolsCloudbuildV1Build given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ContaineranalysisGoogleDevtoolsCloudbuildV1Build
   * @throws IOException if the JSON string is invalid with respect to ContaineranalysisGoogleDevtoolsCloudbuildV1Build
   */
  public static ContaineranalysisGoogleDevtoolsCloudbuildV1Build fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ContaineranalysisGoogleDevtoolsCloudbuildV1Build.class);
  }

  /**
   * Convert an instance of ContaineranalysisGoogleDevtoolsCloudbuildV1Build to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

