/*
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Steps taken to build the artifact. For a TaskRun, typically each container corresponds to one step in the recipe.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:38.234919-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SlsaRecipe {
  public static final String SERIALIZED_NAME_ARGUMENTS = "arguments";
  @SerializedName(SERIALIZED_NAME_ARGUMENTS)
  private Map<String, Object> arguments = new HashMap<>();

  public static final String SERIALIZED_NAME_DEFINED_IN_MATERIAL = "definedInMaterial";
  @SerializedName(SERIALIZED_NAME_DEFINED_IN_MATERIAL)
  private String definedInMaterial;

  public static final String SERIALIZED_NAME_ENTRY_POINT = "entryPoint";
  @SerializedName(SERIALIZED_NAME_ENTRY_POINT)
  private String entryPoint;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private Map<String, Object> environment = new HashMap<>();

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public SlsaRecipe() {
  }

  public SlsaRecipe arguments(Map<String, Object> arguments) {
    this.arguments = arguments;
    return this;
  }

  public SlsaRecipe putArgumentsItem(String key, Object argumentsItem) {
    if (this.arguments == null) {
      this.arguments = new HashMap<>();
    }
    this.arguments.put(key, argumentsItem);
    return this;
  }

  /**
   * Collection of all external inputs that influenced the build on top of recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe type were \&quot;make\&quot;, then this might be the flags passed to make aside from the target, which is captured in recipe.entryPoint. Depending on the recipe Type, the structure may be different.
   * @return arguments
   */
  @javax.annotation.Nullable
  public Map<String, Object> getArguments() {
    return arguments;
  }

  public void setArguments(Map<String, Object> arguments) {
    this.arguments = arguments;
  }


  public SlsaRecipe definedInMaterial(String definedInMaterial) {
    this.definedInMaterial = definedInMaterial;
    return this;
  }

  /**
   * Index in materials containing the recipe steps that are not implied by recipe.type. For example, if the recipe type were \&quot;make\&quot;, then this would point to the source containing the Makefile, not the make program itself. Set to -1 if the recipe doesn&#39;t come from a material, as zero is default unset value for int64.
   * @return definedInMaterial
   */
  @javax.annotation.Nullable
  public String getDefinedInMaterial() {
    return definedInMaterial;
  }

  public void setDefinedInMaterial(String definedInMaterial) {
    this.definedInMaterial = definedInMaterial;
  }


  public SlsaRecipe entryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
    return this;
  }

  /**
   * String identifying the entry point into the build. This is often a path to a configuration file and/or a target label within that file. The syntax and meaning are defined by recipe.type. For example, if the recipe type were \&quot;make\&quot;, then this would reference the directory in which to run make as well as which target to use.
   * @return entryPoint
   */
  @javax.annotation.Nullable
  public String getEntryPoint() {
    return entryPoint;
  }

  public void setEntryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
  }


  public SlsaRecipe environment(Map<String, Object> environment) {
    this.environment = environment;
    return this;
  }

  public SlsaRecipe putEnvironmentItem(String key, Object environmentItem) {
    if (this.environment == null) {
      this.environment = new HashMap<>();
    }
    this.environment.put(key, environmentItem);
    return this;
  }

  /**
   * Any other builder-controlled inputs necessary for correctly evaluating the recipe. Usually only needed for reproducing the build but not evaluated as part of policy. Depending on the recipe Type, the structure may be different.
   * @return environment
   */
  @javax.annotation.Nullable
  public Map<String, Object> getEnvironment() {
    return environment;
  }

  public void setEnvironment(Map<String, Object> environment) {
    this.environment = environment;
  }


  public SlsaRecipe type(String type) {
    this.type = type;
    return this;
  }

  /**
   * URI indicating what type of recipe was performed. It determines the meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SlsaRecipe slsaRecipe = (SlsaRecipe) o;
    return Objects.equals(this.arguments, slsaRecipe.arguments) &&
        Objects.equals(this.definedInMaterial, slsaRecipe.definedInMaterial) &&
        Objects.equals(this.entryPoint, slsaRecipe.entryPoint) &&
        Objects.equals(this.environment, slsaRecipe.environment) &&
        Objects.equals(this.type, slsaRecipe.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arguments, definedInMaterial, entryPoint, environment, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SlsaRecipe {\n");
    sb.append("    arguments: ").append(toIndentedString(arguments)).append("\n");
    sb.append("    definedInMaterial: ").append(toIndentedString(definedInMaterial)).append("\n");
    sb.append("    entryPoint: ").append(toIndentedString(entryPoint)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("arguments");
    openapiFields.add("definedInMaterial");
    openapiFields.add("entryPoint");
    openapiFields.add("environment");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SlsaRecipe
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SlsaRecipe.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SlsaRecipe is not found in the empty JSON string", SlsaRecipe.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SlsaRecipe.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SlsaRecipe` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("definedInMaterial") != null && !jsonObj.get("definedInMaterial").isJsonNull()) && !jsonObj.get("definedInMaterial").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definedInMaterial` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definedInMaterial").toString()));
      }
      if ((jsonObj.get("entryPoint") != null && !jsonObj.get("entryPoint").isJsonNull()) && !jsonObj.get("entryPoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entryPoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entryPoint").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SlsaRecipe.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SlsaRecipe' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SlsaRecipe> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SlsaRecipe.class));

       return (TypeAdapter<T>) new TypeAdapter<SlsaRecipe>() {
           @Override
           public void write(JsonWriter out, SlsaRecipe value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SlsaRecipe read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SlsaRecipe given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SlsaRecipe
   * @throws IOException if the JSON string is invalid with respect to SlsaRecipe
   */
  public static SlsaRecipe fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SlsaRecipe.class);
  }

  /**
   * Convert an instance of SlsaRecipe to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

