/*
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GrafeasV1FileLocation;
import org.openapitools.client.model.Version;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A detail for a distro and package this vulnerability occurrence was found in and its associated fix (if one is available).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:38.234919-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PackageIssue {
  public static final String SERIALIZED_NAME_AFFECTED_CPE_URI = "affectedCpeUri";
  @SerializedName(SERIALIZED_NAME_AFFECTED_CPE_URI)
  private String affectedCpeUri;

  public static final String SERIALIZED_NAME_AFFECTED_PACKAGE = "affectedPackage";
  @SerializedName(SERIALIZED_NAME_AFFECTED_PACKAGE)
  private String affectedPackage;

  public static final String SERIALIZED_NAME_AFFECTED_VERSION = "affectedVersion";
  @SerializedName(SERIALIZED_NAME_AFFECTED_VERSION)
  private Version affectedVersion;

  /**
   * Output only. The distro or language system assigned severity for this vulnerability when that is available and note provider assigned severity when it is not available.
   */
  @JsonAdapter(EffectiveSeverityEnum.Adapter.class)
  public enum EffectiveSeverityEnum {
    SEVERITY_UNSPECIFIED("SEVERITY_UNSPECIFIED"),
    
    MINIMAL("MINIMAL"),
    
    LOW("LOW"),
    
    MEDIUM("MEDIUM"),
    
    HIGH("HIGH"),
    
    CRITICAL("CRITICAL");

    private String value;

    EffectiveSeverityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EffectiveSeverityEnum fromValue(String value) {
      for (EffectiveSeverityEnum b : EffectiveSeverityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EffectiveSeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EffectiveSeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EffectiveSeverityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EffectiveSeverityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EffectiveSeverityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EFFECTIVE_SEVERITY = "effectiveSeverity";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_SEVERITY)
  private EffectiveSeverityEnum effectiveSeverity;

  public static final String SERIALIZED_NAME_FILE_LOCATION = "fileLocation";
  @SerializedName(SERIALIZED_NAME_FILE_LOCATION)
  private List<GrafeasV1FileLocation> fileLocation = new ArrayList<>();

  public static final String SERIALIZED_NAME_FIX_AVAILABLE = "fixAvailable";
  @SerializedName(SERIALIZED_NAME_FIX_AVAILABLE)
  private Boolean fixAvailable;

  public static final String SERIALIZED_NAME_FIXED_CPE_URI = "fixedCpeUri";
  @SerializedName(SERIALIZED_NAME_FIXED_CPE_URI)
  private String fixedCpeUri;

  public static final String SERIALIZED_NAME_FIXED_PACKAGE = "fixedPackage";
  @SerializedName(SERIALIZED_NAME_FIXED_PACKAGE)
  private String fixedPackage;

  public static final String SERIALIZED_NAME_FIXED_VERSION = "fixedVersion";
  @SerializedName(SERIALIZED_NAME_FIXED_VERSION)
  private Version fixedVersion;

  public static final String SERIALIZED_NAME_PACKAGE_TYPE = "packageType";
  @SerializedName(SERIALIZED_NAME_PACKAGE_TYPE)
  private String packageType;

  public PackageIssue() {
  }

  public PackageIssue(
     EffectiveSeverityEnum effectiveSeverity
  ) {
    this();
    this.effectiveSeverity = effectiveSeverity;
  }

  public PackageIssue affectedCpeUri(String affectedCpeUri) {
    this.affectedCpeUri = affectedCpeUri;
    return this;
  }

  /**
   * Required. The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was found in.
   * @return affectedCpeUri
   */
  @javax.annotation.Nullable
  public String getAffectedCpeUri() {
    return affectedCpeUri;
  }

  public void setAffectedCpeUri(String affectedCpeUri) {
    this.affectedCpeUri = affectedCpeUri;
  }


  public PackageIssue affectedPackage(String affectedPackage) {
    this.affectedPackage = affectedPackage;
    return this;
  }

  /**
   * Required. The package this vulnerability was found in.
   * @return affectedPackage
   */
  @javax.annotation.Nullable
  public String getAffectedPackage() {
    return affectedPackage;
  }

  public void setAffectedPackage(String affectedPackage) {
    this.affectedPackage = affectedPackage;
  }


  public PackageIssue affectedVersion(Version affectedVersion) {
    this.affectedVersion = affectedVersion;
    return this;
  }

  /**
   * Get affectedVersion
   * @return affectedVersion
   */
  @javax.annotation.Nullable
  public Version getAffectedVersion() {
    return affectedVersion;
  }

  public void setAffectedVersion(Version affectedVersion) {
    this.affectedVersion = affectedVersion;
  }


  /**
   * Output only. The distro or language system assigned severity for this vulnerability when that is available and note provider assigned severity when it is not available.
   * @return effectiveSeverity
   */
  @javax.annotation.Nullable
  public EffectiveSeverityEnum getEffectiveSeverity() {
    return effectiveSeverity;
  }



  public PackageIssue fileLocation(List<GrafeasV1FileLocation> fileLocation) {
    this.fileLocation = fileLocation;
    return this;
  }

  public PackageIssue addFileLocationItem(GrafeasV1FileLocation fileLocationItem) {
    if (this.fileLocation == null) {
      this.fileLocation = new ArrayList<>();
    }
    this.fileLocation.add(fileLocationItem);
    return this;
  }

  /**
   * The location at which this package was found.
   * @return fileLocation
   */
  @javax.annotation.Nullable
  public List<GrafeasV1FileLocation> getFileLocation() {
    return fileLocation;
  }

  public void setFileLocation(List<GrafeasV1FileLocation> fileLocation) {
    this.fileLocation = fileLocation;
  }


  public PackageIssue fixAvailable(Boolean fixAvailable) {
    this.fixAvailable = fixAvailable;
    return this;
  }

  /**
   * Output only. Whether a fix is available for this package.
   * @return fixAvailable
   */
  @javax.annotation.Nullable
  public Boolean getFixAvailable() {
    return fixAvailable;
  }

  public void setFixAvailable(Boolean fixAvailable) {
    this.fixAvailable = fixAvailable;
  }


  public PackageIssue fixedCpeUri(String fixedCpeUri) {
    this.fixedCpeUri = fixedCpeUri;
    return this;
  }

  /**
   * The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was fixed in. It is possible for this to be different from the affected_cpe_uri.
   * @return fixedCpeUri
   */
  @javax.annotation.Nullable
  public String getFixedCpeUri() {
    return fixedCpeUri;
  }

  public void setFixedCpeUri(String fixedCpeUri) {
    this.fixedCpeUri = fixedCpeUri;
  }


  public PackageIssue fixedPackage(String fixedPackage) {
    this.fixedPackage = fixedPackage;
    return this;
  }

  /**
   * The package this vulnerability was fixed in. It is possible for this to be different from the affected_package.
   * @return fixedPackage
   */
  @javax.annotation.Nullable
  public String getFixedPackage() {
    return fixedPackage;
  }

  public void setFixedPackage(String fixedPackage) {
    this.fixedPackage = fixedPackage;
  }


  public PackageIssue fixedVersion(Version fixedVersion) {
    this.fixedVersion = fixedVersion;
    return this;
  }

  /**
   * Get fixedVersion
   * @return fixedVersion
   */
  @javax.annotation.Nullable
  public Version getFixedVersion() {
    return fixedVersion;
  }

  public void setFixedVersion(Version fixedVersion) {
    this.fixedVersion = fixedVersion;
  }


  public PackageIssue packageType(String packageType) {
    this.packageType = packageType;
    return this;
  }

  /**
   * The type of package (e.g. OS, MAVEN, GO).
   * @return packageType
   */
  @javax.annotation.Nullable
  public String getPackageType() {
    return packageType;
  }

  public void setPackageType(String packageType) {
    this.packageType = packageType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PackageIssue packageIssue = (PackageIssue) o;
    return Objects.equals(this.affectedCpeUri, packageIssue.affectedCpeUri) &&
        Objects.equals(this.affectedPackage, packageIssue.affectedPackage) &&
        Objects.equals(this.affectedVersion, packageIssue.affectedVersion) &&
        Objects.equals(this.effectiveSeverity, packageIssue.effectiveSeverity) &&
        Objects.equals(this.fileLocation, packageIssue.fileLocation) &&
        Objects.equals(this.fixAvailable, packageIssue.fixAvailable) &&
        Objects.equals(this.fixedCpeUri, packageIssue.fixedCpeUri) &&
        Objects.equals(this.fixedPackage, packageIssue.fixedPackage) &&
        Objects.equals(this.fixedVersion, packageIssue.fixedVersion) &&
        Objects.equals(this.packageType, packageIssue.packageType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affectedCpeUri, affectedPackage, affectedVersion, effectiveSeverity, fileLocation, fixAvailable, fixedCpeUri, fixedPackage, fixedVersion, packageType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PackageIssue {\n");
    sb.append("    affectedCpeUri: ").append(toIndentedString(affectedCpeUri)).append("\n");
    sb.append("    affectedPackage: ").append(toIndentedString(affectedPackage)).append("\n");
    sb.append("    affectedVersion: ").append(toIndentedString(affectedVersion)).append("\n");
    sb.append("    effectiveSeverity: ").append(toIndentedString(effectiveSeverity)).append("\n");
    sb.append("    fileLocation: ").append(toIndentedString(fileLocation)).append("\n");
    sb.append("    fixAvailable: ").append(toIndentedString(fixAvailable)).append("\n");
    sb.append("    fixedCpeUri: ").append(toIndentedString(fixedCpeUri)).append("\n");
    sb.append("    fixedPackage: ").append(toIndentedString(fixedPackage)).append("\n");
    sb.append("    fixedVersion: ").append(toIndentedString(fixedVersion)).append("\n");
    sb.append("    packageType: ").append(toIndentedString(packageType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("affectedCpeUri");
    openapiFields.add("affectedPackage");
    openapiFields.add("affectedVersion");
    openapiFields.add("effectiveSeverity");
    openapiFields.add("fileLocation");
    openapiFields.add("fixAvailable");
    openapiFields.add("fixedCpeUri");
    openapiFields.add("fixedPackage");
    openapiFields.add("fixedVersion");
    openapiFields.add("packageType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PackageIssue
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PackageIssue.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PackageIssue is not found in the empty JSON string", PackageIssue.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PackageIssue.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PackageIssue` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("affectedCpeUri") != null && !jsonObj.get("affectedCpeUri").isJsonNull()) && !jsonObj.get("affectedCpeUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `affectedCpeUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("affectedCpeUri").toString()));
      }
      if ((jsonObj.get("affectedPackage") != null && !jsonObj.get("affectedPackage").isJsonNull()) && !jsonObj.get("affectedPackage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `affectedPackage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("affectedPackage").toString()));
      }
      // validate the optional field `affectedVersion`
      if (jsonObj.get("affectedVersion") != null && !jsonObj.get("affectedVersion").isJsonNull()) {
        Version.validateJsonElement(jsonObj.get("affectedVersion"));
      }
      if ((jsonObj.get("effectiveSeverity") != null && !jsonObj.get("effectiveSeverity").isJsonNull()) && !jsonObj.get("effectiveSeverity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `effectiveSeverity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("effectiveSeverity").toString()));
      }
      // validate the optional field `effectiveSeverity`
      if (jsonObj.get("effectiveSeverity") != null && !jsonObj.get("effectiveSeverity").isJsonNull()) {
        EffectiveSeverityEnum.validateJsonElement(jsonObj.get("effectiveSeverity"));
      }
      if (jsonObj.get("fileLocation") != null && !jsonObj.get("fileLocation").isJsonNull()) {
        JsonArray jsonArrayfileLocation = jsonObj.getAsJsonArray("fileLocation");
        if (jsonArrayfileLocation != null) {
          // ensure the json data is an array
          if (!jsonObj.get("fileLocation").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `fileLocation` to be an array in the JSON string but got `%s`", jsonObj.get("fileLocation").toString()));
          }

          // validate the optional field `fileLocation` (array)
          for (int i = 0; i < jsonArrayfileLocation.size(); i++) {
            GrafeasV1FileLocation.validateJsonElement(jsonArrayfileLocation.get(i));
          };
        }
      }
      if ((jsonObj.get("fixedCpeUri") != null && !jsonObj.get("fixedCpeUri").isJsonNull()) && !jsonObj.get("fixedCpeUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fixedCpeUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fixedCpeUri").toString()));
      }
      if ((jsonObj.get("fixedPackage") != null && !jsonObj.get("fixedPackage").isJsonNull()) && !jsonObj.get("fixedPackage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fixedPackage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fixedPackage").toString()));
      }
      // validate the optional field `fixedVersion`
      if (jsonObj.get("fixedVersion") != null && !jsonObj.get("fixedVersion").isJsonNull()) {
        Version.validateJsonElement(jsonObj.get("fixedVersion"));
      }
      if ((jsonObj.get("packageType") != null && !jsonObj.get("packageType").isJsonNull()) && !jsonObj.get("packageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `packageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("packageType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PackageIssue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PackageIssue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PackageIssue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PackageIssue.class));

       return (TypeAdapter<T>) new TypeAdapter<PackageIssue>() {
           @Override
           public void write(JsonWriter out, PackageIssue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PackageIssue read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PackageIssue given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PackageIssue
   * @throws IOException if the JSON string is invalid with respect to PackageIssue
   */
  public static PackageIssue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PackageIssue.class);
  }

  /**
   * Convert an instance of PackageIssue to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

