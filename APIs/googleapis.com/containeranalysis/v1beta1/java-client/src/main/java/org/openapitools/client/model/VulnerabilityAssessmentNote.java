/*
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Assessment;
import org.openapitools.client.model.Product;
import org.openapitools.client.model.Publisher;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A single VulnerabilityAssessmentNote represents one particular product&#39;s vulnerability assessment for one CVE.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:41.469450-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VulnerabilityAssessmentNote {
  public static final String SERIALIZED_NAME_ASSESSMENT = "assessment";
  @SerializedName(SERIALIZED_NAME_ASSESSMENT)
  private Assessment assessment;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_LONG_DESCRIPTION = "longDescription";
  @SerializedName(SERIALIZED_NAME_LONG_DESCRIPTION)
  private String longDescription;

  public static final String SERIALIZED_NAME_PRODUCT = "product";
  @SerializedName(SERIALIZED_NAME_PRODUCT)
  private Product product;

  public static final String SERIALIZED_NAME_PUBLISHER = "publisher";
  @SerializedName(SERIALIZED_NAME_PUBLISHER)
  private Publisher publisher;

  public static final String SERIALIZED_NAME_SHORT_DESCRIPTION = "shortDescription";
  @SerializedName(SERIALIZED_NAME_SHORT_DESCRIPTION)
  private String shortDescription;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public VulnerabilityAssessmentNote() {
  }

  public VulnerabilityAssessmentNote assessment(Assessment assessment) {
    this.assessment = assessment;
    return this;
  }

  /**
   * Get assessment
   * @return assessment
   */
  @javax.annotation.Nullable
  public Assessment getAssessment() {
    return assessment;
  }

  public void setAssessment(Assessment assessment) {
    this.assessment = assessment;
  }


  public VulnerabilityAssessmentNote languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Identifies the language used by this document, corresponding to IETF BCP 47 / RFC 5646.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public VulnerabilityAssessmentNote longDescription(String longDescription) {
    this.longDescription = longDescription;
    return this;
  }

  /**
   * A detailed description of this Vex.
   * @return longDescription
   */
  @javax.annotation.Nullable
  public String getLongDescription() {
    return longDescription;
  }

  public void setLongDescription(String longDescription) {
    this.longDescription = longDescription;
  }


  public VulnerabilityAssessmentNote product(Product product) {
    this.product = product;
    return this;
  }

  /**
   * Get product
   * @return product
   */
  @javax.annotation.Nullable
  public Product getProduct() {
    return product;
  }

  public void setProduct(Product product) {
    this.product = product;
  }


  public VulnerabilityAssessmentNote publisher(Publisher publisher) {
    this.publisher = publisher;
    return this;
  }

  /**
   * Get publisher
   * @return publisher
   */
  @javax.annotation.Nullable
  public Publisher getPublisher() {
    return publisher;
  }

  public void setPublisher(Publisher publisher) {
    this.publisher = publisher;
  }


  public VulnerabilityAssessmentNote shortDescription(String shortDescription) {
    this.shortDescription = shortDescription;
    return this;
  }

  /**
   * A one sentence description of this Vex.
   * @return shortDescription
   */
  @javax.annotation.Nullable
  public String getShortDescription() {
    return shortDescription;
  }

  public void setShortDescription(String shortDescription) {
    this.shortDescription = shortDescription;
  }


  public VulnerabilityAssessmentNote title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the note. E.g. &#x60;Vex-Debian-11.4&#x60;
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VulnerabilityAssessmentNote vulnerabilityAssessmentNote = (VulnerabilityAssessmentNote) o;
    return Objects.equals(this.assessment, vulnerabilityAssessmentNote.assessment) &&
        Objects.equals(this.languageCode, vulnerabilityAssessmentNote.languageCode) &&
        Objects.equals(this.longDescription, vulnerabilityAssessmentNote.longDescription) &&
        Objects.equals(this.product, vulnerabilityAssessmentNote.product) &&
        Objects.equals(this.publisher, vulnerabilityAssessmentNote.publisher) &&
        Objects.equals(this.shortDescription, vulnerabilityAssessmentNote.shortDescription) &&
        Objects.equals(this.title, vulnerabilityAssessmentNote.title);
  }

  @Override
  public int hashCode() {
    return Objects.hash(assessment, languageCode, longDescription, product, publisher, shortDescription, title);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VulnerabilityAssessmentNote {\n");
    sb.append("    assessment: ").append(toIndentedString(assessment)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    longDescription: ").append(toIndentedString(longDescription)).append("\n");
    sb.append("    product: ").append(toIndentedString(product)).append("\n");
    sb.append("    publisher: ").append(toIndentedString(publisher)).append("\n");
    sb.append("    shortDescription: ").append(toIndentedString(shortDescription)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("assessment");
    openapiFields.add("languageCode");
    openapiFields.add("longDescription");
    openapiFields.add("product");
    openapiFields.add("publisher");
    openapiFields.add("shortDescription");
    openapiFields.add("title");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VulnerabilityAssessmentNote
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VulnerabilityAssessmentNote.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VulnerabilityAssessmentNote is not found in the empty JSON string", VulnerabilityAssessmentNote.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VulnerabilityAssessmentNote.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VulnerabilityAssessmentNote` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `assessment`
      if (jsonObj.get("assessment") != null && !jsonObj.get("assessment").isJsonNull()) {
        Assessment.validateJsonElement(jsonObj.get("assessment"));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      if ((jsonObj.get("longDescription") != null && !jsonObj.get("longDescription").isJsonNull()) && !jsonObj.get("longDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `longDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("longDescription").toString()));
      }
      // validate the optional field `product`
      if (jsonObj.get("product") != null && !jsonObj.get("product").isJsonNull()) {
        Product.validateJsonElement(jsonObj.get("product"));
      }
      // validate the optional field `publisher`
      if (jsonObj.get("publisher") != null && !jsonObj.get("publisher").isJsonNull()) {
        Publisher.validateJsonElement(jsonObj.get("publisher"));
      }
      if ((jsonObj.get("shortDescription") != null && !jsonObj.get("shortDescription").isJsonNull()) && !jsonObj.get("shortDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shortDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shortDescription").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VulnerabilityAssessmentNote.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VulnerabilityAssessmentNote' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VulnerabilityAssessmentNote> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VulnerabilityAssessmentNote.class));

       return (TypeAdapter<T>) new TypeAdapter<VulnerabilityAssessmentNote>() {
           @Override
           public void write(JsonWriter out, VulnerabilityAssessmentNote value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VulnerabilityAssessmentNote read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VulnerabilityAssessmentNote given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VulnerabilityAssessmentNote
   * @throws IOException if the JSON string is invalid with respect to VulnerabilityAssessmentNote
   */
  public static VulnerabilityAssessmentNote fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VulnerabilityAssessmentNote.class);
  }

  /**
   * Convert an instance of VulnerabilityAssessmentNote to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

