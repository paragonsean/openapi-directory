/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGrafeasV1beta1VulnerabilityDetails.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGrafeasV1beta1VulnerabilityDetails::OAIGrafeasV1beta1VulnerabilityDetails(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGrafeasV1beta1VulnerabilityDetails::OAIGrafeasV1beta1VulnerabilityDetails() {
    this->initializeModel();
}

OAIGrafeasV1beta1VulnerabilityDetails::~OAIGrafeasV1beta1VulnerabilityDetails() {}

void OAIGrafeasV1beta1VulnerabilityDetails::initializeModel() {

    m_cvss_score_isSet = false;
    m_cvss_score_isValid = false;

    m_cvss_v2_isSet = false;
    m_cvss_v2_isValid = false;

    m_cvss_v3_isSet = false;
    m_cvss_v3_isValid = false;

    m_cvss_version_isSet = false;
    m_cvss_version_isValid = false;

    m_effective_severity_isSet = false;
    m_effective_severity_isValid = false;

    m_extra_details_isSet = false;
    m_extra_details_isValid = false;

    m_long_description_isSet = false;
    m_long_description_isValid = false;

    m_package_issue_isSet = false;
    m_package_issue_isValid = false;

    m_related_urls_isSet = false;
    m_related_urls_isValid = false;

    m_severity_isSet = false;
    m_severity_isValid = false;

    m_short_description_isSet = false;
    m_short_description_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_vex_assessment_isSet = false;
    m_vex_assessment_isValid = false;
}

void OAIGrafeasV1beta1VulnerabilityDetails::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGrafeasV1beta1VulnerabilityDetails::fromJsonObject(QJsonObject json) {

    m_cvss_score_isValid = ::OpenAPI::fromJsonValue(m_cvss_score, json[QString("cvssScore")]);
    m_cvss_score_isSet = !json[QString("cvssScore")].isNull() && m_cvss_score_isValid;

    m_cvss_v2_isValid = ::OpenAPI::fromJsonValue(m_cvss_v2, json[QString("cvssV2")]);
    m_cvss_v2_isSet = !json[QString("cvssV2")].isNull() && m_cvss_v2_isValid;

    m_cvss_v3_isValid = ::OpenAPI::fromJsonValue(m_cvss_v3, json[QString("cvssV3")]);
    m_cvss_v3_isSet = !json[QString("cvssV3")].isNull() && m_cvss_v3_isValid;

    m_cvss_version_isValid = ::OpenAPI::fromJsonValue(m_cvss_version, json[QString("cvssVersion")]);
    m_cvss_version_isSet = !json[QString("cvssVersion")].isNull() && m_cvss_version_isValid;

    m_effective_severity_isValid = ::OpenAPI::fromJsonValue(m_effective_severity, json[QString("effectiveSeverity")]);
    m_effective_severity_isSet = !json[QString("effectiveSeverity")].isNull() && m_effective_severity_isValid;

    m_extra_details_isValid = ::OpenAPI::fromJsonValue(m_extra_details, json[QString("extraDetails")]);
    m_extra_details_isSet = !json[QString("extraDetails")].isNull() && m_extra_details_isValid;

    m_long_description_isValid = ::OpenAPI::fromJsonValue(m_long_description, json[QString("longDescription")]);
    m_long_description_isSet = !json[QString("longDescription")].isNull() && m_long_description_isValid;

    m_package_issue_isValid = ::OpenAPI::fromJsonValue(m_package_issue, json[QString("packageIssue")]);
    m_package_issue_isSet = !json[QString("packageIssue")].isNull() && m_package_issue_isValid;

    m_related_urls_isValid = ::OpenAPI::fromJsonValue(m_related_urls, json[QString("relatedUrls")]);
    m_related_urls_isSet = !json[QString("relatedUrls")].isNull() && m_related_urls_isValid;

    m_severity_isValid = ::OpenAPI::fromJsonValue(m_severity, json[QString("severity")]);
    m_severity_isSet = !json[QString("severity")].isNull() && m_severity_isValid;

    m_short_description_isValid = ::OpenAPI::fromJsonValue(m_short_description, json[QString("shortDescription")]);
    m_short_description_isSet = !json[QString("shortDescription")].isNull() && m_short_description_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_vex_assessment_isValid = ::OpenAPI::fromJsonValue(m_vex_assessment, json[QString("vexAssessment")]);
    m_vex_assessment_isSet = !json[QString("vexAssessment")].isNull() && m_vex_assessment_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGrafeasV1beta1VulnerabilityDetails::asJsonObject() const {
    QJsonObject obj;
    if (m_cvss_score_isSet) {
        obj.insert(QString("cvssScore"), ::OpenAPI::toJsonValue(m_cvss_score));
    }
    if (m_cvss_v2.isSet()) {
        obj.insert(QString("cvssV2"), ::OpenAPI::toJsonValue(m_cvss_v2));
    }
    if (m_cvss_v3.isSet()) {
        obj.insert(QString("cvssV3"), ::OpenAPI::toJsonValue(m_cvss_v3));
    }
    if (m_cvss_version_isSet) {
        obj.insert(QString("cvssVersion"), ::OpenAPI::toJsonValue(m_cvss_version));
    }
    if (m_effective_severity_isSet) {
        obj.insert(QString("effectiveSeverity"), ::OpenAPI::toJsonValue(m_effective_severity));
    }
    if (m_extra_details_isSet) {
        obj.insert(QString("extraDetails"), ::OpenAPI::toJsonValue(m_extra_details));
    }
    if (m_long_description_isSet) {
        obj.insert(QString("longDescription"), ::OpenAPI::toJsonValue(m_long_description));
    }
    if (m_package_issue.size() > 0) {
        obj.insert(QString("packageIssue"), ::OpenAPI::toJsonValue(m_package_issue));
    }
    if (m_related_urls.size() > 0) {
        obj.insert(QString("relatedUrls"), ::OpenAPI::toJsonValue(m_related_urls));
    }
    if (m_severity_isSet) {
        obj.insert(QString("severity"), ::OpenAPI::toJsonValue(m_severity));
    }
    if (m_short_description_isSet) {
        obj.insert(QString("shortDescription"), ::OpenAPI::toJsonValue(m_short_description));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_vex_assessment.isSet()) {
        obj.insert(QString("vexAssessment"), ::OpenAPI::toJsonValue(m_vex_assessment));
    }
    return obj;
}

float OAIGrafeasV1beta1VulnerabilityDetails::getCvssScore() const {
    return m_cvss_score;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setCvssScore(const float &cvss_score) {
    m_cvss_score = cvss_score;
    m_cvss_score_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_score_Set() const{
    return m_cvss_score_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_score_Valid() const{
    return m_cvss_score_isValid;
}

OAICVSS OAIGrafeasV1beta1VulnerabilityDetails::getCvssV2() const {
    return m_cvss_v2;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setCvssV2(const OAICVSS &cvss_v2) {
    m_cvss_v2 = cvss_v2;
    m_cvss_v2_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_v2_Set() const{
    return m_cvss_v2_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_v2_Valid() const{
    return m_cvss_v2_isValid;
}

OAICVSS OAIGrafeasV1beta1VulnerabilityDetails::getCvssV3() const {
    return m_cvss_v3;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setCvssV3(const OAICVSS &cvss_v3) {
    m_cvss_v3 = cvss_v3;
    m_cvss_v3_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_v3_Set() const{
    return m_cvss_v3_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_v3_Valid() const{
    return m_cvss_v3_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getCvssVersion() const {
    return m_cvss_version;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setCvssVersion(const QString &cvss_version) {
    m_cvss_version = cvss_version;
    m_cvss_version_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_version_Set() const{
    return m_cvss_version_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_cvss_version_Valid() const{
    return m_cvss_version_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getEffectiveSeverity() const {
    return m_effective_severity;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setEffectiveSeverity(const QString &effective_severity) {
    m_effective_severity = effective_severity;
    m_effective_severity_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_effective_severity_Set() const{
    return m_effective_severity_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_effective_severity_Valid() const{
    return m_effective_severity_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getExtraDetails() const {
    return m_extra_details;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setExtraDetails(const QString &extra_details) {
    m_extra_details = extra_details;
    m_extra_details_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_extra_details_Set() const{
    return m_extra_details_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_extra_details_Valid() const{
    return m_extra_details_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getLongDescription() const {
    return m_long_description;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setLongDescription(const QString &long_description) {
    m_long_description = long_description;
    m_long_description_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_long_description_Set() const{
    return m_long_description_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_long_description_Valid() const{
    return m_long_description_isValid;
}

QList<OAIPackageIssue> OAIGrafeasV1beta1VulnerabilityDetails::getPackageIssue() const {
    return m_package_issue;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setPackageIssue(const QList<OAIPackageIssue> &package_issue) {
    m_package_issue = package_issue;
    m_package_issue_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_package_issue_Set() const{
    return m_package_issue_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_package_issue_Valid() const{
    return m_package_issue_isValid;
}

QList<OAIRelatedUrl> OAIGrafeasV1beta1VulnerabilityDetails::getRelatedUrls() const {
    return m_related_urls;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setRelatedUrls(const QList<OAIRelatedUrl> &related_urls) {
    m_related_urls = related_urls;
    m_related_urls_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_related_urls_Set() const{
    return m_related_urls_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_related_urls_Valid() const{
    return m_related_urls_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getSeverity() const {
    return m_severity;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setSeverity(const QString &severity) {
    m_severity = severity;
    m_severity_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_severity_Set() const{
    return m_severity_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_severity_Valid() const{
    return m_severity_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getShortDescription() const {
    return m_short_description;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setShortDescription(const QString &short_description) {
    m_short_description = short_description;
    m_short_description_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_short_description_Set() const{
    return m_short_description_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_short_description_Valid() const{
    return m_short_description_isValid;
}

QString OAIGrafeasV1beta1VulnerabilityDetails::getType() const {
    return m_type;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_type_Set() const{
    return m_type_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_type_Valid() const{
    return m_type_isValid;
}

OAIVexAssessment OAIGrafeasV1beta1VulnerabilityDetails::getVexAssessment() const {
    return m_vex_assessment;
}
void OAIGrafeasV1beta1VulnerabilityDetails::setVexAssessment(const OAIVexAssessment &vex_assessment) {
    m_vex_assessment = vex_assessment;
    m_vex_assessment_isSet = true;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_vex_assessment_Set() const{
    return m_vex_assessment_isSet;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::is_vex_assessment_Valid() const{
    return m_vex_assessment_isValid;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cvss_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_v2.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_v3.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_effective_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_extra_details_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_long_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_issue.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_related_urls.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_short_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vex_assessment.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGrafeasV1beta1VulnerabilityDetails::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
