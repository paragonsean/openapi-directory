/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVexAssessment.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVexAssessment::OAIVexAssessment(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVexAssessment::OAIVexAssessment() {
    this->initializeModel();
}

OAIVexAssessment::~OAIVexAssessment() {}

void OAIVexAssessment::initializeModel() {

    m_cve_isSet = false;
    m_cve_isValid = false;

    m_impacts_isSet = false;
    m_impacts_isValid = false;

    m_justification_isSet = false;
    m_justification_isValid = false;

    m_note_name_isSet = false;
    m_note_name_isValid = false;

    m_related_uris_isSet = false;
    m_related_uris_isValid = false;

    m_remediations_isSet = false;
    m_remediations_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_vulnerability_id_isSet = false;
    m_vulnerability_id_isValid = false;
}

void OAIVexAssessment::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVexAssessment::fromJsonObject(QJsonObject json) {

    m_cve_isValid = ::OpenAPI::fromJsonValue(m_cve, json[QString("cve")]);
    m_cve_isSet = !json[QString("cve")].isNull() && m_cve_isValid;

    m_impacts_isValid = ::OpenAPI::fromJsonValue(m_impacts, json[QString("impacts")]);
    m_impacts_isSet = !json[QString("impacts")].isNull() && m_impacts_isValid;

    m_justification_isValid = ::OpenAPI::fromJsonValue(m_justification, json[QString("justification")]);
    m_justification_isSet = !json[QString("justification")].isNull() && m_justification_isValid;

    m_note_name_isValid = ::OpenAPI::fromJsonValue(m_note_name, json[QString("noteName")]);
    m_note_name_isSet = !json[QString("noteName")].isNull() && m_note_name_isValid;

    m_related_uris_isValid = ::OpenAPI::fromJsonValue(m_related_uris, json[QString("relatedUris")]);
    m_related_uris_isSet = !json[QString("relatedUris")].isNull() && m_related_uris_isValid;

    m_remediations_isValid = ::OpenAPI::fromJsonValue(m_remediations, json[QString("remediations")]);
    m_remediations_isSet = !json[QString("remediations")].isNull() && m_remediations_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_vulnerability_id_isValid = ::OpenAPI::fromJsonValue(m_vulnerability_id, json[QString("vulnerabilityId")]);
    m_vulnerability_id_isSet = !json[QString("vulnerabilityId")].isNull() && m_vulnerability_id_isValid;
}

QString OAIVexAssessment::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVexAssessment::asJsonObject() const {
    QJsonObject obj;
    if (m_cve_isSet) {
        obj.insert(QString("cve"), ::OpenAPI::toJsonValue(m_cve));
    }
    if (m_impacts.size() > 0) {
        obj.insert(QString("impacts"), ::OpenAPI::toJsonValue(m_impacts));
    }
    if (m_justification.isSet()) {
        obj.insert(QString("justification"), ::OpenAPI::toJsonValue(m_justification));
    }
    if (m_note_name_isSet) {
        obj.insert(QString("noteName"), ::OpenAPI::toJsonValue(m_note_name));
    }
    if (m_related_uris.size() > 0) {
        obj.insert(QString("relatedUris"), ::OpenAPI::toJsonValue(m_related_uris));
    }
    if (m_remediations.size() > 0) {
        obj.insert(QString("remediations"), ::OpenAPI::toJsonValue(m_remediations));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_vulnerability_id_isSet) {
        obj.insert(QString("vulnerabilityId"), ::OpenAPI::toJsonValue(m_vulnerability_id));
    }
    return obj;
}

QString OAIVexAssessment::getCve() const {
    return m_cve;
}
void OAIVexAssessment::setCve(const QString &cve) {
    m_cve = cve;
    m_cve_isSet = true;
}

bool OAIVexAssessment::is_cve_Set() const{
    return m_cve_isSet;
}

bool OAIVexAssessment::is_cve_Valid() const{
    return m_cve_isValid;
}

QList<QString> OAIVexAssessment::getImpacts() const {
    return m_impacts;
}
void OAIVexAssessment::setImpacts(const QList<QString> &impacts) {
    m_impacts = impacts;
    m_impacts_isSet = true;
}

bool OAIVexAssessment::is_impacts_Set() const{
    return m_impacts_isSet;
}

bool OAIVexAssessment::is_impacts_Valid() const{
    return m_impacts_isValid;
}

OAIJustification OAIVexAssessment::getJustification() const {
    return m_justification;
}
void OAIVexAssessment::setJustification(const OAIJustification &justification) {
    m_justification = justification;
    m_justification_isSet = true;
}

bool OAIVexAssessment::is_justification_Set() const{
    return m_justification_isSet;
}

bool OAIVexAssessment::is_justification_Valid() const{
    return m_justification_isValid;
}

QString OAIVexAssessment::getNoteName() const {
    return m_note_name;
}
void OAIVexAssessment::setNoteName(const QString &note_name) {
    m_note_name = note_name;
    m_note_name_isSet = true;
}

bool OAIVexAssessment::is_note_name_Set() const{
    return m_note_name_isSet;
}

bool OAIVexAssessment::is_note_name_Valid() const{
    return m_note_name_isValid;
}

QList<OAIRelatedUrl> OAIVexAssessment::getRelatedUris() const {
    return m_related_uris;
}
void OAIVexAssessment::setRelatedUris(const QList<OAIRelatedUrl> &related_uris) {
    m_related_uris = related_uris;
    m_related_uris_isSet = true;
}

bool OAIVexAssessment::is_related_uris_Set() const{
    return m_related_uris_isSet;
}

bool OAIVexAssessment::is_related_uris_Valid() const{
    return m_related_uris_isValid;
}

QList<OAIRemediation> OAIVexAssessment::getRemediations() const {
    return m_remediations;
}
void OAIVexAssessment::setRemediations(const QList<OAIRemediation> &remediations) {
    m_remediations = remediations;
    m_remediations_isSet = true;
}

bool OAIVexAssessment::is_remediations_Set() const{
    return m_remediations_isSet;
}

bool OAIVexAssessment::is_remediations_Valid() const{
    return m_remediations_isValid;
}

QString OAIVexAssessment::getState() const {
    return m_state;
}
void OAIVexAssessment::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIVexAssessment::is_state_Set() const{
    return m_state_isSet;
}

bool OAIVexAssessment::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIVexAssessment::getVulnerabilityId() const {
    return m_vulnerability_id;
}
void OAIVexAssessment::setVulnerabilityId(const QString &vulnerability_id) {
    m_vulnerability_id = vulnerability_id;
    m_vulnerability_id_isSet = true;
}

bool OAIVexAssessment::is_vulnerability_id_Set() const{
    return m_vulnerability_id_isSet;
}

bool OAIVexAssessment::is_vulnerability_id_Valid() const{
    return m_vulnerability_id_isValid;
}

bool OAIVexAssessment::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cve_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_impacts.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_justification.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_note_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_related_uris.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_remediations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vulnerability_id_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVexAssessment::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
