/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDiscovered.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDiscovered::OAIDiscovered(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDiscovered::OAIDiscovered() {
    this->initializeModel();
}

OAIDiscovered::~OAIDiscovered() {}

void OAIDiscovered::initializeModel() {

    m_analysis_completed_isSet = false;
    m_analysis_completed_isValid = false;

    m_analysis_error_isSet = false;
    m_analysis_error_isValid = false;

    m_analysis_status_isSet = false;
    m_analysis_status_isValid = false;

    m_analysis_status_error_isSet = false;
    m_analysis_status_error_isValid = false;

    m_continuous_analysis_isSet = false;
    m_continuous_analysis_isValid = false;

    m_last_analysis_time_isSet = false;
    m_last_analysis_time_isValid = false;

    m_last_scan_time_isSet = false;
    m_last_scan_time_isValid = false;

    m_sbom_status_isSet = false;
    m_sbom_status_isValid = false;
}

void OAIDiscovered::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDiscovered::fromJsonObject(QJsonObject json) {

    m_analysis_completed_isValid = ::OpenAPI::fromJsonValue(m_analysis_completed, json[QString("analysisCompleted")]);
    m_analysis_completed_isSet = !json[QString("analysisCompleted")].isNull() && m_analysis_completed_isValid;

    m_analysis_error_isValid = ::OpenAPI::fromJsonValue(m_analysis_error, json[QString("analysisError")]);
    m_analysis_error_isSet = !json[QString("analysisError")].isNull() && m_analysis_error_isValid;

    m_analysis_status_isValid = ::OpenAPI::fromJsonValue(m_analysis_status, json[QString("analysisStatus")]);
    m_analysis_status_isSet = !json[QString("analysisStatus")].isNull() && m_analysis_status_isValid;

    m_analysis_status_error_isValid = ::OpenAPI::fromJsonValue(m_analysis_status_error, json[QString("analysisStatusError")]);
    m_analysis_status_error_isSet = !json[QString("analysisStatusError")].isNull() && m_analysis_status_error_isValid;

    m_continuous_analysis_isValid = ::OpenAPI::fromJsonValue(m_continuous_analysis, json[QString("continuousAnalysis")]);
    m_continuous_analysis_isSet = !json[QString("continuousAnalysis")].isNull() && m_continuous_analysis_isValid;

    m_last_analysis_time_isValid = ::OpenAPI::fromJsonValue(m_last_analysis_time, json[QString("lastAnalysisTime")]);
    m_last_analysis_time_isSet = !json[QString("lastAnalysisTime")].isNull() && m_last_analysis_time_isValid;

    m_last_scan_time_isValid = ::OpenAPI::fromJsonValue(m_last_scan_time, json[QString("lastScanTime")]);
    m_last_scan_time_isSet = !json[QString("lastScanTime")].isNull() && m_last_scan_time_isValid;

    m_sbom_status_isValid = ::OpenAPI::fromJsonValue(m_sbom_status, json[QString("sbomStatus")]);
    m_sbom_status_isSet = !json[QString("sbomStatus")].isNull() && m_sbom_status_isValid;
}

QString OAIDiscovered::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDiscovered::asJsonObject() const {
    QJsonObject obj;
    if (m_analysis_completed.isSet()) {
        obj.insert(QString("analysisCompleted"), ::OpenAPI::toJsonValue(m_analysis_completed));
    }
    if (m_analysis_error.size() > 0) {
        obj.insert(QString("analysisError"), ::OpenAPI::toJsonValue(m_analysis_error));
    }
    if (m_analysis_status_isSet) {
        obj.insert(QString("analysisStatus"), ::OpenAPI::toJsonValue(m_analysis_status));
    }
    if (m_analysis_status_error.isSet()) {
        obj.insert(QString("analysisStatusError"), ::OpenAPI::toJsonValue(m_analysis_status_error));
    }
    if (m_continuous_analysis_isSet) {
        obj.insert(QString("continuousAnalysis"), ::OpenAPI::toJsonValue(m_continuous_analysis));
    }
    if (m_last_analysis_time_isSet) {
        obj.insert(QString("lastAnalysisTime"), ::OpenAPI::toJsonValue(m_last_analysis_time));
    }
    if (m_last_scan_time_isSet) {
        obj.insert(QString("lastScanTime"), ::OpenAPI::toJsonValue(m_last_scan_time));
    }
    if (m_sbom_status.isSet()) {
        obj.insert(QString("sbomStatus"), ::OpenAPI::toJsonValue(m_sbom_status));
    }
    return obj;
}

OAIAnalysisCompleted OAIDiscovered::getAnalysisCompleted() const {
    return m_analysis_completed;
}
void OAIDiscovered::setAnalysisCompleted(const OAIAnalysisCompleted &analysis_completed) {
    m_analysis_completed = analysis_completed;
    m_analysis_completed_isSet = true;
}

bool OAIDiscovered::is_analysis_completed_Set() const{
    return m_analysis_completed_isSet;
}

bool OAIDiscovered::is_analysis_completed_Valid() const{
    return m_analysis_completed_isValid;
}

QList<OAIStatus> OAIDiscovered::getAnalysisError() const {
    return m_analysis_error;
}
void OAIDiscovered::setAnalysisError(const QList<OAIStatus> &analysis_error) {
    m_analysis_error = analysis_error;
    m_analysis_error_isSet = true;
}

bool OAIDiscovered::is_analysis_error_Set() const{
    return m_analysis_error_isSet;
}

bool OAIDiscovered::is_analysis_error_Valid() const{
    return m_analysis_error_isValid;
}

QString OAIDiscovered::getAnalysisStatus() const {
    return m_analysis_status;
}
void OAIDiscovered::setAnalysisStatus(const QString &analysis_status) {
    m_analysis_status = analysis_status;
    m_analysis_status_isSet = true;
}

bool OAIDiscovered::is_analysis_status_Set() const{
    return m_analysis_status_isSet;
}

bool OAIDiscovered::is_analysis_status_Valid() const{
    return m_analysis_status_isValid;
}

OAIStatus OAIDiscovered::getAnalysisStatusError() const {
    return m_analysis_status_error;
}
void OAIDiscovered::setAnalysisStatusError(const OAIStatus &analysis_status_error) {
    m_analysis_status_error = analysis_status_error;
    m_analysis_status_error_isSet = true;
}

bool OAIDiscovered::is_analysis_status_error_Set() const{
    return m_analysis_status_error_isSet;
}

bool OAIDiscovered::is_analysis_status_error_Valid() const{
    return m_analysis_status_error_isValid;
}

QString OAIDiscovered::getContinuousAnalysis() const {
    return m_continuous_analysis;
}
void OAIDiscovered::setContinuousAnalysis(const QString &continuous_analysis) {
    m_continuous_analysis = continuous_analysis;
    m_continuous_analysis_isSet = true;
}

bool OAIDiscovered::is_continuous_analysis_Set() const{
    return m_continuous_analysis_isSet;
}

bool OAIDiscovered::is_continuous_analysis_Valid() const{
    return m_continuous_analysis_isValid;
}

QString OAIDiscovered::getLastAnalysisTime() const {
    return m_last_analysis_time;
}
void OAIDiscovered::setLastAnalysisTime(const QString &last_analysis_time) {
    m_last_analysis_time = last_analysis_time;
    m_last_analysis_time_isSet = true;
}

bool OAIDiscovered::is_last_analysis_time_Set() const{
    return m_last_analysis_time_isSet;
}

bool OAIDiscovered::is_last_analysis_time_Valid() const{
    return m_last_analysis_time_isValid;
}

QString OAIDiscovered::getLastScanTime() const {
    return m_last_scan_time;
}
void OAIDiscovered::setLastScanTime(const QString &last_scan_time) {
    m_last_scan_time = last_scan_time;
    m_last_scan_time_isSet = true;
}

bool OAIDiscovered::is_last_scan_time_Set() const{
    return m_last_scan_time_isSet;
}

bool OAIDiscovered::is_last_scan_time_Valid() const{
    return m_last_scan_time_isValid;
}

OAISBOMStatus OAIDiscovered::getSbomStatus() const {
    return m_sbom_status;
}
void OAIDiscovered::setSbomStatus(const OAISBOMStatus &sbom_status) {
    m_sbom_status = sbom_status;
    m_sbom_status_isSet = true;
}

bool OAIDiscovered::is_sbom_status_Set() const{
    return m_sbom_status_isSet;
}

bool OAIDiscovered::is_sbom_status_Valid() const{
    return m_sbom_status_isValid;
}

bool OAIDiscovered::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_analysis_completed.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_analysis_error.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_analysis_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_analysis_status_error.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_continuous_analysis_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_analysis_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_scan_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sbom_status.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDiscovered::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
