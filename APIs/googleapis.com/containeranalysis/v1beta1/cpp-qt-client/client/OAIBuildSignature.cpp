/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBuildSignature.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIBuildSignature::OAIBuildSignature(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIBuildSignature::OAIBuildSignature() {
    this->initializeModel();
}

OAIBuildSignature::~OAIBuildSignature() {}

void OAIBuildSignature::initializeModel() {

    m_key_id_isSet = false;
    m_key_id_isValid = false;

    m_key_type_isSet = false;
    m_key_type_isValid = false;

    m_public_key_isSet = false;
    m_public_key_isValid = false;

    m_signature_isSet = false;
    m_signature_isValid = false;
}

void OAIBuildSignature::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIBuildSignature::fromJsonObject(QJsonObject json) {

    m_key_id_isValid = ::OpenAPI::fromJsonValue(m_key_id, json[QString("keyId")]);
    m_key_id_isSet = !json[QString("keyId")].isNull() && m_key_id_isValid;

    m_key_type_isValid = ::OpenAPI::fromJsonValue(m_key_type, json[QString("keyType")]);
    m_key_type_isSet = !json[QString("keyType")].isNull() && m_key_type_isValid;

    m_public_key_isValid = ::OpenAPI::fromJsonValue(m_public_key, json[QString("publicKey")]);
    m_public_key_isSet = !json[QString("publicKey")].isNull() && m_public_key_isValid;

    m_signature_isValid = ::OpenAPI::fromJsonValue(m_signature, json[QString("signature")]);
    m_signature_isSet = !json[QString("signature")].isNull() && m_signature_isValid;
}

QString OAIBuildSignature::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIBuildSignature::asJsonObject() const {
    QJsonObject obj;
    if (m_key_id_isSet) {
        obj.insert(QString("keyId"), ::OpenAPI::toJsonValue(m_key_id));
    }
    if (m_key_type_isSet) {
        obj.insert(QString("keyType"), ::OpenAPI::toJsonValue(m_key_type));
    }
    if (m_public_key_isSet) {
        obj.insert(QString("publicKey"), ::OpenAPI::toJsonValue(m_public_key));
    }
    if (m_signature_isSet) {
        obj.insert(QString("signature"), ::OpenAPI::toJsonValue(m_signature));
    }
    return obj;
}

QString OAIBuildSignature::getKeyId() const {
    return m_key_id;
}
void OAIBuildSignature::setKeyId(const QString &key_id) {
    m_key_id = key_id;
    m_key_id_isSet = true;
}

bool OAIBuildSignature::is_key_id_Set() const{
    return m_key_id_isSet;
}

bool OAIBuildSignature::is_key_id_Valid() const{
    return m_key_id_isValid;
}

QString OAIBuildSignature::getKeyType() const {
    return m_key_type;
}
void OAIBuildSignature::setKeyType(const QString &key_type) {
    m_key_type = key_type;
    m_key_type_isSet = true;
}

bool OAIBuildSignature::is_key_type_Set() const{
    return m_key_type_isSet;
}

bool OAIBuildSignature::is_key_type_Valid() const{
    return m_key_type_isValid;
}

QString OAIBuildSignature::getPublicKey() const {
    return m_public_key;
}
void OAIBuildSignature::setPublicKey(const QString &public_key) {
    m_public_key = public_key;
    m_public_key_isSet = true;
}

bool OAIBuildSignature::is_public_key_Set() const{
    return m_public_key_isSet;
}

bool OAIBuildSignature::is_public_key_Valid() const{
    return m_public_key_isValid;
}

QByteArray OAIBuildSignature::getSignature() const {
    return m_signature;
}
void OAIBuildSignature::setSignature(const QByteArray &signature) {
    m_signature = signature;
    m_signature_isSet = true;
}

bool OAIBuildSignature::is_signature_Set() const{
    return m_signature_isSet;
}

bool OAIBuildSignature::is_signature_Valid() const{
    return m_signature_isValid;
}

bool OAIBuildSignature::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_key_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_public_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_signature_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIBuildSignature::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
