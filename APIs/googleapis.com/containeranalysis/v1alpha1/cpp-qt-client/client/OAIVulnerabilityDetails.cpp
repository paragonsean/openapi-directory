/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVulnerabilityDetails.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVulnerabilityDetails::OAIVulnerabilityDetails(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVulnerabilityDetails::OAIVulnerabilityDetails() {
    this->initializeModel();
}

OAIVulnerabilityDetails::~OAIVulnerabilityDetails() {}

void OAIVulnerabilityDetails::initializeModel() {

    m_cvss_score_isSet = false;
    m_cvss_score_isValid = false;

    m_cvss_v2_isSet = false;
    m_cvss_v2_isValid = false;

    m_cvss_v3_isSet = false;
    m_cvss_v3_isValid = false;

    m_cvss_version_isSet = false;
    m_cvss_version_isValid = false;

    m_effective_severity_isSet = false;
    m_effective_severity_isValid = false;

    m_extra_details_isSet = false;
    m_extra_details_isValid = false;

    m_package_issue_isSet = false;
    m_package_issue_isValid = false;

    m_severity_isSet = false;
    m_severity_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_vex_assessment_isSet = false;
    m_vex_assessment_isValid = false;
}

void OAIVulnerabilityDetails::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVulnerabilityDetails::fromJsonObject(QJsonObject json) {

    m_cvss_score_isValid = ::OpenAPI::fromJsonValue(m_cvss_score, json[QString("cvssScore")]);
    m_cvss_score_isSet = !json[QString("cvssScore")].isNull() && m_cvss_score_isValid;

    m_cvss_v2_isValid = ::OpenAPI::fromJsonValue(m_cvss_v2, json[QString("cvssV2")]);
    m_cvss_v2_isSet = !json[QString("cvssV2")].isNull() && m_cvss_v2_isValid;

    m_cvss_v3_isValid = ::OpenAPI::fromJsonValue(m_cvss_v3, json[QString("cvssV3")]);
    m_cvss_v3_isSet = !json[QString("cvssV3")].isNull() && m_cvss_v3_isValid;

    m_cvss_version_isValid = ::OpenAPI::fromJsonValue(m_cvss_version, json[QString("cvssVersion")]);
    m_cvss_version_isSet = !json[QString("cvssVersion")].isNull() && m_cvss_version_isValid;

    m_effective_severity_isValid = ::OpenAPI::fromJsonValue(m_effective_severity, json[QString("effectiveSeverity")]);
    m_effective_severity_isSet = !json[QString("effectiveSeverity")].isNull() && m_effective_severity_isValid;

    m_extra_details_isValid = ::OpenAPI::fromJsonValue(m_extra_details, json[QString("extraDetails")]);
    m_extra_details_isSet = !json[QString("extraDetails")].isNull() && m_extra_details_isValid;

    m_package_issue_isValid = ::OpenAPI::fromJsonValue(m_package_issue, json[QString("packageIssue")]);
    m_package_issue_isSet = !json[QString("packageIssue")].isNull() && m_package_issue_isValid;

    m_severity_isValid = ::OpenAPI::fromJsonValue(m_severity, json[QString("severity")]);
    m_severity_isSet = !json[QString("severity")].isNull() && m_severity_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_vex_assessment_isValid = ::OpenAPI::fromJsonValue(m_vex_assessment, json[QString("vexAssessment")]);
    m_vex_assessment_isSet = !json[QString("vexAssessment")].isNull() && m_vex_assessment_isValid;
}

QString OAIVulnerabilityDetails::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVulnerabilityDetails::asJsonObject() const {
    QJsonObject obj;
    if (m_cvss_score_isSet) {
        obj.insert(QString("cvssScore"), ::OpenAPI::toJsonValue(m_cvss_score));
    }
    if (m_cvss_v2.isSet()) {
        obj.insert(QString("cvssV2"), ::OpenAPI::toJsonValue(m_cvss_v2));
    }
    if (m_cvss_v3.isSet()) {
        obj.insert(QString("cvssV3"), ::OpenAPI::toJsonValue(m_cvss_v3));
    }
    if (m_cvss_version_isSet) {
        obj.insert(QString("cvssVersion"), ::OpenAPI::toJsonValue(m_cvss_version));
    }
    if (m_effective_severity_isSet) {
        obj.insert(QString("effectiveSeverity"), ::OpenAPI::toJsonValue(m_effective_severity));
    }
    if (m_extra_details_isSet) {
        obj.insert(QString("extraDetails"), ::OpenAPI::toJsonValue(m_extra_details));
    }
    if (m_package_issue.size() > 0) {
        obj.insert(QString("packageIssue"), ::OpenAPI::toJsonValue(m_package_issue));
    }
    if (m_severity_isSet) {
        obj.insert(QString("severity"), ::OpenAPI::toJsonValue(m_severity));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_vex_assessment.isSet()) {
        obj.insert(QString("vexAssessment"), ::OpenAPI::toJsonValue(m_vex_assessment));
    }
    return obj;
}

float OAIVulnerabilityDetails::getCvssScore() const {
    return m_cvss_score;
}
void OAIVulnerabilityDetails::setCvssScore(const float &cvss_score) {
    m_cvss_score = cvss_score;
    m_cvss_score_isSet = true;
}

bool OAIVulnerabilityDetails::is_cvss_score_Set() const{
    return m_cvss_score_isSet;
}

bool OAIVulnerabilityDetails::is_cvss_score_Valid() const{
    return m_cvss_score_isValid;
}

OAICVSS OAIVulnerabilityDetails::getCvssV2() const {
    return m_cvss_v2;
}
void OAIVulnerabilityDetails::setCvssV2(const OAICVSS &cvss_v2) {
    m_cvss_v2 = cvss_v2;
    m_cvss_v2_isSet = true;
}

bool OAIVulnerabilityDetails::is_cvss_v2_Set() const{
    return m_cvss_v2_isSet;
}

bool OAIVulnerabilityDetails::is_cvss_v2_Valid() const{
    return m_cvss_v2_isValid;
}

OAICVSS OAIVulnerabilityDetails::getCvssV3() const {
    return m_cvss_v3;
}
void OAIVulnerabilityDetails::setCvssV3(const OAICVSS &cvss_v3) {
    m_cvss_v3 = cvss_v3;
    m_cvss_v3_isSet = true;
}

bool OAIVulnerabilityDetails::is_cvss_v3_Set() const{
    return m_cvss_v3_isSet;
}

bool OAIVulnerabilityDetails::is_cvss_v3_Valid() const{
    return m_cvss_v3_isValid;
}

QString OAIVulnerabilityDetails::getCvssVersion() const {
    return m_cvss_version;
}
void OAIVulnerabilityDetails::setCvssVersion(const QString &cvss_version) {
    m_cvss_version = cvss_version;
    m_cvss_version_isSet = true;
}

bool OAIVulnerabilityDetails::is_cvss_version_Set() const{
    return m_cvss_version_isSet;
}

bool OAIVulnerabilityDetails::is_cvss_version_Valid() const{
    return m_cvss_version_isValid;
}

QString OAIVulnerabilityDetails::getEffectiveSeverity() const {
    return m_effective_severity;
}
void OAIVulnerabilityDetails::setEffectiveSeverity(const QString &effective_severity) {
    m_effective_severity = effective_severity;
    m_effective_severity_isSet = true;
}

bool OAIVulnerabilityDetails::is_effective_severity_Set() const{
    return m_effective_severity_isSet;
}

bool OAIVulnerabilityDetails::is_effective_severity_Valid() const{
    return m_effective_severity_isValid;
}

QString OAIVulnerabilityDetails::getExtraDetails() const {
    return m_extra_details;
}
void OAIVulnerabilityDetails::setExtraDetails(const QString &extra_details) {
    m_extra_details = extra_details;
    m_extra_details_isSet = true;
}

bool OAIVulnerabilityDetails::is_extra_details_Set() const{
    return m_extra_details_isSet;
}

bool OAIVulnerabilityDetails::is_extra_details_Valid() const{
    return m_extra_details_isValid;
}

QList<OAIPackageIssue> OAIVulnerabilityDetails::getPackageIssue() const {
    return m_package_issue;
}
void OAIVulnerabilityDetails::setPackageIssue(const QList<OAIPackageIssue> &package_issue) {
    m_package_issue = package_issue;
    m_package_issue_isSet = true;
}

bool OAIVulnerabilityDetails::is_package_issue_Set() const{
    return m_package_issue_isSet;
}

bool OAIVulnerabilityDetails::is_package_issue_Valid() const{
    return m_package_issue_isValid;
}

QString OAIVulnerabilityDetails::getSeverity() const {
    return m_severity;
}
void OAIVulnerabilityDetails::setSeverity(const QString &severity) {
    m_severity = severity;
    m_severity_isSet = true;
}

bool OAIVulnerabilityDetails::is_severity_Set() const{
    return m_severity_isSet;
}

bool OAIVulnerabilityDetails::is_severity_Valid() const{
    return m_severity_isValid;
}

QString OAIVulnerabilityDetails::getType() const {
    return m_type;
}
void OAIVulnerabilityDetails::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIVulnerabilityDetails::is_type_Set() const{
    return m_type_isSet;
}

bool OAIVulnerabilityDetails::is_type_Valid() const{
    return m_type_isValid;
}

OAIVexAssessment OAIVulnerabilityDetails::getVexAssessment() const {
    return m_vex_assessment;
}
void OAIVulnerabilityDetails::setVexAssessment(const OAIVexAssessment &vex_assessment) {
    m_vex_assessment = vex_assessment;
    m_vex_assessment_isSet = true;
}

bool OAIVulnerabilityDetails::is_vex_assessment_Set() const{
    return m_vex_assessment_isSet;
}

bool OAIVulnerabilityDetails::is_vex_assessment_Valid() const{
    return m_vex_assessment_isValid;
}

bool OAIVulnerabilityDetails::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cvss_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_v2.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_v3.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_effective_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_extra_details_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_issue.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vex_assessment.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVulnerabilityDetails::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
