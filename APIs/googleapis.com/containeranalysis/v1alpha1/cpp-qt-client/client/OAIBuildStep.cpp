/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBuildStep.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIBuildStep::OAIBuildStep(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIBuildStep::OAIBuildStep() {
    this->initializeModel();
}

OAIBuildStep::~OAIBuildStep() {}

void OAIBuildStep::initializeModel() {

    m_allow_exit_codes_isSet = false;
    m_allow_exit_codes_isValid = false;

    m_allow_failure_isSet = false;
    m_allow_failure_isValid = false;

    m_args_isSet = false;
    m_args_isValid = false;

    m_automap_substitutions_isSet = false;
    m_automap_substitutions_isValid = false;

    m_dir_isSet = false;
    m_dir_isValid = false;

    m_entrypoint_isSet = false;
    m_entrypoint_isValid = false;

    m_env_isSet = false;
    m_env_isValid = false;

    m_exit_code_isSet = false;
    m_exit_code_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_pull_timing_isSet = false;
    m_pull_timing_isValid = false;

    m_script_isSet = false;
    m_script_isValid = false;

    m_secret_env_isSet = false;
    m_secret_env_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_timeout_isSet = false;
    m_timeout_isValid = false;

    m_timing_isSet = false;
    m_timing_isValid = false;

    m_volumes_isSet = false;
    m_volumes_isValid = false;

    m_wait_for_isSet = false;
    m_wait_for_isValid = false;
}

void OAIBuildStep::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIBuildStep::fromJsonObject(QJsonObject json) {

    m_allow_exit_codes_isValid = ::OpenAPI::fromJsonValue(m_allow_exit_codes, json[QString("allowExitCodes")]);
    m_allow_exit_codes_isSet = !json[QString("allowExitCodes")].isNull() && m_allow_exit_codes_isValid;

    m_allow_failure_isValid = ::OpenAPI::fromJsonValue(m_allow_failure, json[QString("allowFailure")]);
    m_allow_failure_isSet = !json[QString("allowFailure")].isNull() && m_allow_failure_isValid;

    m_args_isValid = ::OpenAPI::fromJsonValue(m_args, json[QString("args")]);
    m_args_isSet = !json[QString("args")].isNull() && m_args_isValid;

    m_automap_substitutions_isValid = ::OpenAPI::fromJsonValue(m_automap_substitutions, json[QString("automapSubstitutions")]);
    m_automap_substitutions_isSet = !json[QString("automapSubstitutions")].isNull() && m_automap_substitutions_isValid;

    m_dir_isValid = ::OpenAPI::fromJsonValue(m_dir, json[QString("dir")]);
    m_dir_isSet = !json[QString("dir")].isNull() && m_dir_isValid;

    m_entrypoint_isValid = ::OpenAPI::fromJsonValue(m_entrypoint, json[QString("entrypoint")]);
    m_entrypoint_isSet = !json[QString("entrypoint")].isNull() && m_entrypoint_isValid;

    m_env_isValid = ::OpenAPI::fromJsonValue(m_env, json[QString("env")]);
    m_env_isSet = !json[QString("env")].isNull() && m_env_isValid;

    m_exit_code_isValid = ::OpenAPI::fromJsonValue(m_exit_code, json[QString("exitCode")]);
    m_exit_code_isSet = !json[QString("exitCode")].isNull() && m_exit_code_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_pull_timing_isValid = ::OpenAPI::fromJsonValue(m_pull_timing, json[QString("pullTiming")]);
    m_pull_timing_isSet = !json[QString("pullTiming")].isNull() && m_pull_timing_isValid;

    m_script_isValid = ::OpenAPI::fromJsonValue(m_script, json[QString("script")]);
    m_script_isSet = !json[QString("script")].isNull() && m_script_isValid;

    m_secret_env_isValid = ::OpenAPI::fromJsonValue(m_secret_env, json[QString("secretEnv")]);
    m_secret_env_isSet = !json[QString("secretEnv")].isNull() && m_secret_env_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_timeout_isValid = ::OpenAPI::fromJsonValue(m_timeout, json[QString("timeout")]);
    m_timeout_isSet = !json[QString("timeout")].isNull() && m_timeout_isValid;

    m_timing_isValid = ::OpenAPI::fromJsonValue(m_timing, json[QString("timing")]);
    m_timing_isSet = !json[QString("timing")].isNull() && m_timing_isValid;

    m_volumes_isValid = ::OpenAPI::fromJsonValue(m_volumes, json[QString("volumes")]);
    m_volumes_isSet = !json[QString("volumes")].isNull() && m_volumes_isValid;

    m_wait_for_isValid = ::OpenAPI::fromJsonValue(m_wait_for, json[QString("waitFor")]);
    m_wait_for_isSet = !json[QString("waitFor")].isNull() && m_wait_for_isValid;
}

QString OAIBuildStep::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIBuildStep::asJsonObject() const {
    QJsonObject obj;
    if (m_allow_exit_codes.size() > 0) {
        obj.insert(QString("allowExitCodes"), ::OpenAPI::toJsonValue(m_allow_exit_codes));
    }
    if (m_allow_failure_isSet) {
        obj.insert(QString("allowFailure"), ::OpenAPI::toJsonValue(m_allow_failure));
    }
    if (m_args.size() > 0) {
        obj.insert(QString("args"), ::OpenAPI::toJsonValue(m_args));
    }
    if (m_automap_substitutions_isSet) {
        obj.insert(QString("automapSubstitutions"), ::OpenAPI::toJsonValue(m_automap_substitutions));
    }
    if (m_dir_isSet) {
        obj.insert(QString("dir"), ::OpenAPI::toJsonValue(m_dir));
    }
    if (m_entrypoint_isSet) {
        obj.insert(QString("entrypoint"), ::OpenAPI::toJsonValue(m_entrypoint));
    }
    if (m_env.size() > 0) {
        obj.insert(QString("env"), ::OpenAPI::toJsonValue(m_env));
    }
    if (m_exit_code_isSet) {
        obj.insert(QString("exitCode"), ::OpenAPI::toJsonValue(m_exit_code));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_pull_timing.isSet()) {
        obj.insert(QString("pullTiming"), ::OpenAPI::toJsonValue(m_pull_timing));
    }
    if (m_script_isSet) {
        obj.insert(QString("script"), ::OpenAPI::toJsonValue(m_script));
    }
    if (m_secret_env.size() > 0) {
        obj.insert(QString("secretEnv"), ::OpenAPI::toJsonValue(m_secret_env));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_timeout_isSet) {
        obj.insert(QString("timeout"), ::OpenAPI::toJsonValue(m_timeout));
    }
    if (m_timing.isSet()) {
        obj.insert(QString("timing"), ::OpenAPI::toJsonValue(m_timing));
    }
    if (m_volumes.size() > 0) {
        obj.insert(QString("volumes"), ::OpenAPI::toJsonValue(m_volumes));
    }
    if (m_wait_for.size() > 0) {
        obj.insert(QString("waitFor"), ::OpenAPI::toJsonValue(m_wait_for));
    }
    return obj;
}

QList<qint32> OAIBuildStep::getAllowExitCodes() const {
    return m_allow_exit_codes;
}
void OAIBuildStep::setAllowExitCodes(const QList<qint32> &allow_exit_codes) {
    m_allow_exit_codes = allow_exit_codes;
    m_allow_exit_codes_isSet = true;
}

bool OAIBuildStep::is_allow_exit_codes_Set() const{
    return m_allow_exit_codes_isSet;
}

bool OAIBuildStep::is_allow_exit_codes_Valid() const{
    return m_allow_exit_codes_isValid;
}

bool OAIBuildStep::isAllowFailure() const {
    return m_allow_failure;
}
void OAIBuildStep::setAllowFailure(const bool &allow_failure) {
    m_allow_failure = allow_failure;
    m_allow_failure_isSet = true;
}

bool OAIBuildStep::is_allow_failure_Set() const{
    return m_allow_failure_isSet;
}

bool OAIBuildStep::is_allow_failure_Valid() const{
    return m_allow_failure_isValid;
}

QList<QString> OAIBuildStep::getArgs() const {
    return m_args;
}
void OAIBuildStep::setArgs(const QList<QString> &args) {
    m_args = args;
    m_args_isSet = true;
}

bool OAIBuildStep::is_args_Set() const{
    return m_args_isSet;
}

bool OAIBuildStep::is_args_Valid() const{
    return m_args_isValid;
}

bool OAIBuildStep::isAutomapSubstitutions() const {
    return m_automap_substitutions;
}
void OAIBuildStep::setAutomapSubstitutions(const bool &automap_substitutions) {
    m_automap_substitutions = automap_substitutions;
    m_automap_substitutions_isSet = true;
}

bool OAIBuildStep::is_automap_substitutions_Set() const{
    return m_automap_substitutions_isSet;
}

bool OAIBuildStep::is_automap_substitutions_Valid() const{
    return m_automap_substitutions_isValid;
}

QString OAIBuildStep::getDir() const {
    return m_dir;
}
void OAIBuildStep::setDir(const QString &dir) {
    m_dir = dir;
    m_dir_isSet = true;
}

bool OAIBuildStep::is_dir_Set() const{
    return m_dir_isSet;
}

bool OAIBuildStep::is_dir_Valid() const{
    return m_dir_isValid;
}

QString OAIBuildStep::getEntrypoint() const {
    return m_entrypoint;
}
void OAIBuildStep::setEntrypoint(const QString &entrypoint) {
    m_entrypoint = entrypoint;
    m_entrypoint_isSet = true;
}

bool OAIBuildStep::is_entrypoint_Set() const{
    return m_entrypoint_isSet;
}

bool OAIBuildStep::is_entrypoint_Valid() const{
    return m_entrypoint_isValid;
}

QList<QString> OAIBuildStep::getEnv() const {
    return m_env;
}
void OAIBuildStep::setEnv(const QList<QString> &env) {
    m_env = env;
    m_env_isSet = true;
}

bool OAIBuildStep::is_env_Set() const{
    return m_env_isSet;
}

bool OAIBuildStep::is_env_Valid() const{
    return m_env_isValid;
}

qint32 OAIBuildStep::getExitCode() const {
    return m_exit_code;
}
void OAIBuildStep::setExitCode(const qint32 &exit_code) {
    m_exit_code = exit_code;
    m_exit_code_isSet = true;
}

bool OAIBuildStep::is_exit_code_Set() const{
    return m_exit_code_isSet;
}

bool OAIBuildStep::is_exit_code_Valid() const{
    return m_exit_code_isValid;
}

QString OAIBuildStep::getId() const {
    return m_id;
}
void OAIBuildStep::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIBuildStep::is_id_Set() const{
    return m_id_isSet;
}

bool OAIBuildStep::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIBuildStep::getName() const {
    return m_name;
}
void OAIBuildStep::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIBuildStep::is_name_Set() const{
    return m_name_isSet;
}

bool OAIBuildStep::is_name_Valid() const{
    return m_name_isValid;
}

OAITimeSpan OAIBuildStep::getPullTiming() const {
    return m_pull_timing;
}
void OAIBuildStep::setPullTiming(const OAITimeSpan &pull_timing) {
    m_pull_timing = pull_timing;
    m_pull_timing_isSet = true;
}

bool OAIBuildStep::is_pull_timing_Set() const{
    return m_pull_timing_isSet;
}

bool OAIBuildStep::is_pull_timing_Valid() const{
    return m_pull_timing_isValid;
}

QString OAIBuildStep::getScript() const {
    return m_script;
}
void OAIBuildStep::setScript(const QString &script) {
    m_script = script;
    m_script_isSet = true;
}

bool OAIBuildStep::is_script_Set() const{
    return m_script_isSet;
}

bool OAIBuildStep::is_script_Valid() const{
    return m_script_isValid;
}

QList<QString> OAIBuildStep::getSecretEnv() const {
    return m_secret_env;
}
void OAIBuildStep::setSecretEnv(const QList<QString> &secret_env) {
    m_secret_env = secret_env;
    m_secret_env_isSet = true;
}

bool OAIBuildStep::is_secret_env_Set() const{
    return m_secret_env_isSet;
}

bool OAIBuildStep::is_secret_env_Valid() const{
    return m_secret_env_isValid;
}

QString OAIBuildStep::getStatus() const {
    return m_status;
}
void OAIBuildStep::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIBuildStep::is_status_Set() const{
    return m_status_isSet;
}

bool OAIBuildStep::is_status_Valid() const{
    return m_status_isValid;
}

QString OAIBuildStep::getTimeout() const {
    return m_timeout;
}
void OAIBuildStep::setTimeout(const QString &timeout) {
    m_timeout = timeout;
    m_timeout_isSet = true;
}

bool OAIBuildStep::is_timeout_Set() const{
    return m_timeout_isSet;
}

bool OAIBuildStep::is_timeout_Valid() const{
    return m_timeout_isValid;
}

OAITimeSpan OAIBuildStep::getTiming() const {
    return m_timing;
}
void OAIBuildStep::setTiming(const OAITimeSpan &timing) {
    m_timing = timing;
    m_timing_isSet = true;
}

bool OAIBuildStep::is_timing_Set() const{
    return m_timing_isSet;
}

bool OAIBuildStep::is_timing_Valid() const{
    return m_timing_isValid;
}

QList<OAIVolume> OAIBuildStep::getVolumes() const {
    return m_volumes;
}
void OAIBuildStep::setVolumes(const QList<OAIVolume> &volumes) {
    m_volumes = volumes;
    m_volumes_isSet = true;
}

bool OAIBuildStep::is_volumes_Set() const{
    return m_volumes_isSet;
}

bool OAIBuildStep::is_volumes_Valid() const{
    return m_volumes_isValid;
}

QList<QString> OAIBuildStep::getWaitFor() const {
    return m_wait_for;
}
void OAIBuildStep::setWaitFor(const QList<QString> &wait_for) {
    m_wait_for = wait_for;
    m_wait_for_isSet = true;
}

bool OAIBuildStep::is_wait_for_Set() const{
    return m_wait_for_isSet;
}

bool OAIBuildStep::is_wait_for_Valid() const{
    return m_wait_for_isValid;
}

bool OAIBuildStep::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allow_exit_codes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_allow_failure_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_args.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_automap_substitutions_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entrypoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_env.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_exit_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pull_timing.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_script_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_env.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timing.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_volumes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wait_for.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIBuildStep::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
