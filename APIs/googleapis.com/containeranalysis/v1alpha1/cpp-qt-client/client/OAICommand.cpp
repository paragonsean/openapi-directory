/**
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICommand.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICommand::OAICommand(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICommand::OAICommand() {
    this->initializeModel();
}

OAICommand::~OAICommand() {}

void OAICommand::initializeModel() {

    m_args_isSet = false;
    m_args_isValid = false;

    m_dir_isSet = false;
    m_dir_isValid = false;

    m_env_isSet = false;
    m_env_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_wait_for_isSet = false;
    m_wait_for_isValid = false;
}

void OAICommand::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICommand::fromJsonObject(QJsonObject json) {

    m_args_isValid = ::OpenAPI::fromJsonValue(m_args, json[QString("args")]);
    m_args_isSet = !json[QString("args")].isNull() && m_args_isValid;

    m_dir_isValid = ::OpenAPI::fromJsonValue(m_dir, json[QString("dir")]);
    m_dir_isSet = !json[QString("dir")].isNull() && m_dir_isValid;

    m_env_isValid = ::OpenAPI::fromJsonValue(m_env, json[QString("env")]);
    m_env_isSet = !json[QString("env")].isNull() && m_env_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_wait_for_isValid = ::OpenAPI::fromJsonValue(m_wait_for, json[QString("waitFor")]);
    m_wait_for_isSet = !json[QString("waitFor")].isNull() && m_wait_for_isValid;
}

QString OAICommand::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICommand::asJsonObject() const {
    QJsonObject obj;
    if (m_args.size() > 0) {
        obj.insert(QString("args"), ::OpenAPI::toJsonValue(m_args));
    }
    if (m_dir_isSet) {
        obj.insert(QString("dir"), ::OpenAPI::toJsonValue(m_dir));
    }
    if (m_env.size() > 0) {
        obj.insert(QString("env"), ::OpenAPI::toJsonValue(m_env));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_wait_for.size() > 0) {
        obj.insert(QString("waitFor"), ::OpenAPI::toJsonValue(m_wait_for));
    }
    return obj;
}

QList<QString> OAICommand::getArgs() const {
    return m_args;
}
void OAICommand::setArgs(const QList<QString> &args) {
    m_args = args;
    m_args_isSet = true;
}

bool OAICommand::is_args_Set() const{
    return m_args_isSet;
}

bool OAICommand::is_args_Valid() const{
    return m_args_isValid;
}

QString OAICommand::getDir() const {
    return m_dir;
}
void OAICommand::setDir(const QString &dir) {
    m_dir = dir;
    m_dir_isSet = true;
}

bool OAICommand::is_dir_Set() const{
    return m_dir_isSet;
}

bool OAICommand::is_dir_Valid() const{
    return m_dir_isValid;
}

QList<QString> OAICommand::getEnv() const {
    return m_env;
}
void OAICommand::setEnv(const QList<QString> &env) {
    m_env = env;
    m_env_isSet = true;
}

bool OAICommand::is_env_Set() const{
    return m_env_isSet;
}

bool OAICommand::is_env_Valid() const{
    return m_env_isValid;
}

QString OAICommand::getId() const {
    return m_id;
}
void OAICommand::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAICommand::is_id_Set() const{
    return m_id_isSet;
}

bool OAICommand::is_id_Valid() const{
    return m_id_isValid;
}

QString OAICommand::getName() const {
    return m_name;
}
void OAICommand::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAICommand::is_name_Set() const{
    return m_name_isSet;
}

bool OAICommand::is_name_Valid() const{
    return m_name_isValid;
}

QList<QString> OAICommand::getWaitFor() const {
    return m_wait_for;
}
void OAICommand::setWaitFor(const QList<QString> &wait_for) {
    m_wait_for = wait_for;
    m_wait_for_isSet = true;
}

bool OAICommand::is_wait_for_Set() const{
    return m_wait_for_isSet;
}

bool OAICommand::is_wait_for_Valid() const{
    return m_wait_for_isValid;
}

bool OAICommand::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_args.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_dir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_env.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wait_for.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICommand::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
