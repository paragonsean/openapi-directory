/*
 * Container Analysis API
 * This API is a prerequisite for leveraging Artifact Analysis scanning capabilities in both Artifact Registry and with Advanced Vulnerability Insights (runtime scanning) in GKE. In addition, the Container Analysis API is an implementation of the Grafeas API, which enables storing, querying, and retrieval of critical metadata about all of your software artifacts.
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ExternalRef;
import org.openapitools.client.model.License;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PackageInfoNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:46.438210-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PackageInfoNote {
  public static final String SERIALIZED_NAME_ANALYZED = "analyzed";
  @SerializedName(SERIALIZED_NAME_ANALYZED)
  private Boolean analyzed;

  public static final String SERIALIZED_NAME_ATTRIBUTION = "attribution";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTION)
  private String attribution;

  public static final String SERIALIZED_NAME_CHECKSUM = "checksum";
  @SerializedName(SERIALIZED_NAME_CHECKSUM)
  private String checksum;

  public static final String SERIALIZED_NAME_COPYRIGHT = "copyright";
  @SerializedName(SERIALIZED_NAME_COPYRIGHT)
  private String copyright;

  public static final String SERIALIZED_NAME_DETAILED_DESCRIPTION = "detailedDescription";
  @SerializedName(SERIALIZED_NAME_DETAILED_DESCRIPTION)
  private String detailedDescription;

  public static final String SERIALIZED_NAME_DOWNLOAD_LOCATION = "downloadLocation";
  @SerializedName(SERIALIZED_NAME_DOWNLOAD_LOCATION)
  private String downloadLocation;

  public static final String SERIALIZED_NAME_EXTERNAL_REFS = "externalRefs";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_REFS)
  private List<ExternalRef> externalRefs = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILES_LICENSE_INFO = "filesLicenseInfo";
  @SerializedName(SERIALIZED_NAME_FILES_LICENSE_INFO)
  private List<String> filesLicenseInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_HOME_PAGE = "homePage";
  @SerializedName(SERIALIZED_NAME_HOME_PAGE)
  private String homePage;

  public static final String SERIALIZED_NAME_LICENSE_DECLARED = "licenseDeclared";
  @SerializedName(SERIALIZED_NAME_LICENSE_DECLARED)
  private License licenseDeclared;

  public static final String SERIALIZED_NAME_ORIGINATOR = "originator";
  @SerializedName(SERIALIZED_NAME_ORIGINATOR)
  private String originator;

  public static final String SERIALIZED_NAME_PACKAGE_TYPE = "packageType";
  @SerializedName(SERIALIZED_NAME_PACKAGE_TYPE)
  private String packageType;

  public static final String SERIALIZED_NAME_SUMMARY_DESCRIPTION = "summaryDescription";
  @SerializedName(SERIALIZED_NAME_SUMMARY_DESCRIPTION)
  private String summaryDescription;

  public static final String SERIALIZED_NAME_SUPPLIER = "supplier";
  @SerializedName(SERIALIZED_NAME_SUPPLIER)
  private String supplier;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_VERIFICATION_CODE = "verificationCode";
  @SerializedName(SERIALIZED_NAME_VERIFICATION_CODE)
  private String verificationCode;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public PackageInfoNote() {
  }

  public PackageInfoNote analyzed(Boolean analyzed) {
    this.analyzed = analyzed;
    return this;
  }

  /**
   * Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
   * @return analyzed
   */
  @javax.annotation.Nullable
  public Boolean getAnalyzed() {
    return analyzed;
  }

  public void setAnalyzed(Boolean analyzed) {
    this.analyzed = analyzed;
  }


  public PackageInfoNote attribution(String attribution) {
    this.attribution = attribution;
    return this;
  }

  /**
   * A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
   * @return attribution
   */
  @javax.annotation.Nullable
  public String getAttribution() {
    return attribution;
  }

  public void setAttribution(String attribution) {
    this.attribution = attribution;
  }


  public PackageInfoNote checksum(String checksum) {
    this.checksum = checksum;
    return this;
  }

  /**
   * Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
   * @return checksum
   */
  @javax.annotation.Nullable
  public String getChecksum() {
    return checksum;
  }

  public void setChecksum(String checksum) {
    this.checksum = checksum;
  }


  public PackageInfoNote copyright(String copyright) {
    this.copyright = copyright;
    return this;
  }

  /**
   * Identify the copyright holders of the package, as well as any dates present
   * @return copyright
   */
  @javax.annotation.Nullable
  public String getCopyright() {
    return copyright;
  }

  public void setCopyright(String copyright) {
    this.copyright = copyright;
  }


  public PackageInfoNote detailedDescription(String detailedDescription) {
    this.detailedDescription = detailedDescription;
    return this;
  }

  /**
   * A more detailed description of the package
   * @return detailedDescription
   */
  @javax.annotation.Nullable
  public String getDetailedDescription() {
    return detailedDescription;
  }

  public void setDetailedDescription(String detailedDescription) {
    this.detailedDescription = detailedDescription;
  }


  public PackageInfoNote downloadLocation(String downloadLocation) {
    this.downloadLocation = downloadLocation;
    return this;
  }

  /**
   * This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
   * @return downloadLocation
   */
  @javax.annotation.Nullable
  public String getDownloadLocation() {
    return downloadLocation;
  }

  public void setDownloadLocation(String downloadLocation) {
    this.downloadLocation = downloadLocation;
  }


  public PackageInfoNote externalRefs(List<ExternalRef> externalRefs) {
    this.externalRefs = externalRefs;
    return this;
  }

  public PackageInfoNote addExternalRefsItem(ExternalRef externalRefsItem) {
    if (this.externalRefs == null) {
      this.externalRefs = new ArrayList<>();
    }
    this.externalRefs.add(externalRefsItem);
    return this;
  }

  /**
   * ExternalRef
   * @return externalRefs
   */
  @javax.annotation.Nullable
  public List<ExternalRef> getExternalRefs() {
    return externalRefs;
  }

  public void setExternalRefs(List<ExternalRef> externalRefs) {
    this.externalRefs = externalRefs;
  }


  public PackageInfoNote filesLicenseInfo(List<String> filesLicenseInfo) {
    this.filesLicenseInfo = filesLicenseInfo;
    return this;
  }

  public PackageInfoNote addFilesLicenseInfoItem(String filesLicenseInfoItem) {
    if (this.filesLicenseInfo == null) {
      this.filesLicenseInfo = new ArrayList<>();
    }
    this.filesLicenseInfo.add(filesLicenseInfoItem);
    return this;
  }

  /**
   * Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field â€“ it is simply a listing of all licenses found
   * @return filesLicenseInfo
   */
  @javax.annotation.Nullable
  public List<String> getFilesLicenseInfo() {
    return filesLicenseInfo;
  }

  public void setFilesLicenseInfo(List<String> filesLicenseInfo) {
    this.filesLicenseInfo = filesLicenseInfo;
  }


  public PackageInfoNote homePage(String homePage) {
    this.homePage = homePage;
    return this;
  }

  /**
   * Provide a place for the SPDX file creator to record a web site that serves as the package&#39;s home page
   * @return homePage
   */
  @javax.annotation.Nullable
  public String getHomePage() {
    return homePage;
  }

  public void setHomePage(String homePage) {
    this.homePage = homePage;
  }


  public PackageInfoNote licenseDeclared(License licenseDeclared) {
    this.licenseDeclared = licenseDeclared;
    return this;
  }

  /**
   * Get licenseDeclared
   * @return licenseDeclared
   */
  @javax.annotation.Nullable
  public License getLicenseDeclared() {
    return licenseDeclared;
  }

  public void setLicenseDeclared(License licenseDeclared) {
    this.licenseDeclared = licenseDeclared;
  }


  public PackageInfoNote originator(String originator) {
    this.originator = originator;
    return this;
  }

  /**
   * If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
   * @return originator
   */
  @javax.annotation.Nullable
  public String getOriginator() {
    return originator;
  }

  public void setOriginator(String originator) {
    this.originator = originator;
  }


  public PackageInfoNote packageType(String packageType) {
    this.packageType = packageType;
    return this;
  }

  /**
   * The type of package: OS, MAVEN, GO, GO_STDLIB, etc.
   * @return packageType
   */
  @javax.annotation.Nullable
  public String getPackageType() {
    return packageType;
  }

  public void setPackageType(String packageType) {
    this.packageType = packageType;
  }


  public PackageInfoNote summaryDescription(String summaryDescription) {
    this.summaryDescription = summaryDescription;
    return this;
  }

  /**
   * A short description of the package
   * @return summaryDescription
   */
  @javax.annotation.Nullable
  public String getSummaryDescription() {
    return summaryDescription;
  }

  public void setSummaryDescription(String summaryDescription) {
    this.summaryDescription = summaryDescription;
  }


  public PackageInfoNote supplier(String supplier) {
    this.supplier = supplier;
    return this;
  }

  /**
   * Identify the actual distribution source for the package/directory identified in the SPDX file
   * @return supplier
   */
  @javax.annotation.Nullable
  public String getSupplier() {
    return supplier;
  }

  public void setSupplier(String supplier) {
    this.supplier = supplier;
  }


  public PackageInfoNote title(String title) {
    this.title = title;
    return this;
  }

  /**
   * Identify the full name of the package as given by the Package Originator
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public PackageInfoNote verificationCode(String verificationCode) {
    this.verificationCode = verificationCode;
    return this;
  }

  /**
   * This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
   * @return verificationCode
   */
  @javax.annotation.Nullable
  public String getVerificationCode() {
    return verificationCode;
  }

  public void setVerificationCode(String verificationCode) {
    this.verificationCode = verificationCode;
  }


  public PackageInfoNote version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Identify the version of the package
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PackageInfoNote packageInfoNote = (PackageInfoNote) o;
    return Objects.equals(this.analyzed, packageInfoNote.analyzed) &&
        Objects.equals(this.attribution, packageInfoNote.attribution) &&
        Objects.equals(this.checksum, packageInfoNote.checksum) &&
        Objects.equals(this.copyright, packageInfoNote.copyright) &&
        Objects.equals(this.detailedDescription, packageInfoNote.detailedDescription) &&
        Objects.equals(this.downloadLocation, packageInfoNote.downloadLocation) &&
        Objects.equals(this.externalRefs, packageInfoNote.externalRefs) &&
        Objects.equals(this.filesLicenseInfo, packageInfoNote.filesLicenseInfo) &&
        Objects.equals(this.homePage, packageInfoNote.homePage) &&
        Objects.equals(this.licenseDeclared, packageInfoNote.licenseDeclared) &&
        Objects.equals(this.originator, packageInfoNote.originator) &&
        Objects.equals(this.packageType, packageInfoNote.packageType) &&
        Objects.equals(this.summaryDescription, packageInfoNote.summaryDescription) &&
        Objects.equals(this.supplier, packageInfoNote.supplier) &&
        Objects.equals(this.title, packageInfoNote.title) &&
        Objects.equals(this.verificationCode, packageInfoNote.verificationCode) &&
        Objects.equals(this.version, packageInfoNote.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(analyzed, attribution, checksum, copyright, detailedDescription, downloadLocation, externalRefs, filesLicenseInfo, homePage, licenseDeclared, originator, packageType, summaryDescription, supplier, title, verificationCode, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PackageInfoNote {\n");
    sb.append("    analyzed: ").append(toIndentedString(analyzed)).append("\n");
    sb.append("    attribution: ").append(toIndentedString(attribution)).append("\n");
    sb.append("    checksum: ").append(toIndentedString(checksum)).append("\n");
    sb.append("    copyright: ").append(toIndentedString(copyright)).append("\n");
    sb.append("    detailedDescription: ").append(toIndentedString(detailedDescription)).append("\n");
    sb.append("    downloadLocation: ").append(toIndentedString(downloadLocation)).append("\n");
    sb.append("    externalRefs: ").append(toIndentedString(externalRefs)).append("\n");
    sb.append("    filesLicenseInfo: ").append(toIndentedString(filesLicenseInfo)).append("\n");
    sb.append("    homePage: ").append(toIndentedString(homePage)).append("\n");
    sb.append("    licenseDeclared: ").append(toIndentedString(licenseDeclared)).append("\n");
    sb.append("    originator: ").append(toIndentedString(originator)).append("\n");
    sb.append("    packageType: ").append(toIndentedString(packageType)).append("\n");
    sb.append("    summaryDescription: ").append(toIndentedString(summaryDescription)).append("\n");
    sb.append("    supplier: ").append(toIndentedString(supplier)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    verificationCode: ").append(toIndentedString(verificationCode)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("analyzed");
    openapiFields.add("attribution");
    openapiFields.add("checksum");
    openapiFields.add("copyright");
    openapiFields.add("detailedDescription");
    openapiFields.add("downloadLocation");
    openapiFields.add("externalRefs");
    openapiFields.add("filesLicenseInfo");
    openapiFields.add("homePage");
    openapiFields.add("licenseDeclared");
    openapiFields.add("originator");
    openapiFields.add("packageType");
    openapiFields.add("summaryDescription");
    openapiFields.add("supplier");
    openapiFields.add("title");
    openapiFields.add("verificationCode");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PackageInfoNote
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PackageInfoNote.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PackageInfoNote is not found in the empty JSON string", PackageInfoNote.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PackageInfoNote.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PackageInfoNote` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("attribution") != null && !jsonObj.get("attribution").isJsonNull()) && !jsonObj.get("attribution").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `attribution` to be a primitive type in the JSON string but got `%s`", jsonObj.get("attribution").toString()));
      }
      if ((jsonObj.get("checksum") != null && !jsonObj.get("checksum").isJsonNull()) && !jsonObj.get("checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checksum").toString()));
      }
      if ((jsonObj.get("copyright") != null && !jsonObj.get("copyright").isJsonNull()) && !jsonObj.get("copyright").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `copyright` to be a primitive type in the JSON string but got `%s`", jsonObj.get("copyright").toString()));
      }
      if ((jsonObj.get("detailedDescription") != null && !jsonObj.get("detailedDescription").isJsonNull()) && !jsonObj.get("detailedDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `detailedDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("detailedDescription").toString()));
      }
      if ((jsonObj.get("downloadLocation") != null && !jsonObj.get("downloadLocation").isJsonNull()) && !jsonObj.get("downloadLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `downloadLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("downloadLocation").toString()));
      }
      if (jsonObj.get("externalRefs") != null && !jsonObj.get("externalRefs").isJsonNull()) {
        JsonArray jsonArrayexternalRefs = jsonObj.getAsJsonArray("externalRefs");
        if (jsonArrayexternalRefs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("externalRefs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `externalRefs` to be an array in the JSON string but got `%s`", jsonObj.get("externalRefs").toString()));
          }

          // validate the optional field `externalRefs` (array)
          for (int i = 0; i < jsonArrayexternalRefs.size(); i++) {
            ExternalRef.validateJsonElement(jsonArrayexternalRefs.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("filesLicenseInfo") != null && !jsonObj.get("filesLicenseInfo").isJsonNull() && !jsonObj.get("filesLicenseInfo").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `filesLicenseInfo` to be an array in the JSON string but got `%s`", jsonObj.get("filesLicenseInfo").toString()));
      }
      if ((jsonObj.get("homePage") != null && !jsonObj.get("homePage").isJsonNull()) && !jsonObj.get("homePage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `homePage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("homePage").toString()));
      }
      // validate the optional field `licenseDeclared`
      if (jsonObj.get("licenseDeclared") != null && !jsonObj.get("licenseDeclared").isJsonNull()) {
        License.validateJsonElement(jsonObj.get("licenseDeclared"));
      }
      if ((jsonObj.get("originator") != null && !jsonObj.get("originator").isJsonNull()) && !jsonObj.get("originator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originator").toString()));
      }
      if ((jsonObj.get("packageType") != null && !jsonObj.get("packageType").isJsonNull()) && !jsonObj.get("packageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `packageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("packageType").toString()));
      }
      if ((jsonObj.get("summaryDescription") != null && !jsonObj.get("summaryDescription").isJsonNull()) && !jsonObj.get("summaryDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summaryDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summaryDescription").toString()));
      }
      if ((jsonObj.get("supplier") != null && !jsonObj.get("supplier").isJsonNull()) && !jsonObj.get("supplier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `supplier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("supplier").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      if ((jsonObj.get("verificationCode") != null && !jsonObj.get("verificationCode").isJsonNull()) && !jsonObj.get("verificationCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `verificationCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("verificationCode").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PackageInfoNote.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PackageInfoNote' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PackageInfoNote> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PackageInfoNote.class));

       return (TypeAdapter<T>) new TypeAdapter<PackageInfoNote>() {
           @Override
           public void write(JsonWriter out, PackageInfoNote value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PackageInfoNote read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PackageInfoNote given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PackageInfoNote
   * @throws IOException if the JSON string is invalid with respect to PackageInfoNote
   */
  public static PackageInfoNote fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PackageInfoNote.class);
  }

  /**
   * Convert an instance of PackageInfoNote to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

