/**
 * Google Identity Toolkit API
 * Help the third party sites to implement federated login.
 *
 * The version of the OpenAPI document: v3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateAuthUriResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateAuthUriResponse::OAICreateAuthUriResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateAuthUriResponse::OAICreateAuthUriResponse() {
    this->initializeModel();
}

OAICreateAuthUriResponse::~OAICreateAuthUriResponse() {}

void OAICreateAuthUriResponse::initializeModel() {

    m_all_providers_isSet = false;
    m_all_providers_isValid = false;

    m_auth_uri_isSet = false;
    m_auth_uri_isValid = false;

    m_captcha_required_isSet = false;
    m_captcha_required_isValid = false;

    m_for_existing_provider_isSet = false;
    m_for_existing_provider_isValid = false;

    m_kind_isSet = false;
    m_kind_isValid = false;

    m_provider_id_isSet = false;
    m_provider_id_isValid = false;

    m_registered_isSet = false;
    m_registered_isValid = false;

    m_session_id_isSet = false;
    m_session_id_isValid = false;

    m_signin_methods_isSet = false;
    m_signin_methods_isValid = false;
}

void OAICreateAuthUriResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateAuthUriResponse::fromJsonObject(QJsonObject json) {

    m_all_providers_isValid = ::OpenAPI::fromJsonValue(m_all_providers, json[QString("allProviders")]);
    m_all_providers_isSet = !json[QString("allProviders")].isNull() && m_all_providers_isValid;

    m_auth_uri_isValid = ::OpenAPI::fromJsonValue(m_auth_uri, json[QString("authUri")]);
    m_auth_uri_isSet = !json[QString("authUri")].isNull() && m_auth_uri_isValid;

    m_captcha_required_isValid = ::OpenAPI::fromJsonValue(m_captcha_required, json[QString("captchaRequired")]);
    m_captcha_required_isSet = !json[QString("captchaRequired")].isNull() && m_captcha_required_isValid;

    m_for_existing_provider_isValid = ::OpenAPI::fromJsonValue(m_for_existing_provider, json[QString("forExistingProvider")]);
    m_for_existing_provider_isSet = !json[QString("forExistingProvider")].isNull() && m_for_existing_provider_isValid;

    m_kind_isValid = ::OpenAPI::fromJsonValue(m_kind, json[QString("kind")]);
    m_kind_isSet = !json[QString("kind")].isNull() && m_kind_isValid;

    m_provider_id_isValid = ::OpenAPI::fromJsonValue(m_provider_id, json[QString("providerId")]);
    m_provider_id_isSet = !json[QString("providerId")].isNull() && m_provider_id_isValid;

    m_registered_isValid = ::OpenAPI::fromJsonValue(m_registered, json[QString("registered")]);
    m_registered_isSet = !json[QString("registered")].isNull() && m_registered_isValid;

    m_session_id_isValid = ::OpenAPI::fromJsonValue(m_session_id, json[QString("sessionId")]);
    m_session_id_isSet = !json[QString("sessionId")].isNull() && m_session_id_isValid;

    m_signin_methods_isValid = ::OpenAPI::fromJsonValue(m_signin_methods, json[QString("signinMethods")]);
    m_signin_methods_isSet = !json[QString("signinMethods")].isNull() && m_signin_methods_isValid;
}

QString OAICreateAuthUriResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateAuthUriResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_all_providers.size() > 0) {
        obj.insert(QString("allProviders"), ::OpenAPI::toJsonValue(m_all_providers));
    }
    if (m_auth_uri_isSet) {
        obj.insert(QString("authUri"), ::OpenAPI::toJsonValue(m_auth_uri));
    }
    if (m_captcha_required_isSet) {
        obj.insert(QString("captchaRequired"), ::OpenAPI::toJsonValue(m_captcha_required));
    }
    if (m_for_existing_provider_isSet) {
        obj.insert(QString("forExistingProvider"), ::OpenAPI::toJsonValue(m_for_existing_provider));
    }
    if (m_kind_isSet) {
        obj.insert(QString("kind"), ::OpenAPI::toJsonValue(m_kind));
    }
    if (m_provider_id_isSet) {
        obj.insert(QString("providerId"), ::OpenAPI::toJsonValue(m_provider_id));
    }
    if (m_registered_isSet) {
        obj.insert(QString("registered"), ::OpenAPI::toJsonValue(m_registered));
    }
    if (m_session_id_isSet) {
        obj.insert(QString("sessionId"), ::OpenAPI::toJsonValue(m_session_id));
    }
    if (m_signin_methods.size() > 0) {
        obj.insert(QString("signinMethods"), ::OpenAPI::toJsonValue(m_signin_methods));
    }
    return obj;
}

QList<QString> OAICreateAuthUriResponse::getAllProviders() const {
    return m_all_providers;
}
void OAICreateAuthUriResponse::setAllProviders(const QList<QString> &all_providers) {
    m_all_providers = all_providers;
    m_all_providers_isSet = true;
}

bool OAICreateAuthUriResponse::is_all_providers_Set() const{
    return m_all_providers_isSet;
}

bool OAICreateAuthUriResponse::is_all_providers_Valid() const{
    return m_all_providers_isValid;
}

QString OAICreateAuthUriResponse::getAuthUri() const {
    return m_auth_uri;
}
void OAICreateAuthUriResponse::setAuthUri(const QString &auth_uri) {
    m_auth_uri = auth_uri;
    m_auth_uri_isSet = true;
}

bool OAICreateAuthUriResponse::is_auth_uri_Set() const{
    return m_auth_uri_isSet;
}

bool OAICreateAuthUriResponse::is_auth_uri_Valid() const{
    return m_auth_uri_isValid;
}

bool OAICreateAuthUriResponse::isCaptchaRequired() const {
    return m_captcha_required;
}
void OAICreateAuthUriResponse::setCaptchaRequired(const bool &captcha_required) {
    m_captcha_required = captcha_required;
    m_captcha_required_isSet = true;
}

bool OAICreateAuthUriResponse::is_captcha_required_Set() const{
    return m_captcha_required_isSet;
}

bool OAICreateAuthUriResponse::is_captcha_required_Valid() const{
    return m_captcha_required_isValid;
}

bool OAICreateAuthUriResponse::isForExistingProvider() const {
    return m_for_existing_provider;
}
void OAICreateAuthUriResponse::setForExistingProvider(const bool &for_existing_provider) {
    m_for_existing_provider = for_existing_provider;
    m_for_existing_provider_isSet = true;
}

bool OAICreateAuthUriResponse::is_for_existing_provider_Set() const{
    return m_for_existing_provider_isSet;
}

bool OAICreateAuthUriResponse::is_for_existing_provider_Valid() const{
    return m_for_existing_provider_isValid;
}

QString OAICreateAuthUriResponse::getKind() const {
    return m_kind;
}
void OAICreateAuthUriResponse::setKind(const QString &kind) {
    m_kind = kind;
    m_kind_isSet = true;
}

bool OAICreateAuthUriResponse::is_kind_Set() const{
    return m_kind_isSet;
}

bool OAICreateAuthUriResponse::is_kind_Valid() const{
    return m_kind_isValid;
}

QString OAICreateAuthUriResponse::getProviderId() const {
    return m_provider_id;
}
void OAICreateAuthUriResponse::setProviderId(const QString &provider_id) {
    m_provider_id = provider_id;
    m_provider_id_isSet = true;
}

bool OAICreateAuthUriResponse::is_provider_id_Set() const{
    return m_provider_id_isSet;
}

bool OAICreateAuthUriResponse::is_provider_id_Valid() const{
    return m_provider_id_isValid;
}

bool OAICreateAuthUriResponse::isRegistered() const {
    return m_registered;
}
void OAICreateAuthUriResponse::setRegistered(const bool &registered) {
    m_registered = registered;
    m_registered_isSet = true;
}

bool OAICreateAuthUriResponse::is_registered_Set() const{
    return m_registered_isSet;
}

bool OAICreateAuthUriResponse::is_registered_Valid() const{
    return m_registered_isValid;
}

QString OAICreateAuthUriResponse::getSessionId() const {
    return m_session_id;
}
void OAICreateAuthUriResponse::setSessionId(const QString &session_id) {
    m_session_id = session_id;
    m_session_id_isSet = true;
}

bool OAICreateAuthUriResponse::is_session_id_Set() const{
    return m_session_id_isSet;
}

bool OAICreateAuthUriResponse::is_session_id_Valid() const{
    return m_session_id_isValid;
}

QList<QString> OAICreateAuthUriResponse::getSigninMethods() const {
    return m_signin_methods;
}
void OAICreateAuthUriResponse::setSigninMethods(const QList<QString> &signin_methods) {
    m_signin_methods = signin_methods;
    m_signin_methods_isSet = true;
}

bool OAICreateAuthUriResponse::is_signin_methods_Set() const{
    return m_signin_methods_isSet;
}

bool OAICreateAuthUriResponse::is_signin_methods_Valid() const{
    return m_signin_methods_isValid;
}

bool OAICreateAuthUriResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_all_providers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_auth_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_captcha_required_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_for_existing_provider_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_registered_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_session_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_signin_methods.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateAuthUriResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
