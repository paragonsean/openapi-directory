/*
 * Google Drive API
 * The Google Drive API allows clients to access resources from Google Drive.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ContentRestriction;
import org.openapitools.client.model.FileCapabilities;
import org.openapitools.client.model.FileContentHints;
import org.openapitools.client.model.FileImageMediaMetadata;
import org.openapitools.client.model.FileLabelInfo;
import org.openapitools.client.model.FileLinkShareMetadata;
import org.openapitools.client.model.FileShortcutDetails;
import org.openapitools.client.model.FileVideoMediaMetadata;
import org.openapitools.client.model.Permission;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The metadata for a file. Some resource methods (such as &#x60;files.update&#x60;) require a &#x60;fileId&#x60;. Use the &#x60;files.list&#x60; method to retrieve the ID for a file.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:32.870459-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ModelFile {
  public static final String SERIALIZED_NAME_APP_PROPERTIES = "appProperties";
  @SerializedName(SERIALIZED_NAME_APP_PROPERTIES)
  private Map<String, String> appProperties = new HashMap<>();

  public static final String SERIALIZED_NAME_CAPABILITIES = "capabilities";
  @SerializedName(SERIALIZED_NAME_CAPABILITIES)
  private FileCapabilities capabilities;

  public static final String SERIALIZED_NAME_CONTENT_HINTS = "contentHints";
  @SerializedName(SERIALIZED_NAME_CONTENT_HINTS)
  private FileContentHints contentHints;

  public static final String SERIALIZED_NAME_CONTENT_RESTRICTIONS = "contentRestrictions";
  @SerializedName(SERIALIZED_NAME_CONTENT_RESTRICTIONS)
  private List<ContentRestriction> contentRestrictions = new ArrayList<>();

  public static final String SERIALIZED_NAME_COPY_REQUIRES_WRITER_PERMISSION = "copyRequiresWriterPermission";
  @SerializedName(SERIALIZED_NAME_COPY_REQUIRES_WRITER_PERMISSION)
  private Boolean copyRequiresWriterPermission;

  public static final String SERIALIZED_NAME_CREATED_TIME = "createdTime";
  @SerializedName(SERIALIZED_NAME_CREATED_TIME)
  private OffsetDateTime createdTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DRIVE_ID = "driveId";
  @SerializedName(SERIALIZED_NAME_DRIVE_ID)
  private String driveId;

  public static final String SERIALIZED_NAME_EXPLICITLY_TRASHED = "explicitlyTrashed";
  @SerializedName(SERIALIZED_NAME_EXPLICITLY_TRASHED)
  private Boolean explicitlyTrashed;

  public static final String SERIALIZED_NAME_EXPORT_LINKS = "exportLinks";
  @SerializedName(SERIALIZED_NAME_EXPORT_LINKS)
  private Map<String, String> exportLinks = new HashMap<>();

  public static final String SERIALIZED_NAME_FILE_EXTENSION = "fileExtension";
  @SerializedName(SERIALIZED_NAME_FILE_EXTENSION)
  private String fileExtension;

  public static final String SERIALIZED_NAME_FOLDER_COLOR_RGB = "folderColorRgb";
  @SerializedName(SERIALIZED_NAME_FOLDER_COLOR_RGB)
  private String folderColorRgb;

  public static final String SERIALIZED_NAME_FULL_FILE_EXTENSION = "fullFileExtension";
  @SerializedName(SERIALIZED_NAME_FULL_FILE_EXTENSION)
  private String fullFileExtension;

  public static final String SERIALIZED_NAME_HAS_AUGMENTED_PERMISSIONS = "hasAugmentedPermissions";
  @SerializedName(SERIALIZED_NAME_HAS_AUGMENTED_PERMISSIONS)
  private Boolean hasAugmentedPermissions;

  public static final String SERIALIZED_NAME_HAS_THUMBNAIL = "hasThumbnail";
  @SerializedName(SERIALIZED_NAME_HAS_THUMBNAIL)
  private Boolean hasThumbnail;

  public static final String SERIALIZED_NAME_HEAD_REVISION_ID = "headRevisionId";
  @SerializedName(SERIALIZED_NAME_HEAD_REVISION_ID)
  private String headRevisionId;

  public static final String SERIALIZED_NAME_ICON_LINK = "iconLink";
  @SerializedName(SERIALIZED_NAME_ICON_LINK)
  private String iconLink;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMAGE_MEDIA_METADATA = "imageMediaMetadata";
  @SerializedName(SERIALIZED_NAME_IMAGE_MEDIA_METADATA)
  private FileImageMediaMetadata imageMediaMetadata;

  public static final String SERIALIZED_NAME_IS_APP_AUTHORIZED = "isAppAuthorized";
  @SerializedName(SERIALIZED_NAME_IS_APP_AUTHORIZED)
  private Boolean isAppAuthorized;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "drive#file";

  public static final String SERIALIZED_NAME_LABEL_INFO = "labelInfo";
  @SerializedName(SERIALIZED_NAME_LABEL_INFO)
  private FileLabelInfo labelInfo;

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER = "lastModifyingUser";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER)
  private User lastModifyingUser;

  public static final String SERIALIZED_NAME_LINK_SHARE_METADATA = "linkShareMetadata";
  @SerializedName(SERIALIZED_NAME_LINK_SHARE_METADATA)
  private FileLinkShareMetadata linkShareMetadata;

  public static final String SERIALIZED_NAME_MD5_CHECKSUM = "md5Checksum";
  @SerializedName(SERIALIZED_NAME_MD5_CHECKSUM)
  private String md5Checksum;

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_MODIFIED_BY_ME = "modifiedByMe";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY_ME)
  private Boolean modifiedByMe;

  public static final String SERIALIZED_NAME_MODIFIED_BY_ME_TIME = "modifiedByMeTime";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY_ME_TIME)
  private OffsetDateTime modifiedByMeTime;

  public static final String SERIALIZED_NAME_MODIFIED_TIME = "modifiedTime";
  @SerializedName(SERIALIZED_NAME_MODIFIED_TIME)
  private OffsetDateTime modifiedTime;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_ORIGINAL_FILENAME = "originalFilename";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_FILENAME)
  private String originalFilename;

  public static final String SERIALIZED_NAME_OWNED_BY_ME = "ownedByMe";
  @SerializedName(SERIALIZED_NAME_OWNED_BY_ME)
  private Boolean ownedByMe;

  public static final String SERIALIZED_NAME_OWNERS = "owners";
  @SerializedName(SERIALIZED_NAME_OWNERS)
  private List<User> owners = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARENTS = "parents";
  @SerializedName(SERIALIZED_NAME_PARENTS)
  private List<String> parents = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMISSION_IDS = "permissionIds";
  @SerializedName(SERIALIZED_NAME_PERMISSION_IDS)
  private List<String> permissionIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMISSIONS = "permissions";
  @SerializedName(SERIALIZED_NAME_PERMISSIONS)
  private List<Permission> permissions = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private Map<String, String> properties = new HashMap<>();

  public static final String SERIALIZED_NAME_QUOTA_BYTES_USED = "quotaBytesUsed";
  @SerializedName(SERIALIZED_NAME_QUOTA_BYTES_USED)
  private String quotaBytesUsed;

  public static final String SERIALIZED_NAME_RESOURCE_KEY = "resourceKey";
  @SerializedName(SERIALIZED_NAME_RESOURCE_KEY)
  private String resourceKey;

  public static final String SERIALIZED_NAME_SHA1_CHECKSUM = "sha1Checksum";
  @SerializedName(SERIALIZED_NAME_SHA1_CHECKSUM)
  private String sha1Checksum;

  public static final String SERIALIZED_NAME_SHA256_CHECKSUM = "sha256Checksum";
  @SerializedName(SERIALIZED_NAME_SHA256_CHECKSUM)
  private String sha256Checksum;

  public static final String SERIALIZED_NAME_SHARED = "shared";
  @SerializedName(SERIALIZED_NAME_SHARED)
  private Boolean shared;

  public static final String SERIALIZED_NAME_SHARED_WITH_ME_TIME = "sharedWithMeTime";
  @SerializedName(SERIALIZED_NAME_SHARED_WITH_ME_TIME)
  private OffsetDateTime sharedWithMeTime;

  public static final String SERIALIZED_NAME_SHARING_USER = "sharingUser";
  @SerializedName(SERIALIZED_NAME_SHARING_USER)
  private User sharingUser;

  public static final String SERIALIZED_NAME_SHORTCUT_DETAILS = "shortcutDetails";
  @SerializedName(SERIALIZED_NAME_SHORTCUT_DETAILS)
  private FileShortcutDetails shortcutDetails;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private String size;

  public static final String SERIALIZED_NAME_SPACES = "spaces";
  @SerializedName(SERIALIZED_NAME_SPACES)
  private List<String> spaces = new ArrayList<>();

  public static final String SERIALIZED_NAME_STARRED = "starred";
  @SerializedName(SERIALIZED_NAME_STARRED)
  private Boolean starred;

  public static final String SERIALIZED_NAME_TEAM_DRIVE_ID = "teamDriveId";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_TEAM_DRIVE_ID)
  private String teamDriveId;

  public static final String SERIALIZED_NAME_THUMBNAIL_LINK = "thumbnailLink";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL_LINK)
  private String thumbnailLink;

  public static final String SERIALIZED_NAME_THUMBNAIL_VERSION = "thumbnailVersion";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL_VERSION)
  private String thumbnailVersion;

  public static final String SERIALIZED_NAME_TRASHED = "trashed";
  @SerializedName(SERIALIZED_NAME_TRASHED)
  private Boolean trashed;

  public static final String SERIALIZED_NAME_TRASHED_TIME = "trashedTime";
  @SerializedName(SERIALIZED_NAME_TRASHED_TIME)
  private OffsetDateTime trashedTime;

  public static final String SERIALIZED_NAME_TRASHING_USER = "trashingUser";
  @SerializedName(SERIALIZED_NAME_TRASHING_USER)
  private User trashingUser;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_VIDEO_MEDIA_METADATA = "videoMediaMetadata";
  @SerializedName(SERIALIZED_NAME_VIDEO_MEDIA_METADATA)
  private FileVideoMediaMetadata videoMediaMetadata;

  public static final String SERIALIZED_NAME_VIEWED_BY_ME = "viewedByMe";
  @SerializedName(SERIALIZED_NAME_VIEWED_BY_ME)
  private Boolean viewedByMe;

  public static final String SERIALIZED_NAME_VIEWED_BY_ME_TIME = "viewedByMeTime";
  @SerializedName(SERIALIZED_NAME_VIEWED_BY_ME_TIME)
  private OffsetDateTime viewedByMeTime;

  public static final String SERIALIZED_NAME_VIEWERS_CAN_COPY_CONTENT = "viewersCanCopyContent";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_VIEWERS_CAN_COPY_CONTENT)
  private Boolean viewersCanCopyContent;

  public static final String SERIALIZED_NAME_WEB_CONTENT_LINK = "webContentLink";
  @SerializedName(SERIALIZED_NAME_WEB_CONTENT_LINK)
  private String webContentLink;

  public static final String SERIALIZED_NAME_WEB_VIEW_LINK = "webViewLink";
  @SerializedName(SERIALIZED_NAME_WEB_VIEW_LINK)
  private String webViewLink;

  public static final String SERIALIZED_NAME_WRITERS_CAN_SHARE = "writersCanShare";
  @SerializedName(SERIALIZED_NAME_WRITERS_CAN_SHARE)
  private Boolean writersCanShare;

  public ModelFile() {
  }

  public ModelFile(
     Map<String, String> exportLinks
  ) {
    this();
    this.exportLinks = exportLinks;
  }

  public ModelFile appProperties(Map<String, String> appProperties) {
    this.appProperties = appProperties;
    return this;
  }

  public ModelFile putAppPropertiesItem(String key, String appPropertiesItem) {
    if (this.appProperties == null) {
      this.appProperties = new HashMap<>();
    }
    this.appProperties.put(key, appPropertiesItem);
    return this;
  }

  /**
   * A collection of arbitrary key-value pairs which are private to the requesting app. Entries with null values are cleared in update and copy requests. These properties can only be retrieved using an authenticated request. An authenticated request uses an access token obtained with a OAuth 2 client ID. You cannot use an API key to retrieve private properties.
   * @return appProperties
   */
  @javax.annotation.Nullable
  public Map<String, String> getAppProperties() {
    return appProperties;
  }

  public void setAppProperties(Map<String, String> appProperties) {
    this.appProperties = appProperties;
  }


  public ModelFile capabilities(FileCapabilities capabilities) {
    this.capabilities = capabilities;
    return this;
  }

  /**
   * Get capabilities
   * @return capabilities
   */
  @javax.annotation.Nullable
  public FileCapabilities getCapabilities() {
    return capabilities;
  }

  public void setCapabilities(FileCapabilities capabilities) {
    this.capabilities = capabilities;
  }


  public ModelFile contentHints(FileContentHints contentHints) {
    this.contentHints = contentHints;
    return this;
  }

  /**
   * Get contentHints
   * @return contentHints
   */
  @javax.annotation.Nullable
  public FileContentHints getContentHints() {
    return contentHints;
  }

  public void setContentHints(FileContentHints contentHints) {
    this.contentHints = contentHints;
  }


  public ModelFile contentRestrictions(List<ContentRestriction> contentRestrictions) {
    this.contentRestrictions = contentRestrictions;
    return this;
  }

  public ModelFile addContentRestrictionsItem(ContentRestriction contentRestrictionsItem) {
    if (this.contentRestrictions == null) {
      this.contentRestrictions = new ArrayList<>();
    }
    this.contentRestrictions.add(contentRestrictionsItem);
    return this;
  }

  /**
   * Restrictions for accessing the content of the file. Only populated if such a restriction exists.
   * @return contentRestrictions
   */
  @javax.annotation.Nullable
  public List<ContentRestriction> getContentRestrictions() {
    return contentRestrictions;
  }

  public void setContentRestrictions(List<ContentRestriction> contentRestrictions) {
    this.contentRestrictions = contentRestrictions;
  }


  public ModelFile copyRequiresWriterPermission(Boolean copyRequiresWriterPermission) {
    this.copyRequiresWriterPermission = copyRequiresWriterPermission;
    return this;
  }

  /**
   * Whether the options to copy, print, or download this file, should be disabled for readers and commenters.
   * @return copyRequiresWriterPermission
   */
  @javax.annotation.Nullable
  public Boolean getCopyRequiresWriterPermission() {
    return copyRequiresWriterPermission;
  }

  public void setCopyRequiresWriterPermission(Boolean copyRequiresWriterPermission) {
    this.copyRequiresWriterPermission = copyRequiresWriterPermission;
  }


  public ModelFile createdTime(OffsetDateTime createdTime) {
    this.createdTime = createdTime;
    return this;
  }

  /**
   * The time at which the file was created (RFC 3339 date-time).
   * @return createdTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedTime() {
    return createdTime;
  }

  public void setCreatedTime(OffsetDateTime createdTime) {
    this.createdTime = createdTime;
  }


  public ModelFile description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A short description of the file.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ModelFile driveId(String driveId) {
    this.driveId = driveId;
    return this;
  }

  /**
   * Output only. ID of the shared drive the file resides in. Only populated for items in shared drives.
   * @return driveId
   */
  @javax.annotation.Nullable
  public String getDriveId() {
    return driveId;
  }

  public void setDriveId(String driveId) {
    this.driveId = driveId;
  }


  public ModelFile explicitlyTrashed(Boolean explicitlyTrashed) {
    this.explicitlyTrashed = explicitlyTrashed;
    return this;
  }

  /**
   * Output only. Whether the file has been explicitly trashed, as opposed to recursively trashed from a parent folder.
   * @return explicitlyTrashed
   */
  @javax.annotation.Nullable
  public Boolean getExplicitlyTrashed() {
    return explicitlyTrashed;
  }

  public void setExplicitlyTrashed(Boolean explicitlyTrashed) {
    this.explicitlyTrashed = explicitlyTrashed;
  }


  /**
   * Output only. Links for exporting Docs Editors files to specific formats.
   * @return exportLinks
   */
  @javax.annotation.Nullable
  public Map<String, String> getExportLinks() {
    return exportLinks;
  }



  public ModelFile fileExtension(String fileExtension) {
    this.fileExtension = fileExtension;
    return this;
  }

  /**
   * Output only. The final component of &#x60;fullFileExtension&#x60;. This is only available for files with binary content in Google Drive.
   * @return fileExtension
   */
  @javax.annotation.Nullable
  public String getFileExtension() {
    return fileExtension;
  }

  public void setFileExtension(String fileExtension) {
    this.fileExtension = fileExtension;
  }


  public ModelFile folderColorRgb(String folderColorRgb) {
    this.folderColorRgb = folderColorRgb;
    return this;
  }

  /**
   * The color for a folder or a shortcut to a folder as an RGB hex string. The supported colors are published in the &#x60;folderColorPalette&#x60; field of the About resource. If an unsupported color is specified, the closest color in the palette is used instead.
   * @return folderColorRgb
   */
  @javax.annotation.Nullable
  public String getFolderColorRgb() {
    return folderColorRgb;
  }

  public void setFolderColorRgb(String folderColorRgb) {
    this.folderColorRgb = folderColorRgb;
  }


  public ModelFile fullFileExtension(String fullFileExtension) {
    this.fullFileExtension = fullFileExtension;
    return this;
  }

  /**
   * Output only. The full file extension extracted from the &#x60;name&#x60; field. May contain multiple concatenated extensions, such as \&quot;tar.gz\&quot;. This is only available for files with binary content in Google Drive. This is automatically updated when the &#x60;name&#x60; field changes, however it is not cleared if the new name does not contain a valid extension.
   * @return fullFileExtension
   */
  @javax.annotation.Nullable
  public String getFullFileExtension() {
    return fullFileExtension;
  }

  public void setFullFileExtension(String fullFileExtension) {
    this.fullFileExtension = fullFileExtension;
  }


  public ModelFile hasAugmentedPermissions(Boolean hasAugmentedPermissions) {
    this.hasAugmentedPermissions = hasAugmentedPermissions;
    return this;
  }

  /**
   * Output only. Whether there are permissions directly on this file. This field is only populated for items in shared drives.
   * @return hasAugmentedPermissions
   */
  @javax.annotation.Nullable
  public Boolean getHasAugmentedPermissions() {
    return hasAugmentedPermissions;
  }

  public void setHasAugmentedPermissions(Boolean hasAugmentedPermissions) {
    this.hasAugmentedPermissions = hasAugmentedPermissions;
  }


  public ModelFile hasThumbnail(Boolean hasThumbnail) {
    this.hasThumbnail = hasThumbnail;
    return this;
  }

  /**
   * Output only. Whether this file has a thumbnail. This does not indicate whether the requesting app has access to the thumbnail. To check access, look for the presence of the thumbnailLink field.
   * @return hasThumbnail
   */
  @javax.annotation.Nullable
  public Boolean getHasThumbnail() {
    return hasThumbnail;
  }

  public void setHasThumbnail(Boolean hasThumbnail) {
    this.hasThumbnail = hasThumbnail;
  }


  public ModelFile headRevisionId(String headRevisionId) {
    this.headRevisionId = headRevisionId;
    return this;
  }

  /**
   * Output only. The ID of the file&#39;s head revision. This is currently only available for files with binary content in Google Drive.
   * @return headRevisionId
   */
  @javax.annotation.Nullable
  public String getHeadRevisionId() {
    return headRevisionId;
  }

  public void setHeadRevisionId(String headRevisionId) {
    this.headRevisionId = headRevisionId;
  }


  public ModelFile iconLink(String iconLink) {
    this.iconLink = iconLink;
    return this;
  }

  /**
   * Output only. A static, unauthenticated link to the file&#39;s icon.
   * @return iconLink
   */
  @javax.annotation.Nullable
  public String getIconLink() {
    return iconLink;
  }

  public void setIconLink(String iconLink) {
    this.iconLink = iconLink;
  }


  public ModelFile id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of the file.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ModelFile imageMediaMetadata(FileImageMediaMetadata imageMediaMetadata) {
    this.imageMediaMetadata = imageMediaMetadata;
    return this;
  }

  /**
   * Get imageMediaMetadata
   * @return imageMediaMetadata
   */
  @javax.annotation.Nullable
  public FileImageMediaMetadata getImageMediaMetadata() {
    return imageMediaMetadata;
  }

  public void setImageMediaMetadata(FileImageMediaMetadata imageMediaMetadata) {
    this.imageMediaMetadata = imageMediaMetadata;
  }


  public ModelFile isAppAuthorized(Boolean isAppAuthorized) {
    this.isAppAuthorized = isAppAuthorized;
    return this;
  }

  /**
   * Output only. Whether the file was created or opened by the requesting app.
   * @return isAppAuthorized
   */
  @javax.annotation.Nullable
  public Boolean getIsAppAuthorized() {
    return isAppAuthorized;
  }

  public void setIsAppAuthorized(Boolean isAppAuthorized) {
    this.isAppAuthorized = isAppAuthorized;
  }


  public ModelFile kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Output only. Identifies what kind of resource this is. Value: the fixed string &#x60;\&quot;drive#file\&quot;&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public ModelFile labelInfo(FileLabelInfo labelInfo) {
    this.labelInfo = labelInfo;
    return this;
  }

  /**
   * Get labelInfo
   * @return labelInfo
   */
  @javax.annotation.Nullable
  public FileLabelInfo getLabelInfo() {
    return labelInfo;
  }

  public void setLabelInfo(FileLabelInfo labelInfo) {
    this.labelInfo = labelInfo;
  }


  public ModelFile lastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
    return this;
  }

  /**
   * Get lastModifyingUser
   * @return lastModifyingUser
   */
  @javax.annotation.Nullable
  public User getLastModifyingUser() {
    return lastModifyingUser;
  }

  public void setLastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
  }


  public ModelFile linkShareMetadata(FileLinkShareMetadata linkShareMetadata) {
    this.linkShareMetadata = linkShareMetadata;
    return this;
  }

  /**
   * Get linkShareMetadata
   * @return linkShareMetadata
   */
  @javax.annotation.Nullable
  public FileLinkShareMetadata getLinkShareMetadata() {
    return linkShareMetadata;
  }

  public void setLinkShareMetadata(FileLinkShareMetadata linkShareMetadata) {
    this.linkShareMetadata = linkShareMetadata;
  }


  public ModelFile md5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
    return this;
  }

  /**
   * Output only. The MD5 checksum for the content of the file. This is only applicable to files with binary content in Google Drive.
   * @return md5Checksum
   */
  @javax.annotation.Nullable
  public String getMd5Checksum() {
    return md5Checksum;
  }

  public void setMd5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
  }


  public ModelFile mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * The MIME type of the file. Google Drive attempts to automatically detect an appropriate value from uploaded content, if no value is provided. The value cannot be changed unless a new revision is uploaded. If a file is created with a Google Doc MIME type, the uploaded content is imported, if possible. The supported import formats are published in the About resource.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public ModelFile modifiedByMe(Boolean modifiedByMe) {
    this.modifiedByMe = modifiedByMe;
    return this;
  }

  /**
   * Output only. Whether the file has been modified by this user.
   * @return modifiedByMe
   */
  @javax.annotation.Nullable
  public Boolean getModifiedByMe() {
    return modifiedByMe;
  }

  public void setModifiedByMe(Boolean modifiedByMe) {
    this.modifiedByMe = modifiedByMe;
  }


  public ModelFile modifiedByMeTime(OffsetDateTime modifiedByMeTime) {
    this.modifiedByMeTime = modifiedByMeTime;
    return this;
  }

  /**
   * The last time the file was modified by the user (RFC 3339 date-time).
   * @return modifiedByMeTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedByMeTime() {
    return modifiedByMeTime;
  }

  public void setModifiedByMeTime(OffsetDateTime modifiedByMeTime) {
    this.modifiedByMeTime = modifiedByMeTime;
  }


  public ModelFile modifiedTime(OffsetDateTime modifiedTime) {
    this.modifiedTime = modifiedTime;
    return this;
  }

  /**
   * he last time the file was modified by anyone (RFC 3339 date-time). Note that setting modifiedTime will also update modifiedByMeTime for the user.
   * @return modifiedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedTime() {
    return modifiedTime;
  }

  public void setModifiedTime(OffsetDateTime modifiedTime) {
    this.modifiedTime = modifiedTime;
  }


  public ModelFile name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the file. This is not necessarily unique within a folder. Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ModelFile originalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
    return this;
  }

  /**
   * The original filename of the uploaded content if available, or else the original value of the &#x60;name&#x60; field. This is only available for files with binary content in Google Drive.
   * @return originalFilename
   */
  @javax.annotation.Nullable
  public String getOriginalFilename() {
    return originalFilename;
  }

  public void setOriginalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
  }


  public ModelFile ownedByMe(Boolean ownedByMe) {
    this.ownedByMe = ownedByMe;
    return this;
  }

  /**
   * Output only. Whether the user owns the file. Not populated for items in shared drives.
   * @return ownedByMe
   */
  @javax.annotation.Nullable
  public Boolean getOwnedByMe() {
    return ownedByMe;
  }

  public void setOwnedByMe(Boolean ownedByMe) {
    this.ownedByMe = ownedByMe;
  }


  public ModelFile owners(List<User> owners) {
    this.owners = owners;
    return this;
  }

  public ModelFile addOwnersItem(User ownersItem) {
    if (this.owners == null) {
      this.owners = new ArrayList<>();
    }
    this.owners.add(ownersItem);
    return this;
  }

  /**
   * Output only. The owner of this file. Only certain legacy files may have more than one owner. This field isn&#39;t populated for items in shared drives.
   * @return owners
   */
  @javax.annotation.Nullable
  public List<User> getOwners() {
    return owners;
  }

  public void setOwners(List<User> owners) {
    this.owners = owners;
  }


  public ModelFile parents(List<String> parents) {
    this.parents = parents;
    return this;
  }

  public ModelFile addParentsItem(String parentsItem) {
    if (this.parents == null) {
      this.parents = new ArrayList<>();
    }
    this.parents.add(parentsItem);
    return this;
  }

  /**
   * The IDs of the parent folders which contain the file. If not specified as part of a create request, the file is placed directly in the user&#39;s My Drive folder. If not specified as part of a copy request, the file inherits any discoverable parents of the source file. Update requests must use the &#x60;addParents&#x60; and &#x60;removeParents&#x60; parameters to modify the parents list.
   * @return parents
   */
  @javax.annotation.Nullable
  public List<String> getParents() {
    return parents;
  }

  public void setParents(List<String> parents) {
    this.parents = parents;
  }


  public ModelFile permissionIds(List<String> permissionIds) {
    this.permissionIds = permissionIds;
    return this;
  }

  public ModelFile addPermissionIdsItem(String permissionIdsItem) {
    if (this.permissionIds == null) {
      this.permissionIds = new ArrayList<>();
    }
    this.permissionIds.add(permissionIdsItem);
    return this;
  }

  /**
   * Output only. List of permission IDs for users with access to this file.
   * @return permissionIds
   */
  @javax.annotation.Nullable
  public List<String> getPermissionIds() {
    return permissionIds;
  }

  public void setPermissionIds(List<String> permissionIds) {
    this.permissionIds = permissionIds;
  }


  public ModelFile permissions(List<Permission> permissions) {
    this.permissions = permissions;
    return this;
  }

  public ModelFile addPermissionsItem(Permission permissionsItem) {
    if (this.permissions == null) {
      this.permissions = new ArrayList<>();
    }
    this.permissions.add(permissionsItem);
    return this;
  }

  /**
   * Output only. The full list of permissions for the file. This is only available if the requesting user can share the file. Not populated for items in shared drives.
   * @return permissions
   */
  @javax.annotation.Nullable
  public List<Permission> getPermissions() {
    return permissions;
  }

  public void setPermissions(List<Permission> permissions) {
    this.permissions = permissions;
  }


  public ModelFile properties(Map<String, String> properties) {
    this.properties = properties;
    return this;
  }

  public ModelFile putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

  /**
   * A collection of arbitrary key-value pairs which are visible to all apps. Entries with null values are cleared in update and copy requests.
   * @return properties
   */
  @javax.annotation.Nullable
  public Map<String, String> getProperties() {
    return properties;
  }

  public void setProperties(Map<String, String> properties) {
    this.properties = properties;
  }


  public ModelFile quotaBytesUsed(String quotaBytesUsed) {
    this.quotaBytesUsed = quotaBytesUsed;
    return this;
  }

  /**
   * Output only. The number of storage quota bytes used by the file. This includes the head revision as well as previous revisions with &#x60;keepForever&#x60; enabled.
   * @return quotaBytesUsed
   */
  @javax.annotation.Nullable
  public String getQuotaBytesUsed() {
    return quotaBytesUsed;
  }

  public void setQuotaBytesUsed(String quotaBytesUsed) {
    this.quotaBytesUsed = quotaBytesUsed;
  }


  public ModelFile resourceKey(String resourceKey) {
    this.resourceKey = resourceKey;
    return this;
  }

  /**
   * Output only. A key needed to access the item via a shared link.
   * @return resourceKey
   */
  @javax.annotation.Nullable
  public String getResourceKey() {
    return resourceKey;
  }

  public void setResourceKey(String resourceKey) {
    this.resourceKey = resourceKey;
  }


  public ModelFile sha1Checksum(String sha1Checksum) {
    this.sha1Checksum = sha1Checksum;
    return this;
  }

  /**
   * Output only. The SHA1 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return sha1Checksum
   */
  @javax.annotation.Nullable
  public String getSha1Checksum() {
    return sha1Checksum;
  }

  public void setSha1Checksum(String sha1Checksum) {
    this.sha1Checksum = sha1Checksum;
  }


  public ModelFile sha256Checksum(String sha256Checksum) {
    this.sha256Checksum = sha256Checksum;
    return this;
  }

  /**
   * Output only. The SHA256 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return sha256Checksum
   */
  @javax.annotation.Nullable
  public String getSha256Checksum() {
    return sha256Checksum;
  }

  public void setSha256Checksum(String sha256Checksum) {
    this.sha256Checksum = sha256Checksum;
  }


  public ModelFile shared(Boolean shared) {
    this.shared = shared;
    return this;
  }

  /**
   * Output only. Whether the file has been shared. Not populated for items in shared drives.
   * @return shared
   */
  @javax.annotation.Nullable
  public Boolean getShared() {
    return shared;
  }

  public void setShared(Boolean shared) {
    this.shared = shared;
  }


  public ModelFile sharedWithMeTime(OffsetDateTime sharedWithMeTime) {
    this.sharedWithMeTime = sharedWithMeTime;
    return this;
  }

  /**
   * The time at which the file was shared with the user, if applicable (RFC 3339 date-time).
   * @return sharedWithMeTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSharedWithMeTime() {
    return sharedWithMeTime;
  }

  public void setSharedWithMeTime(OffsetDateTime sharedWithMeTime) {
    this.sharedWithMeTime = sharedWithMeTime;
  }


  public ModelFile sharingUser(User sharingUser) {
    this.sharingUser = sharingUser;
    return this;
  }

  /**
   * Get sharingUser
   * @return sharingUser
   */
  @javax.annotation.Nullable
  public User getSharingUser() {
    return sharingUser;
  }

  public void setSharingUser(User sharingUser) {
    this.sharingUser = sharingUser;
  }


  public ModelFile shortcutDetails(FileShortcutDetails shortcutDetails) {
    this.shortcutDetails = shortcutDetails;
    return this;
  }

  /**
   * Get shortcutDetails
   * @return shortcutDetails
   */
  @javax.annotation.Nullable
  public FileShortcutDetails getShortcutDetails() {
    return shortcutDetails;
  }

  public void setShortcutDetails(FileShortcutDetails shortcutDetails) {
    this.shortcutDetails = shortcutDetails;
  }


  public ModelFile size(String size) {
    this.size = size;
    return this;
  }

  /**
   * Output only. Size in bytes of blobs and first party editor files. Won&#39;t be populated for files that have no size, like shortcuts and folders.
   * @return size
   */
  @javax.annotation.Nullable
  public String getSize() {
    return size;
  }

  public void setSize(String size) {
    this.size = size;
  }


  public ModelFile spaces(List<String> spaces) {
    this.spaces = spaces;
    return this;
  }

  public ModelFile addSpacesItem(String spacesItem) {
    if (this.spaces == null) {
      this.spaces = new ArrayList<>();
    }
    this.spaces.add(spacesItem);
    return this;
  }

  /**
   * Output only. The list of spaces which contain the file. The currently supported values are &#39;drive&#39;, &#39;appDataFolder&#39; and &#39;photos&#39;.
   * @return spaces
   */
  @javax.annotation.Nullable
  public List<String> getSpaces() {
    return spaces;
  }

  public void setSpaces(List<String> spaces) {
    this.spaces = spaces;
  }


  public ModelFile starred(Boolean starred) {
    this.starred = starred;
    return this;
  }

  /**
   * Whether the user has starred the file.
   * @return starred
   */
  @javax.annotation.Nullable
  public Boolean getStarred() {
    return starred;
  }

  public void setStarred(Boolean starred) {
    this.starred = starred;
  }


  @Deprecated
  public ModelFile teamDriveId(String teamDriveId) {
    this.teamDriveId = teamDriveId;
    return this;
  }

  /**
   * Deprecated: Output only. Use &#x60;driveId&#x60; instead.
   * @return teamDriveId
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getTeamDriveId() {
    return teamDriveId;
  }

  @Deprecated
  public void setTeamDriveId(String teamDriveId) {
    this.teamDriveId = teamDriveId;
  }


  public ModelFile thumbnailLink(String thumbnailLink) {
    this.thumbnailLink = thumbnailLink;
    return this;
  }

  /**
   * Output only. A short-lived link to the file&#39;s thumbnail, if available. Typically lasts on the order of hours. Only populated when the requesting app can access the file&#39;s content. If the file isn&#39;t shared publicly, the URL returned in &#x60;Files.thumbnailLink&#x60; must be fetched using a credentialed request.
   * @return thumbnailLink
   */
  @javax.annotation.Nullable
  public String getThumbnailLink() {
    return thumbnailLink;
  }

  public void setThumbnailLink(String thumbnailLink) {
    this.thumbnailLink = thumbnailLink;
  }


  public ModelFile thumbnailVersion(String thumbnailVersion) {
    this.thumbnailVersion = thumbnailVersion;
    return this;
  }

  /**
   * Output only. The thumbnail version for use in thumbnail cache invalidation.
   * @return thumbnailVersion
   */
  @javax.annotation.Nullable
  public String getThumbnailVersion() {
    return thumbnailVersion;
  }

  public void setThumbnailVersion(String thumbnailVersion) {
    this.thumbnailVersion = thumbnailVersion;
  }


  public ModelFile trashed(Boolean trashed) {
    this.trashed = trashed;
    return this;
  }

  /**
   * Whether the file has been trashed, either explicitly or from a trashed parent folder. Only the owner may trash a file, and other users cannot see files in the owner&#39;s trash.
   * @return trashed
   */
  @javax.annotation.Nullable
  public Boolean getTrashed() {
    return trashed;
  }

  public void setTrashed(Boolean trashed) {
    this.trashed = trashed;
  }


  public ModelFile trashedTime(OffsetDateTime trashedTime) {
    this.trashedTime = trashedTime;
    return this;
  }

  /**
   * The time that the item was trashed (RFC 3339 date-time). Only populated for items in shared drives.
   * @return trashedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTrashedTime() {
    return trashedTime;
  }

  public void setTrashedTime(OffsetDateTime trashedTime) {
    this.trashedTime = trashedTime;
  }


  public ModelFile trashingUser(User trashingUser) {
    this.trashingUser = trashingUser;
    return this;
  }

  /**
   * Get trashingUser
   * @return trashingUser
   */
  @javax.annotation.Nullable
  public User getTrashingUser() {
    return trashingUser;
  }

  public void setTrashingUser(User trashingUser) {
    this.trashingUser = trashingUser;
  }


  public ModelFile version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Output only. A monotonically increasing version number for the file. This reflects every change made to the file on the server, even those not visible to the user.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public ModelFile videoMediaMetadata(FileVideoMediaMetadata videoMediaMetadata) {
    this.videoMediaMetadata = videoMediaMetadata;
    return this;
  }

  /**
   * Get videoMediaMetadata
   * @return videoMediaMetadata
   */
  @javax.annotation.Nullable
  public FileVideoMediaMetadata getVideoMediaMetadata() {
    return videoMediaMetadata;
  }

  public void setVideoMediaMetadata(FileVideoMediaMetadata videoMediaMetadata) {
    this.videoMediaMetadata = videoMediaMetadata;
  }


  public ModelFile viewedByMe(Boolean viewedByMe) {
    this.viewedByMe = viewedByMe;
    return this;
  }

  /**
   * Output only. Whether the file has been viewed by this user.
   * @return viewedByMe
   */
  @javax.annotation.Nullable
  public Boolean getViewedByMe() {
    return viewedByMe;
  }

  public void setViewedByMe(Boolean viewedByMe) {
    this.viewedByMe = viewedByMe;
  }


  public ModelFile viewedByMeTime(OffsetDateTime viewedByMeTime) {
    this.viewedByMeTime = viewedByMeTime;
    return this;
  }

  /**
   * The last time the file was viewed by the user (RFC 3339 date-time).
   * @return viewedByMeTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getViewedByMeTime() {
    return viewedByMeTime;
  }

  public void setViewedByMeTime(OffsetDateTime viewedByMeTime) {
    this.viewedByMeTime = viewedByMeTime;
  }


  @Deprecated
  public ModelFile viewersCanCopyContent(Boolean viewersCanCopyContent) {
    this.viewersCanCopyContent = viewersCanCopyContent;
    return this;
  }

  /**
   * Deprecated: Use &#x60;copyRequiresWriterPermission&#x60; instead.
   * @return viewersCanCopyContent
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getViewersCanCopyContent() {
    return viewersCanCopyContent;
  }

  @Deprecated
  public void setViewersCanCopyContent(Boolean viewersCanCopyContent) {
    this.viewersCanCopyContent = viewersCanCopyContent;
  }


  public ModelFile webContentLink(String webContentLink) {
    this.webContentLink = webContentLink;
    return this;
  }

  /**
   * Output only. A link for downloading the content of the file in a browser. This is only available for files with binary content in Google Drive.
   * @return webContentLink
   */
  @javax.annotation.Nullable
  public String getWebContentLink() {
    return webContentLink;
  }

  public void setWebContentLink(String webContentLink) {
    this.webContentLink = webContentLink;
  }


  public ModelFile webViewLink(String webViewLink) {
    this.webViewLink = webViewLink;
    return this;
  }

  /**
   * Output only. A link for opening the file in a relevant Google editor or viewer in a browser.
   * @return webViewLink
   */
  @javax.annotation.Nullable
  public String getWebViewLink() {
    return webViewLink;
  }

  public void setWebViewLink(String webViewLink) {
    this.webViewLink = webViewLink;
  }


  public ModelFile writersCanShare(Boolean writersCanShare) {
    this.writersCanShare = writersCanShare;
    return this;
  }

  /**
   * Whether users with only &#x60;writer&#x60; permission can modify the file&#39;s permissions. Not populated for items in shared drives.
   * @return writersCanShare
   */
  @javax.annotation.Nullable
  public Boolean getWritersCanShare() {
    return writersCanShare;
  }

  public void setWritersCanShare(Boolean writersCanShare) {
    this.writersCanShare = writersCanShare;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelFile _file = (ModelFile) o;
    return Objects.equals(this.appProperties, _file.appProperties) &&
        Objects.equals(this.capabilities, _file.capabilities) &&
        Objects.equals(this.contentHints, _file.contentHints) &&
        Objects.equals(this.contentRestrictions, _file.contentRestrictions) &&
        Objects.equals(this.copyRequiresWriterPermission, _file.copyRequiresWriterPermission) &&
        Objects.equals(this.createdTime, _file.createdTime) &&
        Objects.equals(this.description, _file.description) &&
        Objects.equals(this.driveId, _file.driveId) &&
        Objects.equals(this.explicitlyTrashed, _file.explicitlyTrashed) &&
        Objects.equals(this.exportLinks, _file.exportLinks) &&
        Objects.equals(this.fileExtension, _file.fileExtension) &&
        Objects.equals(this.folderColorRgb, _file.folderColorRgb) &&
        Objects.equals(this.fullFileExtension, _file.fullFileExtension) &&
        Objects.equals(this.hasAugmentedPermissions, _file.hasAugmentedPermissions) &&
        Objects.equals(this.hasThumbnail, _file.hasThumbnail) &&
        Objects.equals(this.headRevisionId, _file.headRevisionId) &&
        Objects.equals(this.iconLink, _file.iconLink) &&
        Objects.equals(this.id, _file.id) &&
        Objects.equals(this.imageMediaMetadata, _file.imageMediaMetadata) &&
        Objects.equals(this.isAppAuthorized, _file.isAppAuthorized) &&
        Objects.equals(this.kind, _file.kind) &&
        Objects.equals(this.labelInfo, _file.labelInfo) &&
        Objects.equals(this.lastModifyingUser, _file.lastModifyingUser) &&
        Objects.equals(this.linkShareMetadata, _file.linkShareMetadata) &&
        Objects.equals(this.md5Checksum, _file.md5Checksum) &&
        Objects.equals(this.mimeType, _file.mimeType) &&
        Objects.equals(this.modifiedByMe, _file.modifiedByMe) &&
        Objects.equals(this.modifiedByMeTime, _file.modifiedByMeTime) &&
        Objects.equals(this.modifiedTime, _file.modifiedTime) &&
        Objects.equals(this.name, _file.name) &&
        Objects.equals(this.originalFilename, _file.originalFilename) &&
        Objects.equals(this.ownedByMe, _file.ownedByMe) &&
        Objects.equals(this.owners, _file.owners) &&
        Objects.equals(this.parents, _file.parents) &&
        Objects.equals(this.permissionIds, _file.permissionIds) &&
        Objects.equals(this.permissions, _file.permissions) &&
        Objects.equals(this.properties, _file.properties) &&
        Objects.equals(this.quotaBytesUsed, _file.quotaBytesUsed) &&
        Objects.equals(this.resourceKey, _file.resourceKey) &&
        Objects.equals(this.sha1Checksum, _file.sha1Checksum) &&
        Objects.equals(this.sha256Checksum, _file.sha256Checksum) &&
        Objects.equals(this.shared, _file.shared) &&
        Objects.equals(this.sharedWithMeTime, _file.sharedWithMeTime) &&
        Objects.equals(this.sharingUser, _file.sharingUser) &&
        Objects.equals(this.shortcutDetails, _file.shortcutDetails) &&
        Objects.equals(this.size, _file.size) &&
        Objects.equals(this.spaces, _file.spaces) &&
        Objects.equals(this.starred, _file.starred) &&
        Objects.equals(this.teamDriveId, _file.teamDriveId) &&
        Objects.equals(this.thumbnailLink, _file.thumbnailLink) &&
        Objects.equals(this.thumbnailVersion, _file.thumbnailVersion) &&
        Objects.equals(this.trashed, _file.trashed) &&
        Objects.equals(this.trashedTime, _file.trashedTime) &&
        Objects.equals(this.trashingUser, _file.trashingUser) &&
        Objects.equals(this.version, _file.version) &&
        Objects.equals(this.videoMediaMetadata, _file.videoMediaMetadata) &&
        Objects.equals(this.viewedByMe, _file.viewedByMe) &&
        Objects.equals(this.viewedByMeTime, _file.viewedByMeTime) &&
        Objects.equals(this.viewersCanCopyContent, _file.viewersCanCopyContent) &&
        Objects.equals(this.webContentLink, _file.webContentLink) &&
        Objects.equals(this.webViewLink, _file.webViewLink) &&
        Objects.equals(this.writersCanShare, _file.writersCanShare);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appProperties, capabilities, contentHints, contentRestrictions, copyRequiresWriterPermission, createdTime, description, driveId, explicitlyTrashed, exportLinks, fileExtension, folderColorRgb, fullFileExtension, hasAugmentedPermissions, hasThumbnail, headRevisionId, iconLink, id, imageMediaMetadata, isAppAuthorized, kind, labelInfo, lastModifyingUser, linkShareMetadata, md5Checksum, mimeType, modifiedByMe, modifiedByMeTime, modifiedTime, name, originalFilename, ownedByMe, owners, parents, permissionIds, permissions, properties, quotaBytesUsed, resourceKey, sha1Checksum, sha256Checksum, shared, sharedWithMeTime, sharingUser, shortcutDetails, size, spaces, starred, teamDriveId, thumbnailLink, thumbnailVersion, trashed, trashedTime, trashingUser, version, videoMediaMetadata, viewedByMe, viewedByMeTime, viewersCanCopyContent, webContentLink, webViewLink, writersCanShare);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ModelFile {\n");
    sb.append("    appProperties: ").append(toIndentedString(appProperties)).append("\n");
    sb.append("    capabilities: ").append(toIndentedString(capabilities)).append("\n");
    sb.append("    contentHints: ").append(toIndentedString(contentHints)).append("\n");
    sb.append("    contentRestrictions: ").append(toIndentedString(contentRestrictions)).append("\n");
    sb.append("    copyRequiresWriterPermission: ").append(toIndentedString(copyRequiresWriterPermission)).append("\n");
    sb.append("    createdTime: ").append(toIndentedString(createdTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    driveId: ").append(toIndentedString(driveId)).append("\n");
    sb.append("    explicitlyTrashed: ").append(toIndentedString(explicitlyTrashed)).append("\n");
    sb.append("    exportLinks: ").append(toIndentedString(exportLinks)).append("\n");
    sb.append("    fileExtension: ").append(toIndentedString(fileExtension)).append("\n");
    sb.append("    folderColorRgb: ").append(toIndentedString(folderColorRgb)).append("\n");
    sb.append("    fullFileExtension: ").append(toIndentedString(fullFileExtension)).append("\n");
    sb.append("    hasAugmentedPermissions: ").append(toIndentedString(hasAugmentedPermissions)).append("\n");
    sb.append("    hasThumbnail: ").append(toIndentedString(hasThumbnail)).append("\n");
    sb.append("    headRevisionId: ").append(toIndentedString(headRevisionId)).append("\n");
    sb.append("    iconLink: ").append(toIndentedString(iconLink)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    imageMediaMetadata: ").append(toIndentedString(imageMediaMetadata)).append("\n");
    sb.append("    isAppAuthorized: ").append(toIndentedString(isAppAuthorized)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labelInfo: ").append(toIndentedString(labelInfo)).append("\n");
    sb.append("    lastModifyingUser: ").append(toIndentedString(lastModifyingUser)).append("\n");
    sb.append("    linkShareMetadata: ").append(toIndentedString(linkShareMetadata)).append("\n");
    sb.append("    md5Checksum: ").append(toIndentedString(md5Checksum)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    modifiedByMe: ").append(toIndentedString(modifiedByMe)).append("\n");
    sb.append("    modifiedByMeTime: ").append(toIndentedString(modifiedByMeTime)).append("\n");
    sb.append("    modifiedTime: ").append(toIndentedString(modifiedTime)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    originalFilename: ").append(toIndentedString(originalFilename)).append("\n");
    sb.append("    ownedByMe: ").append(toIndentedString(ownedByMe)).append("\n");
    sb.append("    owners: ").append(toIndentedString(owners)).append("\n");
    sb.append("    parents: ").append(toIndentedString(parents)).append("\n");
    sb.append("    permissionIds: ").append(toIndentedString(permissionIds)).append("\n");
    sb.append("    permissions: ").append(toIndentedString(permissions)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    quotaBytesUsed: ").append(toIndentedString(quotaBytesUsed)).append("\n");
    sb.append("    resourceKey: ").append(toIndentedString(resourceKey)).append("\n");
    sb.append("    sha1Checksum: ").append(toIndentedString(sha1Checksum)).append("\n");
    sb.append("    sha256Checksum: ").append(toIndentedString(sha256Checksum)).append("\n");
    sb.append("    shared: ").append(toIndentedString(shared)).append("\n");
    sb.append("    sharedWithMeTime: ").append(toIndentedString(sharedWithMeTime)).append("\n");
    sb.append("    sharingUser: ").append(toIndentedString(sharingUser)).append("\n");
    sb.append("    shortcutDetails: ").append(toIndentedString(shortcutDetails)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    spaces: ").append(toIndentedString(spaces)).append("\n");
    sb.append("    starred: ").append(toIndentedString(starred)).append("\n");
    sb.append("    teamDriveId: ").append(toIndentedString(teamDriveId)).append("\n");
    sb.append("    thumbnailLink: ").append(toIndentedString(thumbnailLink)).append("\n");
    sb.append("    thumbnailVersion: ").append(toIndentedString(thumbnailVersion)).append("\n");
    sb.append("    trashed: ").append(toIndentedString(trashed)).append("\n");
    sb.append("    trashedTime: ").append(toIndentedString(trashedTime)).append("\n");
    sb.append("    trashingUser: ").append(toIndentedString(trashingUser)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    videoMediaMetadata: ").append(toIndentedString(videoMediaMetadata)).append("\n");
    sb.append("    viewedByMe: ").append(toIndentedString(viewedByMe)).append("\n");
    sb.append("    viewedByMeTime: ").append(toIndentedString(viewedByMeTime)).append("\n");
    sb.append("    viewersCanCopyContent: ").append(toIndentedString(viewersCanCopyContent)).append("\n");
    sb.append("    webContentLink: ").append(toIndentedString(webContentLink)).append("\n");
    sb.append("    webViewLink: ").append(toIndentedString(webViewLink)).append("\n");
    sb.append("    writersCanShare: ").append(toIndentedString(writersCanShare)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("appProperties");
    openapiFields.add("capabilities");
    openapiFields.add("contentHints");
    openapiFields.add("contentRestrictions");
    openapiFields.add("copyRequiresWriterPermission");
    openapiFields.add("createdTime");
    openapiFields.add("description");
    openapiFields.add("driveId");
    openapiFields.add("explicitlyTrashed");
    openapiFields.add("exportLinks");
    openapiFields.add("fileExtension");
    openapiFields.add("folderColorRgb");
    openapiFields.add("fullFileExtension");
    openapiFields.add("hasAugmentedPermissions");
    openapiFields.add("hasThumbnail");
    openapiFields.add("headRevisionId");
    openapiFields.add("iconLink");
    openapiFields.add("id");
    openapiFields.add("imageMediaMetadata");
    openapiFields.add("isAppAuthorized");
    openapiFields.add("kind");
    openapiFields.add("labelInfo");
    openapiFields.add("lastModifyingUser");
    openapiFields.add("linkShareMetadata");
    openapiFields.add("md5Checksum");
    openapiFields.add("mimeType");
    openapiFields.add("modifiedByMe");
    openapiFields.add("modifiedByMeTime");
    openapiFields.add("modifiedTime");
    openapiFields.add("name");
    openapiFields.add("originalFilename");
    openapiFields.add("ownedByMe");
    openapiFields.add("owners");
    openapiFields.add("parents");
    openapiFields.add("permissionIds");
    openapiFields.add("permissions");
    openapiFields.add("properties");
    openapiFields.add("quotaBytesUsed");
    openapiFields.add("resourceKey");
    openapiFields.add("sha1Checksum");
    openapiFields.add("sha256Checksum");
    openapiFields.add("shared");
    openapiFields.add("sharedWithMeTime");
    openapiFields.add("sharingUser");
    openapiFields.add("shortcutDetails");
    openapiFields.add("size");
    openapiFields.add("spaces");
    openapiFields.add("starred");
    openapiFields.add("teamDriveId");
    openapiFields.add("thumbnailLink");
    openapiFields.add("thumbnailVersion");
    openapiFields.add("trashed");
    openapiFields.add("trashedTime");
    openapiFields.add("trashingUser");
    openapiFields.add("version");
    openapiFields.add("videoMediaMetadata");
    openapiFields.add("viewedByMe");
    openapiFields.add("viewedByMeTime");
    openapiFields.add("viewersCanCopyContent");
    openapiFields.add("webContentLink");
    openapiFields.add("webViewLink");
    openapiFields.add("writersCanShare");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ModelFile
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ModelFile.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ModelFile is not found in the empty JSON string", ModelFile.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ModelFile.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ModelFile` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `capabilities`
      if (jsonObj.get("capabilities") != null && !jsonObj.get("capabilities").isJsonNull()) {
        FileCapabilities.validateJsonElement(jsonObj.get("capabilities"));
      }
      // validate the optional field `contentHints`
      if (jsonObj.get("contentHints") != null && !jsonObj.get("contentHints").isJsonNull()) {
        FileContentHints.validateJsonElement(jsonObj.get("contentHints"));
      }
      if (jsonObj.get("contentRestrictions") != null && !jsonObj.get("contentRestrictions").isJsonNull()) {
        JsonArray jsonArraycontentRestrictions = jsonObj.getAsJsonArray("contentRestrictions");
        if (jsonArraycontentRestrictions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("contentRestrictions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `contentRestrictions` to be an array in the JSON string but got `%s`", jsonObj.get("contentRestrictions").toString()));
          }

          // validate the optional field `contentRestrictions` (array)
          for (int i = 0; i < jsonArraycontentRestrictions.size(); i++) {
            ContentRestriction.validateJsonElement(jsonArraycontentRestrictions.get(i));
          };
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("driveId") != null && !jsonObj.get("driveId").isJsonNull()) && !jsonObj.get("driveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `driveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("driveId").toString()));
      }
      if ((jsonObj.get("fileExtension") != null && !jsonObj.get("fileExtension").isJsonNull()) && !jsonObj.get("fileExtension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileExtension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileExtension").toString()));
      }
      if ((jsonObj.get("folderColorRgb") != null && !jsonObj.get("folderColorRgb").isJsonNull()) && !jsonObj.get("folderColorRgb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `folderColorRgb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("folderColorRgb").toString()));
      }
      if ((jsonObj.get("fullFileExtension") != null && !jsonObj.get("fullFileExtension").isJsonNull()) && !jsonObj.get("fullFileExtension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fullFileExtension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fullFileExtension").toString()));
      }
      if ((jsonObj.get("headRevisionId") != null && !jsonObj.get("headRevisionId").isJsonNull()) && !jsonObj.get("headRevisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `headRevisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("headRevisionId").toString()));
      }
      if ((jsonObj.get("iconLink") != null && !jsonObj.get("iconLink").isJsonNull()) && !jsonObj.get("iconLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iconLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iconLink").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `imageMediaMetadata`
      if (jsonObj.get("imageMediaMetadata") != null && !jsonObj.get("imageMediaMetadata").isJsonNull()) {
        FileImageMediaMetadata.validateJsonElement(jsonObj.get("imageMediaMetadata"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `labelInfo`
      if (jsonObj.get("labelInfo") != null && !jsonObj.get("labelInfo").isJsonNull()) {
        FileLabelInfo.validateJsonElement(jsonObj.get("labelInfo"));
      }
      // validate the optional field `lastModifyingUser`
      if (jsonObj.get("lastModifyingUser") != null && !jsonObj.get("lastModifyingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("lastModifyingUser"));
      }
      // validate the optional field `linkShareMetadata`
      if (jsonObj.get("linkShareMetadata") != null && !jsonObj.get("linkShareMetadata").isJsonNull()) {
        FileLinkShareMetadata.validateJsonElement(jsonObj.get("linkShareMetadata"));
      }
      if ((jsonObj.get("md5Checksum") != null && !jsonObj.get("md5Checksum").isJsonNull()) && !jsonObj.get("md5Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `md5Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("md5Checksum").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("originalFilename") != null && !jsonObj.get("originalFilename").isJsonNull()) && !jsonObj.get("originalFilename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalFilename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalFilename").toString()));
      }
      if (jsonObj.get("owners") != null && !jsonObj.get("owners").isJsonNull()) {
        JsonArray jsonArrayowners = jsonObj.getAsJsonArray("owners");
        if (jsonArrayowners != null) {
          // ensure the json data is an array
          if (!jsonObj.get("owners").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `owners` to be an array in the JSON string but got `%s`", jsonObj.get("owners").toString()));
          }

          // validate the optional field `owners` (array)
          for (int i = 0; i < jsonArrayowners.size(); i++) {
            User.validateJsonElement(jsonArrayowners.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("parents") != null && !jsonObj.get("parents").isJsonNull() && !jsonObj.get("parents").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `parents` to be an array in the JSON string but got `%s`", jsonObj.get("parents").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permissionIds") != null && !jsonObj.get("permissionIds").isJsonNull() && !jsonObj.get("permissionIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permissionIds` to be an array in the JSON string but got `%s`", jsonObj.get("permissionIds").toString()));
      }
      if (jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) {
        JsonArray jsonArraypermissions = jsonObj.getAsJsonArray("permissions");
        if (jsonArraypermissions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("permissions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `permissions` to be an array in the JSON string but got `%s`", jsonObj.get("permissions").toString()));
          }

          // validate the optional field `permissions` (array)
          for (int i = 0; i < jsonArraypermissions.size(); i++) {
            Permission.validateJsonElement(jsonArraypermissions.get(i));
          };
        }
      }
      if ((jsonObj.get("quotaBytesUsed") != null && !jsonObj.get("quotaBytesUsed").isJsonNull()) && !jsonObj.get("quotaBytesUsed").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quotaBytesUsed` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quotaBytesUsed").toString()));
      }
      if ((jsonObj.get("resourceKey") != null && !jsonObj.get("resourceKey").isJsonNull()) && !jsonObj.get("resourceKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resourceKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resourceKey").toString()));
      }
      if ((jsonObj.get("sha1Checksum") != null && !jsonObj.get("sha1Checksum").isJsonNull()) && !jsonObj.get("sha1Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sha1Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sha1Checksum").toString()));
      }
      if ((jsonObj.get("sha256Checksum") != null && !jsonObj.get("sha256Checksum").isJsonNull()) && !jsonObj.get("sha256Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sha256Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sha256Checksum").toString()));
      }
      // validate the optional field `sharingUser`
      if (jsonObj.get("sharingUser") != null && !jsonObj.get("sharingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("sharingUser"));
      }
      // validate the optional field `shortcutDetails`
      if (jsonObj.get("shortcutDetails") != null && !jsonObj.get("shortcutDetails").isJsonNull()) {
        FileShortcutDetails.validateJsonElement(jsonObj.get("shortcutDetails"));
      }
      if ((jsonObj.get("size") != null && !jsonObj.get("size").isJsonNull()) && !jsonObj.get("size").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `size` to be a primitive type in the JSON string but got `%s`", jsonObj.get("size").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("spaces") != null && !jsonObj.get("spaces").isJsonNull() && !jsonObj.get("spaces").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `spaces` to be an array in the JSON string but got `%s`", jsonObj.get("spaces").toString()));
      }
      if ((jsonObj.get("teamDriveId") != null && !jsonObj.get("teamDriveId").isJsonNull()) && !jsonObj.get("teamDriveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `teamDriveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("teamDriveId").toString()));
      }
      if ((jsonObj.get("thumbnailLink") != null && !jsonObj.get("thumbnailLink").isJsonNull()) && !jsonObj.get("thumbnailLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbnailLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbnailLink").toString()));
      }
      if ((jsonObj.get("thumbnailVersion") != null && !jsonObj.get("thumbnailVersion").isJsonNull()) && !jsonObj.get("thumbnailVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbnailVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbnailVersion").toString()));
      }
      // validate the optional field `trashingUser`
      if (jsonObj.get("trashingUser") != null && !jsonObj.get("trashingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("trashingUser"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      // validate the optional field `videoMediaMetadata`
      if (jsonObj.get("videoMediaMetadata") != null && !jsonObj.get("videoMediaMetadata").isJsonNull()) {
        FileVideoMediaMetadata.validateJsonElement(jsonObj.get("videoMediaMetadata"));
      }
      if ((jsonObj.get("webContentLink") != null && !jsonObj.get("webContentLink").isJsonNull()) && !jsonObj.get("webContentLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webContentLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webContentLink").toString()));
      }
      if ((jsonObj.get("webViewLink") != null && !jsonObj.get("webViewLink").isJsonNull()) && !jsonObj.get("webViewLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webViewLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webViewLink").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ModelFile.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ModelFile' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ModelFile> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ModelFile.class));

       return (TypeAdapter<T>) new TypeAdapter<ModelFile>() {
           @Override
           public void write(JsonWriter out, ModelFile value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ModelFile read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ModelFile given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ModelFile
   * @throws IOException if the JSON string is invalid with respect to ModelFile
   */
  public static ModelFile fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ModelFile.class);
  }

  /**
   * Convert an instance of ModelFile to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

