/*
 * Google Drive API
 * The Google Drive API allows clients to access resources from Google Drive.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The metadata for a revision to a file. Some resource methods (such as &#x60;revisions.update&#x60;) require a &#x60;revisionId&#x60;. Use the &#x60;revisions.list&#x60; method to retrieve the ID for a revision.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:32.870459-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Revision {
  public static final String SERIALIZED_NAME_EXPORT_LINKS = "exportLinks";
  @SerializedName(SERIALIZED_NAME_EXPORT_LINKS)
  private Map<String, String> exportLinks = new HashMap<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KEEP_FOREVER = "keepForever";
  @SerializedName(SERIALIZED_NAME_KEEP_FOREVER)
  private Boolean keepForever;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "drive#revision";

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER = "lastModifyingUser";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER)
  private User lastModifyingUser;

  public static final String SERIALIZED_NAME_MD5_CHECKSUM = "md5Checksum";
  @SerializedName(SERIALIZED_NAME_MD5_CHECKSUM)
  private String md5Checksum;

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_MODIFIED_TIME = "modifiedTime";
  @SerializedName(SERIALIZED_NAME_MODIFIED_TIME)
  private OffsetDateTime modifiedTime;

  public static final String SERIALIZED_NAME_ORIGINAL_FILENAME = "originalFilename";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_FILENAME)
  private String originalFilename;

  public static final String SERIALIZED_NAME_PUBLISH_AUTO = "publishAuto";
  @SerializedName(SERIALIZED_NAME_PUBLISH_AUTO)
  private Boolean publishAuto;

  public static final String SERIALIZED_NAME_PUBLISHED = "published";
  @SerializedName(SERIALIZED_NAME_PUBLISHED)
  private Boolean published;

  public static final String SERIALIZED_NAME_PUBLISHED_LINK = "publishedLink";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_LINK)
  private String publishedLink;

  public static final String SERIALIZED_NAME_PUBLISHED_OUTSIDE_DOMAIN = "publishedOutsideDomain";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_OUTSIDE_DOMAIN)
  private Boolean publishedOutsideDomain;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private String size;

  public Revision() {
  }

  public Revision exportLinks(Map<String, String> exportLinks) {
    this.exportLinks = exportLinks;
    return this;
  }

  public Revision putExportLinksItem(String key, String exportLinksItem) {
    if (this.exportLinks == null) {
      this.exportLinks = new HashMap<>();
    }
    this.exportLinks.put(key, exportLinksItem);
    return this;
  }

  /**
   * Output only. Links for exporting Docs Editors files to specific formats.
   * @return exportLinks
   */
  @javax.annotation.Nullable
  public Map<String, String> getExportLinks() {
    return exportLinks;
  }

  public void setExportLinks(Map<String, String> exportLinks) {
    this.exportLinks = exportLinks;
  }


  public Revision id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Output only. The ID of the revision.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Revision keepForever(Boolean keepForever) {
    this.keepForever = keepForever;
    return this;
  }

  /**
   * Whether to keep this revision forever, even if it is no longer the head revision. If not set, the revision will be automatically purged 30 days after newer content is uploaded. This can be set on a maximum of 200 revisions for a file. This field is only applicable to files with binary content in Drive.
   * @return keepForever
   */
  @javax.annotation.Nullable
  public Boolean getKeepForever() {
    return keepForever;
  }

  public void setKeepForever(Boolean keepForever) {
    this.keepForever = keepForever;
  }


  public Revision kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Output only. Identifies what kind of resource this is. Value: the fixed string &#x60;\&quot;drive#revision\&quot;&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Revision lastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
    return this;
  }

  /**
   * Get lastModifyingUser
   * @return lastModifyingUser
   */
  @javax.annotation.Nullable
  public User getLastModifyingUser() {
    return lastModifyingUser;
  }

  public void setLastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
  }


  public Revision md5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
    return this;
  }

  /**
   * Output only. The MD5 checksum of the revision&#39;s content. This is only applicable to files with binary content in Drive.
   * @return md5Checksum
   */
  @javax.annotation.Nullable
  public String getMd5Checksum() {
    return md5Checksum;
  }

  public void setMd5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
  }


  public Revision mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * Output only. The MIME type of the revision.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public Revision modifiedTime(OffsetDateTime modifiedTime) {
    this.modifiedTime = modifiedTime;
    return this;
  }

  /**
   * The last time the revision was modified (RFC 3339 date-time).
   * @return modifiedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedTime() {
    return modifiedTime;
  }

  public void setModifiedTime(OffsetDateTime modifiedTime) {
    this.modifiedTime = modifiedTime;
  }


  public Revision originalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
    return this;
  }

  /**
   * Output only. The original filename used to create this revision. This is only applicable to files with binary content in Drive.
   * @return originalFilename
   */
  @javax.annotation.Nullable
  public String getOriginalFilename() {
    return originalFilename;
  }

  public void setOriginalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
  }


  public Revision publishAuto(Boolean publishAuto) {
    this.publishAuto = publishAuto;
    return this;
  }

  /**
   * Whether subsequent revisions will be automatically republished. This is only applicable to Docs Editors files.
   * @return publishAuto
   */
  @javax.annotation.Nullable
  public Boolean getPublishAuto() {
    return publishAuto;
  }

  public void setPublishAuto(Boolean publishAuto) {
    this.publishAuto = publishAuto;
  }


  public Revision published(Boolean published) {
    this.published = published;
    return this;
  }

  /**
   * Whether this revision is published. This is only applicable to Docs Editors files.
   * @return published
   */
  @javax.annotation.Nullable
  public Boolean getPublished() {
    return published;
  }

  public void setPublished(Boolean published) {
    this.published = published;
  }


  public Revision publishedLink(String publishedLink) {
    this.publishedLink = publishedLink;
    return this;
  }

  /**
   * Output only. A link to the published revision. This is only populated for Google Sites files.
   * @return publishedLink
   */
  @javax.annotation.Nullable
  public String getPublishedLink() {
    return publishedLink;
  }

  public void setPublishedLink(String publishedLink) {
    this.publishedLink = publishedLink;
  }


  public Revision publishedOutsideDomain(Boolean publishedOutsideDomain) {
    this.publishedOutsideDomain = publishedOutsideDomain;
    return this;
  }

  /**
   * Whether this revision is published outside the domain. This is only applicable to Docs Editors files.
   * @return publishedOutsideDomain
   */
  @javax.annotation.Nullable
  public Boolean getPublishedOutsideDomain() {
    return publishedOutsideDomain;
  }

  public void setPublishedOutsideDomain(Boolean publishedOutsideDomain) {
    this.publishedOutsideDomain = publishedOutsideDomain;
  }


  public Revision size(String size) {
    this.size = size;
    return this;
  }

  /**
   * Output only. The size of the revision&#39;s content in bytes. This is only applicable to files with binary content in Drive.
   * @return size
   */
  @javax.annotation.Nullable
  public String getSize() {
    return size;
  }

  public void setSize(String size) {
    this.size = size;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Revision revision = (Revision) o;
    return Objects.equals(this.exportLinks, revision.exportLinks) &&
        Objects.equals(this.id, revision.id) &&
        Objects.equals(this.keepForever, revision.keepForever) &&
        Objects.equals(this.kind, revision.kind) &&
        Objects.equals(this.lastModifyingUser, revision.lastModifyingUser) &&
        Objects.equals(this.md5Checksum, revision.md5Checksum) &&
        Objects.equals(this.mimeType, revision.mimeType) &&
        Objects.equals(this.modifiedTime, revision.modifiedTime) &&
        Objects.equals(this.originalFilename, revision.originalFilename) &&
        Objects.equals(this.publishAuto, revision.publishAuto) &&
        Objects.equals(this.published, revision.published) &&
        Objects.equals(this.publishedLink, revision.publishedLink) &&
        Objects.equals(this.publishedOutsideDomain, revision.publishedOutsideDomain) &&
        Objects.equals(this.size, revision.size);
  }

  @Override
  public int hashCode() {
    return Objects.hash(exportLinks, id, keepForever, kind, lastModifyingUser, md5Checksum, mimeType, modifiedTime, originalFilename, publishAuto, published, publishedLink, publishedOutsideDomain, size);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Revision {\n");
    sb.append("    exportLinks: ").append(toIndentedString(exportLinks)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    keepForever: ").append(toIndentedString(keepForever)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    lastModifyingUser: ").append(toIndentedString(lastModifyingUser)).append("\n");
    sb.append("    md5Checksum: ").append(toIndentedString(md5Checksum)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    modifiedTime: ").append(toIndentedString(modifiedTime)).append("\n");
    sb.append("    originalFilename: ").append(toIndentedString(originalFilename)).append("\n");
    sb.append("    publishAuto: ").append(toIndentedString(publishAuto)).append("\n");
    sb.append("    published: ").append(toIndentedString(published)).append("\n");
    sb.append("    publishedLink: ").append(toIndentedString(publishedLink)).append("\n");
    sb.append("    publishedOutsideDomain: ").append(toIndentedString(publishedOutsideDomain)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("exportLinks");
    openapiFields.add("id");
    openapiFields.add("keepForever");
    openapiFields.add("kind");
    openapiFields.add("lastModifyingUser");
    openapiFields.add("md5Checksum");
    openapiFields.add("mimeType");
    openapiFields.add("modifiedTime");
    openapiFields.add("originalFilename");
    openapiFields.add("publishAuto");
    openapiFields.add("published");
    openapiFields.add("publishedLink");
    openapiFields.add("publishedOutsideDomain");
    openapiFields.add("size");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Revision
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Revision.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Revision is not found in the empty JSON string", Revision.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Revision.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Revision` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `lastModifyingUser`
      if (jsonObj.get("lastModifyingUser") != null && !jsonObj.get("lastModifyingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("lastModifyingUser"));
      }
      if ((jsonObj.get("md5Checksum") != null && !jsonObj.get("md5Checksum").isJsonNull()) && !jsonObj.get("md5Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `md5Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("md5Checksum").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("originalFilename") != null && !jsonObj.get("originalFilename").isJsonNull()) && !jsonObj.get("originalFilename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalFilename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalFilename").toString()));
      }
      if ((jsonObj.get("publishedLink") != null && !jsonObj.get("publishedLink").isJsonNull()) && !jsonObj.get("publishedLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publishedLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publishedLink").toString()));
      }
      if ((jsonObj.get("size") != null && !jsonObj.get("size").isJsonNull()) && !jsonObj.get("size").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `size` to be a primitive type in the JSON string but got `%s`", jsonObj.get("size").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Revision.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Revision' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Revision> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Revision.class));

       return (TypeAdapter<T>) new TypeAdapter<Revision>() {
           @Override
           public void write(JsonWriter out, Revision value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Revision read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Revision given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Revision
   * @throws IOException if the JSON string is invalid with respect to Revision
   */
  public static Revision fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Revision.class);
  }

  /**
   * Convert an instance of Revision to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

