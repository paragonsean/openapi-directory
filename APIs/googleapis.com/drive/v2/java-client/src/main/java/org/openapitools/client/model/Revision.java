/*
 * Google Drive API
 * The Google Drive API allows clients to access resources from Google Drive.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A revision of a file. Some resource methods (such as &#x60;revisions.update&#x60;) require a &#x60;revisionId&#x60;. Use the &#x60;revisions.list&#x60; method to retrieve the ID for a revision.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:35.616021-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Revision {
  public static final String SERIALIZED_NAME_DOWNLOAD_URL = "downloadUrl";
  @SerializedName(SERIALIZED_NAME_DOWNLOAD_URL)
  private String downloadUrl;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_EXPORT_LINKS = "exportLinks";
  @SerializedName(SERIALIZED_NAME_EXPORT_LINKS)
  private Map<String, String> exportLinks = new HashMap<>();

  public static final String SERIALIZED_NAME_FILE_SIZE = "fileSize";
  @SerializedName(SERIALIZED_NAME_FILE_SIZE)
  private String fileSize;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "drive#revision";

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER = "lastModifyingUser";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER)
  private User lastModifyingUser;

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER_NAME = "lastModifyingUserName";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER_NAME)
  private String lastModifyingUserName;

  public static final String SERIALIZED_NAME_MD5_CHECKSUM = "md5Checksum";
  @SerializedName(SERIALIZED_NAME_MD5_CHECKSUM)
  private String md5Checksum;

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  private OffsetDateTime modifiedDate;

  public static final String SERIALIZED_NAME_ORIGINAL_FILENAME = "originalFilename";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_FILENAME)
  private String originalFilename;

  public static final String SERIALIZED_NAME_PINNED = "pinned";
  @SerializedName(SERIALIZED_NAME_PINNED)
  private Boolean pinned;

  public static final String SERIALIZED_NAME_PUBLISH_AUTO = "publishAuto";
  @SerializedName(SERIALIZED_NAME_PUBLISH_AUTO)
  private Boolean publishAuto;

  public static final String SERIALIZED_NAME_PUBLISHED = "published";
  @SerializedName(SERIALIZED_NAME_PUBLISHED)
  private Boolean published;

  public static final String SERIALIZED_NAME_PUBLISHED_LINK = "publishedLink";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_LINK)
  private String publishedLink;

  public static final String SERIALIZED_NAME_PUBLISHED_OUTSIDE_DOMAIN = "publishedOutsideDomain";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_OUTSIDE_DOMAIN)
  private Boolean publishedOutsideDomain;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public Revision() {
  }

  public Revision downloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
    return this;
  }

  /**
   * Output only. Short term download URL for the file. This will only be populated on files with content stored in Drive.
   * @return downloadUrl
   */
  @javax.annotation.Nullable
  public String getDownloadUrl() {
    return downloadUrl;
  }

  public void setDownloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
  }


  public Revision etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * Output only. The ETag of the revision.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public Revision exportLinks(Map<String, String> exportLinks) {
    this.exportLinks = exportLinks;
    return this;
  }

  public Revision putExportLinksItem(String key, String exportLinksItem) {
    if (this.exportLinks == null) {
      this.exportLinks = new HashMap<>();
    }
    this.exportLinks.put(key, exportLinksItem);
    return this;
  }

  /**
   * Output only. Links for exporting Docs Editors files to specific formats.
   * @return exportLinks
   */
  @javax.annotation.Nullable
  public Map<String, String> getExportLinks() {
    return exportLinks;
  }

  public void setExportLinks(Map<String, String> exportLinks) {
    this.exportLinks = exportLinks;
  }


  public Revision fileSize(String fileSize) {
    this.fileSize = fileSize;
    return this;
  }

  /**
   * Output only. The size of the revision in bytes. This will only be populated on files with content stored in Drive.
   * @return fileSize
   */
  @javax.annotation.Nullable
  public String getFileSize() {
    return fileSize;
  }

  public void setFileSize(String fileSize) {
    this.fileSize = fileSize;
  }


  public Revision id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Output only. The ID of the revision.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Revision kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Output only. This is always &#x60;drive#revision&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Revision lastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
    return this;
  }

  /**
   * Get lastModifyingUser
   * @return lastModifyingUser
   */
  @javax.annotation.Nullable
  public User getLastModifyingUser() {
    return lastModifyingUser;
  }

  public void setLastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
  }


  public Revision lastModifyingUserName(String lastModifyingUserName) {
    this.lastModifyingUserName = lastModifyingUserName;
    return this;
  }

  /**
   * Output only. Name of the last user to modify this revision.
   * @return lastModifyingUserName
   */
  @javax.annotation.Nullable
  public String getLastModifyingUserName() {
    return lastModifyingUserName;
  }

  public void setLastModifyingUserName(String lastModifyingUserName) {
    this.lastModifyingUserName = lastModifyingUserName;
  }


  public Revision md5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
    return this;
  }

  /**
   * Output only. An MD5 checksum for the content of this revision. This will only be populated on files with content stored in Drive.
   * @return md5Checksum
   */
  @javax.annotation.Nullable
  public String getMd5Checksum() {
    return md5Checksum;
  }

  public void setMd5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
  }


  public Revision mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * Output only. The MIME type of the revision.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public Revision modifiedDate(OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
    return this;
  }

  /**
   * Last time this revision was modified (formatted RFC 3339 timestamp).
   * @return modifiedDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedDate() {
    return modifiedDate;
  }

  public void setModifiedDate(OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
  }


  public Revision originalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
    return this;
  }

  /**
   * Output only. The original filename when this revision was created. This will only be populated on files with content stored in Drive.
   * @return originalFilename
   */
  @javax.annotation.Nullable
  public String getOriginalFilename() {
    return originalFilename;
  }

  public void setOriginalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
  }


  public Revision pinned(Boolean pinned) {
    this.pinned = pinned;
    return this;
  }

  /**
   * Whether this revision is pinned to prevent automatic purging. If not set, the revision is automatically purged 30 days after newer content is uploaded. This field can only be modified on files with content stored in Drive, excluding Docs Editors files. Revisions can also be pinned when they are created through the drive.files.insert/update/copy by using the pinned query parameter. Pinned revisions are stored indefinitely using additional storage quota, up to a maximum of 200 revisions.
   * @return pinned
   */
  @javax.annotation.Nullable
  public Boolean getPinned() {
    return pinned;
  }

  public void setPinned(Boolean pinned) {
    this.pinned = pinned;
  }


  public Revision publishAuto(Boolean publishAuto) {
    this.publishAuto = publishAuto;
    return this;
  }

  /**
   * Whether subsequent revisions will be automatically republished. This is only populated and can only be modified for Docs Editors files.
   * @return publishAuto
   */
  @javax.annotation.Nullable
  public Boolean getPublishAuto() {
    return publishAuto;
  }

  public void setPublishAuto(Boolean publishAuto) {
    this.publishAuto = publishAuto;
  }


  public Revision published(Boolean published) {
    this.published = published;
    return this;
  }

  /**
   * Whether this revision is published. This is only populated and can only be modified for Docs Editors files.
   * @return published
   */
  @javax.annotation.Nullable
  public Boolean getPublished() {
    return published;
  }

  public void setPublished(Boolean published) {
    this.published = published;
  }


  public Revision publishedLink(String publishedLink) {
    this.publishedLink = publishedLink;
    return this;
  }

  /**
   * Output only. A link to the published revision. This is only populated for Google Sites files.
   * @return publishedLink
   */
  @javax.annotation.Nullable
  public String getPublishedLink() {
    return publishedLink;
  }

  public void setPublishedLink(String publishedLink) {
    this.publishedLink = publishedLink;
  }


  public Revision publishedOutsideDomain(Boolean publishedOutsideDomain) {
    this.publishedOutsideDomain = publishedOutsideDomain;
    return this;
  }

  /**
   * Whether this revision is published outside the domain. This is only populated and can only be modified for Docs Editors files.
   * @return publishedOutsideDomain
   */
  @javax.annotation.Nullable
  public Boolean getPublishedOutsideDomain() {
    return publishedOutsideDomain;
  }

  public void setPublishedOutsideDomain(Boolean publishedOutsideDomain) {
    this.publishedOutsideDomain = publishedOutsideDomain;
  }


  public Revision selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * Output only. A link back to this revision.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Revision revision = (Revision) o;
    return Objects.equals(this.downloadUrl, revision.downloadUrl) &&
        Objects.equals(this.etag, revision.etag) &&
        Objects.equals(this.exportLinks, revision.exportLinks) &&
        Objects.equals(this.fileSize, revision.fileSize) &&
        Objects.equals(this.id, revision.id) &&
        Objects.equals(this.kind, revision.kind) &&
        Objects.equals(this.lastModifyingUser, revision.lastModifyingUser) &&
        Objects.equals(this.lastModifyingUserName, revision.lastModifyingUserName) &&
        Objects.equals(this.md5Checksum, revision.md5Checksum) &&
        Objects.equals(this.mimeType, revision.mimeType) &&
        Objects.equals(this.modifiedDate, revision.modifiedDate) &&
        Objects.equals(this.originalFilename, revision.originalFilename) &&
        Objects.equals(this.pinned, revision.pinned) &&
        Objects.equals(this.publishAuto, revision.publishAuto) &&
        Objects.equals(this.published, revision.published) &&
        Objects.equals(this.publishedLink, revision.publishedLink) &&
        Objects.equals(this.publishedOutsideDomain, revision.publishedOutsideDomain) &&
        Objects.equals(this.selfLink, revision.selfLink);
  }

  @Override
  public int hashCode() {
    return Objects.hash(downloadUrl, etag, exportLinks, fileSize, id, kind, lastModifyingUser, lastModifyingUserName, md5Checksum, mimeType, modifiedDate, originalFilename, pinned, publishAuto, published, publishedLink, publishedOutsideDomain, selfLink);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Revision {\n");
    sb.append("    downloadUrl: ").append(toIndentedString(downloadUrl)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    exportLinks: ").append(toIndentedString(exportLinks)).append("\n");
    sb.append("    fileSize: ").append(toIndentedString(fileSize)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    lastModifyingUser: ").append(toIndentedString(lastModifyingUser)).append("\n");
    sb.append("    lastModifyingUserName: ").append(toIndentedString(lastModifyingUserName)).append("\n");
    sb.append("    md5Checksum: ").append(toIndentedString(md5Checksum)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    originalFilename: ").append(toIndentedString(originalFilename)).append("\n");
    sb.append("    pinned: ").append(toIndentedString(pinned)).append("\n");
    sb.append("    publishAuto: ").append(toIndentedString(publishAuto)).append("\n");
    sb.append("    published: ").append(toIndentedString(published)).append("\n");
    sb.append("    publishedLink: ").append(toIndentedString(publishedLink)).append("\n");
    sb.append("    publishedOutsideDomain: ").append(toIndentedString(publishedOutsideDomain)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("downloadUrl");
    openapiFields.add("etag");
    openapiFields.add("exportLinks");
    openapiFields.add("fileSize");
    openapiFields.add("id");
    openapiFields.add("kind");
    openapiFields.add("lastModifyingUser");
    openapiFields.add("lastModifyingUserName");
    openapiFields.add("md5Checksum");
    openapiFields.add("mimeType");
    openapiFields.add("modifiedDate");
    openapiFields.add("originalFilename");
    openapiFields.add("pinned");
    openapiFields.add("publishAuto");
    openapiFields.add("published");
    openapiFields.add("publishedLink");
    openapiFields.add("publishedOutsideDomain");
    openapiFields.add("selfLink");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Revision
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Revision.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Revision is not found in the empty JSON string", Revision.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Revision.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Revision` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("downloadUrl") != null && !jsonObj.get("downloadUrl").isJsonNull()) && !jsonObj.get("downloadUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `downloadUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("downloadUrl").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("fileSize") != null && !jsonObj.get("fileSize").isJsonNull()) && !jsonObj.get("fileSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileSize").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `lastModifyingUser`
      if (jsonObj.get("lastModifyingUser") != null && !jsonObj.get("lastModifyingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("lastModifyingUser"));
      }
      if ((jsonObj.get("lastModifyingUserName") != null && !jsonObj.get("lastModifyingUserName").isJsonNull()) && !jsonObj.get("lastModifyingUserName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastModifyingUserName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastModifyingUserName").toString()));
      }
      if ((jsonObj.get("md5Checksum") != null && !jsonObj.get("md5Checksum").isJsonNull()) && !jsonObj.get("md5Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `md5Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("md5Checksum").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("originalFilename") != null && !jsonObj.get("originalFilename").isJsonNull()) && !jsonObj.get("originalFilename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalFilename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalFilename").toString()));
      }
      if ((jsonObj.get("publishedLink") != null && !jsonObj.get("publishedLink").isJsonNull()) && !jsonObj.get("publishedLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publishedLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publishedLink").toString()));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Revision.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Revision' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Revision> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Revision.class));

       return (TypeAdapter<T>) new TypeAdapter<Revision>() {
           @Override
           public void write(JsonWriter out, Revision value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Revision read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Revision given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Revision
   * @throws IOException if the JSON string is invalid with respect to Revision
   */
  public static Revision fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Revision.class);
  }

  /**
   * Convert an instance of Revision to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

