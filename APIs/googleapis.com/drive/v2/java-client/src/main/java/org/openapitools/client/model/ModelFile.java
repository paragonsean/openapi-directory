/*
 * Google Drive API
 * The Google Drive API allows clients to access resources from Google Drive.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ContentRestriction;
import org.openapitools.client.model.FileCapabilities;
import org.openapitools.client.model.FileImageMediaMetadata;
import org.openapitools.client.model.FileIndexableText;
import org.openapitools.client.model.FileLabelInfo;
import org.openapitools.client.model.FileLabels;
import org.openapitools.client.model.FileLinkShareMetadata;
import org.openapitools.client.model.FileShortcutDetails;
import org.openapitools.client.model.FileThumbnail;
import org.openapitools.client.model.FileVideoMediaMetadata;
import org.openapitools.client.model.ParentReference;
import org.openapitools.client.model.Permission;
import org.openapitools.client.model.Property;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The metadata for a file. Some resource methods (such as &#x60;files.update&#x60;) require a &#x60;fileId&#x60;. Use the &#x60;files.list&#x60; method to retrieve the ID for a file.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:35.616021-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ModelFile {
  public static final String SERIALIZED_NAME_ALTERNATE_LINK = "alternateLink";
  @SerializedName(SERIALIZED_NAME_ALTERNATE_LINK)
  private String alternateLink;

  public static final String SERIALIZED_NAME_APP_DATA_CONTENTS = "appDataContents";
  @SerializedName(SERIALIZED_NAME_APP_DATA_CONTENTS)
  private Boolean appDataContents;

  public static final String SERIALIZED_NAME_CAN_COMMENT = "canComment";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CAN_COMMENT)
  private Boolean canComment;

  public static final String SERIALIZED_NAME_CAN_READ_REVISIONS = "canReadRevisions";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CAN_READ_REVISIONS)
  private Boolean canReadRevisions;

  public static final String SERIALIZED_NAME_CAPABILITIES = "capabilities";
  @SerializedName(SERIALIZED_NAME_CAPABILITIES)
  private FileCapabilities capabilities;

  public static final String SERIALIZED_NAME_CONTENT_RESTRICTIONS = "contentRestrictions";
  @SerializedName(SERIALIZED_NAME_CONTENT_RESTRICTIONS)
  private List<ContentRestriction> contentRestrictions = new ArrayList<>();

  public static final String SERIALIZED_NAME_COPY_REQUIRES_WRITER_PERMISSION = "copyRequiresWriterPermission";
  @SerializedName(SERIALIZED_NAME_COPY_REQUIRES_WRITER_PERMISSION)
  private Boolean copyRequiresWriterPermission;

  public static final String SERIALIZED_NAME_COPYABLE = "copyable";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_COPYABLE)
  private Boolean copyable;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private OffsetDateTime createdDate;

  public static final String SERIALIZED_NAME_DEFAULT_OPEN_WITH_LINK = "defaultOpenWithLink";
  @SerializedName(SERIALIZED_NAME_DEFAULT_OPEN_WITH_LINK)
  private String defaultOpenWithLink;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DOWNLOAD_URL = "downloadUrl";
  @SerializedName(SERIALIZED_NAME_DOWNLOAD_URL)
  private String downloadUrl;

  public static final String SERIALIZED_NAME_DRIVE_ID = "driveId";
  @SerializedName(SERIALIZED_NAME_DRIVE_ID)
  private String driveId;

  public static final String SERIALIZED_NAME_EDITABLE = "editable";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_EDITABLE)
  private Boolean editable;

  public static final String SERIALIZED_NAME_EMBED_LINK = "embedLink";
  @SerializedName(SERIALIZED_NAME_EMBED_LINK)
  private String embedLink;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_EXPLICITLY_TRASHED = "explicitlyTrashed";
  @SerializedName(SERIALIZED_NAME_EXPLICITLY_TRASHED)
  private Boolean explicitlyTrashed;

  public static final String SERIALIZED_NAME_EXPORT_LINKS = "exportLinks";
  @SerializedName(SERIALIZED_NAME_EXPORT_LINKS)
  private Map<String, String> exportLinks = new HashMap<>();

  public static final String SERIALIZED_NAME_FILE_EXTENSION = "fileExtension";
  @SerializedName(SERIALIZED_NAME_FILE_EXTENSION)
  private String fileExtension;

  public static final String SERIALIZED_NAME_FILE_SIZE = "fileSize";
  @SerializedName(SERIALIZED_NAME_FILE_SIZE)
  private String fileSize;

  public static final String SERIALIZED_NAME_FOLDER_COLOR_RGB = "folderColorRgb";
  @SerializedName(SERIALIZED_NAME_FOLDER_COLOR_RGB)
  private String folderColorRgb;

  public static final String SERIALIZED_NAME_FULL_FILE_EXTENSION = "fullFileExtension";
  @SerializedName(SERIALIZED_NAME_FULL_FILE_EXTENSION)
  private String fullFileExtension;

  public static final String SERIALIZED_NAME_HAS_AUGMENTED_PERMISSIONS = "hasAugmentedPermissions";
  @SerializedName(SERIALIZED_NAME_HAS_AUGMENTED_PERMISSIONS)
  private Boolean hasAugmentedPermissions;

  public static final String SERIALIZED_NAME_HAS_THUMBNAIL = "hasThumbnail";
  @SerializedName(SERIALIZED_NAME_HAS_THUMBNAIL)
  private Boolean hasThumbnail;

  public static final String SERIALIZED_NAME_HEAD_REVISION_ID = "headRevisionId";
  @SerializedName(SERIALIZED_NAME_HEAD_REVISION_ID)
  private String headRevisionId;

  public static final String SERIALIZED_NAME_ICON_LINK = "iconLink";
  @SerializedName(SERIALIZED_NAME_ICON_LINK)
  private String iconLink;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMAGE_MEDIA_METADATA = "imageMediaMetadata";
  @SerializedName(SERIALIZED_NAME_IMAGE_MEDIA_METADATA)
  private FileImageMediaMetadata imageMediaMetadata;

  public static final String SERIALIZED_NAME_INDEXABLE_TEXT = "indexableText";
  @SerializedName(SERIALIZED_NAME_INDEXABLE_TEXT)
  private FileIndexableText indexableText;

  public static final String SERIALIZED_NAME_IS_APP_AUTHORIZED = "isAppAuthorized";
  @SerializedName(SERIALIZED_NAME_IS_APP_AUTHORIZED)
  private Boolean isAppAuthorized;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "drive#file";

  public static final String SERIALIZED_NAME_LABEL_INFO = "labelInfo";
  @SerializedName(SERIALIZED_NAME_LABEL_INFO)
  private FileLabelInfo labelInfo;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private FileLabels labels;

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER = "lastModifyingUser";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER)
  private User lastModifyingUser;

  public static final String SERIALIZED_NAME_LAST_MODIFYING_USER_NAME = "lastModifyingUserName";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFYING_USER_NAME)
  private String lastModifyingUserName;

  public static final String SERIALIZED_NAME_LAST_VIEWED_BY_ME_DATE = "lastViewedByMeDate";
  @SerializedName(SERIALIZED_NAME_LAST_VIEWED_BY_ME_DATE)
  private OffsetDateTime lastViewedByMeDate;

  public static final String SERIALIZED_NAME_LINK_SHARE_METADATA = "linkShareMetadata";
  @SerializedName(SERIALIZED_NAME_LINK_SHARE_METADATA)
  private FileLinkShareMetadata linkShareMetadata;

  public static final String SERIALIZED_NAME_MARKED_VIEWED_BY_ME_DATE = "markedViewedByMeDate";
  @SerializedName(SERIALIZED_NAME_MARKED_VIEWED_BY_ME_DATE)
  private OffsetDateTime markedViewedByMeDate;

  public static final String SERIALIZED_NAME_MD5_CHECKSUM = "md5Checksum";
  @SerializedName(SERIALIZED_NAME_MD5_CHECKSUM)
  private String md5Checksum;

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_MODIFIED_BY_ME_DATE = "modifiedByMeDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY_ME_DATE)
  private OffsetDateTime modifiedByMeDate;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  private OffsetDateTime modifiedDate;

  public static final String SERIALIZED_NAME_OPEN_WITH_LINKS = "openWithLinks";
  @SerializedName(SERIALIZED_NAME_OPEN_WITH_LINKS)
  private Map<String, String> openWithLinks = new HashMap<>();

  public static final String SERIALIZED_NAME_ORIGINAL_FILENAME = "originalFilename";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_FILENAME)
  private String originalFilename;

  public static final String SERIALIZED_NAME_OWNED_BY_ME = "ownedByMe";
  @SerializedName(SERIALIZED_NAME_OWNED_BY_ME)
  private Boolean ownedByMe;

  public static final String SERIALIZED_NAME_OWNER_NAMES = "ownerNames";
  @SerializedName(SERIALIZED_NAME_OWNER_NAMES)
  private List<String> ownerNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_OWNERS = "owners";
  @SerializedName(SERIALIZED_NAME_OWNERS)
  private List<User> owners = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARENTS = "parents";
  @SerializedName(SERIALIZED_NAME_PARENTS)
  private List<ParentReference> parents = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMISSION_IDS = "permissionIds";
  @SerializedName(SERIALIZED_NAME_PERMISSION_IDS)
  private List<String> permissionIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMISSIONS = "permissions";
  @SerializedName(SERIALIZED_NAME_PERMISSIONS)
  private List<Permission> permissions = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private List<Property> properties = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUOTA_BYTES_USED = "quotaBytesUsed";
  @SerializedName(SERIALIZED_NAME_QUOTA_BYTES_USED)
  private String quotaBytesUsed;

  public static final String SERIALIZED_NAME_RESOURCE_KEY = "resourceKey";
  @SerializedName(SERIALIZED_NAME_RESOURCE_KEY)
  private String resourceKey;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public static final String SERIALIZED_NAME_SHA1_CHECKSUM = "sha1Checksum";
  @SerializedName(SERIALIZED_NAME_SHA1_CHECKSUM)
  private String sha1Checksum;

  public static final String SERIALIZED_NAME_SHA256_CHECKSUM = "sha256Checksum";
  @SerializedName(SERIALIZED_NAME_SHA256_CHECKSUM)
  private String sha256Checksum;

  public static final String SERIALIZED_NAME_SHAREABLE = "shareable";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_SHAREABLE)
  private Boolean shareable;

  public static final String SERIALIZED_NAME_SHARED = "shared";
  @SerializedName(SERIALIZED_NAME_SHARED)
  private Boolean shared;

  public static final String SERIALIZED_NAME_SHARED_WITH_ME_DATE = "sharedWithMeDate";
  @SerializedName(SERIALIZED_NAME_SHARED_WITH_ME_DATE)
  private OffsetDateTime sharedWithMeDate;

  public static final String SERIALIZED_NAME_SHARING_USER = "sharingUser";
  @SerializedName(SERIALIZED_NAME_SHARING_USER)
  private User sharingUser;

  public static final String SERIALIZED_NAME_SHORTCUT_DETAILS = "shortcutDetails";
  @SerializedName(SERIALIZED_NAME_SHORTCUT_DETAILS)
  private FileShortcutDetails shortcutDetails;

  public static final String SERIALIZED_NAME_SPACES = "spaces";
  @SerializedName(SERIALIZED_NAME_SPACES)
  private List<String> spaces = new ArrayList<>();

  public static final String SERIALIZED_NAME_TEAM_DRIVE_ID = "teamDriveId";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_TEAM_DRIVE_ID)
  private String teamDriveId;

  public static final String SERIALIZED_NAME_THUMBNAIL = "thumbnail";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL)
  private FileThumbnail thumbnail;

  public static final String SERIALIZED_NAME_THUMBNAIL_LINK = "thumbnailLink";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL_LINK)
  private String thumbnailLink;

  public static final String SERIALIZED_NAME_THUMBNAIL_VERSION = "thumbnailVersion";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL_VERSION)
  private String thumbnailVersion;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_TRASHED_DATE = "trashedDate";
  @SerializedName(SERIALIZED_NAME_TRASHED_DATE)
  private OffsetDateTime trashedDate;

  public static final String SERIALIZED_NAME_TRASHING_USER = "trashingUser";
  @SerializedName(SERIALIZED_NAME_TRASHING_USER)
  private User trashingUser;

  public static final String SERIALIZED_NAME_USER_PERMISSION = "userPermission";
  @SerializedName(SERIALIZED_NAME_USER_PERMISSION)
  private Permission userPermission;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_VIDEO_MEDIA_METADATA = "videoMediaMetadata";
  @SerializedName(SERIALIZED_NAME_VIDEO_MEDIA_METADATA)
  private FileVideoMediaMetadata videoMediaMetadata;

  public static final String SERIALIZED_NAME_WEB_CONTENT_LINK = "webContentLink";
  @SerializedName(SERIALIZED_NAME_WEB_CONTENT_LINK)
  private String webContentLink;

  public static final String SERIALIZED_NAME_WEB_VIEW_LINK = "webViewLink";
  @SerializedName(SERIALIZED_NAME_WEB_VIEW_LINK)
  private String webViewLink;

  public static final String SERIALIZED_NAME_WRITERS_CAN_SHARE = "writersCanShare";
  @SerializedName(SERIALIZED_NAME_WRITERS_CAN_SHARE)
  private Boolean writersCanShare;

  public ModelFile() {
  }

  public ModelFile(
     Map<String, String> exportLinks
  ) {
    this();
    this.exportLinks = exportLinks;
  }

  public ModelFile alternateLink(String alternateLink) {
    this.alternateLink = alternateLink;
    return this;
  }

  /**
   * Output only. A link for opening the file in a relevant Google editor or viewer.
   * @return alternateLink
   */
  @javax.annotation.Nullable
  public String getAlternateLink() {
    return alternateLink;
  }

  public void setAlternateLink(String alternateLink) {
    this.alternateLink = alternateLink;
  }


  public ModelFile appDataContents(Boolean appDataContents) {
    this.appDataContents = appDataContents;
    return this;
  }

  /**
   * Output only. Whether this file is in the Application Data folder.
   * @return appDataContents
   */
  @javax.annotation.Nullable
  public Boolean getAppDataContents() {
    return appDataContents;
  }

  public void setAppDataContents(Boolean appDataContents) {
    this.appDataContents = appDataContents;
  }


  @Deprecated
  public ModelFile canComment(Boolean canComment) {
    this.canComment = canComment;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;capabilities/canComment&#x60; instead.
   * @return canComment
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getCanComment() {
    return canComment;
  }

  @Deprecated
  public void setCanComment(Boolean canComment) {
    this.canComment = canComment;
  }


  @Deprecated
  public ModelFile canReadRevisions(Boolean canReadRevisions) {
    this.canReadRevisions = canReadRevisions;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;capabilities/canReadRevisions&#x60; instead.
   * @return canReadRevisions
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getCanReadRevisions() {
    return canReadRevisions;
  }

  @Deprecated
  public void setCanReadRevisions(Boolean canReadRevisions) {
    this.canReadRevisions = canReadRevisions;
  }


  public ModelFile capabilities(FileCapabilities capabilities) {
    this.capabilities = capabilities;
    return this;
  }

  /**
   * Get capabilities
   * @return capabilities
   */
  @javax.annotation.Nullable
  public FileCapabilities getCapabilities() {
    return capabilities;
  }

  public void setCapabilities(FileCapabilities capabilities) {
    this.capabilities = capabilities;
  }


  public ModelFile contentRestrictions(List<ContentRestriction> contentRestrictions) {
    this.contentRestrictions = contentRestrictions;
    return this;
  }

  public ModelFile addContentRestrictionsItem(ContentRestriction contentRestrictionsItem) {
    if (this.contentRestrictions == null) {
      this.contentRestrictions = new ArrayList<>();
    }
    this.contentRestrictions.add(contentRestrictionsItem);
    return this;
  }

  /**
   * Restrictions for accessing the content of the file. Only populated if such a restriction exists.
   * @return contentRestrictions
   */
  @javax.annotation.Nullable
  public List<ContentRestriction> getContentRestrictions() {
    return contentRestrictions;
  }

  public void setContentRestrictions(List<ContentRestriction> contentRestrictions) {
    this.contentRestrictions = contentRestrictions;
  }


  public ModelFile copyRequiresWriterPermission(Boolean copyRequiresWriterPermission) {
    this.copyRequiresWriterPermission = copyRequiresWriterPermission;
    return this;
  }

  /**
   * Whether the options to copy, print, or download this file, should be disabled for readers and commenters.
   * @return copyRequiresWriterPermission
   */
  @javax.annotation.Nullable
  public Boolean getCopyRequiresWriterPermission() {
    return copyRequiresWriterPermission;
  }

  public void setCopyRequiresWriterPermission(Boolean copyRequiresWriterPermission) {
    this.copyRequiresWriterPermission = copyRequiresWriterPermission;
  }


  @Deprecated
  public ModelFile copyable(Boolean copyable) {
    this.copyable = copyable;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;capabilities/canCopy&#x60; instead.
   * @return copyable
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getCopyable() {
    return copyable;
  }

  @Deprecated
  public void setCopyable(Boolean copyable) {
    this.copyable = copyable;
  }


  public ModelFile createdDate(OffsetDateTime createdDate) {
    this.createdDate = createdDate;
    return this;
  }

  /**
   * Create time for this file (formatted RFC 3339 timestamp).
   * @return createdDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(OffsetDateTime createdDate) {
    this.createdDate = createdDate;
  }


  public ModelFile defaultOpenWithLink(String defaultOpenWithLink) {
    this.defaultOpenWithLink = defaultOpenWithLink;
    return this;
  }

  /**
   * Output only. A link to open this file with the user&#39;s default app for this file. Only populated when the drive.apps.readonly scope is used.
   * @return defaultOpenWithLink
   */
  @javax.annotation.Nullable
  public String getDefaultOpenWithLink() {
    return defaultOpenWithLink;
  }

  public void setDefaultOpenWithLink(String defaultOpenWithLink) {
    this.defaultOpenWithLink = defaultOpenWithLink;
  }


  public ModelFile description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A short description of the file.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ModelFile downloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
    return this;
  }

  /**
   * Output only. Short lived download URL for the file. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files.
   * @return downloadUrl
   */
  @javax.annotation.Nullable
  public String getDownloadUrl() {
    return downloadUrl;
  }

  public void setDownloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
  }


  public ModelFile driveId(String driveId) {
    this.driveId = driveId;
    return this;
  }

  /**
   * Output only. ID of the shared drive the file resides in. Only populated for items in shared drives.
   * @return driveId
   */
  @javax.annotation.Nullable
  public String getDriveId() {
    return driveId;
  }

  public void setDriveId(String driveId) {
    this.driveId = driveId;
  }


  @Deprecated
  public ModelFile editable(Boolean editable) {
    this.editable = editable;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;capabilities/canEdit&#x60; instead.
   * @return editable
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getEditable() {
    return editable;
  }

  @Deprecated
  public void setEditable(Boolean editable) {
    this.editable = editable;
  }


  public ModelFile embedLink(String embedLink) {
    this.embedLink = embedLink;
    return this;
  }

  /**
   * Output only. A link for embedding the file.
   * @return embedLink
   */
  @javax.annotation.Nullable
  public String getEmbedLink() {
    return embedLink;
  }

  public void setEmbedLink(String embedLink) {
    this.embedLink = embedLink;
  }


  public ModelFile etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * Output only. ETag of the file.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public ModelFile explicitlyTrashed(Boolean explicitlyTrashed) {
    this.explicitlyTrashed = explicitlyTrashed;
    return this;
  }

  /**
   * Output only. Whether this file has been explicitly trashed, as opposed to recursively trashed.
   * @return explicitlyTrashed
   */
  @javax.annotation.Nullable
  public Boolean getExplicitlyTrashed() {
    return explicitlyTrashed;
  }

  public void setExplicitlyTrashed(Boolean explicitlyTrashed) {
    this.explicitlyTrashed = explicitlyTrashed;
  }


  /**
   * Output only. Links for exporting Docs Editors files to specific formats.
   * @return exportLinks
   */
  @javax.annotation.Nullable
  public Map<String, String> getExportLinks() {
    return exportLinks;
  }



  public ModelFile fileExtension(String fileExtension) {
    this.fileExtension = fileExtension;
    return this;
  }

  /**
   * Output only. The final component of &#x60;fullFileExtension&#x60; with trailing text that does not appear to be part of the extension removed. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return fileExtension
   */
  @javax.annotation.Nullable
  public String getFileExtension() {
    return fileExtension;
  }

  public void setFileExtension(String fileExtension) {
    this.fileExtension = fileExtension;
  }


  public ModelFile fileSize(String fileSize) {
    this.fileSize = fileSize;
    return this;
  }

  /**
   * Output only. Size in bytes of blobs and first party editor files. Won&#39;t be populated for files that have no size, like shortcuts and folders.
   * @return fileSize
   */
  @javax.annotation.Nullable
  public String getFileSize() {
    return fileSize;
  }

  public void setFileSize(String fileSize) {
    this.fileSize = fileSize;
  }


  public ModelFile folderColorRgb(String folderColorRgb) {
    this.folderColorRgb = folderColorRgb;
    return this;
  }

  /**
   * Folder color as an RGB hex string if the file is a folder or a shortcut to a folder. The list of supported colors is available in the folderColorPalette field of the About resource. If an unsupported color is specified, it will be changed to the closest color in the palette.
   * @return folderColorRgb
   */
  @javax.annotation.Nullable
  public String getFolderColorRgb() {
    return folderColorRgb;
  }

  public void setFolderColorRgb(String folderColorRgb) {
    this.folderColorRgb = folderColorRgb;
  }


  public ModelFile fullFileExtension(String fullFileExtension) {
    this.fullFileExtension = fullFileExtension;
    return this;
  }

  /**
   * Output only. The full file extension; extracted from the title. May contain multiple concatenated extensions, such as \&quot;tar.gz\&quot;. Removing an extension from the title does not clear this field; however, changing the extension on the title does update this field. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return fullFileExtension
   */
  @javax.annotation.Nullable
  public String getFullFileExtension() {
    return fullFileExtension;
  }

  public void setFullFileExtension(String fullFileExtension) {
    this.fullFileExtension = fullFileExtension;
  }


  public ModelFile hasAugmentedPermissions(Boolean hasAugmentedPermissions) {
    this.hasAugmentedPermissions = hasAugmentedPermissions;
    return this;
  }

  /**
   * Output only. Whether there are permissions directly on this file. This field is only populated for items in shared drives.
   * @return hasAugmentedPermissions
   */
  @javax.annotation.Nullable
  public Boolean getHasAugmentedPermissions() {
    return hasAugmentedPermissions;
  }

  public void setHasAugmentedPermissions(Boolean hasAugmentedPermissions) {
    this.hasAugmentedPermissions = hasAugmentedPermissions;
  }


  public ModelFile hasThumbnail(Boolean hasThumbnail) {
    this.hasThumbnail = hasThumbnail;
    return this;
  }

  /**
   * Output only. Whether this file has a thumbnail. This does not indicate whether the requesting app has access to the thumbnail. To check access, look for the presence of the thumbnailLink field.
   * @return hasThumbnail
   */
  @javax.annotation.Nullable
  public Boolean getHasThumbnail() {
    return hasThumbnail;
  }

  public void setHasThumbnail(Boolean hasThumbnail) {
    this.hasThumbnail = hasThumbnail;
  }


  public ModelFile headRevisionId(String headRevisionId) {
    this.headRevisionId = headRevisionId;
    return this;
  }

  /**
   * Output only. The ID of the file&#39;s head revision. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return headRevisionId
   */
  @javax.annotation.Nullable
  public String getHeadRevisionId() {
    return headRevisionId;
  }

  public void setHeadRevisionId(String headRevisionId) {
    this.headRevisionId = headRevisionId;
  }


  public ModelFile iconLink(String iconLink) {
    this.iconLink = iconLink;
    return this;
  }

  /**
   * Output only. A link to the file&#39;s icon.
   * @return iconLink
   */
  @javax.annotation.Nullable
  public String getIconLink() {
    return iconLink;
  }

  public void setIconLink(String iconLink) {
    this.iconLink = iconLink;
  }


  public ModelFile id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of the file.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ModelFile imageMediaMetadata(FileImageMediaMetadata imageMediaMetadata) {
    this.imageMediaMetadata = imageMediaMetadata;
    return this;
  }

  /**
   * Get imageMediaMetadata
   * @return imageMediaMetadata
   */
  @javax.annotation.Nullable
  public FileImageMediaMetadata getImageMediaMetadata() {
    return imageMediaMetadata;
  }

  public void setImageMediaMetadata(FileImageMediaMetadata imageMediaMetadata) {
    this.imageMediaMetadata = imageMediaMetadata;
  }


  public ModelFile indexableText(FileIndexableText indexableText) {
    this.indexableText = indexableText;
    return this;
  }

  /**
   * Get indexableText
   * @return indexableText
   */
  @javax.annotation.Nullable
  public FileIndexableText getIndexableText() {
    return indexableText;
  }

  public void setIndexableText(FileIndexableText indexableText) {
    this.indexableText = indexableText;
  }


  public ModelFile isAppAuthorized(Boolean isAppAuthorized) {
    this.isAppAuthorized = isAppAuthorized;
    return this;
  }

  /**
   * Output only. Whether the file was created or opened by the requesting app.
   * @return isAppAuthorized
   */
  @javax.annotation.Nullable
  public Boolean getIsAppAuthorized() {
    return isAppAuthorized;
  }

  public void setIsAppAuthorized(Boolean isAppAuthorized) {
    this.isAppAuthorized = isAppAuthorized;
  }


  public ModelFile kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Output only. The type of file. This is always &#x60;drive#file&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public ModelFile labelInfo(FileLabelInfo labelInfo) {
    this.labelInfo = labelInfo;
    return this;
  }

  /**
   * Get labelInfo
   * @return labelInfo
   */
  @javax.annotation.Nullable
  public FileLabelInfo getLabelInfo() {
    return labelInfo;
  }

  public void setLabelInfo(FileLabelInfo labelInfo) {
    this.labelInfo = labelInfo;
  }


  public ModelFile labels(FileLabels labels) {
    this.labels = labels;
    return this;
  }

  /**
   * Get labels
   * @return labels
   */
  @javax.annotation.Nullable
  public FileLabels getLabels() {
    return labels;
  }

  public void setLabels(FileLabels labels) {
    this.labels = labels;
  }


  public ModelFile lastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
    return this;
  }

  /**
   * Get lastModifyingUser
   * @return lastModifyingUser
   */
  @javax.annotation.Nullable
  public User getLastModifyingUser() {
    return lastModifyingUser;
  }

  public void setLastModifyingUser(User lastModifyingUser) {
    this.lastModifyingUser = lastModifyingUser;
  }


  public ModelFile lastModifyingUserName(String lastModifyingUserName) {
    this.lastModifyingUserName = lastModifyingUserName;
    return this;
  }

  /**
   * Output only. Name of the last user to modify this file.
   * @return lastModifyingUserName
   */
  @javax.annotation.Nullable
  public String getLastModifyingUserName() {
    return lastModifyingUserName;
  }

  public void setLastModifyingUserName(String lastModifyingUserName) {
    this.lastModifyingUserName = lastModifyingUserName;
  }


  public ModelFile lastViewedByMeDate(OffsetDateTime lastViewedByMeDate) {
    this.lastViewedByMeDate = lastViewedByMeDate;
    return this;
  }

  /**
   * Last time this file was viewed by the user (formatted RFC 3339 timestamp).
   * @return lastViewedByMeDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastViewedByMeDate() {
    return lastViewedByMeDate;
  }

  public void setLastViewedByMeDate(OffsetDateTime lastViewedByMeDate) {
    this.lastViewedByMeDate = lastViewedByMeDate;
  }


  public ModelFile linkShareMetadata(FileLinkShareMetadata linkShareMetadata) {
    this.linkShareMetadata = linkShareMetadata;
    return this;
  }

  /**
   * Get linkShareMetadata
   * @return linkShareMetadata
   */
  @javax.annotation.Nullable
  public FileLinkShareMetadata getLinkShareMetadata() {
    return linkShareMetadata;
  }

  public void setLinkShareMetadata(FileLinkShareMetadata linkShareMetadata) {
    this.linkShareMetadata = linkShareMetadata;
  }


  public ModelFile markedViewedByMeDate(OffsetDateTime markedViewedByMeDate) {
    this.markedViewedByMeDate = markedViewedByMeDate;
    return this;
  }

  /**
   * Deprecated.
   * @return markedViewedByMeDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getMarkedViewedByMeDate() {
    return markedViewedByMeDate;
  }

  public void setMarkedViewedByMeDate(OffsetDateTime markedViewedByMeDate) {
    this.markedViewedByMeDate = markedViewedByMeDate;
  }


  public ModelFile md5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
    return this;
  }

  /**
   * Output only. An MD5 checksum for the content of this file. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return md5Checksum
   */
  @javax.annotation.Nullable
  public String getMd5Checksum() {
    return md5Checksum;
  }

  public void setMd5Checksum(String md5Checksum) {
    this.md5Checksum = md5Checksum;
  }


  public ModelFile mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * The MIME type of the file. This is only mutable on update when uploading new content. This field can be left blank, and the mimetype will be determined from the uploaded content&#39;s MIME type.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public ModelFile modifiedByMeDate(OffsetDateTime modifiedByMeDate) {
    this.modifiedByMeDate = modifiedByMeDate;
    return this;
  }

  /**
   * Last time this file was modified by the user (formatted RFC 3339 timestamp). Note that setting modifiedDate will also update the modifiedByMe date for the user which set the date.
   * @return modifiedByMeDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedByMeDate() {
    return modifiedByMeDate;
  }

  public void setModifiedByMeDate(OffsetDateTime modifiedByMeDate) {
    this.modifiedByMeDate = modifiedByMeDate;
  }


  public ModelFile modifiedDate(OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
    return this;
  }

  /**
   * Last time this file was modified by anyone (formatted RFC 3339 timestamp). This is only mutable on update when the setModifiedDate parameter is set.
   * @return modifiedDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedDate() {
    return modifiedDate;
  }

  public void setModifiedDate(OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
  }


  public ModelFile openWithLinks(Map<String, String> openWithLinks) {
    this.openWithLinks = openWithLinks;
    return this;
  }

  public ModelFile putOpenWithLinksItem(String key, String openWithLinksItem) {
    if (this.openWithLinks == null) {
      this.openWithLinks = new HashMap<>();
    }
    this.openWithLinks.put(key, openWithLinksItem);
    return this;
  }

  /**
   * Output only. A map of the id of each of the user&#39;s apps to a link to open this file with that app. Only populated when the drive.apps.readonly scope is used.
   * @return openWithLinks
   */
  @javax.annotation.Nullable
  public Map<String, String> getOpenWithLinks() {
    return openWithLinks;
  }

  public void setOpenWithLinks(Map<String, String> openWithLinks) {
    this.openWithLinks = openWithLinks;
  }


  public ModelFile originalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
    return this;
  }

  /**
   * The original filename of the uploaded content if available, or else the original value of the &#x60;title&#x60; field. This is only available for files with binary content in Google Drive.
   * @return originalFilename
   */
  @javax.annotation.Nullable
  public String getOriginalFilename() {
    return originalFilename;
  }

  public void setOriginalFilename(String originalFilename) {
    this.originalFilename = originalFilename;
  }


  public ModelFile ownedByMe(Boolean ownedByMe) {
    this.ownedByMe = ownedByMe;
    return this;
  }

  /**
   * Output only. Whether the file is owned by the current user. Not populated for items in shared drives.
   * @return ownedByMe
   */
  @javax.annotation.Nullable
  public Boolean getOwnedByMe() {
    return ownedByMe;
  }

  public void setOwnedByMe(Boolean ownedByMe) {
    this.ownedByMe = ownedByMe;
  }


  public ModelFile ownerNames(List<String> ownerNames) {
    this.ownerNames = ownerNames;
    return this;
  }

  public ModelFile addOwnerNamesItem(String ownerNamesItem) {
    if (this.ownerNames == null) {
      this.ownerNames = new ArrayList<>();
    }
    this.ownerNames.add(ownerNamesItem);
    return this;
  }

  /**
   * Output only. Name(s) of the owner(s) of this file. Not populated for items in shared drives.
   * @return ownerNames
   */
  @javax.annotation.Nullable
  public List<String> getOwnerNames() {
    return ownerNames;
  }

  public void setOwnerNames(List<String> ownerNames) {
    this.ownerNames = ownerNames;
  }


  public ModelFile owners(List<User> owners) {
    this.owners = owners;
    return this;
  }

  public ModelFile addOwnersItem(User ownersItem) {
    if (this.owners == null) {
      this.owners = new ArrayList<>();
    }
    this.owners.add(ownersItem);
    return this;
  }

  /**
   * Output only. The owner of this file. Only certain legacy files may have more than one owner. This field isn&#39;t populated for items in shared drives.
   * @return owners
   */
  @javax.annotation.Nullable
  public List<User> getOwners() {
    return owners;
  }

  public void setOwners(List<User> owners) {
    this.owners = owners;
  }


  public ModelFile parents(List<ParentReference> parents) {
    this.parents = parents;
    return this;
  }

  public ModelFile addParentsItem(ParentReference parentsItem) {
    if (this.parents == null) {
      this.parents = new ArrayList<>();
    }
    this.parents.add(parentsItem);
    return this;
  }

  /**
   * Collection of parent folders which contain this file. If not specified as part of an insert request, the file will be placed directly in the user&#39;s My Drive folder. If not specified as part of a copy request, the file will inherit any discoverable parents of the source file. Update requests can also use the &#x60;addParents&#x60; and &#x60;removeParents&#x60; parameters to modify the parents list.
   * @return parents
   */
  @javax.annotation.Nullable
  public List<ParentReference> getParents() {
    return parents;
  }

  public void setParents(List<ParentReference> parents) {
    this.parents = parents;
  }


  public ModelFile permissionIds(List<String> permissionIds) {
    this.permissionIds = permissionIds;
    return this;
  }

  public ModelFile addPermissionIdsItem(String permissionIdsItem) {
    if (this.permissionIds == null) {
      this.permissionIds = new ArrayList<>();
    }
    this.permissionIds.add(permissionIdsItem);
    return this;
  }

  /**
   * Output only. List of permission IDs for users with access to this file.
   * @return permissionIds
   */
  @javax.annotation.Nullable
  public List<String> getPermissionIds() {
    return permissionIds;
  }

  public void setPermissionIds(List<String> permissionIds) {
    this.permissionIds = permissionIds;
  }


  public ModelFile permissions(List<Permission> permissions) {
    this.permissions = permissions;
    return this;
  }

  public ModelFile addPermissionsItem(Permission permissionsItem) {
    if (this.permissions == null) {
      this.permissions = new ArrayList<>();
    }
    this.permissions.add(permissionsItem);
    return this;
  }

  /**
   * Output only. The list of permissions for users with access to this file. Not populated for items in shared drives.
   * @return permissions
   */
  @javax.annotation.Nullable
  public List<Permission> getPermissions() {
    return permissions;
  }

  public void setPermissions(List<Permission> permissions) {
    this.permissions = permissions;
  }


  public ModelFile properties(List<Property> properties) {
    this.properties = properties;
    return this;
  }

  public ModelFile addPropertiesItem(Property propertiesItem) {
    if (this.properties == null) {
      this.properties = new ArrayList<>();
    }
    this.properties.add(propertiesItem);
    return this;
  }

  /**
   * The list of properties.
   * @return properties
   */
  @javax.annotation.Nullable
  public List<Property> getProperties() {
    return properties;
  }

  public void setProperties(List<Property> properties) {
    this.properties = properties;
  }


  public ModelFile quotaBytesUsed(String quotaBytesUsed) {
    this.quotaBytesUsed = quotaBytesUsed;
    return this;
  }

  /**
   * Output only. The number of quota bytes used by this file.
   * @return quotaBytesUsed
   */
  @javax.annotation.Nullable
  public String getQuotaBytesUsed() {
    return quotaBytesUsed;
  }

  public void setQuotaBytesUsed(String quotaBytesUsed) {
    this.quotaBytesUsed = quotaBytesUsed;
  }


  public ModelFile resourceKey(String resourceKey) {
    this.resourceKey = resourceKey;
    return this;
  }

  /**
   * Output only. A key needed to access the item via a shared link.
   * @return resourceKey
   */
  @javax.annotation.Nullable
  public String getResourceKey() {
    return resourceKey;
  }

  public void setResourceKey(String resourceKey) {
    this.resourceKey = resourceKey;
  }


  public ModelFile selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * Output only. A link back to this file.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }


  public ModelFile sha1Checksum(String sha1Checksum) {
    this.sha1Checksum = sha1Checksum;
    return this;
  }

  /**
   * Output only. The SHA1 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return sha1Checksum
   */
  @javax.annotation.Nullable
  public String getSha1Checksum() {
    return sha1Checksum;
  }

  public void setSha1Checksum(String sha1Checksum) {
    this.sha1Checksum = sha1Checksum;
  }


  public ModelFile sha256Checksum(String sha256Checksum) {
    this.sha256Checksum = sha256Checksum;
    return this;
  }

  /**
   * Output only. The SHA256 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
   * @return sha256Checksum
   */
  @javax.annotation.Nullable
  public String getSha256Checksum() {
    return sha256Checksum;
  }

  public void setSha256Checksum(String sha256Checksum) {
    this.sha256Checksum = sha256Checksum;
  }


  @Deprecated
  public ModelFile shareable(Boolean shareable) {
    this.shareable = shareable;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;capabilities/canShare&#x60; instead.
   * @return shareable
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getShareable() {
    return shareable;
  }

  @Deprecated
  public void setShareable(Boolean shareable) {
    this.shareable = shareable;
  }


  public ModelFile shared(Boolean shared) {
    this.shared = shared;
    return this;
  }

  /**
   * Output only. Whether the file has been shared. Not populated for items in shared drives.
   * @return shared
   */
  @javax.annotation.Nullable
  public Boolean getShared() {
    return shared;
  }

  public void setShared(Boolean shared) {
    this.shared = shared;
  }


  public ModelFile sharedWithMeDate(OffsetDateTime sharedWithMeDate) {
    this.sharedWithMeDate = sharedWithMeDate;
    return this;
  }

  /**
   * Time at which this file was shared with the user (formatted RFC 3339 timestamp).
   * @return sharedWithMeDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSharedWithMeDate() {
    return sharedWithMeDate;
  }

  public void setSharedWithMeDate(OffsetDateTime sharedWithMeDate) {
    this.sharedWithMeDate = sharedWithMeDate;
  }


  public ModelFile sharingUser(User sharingUser) {
    this.sharingUser = sharingUser;
    return this;
  }

  /**
   * Get sharingUser
   * @return sharingUser
   */
  @javax.annotation.Nullable
  public User getSharingUser() {
    return sharingUser;
  }

  public void setSharingUser(User sharingUser) {
    this.sharingUser = sharingUser;
  }


  public ModelFile shortcutDetails(FileShortcutDetails shortcutDetails) {
    this.shortcutDetails = shortcutDetails;
    return this;
  }

  /**
   * Get shortcutDetails
   * @return shortcutDetails
   */
  @javax.annotation.Nullable
  public FileShortcutDetails getShortcutDetails() {
    return shortcutDetails;
  }

  public void setShortcutDetails(FileShortcutDetails shortcutDetails) {
    this.shortcutDetails = shortcutDetails;
  }


  public ModelFile spaces(List<String> spaces) {
    this.spaces = spaces;
    return this;
  }

  public ModelFile addSpacesItem(String spacesItem) {
    if (this.spaces == null) {
      this.spaces = new ArrayList<>();
    }
    this.spaces.add(spacesItem);
    return this;
  }

  /**
   * Output only. The list of spaces which contain the file. Supported values are &#x60;drive&#x60;, &#x60;appDataFolder&#x60; and &#x60;photos&#x60;.
   * @return spaces
   */
  @javax.annotation.Nullable
  public List<String> getSpaces() {
    return spaces;
  }

  public void setSpaces(List<String> spaces) {
    this.spaces = spaces;
  }


  @Deprecated
  public ModelFile teamDriveId(String teamDriveId) {
    this.teamDriveId = teamDriveId;
    return this;
  }

  /**
   * Output only. Deprecated: Use &#x60;driveId&#x60; instead.
   * @return teamDriveId
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getTeamDriveId() {
    return teamDriveId;
  }

  @Deprecated
  public void setTeamDriveId(String teamDriveId) {
    this.teamDriveId = teamDriveId;
  }


  public ModelFile thumbnail(FileThumbnail thumbnail) {
    this.thumbnail = thumbnail;
    return this;
  }

  /**
   * Get thumbnail
   * @return thumbnail
   */
  @javax.annotation.Nullable
  public FileThumbnail getThumbnail() {
    return thumbnail;
  }

  public void setThumbnail(FileThumbnail thumbnail) {
    this.thumbnail = thumbnail;
  }


  public ModelFile thumbnailLink(String thumbnailLink) {
    this.thumbnailLink = thumbnailLink;
    return this;
  }

  /**
   * Output only. A short-lived link to the file&#39;s thumbnail, if available. Typically lasts on the order of hours. Only populated when the requesting app can access the file&#39;s content. If the file isn&#39;t shared publicly, the URL returned in &#x60;Files.thumbnailLink&#x60; must be fetched using a credentialed request.
   * @return thumbnailLink
   */
  @javax.annotation.Nullable
  public String getThumbnailLink() {
    return thumbnailLink;
  }

  public void setThumbnailLink(String thumbnailLink) {
    this.thumbnailLink = thumbnailLink;
  }


  public ModelFile thumbnailVersion(String thumbnailVersion) {
    this.thumbnailVersion = thumbnailVersion;
    return this;
  }

  /**
   * Output only. The thumbnail version for use in thumbnail cache invalidation.
   * @return thumbnailVersion
   */
  @javax.annotation.Nullable
  public String getThumbnailVersion() {
    return thumbnailVersion;
  }

  public void setThumbnailVersion(String thumbnailVersion) {
    this.thumbnailVersion = thumbnailVersion;
  }


  public ModelFile title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of this file. Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the title is constant.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public ModelFile trashedDate(OffsetDateTime trashedDate) {
    this.trashedDate = trashedDate;
    return this;
  }

  /**
   * The time that the item was trashed (formatted RFC 3339 timestamp). Only populated for items in shared drives.
   * @return trashedDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTrashedDate() {
    return trashedDate;
  }

  public void setTrashedDate(OffsetDateTime trashedDate) {
    this.trashedDate = trashedDate;
  }


  public ModelFile trashingUser(User trashingUser) {
    this.trashingUser = trashingUser;
    return this;
  }

  /**
   * Get trashingUser
   * @return trashingUser
   */
  @javax.annotation.Nullable
  public User getTrashingUser() {
    return trashingUser;
  }

  public void setTrashingUser(User trashingUser) {
    this.trashingUser = trashingUser;
  }


  public ModelFile userPermission(Permission userPermission) {
    this.userPermission = userPermission;
    return this;
  }

  /**
   * Get userPermission
   * @return userPermission
   */
  @javax.annotation.Nullable
  public Permission getUserPermission() {
    return userPermission;
  }

  public void setUserPermission(Permission userPermission) {
    this.userPermission = userPermission;
  }


  public ModelFile version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Output only. A monotonically increasing version number for the file. This reflects every change made to the file on the server, even those not visible to the requesting user.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public ModelFile videoMediaMetadata(FileVideoMediaMetadata videoMediaMetadata) {
    this.videoMediaMetadata = videoMediaMetadata;
    return this;
  }

  /**
   * Get videoMediaMetadata
   * @return videoMediaMetadata
   */
  @javax.annotation.Nullable
  public FileVideoMediaMetadata getVideoMediaMetadata() {
    return videoMediaMetadata;
  }

  public void setVideoMediaMetadata(FileVideoMediaMetadata videoMediaMetadata) {
    this.videoMediaMetadata = videoMediaMetadata;
  }


  public ModelFile webContentLink(String webContentLink) {
    this.webContentLink = webContentLink;
    return this;
  }

  /**
   * Output only. A link for downloading the content of the file in a browser using cookie based authentication. In cases where the content is shared publicly, the content can be downloaded without any credentials.
   * @return webContentLink
   */
  @javax.annotation.Nullable
  public String getWebContentLink() {
    return webContentLink;
  }

  public void setWebContentLink(String webContentLink) {
    this.webContentLink = webContentLink;
  }


  public ModelFile webViewLink(String webViewLink) {
    this.webViewLink = webViewLink;
    return this;
  }

  /**
   * Output only. A link only available on public folders for viewing their static web assets (HTML, CSS, JS, etc) via Google Drive&#39;s Website Hosting.
   * @return webViewLink
   */
  @javax.annotation.Nullable
  public String getWebViewLink() {
    return webViewLink;
  }

  public void setWebViewLink(String webViewLink) {
    this.webViewLink = webViewLink;
  }


  public ModelFile writersCanShare(Boolean writersCanShare) {
    this.writersCanShare = writersCanShare;
    return this;
  }

  /**
   * Whether writers can share the document with other users. Not populated for items in shared drives.
   * @return writersCanShare
   */
  @javax.annotation.Nullable
  public Boolean getWritersCanShare() {
    return writersCanShare;
  }

  public void setWritersCanShare(Boolean writersCanShare) {
    this.writersCanShare = writersCanShare;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelFile _file = (ModelFile) o;
    return Objects.equals(this.alternateLink, _file.alternateLink) &&
        Objects.equals(this.appDataContents, _file.appDataContents) &&
        Objects.equals(this.canComment, _file.canComment) &&
        Objects.equals(this.canReadRevisions, _file.canReadRevisions) &&
        Objects.equals(this.capabilities, _file.capabilities) &&
        Objects.equals(this.contentRestrictions, _file.contentRestrictions) &&
        Objects.equals(this.copyRequiresWriterPermission, _file.copyRequiresWriterPermission) &&
        Objects.equals(this.copyable, _file.copyable) &&
        Objects.equals(this.createdDate, _file.createdDate) &&
        Objects.equals(this.defaultOpenWithLink, _file.defaultOpenWithLink) &&
        Objects.equals(this.description, _file.description) &&
        Objects.equals(this.downloadUrl, _file.downloadUrl) &&
        Objects.equals(this.driveId, _file.driveId) &&
        Objects.equals(this.editable, _file.editable) &&
        Objects.equals(this.embedLink, _file.embedLink) &&
        Objects.equals(this.etag, _file.etag) &&
        Objects.equals(this.explicitlyTrashed, _file.explicitlyTrashed) &&
        Objects.equals(this.exportLinks, _file.exportLinks) &&
        Objects.equals(this.fileExtension, _file.fileExtension) &&
        Objects.equals(this.fileSize, _file.fileSize) &&
        Objects.equals(this.folderColorRgb, _file.folderColorRgb) &&
        Objects.equals(this.fullFileExtension, _file.fullFileExtension) &&
        Objects.equals(this.hasAugmentedPermissions, _file.hasAugmentedPermissions) &&
        Objects.equals(this.hasThumbnail, _file.hasThumbnail) &&
        Objects.equals(this.headRevisionId, _file.headRevisionId) &&
        Objects.equals(this.iconLink, _file.iconLink) &&
        Objects.equals(this.id, _file.id) &&
        Objects.equals(this.imageMediaMetadata, _file.imageMediaMetadata) &&
        Objects.equals(this.indexableText, _file.indexableText) &&
        Objects.equals(this.isAppAuthorized, _file.isAppAuthorized) &&
        Objects.equals(this.kind, _file.kind) &&
        Objects.equals(this.labelInfo, _file.labelInfo) &&
        Objects.equals(this.labels, _file.labels) &&
        Objects.equals(this.lastModifyingUser, _file.lastModifyingUser) &&
        Objects.equals(this.lastModifyingUserName, _file.lastModifyingUserName) &&
        Objects.equals(this.lastViewedByMeDate, _file.lastViewedByMeDate) &&
        Objects.equals(this.linkShareMetadata, _file.linkShareMetadata) &&
        Objects.equals(this.markedViewedByMeDate, _file.markedViewedByMeDate) &&
        Objects.equals(this.md5Checksum, _file.md5Checksum) &&
        Objects.equals(this.mimeType, _file.mimeType) &&
        Objects.equals(this.modifiedByMeDate, _file.modifiedByMeDate) &&
        Objects.equals(this.modifiedDate, _file.modifiedDate) &&
        Objects.equals(this.openWithLinks, _file.openWithLinks) &&
        Objects.equals(this.originalFilename, _file.originalFilename) &&
        Objects.equals(this.ownedByMe, _file.ownedByMe) &&
        Objects.equals(this.ownerNames, _file.ownerNames) &&
        Objects.equals(this.owners, _file.owners) &&
        Objects.equals(this.parents, _file.parents) &&
        Objects.equals(this.permissionIds, _file.permissionIds) &&
        Objects.equals(this.permissions, _file.permissions) &&
        Objects.equals(this.properties, _file.properties) &&
        Objects.equals(this.quotaBytesUsed, _file.quotaBytesUsed) &&
        Objects.equals(this.resourceKey, _file.resourceKey) &&
        Objects.equals(this.selfLink, _file.selfLink) &&
        Objects.equals(this.sha1Checksum, _file.sha1Checksum) &&
        Objects.equals(this.sha256Checksum, _file.sha256Checksum) &&
        Objects.equals(this.shareable, _file.shareable) &&
        Objects.equals(this.shared, _file.shared) &&
        Objects.equals(this.sharedWithMeDate, _file.sharedWithMeDate) &&
        Objects.equals(this.sharingUser, _file.sharingUser) &&
        Objects.equals(this.shortcutDetails, _file.shortcutDetails) &&
        Objects.equals(this.spaces, _file.spaces) &&
        Objects.equals(this.teamDriveId, _file.teamDriveId) &&
        Objects.equals(this.thumbnail, _file.thumbnail) &&
        Objects.equals(this.thumbnailLink, _file.thumbnailLink) &&
        Objects.equals(this.thumbnailVersion, _file.thumbnailVersion) &&
        Objects.equals(this.title, _file.title) &&
        Objects.equals(this.trashedDate, _file.trashedDate) &&
        Objects.equals(this.trashingUser, _file.trashingUser) &&
        Objects.equals(this.userPermission, _file.userPermission) &&
        Objects.equals(this.version, _file.version) &&
        Objects.equals(this.videoMediaMetadata, _file.videoMediaMetadata) &&
        Objects.equals(this.webContentLink, _file.webContentLink) &&
        Objects.equals(this.webViewLink, _file.webViewLink) &&
        Objects.equals(this.writersCanShare, _file.writersCanShare);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alternateLink, appDataContents, canComment, canReadRevisions, capabilities, contentRestrictions, copyRequiresWriterPermission, copyable, createdDate, defaultOpenWithLink, description, downloadUrl, driveId, editable, embedLink, etag, explicitlyTrashed, exportLinks, fileExtension, fileSize, folderColorRgb, fullFileExtension, hasAugmentedPermissions, hasThumbnail, headRevisionId, iconLink, id, imageMediaMetadata, indexableText, isAppAuthorized, kind, labelInfo, labels, lastModifyingUser, lastModifyingUserName, lastViewedByMeDate, linkShareMetadata, markedViewedByMeDate, md5Checksum, mimeType, modifiedByMeDate, modifiedDate, openWithLinks, originalFilename, ownedByMe, ownerNames, owners, parents, permissionIds, permissions, properties, quotaBytesUsed, resourceKey, selfLink, sha1Checksum, sha256Checksum, shareable, shared, sharedWithMeDate, sharingUser, shortcutDetails, spaces, teamDriveId, thumbnail, thumbnailLink, thumbnailVersion, title, trashedDate, trashingUser, userPermission, version, videoMediaMetadata, webContentLink, webViewLink, writersCanShare);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ModelFile {\n");
    sb.append("    alternateLink: ").append(toIndentedString(alternateLink)).append("\n");
    sb.append("    appDataContents: ").append(toIndentedString(appDataContents)).append("\n");
    sb.append("    canComment: ").append(toIndentedString(canComment)).append("\n");
    sb.append("    canReadRevisions: ").append(toIndentedString(canReadRevisions)).append("\n");
    sb.append("    capabilities: ").append(toIndentedString(capabilities)).append("\n");
    sb.append("    contentRestrictions: ").append(toIndentedString(contentRestrictions)).append("\n");
    sb.append("    copyRequiresWriterPermission: ").append(toIndentedString(copyRequiresWriterPermission)).append("\n");
    sb.append("    copyable: ").append(toIndentedString(copyable)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    defaultOpenWithLink: ").append(toIndentedString(defaultOpenWithLink)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    downloadUrl: ").append(toIndentedString(downloadUrl)).append("\n");
    sb.append("    driveId: ").append(toIndentedString(driveId)).append("\n");
    sb.append("    editable: ").append(toIndentedString(editable)).append("\n");
    sb.append("    embedLink: ").append(toIndentedString(embedLink)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    explicitlyTrashed: ").append(toIndentedString(explicitlyTrashed)).append("\n");
    sb.append("    exportLinks: ").append(toIndentedString(exportLinks)).append("\n");
    sb.append("    fileExtension: ").append(toIndentedString(fileExtension)).append("\n");
    sb.append("    fileSize: ").append(toIndentedString(fileSize)).append("\n");
    sb.append("    folderColorRgb: ").append(toIndentedString(folderColorRgb)).append("\n");
    sb.append("    fullFileExtension: ").append(toIndentedString(fullFileExtension)).append("\n");
    sb.append("    hasAugmentedPermissions: ").append(toIndentedString(hasAugmentedPermissions)).append("\n");
    sb.append("    hasThumbnail: ").append(toIndentedString(hasThumbnail)).append("\n");
    sb.append("    headRevisionId: ").append(toIndentedString(headRevisionId)).append("\n");
    sb.append("    iconLink: ").append(toIndentedString(iconLink)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    imageMediaMetadata: ").append(toIndentedString(imageMediaMetadata)).append("\n");
    sb.append("    indexableText: ").append(toIndentedString(indexableText)).append("\n");
    sb.append("    isAppAuthorized: ").append(toIndentedString(isAppAuthorized)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labelInfo: ").append(toIndentedString(labelInfo)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lastModifyingUser: ").append(toIndentedString(lastModifyingUser)).append("\n");
    sb.append("    lastModifyingUserName: ").append(toIndentedString(lastModifyingUserName)).append("\n");
    sb.append("    lastViewedByMeDate: ").append(toIndentedString(lastViewedByMeDate)).append("\n");
    sb.append("    linkShareMetadata: ").append(toIndentedString(linkShareMetadata)).append("\n");
    sb.append("    markedViewedByMeDate: ").append(toIndentedString(markedViewedByMeDate)).append("\n");
    sb.append("    md5Checksum: ").append(toIndentedString(md5Checksum)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    modifiedByMeDate: ").append(toIndentedString(modifiedByMeDate)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    openWithLinks: ").append(toIndentedString(openWithLinks)).append("\n");
    sb.append("    originalFilename: ").append(toIndentedString(originalFilename)).append("\n");
    sb.append("    ownedByMe: ").append(toIndentedString(ownedByMe)).append("\n");
    sb.append("    ownerNames: ").append(toIndentedString(ownerNames)).append("\n");
    sb.append("    owners: ").append(toIndentedString(owners)).append("\n");
    sb.append("    parents: ").append(toIndentedString(parents)).append("\n");
    sb.append("    permissionIds: ").append(toIndentedString(permissionIds)).append("\n");
    sb.append("    permissions: ").append(toIndentedString(permissions)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    quotaBytesUsed: ").append(toIndentedString(quotaBytesUsed)).append("\n");
    sb.append("    resourceKey: ").append(toIndentedString(resourceKey)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    sha1Checksum: ").append(toIndentedString(sha1Checksum)).append("\n");
    sb.append("    sha256Checksum: ").append(toIndentedString(sha256Checksum)).append("\n");
    sb.append("    shareable: ").append(toIndentedString(shareable)).append("\n");
    sb.append("    shared: ").append(toIndentedString(shared)).append("\n");
    sb.append("    sharedWithMeDate: ").append(toIndentedString(sharedWithMeDate)).append("\n");
    sb.append("    sharingUser: ").append(toIndentedString(sharingUser)).append("\n");
    sb.append("    shortcutDetails: ").append(toIndentedString(shortcutDetails)).append("\n");
    sb.append("    spaces: ").append(toIndentedString(spaces)).append("\n");
    sb.append("    teamDriveId: ").append(toIndentedString(teamDriveId)).append("\n");
    sb.append("    thumbnail: ").append(toIndentedString(thumbnail)).append("\n");
    sb.append("    thumbnailLink: ").append(toIndentedString(thumbnailLink)).append("\n");
    sb.append("    thumbnailVersion: ").append(toIndentedString(thumbnailVersion)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    trashedDate: ").append(toIndentedString(trashedDate)).append("\n");
    sb.append("    trashingUser: ").append(toIndentedString(trashingUser)).append("\n");
    sb.append("    userPermission: ").append(toIndentedString(userPermission)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    videoMediaMetadata: ").append(toIndentedString(videoMediaMetadata)).append("\n");
    sb.append("    webContentLink: ").append(toIndentedString(webContentLink)).append("\n");
    sb.append("    webViewLink: ").append(toIndentedString(webViewLink)).append("\n");
    sb.append("    writersCanShare: ").append(toIndentedString(writersCanShare)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alternateLink");
    openapiFields.add("appDataContents");
    openapiFields.add("canComment");
    openapiFields.add("canReadRevisions");
    openapiFields.add("capabilities");
    openapiFields.add("contentRestrictions");
    openapiFields.add("copyRequiresWriterPermission");
    openapiFields.add("copyable");
    openapiFields.add("createdDate");
    openapiFields.add("defaultOpenWithLink");
    openapiFields.add("description");
    openapiFields.add("downloadUrl");
    openapiFields.add("driveId");
    openapiFields.add("editable");
    openapiFields.add("embedLink");
    openapiFields.add("etag");
    openapiFields.add("explicitlyTrashed");
    openapiFields.add("exportLinks");
    openapiFields.add("fileExtension");
    openapiFields.add("fileSize");
    openapiFields.add("folderColorRgb");
    openapiFields.add("fullFileExtension");
    openapiFields.add("hasAugmentedPermissions");
    openapiFields.add("hasThumbnail");
    openapiFields.add("headRevisionId");
    openapiFields.add("iconLink");
    openapiFields.add("id");
    openapiFields.add("imageMediaMetadata");
    openapiFields.add("indexableText");
    openapiFields.add("isAppAuthorized");
    openapiFields.add("kind");
    openapiFields.add("labelInfo");
    openapiFields.add("labels");
    openapiFields.add("lastModifyingUser");
    openapiFields.add("lastModifyingUserName");
    openapiFields.add("lastViewedByMeDate");
    openapiFields.add("linkShareMetadata");
    openapiFields.add("markedViewedByMeDate");
    openapiFields.add("md5Checksum");
    openapiFields.add("mimeType");
    openapiFields.add("modifiedByMeDate");
    openapiFields.add("modifiedDate");
    openapiFields.add("openWithLinks");
    openapiFields.add("originalFilename");
    openapiFields.add("ownedByMe");
    openapiFields.add("ownerNames");
    openapiFields.add("owners");
    openapiFields.add("parents");
    openapiFields.add("permissionIds");
    openapiFields.add("permissions");
    openapiFields.add("properties");
    openapiFields.add("quotaBytesUsed");
    openapiFields.add("resourceKey");
    openapiFields.add("selfLink");
    openapiFields.add("sha1Checksum");
    openapiFields.add("sha256Checksum");
    openapiFields.add("shareable");
    openapiFields.add("shared");
    openapiFields.add("sharedWithMeDate");
    openapiFields.add("sharingUser");
    openapiFields.add("shortcutDetails");
    openapiFields.add("spaces");
    openapiFields.add("teamDriveId");
    openapiFields.add("thumbnail");
    openapiFields.add("thumbnailLink");
    openapiFields.add("thumbnailVersion");
    openapiFields.add("title");
    openapiFields.add("trashedDate");
    openapiFields.add("trashingUser");
    openapiFields.add("userPermission");
    openapiFields.add("version");
    openapiFields.add("videoMediaMetadata");
    openapiFields.add("webContentLink");
    openapiFields.add("webViewLink");
    openapiFields.add("writersCanShare");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ModelFile
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ModelFile.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ModelFile is not found in the empty JSON string", ModelFile.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ModelFile.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ModelFile` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alternateLink") != null && !jsonObj.get("alternateLink").isJsonNull()) && !jsonObj.get("alternateLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alternateLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alternateLink").toString()));
      }
      // validate the optional field `capabilities`
      if (jsonObj.get("capabilities") != null && !jsonObj.get("capabilities").isJsonNull()) {
        FileCapabilities.validateJsonElement(jsonObj.get("capabilities"));
      }
      if (jsonObj.get("contentRestrictions") != null && !jsonObj.get("contentRestrictions").isJsonNull()) {
        JsonArray jsonArraycontentRestrictions = jsonObj.getAsJsonArray("contentRestrictions");
        if (jsonArraycontentRestrictions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("contentRestrictions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `contentRestrictions` to be an array in the JSON string but got `%s`", jsonObj.get("contentRestrictions").toString()));
          }

          // validate the optional field `contentRestrictions` (array)
          for (int i = 0; i < jsonArraycontentRestrictions.size(); i++) {
            ContentRestriction.validateJsonElement(jsonArraycontentRestrictions.get(i));
          };
        }
      }
      if ((jsonObj.get("defaultOpenWithLink") != null && !jsonObj.get("defaultOpenWithLink").isJsonNull()) && !jsonObj.get("defaultOpenWithLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultOpenWithLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultOpenWithLink").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("downloadUrl") != null && !jsonObj.get("downloadUrl").isJsonNull()) && !jsonObj.get("downloadUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `downloadUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("downloadUrl").toString()));
      }
      if ((jsonObj.get("driveId") != null && !jsonObj.get("driveId").isJsonNull()) && !jsonObj.get("driveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `driveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("driveId").toString()));
      }
      if ((jsonObj.get("embedLink") != null && !jsonObj.get("embedLink").isJsonNull()) && !jsonObj.get("embedLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `embedLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("embedLink").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("fileExtension") != null && !jsonObj.get("fileExtension").isJsonNull()) && !jsonObj.get("fileExtension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileExtension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileExtension").toString()));
      }
      if ((jsonObj.get("fileSize") != null && !jsonObj.get("fileSize").isJsonNull()) && !jsonObj.get("fileSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileSize").toString()));
      }
      if ((jsonObj.get("folderColorRgb") != null && !jsonObj.get("folderColorRgb").isJsonNull()) && !jsonObj.get("folderColorRgb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `folderColorRgb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("folderColorRgb").toString()));
      }
      if ((jsonObj.get("fullFileExtension") != null && !jsonObj.get("fullFileExtension").isJsonNull()) && !jsonObj.get("fullFileExtension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fullFileExtension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fullFileExtension").toString()));
      }
      if ((jsonObj.get("headRevisionId") != null && !jsonObj.get("headRevisionId").isJsonNull()) && !jsonObj.get("headRevisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `headRevisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("headRevisionId").toString()));
      }
      if ((jsonObj.get("iconLink") != null && !jsonObj.get("iconLink").isJsonNull()) && !jsonObj.get("iconLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iconLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iconLink").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `imageMediaMetadata`
      if (jsonObj.get("imageMediaMetadata") != null && !jsonObj.get("imageMediaMetadata").isJsonNull()) {
        FileImageMediaMetadata.validateJsonElement(jsonObj.get("imageMediaMetadata"));
      }
      // validate the optional field `indexableText`
      if (jsonObj.get("indexableText") != null && !jsonObj.get("indexableText").isJsonNull()) {
        FileIndexableText.validateJsonElement(jsonObj.get("indexableText"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `labelInfo`
      if (jsonObj.get("labelInfo") != null && !jsonObj.get("labelInfo").isJsonNull()) {
        FileLabelInfo.validateJsonElement(jsonObj.get("labelInfo"));
      }
      // validate the optional field `labels`
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        FileLabels.validateJsonElement(jsonObj.get("labels"));
      }
      // validate the optional field `lastModifyingUser`
      if (jsonObj.get("lastModifyingUser") != null && !jsonObj.get("lastModifyingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("lastModifyingUser"));
      }
      if ((jsonObj.get("lastModifyingUserName") != null && !jsonObj.get("lastModifyingUserName").isJsonNull()) && !jsonObj.get("lastModifyingUserName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastModifyingUserName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastModifyingUserName").toString()));
      }
      // validate the optional field `linkShareMetadata`
      if (jsonObj.get("linkShareMetadata") != null && !jsonObj.get("linkShareMetadata").isJsonNull()) {
        FileLinkShareMetadata.validateJsonElement(jsonObj.get("linkShareMetadata"));
      }
      if ((jsonObj.get("md5Checksum") != null && !jsonObj.get("md5Checksum").isJsonNull()) && !jsonObj.get("md5Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `md5Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("md5Checksum").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("originalFilename") != null && !jsonObj.get("originalFilename").isJsonNull()) && !jsonObj.get("originalFilename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalFilename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalFilename").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ownerNames") != null && !jsonObj.get("ownerNames").isJsonNull() && !jsonObj.get("ownerNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ownerNames` to be an array in the JSON string but got `%s`", jsonObj.get("ownerNames").toString()));
      }
      if (jsonObj.get("owners") != null && !jsonObj.get("owners").isJsonNull()) {
        JsonArray jsonArrayowners = jsonObj.getAsJsonArray("owners");
        if (jsonArrayowners != null) {
          // ensure the json data is an array
          if (!jsonObj.get("owners").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `owners` to be an array in the JSON string but got `%s`", jsonObj.get("owners").toString()));
          }

          // validate the optional field `owners` (array)
          for (int i = 0; i < jsonArrayowners.size(); i++) {
            User.validateJsonElement(jsonArrayowners.get(i));
          };
        }
      }
      if (jsonObj.get("parents") != null && !jsonObj.get("parents").isJsonNull()) {
        JsonArray jsonArrayparents = jsonObj.getAsJsonArray("parents");
        if (jsonArrayparents != null) {
          // ensure the json data is an array
          if (!jsonObj.get("parents").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `parents` to be an array in the JSON string but got `%s`", jsonObj.get("parents").toString()));
          }

          // validate the optional field `parents` (array)
          for (int i = 0; i < jsonArrayparents.size(); i++) {
            ParentReference.validateJsonElement(jsonArrayparents.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permissionIds") != null && !jsonObj.get("permissionIds").isJsonNull() && !jsonObj.get("permissionIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permissionIds` to be an array in the JSON string but got `%s`", jsonObj.get("permissionIds").toString()));
      }
      if (jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) {
        JsonArray jsonArraypermissions = jsonObj.getAsJsonArray("permissions");
        if (jsonArraypermissions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("permissions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `permissions` to be an array in the JSON string but got `%s`", jsonObj.get("permissions").toString()));
          }

          // validate the optional field `permissions` (array)
          for (int i = 0; i < jsonArraypermissions.size(); i++) {
            Permission.validateJsonElement(jsonArraypermissions.get(i));
          };
        }
      }
      if (jsonObj.get("properties") != null && !jsonObj.get("properties").isJsonNull()) {
        JsonArray jsonArrayproperties = jsonObj.getAsJsonArray("properties");
        if (jsonArrayproperties != null) {
          // ensure the json data is an array
          if (!jsonObj.get("properties").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `properties` to be an array in the JSON string but got `%s`", jsonObj.get("properties").toString()));
          }

          // validate the optional field `properties` (array)
          for (int i = 0; i < jsonArrayproperties.size(); i++) {
            Property.validateJsonElement(jsonArrayproperties.get(i));
          };
        }
      }
      if ((jsonObj.get("quotaBytesUsed") != null && !jsonObj.get("quotaBytesUsed").isJsonNull()) && !jsonObj.get("quotaBytesUsed").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quotaBytesUsed` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quotaBytesUsed").toString()));
      }
      if ((jsonObj.get("resourceKey") != null && !jsonObj.get("resourceKey").isJsonNull()) && !jsonObj.get("resourceKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resourceKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resourceKey").toString()));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      if ((jsonObj.get("sha1Checksum") != null && !jsonObj.get("sha1Checksum").isJsonNull()) && !jsonObj.get("sha1Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sha1Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sha1Checksum").toString()));
      }
      if ((jsonObj.get("sha256Checksum") != null && !jsonObj.get("sha256Checksum").isJsonNull()) && !jsonObj.get("sha256Checksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sha256Checksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sha256Checksum").toString()));
      }
      // validate the optional field `sharingUser`
      if (jsonObj.get("sharingUser") != null && !jsonObj.get("sharingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("sharingUser"));
      }
      // validate the optional field `shortcutDetails`
      if (jsonObj.get("shortcutDetails") != null && !jsonObj.get("shortcutDetails").isJsonNull()) {
        FileShortcutDetails.validateJsonElement(jsonObj.get("shortcutDetails"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("spaces") != null && !jsonObj.get("spaces").isJsonNull() && !jsonObj.get("spaces").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `spaces` to be an array in the JSON string but got `%s`", jsonObj.get("spaces").toString()));
      }
      if ((jsonObj.get("teamDriveId") != null && !jsonObj.get("teamDriveId").isJsonNull()) && !jsonObj.get("teamDriveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `teamDriveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("teamDriveId").toString()));
      }
      // validate the optional field `thumbnail`
      if (jsonObj.get("thumbnail") != null && !jsonObj.get("thumbnail").isJsonNull()) {
        FileThumbnail.validateJsonElement(jsonObj.get("thumbnail"));
      }
      if ((jsonObj.get("thumbnailLink") != null && !jsonObj.get("thumbnailLink").isJsonNull()) && !jsonObj.get("thumbnailLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbnailLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbnailLink").toString()));
      }
      if ((jsonObj.get("thumbnailVersion") != null && !jsonObj.get("thumbnailVersion").isJsonNull()) && !jsonObj.get("thumbnailVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbnailVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbnailVersion").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      // validate the optional field `trashingUser`
      if (jsonObj.get("trashingUser") != null && !jsonObj.get("trashingUser").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("trashingUser"));
      }
      // validate the optional field `userPermission`
      if (jsonObj.get("userPermission") != null && !jsonObj.get("userPermission").isJsonNull()) {
        Permission.validateJsonElement(jsonObj.get("userPermission"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      // validate the optional field `videoMediaMetadata`
      if (jsonObj.get("videoMediaMetadata") != null && !jsonObj.get("videoMediaMetadata").isJsonNull()) {
        FileVideoMediaMetadata.validateJsonElement(jsonObj.get("videoMediaMetadata"));
      }
      if ((jsonObj.get("webContentLink") != null && !jsonObj.get("webContentLink").isJsonNull()) && !jsonObj.get("webContentLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webContentLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webContentLink").toString()));
      }
      if ((jsonObj.get("webViewLink") != null && !jsonObj.get("webViewLink").isJsonNull()) && !jsonObj.get("webViewLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webViewLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webViewLink").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ModelFile.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ModelFile' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ModelFile> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ModelFile.class));

       return (TypeAdapter<T>) new TypeAdapter<ModelFile>() {
           @Override
           public void write(JsonWriter out, ModelFile value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ModelFile read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ModelFile given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ModelFile
   * @throws IOException if the JSON string is invalid with respect to ModelFile
   */
  public static ModelFile fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ModelFile.class);
  }

  /**
   * Convert an instance of ModelFile to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

