/**
 * YouTube Analytics API
 * Retrieves your YouTube Analytics data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The ErrorProto model module.
 * @module model/ErrorProto
 * @version v2
 */
class ErrorProto {
    /**
     * Constructs a new <code>ErrorProto</code>.
     * Describes one specific error.
     * @alias module:model/ErrorProto
     */
    constructor() { 
        
        ErrorProto.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ErrorProto</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ErrorProto} obj Optional instance to populate.
     * @return {module:model/ErrorProto} The populated <code>ErrorProto</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ErrorProto();

            if (data.hasOwnProperty('argument')) {
                obj['argument'] = ApiClient.convertToType(data['argument'], ['String']);
            }
            if (data.hasOwnProperty('code')) {
                obj['code'] = ApiClient.convertToType(data['code'], 'String');
            }
            if (data.hasOwnProperty('debugInfo')) {
                obj['debugInfo'] = ApiClient.convertToType(data['debugInfo'], 'String');
            }
            if (data.hasOwnProperty('domain')) {
                obj['domain'] = ApiClient.convertToType(data['domain'], 'String');
            }
            if (data.hasOwnProperty('externalErrorMessage')) {
                obj['externalErrorMessage'] = ApiClient.convertToType(data['externalErrorMessage'], 'String');
            }
            if (data.hasOwnProperty('location')) {
                obj['location'] = ApiClient.convertToType(data['location'], 'String');
            }
            if (data.hasOwnProperty('locationType')) {
                obj['locationType'] = ApiClient.convertToType(data['locationType'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ErrorProto</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ErrorProto</code>.
     */
    static validateJSON(data) {
        // ensure the json data is an array
        if (!Array.isArray(data['argument'])) {
            throw new Error("Expected the field `argument` to be an array in the JSON data but got " + data['argument']);
        }
        // ensure the json data is a string
        if (data['code'] && !(typeof data['code'] === 'string' || data['code'] instanceof String)) {
            throw new Error("Expected the field `code` to be a primitive type in the JSON string but got " + data['code']);
        }
        // ensure the json data is a string
        if (data['debugInfo'] && !(typeof data['debugInfo'] === 'string' || data['debugInfo'] instanceof String)) {
            throw new Error("Expected the field `debugInfo` to be a primitive type in the JSON string but got " + data['debugInfo']);
        }
        // ensure the json data is a string
        if (data['domain'] && !(typeof data['domain'] === 'string' || data['domain'] instanceof String)) {
            throw new Error("Expected the field `domain` to be a primitive type in the JSON string but got " + data['domain']);
        }
        // ensure the json data is a string
        if (data['externalErrorMessage'] && !(typeof data['externalErrorMessage'] === 'string' || data['externalErrorMessage'] instanceof String)) {
            throw new Error("Expected the field `externalErrorMessage` to be a primitive type in the JSON string but got " + data['externalErrorMessage']);
        }
        // ensure the json data is a string
        if (data['location'] && !(typeof data['location'] === 'string' || data['location'] instanceof String)) {
            throw new Error("Expected the field `location` to be a primitive type in the JSON string but got " + data['location']);
        }
        // ensure the json data is a string
        if (data['locationType'] && !(typeof data['locationType'] === 'string' || data['locationType'] instanceof String)) {
            throw new Error("Expected the field `locationType` to be a primitive type in the JSON string but got " + data['locationType']);
        }

        return true;
    }


}



/**
 * Error arguments, to be used when building user-friendly error messages given the error domain and code. Different error codes require different arguments.
 * @member {Array.<String>} argument
 */
ErrorProto.prototype['argument'] = undefined;

/**
 * Error code in the error domain. This should correspond to a value of the enum type whose name is in domain. See the core error domain in error_domain.proto.
 * @member {String} code
 */
ErrorProto.prototype['code'] = undefined;

/**
 * Debugging information, which should not be shared externally.
 * @member {String} debugInfo
 */
ErrorProto.prototype['debugInfo'] = undefined;

/**
 * Error domain. RoSy services can define their own domain and error codes. This should normally be the name of an enum type, such as: gdata.CoreErrorDomain
 * @member {String} domain
 */
ErrorProto.prototype['domain'] = undefined;

/**
 * A short explanation for the error, which can be shared outside Google. Please set domain, code and arguments whenever possible instead of this error message so that external APIs can build safe error messages themselves. External messages built in a RoSy interface will most likely refer to information and concepts that are not available externally and should not be exposed. It is safer if external APIs can understand the errors and decide what the error message should look like.
 * @member {String} externalErrorMessage
 */
ErrorProto.prototype['externalErrorMessage'] = undefined;

/**
 * Location of the error, as specified by the location type. If location_type is PATH, this should be a path to a field that's relative to the request, using FieldPath notation (net/proto2/util/public/field_path.h). Examples: authenticated_user.gaia_id resource.address[2].country
 * @member {String} location
 */
ErrorProto.prototype['location'] = undefined;

/**
 * @member {module:model/ErrorProto.LocationTypeEnum} locationType
 */
ErrorProto.prototype['locationType'] = undefined;





/**
 * Allowed values for the <code>locationType</code> property.
 * @enum {String}
 * @readonly
 */
ErrorProto['LocationTypeEnum'] = {

    /**
     * value: "PATH"
     * @const
     */
    "PATH": "PATH",

    /**
     * value: "OTHER"
     * @const
     */
    "OTHER": "OTHER",

    /**
     * value: "PARAMETER"
     * @const
     */
    "PARAMETER": "PARAMETER"
};



export default ErrorProto;

