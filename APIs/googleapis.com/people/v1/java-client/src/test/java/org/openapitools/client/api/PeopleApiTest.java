/*
 * People API
 * Provides access to information about profiles and contacts.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.BatchCreateContactsRequest;
import org.openapitools.client.model.BatchCreateContactsResponse;
import org.openapitools.client.model.BatchDeleteContactsRequest;
import org.openapitools.client.model.BatchUpdateContactsRequest;
import org.openapitools.client.model.BatchUpdateContactsResponse;
import org.openapitools.client.model.DeleteContactPhotoResponse;
import org.openapitools.client.model.GetPeopleResponse;
import org.openapitools.client.model.ListConnectionsResponse;
import org.openapitools.client.model.ListDirectoryPeopleResponse;
import org.openapitools.client.model.Person;
import org.openapitools.client.model.SearchDirectoryPeopleResponse;
import org.openapitools.client.model.SearchResponse;
import org.openapitools.client.model.UpdateContactPhotoRequest;
import org.openapitools.client.model.UpdateContactPhotoResponse;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for PeopleApi
 */
@Disabled
public class PeopleApiTest {

    private final PeopleApi api = new PeopleApi();

    /**
     * Create a batch of new contacts and return the PersonResponses for the newly Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleBatchCreateContactsTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        BatchCreateContactsRequest batchCreateContactsRequest = null;
        BatchCreateContactsResponse response = api.peoplePeopleBatchCreateContacts($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, batchCreateContactsRequest);
        // TODO: test validations
    }

    /**
     * Delete a batch of contacts. Any non-contact data will not be deleted. Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleBatchDeleteContactsTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        BatchDeleteContactsRequest batchDeleteContactsRequest = null;
        Object response = api.peoplePeopleBatchDeleteContacts($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, batchDeleteContactsRequest);
        // TODO: test validations
    }

    /**
     * Update a batch of contacts and return a map of resource names to PersonResponses for the updated contacts. Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleBatchUpdateContactsTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        BatchUpdateContactsRequest batchUpdateContactsRequest = null;
        BatchUpdateContactsResponse response = api.peoplePeopleBatchUpdateContacts($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, batchUpdateContactsRequest);
        // TODO: test validations
    }

    /**
     * Provides a list of the authenticated user&#39;s contacts. Sync tokens expire 7 days after the full sync. A request with an expired sync token will get an error with an [google.rpc.ErrorInfo](https://cloud.google.com/apis/design/errors#error_info) with reason \&quot;EXPIRED_SYNC_TOKEN\&quot;. In the case of such an error clients should make a full sync request without a &#x60;sync_token&#x60;. The first page of a full sync request has an additional quota. If the quota is exceeded, a 429 error will be returned. This quota is fixed and can not be increased. When the &#x60;sync_token&#x60; is specified, resources deleted since the last sync will be returned as a person with &#x60;PersonMetadata.deleted&#x60; set to true. When the &#x60;page_token&#x60; or &#x60;sync_token&#x60; is specified, all other request parameters must match the first call. Writes may have a propagation delay of several minutes for sync requests. Incremental syncs are not intended for read-after-write use cases. See example usage at [List the user&#39;s contacts that have changed](/people/v1/contacts#list_the_users_contacts_that_have_changed).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleConnectionsListTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        Integer pageSize = null;
        String pageToken = null;
        String personFields = null;
        String requestMaskIncludeField = null;
        Boolean requestSyncToken = null;
        String sortOrder = null;
        List<String> sources = null;
        String syncToken = null;
        ListConnectionsResponse response = api.peoplePeopleConnectionsList(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, pageSize, pageToken, personFields, requestMaskIncludeField, requestSyncToken, sortOrder, sources, syncToken);
        // TODO: test validations
    }

    /**
     * Create a new contact and return the person resource for that contact. The request returns a 400 error if more than one field is specified on a field that is a singleton for contact sources: * biographies * birthdays * genders * names Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleCreateContactTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        String personFields = null;
        List<String> sources = null;
        Person person = null;
        Person response = api.peoplePeopleCreateContact($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, personFields, sources, person);
        // TODO: test validations
    }

    /**
     * Delete a contact person. Any non-contact data will not be deleted. Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleDeleteContactTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        Object response = api.peoplePeopleDeleteContact(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType);
        // TODO: test validations
    }

    /**
     * Delete a contact&#39;s photo. Mutate requests for the same user should be done sequentially to avoid // lock contention.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleDeleteContactPhotoTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        String personFields = null;
        List<String> sources = null;
        DeleteContactPhotoResponse response = api.peoplePeopleDeleteContactPhoto(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, personFields, sources);
        // TODO: test validations
    }

    /**
     * Provides information about a person by specifying a resource name. Use &#x60;people/me&#x60; to indicate the authenticated user. The request returns a 400 error if &#39;personFields&#39; is not specified.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleGetTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        String personFields = null;
        String requestMaskIncludeField = null;
        List<String> sources = null;
        Person response = api.peoplePeopleGet(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, personFields, requestMaskIncludeField, sources);
        // TODO: test validations
    }

    /**
     * Provides information about a list of specific people by specifying a list of requested resource names. Use &#x60;people/me&#x60; to indicate the authenticated user. The request returns a 400 error if &#39;personFields&#39; is not specified.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleGetBatchGetTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        String personFields = null;
        String requestMaskIncludeField = null;
        List<String> resourceNames = null;
        List<String> sources = null;
        GetPeopleResponse response = api.peoplePeopleGetBatchGet($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, personFields, requestMaskIncludeField, resourceNames, sources);
        // TODO: test validations
    }

    /**
     * Provides a list of domain profiles and domain contacts in the authenticated user&#39;s domain directory. When the &#x60;sync_token&#x60; is specified, resources deleted since the last sync will be returned as a person with &#x60;PersonMetadata.deleted&#x60; set to true. When the &#x60;page_token&#x60; or &#x60;sync_token&#x60; is specified, all other request parameters must match the first call. Writes may have a propagation delay of several minutes for sync requests. Incremental syncs are not intended for read-after-write use cases. See example usage at [List the directory people that have changed](/people/v1/directory#list_the_directory_people_that_have_changed).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleListDirectoryPeopleTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        List<String> mergeSources = null;
        Integer pageSize = null;
        String pageToken = null;
        String readMask = null;
        Boolean requestSyncToken = null;
        List<String> sources = null;
        String syncToken = null;
        ListDirectoryPeopleResponse response = api.peoplePeopleListDirectoryPeople($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, mergeSources, pageSize, pageToken, readMask, requestSyncToken, sources, syncToken);
        // TODO: test validations
    }

    /**
     * Provides a list of contacts in the authenticated user&#39;s grouped contacts that matches the search query. The query matches on a contact&#39;s &#x60;names&#x60;, &#x60;nickNames&#x60;, &#x60;emailAddresses&#x60;, &#x60;phoneNumbers&#x60;, and &#x60;organizations&#x60; fields that are from the CONTACT source. **IMPORTANT**: Before searching, clients should send a warmup request with an empty query to update the cache. See https://developers.google.com/people/v1/contacts#search_the_users_contacts
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleSearchContactsTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        Integer pageSize = null;
        String query = null;
        String readMask = null;
        List<String> sources = null;
        SearchResponse response = api.peoplePeopleSearchContacts($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, pageSize, query, readMask, sources);
        // TODO: test validations
    }

    /**
     * Provides a list of domain profiles and domain contacts in the authenticated user&#39;s domain directory that match the search query.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleSearchDirectoryPeopleTest() throws ApiException {
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        List<String> mergeSources = null;
        Integer pageSize = null;
        String pageToken = null;
        String query = null;
        String readMask = null;
        List<String> sources = null;
        SearchDirectoryPeopleResponse response = api.peoplePeopleSearchDirectoryPeople($xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, mergeSources, pageSize, pageToken, query, readMask, sources);
        // TODO: test validations
    }

    /**
     * Update contact data for an existing contact person. Any non-contact data will not be modified. Any non-contact data in the person to update will be ignored. All fields specified in the &#x60;update_mask&#x60; will be replaced. The server returns a 400 error if &#x60;person.metadata.sources&#x60; is not specified for the contact to be updated or if there is no contact source. The server returns a 400 error with reason &#x60;\&quot;failedPrecondition\&quot;&#x60; if &#x60;person.metadata.sources.etag&#x60; is different than the contact&#39;s etag, which indicates the contact has changed since its data was read. Clients should get the latest person and merge their updates into the latest person. The server returns a 400 error if &#x60;memberships&#x60; are being updated and there are no contact group memberships specified on the person. The server returns a 400 error if more than one field is specified on a field that is a singleton for contact sources: * biographies * birthdays * genders * names Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleUpdateContactTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        String personFields = null;
        List<String> sources = null;
        String updatePersonFields = null;
        Person person = null;
        Person response = api.peoplePeopleUpdateContact(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, personFields, sources, updatePersonFields, person);
        // TODO: test validations
    }

    /**
     * Update a contact&#39;s photo. Mutate requests for the same user should be sent sequentially to avoid increased latency and failures.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void peoplePeopleUpdateContactPhotoTest() throws ApiException {
        String resourceName = null;
        String $xgafv = null;
        String accessToken = null;
        String alt = null;
        String paramCallback = null;
        String fields = null;
        String key = null;
        String oauthToken = null;
        Boolean prettyPrint = null;
        String quotaUser = null;
        String uploadProtocol = null;
        String uploadType = null;
        UpdateContactPhotoRequest updateContactPhotoRequest = null;
        UpdateContactPhotoResponse response = api.peoplePeopleUpdateContactPhoto(resourceName, $xgafv, accessToken, alt, paramCallback, fields, key, oauthToken, prettyPrint, quotaUser, uploadProtocol, uploadType, updateContactPhotoRequest);
        // TODO: test validations
    }

}
