/**
 * Cloud Memorystore for Memcached API
 * Google Cloud Memorystore for Memcached API is used for creating and managing Memcached instances in GCP.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIInstance.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIInstance::OAIInstance(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIInstance::OAIInstance() {
    this->initializeModel();
}

OAIInstance::~OAIInstance() {}

void OAIInstance::initializeModel() {

    m_authorized_network_isSet = false;
    m_authorized_network_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_discovery_endpoint_isSet = false;
    m_discovery_endpoint_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_instance_messages_isSet = false;
    m_instance_messages_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_maintenance_policy_isSet = false;
    m_maintenance_policy_isValid = false;

    m_maintenance_schedule_isSet = false;
    m_maintenance_schedule_isValid = false;

    m_memcache_full_version_isSet = false;
    m_memcache_full_version_isValid = false;

    m_memcache_nodes_isSet = false;
    m_memcache_nodes_isValid = false;

    m_memcache_version_isSet = false;
    m_memcache_version_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_node_config_isSet = false;
    m_node_config_isValid = false;

    m_node_count_isSet = false;
    m_node_count_isValid = false;

    m_parameters_isSet = false;
    m_parameters_isValid = false;

    m_reserved_ip_range_id_isSet = false;
    m_reserved_ip_range_id_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_update_time_isSet = false;
    m_update_time_isValid = false;

    m_zones_isSet = false;
    m_zones_isValid = false;
}

void OAIInstance::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIInstance::fromJsonObject(QJsonObject json) {

    m_authorized_network_isValid = ::OpenAPI::fromJsonValue(m_authorized_network, json[QString("authorizedNetwork")]);
    m_authorized_network_isSet = !json[QString("authorizedNetwork")].isNull() && m_authorized_network_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_discovery_endpoint_isValid = ::OpenAPI::fromJsonValue(m_discovery_endpoint, json[QString("discoveryEndpoint")]);
    m_discovery_endpoint_isSet = !json[QString("discoveryEndpoint")].isNull() && m_discovery_endpoint_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_instance_messages_isValid = ::OpenAPI::fromJsonValue(m_instance_messages, json[QString("instanceMessages")]);
    m_instance_messages_isSet = !json[QString("instanceMessages")].isNull() && m_instance_messages_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_maintenance_policy_isValid = ::OpenAPI::fromJsonValue(m_maintenance_policy, json[QString("maintenancePolicy")]);
    m_maintenance_policy_isSet = !json[QString("maintenancePolicy")].isNull() && m_maintenance_policy_isValid;

    m_maintenance_schedule_isValid = ::OpenAPI::fromJsonValue(m_maintenance_schedule, json[QString("maintenanceSchedule")]);
    m_maintenance_schedule_isSet = !json[QString("maintenanceSchedule")].isNull() && m_maintenance_schedule_isValid;

    m_memcache_full_version_isValid = ::OpenAPI::fromJsonValue(m_memcache_full_version, json[QString("memcacheFullVersion")]);
    m_memcache_full_version_isSet = !json[QString("memcacheFullVersion")].isNull() && m_memcache_full_version_isValid;

    m_memcache_nodes_isValid = ::OpenAPI::fromJsonValue(m_memcache_nodes, json[QString("memcacheNodes")]);
    m_memcache_nodes_isSet = !json[QString("memcacheNodes")].isNull() && m_memcache_nodes_isValid;

    m_memcache_version_isValid = ::OpenAPI::fromJsonValue(m_memcache_version, json[QString("memcacheVersion")]);
    m_memcache_version_isSet = !json[QString("memcacheVersion")].isNull() && m_memcache_version_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_node_config_isValid = ::OpenAPI::fromJsonValue(m_node_config, json[QString("nodeConfig")]);
    m_node_config_isSet = !json[QString("nodeConfig")].isNull() && m_node_config_isValid;

    m_node_count_isValid = ::OpenAPI::fromJsonValue(m_node_count, json[QString("nodeCount")]);
    m_node_count_isSet = !json[QString("nodeCount")].isNull() && m_node_count_isValid;

    m_parameters_isValid = ::OpenAPI::fromJsonValue(m_parameters, json[QString("parameters")]);
    m_parameters_isSet = !json[QString("parameters")].isNull() && m_parameters_isValid;

    m_reserved_ip_range_id_isValid = ::OpenAPI::fromJsonValue(m_reserved_ip_range_id, json[QString("reservedIpRangeId")]);
    m_reserved_ip_range_id_isSet = !json[QString("reservedIpRangeId")].isNull() && m_reserved_ip_range_id_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_update_time_isValid = ::OpenAPI::fromJsonValue(m_update_time, json[QString("updateTime")]);
    m_update_time_isSet = !json[QString("updateTime")].isNull() && m_update_time_isValid;

    m_zones_isValid = ::OpenAPI::fromJsonValue(m_zones, json[QString("zones")]);
    m_zones_isSet = !json[QString("zones")].isNull() && m_zones_isValid;
}

QString OAIInstance::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIInstance::asJsonObject() const {
    QJsonObject obj;
    if (m_authorized_network_isSet) {
        obj.insert(QString("authorizedNetwork"), ::OpenAPI::toJsonValue(m_authorized_network));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_discovery_endpoint_isSet) {
        obj.insert(QString("discoveryEndpoint"), ::OpenAPI::toJsonValue(m_discovery_endpoint));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_instance_messages.size() > 0) {
        obj.insert(QString("instanceMessages"), ::OpenAPI::toJsonValue(m_instance_messages));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_maintenance_policy.isSet()) {
        obj.insert(QString("maintenancePolicy"), ::OpenAPI::toJsonValue(m_maintenance_policy));
    }
    if (m_maintenance_schedule.isSet()) {
        obj.insert(QString("maintenanceSchedule"), ::OpenAPI::toJsonValue(m_maintenance_schedule));
    }
    if (m_memcache_full_version_isSet) {
        obj.insert(QString("memcacheFullVersion"), ::OpenAPI::toJsonValue(m_memcache_full_version));
    }
    if (m_memcache_nodes.size() > 0) {
        obj.insert(QString("memcacheNodes"), ::OpenAPI::toJsonValue(m_memcache_nodes));
    }
    if (m_memcache_version_isSet) {
        obj.insert(QString("memcacheVersion"), ::OpenAPI::toJsonValue(m_memcache_version));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_node_config.isSet()) {
        obj.insert(QString("nodeConfig"), ::OpenAPI::toJsonValue(m_node_config));
    }
    if (m_node_count_isSet) {
        obj.insert(QString("nodeCount"), ::OpenAPI::toJsonValue(m_node_count));
    }
    if (m_parameters.isSet()) {
        obj.insert(QString("parameters"), ::OpenAPI::toJsonValue(m_parameters));
    }
    if (m_reserved_ip_range_id.size() > 0) {
        obj.insert(QString("reservedIpRangeId"), ::OpenAPI::toJsonValue(m_reserved_ip_range_id));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_update_time_isSet) {
        obj.insert(QString("updateTime"), ::OpenAPI::toJsonValue(m_update_time));
    }
    if (m_zones.size() > 0) {
        obj.insert(QString("zones"), ::OpenAPI::toJsonValue(m_zones));
    }
    return obj;
}

QString OAIInstance::getAuthorizedNetwork() const {
    return m_authorized_network;
}
void OAIInstance::setAuthorizedNetwork(const QString &authorized_network) {
    m_authorized_network = authorized_network;
    m_authorized_network_isSet = true;
}

bool OAIInstance::is_authorized_network_Set() const{
    return m_authorized_network_isSet;
}

bool OAIInstance::is_authorized_network_Valid() const{
    return m_authorized_network_isValid;
}

QString OAIInstance::getCreateTime() const {
    return m_create_time;
}
void OAIInstance::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAIInstance::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAIInstance::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QString OAIInstance::getDiscoveryEndpoint() const {
    return m_discovery_endpoint;
}
void OAIInstance::setDiscoveryEndpoint(const QString &discovery_endpoint) {
    m_discovery_endpoint = discovery_endpoint;
    m_discovery_endpoint_isSet = true;
}

bool OAIInstance::is_discovery_endpoint_Set() const{
    return m_discovery_endpoint_isSet;
}

bool OAIInstance::is_discovery_endpoint_Valid() const{
    return m_discovery_endpoint_isValid;
}

QString OAIInstance::getDisplayName() const {
    return m_display_name;
}
void OAIInstance::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIInstance::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIInstance::is_display_name_Valid() const{
    return m_display_name_isValid;
}

QList<OAIInstanceMessage> OAIInstance::getInstanceMessages() const {
    return m_instance_messages;
}
void OAIInstance::setInstanceMessages(const QList<OAIInstanceMessage> &instance_messages) {
    m_instance_messages = instance_messages;
    m_instance_messages_isSet = true;
}

bool OAIInstance::is_instance_messages_Set() const{
    return m_instance_messages_isSet;
}

bool OAIInstance::is_instance_messages_Valid() const{
    return m_instance_messages_isValid;
}

QMap<QString, QString> OAIInstance::getLabels() const {
    return m_labels;
}
void OAIInstance::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIInstance::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIInstance::is_labels_Valid() const{
    return m_labels_isValid;
}

OAIGoogleCloudMemcacheV1MaintenancePolicy OAIInstance::getMaintenancePolicy() const {
    return m_maintenance_policy;
}
void OAIInstance::setMaintenancePolicy(const OAIGoogleCloudMemcacheV1MaintenancePolicy &maintenance_policy) {
    m_maintenance_policy = maintenance_policy;
    m_maintenance_policy_isSet = true;
}

bool OAIInstance::is_maintenance_policy_Set() const{
    return m_maintenance_policy_isSet;
}

bool OAIInstance::is_maintenance_policy_Valid() const{
    return m_maintenance_policy_isValid;
}

OAIMaintenanceSchedule OAIInstance::getMaintenanceSchedule() const {
    return m_maintenance_schedule;
}
void OAIInstance::setMaintenanceSchedule(const OAIMaintenanceSchedule &maintenance_schedule) {
    m_maintenance_schedule = maintenance_schedule;
    m_maintenance_schedule_isSet = true;
}

bool OAIInstance::is_maintenance_schedule_Set() const{
    return m_maintenance_schedule_isSet;
}

bool OAIInstance::is_maintenance_schedule_Valid() const{
    return m_maintenance_schedule_isValid;
}

QString OAIInstance::getMemcacheFullVersion() const {
    return m_memcache_full_version;
}
void OAIInstance::setMemcacheFullVersion(const QString &memcache_full_version) {
    m_memcache_full_version = memcache_full_version;
    m_memcache_full_version_isSet = true;
}

bool OAIInstance::is_memcache_full_version_Set() const{
    return m_memcache_full_version_isSet;
}

bool OAIInstance::is_memcache_full_version_Valid() const{
    return m_memcache_full_version_isValid;
}

QList<OAINode> OAIInstance::getMemcacheNodes() const {
    return m_memcache_nodes;
}
void OAIInstance::setMemcacheNodes(const QList<OAINode> &memcache_nodes) {
    m_memcache_nodes = memcache_nodes;
    m_memcache_nodes_isSet = true;
}

bool OAIInstance::is_memcache_nodes_Set() const{
    return m_memcache_nodes_isSet;
}

bool OAIInstance::is_memcache_nodes_Valid() const{
    return m_memcache_nodes_isValid;
}

QString OAIInstance::getMemcacheVersion() const {
    return m_memcache_version;
}
void OAIInstance::setMemcacheVersion(const QString &memcache_version) {
    m_memcache_version = memcache_version;
    m_memcache_version_isSet = true;
}

bool OAIInstance::is_memcache_version_Set() const{
    return m_memcache_version_isSet;
}

bool OAIInstance::is_memcache_version_Valid() const{
    return m_memcache_version_isValid;
}

QString OAIInstance::getName() const {
    return m_name;
}
void OAIInstance::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIInstance::is_name_Set() const{
    return m_name_isSet;
}

bool OAIInstance::is_name_Valid() const{
    return m_name_isValid;
}

OAINodeConfig OAIInstance::getNodeConfig() const {
    return m_node_config;
}
void OAIInstance::setNodeConfig(const OAINodeConfig &node_config) {
    m_node_config = node_config;
    m_node_config_isSet = true;
}

bool OAIInstance::is_node_config_Set() const{
    return m_node_config_isSet;
}

bool OAIInstance::is_node_config_Valid() const{
    return m_node_config_isValid;
}

qint32 OAIInstance::getNodeCount() const {
    return m_node_count;
}
void OAIInstance::setNodeCount(const qint32 &node_count) {
    m_node_count = node_count;
    m_node_count_isSet = true;
}

bool OAIInstance::is_node_count_Set() const{
    return m_node_count_isSet;
}

bool OAIInstance::is_node_count_Valid() const{
    return m_node_count_isValid;
}

OAIMemcacheParameters OAIInstance::getParameters() const {
    return m_parameters;
}
void OAIInstance::setParameters(const OAIMemcacheParameters &parameters) {
    m_parameters = parameters;
    m_parameters_isSet = true;
}

bool OAIInstance::is_parameters_Set() const{
    return m_parameters_isSet;
}

bool OAIInstance::is_parameters_Valid() const{
    return m_parameters_isValid;
}

QList<QString> OAIInstance::getReservedIpRangeId() const {
    return m_reserved_ip_range_id;
}
void OAIInstance::setReservedIpRangeId(const QList<QString> &reserved_ip_range_id) {
    m_reserved_ip_range_id = reserved_ip_range_id;
    m_reserved_ip_range_id_isSet = true;
}

bool OAIInstance::is_reserved_ip_range_id_Set() const{
    return m_reserved_ip_range_id_isSet;
}

bool OAIInstance::is_reserved_ip_range_id_Valid() const{
    return m_reserved_ip_range_id_isValid;
}

QString OAIInstance::getState() const {
    return m_state;
}
void OAIInstance::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIInstance::is_state_Set() const{
    return m_state_isSet;
}

bool OAIInstance::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIInstance::getUpdateTime() const {
    return m_update_time;
}
void OAIInstance::setUpdateTime(const QString &update_time) {
    m_update_time = update_time;
    m_update_time_isSet = true;
}

bool OAIInstance::is_update_time_Set() const{
    return m_update_time_isSet;
}

bool OAIInstance::is_update_time_Valid() const{
    return m_update_time_isValid;
}

QList<QString> OAIInstance::getZones() const {
    return m_zones;
}
void OAIInstance::setZones(const QList<QString> &zones) {
    m_zones = zones;
    m_zones_isSet = true;
}

bool OAIInstance::is_zones_Set() const{
    return m_zones_isSet;
}

bool OAIInstance::is_zones_Valid() const{
    return m_zones_isValid;
}

bool OAIInstance::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_authorized_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_discovery_endpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_messages.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_maintenance_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_maintenance_schedule.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_memcache_full_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_memcache_nodes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_memcache_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_parameters.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_reserved_ip_range_id.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_zones.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIInstance::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
