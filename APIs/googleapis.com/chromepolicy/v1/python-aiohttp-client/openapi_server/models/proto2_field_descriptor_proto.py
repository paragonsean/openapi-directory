# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Proto2FieldDescriptorProto(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, default_value: str=None, json_name: str=None, label: str=None, name: str=None, number: int=None, oneof_index: int=None, proto3_optional: bool=None, type: str=None, type_name: str=None):
        """Proto2FieldDescriptorProto - a model defined in OpenAPI

        :param default_value: The default_value of this Proto2FieldDescriptorProto.
        :param json_name: The json_name of this Proto2FieldDescriptorProto.
        :param label: The label of this Proto2FieldDescriptorProto.
        :param name: The name of this Proto2FieldDescriptorProto.
        :param number: The number of this Proto2FieldDescriptorProto.
        :param oneof_index: The oneof_index of this Proto2FieldDescriptorProto.
        :param proto3_optional: The proto3_optional of this Proto2FieldDescriptorProto.
        :param type: The type of this Proto2FieldDescriptorProto.
        :param type_name: The type_name of this Proto2FieldDescriptorProto.
        """
        self.openapi_types = {
            'default_value': str,
            'json_name': str,
            'label': str,
            'name': str,
            'number': int,
            'oneof_index': int,
            'proto3_optional': bool,
            'type': str,
            'type_name': str
        }

        self.attribute_map = {
            'default_value': 'defaultValue',
            'json_name': 'jsonName',
            'label': 'label',
            'name': 'name',
            'number': 'number',
            'oneof_index': 'oneofIndex',
            'proto3_optional': 'proto3Optional',
            'type': 'type',
            'type_name': 'typeName'
        }

        self._default_value = default_value
        self._json_name = json_name
        self._label = label
        self._name = name
        self._number = number
        self._oneof_index = oneof_index
        self._proto3_optional = proto3_optional
        self._type = type
        self._type_name = type_name

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Proto2FieldDescriptorProto':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Proto2FieldDescriptorProto of this Proto2FieldDescriptorProto.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def default_value(self):
        """Gets the default_value of this Proto2FieldDescriptorProto.

        For numeric types, contains the original text representation of the value. For booleans, \"true\" or \"false\". For strings, contains the default text contents (not escaped in any way). For bytes, contains the C escaped value. All bytes >= 128 are escaped.

        :return: The default_value of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._default_value

    @default_value.setter
    def default_value(self, default_value):
        """Sets the default_value of this Proto2FieldDescriptorProto.

        For numeric types, contains the original text representation of the value. For booleans, \"true\" or \"false\". For strings, contains the default text contents (not escaped in any way). For bytes, contains the C escaped value. All bytes >= 128 are escaped.

        :param default_value: The default_value of this Proto2FieldDescriptorProto.
        :type default_value: str
        """

        self._default_value = default_value

    @property
    def json_name(self):
        """Gets the json_name of this Proto2FieldDescriptorProto.

        JSON name of this field. The value is set by protocol compiler. If the user has set a \"json_name\" option on this field, that option's value will be used. Otherwise, it's deduced from the field's name by converting it to camelCase.

        :return: The json_name of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._json_name

    @json_name.setter
    def json_name(self, json_name):
        """Sets the json_name of this Proto2FieldDescriptorProto.

        JSON name of this field. The value is set by protocol compiler. If the user has set a \"json_name\" option on this field, that option's value will be used. Otherwise, it's deduced from the field's name by converting it to camelCase.

        :param json_name: The json_name of this Proto2FieldDescriptorProto.
        :type json_name: str
        """

        self._json_name = json_name

    @property
    def label(self):
        """Gets the label of this Proto2FieldDescriptorProto.


        :return: The label of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._label

    @label.setter
    def label(self, label):
        """Sets the label of this Proto2FieldDescriptorProto.


        :param label: The label of this Proto2FieldDescriptorProto.
        :type label: str
        """
        allowed_values = ["LABEL_OPTIONAL", "LABEL_REPEATED", "LABEL_REQUIRED"]  # noqa: E501
        if label not in allowed_values:
            raise ValueError(
                "Invalid value for `label` ({0}), must be one of {1}"
                .format(label, allowed_values)
            )

        self._label = label

    @property
    def name(self):
        """Gets the name of this Proto2FieldDescriptorProto.


        :return: The name of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Proto2FieldDescriptorProto.


        :param name: The name of this Proto2FieldDescriptorProto.
        :type name: str
        """

        self._name = name

    @property
    def number(self):
        """Gets the number of this Proto2FieldDescriptorProto.


        :return: The number of this Proto2FieldDescriptorProto.
        :rtype: int
        """
        return self._number

    @number.setter
    def number(self, number):
        """Sets the number of this Proto2FieldDescriptorProto.


        :param number: The number of this Proto2FieldDescriptorProto.
        :type number: int
        """

        self._number = number

    @property
    def oneof_index(self):
        """Gets the oneof_index of this Proto2FieldDescriptorProto.

        If set, gives the index of a oneof in the containing type's oneof_decl list. This field is a member of that oneof.

        :return: The oneof_index of this Proto2FieldDescriptorProto.
        :rtype: int
        """
        return self._oneof_index

    @oneof_index.setter
    def oneof_index(self, oneof_index):
        """Sets the oneof_index of this Proto2FieldDescriptorProto.

        If set, gives the index of a oneof in the containing type's oneof_decl list. This field is a member of that oneof.

        :param oneof_index: The oneof_index of this Proto2FieldDescriptorProto.
        :type oneof_index: int
        """

        self._oneof_index = oneof_index

    @property
    def proto3_optional(self):
        """Gets the proto3_optional of this Proto2FieldDescriptorProto.

        If true, this is a proto3 \"optional\". When a proto3 field is optional, it tracks presence regardless of field type. When proto3_optional is true, this field must belong to a oneof to signal to old proto3 clients that presence is tracked for this field. This oneof is known as a \"synthetic\" oneof, and this field must be its sole member (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs exist in the descriptor only, and do not generate any API. Synthetic oneofs must be ordered after all \"real\" oneofs. For message fields, proto3_optional doesn't create any semantic change, since non-repeated message fields always track presence. However it still indicates the semantic detail of whether the user wrote \"optional\" or not. This can be useful for round-tripping the .proto file. For consistency we give message fields a synthetic oneof also, even though it is not required to track presence. This is especially important because the parser can't tell if a field is a message or an enum, so it must always create a synthetic oneof. Proto2 optional fields do not set this flag, because they already indicate optional with `LABEL_OPTIONAL`.

        :return: The proto3_optional of this Proto2FieldDescriptorProto.
        :rtype: bool
        """
        return self._proto3_optional

    @proto3_optional.setter
    def proto3_optional(self, proto3_optional):
        """Sets the proto3_optional of this Proto2FieldDescriptorProto.

        If true, this is a proto3 \"optional\". When a proto3 field is optional, it tracks presence regardless of field type. When proto3_optional is true, this field must belong to a oneof to signal to old proto3 clients that presence is tracked for this field. This oneof is known as a \"synthetic\" oneof, and this field must be its sole member (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs exist in the descriptor only, and do not generate any API. Synthetic oneofs must be ordered after all \"real\" oneofs. For message fields, proto3_optional doesn't create any semantic change, since non-repeated message fields always track presence. However it still indicates the semantic detail of whether the user wrote \"optional\" or not. This can be useful for round-tripping the .proto file. For consistency we give message fields a synthetic oneof also, even though it is not required to track presence. This is especially important because the parser can't tell if a field is a message or an enum, so it must always create a synthetic oneof. Proto2 optional fields do not set this flag, because they already indicate optional with `LABEL_OPTIONAL`.

        :param proto3_optional: The proto3_optional of this Proto2FieldDescriptorProto.
        :type proto3_optional: bool
        """

        self._proto3_optional = proto3_optional

    @property
    def type(self):
        """Gets the type of this Proto2FieldDescriptorProto.

        If type_name is set, this need not be set. If both this and type_name are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.

        :return: The type of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Proto2FieldDescriptorProto.

        If type_name is set, this need not be set. If both this and type_name are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.

        :param type: The type of this Proto2FieldDescriptorProto.
        :type type: str
        """
        allowed_values = ["TYPE_DOUBLE", "TYPE_FLOAT", "TYPE_INT64", "TYPE_UINT64", "TYPE_INT32", "TYPE_FIXED64", "TYPE_FIXED32", "TYPE_BOOL", "TYPE_STRING", "TYPE_GROUP", "TYPE_MESSAGE", "TYPE_BYTES", "TYPE_UINT32", "TYPE_ENUM", "TYPE_SFIXED32", "TYPE_SFIXED64", "TYPE_SINT32", "TYPE_SINT64"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def type_name(self):
        """Gets the type_name of this Proto2FieldDescriptorProto.

        For message and enum types, this is the name of the type. If the name starts with a '.', it is fully-qualified. Otherwise, C++-like scoping rules are used to find the type (i.e. first the nested types within this message are searched, then within the parent, on up to the root namespace).

        :return: The type_name of this Proto2FieldDescriptorProto.
        :rtype: str
        """
        return self._type_name

    @type_name.setter
    def type_name(self, type_name):
        """Sets the type_name of this Proto2FieldDescriptorProto.

        For message and enum types, this is the name of the type. If the name starts with a '.', it is fully-qualified. Otherwise, C++-like scoping rules are used to find the type (i.e. first the nested types within this message are searched, then within the parent, on up to the root namespace).

        :param type_name: The type_name of this Proto2FieldDescriptorProto.
        :type type_name: str
        """

        self._type_name = type_name
