/**
 * Chrome Policy API
 * The Chrome Policy API is a suite of services that allows Chrome administrators to control the policies applied to their managed Chrome OS devices and Chrome browsers.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The Proto2FieldDescriptorProto model module.
 * @module model/Proto2FieldDescriptorProto
 * @version v1
 */
class Proto2FieldDescriptorProto {
    /**
     * Constructs a new <code>Proto2FieldDescriptorProto</code>.
     * Describes a field within a message.
     * @alias module:model/Proto2FieldDescriptorProto
     */
    constructor() { 
        
        Proto2FieldDescriptorProto.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Proto2FieldDescriptorProto</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Proto2FieldDescriptorProto} obj Optional instance to populate.
     * @return {module:model/Proto2FieldDescriptorProto} The populated <code>Proto2FieldDescriptorProto</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Proto2FieldDescriptorProto();

            if (data.hasOwnProperty('defaultValue')) {
                obj['defaultValue'] = ApiClient.convertToType(data['defaultValue'], 'String');
            }
            if (data.hasOwnProperty('jsonName')) {
                obj['jsonName'] = ApiClient.convertToType(data['jsonName'], 'String');
            }
            if (data.hasOwnProperty('label')) {
                obj['label'] = ApiClient.convertToType(data['label'], 'String');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('number')) {
                obj['number'] = ApiClient.convertToType(data['number'], 'Number');
            }
            if (data.hasOwnProperty('oneofIndex')) {
                obj['oneofIndex'] = ApiClient.convertToType(data['oneofIndex'], 'Number');
            }
            if (data.hasOwnProperty('proto3Optional')) {
                obj['proto3Optional'] = ApiClient.convertToType(data['proto3Optional'], 'Boolean');
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
            if (data.hasOwnProperty('typeName')) {
                obj['typeName'] = ApiClient.convertToType(data['typeName'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Proto2FieldDescriptorProto</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Proto2FieldDescriptorProto</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['defaultValue'] && !(typeof data['defaultValue'] === 'string' || data['defaultValue'] instanceof String)) {
            throw new Error("Expected the field `defaultValue` to be a primitive type in the JSON string but got " + data['defaultValue']);
        }
        // ensure the json data is a string
        if (data['jsonName'] && !(typeof data['jsonName'] === 'string' || data['jsonName'] instanceof String)) {
            throw new Error("Expected the field `jsonName` to be a primitive type in the JSON string but got " + data['jsonName']);
        }
        // ensure the json data is a string
        if (data['label'] && !(typeof data['label'] === 'string' || data['label'] instanceof String)) {
            throw new Error("Expected the field `label` to be a primitive type in the JSON string but got " + data['label']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }
        // ensure the json data is a string
        if (data['typeName'] && !(typeof data['typeName'] === 'string' || data['typeName'] instanceof String)) {
            throw new Error("Expected the field `typeName` to be a primitive type in the JSON string but got " + data['typeName']);
        }

        return true;
    }


}



/**
 * For numeric types, contains the original text representation of the value. For booleans, \"true\" or \"false\". For strings, contains the default text contents (not escaped in any way). For bytes, contains the C escaped value. All bytes >= 128 are escaped.
 * @member {String} defaultValue
 */
Proto2FieldDescriptorProto.prototype['defaultValue'] = undefined;

/**
 * JSON name of this field. The value is set by protocol compiler. If the user has set a \"json_name\" option on this field, that option's value will be used. Otherwise, it's deduced from the field's name by converting it to camelCase.
 * @member {String} jsonName
 */
Proto2FieldDescriptorProto.prototype['jsonName'] = undefined;

/**
 * @member {module:model/Proto2FieldDescriptorProto.LabelEnum} label
 */
Proto2FieldDescriptorProto.prototype['label'] = undefined;

/**
 * @member {String} name
 */
Proto2FieldDescriptorProto.prototype['name'] = undefined;

/**
 * @member {Number} number
 */
Proto2FieldDescriptorProto.prototype['number'] = undefined;

/**
 * If set, gives the index of a oneof in the containing type's oneof_decl list. This field is a member of that oneof.
 * @member {Number} oneofIndex
 */
Proto2FieldDescriptorProto.prototype['oneofIndex'] = undefined;

/**
 * If true, this is a proto3 \"optional\". When a proto3 field is optional, it tracks presence regardless of field type. When proto3_optional is true, this field must belong to a oneof to signal to old proto3 clients that presence is tracked for this field. This oneof is known as a \"synthetic\" oneof, and this field must be its sole member (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs exist in the descriptor only, and do not generate any API. Synthetic oneofs must be ordered after all \"real\" oneofs. For message fields, proto3_optional doesn't create any semantic change, since non-repeated message fields always track presence. However it still indicates the semantic detail of whether the user wrote \"optional\" or not. This can be useful for round-tripping the .proto file. For consistency we give message fields a synthetic oneof also, even though it is not required to track presence. This is especially important because the parser can't tell if a field is a message or an enum, so it must always create a synthetic oneof. Proto2 optional fields do not set this flag, because they already indicate optional with `LABEL_OPTIONAL`.
 * @member {Boolean} proto3Optional
 */
Proto2FieldDescriptorProto.prototype['proto3Optional'] = undefined;

/**
 * If type_name is set, this need not be set. If both this and type_name are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
 * @member {module:model/Proto2FieldDescriptorProto.TypeEnum} type
 */
Proto2FieldDescriptorProto.prototype['type'] = undefined;

/**
 * For message and enum types, this is the name of the type. If the name starts with a '.', it is fully-qualified. Otherwise, C++-like scoping rules are used to find the type (i.e. first the nested types within this message are searched, then within the parent, on up to the root namespace).
 * @member {String} typeName
 */
Proto2FieldDescriptorProto.prototype['typeName'] = undefined;





/**
 * Allowed values for the <code>label</code> property.
 * @enum {String}
 * @readonly
 */
Proto2FieldDescriptorProto['LabelEnum'] = {

    /**
     * value: "LABEL_OPTIONAL"
     * @const
     */
    "OPTIONAL": "LABEL_OPTIONAL",

    /**
     * value: "LABEL_REPEATED"
     * @const
     */
    "REPEATED": "LABEL_REPEATED",

    /**
     * value: "LABEL_REQUIRED"
     * @const
     */
    "REQUIRED": "LABEL_REQUIRED"
};


/**
 * Allowed values for the <code>type</code> property.
 * @enum {String}
 * @readonly
 */
Proto2FieldDescriptorProto['TypeEnum'] = {

    /**
     * value: "TYPE_DOUBLE"
     * @const
     */
    "DOUBLE": "TYPE_DOUBLE",

    /**
     * value: "TYPE_FLOAT"
     * @const
     */
    "FLOAT": "TYPE_FLOAT",

    /**
     * value: "TYPE_INT64"
     * @const
     */
    "INT64": "TYPE_INT64",

    /**
     * value: "TYPE_UINT64"
     * @const
     */
    "UINT64": "TYPE_UINT64",

    /**
     * value: "TYPE_INT32"
     * @const
     */
    "INT32": "TYPE_INT32",

    /**
     * value: "TYPE_FIXED64"
     * @const
     */
    "FIXED64": "TYPE_FIXED64",

    /**
     * value: "TYPE_FIXED32"
     * @const
     */
    "FIXED32": "TYPE_FIXED32",

    /**
     * value: "TYPE_BOOL"
     * @const
     */
    "BOOL": "TYPE_BOOL",

    /**
     * value: "TYPE_STRING"
     * @const
     */
    "STRING": "TYPE_STRING",

    /**
     * value: "TYPE_GROUP"
     * @const
     */
    "GROUP": "TYPE_GROUP",

    /**
     * value: "TYPE_MESSAGE"
     * @const
     */
    "MESSAGE": "TYPE_MESSAGE",

    /**
     * value: "TYPE_BYTES"
     * @const
     */
    "BYTES": "TYPE_BYTES",

    /**
     * value: "TYPE_UINT32"
     * @const
     */
    "UINT32": "TYPE_UINT32",

    /**
     * value: "TYPE_ENUM"
     * @const
     */
    "ENUM": "TYPE_ENUM",

    /**
     * value: "TYPE_SFIXED32"
     * @const
     */
    "SFIXED32": "TYPE_SFIXED32",

    /**
     * value: "TYPE_SFIXED64"
     * @const
     */
    "SFIXED64": "TYPE_SFIXED64",

    /**
     * value: "TYPE_SINT32"
     * @const
     */
    "SINT32": "TYPE_SINT32",

    /**
     * value: "TYPE_SINT64"
     * @const
     */
    "SINT64": "TYPE_SINT64"
};



export default Proto2FieldDescriptorProto;

