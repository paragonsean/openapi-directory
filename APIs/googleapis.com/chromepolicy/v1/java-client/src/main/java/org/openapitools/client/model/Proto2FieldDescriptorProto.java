/*
 * Chrome Policy API
 * The Chrome Policy API is a suite of services that allows Chrome administrators to control the policies applied to their managed Chrome OS devices and Chrome browsers.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes a field within a message.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:19.062447-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Proto2FieldDescriptorProto {
  public static final String SERIALIZED_NAME_DEFAULT_VALUE = "defaultValue";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VALUE)
  private String defaultValue;

  public static final String SERIALIZED_NAME_JSON_NAME = "jsonName";
  @SerializedName(SERIALIZED_NAME_JSON_NAME)
  private String jsonName;

  /**
   * Gets or Sets label
   */
  @JsonAdapter(LabelEnum.Adapter.class)
  public enum LabelEnum {
    OPTIONAL("LABEL_OPTIONAL"),
    
    REPEATED("LABEL_REPEATED"),
    
    REQUIRED("LABEL_REQUIRED");

    private String value;

    LabelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LabelEnum fromValue(String value) {
      for (LabelEnum b : LabelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LabelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LabelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LabelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LabelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LabelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LABEL = "label";
  @SerializedName(SERIALIZED_NAME_LABEL)
  private LabelEnum label;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private Integer number;

  public static final String SERIALIZED_NAME_ONEOF_INDEX = "oneofIndex";
  @SerializedName(SERIALIZED_NAME_ONEOF_INDEX)
  private Integer oneofIndex;

  public static final String SERIALIZED_NAME_PROTO3_OPTIONAL = "proto3Optional";
  @SerializedName(SERIALIZED_NAME_PROTO3_OPTIONAL)
  private Boolean proto3Optional;

  /**
   * If type_name is set, this need not be set. If both this and type_name are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    DOUBLE("TYPE_DOUBLE"),
    
    FLOAT("TYPE_FLOAT"),
    
    INT64("TYPE_INT64"),
    
    UINT64("TYPE_UINT64"),
    
    INT32("TYPE_INT32"),
    
    FIXED64("TYPE_FIXED64"),
    
    FIXED32("TYPE_FIXED32"),
    
    BOOL("TYPE_BOOL"),
    
    STRING("TYPE_STRING"),
    
    GROUP("TYPE_GROUP"),
    
    MESSAGE("TYPE_MESSAGE"),
    
    BYTES("TYPE_BYTES"),
    
    UINT32("TYPE_UINT32"),
    
    ENUM("TYPE_ENUM"),
    
    SFIXED32("TYPE_SFIXED32"),
    
    SFIXED64("TYPE_SFIXED64"),
    
    SINT32("TYPE_SINT32"),
    
    SINT64("TYPE_SINT64");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_TYPE_NAME = "typeName";
  @SerializedName(SERIALIZED_NAME_TYPE_NAME)
  private String typeName;

  public Proto2FieldDescriptorProto() {
  }

  public Proto2FieldDescriptorProto defaultValue(String defaultValue) {
    this.defaultValue = defaultValue;
    return this;
  }

  /**
   * For numeric types, contains the original text representation of the value. For booleans, \&quot;true\&quot; or \&quot;false\&quot;. For strings, contains the default text contents (not escaped in any way). For bytes, contains the C escaped value. All bytes &gt;&#x3D; 128 are escaped.
   * @return defaultValue
   */
  @javax.annotation.Nullable
  public String getDefaultValue() {
    return defaultValue;
  }

  public void setDefaultValue(String defaultValue) {
    this.defaultValue = defaultValue;
  }


  public Proto2FieldDescriptorProto jsonName(String jsonName) {
    this.jsonName = jsonName;
    return this;
  }

  /**
   * JSON name of this field. The value is set by protocol compiler. If the user has set a \&quot;json_name\&quot; option on this field, that option&#39;s value will be used. Otherwise, it&#39;s deduced from the field&#39;s name by converting it to camelCase.
   * @return jsonName
   */
  @javax.annotation.Nullable
  public String getJsonName() {
    return jsonName;
  }

  public void setJsonName(String jsonName) {
    this.jsonName = jsonName;
  }


  public Proto2FieldDescriptorProto label(LabelEnum label) {
    this.label = label;
    return this;
  }

  /**
   * Get label
   * @return label
   */
  @javax.annotation.Nullable
  public LabelEnum getLabel() {
    return label;
  }

  public void setLabel(LabelEnum label) {
    this.label = label;
  }


  public Proto2FieldDescriptorProto name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Proto2FieldDescriptorProto number(Integer number) {
    this.number = number;
    return this;
  }

  /**
   * Get number
   * @return number
   */
  @javax.annotation.Nullable
  public Integer getNumber() {
    return number;
  }

  public void setNumber(Integer number) {
    this.number = number;
  }


  public Proto2FieldDescriptorProto oneofIndex(Integer oneofIndex) {
    this.oneofIndex = oneofIndex;
    return this;
  }

  /**
   * If set, gives the index of a oneof in the containing type&#39;s oneof_decl list. This field is a member of that oneof.
   * @return oneofIndex
   */
  @javax.annotation.Nullable
  public Integer getOneofIndex() {
    return oneofIndex;
  }

  public void setOneofIndex(Integer oneofIndex) {
    this.oneofIndex = oneofIndex;
  }


  public Proto2FieldDescriptorProto proto3Optional(Boolean proto3Optional) {
    this.proto3Optional = proto3Optional;
    return this;
  }

  /**
   * If true, this is a proto3 \&quot;optional\&quot;. When a proto3 field is optional, it tracks presence regardless of field type. When proto3_optional is true, this field must belong to a oneof to signal to old proto3 clients that presence is tracked for this field. This oneof is known as a \&quot;synthetic\&quot; oneof, and this field must be its sole member (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs exist in the descriptor only, and do not generate any API. Synthetic oneofs must be ordered after all \&quot;real\&quot; oneofs. For message fields, proto3_optional doesn&#39;t create any semantic change, since non-repeated message fields always track presence. However it still indicates the semantic detail of whether the user wrote \&quot;optional\&quot; or not. This can be useful for round-tripping the .proto file. For consistency we give message fields a synthetic oneof also, even though it is not required to track presence. This is especially important because the parser can&#39;t tell if a field is a message or an enum, so it must always create a synthetic oneof. Proto2 optional fields do not set this flag, because they already indicate optional with &#x60;LABEL_OPTIONAL&#x60;.
   * @return proto3Optional
   */
  @javax.annotation.Nullable
  public Boolean getProto3Optional() {
    return proto3Optional;
  }

  public void setProto3Optional(Boolean proto3Optional) {
    this.proto3Optional = proto3Optional;
  }


  public Proto2FieldDescriptorProto type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * If type_name is set, this need not be set. If both this and type_name are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public Proto2FieldDescriptorProto typeName(String typeName) {
    this.typeName = typeName;
    return this;
  }

  /**
   * For message and enum types, this is the name of the type. If the name starts with a &#39;.&#39;, it is fully-qualified. Otherwise, C++-like scoping rules are used to find the type (i.e. first the nested types within this message are searched, then within the parent, on up to the root namespace).
   * @return typeName
   */
  @javax.annotation.Nullable
  public String getTypeName() {
    return typeName;
  }

  public void setTypeName(String typeName) {
    this.typeName = typeName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Proto2FieldDescriptorProto proto2FieldDescriptorProto = (Proto2FieldDescriptorProto) o;
    return Objects.equals(this.defaultValue, proto2FieldDescriptorProto.defaultValue) &&
        Objects.equals(this.jsonName, proto2FieldDescriptorProto.jsonName) &&
        Objects.equals(this.label, proto2FieldDescriptorProto.label) &&
        Objects.equals(this.name, proto2FieldDescriptorProto.name) &&
        Objects.equals(this.number, proto2FieldDescriptorProto.number) &&
        Objects.equals(this.oneofIndex, proto2FieldDescriptorProto.oneofIndex) &&
        Objects.equals(this.proto3Optional, proto2FieldDescriptorProto.proto3Optional) &&
        Objects.equals(this.type, proto2FieldDescriptorProto.type) &&
        Objects.equals(this.typeName, proto2FieldDescriptorProto.typeName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultValue, jsonName, label, name, number, oneofIndex, proto3Optional, type, typeName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Proto2FieldDescriptorProto {\n");
    sb.append("    defaultValue: ").append(toIndentedString(defaultValue)).append("\n");
    sb.append("    jsonName: ").append(toIndentedString(jsonName)).append("\n");
    sb.append("    label: ").append(toIndentedString(label)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    oneofIndex: ").append(toIndentedString(oneofIndex)).append("\n");
    sb.append("    proto3Optional: ").append(toIndentedString(proto3Optional)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    typeName: ").append(toIndentedString(typeName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("defaultValue");
    openapiFields.add("jsonName");
    openapiFields.add("label");
    openapiFields.add("name");
    openapiFields.add("number");
    openapiFields.add("oneofIndex");
    openapiFields.add("proto3Optional");
    openapiFields.add("type");
    openapiFields.add("typeName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Proto2FieldDescriptorProto
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Proto2FieldDescriptorProto.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Proto2FieldDescriptorProto is not found in the empty JSON string", Proto2FieldDescriptorProto.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Proto2FieldDescriptorProto.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Proto2FieldDescriptorProto` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("defaultValue") != null && !jsonObj.get("defaultValue").isJsonNull()) && !jsonObj.get("defaultValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultValue").toString()));
      }
      if ((jsonObj.get("jsonName") != null && !jsonObj.get("jsonName").isJsonNull()) && !jsonObj.get("jsonName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jsonName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jsonName").toString()));
      }
      if ((jsonObj.get("label") != null && !jsonObj.get("label").isJsonNull()) && !jsonObj.get("label").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `label` to be a primitive type in the JSON string but got `%s`", jsonObj.get("label").toString()));
      }
      // validate the optional field `label`
      if (jsonObj.get("label") != null && !jsonObj.get("label").isJsonNull()) {
        LabelEnum.validateJsonElement(jsonObj.get("label"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
      if ((jsonObj.get("typeName") != null && !jsonObj.get("typeName").isJsonNull()) && !jsonObj.get("typeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Proto2FieldDescriptorProto.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Proto2FieldDescriptorProto' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Proto2FieldDescriptorProto> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Proto2FieldDescriptorProto.class));

       return (TypeAdapter<T>) new TypeAdapter<Proto2FieldDescriptorProto>() {
           @Override
           public void write(JsonWriter out, Proto2FieldDescriptorProto value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Proto2FieldDescriptorProto read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Proto2FieldDescriptorProto given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Proto2FieldDescriptorProto
   * @throws IOException if the JSON string is invalid with respect to Proto2FieldDescriptorProto
   */
  public static Proto2FieldDescriptorProto fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Proto2FieldDescriptorProto.class);
  }

  /**
   * Convert an instance of Proto2FieldDescriptorProto to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

