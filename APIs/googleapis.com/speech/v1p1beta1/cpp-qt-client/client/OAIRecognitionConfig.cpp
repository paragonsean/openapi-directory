/**
 * Cloud Speech-to-Text API
 * Converts audio to text by applying powerful neural network models.
 *
 * The version of the OpenAPI document: v1p1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRecognitionConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRecognitionConfig::OAIRecognitionConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRecognitionConfig::OAIRecognitionConfig() {
    this->initializeModel();
}

OAIRecognitionConfig::~OAIRecognitionConfig() {}

void OAIRecognitionConfig::initializeModel() {

    m_adaptation_isSet = false;
    m_adaptation_isValid = false;

    m_alternative_language_codes_isSet = false;
    m_alternative_language_codes_isValid = false;

    m_audio_channel_count_isSet = false;
    m_audio_channel_count_isValid = false;

    m_diarization_config_isSet = false;
    m_diarization_config_isValid = false;

    m_diarization_speaker_count_isSet = false;
    m_diarization_speaker_count_isValid = false;

    m_enable_automatic_punctuation_isSet = false;
    m_enable_automatic_punctuation_isValid = false;

    m_enable_separate_recognition_per_channel_isSet = false;
    m_enable_separate_recognition_per_channel_isValid = false;

    m_enable_speaker_diarization_isSet = false;
    m_enable_speaker_diarization_isValid = false;

    m_enable_spoken_emojis_isSet = false;
    m_enable_spoken_emojis_isValid = false;

    m_enable_spoken_punctuation_isSet = false;
    m_enable_spoken_punctuation_isValid = false;

    m_enable_word_confidence_isSet = false;
    m_enable_word_confidence_isValid = false;

    m_enable_word_time_offsets_isSet = false;
    m_enable_word_time_offsets_isValid = false;

    m_encoding_isSet = false;
    m_encoding_isValid = false;

    m_language_code_isSet = false;
    m_language_code_isValid = false;

    m_max_alternatives_isSet = false;
    m_max_alternatives_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_model_isSet = false;
    m_model_isValid = false;

    m_profanity_filter_isSet = false;
    m_profanity_filter_isValid = false;

    m_sample_rate_hertz_isSet = false;
    m_sample_rate_hertz_isValid = false;

    m_speech_contexts_isSet = false;
    m_speech_contexts_isValid = false;

    m_transcript_normalization_isSet = false;
    m_transcript_normalization_isValid = false;

    m_use_enhanced_isSet = false;
    m_use_enhanced_isValid = false;
}

void OAIRecognitionConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRecognitionConfig::fromJsonObject(QJsonObject json) {

    m_adaptation_isValid = ::OpenAPI::fromJsonValue(m_adaptation, json[QString("adaptation")]);
    m_adaptation_isSet = !json[QString("adaptation")].isNull() && m_adaptation_isValid;

    m_alternative_language_codes_isValid = ::OpenAPI::fromJsonValue(m_alternative_language_codes, json[QString("alternativeLanguageCodes")]);
    m_alternative_language_codes_isSet = !json[QString("alternativeLanguageCodes")].isNull() && m_alternative_language_codes_isValid;

    m_audio_channel_count_isValid = ::OpenAPI::fromJsonValue(m_audio_channel_count, json[QString("audioChannelCount")]);
    m_audio_channel_count_isSet = !json[QString("audioChannelCount")].isNull() && m_audio_channel_count_isValid;

    m_diarization_config_isValid = ::OpenAPI::fromJsonValue(m_diarization_config, json[QString("diarizationConfig")]);
    m_diarization_config_isSet = !json[QString("diarizationConfig")].isNull() && m_diarization_config_isValid;

    m_diarization_speaker_count_isValid = ::OpenAPI::fromJsonValue(m_diarization_speaker_count, json[QString("diarizationSpeakerCount")]);
    m_diarization_speaker_count_isSet = !json[QString("diarizationSpeakerCount")].isNull() && m_diarization_speaker_count_isValid;

    m_enable_automatic_punctuation_isValid = ::OpenAPI::fromJsonValue(m_enable_automatic_punctuation, json[QString("enableAutomaticPunctuation")]);
    m_enable_automatic_punctuation_isSet = !json[QString("enableAutomaticPunctuation")].isNull() && m_enable_automatic_punctuation_isValid;

    m_enable_separate_recognition_per_channel_isValid = ::OpenAPI::fromJsonValue(m_enable_separate_recognition_per_channel, json[QString("enableSeparateRecognitionPerChannel")]);
    m_enable_separate_recognition_per_channel_isSet = !json[QString("enableSeparateRecognitionPerChannel")].isNull() && m_enable_separate_recognition_per_channel_isValid;

    m_enable_speaker_diarization_isValid = ::OpenAPI::fromJsonValue(m_enable_speaker_diarization, json[QString("enableSpeakerDiarization")]);
    m_enable_speaker_diarization_isSet = !json[QString("enableSpeakerDiarization")].isNull() && m_enable_speaker_diarization_isValid;

    m_enable_spoken_emojis_isValid = ::OpenAPI::fromJsonValue(m_enable_spoken_emojis, json[QString("enableSpokenEmojis")]);
    m_enable_spoken_emojis_isSet = !json[QString("enableSpokenEmojis")].isNull() && m_enable_spoken_emojis_isValid;

    m_enable_spoken_punctuation_isValid = ::OpenAPI::fromJsonValue(m_enable_spoken_punctuation, json[QString("enableSpokenPunctuation")]);
    m_enable_spoken_punctuation_isSet = !json[QString("enableSpokenPunctuation")].isNull() && m_enable_spoken_punctuation_isValid;

    m_enable_word_confidence_isValid = ::OpenAPI::fromJsonValue(m_enable_word_confidence, json[QString("enableWordConfidence")]);
    m_enable_word_confidence_isSet = !json[QString("enableWordConfidence")].isNull() && m_enable_word_confidence_isValid;

    m_enable_word_time_offsets_isValid = ::OpenAPI::fromJsonValue(m_enable_word_time_offsets, json[QString("enableWordTimeOffsets")]);
    m_enable_word_time_offsets_isSet = !json[QString("enableWordTimeOffsets")].isNull() && m_enable_word_time_offsets_isValid;

    m_encoding_isValid = ::OpenAPI::fromJsonValue(m_encoding, json[QString("encoding")]);
    m_encoding_isSet = !json[QString("encoding")].isNull() && m_encoding_isValid;

    m_language_code_isValid = ::OpenAPI::fromJsonValue(m_language_code, json[QString("languageCode")]);
    m_language_code_isSet = !json[QString("languageCode")].isNull() && m_language_code_isValid;

    m_max_alternatives_isValid = ::OpenAPI::fromJsonValue(m_max_alternatives, json[QString("maxAlternatives")]);
    m_max_alternatives_isSet = !json[QString("maxAlternatives")].isNull() && m_max_alternatives_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_model_isValid = ::OpenAPI::fromJsonValue(m_model, json[QString("model")]);
    m_model_isSet = !json[QString("model")].isNull() && m_model_isValid;

    m_profanity_filter_isValid = ::OpenAPI::fromJsonValue(m_profanity_filter, json[QString("profanityFilter")]);
    m_profanity_filter_isSet = !json[QString("profanityFilter")].isNull() && m_profanity_filter_isValid;

    m_sample_rate_hertz_isValid = ::OpenAPI::fromJsonValue(m_sample_rate_hertz, json[QString("sampleRateHertz")]);
    m_sample_rate_hertz_isSet = !json[QString("sampleRateHertz")].isNull() && m_sample_rate_hertz_isValid;

    m_speech_contexts_isValid = ::OpenAPI::fromJsonValue(m_speech_contexts, json[QString("speechContexts")]);
    m_speech_contexts_isSet = !json[QString("speechContexts")].isNull() && m_speech_contexts_isValid;

    m_transcript_normalization_isValid = ::OpenAPI::fromJsonValue(m_transcript_normalization, json[QString("transcriptNormalization")]);
    m_transcript_normalization_isSet = !json[QString("transcriptNormalization")].isNull() && m_transcript_normalization_isValid;

    m_use_enhanced_isValid = ::OpenAPI::fromJsonValue(m_use_enhanced, json[QString("useEnhanced")]);
    m_use_enhanced_isSet = !json[QString("useEnhanced")].isNull() && m_use_enhanced_isValid;
}

QString OAIRecognitionConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRecognitionConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_adaptation.isSet()) {
        obj.insert(QString("adaptation"), ::OpenAPI::toJsonValue(m_adaptation));
    }
    if (m_alternative_language_codes.size() > 0) {
        obj.insert(QString("alternativeLanguageCodes"), ::OpenAPI::toJsonValue(m_alternative_language_codes));
    }
    if (m_audio_channel_count_isSet) {
        obj.insert(QString("audioChannelCount"), ::OpenAPI::toJsonValue(m_audio_channel_count));
    }
    if (m_diarization_config.isSet()) {
        obj.insert(QString("diarizationConfig"), ::OpenAPI::toJsonValue(m_diarization_config));
    }
    if (m_diarization_speaker_count_isSet) {
        obj.insert(QString("diarizationSpeakerCount"), ::OpenAPI::toJsonValue(m_diarization_speaker_count));
    }
    if (m_enable_automatic_punctuation_isSet) {
        obj.insert(QString("enableAutomaticPunctuation"), ::OpenAPI::toJsonValue(m_enable_automatic_punctuation));
    }
    if (m_enable_separate_recognition_per_channel_isSet) {
        obj.insert(QString("enableSeparateRecognitionPerChannel"), ::OpenAPI::toJsonValue(m_enable_separate_recognition_per_channel));
    }
    if (m_enable_speaker_diarization_isSet) {
        obj.insert(QString("enableSpeakerDiarization"), ::OpenAPI::toJsonValue(m_enable_speaker_diarization));
    }
    if (m_enable_spoken_emojis_isSet) {
        obj.insert(QString("enableSpokenEmojis"), ::OpenAPI::toJsonValue(m_enable_spoken_emojis));
    }
    if (m_enable_spoken_punctuation_isSet) {
        obj.insert(QString("enableSpokenPunctuation"), ::OpenAPI::toJsonValue(m_enable_spoken_punctuation));
    }
    if (m_enable_word_confidence_isSet) {
        obj.insert(QString("enableWordConfidence"), ::OpenAPI::toJsonValue(m_enable_word_confidence));
    }
    if (m_enable_word_time_offsets_isSet) {
        obj.insert(QString("enableWordTimeOffsets"), ::OpenAPI::toJsonValue(m_enable_word_time_offsets));
    }
    if (m_encoding_isSet) {
        obj.insert(QString("encoding"), ::OpenAPI::toJsonValue(m_encoding));
    }
    if (m_language_code_isSet) {
        obj.insert(QString("languageCode"), ::OpenAPI::toJsonValue(m_language_code));
    }
    if (m_max_alternatives_isSet) {
        obj.insert(QString("maxAlternatives"), ::OpenAPI::toJsonValue(m_max_alternatives));
    }
    if (m_metadata.isSet()) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_model_isSet) {
        obj.insert(QString("model"), ::OpenAPI::toJsonValue(m_model));
    }
    if (m_profanity_filter_isSet) {
        obj.insert(QString("profanityFilter"), ::OpenAPI::toJsonValue(m_profanity_filter));
    }
    if (m_sample_rate_hertz_isSet) {
        obj.insert(QString("sampleRateHertz"), ::OpenAPI::toJsonValue(m_sample_rate_hertz));
    }
    if (m_speech_contexts.size() > 0) {
        obj.insert(QString("speechContexts"), ::OpenAPI::toJsonValue(m_speech_contexts));
    }
    if (m_transcript_normalization.isSet()) {
        obj.insert(QString("transcriptNormalization"), ::OpenAPI::toJsonValue(m_transcript_normalization));
    }
    if (m_use_enhanced_isSet) {
        obj.insert(QString("useEnhanced"), ::OpenAPI::toJsonValue(m_use_enhanced));
    }
    return obj;
}

OAISpeechAdaptation OAIRecognitionConfig::getAdaptation() const {
    return m_adaptation;
}
void OAIRecognitionConfig::setAdaptation(const OAISpeechAdaptation &adaptation) {
    m_adaptation = adaptation;
    m_adaptation_isSet = true;
}

bool OAIRecognitionConfig::is_adaptation_Set() const{
    return m_adaptation_isSet;
}

bool OAIRecognitionConfig::is_adaptation_Valid() const{
    return m_adaptation_isValid;
}

QList<QString> OAIRecognitionConfig::getAlternativeLanguageCodes() const {
    return m_alternative_language_codes;
}
void OAIRecognitionConfig::setAlternativeLanguageCodes(const QList<QString> &alternative_language_codes) {
    m_alternative_language_codes = alternative_language_codes;
    m_alternative_language_codes_isSet = true;
}

bool OAIRecognitionConfig::is_alternative_language_codes_Set() const{
    return m_alternative_language_codes_isSet;
}

bool OAIRecognitionConfig::is_alternative_language_codes_Valid() const{
    return m_alternative_language_codes_isValid;
}

qint32 OAIRecognitionConfig::getAudioChannelCount() const {
    return m_audio_channel_count;
}
void OAIRecognitionConfig::setAudioChannelCount(const qint32 &audio_channel_count) {
    m_audio_channel_count = audio_channel_count;
    m_audio_channel_count_isSet = true;
}

bool OAIRecognitionConfig::is_audio_channel_count_Set() const{
    return m_audio_channel_count_isSet;
}

bool OAIRecognitionConfig::is_audio_channel_count_Valid() const{
    return m_audio_channel_count_isValid;
}

OAISpeakerDiarizationConfig OAIRecognitionConfig::getDiarizationConfig() const {
    return m_diarization_config;
}
void OAIRecognitionConfig::setDiarizationConfig(const OAISpeakerDiarizationConfig &diarization_config) {
    m_diarization_config = diarization_config;
    m_diarization_config_isSet = true;
}

bool OAIRecognitionConfig::is_diarization_config_Set() const{
    return m_diarization_config_isSet;
}

bool OAIRecognitionConfig::is_diarization_config_Valid() const{
    return m_diarization_config_isValid;
}

qint32 OAIRecognitionConfig::getDiarizationSpeakerCount() const {
    return m_diarization_speaker_count;
}
void OAIRecognitionConfig::setDiarizationSpeakerCount(const qint32 &diarization_speaker_count) {
    m_diarization_speaker_count = diarization_speaker_count;
    m_diarization_speaker_count_isSet = true;
}

bool OAIRecognitionConfig::is_diarization_speaker_count_Set() const{
    return m_diarization_speaker_count_isSet;
}

bool OAIRecognitionConfig::is_diarization_speaker_count_Valid() const{
    return m_diarization_speaker_count_isValid;
}

bool OAIRecognitionConfig::isEnableAutomaticPunctuation() const {
    return m_enable_automatic_punctuation;
}
void OAIRecognitionConfig::setEnableAutomaticPunctuation(const bool &enable_automatic_punctuation) {
    m_enable_automatic_punctuation = enable_automatic_punctuation;
    m_enable_automatic_punctuation_isSet = true;
}

bool OAIRecognitionConfig::is_enable_automatic_punctuation_Set() const{
    return m_enable_automatic_punctuation_isSet;
}

bool OAIRecognitionConfig::is_enable_automatic_punctuation_Valid() const{
    return m_enable_automatic_punctuation_isValid;
}

bool OAIRecognitionConfig::isEnableSeparateRecognitionPerChannel() const {
    return m_enable_separate_recognition_per_channel;
}
void OAIRecognitionConfig::setEnableSeparateRecognitionPerChannel(const bool &enable_separate_recognition_per_channel) {
    m_enable_separate_recognition_per_channel = enable_separate_recognition_per_channel;
    m_enable_separate_recognition_per_channel_isSet = true;
}

bool OAIRecognitionConfig::is_enable_separate_recognition_per_channel_Set() const{
    return m_enable_separate_recognition_per_channel_isSet;
}

bool OAIRecognitionConfig::is_enable_separate_recognition_per_channel_Valid() const{
    return m_enable_separate_recognition_per_channel_isValid;
}

bool OAIRecognitionConfig::isEnableSpeakerDiarization() const {
    return m_enable_speaker_diarization;
}
void OAIRecognitionConfig::setEnableSpeakerDiarization(const bool &enable_speaker_diarization) {
    m_enable_speaker_diarization = enable_speaker_diarization;
    m_enable_speaker_diarization_isSet = true;
}

bool OAIRecognitionConfig::is_enable_speaker_diarization_Set() const{
    return m_enable_speaker_diarization_isSet;
}

bool OAIRecognitionConfig::is_enable_speaker_diarization_Valid() const{
    return m_enable_speaker_diarization_isValid;
}

bool OAIRecognitionConfig::isEnableSpokenEmojis() const {
    return m_enable_spoken_emojis;
}
void OAIRecognitionConfig::setEnableSpokenEmojis(const bool &enable_spoken_emojis) {
    m_enable_spoken_emojis = enable_spoken_emojis;
    m_enable_spoken_emojis_isSet = true;
}

bool OAIRecognitionConfig::is_enable_spoken_emojis_Set() const{
    return m_enable_spoken_emojis_isSet;
}

bool OAIRecognitionConfig::is_enable_spoken_emojis_Valid() const{
    return m_enable_spoken_emojis_isValid;
}

bool OAIRecognitionConfig::isEnableSpokenPunctuation() const {
    return m_enable_spoken_punctuation;
}
void OAIRecognitionConfig::setEnableSpokenPunctuation(const bool &enable_spoken_punctuation) {
    m_enable_spoken_punctuation = enable_spoken_punctuation;
    m_enable_spoken_punctuation_isSet = true;
}

bool OAIRecognitionConfig::is_enable_spoken_punctuation_Set() const{
    return m_enable_spoken_punctuation_isSet;
}

bool OAIRecognitionConfig::is_enable_spoken_punctuation_Valid() const{
    return m_enable_spoken_punctuation_isValid;
}

bool OAIRecognitionConfig::isEnableWordConfidence() const {
    return m_enable_word_confidence;
}
void OAIRecognitionConfig::setEnableWordConfidence(const bool &enable_word_confidence) {
    m_enable_word_confidence = enable_word_confidence;
    m_enable_word_confidence_isSet = true;
}

bool OAIRecognitionConfig::is_enable_word_confidence_Set() const{
    return m_enable_word_confidence_isSet;
}

bool OAIRecognitionConfig::is_enable_word_confidence_Valid() const{
    return m_enable_word_confidence_isValid;
}

bool OAIRecognitionConfig::isEnableWordTimeOffsets() const {
    return m_enable_word_time_offsets;
}
void OAIRecognitionConfig::setEnableWordTimeOffsets(const bool &enable_word_time_offsets) {
    m_enable_word_time_offsets = enable_word_time_offsets;
    m_enable_word_time_offsets_isSet = true;
}

bool OAIRecognitionConfig::is_enable_word_time_offsets_Set() const{
    return m_enable_word_time_offsets_isSet;
}

bool OAIRecognitionConfig::is_enable_word_time_offsets_Valid() const{
    return m_enable_word_time_offsets_isValid;
}

QString OAIRecognitionConfig::getEncoding() const {
    return m_encoding;
}
void OAIRecognitionConfig::setEncoding(const QString &encoding) {
    m_encoding = encoding;
    m_encoding_isSet = true;
}

bool OAIRecognitionConfig::is_encoding_Set() const{
    return m_encoding_isSet;
}

bool OAIRecognitionConfig::is_encoding_Valid() const{
    return m_encoding_isValid;
}

QString OAIRecognitionConfig::getLanguageCode() const {
    return m_language_code;
}
void OAIRecognitionConfig::setLanguageCode(const QString &language_code) {
    m_language_code = language_code;
    m_language_code_isSet = true;
}

bool OAIRecognitionConfig::is_language_code_Set() const{
    return m_language_code_isSet;
}

bool OAIRecognitionConfig::is_language_code_Valid() const{
    return m_language_code_isValid;
}

qint32 OAIRecognitionConfig::getMaxAlternatives() const {
    return m_max_alternatives;
}
void OAIRecognitionConfig::setMaxAlternatives(const qint32 &max_alternatives) {
    m_max_alternatives = max_alternatives;
    m_max_alternatives_isSet = true;
}

bool OAIRecognitionConfig::is_max_alternatives_Set() const{
    return m_max_alternatives_isSet;
}

bool OAIRecognitionConfig::is_max_alternatives_Valid() const{
    return m_max_alternatives_isValid;
}

OAIRecognitionMetadata OAIRecognitionConfig::getMetadata() const {
    return m_metadata;
}
void OAIRecognitionConfig::setMetadata(const OAIRecognitionMetadata &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAIRecognitionConfig::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAIRecognitionConfig::is_metadata_Valid() const{
    return m_metadata_isValid;
}

QString OAIRecognitionConfig::getModel() const {
    return m_model;
}
void OAIRecognitionConfig::setModel(const QString &model) {
    m_model = model;
    m_model_isSet = true;
}

bool OAIRecognitionConfig::is_model_Set() const{
    return m_model_isSet;
}

bool OAIRecognitionConfig::is_model_Valid() const{
    return m_model_isValid;
}

bool OAIRecognitionConfig::isProfanityFilter() const {
    return m_profanity_filter;
}
void OAIRecognitionConfig::setProfanityFilter(const bool &profanity_filter) {
    m_profanity_filter = profanity_filter;
    m_profanity_filter_isSet = true;
}

bool OAIRecognitionConfig::is_profanity_filter_Set() const{
    return m_profanity_filter_isSet;
}

bool OAIRecognitionConfig::is_profanity_filter_Valid() const{
    return m_profanity_filter_isValid;
}

qint32 OAIRecognitionConfig::getSampleRateHertz() const {
    return m_sample_rate_hertz;
}
void OAIRecognitionConfig::setSampleRateHertz(const qint32 &sample_rate_hertz) {
    m_sample_rate_hertz = sample_rate_hertz;
    m_sample_rate_hertz_isSet = true;
}

bool OAIRecognitionConfig::is_sample_rate_hertz_Set() const{
    return m_sample_rate_hertz_isSet;
}

bool OAIRecognitionConfig::is_sample_rate_hertz_Valid() const{
    return m_sample_rate_hertz_isValid;
}

QList<OAISpeechContext> OAIRecognitionConfig::getSpeechContexts() const {
    return m_speech_contexts;
}
void OAIRecognitionConfig::setSpeechContexts(const QList<OAISpeechContext> &speech_contexts) {
    m_speech_contexts = speech_contexts;
    m_speech_contexts_isSet = true;
}

bool OAIRecognitionConfig::is_speech_contexts_Set() const{
    return m_speech_contexts_isSet;
}

bool OAIRecognitionConfig::is_speech_contexts_Valid() const{
    return m_speech_contexts_isValid;
}

OAITranscriptNormalization OAIRecognitionConfig::getTranscriptNormalization() const {
    return m_transcript_normalization;
}
void OAIRecognitionConfig::setTranscriptNormalization(const OAITranscriptNormalization &transcript_normalization) {
    m_transcript_normalization = transcript_normalization;
    m_transcript_normalization_isSet = true;
}

bool OAIRecognitionConfig::is_transcript_normalization_Set() const{
    return m_transcript_normalization_isSet;
}

bool OAIRecognitionConfig::is_transcript_normalization_Valid() const{
    return m_transcript_normalization_isValid;
}

bool OAIRecognitionConfig::isUseEnhanced() const {
    return m_use_enhanced;
}
void OAIRecognitionConfig::setUseEnhanced(const bool &use_enhanced) {
    m_use_enhanced = use_enhanced;
    m_use_enhanced_isSet = true;
}

bool OAIRecognitionConfig::is_use_enhanced_Set() const{
    return m_use_enhanced_isSet;
}

bool OAIRecognitionConfig::is_use_enhanced_Valid() const{
    return m_use_enhanced_isValid;
}

bool OAIRecognitionConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adaptation.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_alternative_language_codes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_audio_channel_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_diarization_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_diarization_speaker_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_automatic_punctuation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_separate_recognition_per_channel_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_speaker_diarization_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_spoken_emojis_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_spoken_punctuation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_word_confidence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_word_time_offsets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encoding_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_language_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_alternatives_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_model_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_profanity_filter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sample_rate_hertz_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_speech_contexts.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcript_normalization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_use_enhanced_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRecognitionConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
