/*
 * Google Civic Information API
 * Provides polling places, early vote locations, contest data, election officials, and government representatives for U.S. residential addresses.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AdministrationRegion;
import org.openapitools.client.model.Contest;
import org.openapitools.client.model.Election;
import org.openapitools.client.model.PollingLocation;
import org.openapitools.client.model.Precinct;
import org.openapitools.client.model.SimpleAddressType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The result of a voter info lookup query.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:56.745680-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VoterInfoResponse {
  public static final String SERIALIZED_NAME_CONTESTS = "contests";
  @SerializedName(SERIALIZED_NAME_CONTESTS)
  private List<Contest> contests = new ArrayList<>();

  public static final String SERIALIZED_NAME_DROP_OFF_LOCATIONS = "dropOffLocations";
  @SerializedName(SERIALIZED_NAME_DROP_OFF_LOCATIONS)
  private List<PollingLocation> dropOffLocations = new ArrayList<>();

  public static final String SERIALIZED_NAME_EARLY_VOTE_SITES = "earlyVoteSites";
  @SerializedName(SERIALIZED_NAME_EARLY_VOTE_SITES)
  private List<PollingLocation> earlyVoteSites = new ArrayList<>();

  public static final String SERIALIZED_NAME_ELECTION = "election";
  @SerializedName(SERIALIZED_NAME_ELECTION)
  private Election election;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "civicinfo#voterInfoResponse";

  public static final String SERIALIZED_NAME_MAIL_ONLY = "mailOnly";
  @SerializedName(SERIALIZED_NAME_MAIL_ONLY)
  private Boolean mailOnly;

  public static final String SERIALIZED_NAME_NORMALIZED_INPUT = "normalizedInput";
  @SerializedName(SERIALIZED_NAME_NORMALIZED_INPUT)
  private SimpleAddressType normalizedInput;

  public static final String SERIALIZED_NAME_OTHER_ELECTIONS = "otherElections";
  @SerializedName(SERIALIZED_NAME_OTHER_ELECTIONS)
  private List<Election> otherElections = new ArrayList<>();

  public static final String SERIALIZED_NAME_POLLING_LOCATIONS = "pollingLocations";
  @SerializedName(SERIALIZED_NAME_POLLING_LOCATIONS)
  private List<PollingLocation> pollingLocations = new ArrayList<>();

  public static final String SERIALIZED_NAME_PRECINCT_ID = "precinctId";
  @SerializedName(SERIALIZED_NAME_PRECINCT_ID)
  private String precinctId;

  public static final String SERIALIZED_NAME_PRECINCTS = "precincts";
  @SerializedName(SERIALIZED_NAME_PRECINCTS)
  private List<Precinct> precincts = new ArrayList<>();

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private List<AdministrationRegion> state = new ArrayList<>();

  public VoterInfoResponse() {
  }

  public VoterInfoResponse contests(List<Contest> contests) {
    this.contests = contests;
    return this;
  }

  public VoterInfoResponse addContestsItem(Contest contestsItem) {
    if (this.contests == null) {
      this.contests = new ArrayList<>();
    }
    this.contests.add(contestsItem);
    return this;
  }

  /**
   * Contests that will appear on the voter&#39;s ballot.
   * @return contests
   */
  @javax.annotation.Nullable
  public List<Contest> getContests() {
    return contests;
  }

  public void setContests(List<Contest> contests) {
    this.contests = contests;
  }


  public VoterInfoResponse dropOffLocations(List<PollingLocation> dropOffLocations) {
    this.dropOffLocations = dropOffLocations;
    return this;
  }

  public VoterInfoResponse addDropOffLocationsItem(PollingLocation dropOffLocationsItem) {
    if (this.dropOffLocations == null) {
      this.dropOffLocations = new ArrayList<>();
    }
    this.dropOffLocations.add(dropOffLocationsItem);
    return this;
  }

  /**
   * Locations where a voter is eligible to drop off a completed ballot. The voter must have received and completed a ballot prior to arriving at the location. The location may not have ballots available on the premises. These locations could be open on or before election day as indicated in the pollingHours field.
   * @return dropOffLocations
   */
  @javax.annotation.Nullable
  public List<PollingLocation> getDropOffLocations() {
    return dropOffLocations;
  }

  public void setDropOffLocations(List<PollingLocation> dropOffLocations) {
    this.dropOffLocations = dropOffLocations;
  }


  public VoterInfoResponse earlyVoteSites(List<PollingLocation> earlyVoteSites) {
    this.earlyVoteSites = earlyVoteSites;
    return this;
  }

  public VoterInfoResponse addEarlyVoteSitesItem(PollingLocation earlyVoteSitesItem) {
    if (this.earlyVoteSites == null) {
      this.earlyVoteSites = new ArrayList<>();
    }
    this.earlyVoteSites.add(earlyVoteSitesItem);
    return this;
  }

  /**
   * Locations where the voter is eligible to vote early, prior to election day.
   * @return earlyVoteSites
   */
  @javax.annotation.Nullable
  public List<PollingLocation> getEarlyVoteSites() {
    return earlyVoteSites;
  }

  public void setEarlyVoteSites(List<PollingLocation> earlyVoteSites) {
    this.earlyVoteSites = earlyVoteSites;
  }


  public VoterInfoResponse election(Election election) {
    this.election = election;
    return this;
  }

  /**
   * Get election
   * @return election
   */
  @javax.annotation.Nullable
  public Election getElection() {
    return election;
  }

  public void setElection(Election election) {
    this.election = election;
  }


  public VoterInfoResponse kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Identifies what kind of resource this is. Value: the fixed string \&quot;civicinfo#voterInfoResponse\&quot;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public VoterInfoResponse mailOnly(Boolean mailOnly) {
    this.mailOnly = mailOnly;
    return this;
  }

  /**
   * Specifies whether voters in the precinct vote only by mailing their ballots (with the possible option of dropping off their ballots as well).
   * @return mailOnly
   */
  @javax.annotation.Nullable
  public Boolean getMailOnly() {
    return mailOnly;
  }

  public void setMailOnly(Boolean mailOnly) {
    this.mailOnly = mailOnly;
  }


  public VoterInfoResponse normalizedInput(SimpleAddressType normalizedInput) {
    this.normalizedInput = normalizedInput;
    return this;
  }

  /**
   * Get normalizedInput
   * @return normalizedInput
   */
  @javax.annotation.Nullable
  public SimpleAddressType getNormalizedInput() {
    return normalizedInput;
  }

  public void setNormalizedInput(SimpleAddressType normalizedInput) {
    this.normalizedInput = normalizedInput;
  }


  public VoterInfoResponse otherElections(List<Election> otherElections) {
    this.otherElections = otherElections;
    return this;
  }

  public VoterInfoResponse addOtherElectionsItem(Election otherElectionsItem) {
    if (this.otherElections == null) {
      this.otherElections = new ArrayList<>();
    }
    this.otherElections.add(otherElectionsItem);
    return this;
  }

  /**
   * When there are multiple elections for a voter address, the otherElections field is populated in the API response and there are two possibilities: 1. If the earliest election is not the intended election, specify the election ID of the desired election in a second API request using the electionId field. 2. If these elections occur on the same day, the API doesn?t return any polling location, contest, or election official information to ensure that an additional query is made. For user-facing applications, we recommend displaying these elections to the user to disambiguate. A second API request using the electionId field should be made for the election that is relevant to the user.
   * @return otherElections
   */
  @javax.annotation.Nullable
  public List<Election> getOtherElections() {
    return otherElections;
  }

  public void setOtherElections(List<Election> otherElections) {
    this.otherElections = otherElections;
  }


  public VoterInfoResponse pollingLocations(List<PollingLocation> pollingLocations) {
    this.pollingLocations = pollingLocations;
    return this;
  }

  public VoterInfoResponse addPollingLocationsItem(PollingLocation pollingLocationsItem) {
    if (this.pollingLocations == null) {
      this.pollingLocations = new ArrayList<>();
    }
    this.pollingLocations.add(pollingLocationsItem);
    return this;
  }

  /**
   * Locations where the voter is eligible to vote on election day.
   * @return pollingLocations
   */
  @javax.annotation.Nullable
  public List<PollingLocation> getPollingLocations() {
    return pollingLocations;
  }

  public void setPollingLocations(List<PollingLocation> pollingLocations) {
    this.pollingLocations = pollingLocations;
  }


  public VoterInfoResponse precinctId(String precinctId) {
    this.precinctId = precinctId;
    return this;
  }

  /**
   * Get precinctId
   * @return precinctId
   */
  @javax.annotation.Nullable
  public String getPrecinctId() {
    return precinctId;
  }

  public void setPrecinctId(String precinctId) {
    this.precinctId = precinctId;
  }


  public VoterInfoResponse precincts(List<Precinct> precincts) {
    this.precincts = precincts;
    return this;
  }

  public VoterInfoResponse addPrecinctsItem(Precinct precinctsItem) {
    if (this.precincts == null) {
      this.precincts = new ArrayList<>();
    }
    this.precincts.add(precinctsItem);
    return this;
  }

  /**
   * The precincts that match this voter&#39;s address. Will only be returned for project IDs which have been allowlisted as \&quot;partner projects\&quot;.
   * @return precincts
   */
  @javax.annotation.Nullable
  public List<Precinct> getPrecincts() {
    return precincts;
  }

  public void setPrecincts(List<Precinct> precincts) {
    this.precincts = precincts;
  }


  public VoterInfoResponse state(List<AdministrationRegion> state) {
    this.state = state;
    return this;
  }

  public VoterInfoResponse addStateItem(AdministrationRegion stateItem) {
    if (this.state == null) {
      this.state = new ArrayList<>();
    }
    this.state.add(stateItem);
    return this;
  }

  /**
   * Local Election Information for the state that the voter votes in. For the US, there will only be one element in this array.
   * @return state
   */
  @javax.annotation.Nullable
  public List<AdministrationRegion> getState() {
    return state;
  }

  public void setState(List<AdministrationRegion> state) {
    this.state = state;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VoterInfoResponse voterInfoResponse = (VoterInfoResponse) o;
    return Objects.equals(this.contests, voterInfoResponse.contests) &&
        Objects.equals(this.dropOffLocations, voterInfoResponse.dropOffLocations) &&
        Objects.equals(this.earlyVoteSites, voterInfoResponse.earlyVoteSites) &&
        Objects.equals(this.election, voterInfoResponse.election) &&
        Objects.equals(this.kind, voterInfoResponse.kind) &&
        Objects.equals(this.mailOnly, voterInfoResponse.mailOnly) &&
        Objects.equals(this.normalizedInput, voterInfoResponse.normalizedInput) &&
        Objects.equals(this.otherElections, voterInfoResponse.otherElections) &&
        Objects.equals(this.pollingLocations, voterInfoResponse.pollingLocations) &&
        Objects.equals(this.precinctId, voterInfoResponse.precinctId) &&
        Objects.equals(this.precincts, voterInfoResponse.precincts) &&
        Objects.equals(this.state, voterInfoResponse.state);
  }

  @Override
  public int hashCode() {
    return Objects.hash(contests, dropOffLocations, earlyVoteSites, election, kind, mailOnly, normalizedInput, otherElections, pollingLocations, precinctId, precincts, state);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VoterInfoResponse {\n");
    sb.append("    contests: ").append(toIndentedString(contests)).append("\n");
    sb.append("    dropOffLocations: ").append(toIndentedString(dropOffLocations)).append("\n");
    sb.append("    earlyVoteSites: ").append(toIndentedString(earlyVoteSites)).append("\n");
    sb.append("    election: ").append(toIndentedString(election)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    mailOnly: ").append(toIndentedString(mailOnly)).append("\n");
    sb.append("    normalizedInput: ").append(toIndentedString(normalizedInput)).append("\n");
    sb.append("    otherElections: ").append(toIndentedString(otherElections)).append("\n");
    sb.append("    pollingLocations: ").append(toIndentedString(pollingLocations)).append("\n");
    sb.append("    precinctId: ").append(toIndentedString(precinctId)).append("\n");
    sb.append("    precincts: ").append(toIndentedString(precincts)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("contests");
    openapiFields.add("dropOffLocations");
    openapiFields.add("earlyVoteSites");
    openapiFields.add("election");
    openapiFields.add("kind");
    openapiFields.add("mailOnly");
    openapiFields.add("normalizedInput");
    openapiFields.add("otherElections");
    openapiFields.add("pollingLocations");
    openapiFields.add("precinctId");
    openapiFields.add("precincts");
    openapiFields.add("state");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VoterInfoResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VoterInfoResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VoterInfoResponse is not found in the empty JSON string", VoterInfoResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VoterInfoResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VoterInfoResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("contests") != null && !jsonObj.get("contests").isJsonNull()) {
        JsonArray jsonArraycontests = jsonObj.getAsJsonArray("contests");
        if (jsonArraycontests != null) {
          // ensure the json data is an array
          if (!jsonObj.get("contests").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `contests` to be an array in the JSON string but got `%s`", jsonObj.get("contests").toString()));
          }

          // validate the optional field `contests` (array)
          for (int i = 0; i < jsonArraycontests.size(); i++) {
            Contest.validateJsonElement(jsonArraycontests.get(i));
          };
        }
      }
      if (jsonObj.get("dropOffLocations") != null && !jsonObj.get("dropOffLocations").isJsonNull()) {
        JsonArray jsonArraydropOffLocations = jsonObj.getAsJsonArray("dropOffLocations");
        if (jsonArraydropOffLocations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dropOffLocations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dropOffLocations` to be an array in the JSON string but got `%s`", jsonObj.get("dropOffLocations").toString()));
          }

          // validate the optional field `dropOffLocations` (array)
          for (int i = 0; i < jsonArraydropOffLocations.size(); i++) {
            PollingLocation.validateJsonElement(jsonArraydropOffLocations.get(i));
          };
        }
      }
      if (jsonObj.get("earlyVoteSites") != null && !jsonObj.get("earlyVoteSites").isJsonNull()) {
        JsonArray jsonArrayearlyVoteSites = jsonObj.getAsJsonArray("earlyVoteSites");
        if (jsonArrayearlyVoteSites != null) {
          // ensure the json data is an array
          if (!jsonObj.get("earlyVoteSites").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `earlyVoteSites` to be an array in the JSON string but got `%s`", jsonObj.get("earlyVoteSites").toString()));
          }

          // validate the optional field `earlyVoteSites` (array)
          for (int i = 0; i < jsonArrayearlyVoteSites.size(); i++) {
            PollingLocation.validateJsonElement(jsonArrayearlyVoteSites.get(i));
          };
        }
      }
      // validate the optional field `election`
      if (jsonObj.get("election") != null && !jsonObj.get("election").isJsonNull()) {
        Election.validateJsonElement(jsonObj.get("election"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `normalizedInput`
      if (jsonObj.get("normalizedInput") != null && !jsonObj.get("normalizedInput").isJsonNull()) {
        SimpleAddressType.validateJsonElement(jsonObj.get("normalizedInput"));
      }
      if (jsonObj.get("otherElections") != null && !jsonObj.get("otherElections").isJsonNull()) {
        JsonArray jsonArrayotherElections = jsonObj.getAsJsonArray("otherElections");
        if (jsonArrayotherElections != null) {
          // ensure the json data is an array
          if (!jsonObj.get("otherElections").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `otherElections` to be an array in the JSON string but got `%s`", jsonObj.get("otherElections").toString()));
          }

          // validate the optional field `otherElections` (array)
          for (int i = 0; i < jsonArrayotherElections.size(); i++) {
            Election.validateJsonElement(jsonArrayotherElections.get(i));
          };
        }
      }
      if (jsonObj.get("pollingLocations") != null && !jsonObj.get("pollingLocations").isJsonNull()) {
        JsonArray jsonArraypollingLocations = jsonObj.getAsJsonArray("pollingLocations");
        if (jsonArraypollingLocations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pollingLocations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pollingLocations` to be an array in the JSON string but got `%s`", jsonObj.get("pollingLocations").toString()));
          }

          // validate the optional field `pollingLocations` (array)
          for (int i = 0; i < jsonArraypollingLocations.size(); i++) {
            PollingLocation.validateJsonElement(jsonArraypollingLocations.get(i));
          };
        }
      }
      if ((jsonObj.get("precinctId") != null && !jsonObj.get("precinctId").isJsonNull()) && !jsonObj.get("precinctId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `precinctId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("precinctId").toString()));
      }
      if (jsonObj.get("precincts") != null && !jsonObj.get("precincts").isJsonNull()) {
        JsonArray jsonArrayprecincts = jsonObj.getAsJsonArray("precincts");
        if (jsonArrayprecincts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("precincts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `precincts` to be an array in the JSON string but got `%s`", jsonObj.get("precincts").toString()));
          }

          // validate the optional field `precincts` (array)
          for (int i = 0; i < jsonArrayprecincts.size(); i++) {
            Precinct.validateJsonElement(jsonArrayprecincts.get(i));
          };
        }
      }
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        JsonArray jsonArraystate = jsonObj.getAsJsonArray("state");
        if (jsonArraystate != null) {
          // ensure the json data is an array
          if (!jsonObj.get("state").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `state` to be an array in the JSON string but got `%s`", jsonObj.get("state").toString()));
          }

          // validate the optional field `state` (array)
          for (int i = 0; i < jsonArraystate.size(); i++) {
            AdministrationRegion.validateJsonElement(jsonArraystate.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VoterInfoResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VoterInfoResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VoterInfoResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VoterInfoResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<VoterInfoResponse>() {
           @Override
           public void write(JsonWriter out, VoterInfoResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VoterInfoResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VoterInfoResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VoterInfoResponse
   * @throws IOException if the JSON string is invalid with respect to VoterInfoResponse
   */
  public static VoterInfoResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VoterInfoResponse.class);
  }

  /**
   * Convert an instance of VoterInfoResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

