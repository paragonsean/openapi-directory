/*
 * Network Security API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.GoogleCloudNetworksecurityV1CertificateProvider;
import org.openapitools.client.model.MTLSPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ServerTlsPolicy is a resource that specifies how a server should authenticate incoming requests. This resource itself does not affect configuration unless it is attached to a target HTTPS proxy or endpoint config selector resource. ServerTlsPolicy in the form accepted by external HTTPS load balancers can be attached only to TargetHttpsProxy with an &#x60;EXTERNAL&#x60; or &#x60;EXTERNAL_MANAGED&#x60; load balancing scheme. Traffic Director compatible ServerTlsPolicies can be attached to EndpointPolicy and TargetHttpsProxy with Traffic Director &#x60;INTERNAL_SELF_MANAGED&#x60; load balancing scheme.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:15.829513-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ServerTlsPolicy {
  public static final String SERIALIZED_NAME_ALLOW_OPEN = "allowOpen";
  @SerializedName(SERIALIZED_NAME_ALLOW_OPEN)
  private Boolean allowOpen;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MTLS_POLICY = "mtlsPolicy";
  @SerializedName(SERIALIZED_NAME_MTLS_POLICY)
  private MTLSPolicy mtlsPolicy;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SERVER_CERTIFICATE = "serverCertificate";
  @SerializedName(SERIALIZED_NAME_SERVER_CERTIFICATE)
  private GoogleCloudNetworksecurityV1CertificateProvider serverCertificate;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public ServerTlsPolicy() {
  }

  public ServerTlsPolicy(
     String createTime, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.updateTime = updateTime;
  }

  public ServerTlsPolicy allowOpen(Boolean allowOpen) {
    this.allowOpen = allowOpen;
    return this;
  }

  /**
   * This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies. Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if &#x60;allow_open&#x60; and &#x60;mtls_policy&#x60; are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
   * @return allowOpen
   */
  @javax.annotation.Nullable
  public Boolean getAllowOpen() {
    return allowOpen;
  }

  public void setAllowOpen(Boolean allowOpen) {
    this.allowOpen = allowOpen;
  }


  /**
   * Output only. The timestamp when the resource was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public ServerTlsPolicy description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Free-text description of the resource.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ServerTlsPolicy labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public ServerTlsPolicy putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Set of label tags associated with the resource.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public ServerTlsPolicy mtlsPolicy(MTLSPolicy mtlsPolicy) {
    this.mtlsPolicy = mtlsPolicy;
    return this;
  }

  /**
   * Get mtlsPolicy
   * @return mtlsPolicy
   */
  @javax.annotation.Nullable
  public MTLSPolicy getMtlsPolicy() {
    return mtlsPolicy;
  }

  public void setMtlsPolicy(MTLSPolicy mtlsPolicy) {
    this.mtlsPolicy = mtlsPolicy;
  }


  public ServerTlsPolicy name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. Name of the ServerTlsPolicy resource. It matches the pattern &#x60;projects/_*_/locations/{location}/serverTlsPolicies/{server_tls_policy}&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ServerTlsPolicy serverCertificate(GoogleCloudNetworksecurityV1CertificateProvider serverCertificate) {
    this.serverCertificate = serverCertificate;
    return this;
  }

  /**
   * Get serverCertificate
   * @return serverCertificate
   */
  @javax.annotation.Nullable
  public GoogleCloudNetworksecurityV1CertificateProvider getServerCertificate() {
    return serverCertificate;
  }

  public void setServerCertificate(GoogleCloudNetworksecurityV1CertificateProvider serverCertificate) {
    this.serverCertificate = serverCertificate;
  }


  /**
   * Output only. The timestamp when the resource was updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServerTlsPolicy serverTlsPolicy = (ServerTlsPolicy) o;
    return Objects.equals(this.allowOpen, serverTlsPolicy.allowOpen) &&
        Objects.equals(this.createTime, serverTlsPolicy.createTime) &&
        Objects.equals(this.description, serverTlsPolicy.description) &&
        Objects.equals(this.labels, serverTlsPolicy.labels) &&
        Objects.equals(this.mtlsPolicy, serverTlsPolicy.mtlsPolicy) &&
        Objects.equals(this.name, serverTlsPolicy.name) &&
        Objects.equals(this.serverCertificate, serverTlsPolicy.serverCertificate) &&
        Objects.equals(this.updateTime, serverTlsPolicy.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowOpen, createTime, description, labels, mtlsPolicy, name, serverCertificate, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServerTlsPolicy {\n");
    sb.append("    allowOpen: ").append(toIndentedString(allowOpen)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    mtlsPolicy: ").append(toIndentedString(mtlsPolicy)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    serverCertificate: ").append(toIndentedString(serverCertificate)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowOpen");
    openapiFields.add("createTime");
    openapiFields.add("description");
    openapiFields.add("labels");
    openapiFields.add("mtlsPolicy");
    openapiFields.add("name");
    openapiFields.add("serverCertificate");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ServerTlsPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ServerTlsPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServerTlsPolicy is not found in the empty JSON string", ServerTlsPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ServerTlsPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ServerTlsPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `mtlsPolicy`
      if (jsonObj.get("mtlsPolicy") != null && !jsonObj.get("mtlsPolicy").isJsonNull()) {
        MTLSPolicy.validateJsonElement(jsonObj.get("mtlsPolicy"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `serverCertificate`
      if (jsonObj.get("serverCertificate") != null && !jsonObj.get("serverCertificate").isJsonNull()) {
        GoogleCloudNetworksecurityV1CertificateProvider.validateJsonElement(jsonObj.get("serverCertificate"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ServerTlsPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ServerTlsPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ServerTlsPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ServerTlsPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ServerTlsPolicy>() {
           @Override
           public void write(JsonWriter out, ServerTlsPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ServerTlsPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ServerTlsPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ServerTlsPolicy
   * @throws IOException if the JSON string is invalid with respect to ServerTlsPolicy
   */
  public static ServerTlsPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServerTlsPolicy.class);
  }

  /**
   * Convert an instance of ServerTlsPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

