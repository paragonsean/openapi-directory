# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.function_mock import FunctionMock
from openapi_server import util


class TestCase(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, expectation: str=None, expression_report_level: str=None, function_mocks: List[FunctionMock]=None, path_encoding: str=None, request: object=None, resource: object=None):
        """TestCase - a model defined in OpenAPI

        :param expectation: The expectation of this TestCase.
        :param expression_report_level: The expression_report_level of this TestCase.
        :param function_mocks: The function_mocks of this TestCase.
        :param path_encoding: The path_encoding of this TestCase.
        :param request: The request of this TestCase.
        :param resource: The resource of this TestCase.
        """
        self.openapi_types = {
            'expectation': str,
            'expression_report_level': str,
            'function_mocks': List[FunctionMock],
            'path_encoding': str,
            'request': object,
            'resource': object
        }

        self.attribute_map = {
            'expectation': 'expectation',
            'expression_report_level': 'expressionReportLevel',
            'function_mocks': 'functionMocks',
            'path_encoding': 'pathEncoding',
            'request': 'request',
            'resource': 'resource'
        }

        self._expectation = expectation
        self._expression_report_level = expression_report_level
        self._function_mocks = function_mocks
        self._path_encoding = path_encoding
        self._request = request
        self._resource = resource

    @classmethod
    def from_dict(cls, dikt: dict) -> 'TestCase':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The TestCase of this TestCase.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def expectation(self):
        """Gets the expectation of this TestCase.

        Test expectation.

        :return: The expectation of this TestCase.
        :rtype: str
        """
        return self._expectation

    @expectation.setter
    def expectation(self, expectation):
        """Sets the expectation of this TestCase.

        Test expectation.

        :param expectation: The expectation of this TestCase.
        :type expectation: str
        """
        allowed_values = ["EXPECTATION_UNSPECIFIED", "ALLOW", "DENY"]  # noqa: E501
        if expectation not in allowed_values:
            raise ValueError(
                "Invalid value for `expectation` ({0}), must be one of {1}"
                .format(expectation, allowed_values)
            )

        self._expectation = expectation

    @property
    def expression_report_level(self):
        """Gets the expression_report_level of this TestCase.

        Specifies what should be included in the response.

        :return: The expression_report_level of this TestCase.
        :rtype: str
        """
        return self._expression_report_level

    @expression_report_level.setter
    def expression_report_level(self, expression_report_level):
        """Sets the expression_report_level of this TestCase.

        Specifies what should be included in the response.

        :param expression_report_level: The expression_report_level of this TestCase.
        :type expression_report_level: str
        """
        allowed_values = ["LEVEL_UNSPECIFIED", "NONE", "FULL", "VISITED"]  # noqa: E501
        if expression_report_level not in allowed_values:
            raise ValueError(
                "Invalid value for `expression_report_level` ({0}), must be one of {1}"
                .format(expression_report_level, allowed_values)
            )

        self._expression_report_level = expression_report_level

    @property
    def function_mocks(self):
        """Gets the function_mocks of this TestCase.

        Optional function mocks for service-defined functions. If not set, any service defined function is expected to return an error, which may or may not influence the test outcome.

        :return: The function_mocks of this TestCase.
        :rtype: List[FunctionMock]
        """
        return self._function_mocks

    @function_mocks.setter
    def function_mocks(self, function_mocks):
        """Sets the function_mocks of this TestCase.

        Optional function mocks for service-defined functions. If not set, any service defined function is expected to return an error, which may or may not influence the test outcome.

        :param function_mocks: The function_mocks of this TestCase.
        :type function_mocks: List[FunctionMock]
        """

        self._function_mocks = function_mocks

    @property
    def path_encoding(self):
        """Gets the path_encoding of this TestCase.

        Specifies whether paths (such as request.path) are encoded and how.

        :return: The path_encoding of this TestCase.
        :rtype: str
        """
        return self._path_encoding

    @path_encoding.setter
    def path_encoding(self, path_encoding):
        """Sets the path_encoding of this TestCase.

        Specifies whether paths (such as request.path) are encoded and how.

        :param path_encoding: The path_encoding of this TestCase.
        :type path_encoding: str
        """
        allowed_values = ["ENCODING_UNSPECIFIED", "URL_ENCODED", "PLAIN"]  # noqa: E501
        if path_encoding not in allowed_values:
            raise ValueError(
                "Invalid value for `path_encoding` ({0}), must be one of {1}"
                .format(path_encoding, allowed_values)
            )

        self._path_encoding = path_encoding

    @property
    def request(self):
        """Gets the request of this TestCase.

        Request context. The exact format of the request context is service-dependent. See the appropriate service documentation for information about the supported fields and types on the request. Minimally, all services support the following fields and types: Request field | Type ---------------|----------------- auth.uid | `string` auth.token | `map` headers | `map` method | `string` params | `map` path | `string` time | `google.protobuf.Timestamp` If the request value is not well-formed for the service, the request will be rejected as an invalid argument.

        :return: The request of this TestCase.
        :rtype: object
        """
        return self._request

    @request.setter
    def request(self, request):
        """Sets the request of this TestCase.

        Request context. The exact format of the request context is service-dependent. See the appropriate service documentation for information about the supported fields and types on the request. Minimally, all services support the following fields and types: Request field | Type ---------------|----------------- auth.uid | `string` auth.token | `map` headers | `map` method | `string` params | `map` path | `string` time | `google.protobuf.Timestamp` If the request value is not well-formed for the service, the request will be rejected as an invalid argument.

        :param request: The request of this TestCase.
        :type request: object
        """

        self._request = request

    @property
    def resource(self):
        """Gets the resource of this TestCase.

        Optional resource value as it appears in persistent storage before the request is fulfilled. The resource type depends on the `request.path` value.

        :return: The resource of this TestCase.
        :rtype: object
        """
        return self._resource

    @resource.setter
    def resource(self, resource):
        """Sets the resource of this TestCase.

        Optional resource value as it appears in persistent storage before the request is fulfilled. The resource type depends on the `request.path` value.

        :param resource: The resource of this TestCase.
        :type resource: object
        """

        self._resource = resource
