/*
 * Firebase Rules API
 * Creates and manages rules that determine when a Firebase Rules-enabled service should permit a request. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Arg;
import org.openapitools.client.model.Result;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Mock function definition. Mocks must refer to a function declared by the target service. The type of the function args and result will be inferred at test time. If either the arg or result values are not compatible with function type declaration, the request will be considered invalid. More than one &#x60;FunctionMock&#x60; may be provided for a given function name so long as the &#x60;Arg&#x60; matchers are distinct. There may be only one function for a given overload where all &#x60;Arg&#x60; values are &#x60;Arg.any_value&#x60;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:50.690532-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FunctionMock {
  public static final String SERIALIZED_NAME_ARGS = "args";
  @SerializedName(SERIALIZED_NAME_ARGS)
  private List<Arg> args = new ArrayList<>();

  public static final String SERIALIZED_NAME_FUNCTION = "function";
  @SerializedName(SERIALIZED_NAME_FUNCTION)
  private String function;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private Result result;

  public FunctionMock() {
  }

  public FunctionMock args(List<Arg> args) {
    this.args = args;
    return this;
  }

  public FunctionMock addArgsItem(Arg argsItem) {
    if (this.args == null) {
      this.args = new ArrayList<>();
    }
    this.args.add(argsItem);
    return this;
  }

  /**
   * The list of &#x60;Arg&#x60; values to match. The order in which the arguments are provided is the order in which they must appear in the function invocation.
   * @return args
   */
  @javax.annotation.Nullable
  public List<Arg> getArgs() {
    return args;
  }

  public void setArgs(List<Arg> args) {
    this.args = args;
  }


  public FunctionMock function(String function) {
    this.function = function;
    return this;
  }

  /**
   * The name of the function. The function name must match one provided by a service declaration.
   * @return function
   */
  @javax.annotation.Nullable
  public String getFunction() {
    return function;
  }

  public void setFunction(String function) {
    this.function = function;
  }


  public FunctionMock result(Result result) {
    this.result = result;
    return this;
  }

  /**
   * Get result
   * @return result
   */
  @javax.annotation.Nullable
  public Result getResult() {
    return result;
  }

  public void setResult(Result result) {
    this.result = result;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FunctionMock functionMock = (FunctionMock) o;
    return Objects.equals(this.args, functionMock.args) &&
        Objects.equals(this.function, functionMock.function) &&
        Objects.equals(this.result, functionMock.result);
  }

  @Override
  public int hashCode() {
    return Objects.hash(args, function, result);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FunctionMock {\n");
    sb.append("    args: ").append(toIndentedString(args)).append("\n");
    sb.append("    function: ").append(toIndentedString(function)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("args");
    openapiFields.add("function");
    openapiFields.add("result");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FunctionMock
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FunctionMock.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FunctionMock is not found in the empty JSON string", FunctionMock.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FunctionMock.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FunctionMock` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("args") != null && !jsonObj.get("args").isJsonNull()) {
        JsonArray jsonArrayargs = jsonObj.getAsJsonArray("args");
        if (jsonArrayargs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("args").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `args` to be an array in the JSON string but got `%s`", jsonObj.get("args").toString()));
          }

          // validate the optional field `args` (array)
          for (int i = 0; i < jsonArrayargs.size(); i++) {
            Arg.validateJsonElement(jsonArrayargs.get(i));
          };
        }
      }
      if ((jsonObj.get("function") != null && !jsonObj.get("function").isJsonNull()) && !jsonObj.get("function").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `function` to be a primitive type in the JSON string but got `%s`", jsonObj.get("function").toString()));
      }
      // validate the optional field `result`
      if (jsonObj.get("result") != null && !jsonObj.get("result").isJsonNull()) {
        Result.validateJsonElement(jsonObj.get("result"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FunctionMock.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FunctionMock' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FunctionMock> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FunctionMock.class));

       return (TypeAdapter<T>) new TypeAdapter<FunctionMock>() {
           @Override
           public void write(JsonWriter out, FunctionMock value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FunctionMock read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FunctionMock given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FunctionMock
   * @throws IOException if the JSON string is invalid with respect to FunctionMock
   */
  public static FunctionMock fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FunctionMock.class);
  }

  /**
   * Convert an instance of FunctionMock to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

