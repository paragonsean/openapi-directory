/*
 * Firebase Rules API
 * Creates and manages rules that determine when a Firebase Rules-enabled service should permit a request. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ExpressionReport;
import org.openapitools.client.model.FunctionCall;
import org.openapitools.client.model.SourcePosition;
import org.openapitools.client.model.VisitedExpression;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Test result message containing the state of the test as well as a description and source position for test failures.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:50.690532-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TestResult {
  public static final String SERIALIZED_NAME_DEBUG_MESSAGES = "debugMessages";
  @SerializedName(SERIALIZED_NAME_DEBUG_MESSAGES)
  private List<String> debugMessages = new ArrayList<>();

  public static final String SERIALIZED_NAME_ERROR_POSITION = "errorPosition";
  @SerializedName(SERIALIZED_NAME_ERROR_POSITION)
  private SourcePosition errorPosition;

  public static final String SERIALIZED_NAME_EXPRESSION_REPORTS = "expressionReports";
  @SerializedName(SERIALIZED_NAME_EXPRESSION_REPORTS)
  private List<ExpressionReport> expressionReports = new ArrayList<>();

  public static final String SERIALIZED_NAME_FUNCTION_CALLS = "functionCalls";
  @SerializedName(SERIALIZED_NAME_FUNCTION_CALLS)
  private List<FunctionCall> functionCalls = new ArrayList<>();

  /**
   * State of the test.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    SUCCESS("SUCCESS"),
    
    FAILURE("FAILURE");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_VISITED_EXPRESSIONS = "visitedExpressions";
  @SerializedName(SERIALIZED_NAME_VISITED_EXPRESSIONS)
  private List<VisitedExpression> visitedExpressions = new ArrayList<>();

  public TestResult() {
  }

  public TestResult debugMessages(List<String> debugMessages) {
    this.debugMessages = debugMessages;
    return this;
  }

  public TestResult addDebugMessagesItem(String debugMessagesItem) {
    if (this.debugMessages == null) {
      this.debugMessages = new ArrayList<>();
    }
    this.debugMessages.add(debugMessagesItem);
    return this;
  }

  /**
   * Debug messages related to test execution issues encountered during evaluation. Debug messages may be related to too many or too few invocations of function mocks or to runtime errors that occur during evaluation. For example: &#x60;&#x60;&#x60;Unable to read variable [name: \&quot;resource\&quot;]&#x60;&#x60;&#x60;
   * @return debugMessages
   */
  @javax.annotation.Nullable
  public List<String> getDebugMessages() {
    return debugMessages;
  }

  public void setDebugMessages(List<String> debugMessages) {
    this.debugMessages = debugMessages;
  }


  public TestResult errorPosition(SourcePosition errorPosition) {
    this.errorPosition = errorPosition;
    return this;
  }

  /**
   * Get errorPosition
   * @return errorPosition
   */
  @javax.annotation.Nullable
  public SourcePosition getErrorPosition() {
    return errorPosition;
  }

  public void setErrorPosition(SourcePosition errorPosition) {
    this.errorPosition = errorPosition;
  }


  public TestResult expressionReports(List<ExpressionReport> expressionReports) {
    this.expressionReports = expressionReports;
    return this;
  }

  public TestResult addExpressionReportsItem(ExpressionReport expressionReportsItem) {
    if (this.expressionReports == null) {
      this.expressionReports = new ArrayList<>();
    }
    this.expressionReports.add(expressionReportsItem);
    return this;
  }

  /**
   * The mapping from expression in the ruleset AST to the values they were evaluated to. Partially-nested to mirror AST structure. Note that this field is actually tracking expressions and not permission statements in contrast to the \&quot;visited_expressions\&quot; field above. Literal expressions are omitted.
   * @return expressionReports
   */
  @javax.annotation.Nullable
  public List<ExpressionReport> getExpressionReports() {
    return expressionReports;
  }

  public void setExpressionReports(List<ExpressionReport> expressionReports) {
    this.expressionReports = expressionReports;
  }


  public TestResult functionCalls(List<FunctionCall> functionCalls) {
    this.functionCalls = functionCalls;
    return this;
  }

  public TestResult addFunctionCallsItem(FunctionCall functionCallsItem) {
    if (this.functionCalls == null) {
      this.functionCalls = new ArrayList<>();
    }
    this.functionCalls.add(functionCallsItem);
    return this;
  }

  /**
   * The set of function calls made to service-defined methods. Function calls are included in the order in which they are encountered during evaluation, are provided for both mocked and unmocked functions, and included on the response regardless of the test &#x60;state&#x60;.
   * @return functionCalls
   */
  @javax.annotation.Nullable
  public List<FunctionCall> getFunctionCalls() {
    return functionCalls;
  }

  public void setFunctionCalls(List<FunctionCall> functionCalls) {
    this.functionCalls = functionCalls;
  }


  public TestResult state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * State of the test.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public TestResult visitedExpressions(List<VisitedExpression> visitedExpressions) {
    this.visitedExpressions = visitedExpressions;
    return this;
  }

  public TestResult addVisitedExpressionsItem(VisitedExpression visitedExpressionsItem) {
    if (this.visitedExpressions == null) {
      this.visitedExpressions = new ArrayList<>();
    }
    this.visitedExpressions.add(visitedExpressionsItem);
    return this;
  }

  /**
   * The set of visited permission expressions for a given test. This returns the positions and evaluation results of all visited permission expressions which were relevant to the test case, e.g. &#x60;&#x60;&#x60; match /path { allow read if: } &#x60;&#x60;&#x60; For a detailed report of the intermediate evaluation states, see the &#x60;expression_reports&#x60; field
   * @return visitedExpressions
   */
  @javax.annotation.Nullable
  public List<VisitedExpression> getVisitedExpressions() {
    return visitedExpressions;
  }

  public void setVisitedExpressions(List<VisitedExpression> visitedExpressions) {
    this.visitedExpressions = visitedExpressions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResult testResult = (TestResult) o;
    return Objects.equals(this.debugMessages, testResult.debugMessages) &&
        Objects.equals(this.errorPosition, testResult.errorPosition) &&
        Objects.equals(this.expressionReports, testResult.expressionReports) &&
        Objects.equals(this.functionCalls, testResult.functionCalls) &&
        Objects.equals(this.state, testResult.state) &&
        Objects.equals(this.visitedExpressions, testResult.visitedExpressions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(debugMessages, errorPosition, expressionReports, functionCalls, state, visitedExpressions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResult {\n");
    sb.append("    debugMessages: ").append(toIndentedString(debugMessages)).append("\n");
    sb.append("    errorPosition: ").append(toIndentedString(errorPosition)).append("\n");
    sb.append("    expressionReports: ").append(toIndentedString(expressionReports)).append("\n");
    sb.append("    functionCalls: ").append(toIndentedString(functionCalls)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    visitedExpressions: ").append(toIndentedString(visitedExpressions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("debugMessages");
    openapiFields.add("errorPosition");
    openapiFields.add("expressionReports");
    openapiFields.add("functionCalls");
    openapiFields.add("state");
    openapiFields.add("visitedExpressions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TestResult
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TestResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResult is not found in the empty JSON string", TestResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TestResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TestResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("debugMessages") != null && !jsonObj.get("debugMessages").isJsonNull() && !jsonObj.get("debugMessages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `debugMessages` to be an array in the JSON string but got `%s`", jsonObj.get("debugMessages").toString()));
      }
      // validate the optional field `errorPosition`
      if (jsonObj.get("errorPosition") != null && !jsonObj.get("errorPosition").isJsonNull()) {
        SourcePosition.validateJsonElement(jsonObj.get("errorPosition"));
      }
      if (jsonObj.get("expressionReports") != null && !jsonObj.get("expressionReports").isJsonNull()) {
        JsonArray jsonArrayexpressionReports = jsonObj.getAsJsonArray("expressionReports");
        if (jsonArrayexpressionReports != null) {
          // ensure the json data is an array
          if (!jsonObj.get("expressionReports").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `expressionReports` to be an array in the JSON string but got `%s`", jsonObj.get("expressionReports").toString()));
          }

          // validate the optional field `expressionReports` (array)
          for (int i = 0; i < jsonArrayexpressionReports.size(); i++) {
            ExpressionReport.validateJsonElement(jsonArrayexpressionReports.get(i));
          };
        }
      }
      if (jsonObj.get("functionCalls") != null && !jsonObj.get("functionCalls").isJsonNull()) {
        JsonArray jsonArrayfunctionCalls = jsonObj.getAsJsonArray("functionCalls");
        if (jsonArrayfunctionCalls != null) {
          // ensure the json data is an array
          if (!jsonObj.get("functionCalls").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `functionCalls` to be an array in the JSON string but got `%s`", jsonObj.get("functionCalls").toString()));
          }

          // validate the optional field `functionCalls` (array)
          for (int i = 0; i < jsonArrayfunctionCalls.size(); i++) {
            FunctionCall.validateJsonElement(jsonArrayfunctionCalls.get(i));
          };
        }
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if (jsonObj.get("visitedExpressions") != null && !jsonObj.get("visitedExpressions").isJsonNull()) {
        JsonArray jsonArrayvisitedExpressions = jsonObj.getAsJsonArray("visitedExpressions");
        if (jsonArrayvisitedExpressions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("visitedExpressions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `visitedExpressions` to be an array in the JSON string but got `%s`", jsonObj.get("visitedExpressions").toString()));
          }

          // validate the optional field `visitedExpressions` (array)
          for (int i = 0; i < jsonArrayvisitedExpressions.size(); i++) {
            VisitedExpression.validateJsonElement(jsonArrayvisitedExpressions.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResult.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResult>() {
           @Override
           public void write(JsonWriter out, TestResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TestResult given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TestResult
   * @throws IOException if the JSON string is invalid with respect to TestResult
   */
  public static TestResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResult.class);
  }

  /**
   * Convert an instance of TestResult to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

