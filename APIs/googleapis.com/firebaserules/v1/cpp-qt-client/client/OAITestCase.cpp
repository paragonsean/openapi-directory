/**
 * Firebase Rules API
 * Creates and manages rules that determine when a Firebase Rules-enabled service should permit a request. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITestCase.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITestCase::OAITestCase(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITestCase::OAITestCase() {
    this->initializeModel();
}

OAITestCase::~OAITestCase() {}

void OAITestCase::initializeModel() {

    m_expectation_isSet = false;
    m_expectation_isValid = false;

    m_expression_report_level_isSet = false;
    m_expression_report_level_isValid = false;

    m_function_mocks_isSet = false;
    m_function_mocks_isValid = false;

    m_path_encoding_isSet = false;
    m_path_encoding_isValid = false;

    m_request_isSet = false;
    m_request_isValid = false;

    m_resource_isSet = false;
    m_resource_isValid = false;
}

void OAITestCase::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITestCase::fromJsonObject(QJsonObject json) {

    m_expectation_isValid = ::OpenAPI::fromJsonValue(m_expectation, json[QString("expectation")]);
    m_expectation_isSet = !json[QString("expectation")].isNull() && m_expectation_isValid;

    m_expression_report_level_isValid = ::OpenAPI::fromJsonValue(m_expression_report_level, json[QString("expressionReportLevel")]);
    m_expression_report_level_isSet = !json[QString("expressionReportLevel")].isNull() && m_expression_report_level_isValid;

    m_function_mocks_isValid = ::OpenAPI::fromJsonValue(m_function_mocks, json[QString("functionMocks")]);
    m_function_mocks_isSet = !json[QString("functionMocks")].isNull() && m_function_mocks_isValid;

    m_path_encoding_isValid = ::OpenAPI::fromJsonValue(m_path_encoding, json[QString("pathEncoding")]);
    m_path_encoding_isSet = !json[QString("pathEncoding")].isNull() && m_path_encoding_isValid;

    m_request_isValid = ::OpenAPI::fromJsonValue(m_request, json[QString("request")]);
    m_request_isSet = !json[QString("request")].isNull() && m_request_isValid;

    m_resource_isValid = ::OpenAPI::fromJsonValue(m_resource, json[QString("resource")]);
    m_resource_isSet = !json[QString("resource")].isNull() && m_resource_isValid;
}

QString OAITestCase::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITestCase::asJsonObject() const {
    QJsonObject obj;
    if (m_expectation_isSet) {
        obj.insert(QString("expectation"), ::OpenAPI::toJsonValue(m_expectation));
    }
    if (m_expression_report_level_isSet) {
        obj.insert(QString("expressionReportLevel"), ::OpenAPI::toJsonValue(m_expression_report_level));
    }
    if (m_function_mocks.size() > 0) {
        obj.insert(QString("functionMocks"), ::OpenAPI::toJsonValue(m_function_mocks));
    }
    if (m_path_encoding_isSet) {
        obj.insert(QString("pathEncoding"), ::OpenAPI::toJsonValue(m_path_encoding));
    }
    if (m_request_isSet) {
        obj.insert(QString("request"), ::OpenAPI::toJsonValue(m_request));
    }
    if (m_resource_isSet) {
        obj.insert(QString("resource"), ::OpenAPI::toJsonValue(m_resource));
    }
    return obj;
}

QString OAITestCase::getExpectation() const {
    return m_expectation;
}
void OAITestCase::setExpectation(const QString &expectation) {
    m_expectation = expectation;
    m_expectation_isSet = true;
}

bool OAITestCase::is_expectation_Set() const{
    return m_expectation_isSet;
}

bool OAITestCase::is_expectation_Valid() const{
    return m_expectation_isValid;
}

QString OAITestCase::getExpressionReportLevel() const {
    return m_expression_report_level;
}
void OAITestCase::setExpressionReportLevel(const QString &expression_report_level) {
    m_expression_report_level = expression_report_level;
    m_expression_report_level_isSet = true;
}

bool OAITestCase::is_expression_report_level_Set() const{
    return m_expression_report_level_isSet;
}

bool OAITestCase::is_expression_report_level_Valid() const{
    return m_expression_report_level_isValid;
}

QList<OAIFunctionMock> OAITestCase::getFunctionMocks() const {
    return m_function_mocks;
}
void OAITestCase::setFunctionMocks(const QList<OAIFunctionMock> &function_mocks) {
    m_function_mocks = function_mocks;
    m_function_mocks_isSet = true;
}

bool OAITestCase::is_function_mocks_Set() const{
    return m_function_mocks_isSet;
}

bool OAITestCase::is_function_mocks_Valid() const{
    return m_function_mocks_isValid;
}

QString OAITestCase::getPathEncoding() const {
    return m_path_encoding;
}
void OAITestCase::setPathEncoding(const QString &path_encoding) {
    m_path_encoding = path_encoding;
    m_path_encoding_isSet = true;
}

bool OAITestCase::is_path_encoding_Set() const{
    return m_path_encoding_isSet;
}

bool OAITestCase::is_path_encoding_Valid() const{
    return m_path_encoding_isValid;
}

QJsonValue OAITestCase::getRequest() const {
    return m_request;
}
void OAITestCase::setRequest(const QJsonValue &request) {
    m_request = request;
    m_request_isSet = true;
}

bool OAITestCase::is_request_Set() const{
    return m_request_isSet;
}

bool OAITestCase::is_request_Valid() const{
    return m_request_isValid;
}

QJsonValue OAITestCase::getResource() const {
    return m_resource;
}
void OAITestCase::setResource(const QJsonValue &resource) {
    m_resource = resource;
    m_resource_isSet = true;
}

bool OAITestCase::is_resource_Set() const{
    return m_resource_isSet;
}

bool OAITestCase::is_resource_Valid() const{
    return m_resource_isValid;
}

bool OAITestCase::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_expectation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expression_report_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_function_mocks.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_encoding_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITestCase::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
