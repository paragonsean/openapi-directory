/*
 * versionhistory.googleapis.com API
 * Version History API - Prod
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Interval;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Release is owned by a Version. A Release contains information about the release(s) of its parent version. This includes when the release began and ended, as well as what percentage it was released at. If the version is released again, or if the serving percentage changes, it will create another release under the version.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:05.128346-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Release {
  public static final String SERIALIZED_NAME_FRACTION = "fraction";
  @SerializedName(SERIALIZED_NAME_FRACTION)
  private Double fraction;

  public static final String SERIALIZED_NAME_FRACTION_GROUP = "fractionGroup";
  @SerializedName(SERIALIZED_NAME_FRACTION_GROUP)
  private String fractionGroup;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SERVING = "serving";
  @SerializedName(SERIALIZED_NAME_SERVING)
  private Interval serving;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public Release() {
  }

  public Release fraction(Double fraction) {
    this.fraction = fraction;
    return this;
  }

  /**
   * Rollout fraction. This fraction indicates the fraction of people that should receive this version in this release. If the fraction is not specified in ReleaseManager, the API will assume fraction is 1.
   * @return fraction
   */
  @javax.annotation.Nullable
  public Double getFraction() {
    return fraction;
  }

  public void setFraction(Double fraction) {
    this.fraction = fraction;
  }


  public Release fractionGroup(String fractionGroup) {
    this.fractionGroup = fractionGroup;
    return this;
  }

  /**
   * Rollout fraction group. Only fractions with the same fraction_group are statistically comparable: there may be non-fractional differences between different fraction groups.
   * @return fractionGroup
   */
  @javax.annotation.Nullable
  public String getFractionGroup() {
    return fractionGroup;
  }

  public void setFractionGroup(String fractionGroup) {
    this.fractionGroup = fractionGroup;
  }


  public Release name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Release name. Format is \&quot;{product}/platforms/{platform}/channels/{channel}/versions/{version}/releases/{release}\&quot;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Release serving(Interval serving) {
    this.serving = serving;
    return this;
  }

  /**
   * Get serving
   * @return serving
   */
  @javax.annotation.Nullable
  public Interval getServing() {
    return serving;
  }

  public void setServing(Interval serving) {
    this.serving = serving;
  }


  public Release version(String version) {
    this.version = version;
    return this;
  }

  /**
   * String containing just the version number. e.g. \&quot;84.0.4147.38\&quot;
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Release release = (Release) o;
    return Objects.equals(this.fraction, release.fraction) &&
        Objects.equals(this.fractionGroup, release.fractionGroup) &&
        Objects.equals(this.name, release.name) &&
        Objects.equals(this.serving, release.serving) &&
        Objects.equals(this.version, release.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fraction, fractionGroup, name, serving, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Release {\n");
    sb.append("    fraction: ").append(toIndentedString(fraction)).append("\n");
    sb.append("    fractionGroup: ").append(toIndentedString(fractionGroup)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    serving: ").append(toIndentedString(serving)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("fraction");
    openapiFields.add("fractionGroup");
    openapiFields.add("name");
    openapiFields.add("serving");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Release
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Release.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Release is not found in the empty JSON string", Release.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Release.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Release` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("fractionGroup") != null && !jsonObj.get("fractionGroup").isJsonNull()) && !jsonObj.get("fractionGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fractionGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fractionGroup").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `serving`
      if (jsonObj.get("serving") != null && !jsonObj.get("serving").isJsonNull()) {
        Interval.validateJsonElement(jsonObj.get("serving"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Release.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Release' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Release> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Release.class));

       return (TypeAdapter<T>) new TypeAdapter<Release>() {
           @Override
           public void write(JsonWriter out, Release value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Release read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Release given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Release
   * @throws IOException if the JSON string is invalid with respect to Release
   */
  public static Release fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Release.class);
  }

  /**
   * Convert an instance of Release to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

