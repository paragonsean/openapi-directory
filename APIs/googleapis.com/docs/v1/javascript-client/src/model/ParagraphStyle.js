/**
 * Google Docs API
 * Reads and writes Google Docs documents.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Dimension from './Dimension';
import ParagraphBorder from './ParagraphBorder';
import Shading from './Shading';
import TabStop from './TabStop';

/**
 * The ParagraphStyle model module.
 * @module model/ParagraphStyle
 * @version v1
 */
class ParagraphStyle {
    /**
     * Constructs a new <code>ParagraphStyle</code>.
     * Styles that apply to a whole paragraph. Inherited paragraph styles are represented as unset fields in this message. A paragraph style&#39;s parent depends on where the paragraph style is defined: * The ParagraphStyle on a Paragraph inherits from the paragraph&#39;s corresponding named style type. * The ParagraphStyle on a named style inherits from the normal text named style. * The ParagraphStyle of the normal text named style inherits from the default paragraph style in the Docs editor. * The ParagraphStyle on a Paragraph element that&#39;s contained in a table may inherit its paragraph style from the table style. If the paragraph style does not inherit from a parent, unsetting fields will revert the style to a value matching the defaults in the Docs editor.
     * @alias module:model/ParagraphStyle
     */
    constructor() { 
        
        ParagraphStyle.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ParagraphStyle</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ParagraphStyle} obj Optional instance to populate.
     * @return {module:model/ParagraphStyle} The populated <code>ParagraphStyle</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ParagraphStyle();

            if (data.hasOwnProperty('alignment')) {
                obj['alignment'] = ApiClient.convertToType(data['alignment'], 'String');
            }
            if (data.hasOwnProperty('avoidWidowAndOrphan')) {
                obj['avoidWidowAndOrphan'] = ApiClient.convertToType(data['avoidWidowAndOrphan'], 'Boolean');
            }
            if (data.hasOwnProperty('borderBetween')) {
                obj['borderBetween'] = ParagraphBorder.constructFromObject(data['borderBetween']);
            }
            if (data.hasOwnProperty('borderBottom')) {
                obj['borderBottom'] = ParagraphBorder.constructFromObject(data['borderBottom']);
            }
            if (data.hasOwnProperty('borderLeft')) {
                obj['borderLeft'] = ParagraphBorder.constructFromObject(data['borderLeft']);
            }
            if (data.hasOwnProperty('borderRight')) {
                obj['borderRight'] = ParagraphBorder.constructFromObject(data['borderRight']);
            }
            if (data.hasOwnProperty('borderTop')) {
                obj['borderTop'] = ParagraphBorder.constructFromObject(data['borderTop']);
            }
            if (data.hasOwnProperty('direction')) {
                obj['direction'] = ApiClient.convertToType(data['direction'], 'String');
            }
            if (data.hasOwnProperty('headingId')) {
                obj['headingId'] = ApiClient.convertToType(data['headingId'], 'String');
            }
            if (data.hasOwnProperty('indentEnd')) {
                obj['indentEnd'] = Dimension.constructFromObject(data['indentEnd']);
            }
            if (data.hasOwnProperty('indentFirstLine')) {
                obj['indentFirstLine'] = Dimension.constructFromObject(data['indentFirstLine']);
            }
            if (data.hasOwnProperty('indentStart')) {
                obj['indentStart'] = Dimension.constructFromObject(data['indentStart']);
            }
            if (data.hasOwnProperty('keepLinesTogether')) {
                obj['keepLinesTogether'] = ApiClient.convertToType(data['keepLinesTogether'], 'Boolean');
            }
            if (data.hasOwnProperty('keepWithNext')) {
                obj['keepWithNext'] = ApiClient.convertToType(data['keepWithNext'], 'Boolean');
            }
            if (data.hasOwnProperty('lineSpacing')) {
                obj['lineSpacing'] = ApiClient.convertToType(data['lineSpacing'], 'Number');
            }
            if (data.hasOwnProperty('namedStyleType')) {
                obj['namedStyleType'] = ApiClient.convertToType(data['namedStyleType'], 'String');
            }
            if (data.hasOwnProperty('pageBreakBefore')) {
                obj['pageBreakBefore'] = ApiClient.convertToType(data['pageBreakBefore'], 'Boolean');
            }
            if (data.hasOwnProperty('shading')) {
                obj['shading'] = Shading.constructFromObject(data['shading']);
            }
            if (data.hasOwnProperty('spaceAbove')) {
                obj['spaceAbove'] = Dimension.constructFromObject(data['spaceAbove']);
            }
            if (data.hasOwnProperty('spaceBelow')) {
                obj['spaceBelow'] = Dimension.constructFromObject(data['spaceBelow']);
            }
            if (data.hasOwnProperty('spacingMode')) {
                obj['spacingMode'] = ApiClient.convertToType(data['spacingMode'], 'String');
            }
            if (data.hasOwnProperty('tabStops')) {
                obj['tabStops'] = ApiClient.convertToType(data['tabStops'], [TabStop]);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ParagraphStyle</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ParagraphStyle</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['alignment'] && !(typeof data['alignment'] === 'string' || data['alignment'] instanceof String)) {
            throw new Error("Expected the field `alignment` to be a primitive type in the JSON string but got " + data['alignment']);
        }
        // validate the optional field `borderBetween`
        if (data['borderBetween']) { // data not null
          ParagraphBorder.validateJSON(data['borderBetween']);
        }
        // validate the optional field `borderBottom`
        if (data['borderBottom']) { // data not null
          ParagraphBorder.validateJSON(data['borderBottom']);
        }
        // validate the optional field `borderLeft`
        if (data['borderLeft']) { // data not null
          ParagraphBorder.validateJSON(data['borderLeft']);
        }
        // validate the optional field `borderRight`
        if (data['borderRight']) { // data not null
          ParagraphBorder.validateJSON(data['borderRight']);
        }
        // validate the optional field `borderTop`
        if (data['borderTop']) { // data not null
          ParagraphBorder.validateJSON(data['borderTop']);
        }
        // ensure the json data is a string
        if (data['direction'] && !(typeof data['direction'] === 'string' || data['direction'] instanceof String)) {
            throw new Error("Expected the field `direction` to be a primitive type in the JSON string but got " + data['direction']);
        }
        // ensure the json data is a string
        if (data['headingId'] && !(typeof data['headingId'] === 'string' || data['headingId'] instanceof String)) {
            throw new Error("Expected the field `headingId` to be a primitive type in the JSON string but got " + data['headingId']);
        }
        // validate the optional field `indentEnd`
        if (data['indentEnd']) { // data not null
          Dimension.validateJSON(data['indentEnd']);
        }
        // validate the optional field `indentFirstLine`
        if (data['indentFirstLine']) { // data not null
          Dimension.validateJSON(data['indentFirstLine']);
        }
        // validate the optional field `indentStart`
        if (data['indentStart']) { // data not null
          Dimension.validateJSON(data['indentStart']);
        }
        // ensure the json data is a string
        if (data['namedStyleType'] && !(typeof data['namedStyleType'] === 'string' || data['namedStyleType'] instanceof String)) {
            throw new Error("Expected the field `namedStyleType` to be a primitive type in the JSON string but got " + data['namedStyleType']);
        }
        // validate the optional field `shading`
        if (data['shading']) { // data not null
          Shading.validateJSON(data['shading']);
        }
        // validate the optional field `spaceAbove`
        if (data['spaceAbove']) { // data not null
          Dimension.validateJSON(data['spaceAbove']);
        }
        // validate the optional field `spaceBelow`
        if (data['spaceBelow']) { // data not null
          Dimension.validateJSON(data['spaceBelow']);
        }
        // ensure the json data is a string
        if (data['spacingMode'] && !(typeof data['spacingMode'] === 'string' || data['spacingMode'] instanceof String)) {
            throw new Error("Expected the field `spacingMode` to be a primitive type in the JSON string but got " + data['spacingMode']);
        }
        if (data['tabStops']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['tabStops'])) {
                throw new Error("Expected the field `tabStops` to be an array in the JSON data but got " + data['tabStops']);
            }
            // validate the optional field `tabStops` (array)
            for (const item of data['tabStops']) {
                TabStop.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * The text alignment for this paragraph.
 * @member {module:model/ParagraphStyle.AlignmentEnum} alignment
 */
ParagraphStyle.prototype['alignment'] = undefined;

/**
 * Whether to avoid widows and orphans for the paragraph. If unset, the value is inherited from the parent.
 * @member {Boolean} avoidWidowAndOrphan
 */
ParagraphStyle.prototype['avoidWidowAndOrphan'] = undefined;

/**
 * @member {module:model/ParagraphBorder} borderBetween
 */
ParagraphStyle.prototype['borderBetween'] = undefined;

/**
 * @member {module:model/ParagraphBorder} borderBottom
 */
ParagraphStyle.prototype['borderBottom'] = undefined;

/**
 * @member {module:model/ParagraphBorder} borderLeft
 */
ParagraphStyle.prototype['borderLeft'] = undefined;

/**
 * @member {module:model/ParagraphBorder} borderRight
 */
ParagraphStyle.prototype['borderRight'] = undefined;

/**
 * @member {module:model/ParagraphBorder} borderTop
 */
ParagraphStyle.prototype['borderTop'] = undefined;

/**
 * The text direction of this paragraph. If unset, the value defaults to LEFT_TO_RIGHT since paragraph direction is not inherited.
 * @member {module:model/ParagraphStyle.DirectionEnum} direction
 */
ParagraphStyle.prototype['direction'] = undefined;

/**
 * The heading ID of the paragraph. If empty, then this paragraph is not a heading. This property is read-only.
 * @member {String} headingId
 */
ParagraphStyle.prototype['headingId'] = undefined;

/**
 * @member {module:model/Dimension} indentEnd
 */
ParagraphStyle.prototype['indentEnd'] = undefined;

/**
 * @member {module:model/Dimension} indentFirstLine
 */
ParagraphStyle.prototype['indentFirstLine'] = undefined;

/**
 * @member {module:model/Dimension} indentStart
 */
ParagraphStyle.prototype['indentStart'] = undefined;

/**
 * Whether all lines of the paragraph should be laid out on the same page or column if possible. If unset, the value is inherited from the parent.
 * @member {Boolean} keepLinesTogether
 */
ParagraphStyle.prototype['keepLinesTogether'] = undefined;

/**
 * Whether at least a part of this paragraph should be laid out on the same page or column as the next paragraph if possible. If unset, the value is inherited from the parent.
 * @member {Boolean} keepWithNext
 */
ParagraphStyle.prototype['keepWithNext'] = undefined;

/**
 * The amount of space between lines, as a percentage of normal, where normal is represented as 100.0. If unset, the value is inherited from the parent.
 * @member {Number} lineSpacing
 */
ParagraphStyle.prototype['lineSpacing'] = undefined;

/**
 * The named style type of the paragraph. Since updating the named style type affects other properties within ParagraphStyle, the named style type is applied before the other properties are updated.
 * @member {module:model/ParagraphStyle.NamedStyleTypeEnum} namedStyleType
 */
ParagraphStyle.prototype['namedStyleType'] = undefined;

/**
 * Whether the current paragraph should always start at the beginning of a page. If unset, the value is inherited from the parent. Attempting to update page_break_before for paragraphs in unsupported regions, including Table, Header, Footer and Footnote, can result in an invalid document state that returns a 400 bad request error.
 * @member {Boolean} pageBreakBefore
 */
ParagraphStyle.prototype['pageBreakBefore'] = undefined;

/**
 * @member {module:model/Shading} shading
 */
ParagraphStyle.prototype['shading'] = undefined;

/**
 * @member {module:model/Dimension} spaceAbove
 */
ParagraphStyle.prototype['spaceAbove'] = undefined;

/**
 * @member {module:model/Dimension} spaceBelow
 */
ParagraphStyle.prototype['spaceBelow'] = undefined;

/**
 * The spacing mode for the paragraph.
 * @member {module:model/ParagraphStyle.SpacingModeEnum} spacingMode
 */
ParagraphStyle.prototype['spacingMode'] = undefined;

/**
 * A list of the tab stops for this paragraph. The list of tab stops is not inherited. This property is read-only.
 * @member {Array.<module:model/TabStop>} tabStops
 */
ParagraphStyle.prototype['tabStops'] = undefined;





/**
 * Allowed values for the <code>alignment</code> property.
 * @enum {String}
 * @readonly
 */
ParagraphStyle['AlignmentEnum'] = {

    /**
     * value: "ALIGNMENT_UNSPECIFIED"
     * @const
     */
    "ALIGNMENT_UNSPECIFIED": "ALIGNMENT_UNSPECIFIED",

    /**
     * value: "START"
     * @const
     */
    "START": "START",

    /**
     * value: "CENTER"
     * @const
     */
    "CENTER": "CENTER",

    /**
     * value: "END"
     * @const
     */
    "END": "END",

    /**
     * value: "JUSTIFIED"
     * @const
     */
    "JUSTIFIED": "JUSTIFIED"
};


/**
 * Allowed values for the <code>direction</code> property.
 * @enum {String}
 * @readonly
 */
ParagraphStyle['DirectionEnum'] = {

    /**
     * value: "CONTENT_DIRECTION_UNSPECIFIED"
     * @const
     */
    "CONTENT_DIRECTION_UNSPECIFIED": "CONTENT_DIRECTION_UNSPECIFIED",

    /**
     * value: "LEFT_TO_RIGHT"
     * @const
     */
    "LEFT_TO_RIGHT": "LEFT_TO_RIGHT",

    /**
     * value: "RIGHT_TO_LEFT"
     * @const
     */
    "RIGHT_TO_LEFT": "RIGHT_TO_LEFT"
};


/**
 * Allowed values for the <code>namedStyleType</code> property.
 * @enum {String}
 * @readonly
 */
ParagraphStyle['NamedStyleTypeEnum'] = {

    /**
     * value: "NAMED_STYLE_TYPE_UNSPECIFIED"
     * @const
     */
    "NAMED_STYLE_TYPE_UNSPECIFIED": "NAMED_STYLE_TYPE_UNSPECIFIED",

    /**
     * value: "NORMAL_TEXT"
     * @const
     */
    "NORMAL_TEXT": "NORMAL_TEXT",

    /**
     * value: "TITLE"
     * @const
     */
    "TITLE": "TITLE",

    /**
     * value: "SUBTITLE"
     * @const
     */
    "SUBTITLE": "SUBTITLE",

    /**
     * value: "HEADING_1"
     * @const
     */
    "HEADING_1": "HEADING_1",

    /**
     * value: "HEADING_2"
     * @const
     */
    "HEADING_2": "HEADING_2",

    /**
     * value: "HEADING_3"
     * @const
     */
    "HEADING_3": "HEADING_3",

    /**
     * value: "HEADING_4"
     * @const
     */
    "HEADING_4": "HEADING_4",

    /**
     * value: "HEADING_5"
     * @const
     */
    "HEADING_5": "HEADING_5",

    /**
     * value: "HEADING_6"
     * @const
     */
    "HEADING_6": "HEADING_6"
};


/**
 * Allowed values for the <code>spacingMode</code> property.
 * @enum {String}
 * @readonly
 */
ParagraphStyle['SpacingModeEnum'] = {

    /**
     * value: "SPACING_MODE_UNSPECIFIED"
     * @const
     */
    "SPACING_MODE_UNSPECIFIED": "SPACING_MODE_UNSPECIFIED",

    /**
     * value: "NEVER_COLLAPSE"
     * @const
     */
    "NEVER_COLLAPSE": "NEVER_COLLAPSE",

    /**
     * value: "COLLAPSE_LISTS"
     * @const
     */
    "COLLAPSE_LISTS": "COLLAPSE_LISTS"
};



export default ParagraphStyle;

