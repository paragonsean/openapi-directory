/*
 * Google Docs API
 * Reads and writes Google Docs documents.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Range;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A collection of Ranges with the same named range ID. Named ranges allow developers to associate parts of a document with an arbitrary user-defined label so their contents can be programmatically read or edited later. A document can contain multiple named ranges with the same name, but every named range has a unique ID. A named range is created with a single Range, and content inserted inside a named range generally expands that range. However, certain document changes can cause the range to be split into multiple ranges. Named ranges are not private. All applications and collaborators that have access to the document can see its named ranges.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:07.584674-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamedRange {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMED_RANGE_ID = "namedRangeId";
  @SerializedName(SERIALIZED_NAME_NAMED_RANGE_ID)
  private String namedRangeId;

  public static final String SERIALIZED_NAME_RANGES = "ranges";
  @SerializedName(SERIALIZED_NAME_RANGES)
  private List<Range> ranges = new ArrayList<>();

  public NamedRange() {
  }

  public NamedRange name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the named range.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NamedRange namedRangeId(String namedRangeId) {
    this.namedRangeId = namedRangeId;
    return this;
  }

  /**
   * The ID of the named range.
   * @return namedRangeId
   */
  @javax.annotation.Nullable
  public String getNamedRangeId() {
    return namedRangeId;
  }

  public void setNamedRangeId(String namedRangeId) {
    this.namedRangeId = namedRangeId;
  }


  public NamedRange ranges(List<Range> ranges) {
    this.ranges = ranges;
    return this;
  }

  public NamedRange addRangesItem(Range rangesItem) {
    if (this.ranges == null) {
      this.ranges = new ArrayList<>();
    }
    this.ranges.add(rangesItem);
    return this;
  }

  /**
   * The ranges that belong to this named range.
   * @return ranges
   */
  @javax.annotation.Nullable
  public List<Range> getRanges() {
    return ranges;
  }

  public void setRanges(List<Range> ranges) {
    this.ranges = ranges;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamedRange namedRange = (NamedRange) o;
    return Objects.equals(this.name, namedRange.name) &&
        Objects.equals(this.namedRangeId, namedRange.namedRangeId) &&
        Objects.equals(this.ranges, namedRange.ranges);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, namedRangeId, ranges);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamedRange {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namedRangeId: ").append(toIndentedString(namedRangeId)).append("\n");
    sb.append("    ranges: ").append(toIndentedString(ranges)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("namedRangeId");
    openapiFields.add("ranges");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamedRange
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamedRange.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamedRange is not found in the empty JSON string", NamedRange.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamedRange.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamedRange` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("namedRangeId") != null && !jsonObj.get("namedRangeId").isJsonNull()) && !jsonObj.get("namedRangeId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namedRangeId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namedRangeId").toString()));
      }
      if (jsonObj.get("ranges") != null && !jsonObj.get("ranges").isJsonNull()) {
        JsonArray jsonArrayranges = jsonObj.getAsJsonArray("ranges");
        if (jsonArrayranges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ranges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ranges` to be an array in the JSON string but got `%s`", jsonObj.get("ranges").toString()));
          }

          // validate the optional field `ranges` (array)
          for (int i = 0; i < jsonArrayranges.size(); i++) {
            Range.validateJsonElement(jsonArrayranges.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamedRange.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamedRange' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamedRange> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamedRange.class));

       return (TypeAdapter<T>) new TypeAdapter<NamedRange>() {
           @Override
           public void write(JsonWriter out, NamedRange value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamedRange read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamedRange given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamedRange
   * @throws IOException if the JSON string is invalid with respect to NamedRange
   */
  public static NamedRange fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamedRange.class);
  }

  /**
   * Convert an instance of NamedRange to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

