/*
 * Google Docs API
 * Reads and writes Google Docs documents.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.CropProperties;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties of an image.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:07.584674-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ImageProperties {
  public static final String SERIALIZED_NAME_ANGLE = "angle";
  @SerializedName(SERIALIZED_NAME_ANGLE)
  private Float angle;

  public static final String SERIALIZED_NAME_BRIGHTNESS = "brightness";
  @SerializedName(SERIALIZED_NAME_BRIGHTNESS)
  private Float brightness;

  public static final String SERIALIZED_NAME_CONTENT_URI = "contentUri";
  @SerializedName(SERIALIZED_NAME_CONTENT_URI)
  private String contentUri;

  public static final String SERIALIZED_NAME_CONTRAST = "contrast";
  @SerializedName(SERIALIZED_NAME_CONTRAST)
  private Float contrast;

  public static final String SERIALIZED_NAME_CROP_PROPERTIES = "cropProperties";
  @SerializedName(SERIALIZED_NAME_CROP_PROPERTIES)
  private CropProperties cropProperties;

  public static final String SERIALIZED_NAME_SOURCE_URI = "sourceUri";
  @SerializedName(SERIALIZED_NAME_SOURCE_URI)
  private String sourceUri;

  public static final String SERIALIZED_NAME_TRANSPARENCY = "transparency";
  @SerializedName(SERIALIZED_NAME_TRANSPARENCY)
  private Float transparency;

  public ImageProperties() {
  }

  public ImageProperties angle(Float angle) {
    this.angle = angle;
    return this;
  }

  /**
   * The clockwise rotation angle of the image, in radians.
   * @return angle
   */
  @javax.annotation.Nullable
  public Float getAngle() {
    return angle;
  }

  public void setAngle(Float angle) {
    this.angle = angle;
  }


  public ImageProperties brightness(Float brightness) {
    this.brightness = brightness;
    return this;
  }

  /**
   * The brightness effect of the image. The value should be in the interval [-1.0, 1.0], where 0 means no effect.
   * @return brightness
   */
  @javax.annotation.Nullable
  public Float getBrightness() {
    return brightness;
  }

  public void setBrightness(Float brightness) {
    this.brightness = brightness;
  }


  public ImageProperties contentUri(String contentUri) {
    this.contentUri = contentUri;
    return this;
  }

  /**
   * A URI to the image with a default lifetime of 30 minutes. This URI is tagged with the account of the requester. Anyone with the URI effectively accesses the image as the original requester. Access to the image may be lost if the document&#39;s sharing settings change.
   * @return contentUri
   */
  @javax.annotation.Nullable
  public String getContentUri() {
    return contentUri;
  }

  public void setContentUri(String contentUri) {
    this.contentUri = contentUri;
  }


  public ImageProperties contrast(Float contrast) {
    this.contrast = contrast;
    return this;
  }

  /**
   * The contrast effect of the image. The value should be in the interval [-1.0, 1.0], where 0 means no effect.
   * @return contrast
   */
  @javax.annotation.Nullable
  public Float getContrast() {
    return contrast;
  }

  public void setContrast(Float contrast) {
    this.contrast = contrast;
  }


  public ImageProperties cropProperties(CropProperties cropProperties) {
    this.cropProperties = cropProperties;
    return this;
  }

  /**
   * Get cropProperties
   * @return cropProperties
   */
  @javax.annotation.Nullable
  public CropProperties getCropProperties() {
    return cropProperties;
  }

  public void setCropProperties(CropProperties cropProperties) {
    this.cropProperties = cropProperties;
  }


  public ImageProperties sourceUri(String sourceUri) {
    this.sourceUri = sourceUri;
    return this;
  }

  /**
   * The source URI is the URI used to insert the image. The source URI can be empty.
   * @return sourceUri
   */
  @javax.annotation.Nullable
  public String getSourceUri() {
    return sourceUri;
  }

  public void setSourceUri(String sourceUri) {
    this.sourceUri = sourceUri;
  }


  public ImageProperties transparency(Float transparency) {
    this.transparency = transparency;
    return this;
  }

  /**
   * The transparency effect of the image. The value should be in the interval [0.0, 1.0], where 0 means no effect and 1 means transparent.
   * @return transparency
   */
  @javax.annotation.Nullable
  public Float getTransparency() {
    return transparency;
  }

  public void setTransparency(Float transparency) {
    this.transparency = transparency;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImageProperties imageProperties = (ImageProperties) o;
    return Objects.equals(this.angle, imageProperties.angle) &&
        Objects.equals(this.brightness, imageProperties.brightness) &&
        Objects.equals(this.contentUri, imageProperties.contentUri) &&
        Objects.equals(this.contrast, imageProperties.contrast) &&
        Objects.equals(this.cropProperties, imageProperties.cropProperties) &&
        Objects.equals(this.sourceUri, imageProperties.sourceUri) &&
        Objects.equals(this.transparency, imageProperties.transparency);
  }

  @Override
  public int hashCode() {
    return Objects.hash(angle, brightness, contentUri, contrast, cropProperties, sourceUri, transparency);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImageProperties {\n");
    sb.append("    angle: ").append(toIndentedString(angle)).append("\n");
    sb.append("    brightness: ").append(toIndentedString(brightness)).append("\n");
    sb.append("    contentUri: ").append(toIndentedString(contentUri)).append("\n");
    sb.append("    contrast: ").append(toIndentedString(contrast)).append("\n");
    sb.append("    cropProperties: ").append(toIndentedString(cropProperties)).append("\n");
    sb.append("    sourceUri: ").append(toIndentedString(sourceUri)).append("\n");
    sb.append("    transparency: ").append(toIndentedString(transparency)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("angle");
    openapiFields.add("brightness");
    openapiFields.add("contentUri");
    openapiFields.add("contrast");
    openapiFields.add("cropProperties");
    openapiFields.add("sourceUri");
    openapiFields.add("transparency");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ImageProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ImageProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ImageProperties is not found in the empty JSON string", ImageProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ImageProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ImageProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("contentUri") != null && !jsonObj.get("contentUri").isJsonNull()) && !jsonObj.get("contentUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentUri").toString()));
      }
      // validate the optional field `cropProperties`
      if (jsonObj.get("cropProperties") != null && !jsonObj.get("cropProperties").isJsonNull()) {
        CropProperties.validateJsonElement(jsonObj.get("cropProperties"));
      }
      if ((jsonObj.get("sourceUri") != null && !jsonObj.get("sourceUri").isJsonNull()) && !jsonObj.get("sourceUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ImageProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ImageProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ImageProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ImageProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<ImageProperties>() {
           @Override
           public void write(JsonWriter out, ImageProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ImageProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ImageProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ImageProperties
   * @throws IOException if the JSON string is invalid with respect to ImageProperties
   */
  public static ImageProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ImageProperties.class);
  }

  /**
   * Convert an instance of ImageProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

