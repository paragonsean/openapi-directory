/*
 * Google Docs API
 * Reads and writes Google Docs documents.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Dimension;
import org.openapitools.client.model.SectionColumnProperties;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The styling that applies to a section.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:07.584674-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SectionStyle {
  public static final String SERIALIZED_NAME_COLUMN_PROPERTIES = "columnProperties";
  @SerializedName(SERIALIZED_NAME_COLUMN_PROPERTIES)
  private List<SectionColumnProperties> columnProperties = new ArrayList<>();

  /**
   * The style of column separators. This style can be set even when there&#39;s one column in the section. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   */
  @JsonAdapter(ColumnSeparatorStyleEnum.Adapter.class)
  public enum ColumnSeparatorStyleEnum {
    COLUMN_SEPARATOR_STYLE_UNSPECIFIED("COLUMN_SEPARATOR_STYLE_UNSPECIFIED"),
    
    NONE("NONE"),
    
    BETWEEN_EACH_COLUMN("BETWEEN_EACH_COLUMN");

    private String value;

    ColumnSeparatorStyleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ColumnSeparatorStyleEnum fromValue(String value) {
      for (ColumnSeparatorStyleEnum b : ColumnSeparatorStyleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ColumnSeparatorStyleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ColumnSeparatorStyleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ColumnSeparatorStyleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ColumnSeparatorStyleEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ColumnSeparatorStyleEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COLUMN_SEPARATOR_STYLE = "columnSeparatorStyle";
  @SerializedName(SERIALIZED_NAME_COLUMN_SEPARATOR_STYLE)
  private ColumnSeparatorStyleEnum columnSeparatorStyle;

  /**
   * The content direction of this section. If unset, the value defaults to LEFT_TO_RIGHT. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   */
  @JsonAdapter(ContentDirectionEnum.Adapter.class)
  public enum ContentDirectionEnum {
    CONTENT_DIRECTION_UNSPECIFIED("CONTENT_DIRECTION_UNSPECIFIED"),
    
    LEFT_TO_RIGHT("LEFT_TO_RIGHT"),
    
    RIGHT_TO_LEFT("RIGHT_TO_LEFT");

    private String value;

    ContentDirectionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContentDirectionEnum fromValue(String value) {
      for (ContentDirectionEnum b : ContentDirectionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ContentDirectionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentDirectionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentDirectionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ContentDirectionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ContentDirectionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONTENT_DIRECTION = "contentDirection";
  @SerializedName(SERIALIZED_NAME_CONTENT_DIRECTION)
  private ContentDirectionEnum contentDirection;

  public static final String SERIALIZED_NAME_DEFAULT_FOOTER_ID = "defaultFooterId";
  @SerializedName(SERIALIZED_NAME_DEFAULT_FOOTER_ID)
  private String defaultFooterId;

  public static final String SERIALIZED_NAME_DEFAULT_HEADER_ID = "defaultHeaderId";
  @SerializedName(SERIALIZED_NAME_DEFAULT_HEADER_ID)
  private String defaultHeaderId;

  public static final String SERIALIZED_NAME_EVEN_PAGE_FOOTER_ID = "evenPageFooterId";
  @SerializedName(SERIALIZED_NAME_EVEN_PAGE_FOOTER_ID)
  private String evenPageFooterId;

  public static final String SERIALIZED_NAME_EVEN_PAGE_HEADER_ID = "evenPageHeaderId";
  @SerializedName(SERIALIZED_NAME_EVEN_PAGE_HEADER_ID)
  private String evenPageHeaderId;

  public static final String SERIALIZED_NAME_FIRST_PAGE_FOOTER_ID = "firstPageFooterId";
  @SerializedName(SERIALIZED_NAME_FIRST_PAGE_FOOTER_ID)
  private String firstPageFooterId;

  public static final String SERIALIZED_NAME_FIRST_PAGE_HEADER_ID = "firstPageHeaderId";
  @SerializedName(SERIALIZED_NAME_FIRST_PAGE_HEADER_ID)
  private String firstPageHeaderId;

  public static final String SERIALIZED_NAME_FLIP_PAGE_ORIENTATION = "flipPageOrientation";
  @SerializedName(SERIALIZED_NAME_FLIP_PAGE_ORIENTATION)
  private Boolean flipPageOrientation;

  public static final String SERIALIZED_NAME_MARGIN_BOTTOM = "marginBottom";
  @SerializedName(SERIALIZED_NAME_MARGIN_BOTTOM)
  private Dimension marginBottom;

  public static final String SERIALIZED_NAME_MARGIN_FOOTER = "marginFooter";
  @SerializedName(SERIALIZED_NAME_MARGIN_FOOTER)
  private Dimension marginFooter;

  public static final String SERIALIZED_NAME_MARGIN_HEADER = "marginHeader";
  @SerializedName(SERIALIZED_NAME_MARGIN_HEADER)
  private Dimension marginHeader;

  public static final String SERIALIZED_NAME_MARGIN_LEFT = "marginLeft";
  @SerializedName(SERIALIZED_NAME_MARGIN_LEFT)
  private Dimension marginLeft;

  public static final String SERIALIZED_NAME_MARGIN_RIGHT = "marginRight";
  @SerializedName(SERIALIZED_NAME_MARGIN_RIGHT)
  private Dimension marginRight;

  public static final String SERIALIZED_NAME_MARGIN_TOP = "marginTop";
  @SerializedName(SERIALIZED_NAME_MARGIN_TOP)
  private Dimension marginTop;

  public static final String SERIALIZED_NAME_PAGE_NUMBER_START = "pageNumberStart";
  @SerializedName(SERIALIZED_NAME_PAGE_NUMBER_START)
  private Integer pageNumberStart;

  /**
   * Output only. The type of section.
   */
  @JsonAdapter(SectionTypeEnum.Adapter.class)
  public enum SectionTypeEnum {
    SECTION_TYPE_UNSPECIFIED("SECTION_TYPE_UNSPECIFIED"),
    
    CONTINUOUS("CONTINUOUS"),
    
    NEXT_PAGE("NEXT_PAGE");

    private String value;

    SectionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SectionTypeEnum fromValue(String value) {
      for (SectionTypeEnum b : SectionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SectionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SectionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SectionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SectionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SectionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECTION_TYPE = "sectionType";
  @SerializedName(SERIALIZED_NAME_SECTION_TYPE)
  private SectionTypeEnum sectionType;

  public static final String SERIALIZED_NAME_USE_FIRST_PAGE_HEADER_FOOTER = "useFirstPageHeaderFooter";
  @SerializedName(SERIALIZED_NAME_USE_FIRST_PAGE_HEADER_FOOTER)
  private Boolean useFirstPageHeaderFooter;

  public SectionStyle() {
  }

  public SectionStyle columnProperties(List<SectionColumnProperties> columnProperties) {
    this.columnProperties = columnProperties;
    return this;
  }

  public SectionStyle addColumnPropertiesItem(SectionColumnProperties columnPropertiesItem) {
    if (this.columnProperties == null) {
      this.columnProperties = new ArrayList<>();
    }
    this.columnProperties.add(columnPropertiesItem);
    return this;
  }

  /**
   * The section&#39;s columns properties. If empty, the section contains one column with the default properties in the Docs editor. A section can be updated to have no more than 3 columns. When updating this property, setting a concrete value is required. Unsetting this property will result in a 400 bad request error.
   * @return columnProperties
   */
  @javax.annotation.Nullable
  public List<SectionColumnProperties> getColumnProperties() {
    return columnProperties;
  }

  public void setColumnProperties(List<SectionColumnProperties> columnProperties) {
    this.columnProperties = columnProperties;
  }


  public SectionStyle columnSeparatorStyle(ColumnSeparatorStyleEnum columnSeparatorStyle) {
    this.columnSeparatorStyle = columnSeparatorStyle;
    return this;
  }

  /**
   * The style of column separators. This style can be set even when there&#39;s one column in the section. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   * @return columnSeparatorStyle
   */
  @javax.annotation.Nullable
  public ColumnSeparatorStyleEnum getColumnSeparatorStyle() {
    return columnSeparatorStyle;
  }

  public void setColumnSeparatorStyle(ColumnSeparatorStyleEnum columnSeparatorStyle) {
    this.columnSeparatorStyle = columnSeparatorStyle;
  }


  public SectionStyle contentDirection(ContentDirectionEnum contentDirection) {
    this.contentDirection = contentDirection;
    return this;
  }

  /**
   * The content direction of this section. If unset, the value defaults to LEFT_TO_RIGHT. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   * @return contentDirection
   */
  @javax.annotation.Nullable
  public ContentDirectionEnum getContentDirection() {
    return contentDirection;
  }

  public void setContentDirection(ContentDirectionEnum contentDirection) {
    this.contentDirection = contentDirection;
  }


  public SectionStyle defaultFooterId(String defaultFooterId) {
    this.defaultFooterId = defaultFooterId;
    return this;
  }

  /**
   * The ID of the default footer. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s default_footer_id. This property is read-only.
   * @return defaultFooterId
   */
  @javax.annotation.Nullable
  public String getDefaultFooterId() {
    return defaultFooterId;
  }

  public void setDefaultFooterId(String defaultFooterId) {
    this.defaultFooterId = defaultFooterId;
  }


  public SectionStyle defaultHeaderId(String defaultHeaderId) {
    this.defaultHeaderId = defaultHeaderId;
    return this;
  }

  /**
   * The ID of the default header. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s default_header_id. This property is read-only.
   * @return defaultHeaderId
   */
  @javax.annotation.Nullable
  public String getDefaultHeaderId() {
    return defaultHeaderId;
  }

  public void setDefaultHeaderId(String defaultHeaderId) {
    this.defaultHeaderId = defaultHeaderId;
  }


  public SectionStyle evenPageFooterId(String evenPageFooterId) {
    this.evenPageFooterId = evenPageFooterId;
    return this;
  }

  /**
   * The ID of the footer used only for even pages. If the value of DocumentStyle&#39;s use_even_page_header_footer is true, this value is used for the footers on even pages in the section. If it is false, the footers on even pages use the default_footer_id. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s even_page_footer_id. This property is read-only.
   * @return evenPageFooterId
   */
  @javax.annotation.Nullable
  public String getEvenPageFooterId() {
    return evenPageFooterId;
  }

  public void setEvenPageFooterId(String evenPageFooterId) {
    this.evenPageFooterId = evenPageFooterId;
  }


  public SectionStyle evenPageHeaderId(String evenPageHeaderId) {
    this.evenPageHeaderId = evenPageHeaderId;
    return this;
  }

  /**
   * The ID of the header used only for even pages. If the value of DocumentStyle&#39;s use_even_page_header_footer is true, this value is used for the headers on even pages in the section. If it is false, the headers on even pages use the default_header_id. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s even_page_header_id. This property is read-only.
   * @return evenPageHeaderId
   */
  @javax.annotation.Nullable
  public String getEvenPageHeaderId() {
    return evenPageHeaderId;
  }

  public void setEvenPageHeaderId(String evenPageHeaderId) {
    this.evenPageHeaderId = evenPageHeaderId;
  }


  public SectionStyle firstPageFooterId(String firstPageFooterId) {
    this.firstPageFooterId = firstPageFooterId;
    return this;
  }

  /**
   * The ID of the footer used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the footer on the first page of the section. If it&#39;s false, the footer on the first page of the section uses the default_footer_id. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s first_page_footer_id. This property is read-only.
   * @return firstPageFooterId
   */
  @javax.annotation.Nullable
  public String getFirstPageFooterId() {
    return firstPageFooterId;
  }

  public void setFirstPageFooterId(String firstPageFooterId) {
    this.firstPageFooterId = firstPageFooterId;
  }


  public SectionStyle firstPageHeaderId(String firstPageHeaderId) {
    this.firstPageHeaderId = firstPageHeaderId;
    return this;
  }

  /**
   * The ID of the header used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the header on the first page of the section. If it&#39;s false, the header on the first page of the section uses the default_header_id. If unset, the value inherits from the previous SectionBreak&#39;s SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle&#39;s first_page_header_id. This property is read-only.
   * @return firstPageHeaderId
   */
  @javax.annotation.Nullable
  public String getFirstPageHeaderId() {
    return firstPageHeaderId;
  }

  public void setFirstPageHeaderId(String firstPageHeaderId) {
    this.firstPageHeaderId = firstPageHeaderId;
  }


  public SectionStyle flipPageOrientation(Boolean flipPageOrientation) {
    this.flipPageOrientation = flipPageOrientation;
    return this;
  }

  /**
   * Optional. Indicates whether to flip the dimensions of DocumentStyle&#39;s page_size for this section, which allows changing the page orientation between portrait and landscape. If unset, the value inherits from DocumentStyle&#39;s flip_page_orientation. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   * @return flipPageOrientation
   */
  @javax.annotation.Nullable
  public Boolean getFlipPageOrientation() {
    return flipPageOrientation;
  }

  public void setFlipPageOrientation(Boolean flipPageOrientation) {
    this.flipPageOrientation = flipPageOrientation;
  }


  public SectionStyle marginBottom(Dimension marginBottom) {
    this.marginBottom = marginBottom;
    return this;
  }

  /**
   * Get marginBottom
   * @return marginBottom
   */
  @javax.annotation.Nullable
  public Dimension getMarginBottom() {
    return marginBottom;
  }

  public void setMarginBottom(Dimension marginBottom) {
    this.marginBottom = marginBottom;
  }


  public SectionStyle marginFooter(Dimension marginFooter) {
    this.marginFooter = marginFooter;
    return this;
  }

  /**
   * Get marginFooter
   * @return marginFooter
   */
  @javax.annotation.Nullable
  public Dimension getMarginFooter() {
    return marginFooter;
  }

  public void setMarginFooter(Dimension marginFooter) {
    this.marginFooter = marginFooter;
  }


  public SectionStyle marginHeader(Dimension marginHeader) {
    this.marginHeader = marginHeader;
    return this;
  }

  /**
   * Get marginHeader
   * @return marginHeader
   */
  @javax.annotation.Nullable
  public Dimension getMarginHeader() {
    return marginHeader;
  }

  public void setMarginHeader(Dimension marginHeader) {
    this.marginHeader = marginHeader;
  }


  public SectionStyle marginLeft(Dimension marginLeft) {
    this.marginLeft = marginLeft;
    return this;
  }

  /**
   * Get marginLeft
   * @return marginLeft
   */
  @javax.annotation.Nullable
  public Dimension getMarginLeft() {
    return marginLeft;
  }

  public void setMarginLeft(Dimension marginLeft) {
    this.marginLeft = marginLeft;
  }


  public SectionStyle marginRight(Dimension marginRight) {
    this.marginRight = marginRight;
    return this;
  }

  /**
   * Get marginRight
   * @return marginRight
   */
  @javax.annotation.Nullable
  public Dimension getMarginRight() {
    return marginRight;
  }

  public void setMarginRight(Dimension marginRight) {
    this.marginRight = marginRight;
  }


  public SectionStyle marginTop(Dimension marginTop) {
    this.marginTop = marginTop;
    return this;
  }

  /**
   * Get marginTop
   * @return marginTop
   */
  @javax.annotation.Nullable
  public Dimension getMarginTop() {
    return marginTop;
  }

  public void setMarginTop(Dimension marginTop) {
    this.marginTop = marginTop;
  }


  public SectionStyle pageNumberStart(Integer pageNumberStart) {
    this.pageNumberStart = pageNumberStart;
    return this;
  }

  /**
   * The page number from which to start counting the number of pages for this section. If unset, page numbering continues from the previous section. If the value is unset in the first SectionBreak, refer to DocumentStyle&#39;s page_number_start. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   * @return pageNumberStart
   */
  @javax.annotation.Nullable
  public Integer getPageNumberStart() {
    return pageNumberStart;
  }

  public void setPageNumberStart(Integer pageNumberStart) {
    this.pageNumberStart = pageNumberStart;
  }


  public SectionStyle sectionType(SectionTypeEnum sectionType) {
    this.sectionType = sectionType;
    return this;
  }

  /**
   * Output only. The type of section.
   * @return sectionType
   */
  @javax.annotation.Nullable
  public SectionTypeEnum getSectionType() {
    return sectionType;
  }

  public void setSectionType(SectionTypeEnum sectionType) {
    this.sectionType = sectionType;
  }


  public SectionStyle useFirstPageHeaderFooter(Boolean useFirstPageHeaderFooter) {
    this.useFirstPageHeaderFooter = useFirstPageHeaderFooter;
    return this;
  }

  /**
   * Indicates whether to use the first page header / footer IDs for the first page of the section. If unset, it inherits from DocumentStyle&#39;s use_first_page_header_footer for the first section. If the value is unset for subsequent sectors, it should be interpreted as false. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.
   * @return useFirstPageHeaderFooter
   */
  @javax.annotation.Nullable
  public Boolean getUseFirstPageHeaderFooter() {
    return useFirstPageHeaderFooter;
  }

  public void setUseFirstPageHeaderFooter(Boolean useFirstPageHeaderFooter) {
    this.useFirstPageHeaderFooter = useFirstPageHeaderFooter;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SectionStyle sectionStyle = (SectionStyle) o;
    return Objects.equals(this.columnProperties, sectionStyle.columnProperties) &&
        Objects.equals(this.columnSeparatorStyle, sectionStyle.columnSeparatorStyle) &&
        Objects.equals(this.contentDirection, sectionStyle.contentDirection) &&
        Objects.equals(this.defaultFooterId, sectionStyle.defaultFooterId) &&
        Objects.equals(this.defaultHeaderId, sectionStyle.defaultHeaderId) &&
        Objects.equals(this.evenPageFooterId, sectionStyle.evenPageFooterId) &&
        Objects.equals(this.evenPageHeaderId, sectionStyle.evenPageHeaderId) &&
        Objects.equals(this.firstPageFooterId, sectionStyle.firstPageFooterId) &&
        Objects.equals(this.firstPageHeaderId, sectionStyle.firstPageHeaderId) &&
        Objects.equals(this.flipPageOrientation, sectionStyle.flipPageOrientation) &&
        Objects.equals(this.marginBottom, sectionStyle.marginBottom) &&
        Objects.equals(this.marginFooter, sectionStyle.marginFooter) &&
        Objects.equals(this.marginHeader, sectionStyle.marginHeader) &&
        Objects.equals(this.marginLeft, sectionStyle.marginLeft) &&
        Objects.equals(this.marginRight, sectionStyle.marginRight) &&
        Objects.equals(this.marginTop, sectionStyle.marginTop) &&
        Objects.equals(this.pageNumberStart, sectionStyle.pageNumberStart) &&
        Objects.equals(this.sectionType, sectionStyle.sectionType) &&
        Objects.equals(this.useFirstPageHeaderFooter, sectionStyle.useFirstPageHeaderFooter);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columnProperties, columnSeparatorStyle, contentDirection, defaultFooterId, defaultHeaderId, evenPageFooterId, evenPageHeaderId, firstPageFooterId, firstPageHeaderId, flipPageOrientation, marginBottom, marginFooter, marginHeader, marginLeft, marginRight, marginTop, pageNumberStart, sectionType, useFirstPageHeaderFooter);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SectionStyle {\n");
    sb.append("    columnProperties: ").append(toIndentedString(columnProperties)).append("\n");
    sb.append("    columnSeparatorStyle: ").append(toIndentedString(columnSeparatorStyle)).append("\n");
    sb.append("    contentDirection: ").append(toIndentedString(contentDirection)).append("\n");
    sb.append("    defaultFooterId: ").append(toIndentedString(defaultFooterId)).append("\n");
    sb.append("    defaultHeaderId: ").append(toIndentedString(defaultHeaderId)).append("\n");
    sb.append("    evenPageFooterId: ").append(toIndentedString(evenPageFooterId)).append("\n");
    sb.append("    evenPageHeaderId: ").append(toIndentedString(evenPageHeaderId)).append("\n");
    sb.append("    firstPageFooterId: ").append(toIndentedString(firstPageFooterId)).append("\n");
    sb.append("    firstPageHeaderId: ").append(toIndentedString(firstPageHeaderId)).append("\n");
    sb.append("    flipPageOrientation: ").append(toIndentedString(flipPageOrientation)).append("\n");
    sb.append("    marginBottom: ").append(toIndentedString(marginBottom)).append("\n");
    sb.append("    marginFooter: ").append(toIndentedString(marginFooter)).append("\n");
    sb.append("    marginHeader: ").append(toIndentedString(marginHeader)).append("\n");
    sb.append("    marginLeft: ").append(toIndentedString(marginLeft)).append("\n");
    sb.append("    marginRight: ").append(toIndentedString(marginRight)).append("\n");
    sb.append("    marginTop: ").append(toIndentedString(marginTop)).append("\n");
    sb.append("    pageNumberStart: ").append(toIndentedString(pageNumberStart)).append("\n");
    sb.append("    sectionType: ").append(toIndentedString(sectionType)).append("\n");
    sb.append("    useFirstPageHeaderFooter: ").append(toIndentedString(useFirstPageHeaderFooter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("columnProperties");
    openapiFields.add("columnSeparatorStyle");
    openapiFields.add("contentDirection");
    openapiFields.add("defaultFooterId");
    openapiFields.add("defaultHeaderId");
    openapiFields.add("evenPageFooterId");
    openapiFields.add("evenPageHeaderId");
    openapiFields.add("firstPageFooterId");
    openapiFields.add("firstPageHeaderId");
    openapiFields.add("flipPageOrientation");
    openapiFields.add("marginBottom");
    openapiFields.add("marginFooter");
    openapiFields.add("marginHeader");
    openapiFields.add("marginLeft");
    openapiFields.add("marginRight");
    openapiFields.add("marginTop");
    openapiFields.add("pageNumberStart");
    openapiFields.add("sectionType");
    openapiFields.add("useFirstPageHeaderFooter");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SectionStyle
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SectionStyle.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SectionStyle is not found in the empty JSON string", SectionStyle.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SectionStyle.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SectionStyle` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("columnProperties") != null && !jsonObj.get("columnProperties").isJsonNull()) {
        JsonArray jsonArraycolumnProperties = jsonObj.getAsJsonArray("columnProperties");
        if (jsonArraycolumnProperties != null) {
          // ensure the json data is an array
          if (!jsonObj.get("columnProperties").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `columnProperties` to be an array in the JSON string but got `%s`", jsonObj.get("columnProperties").toString()));
          }

          // validate the optional field `columnProperties` (array)
          for (int i = 0; i < jsonArraycolumnProperties.size(); i++) {
            SectionColumnProperties.validateJsonElement(jsonArraycolumnProperties.get(i));
          };
        }
      }
      if ((jsonObj.get("columnSeparatorStyle") != null && !jsonObj.get("columnSeparatorStyle").isJsonNull()) && !jsonObj.get("columnSeparatorStyle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `columnSeparatorStyle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("columnSeparatorStyle").toString()));
      }
      // validate the optional field `columnSeparatorStyle`
      if (jsonObj.get("columnSeparatorStyle") != null && !jsonObj.get("columnSeparatorStyle").isJsonNull()) {
        ColumnSeparatorStyleEnum.validateJsonElement(jsonObj.get("columnSeparatorStyle"));
      }
      if ((jsonObj.get("contentDirection") != null && !jsonObj.get("contentDirection").isJsonNull()) && !jsonObj.get("contentDirection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentDirection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentDirection").toString()));
      }
      // validate the optional field `contentDirection`
      if (jsonObj.get("contentDirection") != null && !jsonObj.get("contentDirection").isJsonNull()) {
        ContentDirectionEnum.validateJsonElement(jsonObj.get("contentDirection"));
      }
      if ((jsonObj.get("defaultFooterId") != null && !jsonObj.get("defaultFooterId").isJsonNull()) && !jsonObj.get("defaultFooterId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultFooterId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultFooterId").toString()));
      }
      if ((jsonObj.get("defaultHeaderId") != null && !jsonObj.get("defaultHeaderId").isJsonNull()) && !jsonObj.get("defaultHeaderId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultHeaderId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultHeaderId").toString()));
      }
      if ((jsonObj.get("evenPageFooterId") != null && !jsonObj.get("evenPageFooterId").isJsonNull()) && !jsonObj.get("evenPageFooterId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `evenPageFooterId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("evenPageFooterId").toString()));
      }
      if ((jsonObj.get("evenPageHeaderId") != null && !jsonObj.get("evenPageHeaderId").isJsonNull()) && !jsonObj.get("evenPageHeaderId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `evenPageHeaderId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("evenPageHeaderId").toString()));
      }
      if ((jsonObj.get("firstPageFooterId") != null && !jsonObj.get("firstPageFooterId").isJsonNull()) && !jsonObj.get("firstPageFooterId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `firstPageFooterId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("firstPageFooterId").toString()));
      }
      if ((jsonObj.get("firstPageHeaderId") != null && !jsonObj.get("firstPageHeaderId").isJsonNull()) && !jsonObj.get("firstPageHeaderId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `firstPageHeaderId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("firstPageHeaderId").toString()));
      }
      // validate the optional field `marginBottom`
      if (jsonObj.get("marginBottom") != null && !jsonObj.get("marginBottom").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginBottom"));
      }
      // validate the optional field `marginFooter`
      if (jsonObj.get("marginFooter") != null && !jsonObj.get("marginFooter").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginFooter"));
      }
      // validate the optional field `marginHeader`
      if (jsonObj.get("marginHeader") != null && !jsonObj.get("marginHeader").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginHeader"));
      }
      // validate the optional field `marginLeft`
      if (jsonObj.get("marginLeft") != null && !jsonObj.get("marginLeft").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginLeft"));
      }
      // validate the optional field `marginRight`
      if (jsonObj.get("marginRight") != null && !jsonObj.get("marginRight").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginRight"));
      }
      // validate the optional field `marginTop`
      if (jsonObj.get("marginTop") != null && !jsonObj.get("marginTop").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("marginTop"));
      }
      if ((jsonObj.get("sectionType") != null && !jsonObj.get("sectionType").isJsonNull()) && !jsonObj.get("sectionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sectionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sectionType").toString()));
      }
      // validate the optional field `sectionType`
      if (jsonObj.get("sectionType") != null && !jsonObj.get("sectionType").isJsonNull()) {
        SectionTypeEnum.validateJsonElement(jsonObj.get("sectionType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SectionStyle.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SectionStyle' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SectionStyle> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SectionStyle.class));

       return (TypeAdapter<T>) new TypeAdapter<SectionStyle>() {
           @Override
           public void write(JsonWriter out, SectionStyle value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SectionStyle read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SectionStyle given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SectionStyle
   * @throws IOException if the JSON string is invalid with respect to SectionStyle
   */
  public static SectionStyle fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SectionStyle.class);
  }

  /**
   * Convert an instance of SectionStyle to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

