/*
 * Google Docs API
 * Reads and writes Google Docs documents.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.Body;
import org.openapitools.client.model.DocumentStyle;
import org.openapitools.client.model.Footer;
import org.openapitools.client.model.Footnote;
import org.openapitools.client.model.Header;
import org.openapitools.client.model.InlineObject;
import org.openapitools.client.model.ModelList;
import org.openapitools.client.model.NamedRanges;
import org.openapitools.client.model.NamedStyles;
import org.openapitools.client.model.PositionedObject;
import org.openapitools.client.model.SuggestedDocumentStyle;
import org.openapitools.client.model.SuggestedNamedStyles;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Google Docs document.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:07.584674-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Document {
  public static final String SERIALIZED_NAME_BODY = "body";
  @SerializedName(SERIALIZED_NAME_BODY)
  private Body body;

  public static final String SERIALIZED_NAME_DOCUMENT_ID = "documentId";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_ID)
  private String documentId;

  public static final String SERIALIZED_NAME_DOCUMENT_STYLE = "documentStyle";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_STYLE)
  private DocumentStyle documentStyle;

  public static final String SERIALIZED_NAME_FOOTERS = "footers";
  @SerializedName(SERIALIZED_NAME_FOOTERS)
  private Map<String, Footer> footers = new HashMap<>();

  public static final String SERIALIZED_NAME_FOOTNOTES = "footnotes";
  @SerializedName(SERIALIZED_NAME_FOOTNOTES)
  private Map<String, Footnote> footnotes = new HashMap<>();

  public static final String SERIALIZED_NAME_HEADERS = "headers";
  @SerializedName(SERIALIZED_NAME_HEADERS)
  private Map<String, Header> headers = new HashMap<>();

  public static final String SERIALIZED_NAME_INLINE_OBJECTS = "inlineObjects";
  @SerializedName(SERIALIZED_NAME_INLINE_OBJECTS)
  private Map<String, InlineObject> inlineObjects = new HashMap<>();

  public static final String SERIALIZED_NAME_LISTS = "lists";
  @SerializedName(SERIALIZED_NAME_LISTS)
  private Map<String, ModelList> lists = new HashMap<>();

  public static final String SERIALIZED_NAME_NAMED_RANGES = "namedRanges";
  @SerializedName(SERIALIZED_NAME_NAMED_RANGES)
  private Map<String, NamedRanges> namedRanges = new HashMap<>();

  public static final String SERIALIZED_NAME_NAMED_STYLES = "namedStyles";
  @SerializedName(SERIALIZED_NAME_NAMED_STYLES)
  private NamedStyles namedStyles;

  public static final String SERIALIZED_NAME_POSITIONED_OBJECTS = "positionedObjects";
  @SerializedName(SERIALIZED_NAME_POSITIONED_OBJECTS)
  private Map<String, PositionedObject> positionedObjects = new HashMap<>();

  public static final String SERIALIZED_NAME_REVISION_ID = "revisionId";
  @SerializedName(SERIALIZED_NAME_REVISION_ID)
  private String revisionId;

  public static final String SERIALIZED_NAME_SUGGESTED_DOCUMENT_STYLE_CHANGES = "suggestedDocumentStyleChanges";
  @SerializedName(SERIALIZED_NAME_SUGGESTED_DOCUMENT_STYLE_CHANGES)
  private Map<String, SuggestedDocumentStyle> suggestedDocumentStyleChanges = new HashMap<>();

  public static final String SERIALIZED_NAME_SUGGESTED_NAMED_STYLES_CHANGES = "suggestedNamedStylesChanges";
  @SerializedName(SERIALIZED_NAME_SUGGESTED_NAMED_STYLES_CHANGES)
  private Map<String, SuggestedNamedStyles> suggestedNamedStylesChanges = new HashMap<>();

  /**
   * Output only. The suggestions view mode applied to the document. Note: When editing a document, changes must be based on a document with SUGGESTIONS_INLINE.
   */
  @JsonAdapter(SuggestionsViewModeEnum.Adapter.class)
  public enum SuggestionsViewModeEnum {
    DEFAULT_FOR_CURRENT_ACCESS("DEFAULT_FOR_CURRENT_ACCESS"),
    
    SUGGESTIONS_INLINE("SUGGESTIONS_INLINE"),
    
    PREVIEW_SUGGESTIONS_ACCEPTED("PREVIEW_SUGGESTIONS_ACCEPTED"),
    
    PREVIEW_WITHOUT_SUGGESTIONS("PREVIEW_WITHOUT_SUGGESTIONS");

    private String value;

    SuggestionsViewModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SuggestionsViewModeEnum fromValue(String value) {
      for (SuggestionsViewModeEnum b : SuggestionsViewModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SuggestionsViewModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SuggestionsViewModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SuggestionsViewModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SuggestionsViewModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SuggestionsViewModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUGGESTIONS_VIEW_MODE = "suggestionsViewMode";
  @SerializedName(SERIALIZED_NAME_SUGGESTIONS_VIEW_MODE)
  private SuggestionsViewModeEnum suggestionsViewMode;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public Document() {
  }

  public Document body(Body body) {
    this.body = body;
    return this;
  }

  /**
   * Get body
   * @return body
   */
  @javax.annotation.Nullable
  public Body getBody() {
    return body;
  }

  public void setBody(Body body) {
    this.body = body;
  }


  public Document documentId(String documentId) {
    this.documentId = documentId;
    return this;
  }

  /**
   * Output only. The ID of the document.
   * @return documentId
   */
  @javax.annotation.Nullable
  public String getDocumentId() {
    return documentId;
  }

  public void setDocumentId(String documentId) {
    this.documentId = documentId;
  }


  public Document documentStyle(DocumentStyle documentStyle) {
    this.documentStyle = documentStyle;
    return this;
  }

  /**
   * Get documentStyle
   * @return documentStyle
   */
  @javax.annotation.Nullable
  public DocumentStyle getDocumentStyle() {
    return documentStyle;
  }

  public void setDocumentStyle(DocumentStyle documentStyle) {
    this.documentStyle = documentStyle;
  }


  public Document footers(Map<String, Footer> footers) {
    this.footers = footers;
    return this;
  }

  public Document putFootersItem(String key, Footer footersItem) {
    if (this.footers == null) {
      this.footers = new HashMap<>();
    }
    this.footers.put(key, footersItem);
    return this;
  }

  /**
   * Output only. The footers in the document, keyed by footer ID.
   * @return footers
   */
  @javax.annotation.Nullable
  public Map<String, Footer> getFooters() {
    return footers;
  }

  public void setFooters(Map<String, Footer> footers) {
    this.footers = footers;
  }


  public Document footnotes(Map<String, Footnote> footnotes) {
    this.footnotes = footnotes;
    return this;
  }

  public Document putFootnotesItem(String key, Footnote footnotesItem) {
    if (this.footnotes == null) {
      this.footnotes = new HashMap<>();
    }
    this.footnotes.put(key, footnotesItem);
    return this;
  }

  /**
   * Output only. The footnotes in the document, keyed by footnote ID.
   * @return footnotes
   */
  @javax.annotation.Nullable
  public Map<String, Footnote> getFootnotes() {
    return footnotes;
  }

  public void setFootnotes(Map<String, Footnote> footnotes) {
    this.footnotes = footnotes;
  }


  public Document headers(Map<String, Header> headers) {
    this.headers = headers;
    return this;
  }

  public Document putHeadersItem(String key, Header headersItem) {
    if (this.headers == null) {
      this.headers = new HashMap<>();
    }
    this.headers.put(key, headersItem);
    return this;
  }

  /**
   * Output only. The headers in the document, keyed by header ID.
   * @return headers
   */
  @javax.annotation.Nullable
  public Map<String, Header> getHeaders() {
    return headers;
  }

  public void setHeaders(Map<String, Header> headers) {
    this.headers = headers;
  }


  public Document inlineObjects(Map<String, InlineObject> inlineObjects) {
    this.inlineObjects = inlineObjects;
    return this;
  }

  public Document putInlineObjectsItem(String key, InlineObject inlineObjectsItem) {
    if (this.inlineObjects == null) {
      this.inlineObjects = new HashMap<>();
    }
    this.inlineObjects.put(key, inlineObjectsItem);
    return this;
  }

  /**
   * Output only. The inline objects in the document, keyed by object ID.
   * @return inlineObjects
   */
  @javax.annotation.Nullable
  public Map<String, InlineObject> getInlineObjects() {
    return inlineObjects;
  }

  public void setInlineObjects(Map<String, InlineObject> inlineObjects) {
    this.inlineObjects = inlineObjects;
  }


  public Document lists(Map<String, ModelList> lists) {
    this.lists = lists;
    return this;
  }

  public Document putListsItem(String key, ModelList listsItem) {
    if (this.lists == null) {
      this.lists = new HashMap<>();
    }
    this.lists.put(key, listsItem);
    return this;
  }

  /**
   * Output only. The lists in the document, keyed by list ID.
   * @return lists
   */
  @javax.annotation.Nullable
  public Map<String, ModelList> getLists() {
    return lists;
  }

  public void setLists(Map<String, ModelList> lists) {
    this.lists = lists;
  }


  public Document namedRanges(Map<String, NamedRanges> namedRanges) {
    this.namedRanges = namedRanges;
    return this;
  }

  public Document putNamedRangesItem(String key, NamedRanges namedRangesItem) {
    if (this.namedRanges == null) {
      this.namedRanges = new HashMap<>();
    }
    this.namedRanges.put(key, namedRangesItem);
    return this;
  }

  /**
   * Output only. The named ranges in the document, keyed by name.
   * @return namedRanges
   */
  @javax.annotation.Nullable
  public Map<String, NamedRanges> getNamedRanges() {
    return namedRanges;
  }

  public void setNamedRanges(Map<String, NamedRanges> namedRanges) {
    this.namedRanges = namedRanges;
  }


  public Document namedStyles(NamedStyles namedStyles) {
    this.namedStyles = namedStyles;
    return this;
  }

  /**
   * Get namedStyles
   * @return namedStyles
   */
  @javax.annotation.Nullable
  public NamedStyles getNamedStyles() {
    return namedStyles;
  }

  public void setNamedStyles(NamedStyles namedStyles) {
    this.namedStyles = namedStyles;
  }


  public Document positionedObjects(Map<String, PositionedObject> positionedObjects) {
    this.positionedObjects = positionedObjects;
    return this;
  }

  public Document putPositionedObjectsItem(String key, PositionedObject positionedObjectsItem) {
    if (this.positionedObjects == null) {
      this.positionedObjects = new HashMap<>();
    }
    this.positionedObjects.put(key, positionedObjectsItem);
    return this;
  }

  /**
   * Output only. The positioned objects in the document, keyed by object ID.
   * @return positionedObjects
   */
  @javax.annotation.Nullable
  public Map<String, PositionedObject> getPositionedObjects() {
    return positionedObjects;
  }

  public void setPositionedObjects(Map<String, PositionedObject> positionedObjects) {
    this.positionedObjects = positionedObjects;
  }


  public Document revisionId(String revisionId) {
    this.revisionId = revisionId;
    return this;
  }

  /**
   * Output only. The revision ID of the document. Can be used in update requests to specify which revision of a document to apply updates to and how the request should behave if the document has been edited since that revision. Only populated if the user has edit access to the document. The revision ID is not a sequential number but an opaque string. The format of the revision ID might change over time. A returned revision ID is only guaranteed to be valid for 24 hours after it has been returned and cannot be shared across users. If the revision ID is unchanged between calls, then the document has not changed. Conversely, a changed ID (for the same document and user) usually means the document has been updated. However, a changed ID can also be due to internal factors such as ID format changes.
   * @return revisionId
   */
  @javax.annotation.Nullable
  public String getRevisionId() {
    return revisionId;
  }

  public void setRevisionId(String revisionId) {
    this.revisionId = revisionId;
  }


  public Document suggestedDocumentStyleChanges(Map<String, SuggestedDocumentStyle> suggestedDocumentStyleChanges) {
    this.suggestedDocumentStyleChanges = suggestedDocumentStyleChanges;
    return this;
  }

  public Document putSuggestedDocumentStyleChangesItem(String key, SuggestedDocumentStyle suggestedDocumentStyleChangesItem) {
    if (this.suggestedDocumentStyleChanges == null) {
      this.suggestedDocumentStyleChanges = new HashMap<>();
    }
    this.suggestedDocumentStyleChanges.put(key, suggestedDocumentStyleChangesItem);
    return this;
  }

  /**
   * Output only. The suggested changes to the style of the document, keyed by suggestion ID.
   * @return suggestedDocumentStyleChanges
   */
  @javax.annotation.Nullable
  public Map<String, SuggestedDocumentStyle> getSuggestedDocumentStyleChanges() {
    return suggestedDocumentStyleChanges;
  }

  public void setSuggestedDocumentStyleChanges(Map<String, SuggestedDocumentStyle> suggestedDocumentStyleChanges) {
    this.suggestedDocumentStyleChanges = suggestedDocumentStyleChanges;
  }


  public Document suggestedNamedStylesChanges(Map<String, SuggestedNamedStyles> suggestedNamedStylesChanges) {
    this.suggestedNamedStylesChanges = suggestedNamedStylesChanges;
    return this;
  }

  public Document putSuggestedNamedStylesChangesItem(String key, SuggestedNamedStyles suggestedNamedStylesChangesItem) {
    if (this.suggestedNamedStylesChanges == null) {
      this.suggestedNamedStylesChanges = new HashMap<>();
    }
    this.suggestedNamedStylesChanges.put(key, suggestedNamedStylesChangesItem);
    return this;
  }

  /**
   * Output only. The suggested changes to the named styles of the document, keyed by suggestion ID.
   * @return suggestedNamedStylesChanges
   */
  @javax.annotation.Nullable
  public Map<String, SuggestedNamedStyles> getSuggestedNamedStylesChanges() {
    return suggestedNamedStylesChanges;
  }

  public void setSuggestedNamedStylesChanges(Map<String, SuggestedNamedStyles> suggestedNamedStylesChanges) {
    this.suggestedNamedStylesChanges = suggestedNamedStylesChanges;
  }


  public Document suggestionsViewMode(SuggestionsViewModeEnum suggestionsViewMode) {
    this.suggestionsViewMode = suggestionsViewMode;
    return this;
  }

  /**
   * Output only. The suggestions view mode applied to the document. Note: When editing a document, changes must be based on a document with SUGGESTIONS_INLINE.
   * @return suggestionsViewMode
   */
  @javax.annotation.Nullable
  public SuggestionsViewModeEnum getSuggestionsViewMode() {
    return suggestionsViewMode;
  }

  public void setSuggestionsViewMode(SuggestionsViewModeEnum suggestionsViewMode) {
    this.suggestionsViewMode = suggestionsViewMode;
  }


  public Document title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the document.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Document document = (Document) o;
    return Objects.equals(this.body, document.body) &&
        Objects.equals(this.documentId, document.documentId) &&
        Objects.equals(this.documentStyle, document.documentStyle) &&
        Objects.equals(this.footers, document.footers) &&
        Objects.equals(this.footnotes, document.footnotes) &&
        Objects.equals(this.headers, document.headers) &&
        Objects.equals(this.inlineObjects, document.inlineObjects) &&
        Objects.equals(this.lists, document.lists) &&
        Objects.equals(this.namedRanges, document.namedRanges) &&
        Objects.equals(this.namedStyles, document.namedStyles) &&
        Objects.equals(this.positionedObjects, document.positionedObjects) &&
        Objects.equals(this.revisionId, document.revisionId) &&
        Objects.equals(this.suggestedDocumentStyleChanges, document.suggestedDocumentStyleChanges) &&
        Objects.equals(this.suggestedNamedStylesChanges, document.suggestedNamedStylesChanges) &&
        Objects.equals(this.suggestionsViewMode, document.suggestionsViewMode) &&
        Objects.equals(this.title, document.title);
  }

  @Override
  public int hashCode() {
    return Objects.hash(body, documentId, documentStyle, footers, footnotes, headers, inlineObjects, lists, namedRanges, namedStyles, positionedObjects, revisionId, suggestedDocumentStyleChanges, suggestedNamedStylesChanges, suggestionsViewMode, title);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Document {\n");
    sb.append("    body: ").append(toIndentedString(body)).append("\n");
    sb.append("    documentId: ").append(toIndentedString(documentId)).append("\n");
    sb.append("    documentStyle: ").append(toIndentedString(documentStyle)).append("\n");
    sb.append("    footers: ").append(toIndentedString(footers)).append("\n");
    sb.append("    footnotes: ").append(toIndentedString(footnotes)).append("\n");
    sb.append("    headers: ").append(toIndentedString(headers)).append("\n");
    sb.append("    inlineObjects: ").append(toIndentedString(inlineObjects)).append("\n");
    sb.append("    lists: ").append(toIndentedString(lists)).append("\n");
    sb.append("    namedRanges: ").append(toIndentedString(namedRanges)).append("\n");
    sb.append("    namedStyles: ").append(toIndentedString(namedStyles)).append("\n");
    sb.append("    positionedObjects: ").append(toIndentedString(positionedObjects)).append("\n");
    sb.append("    revisionId: ").append(toIndentedString(revisionId)).append("\n");
    sb.append("    suggestedDocumentStyleChanges: ").append(toIndentedString(suggestedDocumentStyleChanges)).append("\n");
    sb.append("    suggestedNamedStylesChanges: ").append(toIndentedString(suggestedNamedStylesChanges)).append("\n");
    sb.append("    suggestionsViewMode: ").append(toIndentedString(suggestionsViewMode)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("body");
    openapiFields.add("documentId");
    openapiFields.add("documentStyle");
    openapiFields.add("footers");
    openapiFields.add("footnotes");
    openapiFields.add("headers");
    openapiFields.add("inlineObjects");
    openapiFields.add("lists");
    openapiFields.add("namedRanges");
    openapiFields.add("namedStyles");
    openapiFields.add("positionedObjects");
    openapiFields.add("revisionId");
    openapiFields.add("suggestedDocumentStyleChanges");
    openapiFields.add("suggestedNamedStylesChanges");
    openapiFields.add("suggestionsViewMode");
    openapiFields.add("title");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Document
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Document.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Document is not found in the empty JSON string", Document.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Document.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Document` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `body`
      if (jsonObj.get("body") != null && !jsonObj.get("body").isJsonNull()) {
        Body.validateJsonElement(jsonObj.get("body"));
      }
      if ((jsonObj.get("documentId") != null && !jsonObj.get("documentId").isJsonNull()) && !jsonObj.get("documentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentId").toString()));
      }
      // validate the optional field `documentStyle`
      if (jsonObj.get("documentStyle") != null && !jsonObj.get("documentStyle").isJsonNull()) {
        DocumentStyle.validateJsonElement(jsonObj.get("documentStyle"));
      }
      // validate the optional field `namedStyles`
      if (jsonObj.get("namedStyles") != null && !jsonObj.get("namedStyles").isJsonNull()) {
        NamedStyles.validateJsonElement(jsonObj.get("namedStyles"));
      }
      if ((jsonObj.get("revisionId") != null && !jsonObj.get("revisionId").isJsonNull()) && !jsonObj.get("revisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionId").toString()));
      }
      if ((jsonObj.get("suggestionsViewMode") != null && !jsonObj.get("suggestionsViewMode").isJsonNull()) && !jsonObj.get("suggestionsViewMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suggestionsViewMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suggestionsViewMode").toString()));
      }
      // validate the optional field `suggestionsViewMode`
      if (jsonObj.get("suggestionsViewMode") != null && !jsonObj.get("suggestionsViewMode").isJsonNull()) {
        SuggestionsViewModeEnum.validateJsonElement(jsonObj.get("suggestionsViewMode"));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Document.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Document' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Document> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Document.class));

       return (TypeAdapter<T>) new TypeAdapter<Document>() {
           @Override
           public void write(JsonWriter out, Document value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Document read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Document given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Document
   * @throws IOException if the JSON string is invalid with respect to Document
   */
  public static Document fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Document.class);
  }

  /**
   * Convert an instance of Document to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

