# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.maintenance_policy import MaintenancePolicy
from openapi_server.models.maintenance_schedule import MaintenanceSchedule
from openapi_server.models.node_info import NodeInfo
from openapi_server.models.persistence_config import PersistenceConfig
from openapi_server.models.tls_certificate import TlsCertificate
from openapi_server import util


class Instance(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, alternative_location_id: str=None, auth_enabled: bool=None, authorized_network: str=None, available_maintenance_versions: List[str]=None, connect_mode: str=None, create_time: str=None, current_location_id: str=None, customer_managed_key: str=None, display_name: str=None, host: str=None, labels: Dict[str, str]=None, location_id: str=None, maintenance_policy: MaintenancePolicy=None, maintenance_schedule: MaintenanceSchedule=None, maintenance_version: str=None, memory_size_gb: int=None, name: str=None, nodes: List[NodeInfo]=None, persistence_config: PersistenceConfig=None, persistence_iam_identity: str=None, port: int=None, read_endpoint: str=None, read_endpoint_port: int=None, read_replicas_mode: str=None, redis_configs: Dict[str, str]=None, redis_version: str=None, replica_count: int=None, reserved_ip_range: str=None, satisfies_pzi: bool=None, satisfies_pzs: bool=None, secondary_ip_range: str=None, server_ca_certs: List[TlsCertificate]=None, state: str=None, status_message: str=None, suspension_reasons: List[str]=None, tier: str=None, transit_encryption_mode: str=None):
        """Instance - a model defined in OpenAPI

        :param alternative_location_id: The alternative_location_id of this Instance.
        :param auth_enabled: The auth_enabled of this Instance.
        :param authorized_network: The authorized_network of this Instance.
        :param available_maintenance_versions: The available_maintenance_versions of this Instance.
        :param connect_mode: The connect_mode of this Instance.
        :param create_time: The create_time of this Instance.
        :param current_location_id: The current_location_id of this Instance.
        :param customer_managed_key: The customer_managed_key of this Instance.
        :param display_name: The display_name of this Instance.
        :param host: The host of this Instance.
        :param labels: The labels of this Instance.
        :param location_id: The location_id of this Instance.
        :param maintenance_policy: The maintenance_policy of this Instance.
        :param maintenance_schedule: The maintenance_schedule of this Instance.
        :param maintenance_version: The maintenance_version of this Instance.
        :param memory_size_gb: The memory_size_gb of this Instance.
        :param name: The name of this Instance.
        :param nodes: The nodes of this Instance.
        :param persistence_config: The persistence_config of this Instance.
        :param persistence_iam_identity: The persistence_iam_identity of this Instance.
        :param port: The port of this Instance.
        :param read_endpoint: The read_endpoint of this Instance.
        :param read_endpoint_port: The read_endpoint_port of this Instance.
        :param read_replicas_mode: The read_replicas_mode of this Instance.
        :param redis_configs: The redis_configs of this Instance.
        :param redis_version: The redis_version of this Instance.
        :param replica_count: The replica_count of this Instance.
        :param reserved_ip_range: The reserved_ip_range of this Instance.
        :param satisfies_pzi: The satisfies_pzi of this Instance.
        :param satisfies_pzs: The satisfies_pzs of this Instance.
        :param secondary_ip_range: The secondary_ip_range of this Instance.
        :param server_ca_certs: The server_ca_certs of this Instance.
        :param state: The state of this Instance.
        :param status_message: The status_message of this Instance.
        :param suspension_reasons: The suspension_reasons of this Instance.
        :param tier: The tier of this Instance.
        :param transit_encryption_mode: The transit_encryption_mode of this Instance.
        """
        self.openapi_types = {
            'alternative_location_id': str,
            'auth_enabled': bool,
            'authorized_network': str,
            'available_maintenance_versions': List[str],
            'connect_mode': str,
            'create_time': str,
            'current_location_id': str,
            'customer_managed_key': str,
            'display_name': str,
            'host': str,
            'labels': Dict[str, str],
            'location_id': str,
            'maintenance_policy': MaintenancePolicy,
            'maintenance_schedule': MaintenanceSchedule,
            'maintenance_version': str,
            'memory_size_gb': int,
            'name': str,
            'nodes': List[NodeInfo],
            'persistence_config': PersistenceConfig,
            'persistence_iam_identity': str,
            'port': int,
            'read_endpoint': str,
            'read_endpoint_port': int,
            'read_replicas_mode': str,
            'redis_configs': Dict[str, str],
            'redis_version': str,
            'replica_count': int,
            'reserved_ip_range': str,
            'satisfies_pzi': bool,
            'satisfies_pzs': bool,
            'secondary_ip_range': str,
            'server_ca_certs': List[TlsCertificate],
            'state': str,
            'status_message': str,
            'suspension_reasons': List[str],
            'tier': str,
            'transit_encryption_mode': str
        }

        self.attribute_map = {
            'alternative_location_id': 'alternativeLocationId',
            'auth_enabled': 'authEnabled',
            'authorized_network': 'authorizedNetwork',
            'available_maintenance_versions': 'availableMaintenanceVersions',
            'connect_mode': 'connectMode',
            'create_time': 'createTime',
            'current_location_id': 'currentLocationId',
            'customer_managed_key': 'customerManagedKey',
            'display_name': 'displayName',
            'host': 'host',
            'labels': 'labels',
            'location_id': 'locationId',
            'maintenance_policy': 'maintenancePolicy',
            'maintenance_schedule': 'maintenanceSchedule',
            'maintenance_version': 'maintenanceVersion',
            'memory_size_gb': 'memorySizeGb',
            'name': 'name',
            'nodes': 'nodes',
            'persistence_config': 'persistenceConfig',
            'persistence_iam_identity': 'persistenceIamIdentity',
            'port': 'port',
            'read_endpoint': 'readEndpoint',
            'read_endpoint_port': 'readEndpointPort',
            'read_replicas_mode': 'readReplicasMode',
            'redis_configs': 'redisConfigs',
            'redis_version': 'redisVersion',
            'replica_count': 'replicaCount',
            'reserved_ip_range': 'reservedIpRange',
            'satisfies_pzi': 'satisfiesPzi',
            'satisfies_pzs': 'satisfiesPzs',
            'secondary_ip_range': 'secondaryIpRange',
            'server_ca_certs': 'serverCaCerts',
            'state': 'state',
            'status_message': 'statusMessage',
            'suspension_reasons': 'suspensionReasons',
            'tier': 'tier',
            'transit_encryption_mode': 'transitEncryptionMode'
        }

        self._alternative_location_id = alternative_location_id
        self._auth_enabled = auth_enabled
        self._authorized_network = authorized_network
        self._available_maintenance_versions = available_maintenance_versions
        self._connect_mode = connect_mode
        self._create_time = create_time
        self._current_location_id = current_location_id
        self._customer_managed_key = customer_managed_key
        self._display_name = display_name
        self._host = host
        self._labels = labels
        self._location_id = location_id
        self._maintenance_policy = maintenance_policy
        self._maintenance_schedule = maintenance_schedule
        self._maintenance_version = maintenance_version
        self._memory_size_gb = memory_size_gb
        self._name = name
        self._nodes = nodes
        self._persistence_config = persistence_config
        self._persistence_iam_identity = persistence_iam_identity
        self._port = port
        self._read_endpoint = read_endpoint
        self._read_endpoint_port = read_endpoint_port
        self._read_replicas_mode = read_replicas_mode
        self._redis_configs = redis_configs
        self._redis_version = redis_version
        self._replica_count = replica_count
        self._reserved_ip_range = reserved_ip_range
        self._satisfies_pzi = satisfies_pzi
        self._satisfies_pzs = satisfies_pzs
        self._secondary_ip_range = secondary_ip_range
        self._server_ca_certs = server_ca_certs
        self._state = state
        self._status_message = status_message
        self._suspension_reasons = suspension_reasons
        self._tier = tier
        self._transit_encryption_mode = transit_encryption_mode

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Instance':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Instance of this Instance.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def alternative_location_id(self):
        """Gets the alternative_location_id of this Instance.

        Optional. If specified, at least one node will be provisioned in this zone in addition to the zone specified in location_id. Only applicable to standard tier. If provided, it must be a different zone from the one provided in [location_id]. Additional nodes beyond the first 2 will be placed in zones selected by the service.

        :return: The alternative_location_id of this Instance.
        :rtype: str
        """
        return self._alternative_location_id

    @alternative_location_id.setter
    def alternative_location_id(self, alternative_location_id):
        """Sets the alternative_location_id of this Instance.

        Optional. If specified, at least one node will be provisioned in this zone in addition to the zone specified in location_id. Only applicable to standard tier. If provided, it must be a different zone from the one provided in [location_id]. Additional nodes beyond the first 2 will be placed in zones selected by the service.

        :param alternative_location_id: The alternative_location_id of this Instance.
        :type alternative_location_id: str
        """

        self._alternative_location_id = alternative_location_id

    @property
    def auth_enabled(self):
        """Gets the auth_enabled of this Instance.

        Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If set to \"true\" AUTH is enabled on the instance. Default value is \"false\" meaning AUTH is disabled.

        :return: The auth_enabled of this Instance.
        :rtype: bool
        """
        return self._auth_enabled

    @auth_enabled.setter
    def auth_enabled(self, auth_enabled):
        """Sets the auth_enabled of this Instance.

        Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If set to \"true\" AUTH is enabled on the instance. Default value is \"false\" meaning AUTH is disabled.

        :param auth_enabled: The auth_enabled of this Instance.
        :type auth_enabled: bool
        """

        self._auth_enabled = auth_enabled

    @property
    def authorized_network(self):
        """Gets the authorized_network of this Instance.

        Optional. The full name of the Google Compute Engine [network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected. If left unspecified, the `default` network will be used.

        :return: The authorized_network of this Instance.
        :rtype: str
        """
        return self._authorized_network

    @authorized_network.setter
    def authorized_network(self, authorized_network):
        """Sets the authorized_network of this Instance.

        Optional. The full name of the Google Compute Engine [network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected. If left unspecified, the `default` network will be used.

        :param authorized_network: The authorized_network of this Instance.
        :type authorized_network: str
        """

        self._authorized_network = authorized_network

    @property
    def available_maintenance_versions(self):
        """Gets the available_maintenance_versions of this Instance.

        Optional. The available maintenance versions that an instance could update to.

        :return: The available_maintenance_versions of this Instance.
        :rtype: List[str]
        """
        return self._available_maintenance_versions

    @available_maintenance_versions.setter
    def available_maintenance_versions(self, available_maintenance_versions):
        """Sets the available_maintenance_versions of this Instance.

        Optional. The available maintenance versions that an instance could update to.

        :param available_maintenance_versions: The available_maintenance_versions of this Instance.
        :type available_maintenance_versions: List[str]
        """

        self._available_maintenance_versions = available_maintenance_versions

    @property
    def connect_mode(self):
        """Gets the connect_mode of this Instance.

        Optional. The network connect mode of the Redis instance. If not provided, the connect mode defaults to DIRECT_PEERING.

        :return: The connect_mode of this Instance.
        :rtype: str
        """
        return self._connect_mode

    @connect_mode.setter
    def connect_mode(self, connect_mode):
        """Sets the connect_mode of this Instance.

        Optional. The network connect mode of the Redis instance. If not provided, the connect mode defaults to DIRECT_PEERING.

        :param connect_mode: The connect_mode of this Instance.
        :type connect_mode: str
        """
        allowed_values = ["CONNECT_MODE_UNSPECIFIED", "DIRECT_PEERING", "PRIVATE_SERVICE_ACCESS"]  # noqa: E501
        if connect_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `connect_mode` ({0}), must be one of {1}"
                .format(connect_mode, allowed_values)
            )

        self._connect_mode = connect_mode

    @property
    def create_time(self):
        """Gets the create_time of this Instance.

        Output only. The time the instance was created.

        :return: The create_time of this Instance.
        :rtype: str
        """
        return self._create_time

    @create_time.setter
    def create_time(self, create_time):
        """Sets the create_time of this Instance.

        Output only. The time the instance was created.

        :param create_time: The create_time of this Instance.
        :type create_time: str
        """

        self._create_time = create_time

    @property
    def current_location_id(self):
        """Gets the current_location_id of this Instance.

        Output only. The current zone where the Redis primary node is located. In basic tier, this will always be the same as [location_id]. In standard tier, this can be the zone of any node in the instance.

        :return: The current_location_id of this Instance.
        :rtype: str
        """
        return self._current_location_id

    @current_location_id.setter
    def current_location_id(self, current_location_id):
        """Sets the current_location_id of this Instance.

        Output only. The current zone where the Redis primary node is located. In basic tier, this will always be the same as [location_id]. In standard tier, this can be the zone of any node in the instance.

        :param current_location_id: The current_location_id of this Instance.
        :type current_location_id: str
        """

        self._current_location_id = current_location_id

    @property
    def customer_managed_key(self):
        """Gets the customer_managed_key of this Instance.

        Optional. The KMS key reference that the customer provides when trying to create the instance.

        :return: The customer_managed_key of this Instance.
        :rtype: str
        """
        return self._customer_managed_key

    @customer_managed_key.setter
    def customer_managed_key(self, customer_managed_key):
        """Sets the customer_managed_key of this Instance.

        Optional. The KMS key reference that the customer provides when trying to create the instance.

        :param customer_managed_key: The customer_managed_key of this Instance.
        :type customer_managed_key: str
        """

        self._customer_managed_key = customer_managed_key

    @property
    def display_name(self):
        """Gets the display_name of this Instance.

        An arbitrary and optional user-provided name for the instance.

        :return: The display_name of this Instance.
        :rtype: str
        """
        return self._display_name

    @display_name.setter
    def display_name(self, display_name):
        """Sets the display_name of this Instance.

        An arbitrary and optional user-provided name for the instance.

        :param display_name: The display_name of this Instance.
        :type display_name: str
        """

        self._display_name = display_name

    @property
    def host(self):
        """Gets the host of this Instance.

        Output only. Hostname or IP address of the exposed Redis endpoint used by clients to connect to the service.

        :return: The host of this Instance.
        :rtype: str
        """
        return self._host

    @host.setter
    def host(self, host):
        """Sets the host of this Instance.

        Output only. Hostname or IP address of the exposed Redis endpoint used by clients to connect to the service.

        :param host: The host of this Instance.
        :type host: str
        """

        self._host = host

    @property
    def labels(self):
        """Gets the labels of this Instance.

        Resource labels to represent user provided metadata

        :return: The labels of this Instance.
        :rtype: Dict[str, str]
        """
        return self._labels

    @labels.setter
    def labels(self, labels):
        """Sets the labels of this Instance.

        Resource labels to represent user provided metadata

        :param labels: The labels of this Instance.
        :type labels: Dict[str, str]
        """

        self._labels = labels

    @property
    def location_id(self):
        """Gets the location_id of this Instance.

        Optional. The zone where the instance will be provisioned. If not provided, the service will choose a zone from the specified region for the instance. For standard tier, additional nodes will be added across multiple zones for protection against zonal failures. If specified, at least one node will be provisioned in this zone.

        :return: The location_id of this Instance.
        :rtype: str
        """
        return self._location_id

    @location_id.setter
    def location_id(self, location_id):
        """Sets the location_id of this Instance.

        Optional. The zone where the instance will be provisioned. If not provided, the service will choose a zone from the specified region for the instance. For standard tier, additional nodes will be added across multiple zones for protection against zonal failures. If specified, at least one node will be provisioned in this zone.

        :param location_id: The location_id of this Instance.
        :type location_id: str
        """

        self._location_id = location_id

    @property
    def maintenance_policy(self):
        """Gets the maintenance_policy of this Instance.


        :return: The maintenance_policy of this Instance.
        :rtype: MaintenancePolicy
        """
        return self._maintenance_policy

    @maintenance_policy.setter
    def maintenance_policy(self, maintenance_policy):
        """Sets the maintenance_policy of this Instance.


        :param maintenance_policy: The maintenance_policy of this Instance.
        :type maintenance_policy: MaintenancePolicy
        """

        self._maintenance_policy = maintenance_policy

    @property
    def maintenance_schedule(self):
        """Gets the maintenance_schedule of this Instance.


        :return: The maintenance_schedule of this Instance.
        :rtype: MaintenanceSchedule
        """
        return self._maintenance_schedule

    @maintenance_schedule.setter
    def maintenance_schedule(self, maintenance_schedule):
        """Sets the maintenance_schedule of this Instance.


        :param maintenance_schedule: The maintenance_schedule of this Instance.
        :type maintenance_schedule: MaintenanceSchedule
        """

        self._maintenance_schedule = maintenance_schedule

    @property
    def maintenance_version(self):
        """Gets the maintenance_version of this Instance.

        Optional. The self service update maintenance version. The version is date based such as \"20210712_00_00\".

        :return: The maintenance_version of this Instance.
        :rtype: str
        """
        return self._maintenance_version

    @maintenance_version.setter
    def maintenance_version(self, maintenance_version):
        """Sets the maintenance_version of this Instance.

        Optional. The self service update maintenance version. The version is date based such as \"20210712_00_00\".

        :param maintenance_version: The maintenance_version of this Instance.
        :type maintenance_version: str
        """

        self._maintenance_version = maintenance_version

    @property
    def memory_size_gb(self):
        """Gets the memory_size_gb of this Instance.

        Required. Redis memory size in GiB.

        :return: The memory_size_gb of this Instance.
        :rtype: int
        """
        return self._memory_size_gb

    @memory_size_gb.setter
    def memory_size_gb(self, memory_size_gb):
        """Sets the memory_size_gb of this Instance.

        Required. Redis memory size in GiB.

        :param memory_size_gb: The memory_size_gb of this Instance.
        :type memory_size_gb: int
        """

        self._memory_size_gb = memory_size_gb

    @property
    def name(self):
        """Gets the name of this Instance.

        Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` Note: Redis instances are managed and addressed at regional level so location_id here refers to a GCP region; however, users may choose which specific zone (or collection of zones for cross-zone instances) an instance should be provisioned in. Refer to location_id and alternative_location_id fields for more details.

        :return: The name of this Instance.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Instance.

        Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` Note: Redis instances are managed and addressed at regional level so location_id here refers to a GCP region; however, users may choose which specific zone (or collection of zones for cross-zone instances) an instance should be provisioned in. Refer to location_id and alternative_location_id fields for more details.

        :param name: The name of this Instance.
        :type name: str
        """

        self._name = name

    @property
    def nodes(self):
        """Gets the nodes of this Instance.

        Output only. Info per node.

        :return: The nodes of this Instance.
        :rtype: List[NodeInfo]
        """
        return self._nodes

    @nodes.setter
    def nodes(self, nodes):
        """Sets the nodes of this Instance.

        Output only. Info per node.

        :param nodes: The nodes of this Instance.
        :type nodes: List[NodeInfo]
        """

        self._nodes = nodes

    @property
    def persistence_config(self):
        """Gets the persistence_config of this Instance.


        :return: The persistence_config of this Instance.
        :rtype: PersistenceConfig
        """
        return self._persistence_config

    @persistence_config.setter
    def persistence_config(self, persistence_config):
        """Sets the persistence_config of this Instance.


        :param persistence_config: The persistence_config of this Instance.
        :type persistence_config: PersistenceConfig
        """

        self._persistence_config = persistence_config

    @property
    def persistence_iam_identity(self):
        """Gets the persistence_iam_identity of this Instance.

        Output only. Cloud IAM identity used by import / export operations to transfer data to/from Cloud Storage. Format is \"serviceAccount:\". The value may change over time for a given instance so should be checked before each import/export operation.

        :return: The persistence_iam_identity of this Instance.
        :rtype: str
        """
        return self._persistence_iam_identity

    @persistence_iam_identity.setter
    def persistence_iam_identity(self, persistence_iam_identity):
        """Sets the persistence_iam_identity of this Instance.

        Output only. Cloud IAM identity used by import / export operations to transfer data to/from Cloud Storage. Format is \"serviceAccount:\". The value may change over time for a given instance so should be checked before each import/export operation.

        :param persistence_iam_identity: The persistence_iam_identity of this Instance.
        :type persistence_iam_identity: str
        """

        self._persistence_iam_identity = persistence_iam_identity

    @property
    def port(self):
        """Gets the port of this Instance.

        Output only. The port number of the exposed Redis endpoint.

        :return: The port of this Instance.
        :rtype: int
        """
        return self._port

    @port.setter
    def port(self, port):
        """Sets the port of this Instance.

        Output only. The port number of the exposed Redis endpoint.

        :param port: The port of this Instance.
        :type port: int
        """

        self._port = port

    @property
    def read_endpoint(self):
        """Gets the read_endpoint of this Instance.

        Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only. Targets all healthy replica nodes in instance. Replication is asynchronous and replica nodes will exhibit some lag behind the primary. Write requests must target 'host'.

        :return: The read_endpoint of this Instance.
        :rtype: str
        """
        return self._read_endpoint

    @read_endpoint.setter
    def read_endpoint(self, read_endpoint):
        """Sets the read_endpoint of this Instance.

        Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only. Targets all healthy replica nodes in instance. Replication is asynchronous and replica nodes will exhibit some lag behind the primary. Write requests must target 'host'.

        :param read_endpoint: The read_endpoint of this Instance.
        :type read_endpoint: str
        """

        self._read_endpoint = read_endpoint

    @property
    def read_endpoint_port(self):
        """Gets the read_endpoint_port of this Instance.

        Output only. The port number of the exposed readonly redis endpoint. Standard tier only. Write requests should target 'port'.

        :return: The read_endpoint_port of this Instance.
        :rtype: int
        """
        return self._read_endpoint_port

    @read_endpoint_port.setter
    def read_endpoint_port(self, read_endpoint_port):
        """Sets the read_endpoint_port of this Instance.

        Output only. The port number of the exposed readonly redis endpoint. Standard tier only. Write requests should target 'port'.

        :param read_endpoint_port: The read_endpoint_port of this Instance.
        :type read_endpoint_port: int
        """

        self._read_endpoint_port = read_endpoint_port

    @property
    def read_replicas_mode(self):
        """Gets the read_replicas_mode of this Instance.

        Optional. Read replicas mode for the instance. Defaults to READ_REPLICAS_DISABLED.

        :return: The read_replicas_mode of this Instance.
        :rtype: str
        """
        return self._read_replicas_mode

    @read_replicas_mode.setter
    def read_replicas_mode(self, read_replicas_mode):
        """Sets the read_replicas_mode of this Instance.

        Optional. Read replicas mode for the instance. Defaults to READ_REPLICAS_DISABLED.

        :param read_replicas_mode: The read_replicas_mode of this Instance.
        :type read_replicas_mode: str
        """
        allowed_values = ["READ_REPLICAS_MODE_UNSPECIFIED", "READ_REPLICAS_DISABLED", "READ_REPLICAS_ENABLED"]  # noqa: E501
        if read_replicas_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `read_replicas_mode` ({0}), must be one of {1}"
                .format(read_replicas_mode, allowed_values)
            )

        self._read_replicas_mode = read_replicas_mode

    @property
    def redis_configs(self):
        """Gets the redis_configs of this Instance.

        Optional. Redis configuration parameters, according to http://redis.io/topics/config. Currently, the only supported parameters are: Redis version 3.2 and newer: * maxmemory-policy * notify-keyspace-events Redis version 4.0 and newer: * activedefrag * lfu-decay-time * lfu-log-factor * maxmemory-gb Redis version 5.0 and newer: * stream-node-max-bytes * stream-node-max-entries

        :return: The redis_configs of this Instance.
        :rtype: Dict[str, str]
        """
        return self._redis_configs

    @redis_configs.setter
    def redis_configs(self, redis_configs):
        """Sets the redis_configs of this Instance.

        Optional. Redis configuration parameters, according to http://redis.io/topics/config. Currently, the only supported parameters are: Redis version 3.2 and newer: * maxmemory-policy * notify-keyspace-events Redis version 4.0 and newer: * activedefrag * lfu-decay-time * lfu-log-factor * maxmemory-gb Redis version 5.0 and newer: * stream-node-max-bytes * stream-node-max-entries

        :param redis_configs: The redis_configs of this Instance.
        :type redis_configs: Dict[str, str]
        """

        self._redis_configs = redis_configs

    @property
    def redis_version(self):
        """Gets the redis_version of this Instance.

        Optional. The version of Redis software. If not provided, latest supported version will be used. Currently, the supported values are: * `REDIS_3_2` for Redis 3.2 compatibility * `REDIS_4_0` for Redis 4.0 compatibility (default) * `REDIS_5_0` for Redis 5.0 compatibility * `REDIS_6_X` for Redis 6.x compatibility * `REDIS_7_0` for Redis 7.0 compatibility

        :return: The redis_version of this Instance.
        :rtype: str
        """
        return self._redis_version

    @redis_version.setter
    def redis_version(self, redis_version):
        """Sets the redis_version of this Instance.

        Optional. The version of Redis software. If not provided, latest supported version will be used. Currently, the supported values are: * `REDIS_3_2` for Redis 3.2 compatibility * `REDIS_4_0` for Redis 4.0 compatibility (default) * `REDIS_5_0` for Redis 5.0 compatibility * `REDIS_6_X` for Redis 6.x compatibility * `REDIS_7_0` for Redis 7.0 compatibility

        :param redis_version: The redis_version of this Instance.
        :type redis_version: str
        """

        self._redis_version = redis_version

    @property
    def replica_count(self):
        """Gets the replica_count of this Instance.

        Optional. The number of replica nodes. The valid range for the Standard Tier with read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled for a Standard Tier instance, the only valid value is 1 and the default is 1. The valid value for basic tier is 0 and the default is also 0.

        :return: The replica_count of this Instance.
        :rtype: int
        """
        return self._replica_count

    @replica_count.setter
    def replica_count(self, replica_count):
        """Sets the replica_count of this Instance.

        Optional. The number of replica nodes. The valid range for the Standard Tier with read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled for a Standard Tier instance, the only valid value is 1 and the default is 1. The valid value for basic tier is 0 and the default is also 0.

        :param replica_count: The replica_count of this Instance.
        :type replica_count: int
        """

        self._replica_count = replica_count

    @property
    def reserved_ip_range(self):
        """Gets the reserved_ip_range of this Instance.

        Optional. For DIRECT_PEERING mode, the CIDR range of internal addresses that are reserved for this instance. Range must be unique and non-overlapping with existing subnets in an authorized network. For PRIVATE_SERVICE_ACCESS mode, the name of one allocated IP address ranges associated with this private service access connection. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. For READ_REPLICAS_ENABLED the default block size is /28.

        :return: The reserved_ip_range of this Instance.
        :rtype: str
        """
        return self._reserved_ip_range

    @reserved_ip_range.setter
    def reserved_ip_range(self, reserved_ip_range):
        """Sets the reserved_ip_range of this Instance.

        Optional. For DIRECT_PEERING mode, the CIDR range of internal addresses that are reserved for this instance. Range must be unique and non-overlapping with existing subnets in an authorized network. For PRIVATE_SERVICE_ACCESS mode, the name of one allocated IP address ranges associated with this private service access connection. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. For READ_REPLICAS_ENABLED the default block size is /28.

        :param reserved_ip_range: The reserved_ip_range of this Instance.
        :type reserved_ip_range: str
        """

        self._reserved_ip_range = reserved_ip_range

    @property
    def satisfies_pzi(self):
        """Gets the satisfies_pzi of this Instance.

        Optional. Output only. Reserved for future use.

        :return: The satisfies_pzi of this Instance.
        :rtype: bool
        """
        return self._satisfies_pzi

    @satisfies_pzi.setter
    def satisfies_pzi(self, satisfies_pzi):
        """Sets the satisfies_pzi of this Instance.

        Optional. Output only. Reserved for future use.

        :param satisfies_pzi: The satisfies_pzi of this Instance.
        :type satisfies_pzi: bool
        """

        self._satisfies_pzi = satisfies_pzi

    @property
    def satisfies_pzs(self):
        """Gets the satisfies_pzs of this Instance.

        Optional. Output only. Reserved for future use.

        :return: The satisfies_pzs of this Instance.
        :rtype: bool
        """
        return self._satisfies_pzs

    @satisfies_pzs.setter
    def satisfies_pzs(self, satisfies_pzs):
        """Sets the satisfies_pzs of this Instance.

        Optional. Output only. Reserved for future use.

        :param satisfies_pzs: The satisfies_pzs of this Instance.
        :type satisfies_pzs: bool
        """

        self._satisfies_pzs = satisfies_pzs

    @property
    def secondary_ip_range(self):
        """Gets the secondary_ip_range of this Instance.

        Optional. Additional IP range for node placement. Required when enabling read replicas on an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or \"auto\". For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address range associated with the private service access connection, or \"auto\".

        :return: The secondary_ip_range of this Instance.
        :rtype: str
        """
        return self._secondary_ip_range

    @secondary_ip_range.setter
    def secondary_ip_range(self, secondary_ip_range):
        """Sets the secondary_ip_range of this Instance.

        Optional. Additional IP range for node placement. Required when enabling read replicas on an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or \"auto\". For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address range associated with the private service access connection, or \"auto\".

        :param secondary_ip_range: The secondary_ip_range of this Instance.
        :type secondary_ip_range: str
        """

        self._secondary_ip_range = secondary_ip_range

    @property
    def server_ca_certs(self):
        """Gets the server_ca_certs of this Instance.

        Output only. List of server CA certificates for the instance.

        :return: The server_ca_certs of this Instance.
        :rtype: List[TlsCertificate]
        """
        return self._server_ca_certs

    @server_ca_certs.setter
    def server_ca_certs(self, server_ca_certs):
        """Sets the server_ca_certs of this Instance.

        Output only. List of server CA certificates for the instance.

        :param server_ca_certs: The server_ca_certs of this Instance.
        :type server_ca_certs: List[TlsCertificate]
        """

        self._server_ca_certs = server_ca_certs

    @property
    def state(self):
        """Gets the state of this Instance.

        Output only. The current state of this instance.

        :return: The state of this Instance.
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Instance.

        Output only. The current state of this instance.

        :param state: The state of this Instance.
        :type state: str
        """
        allowed_values = ["STATE_UNSPECIFIED", "CREATING", "READY", "UPDATING", "DELETING", "REPAIRING", "MAINTENANCE", "IMPORTING", "FAILING_OVER"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def status_message(self):
        """Gets the status_message of this Instance.

        Output only. Additional information about the current status of this instance, if available.

        :return: The status_message of this Instance.
        :rtype: str
        """
        return self._status_message

    @status_message.setter
    def status_message(self, status_message):
        """Sets the status_message of this Instance.

        Output only. Additional information about the current status of this instance, if available.

        :param status_message: The status_message of this Instance.
        :type status_message: str
        """

        self._status_message = status_message

    @property
    def suspension_reasons(self):
        """Gets the suspension_reasons of this Instance.

        Optional. reasons that causes instance in \"SUSPENDED\" state.

        :return: The suspension_reasons of this Instance.
        :rtype: List[str]
        """
        return self._suspension_reasons

    @suspension_reasons.setter
    def suspension_reasons(self, suspension_reasons):
        """Sets the suspension_reasons of this Instance.

        Optional. reasons that causes instance in \"SUSPENDED\" state.

        :param suspension_reasons: The suspension_reasons of this Instance.
        :type suspension_reasons: List[str]
        """
        allowed_values = ["SUSPENSION_REASON_UNSPECIFIED", "CUSTOMER_MANAGED_KEY_ISSUE"]  # noqa: E501
        if not set(suspension_reasons).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `suspension_reasons` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(suspension_reasons) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._suspension_reasons = suspension_reasons

    @property
    def tier(self):
        """Gets the tier of this Instance.

        Required. The service tier of the instance.

        :return: The tier of this Instance.
        :rtype: str
        """
        return self._tier

    @tier.setter
    def tier(self, tier):
        """Sets the tier of this Instance.

        Required. The service tier of the instance.

        :param tier: The tier of this Instance.
        :type tier: str
        """
        allowed_values = ["TIER_UNSPECIFIED", "BASIC", "STANDARD_HA"]  # noqa: E501
        if tier not in allowed_values:
            raise ValueError(
                "Invalid value for `tier` ({0}), must be one of {1}"
                .format(tier, allowed_values)
            )

        self._tier = tier

    @property
    def transit_encryption_mode(self):
        """Gets the transit_encryption_mode of this Instance.

        Optional. The TLS mode of the Redis instance. If not provided, TLS is disabled for the instance.

        :return: The transit_encryption_mode of this Instance.
        :rtype: str
        """
        return self._transit_encryption_mode

    @transit_encryption_mode.setter
    def transit_encryption_mode(self, transit_encryption_mode):
        """Sets the transit_encryption_mode of this Instance.

        Optional. The TLS mode of the Redis instance. If not provided, TLS is disabled for the instance.

        :param transit_encryption_mode: The transit_encryption_mode of this Instance.
        :type transit_encryption_mode: str
        """
        allowed_values = ["TRANSIT_ENCRYPTION_MODE_UNSPECIFIED", "SERVER_AUTHENTICATION", "DISABLED"]  # noqa: E501
        if transit_encryption_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `transit_encryption_mode` ({0}), must be one of {1}"
                .format(transit_encryption_mode, allowed_values)
            )

        self._transit_encryption_mode = transit_encryption_mode
