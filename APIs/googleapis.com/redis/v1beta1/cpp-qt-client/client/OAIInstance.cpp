/**
 * Google Cloud Memorystore for Redis API
 * Creates and manages Redis instances on the Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIInstance.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIInstance::OAIInstance(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIInstance::OAIInstance() {
    this->initializeModel();
}

OAIInstance::~OAIInstance() {}

void OAIInstance::initializeModel() {

    m_alternative_location_id_isSet = false;
    m_alternative_location_id_isValid = false;

    m_auth_enabled_isSet = false;
    m_auth_enabled_isValid = false;

    m_authorized_network_isSet = false;
    m_authorized_network_isValid = false;

    m_available_maintenance_versions_isSet = false;
    m_available_maintenance_versions_isValid = false;

    m_connect_mode_isSet = false;
    m_connect_mode_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_current_location_id_isSet = false;
    m_current_location_id_isValid = false;

    m_customer_managed_key_isSet = false;
    m_customer_managed_key_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_host_isSet = false;
    m_host_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_location_id_isSet = false;
    m_location_id_isValid = false;

    m_maintenance_policy_isSet = false;
    m_maintenance_policy_isValid = false;

    m_maintenance_schedule_isSet = false;
    m_maintenance_schedule_isValid = false;

    m_maintenance_version_isSet = false;
    m_maintenance_version_isValid = false;

    m_memory_size_gb_isSet = false;
    m_memory_size_gb_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_nodes_isSet = false;
    m_nodes_isValid = false;

    m_persistence_config_isSet = false;
    m_persistence_config_isValid = false;

    m_persistence_iam_identity_isSet = false;
    m_persistence_iam_identity_isValid = false;

    m_port_isSet = false;
    m_port_isValid = false;

    m_read_endpoint_isSet = false;
    m_read_endpoint_isValid = false;

    m_read_endpoint_port_isSet = false;
    m_read_endpoint_port_isValid = false;

    m_read_replicas_mode_isSet = false;
    m_read_replicas_mode_isValid = false;

    m_redis_configs_isSet = false;
    m_redis_configs_isValid = false;

    m_redis_version_isSet = false;
    m_redis_version_isValid = false;

    m_replica_count_isSet = false;
    m_replica_count_isValid = false;

    m_reserved_ip_range_isSet = false;
    m_reserved_ip_range_isValid = false;

    m_satisfies_pzi_isSet = false;
    m_satisfies_pzi_isValid = false;

    m_satisfies_pzs_isSet = false;
    m_satisfies_pzs_isValid = false;

    m_secondary_ip_range_isSet = false;
    m_secondary_ip_range_isValid = false;

    m_server_ca_certs_isSet = false;
    m_server_ca_certs_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_status_message_isSet = false;
    m_status_message_isValid = false;

    m_suspension_reasons_isSet = false;
    m_suspension_reasons_isValid = false;

    m_tier_isSet = false;
    m_tier_isValid = false;

    m_transit_encryption_mode_isSet = false;
    m_transit_encryption_mode_isValid = false;
}

void OAIInstance::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIInstance::fromJsonObject(QJsonObject json) {

    m_alternative_location_id_isValid = ::OpenAPI::fromJsonValue(m_alternative_location_id, json[QString("alternativeLocationId")]);
    m_alternative_location_id_isSet = !json[QString("alternativeLocationId")].isNull() && m_alternative_location_id_isValid;

    m_auth_enabled_isValid = ::OpenAPI::fromJsonValue(m_auth_enabled, json[QString("authEnabled")]);
    m_auth_enabled_isSet = !json[QString("authEnabled")].isNull() && m_auth_enabled_isValid;

    m_authorized_network_isValid = ::OpenAPI::fromJsonValue(m_authorized_network, json[QString("authorizedNetwork")]);
    m_authorized_network_isSet = !json[QString("authorizedNetwork")].isNull() && m_authorized_network_isValid;

    m_available_maintenance_versions_isValid = ::OpenAPI::fromJsonValue(m_available_maintenance_versions, json[QString("availableMaintenanceVersions")]);
    m_available_maintenance_versions_isSet = !json[QString("availableMaintenanceVersions")].isNull() && m_available_maintenance_versions_isValid;

    m_connect_mode_isValid = ::OpenAPI::fromJsonValue(m_connect_mode, json[QString("connectMode")]);
    m_connect_mode_isSet = !json[QString("connectMode")].isNull() && m_connect_mode_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_current_location_id_isValid = ::OpenAPI::fromJsonValue(m_current_location_id, json[QString("currentLocationId")]);
    m_current_location_id_isSet = !json[QString("currentLocationId")].isNull() && m_current_location_id_isValid;

    m_customer_managed_key_isValid = ::OpenAPI::fromJsonValue(m_customer_managed_key, json[QString("customerManagedKey")]);
    m_customer_managed_key_isSet = !json[QString("customerManagedKey")].isNull() && m_customer_managed_key_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_host_isValid = ::OpenAPI::fromJsonValue(m_host, json[QString("host")]);
    m_host_isSet = !json[QString("host")].isNull() && m_host_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_location_id_isValid = ::OpenAPI::fromJsonValue(m_location_id, json[QString("locationId")]);
    m_location_id_isSet = !json[QString("locationId")].isNull() && m_location_id_isValid;

    m_maintenance_policy_isValid = ::OpenAPI::fromJsonValue(m_maintenance_policy, json[QString("maintenancePolicy")]);
    m_maintenance_policy_isSet = !json[QString("maintenancePolicy")].isNull() && m_maintenance_policy_isValid;

    m_maintenance_schedule_isValid = ::OpenAPI::fromJsonValue(m_maintenance_schedule, json[QString("maintenanceSchedule")]);
    m_maintenance_schedule_isSet = !json[QString("maintenanceSchedule")].isNull() && m_maintenance_schedule_isValid;

    m_maintenance_version_isValid = ::OpenAPI::fromJsonValue(m_maintenance_version, json[QString("maintenanceVersion")]);
    m_maintenance_version_isSet = !json[QString("maintenanceVersion")].isNull() && m_maintenance_version_isValid;

    m_memory_size_gb_isValid = ::OpenAPI::fromJsonValue(m_memory_size_gb, json[QString("memorySizeGb")]);
    m_memory_size_gb_isSet = !json[QString("memorySizeGb")].isNull() && m_memory_size_gb_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_nodes_isValid = ::OpenAPI::fromJsonValue(m_nodes, json[QString("nodes")]);
    m_nodes_isSet = !json[QString("nodes")].isNull() && m_nodes_isValid;

    m_persistence_config_isValid = ::OpenAPI::fromJsonValue(m_persistence_config, json[QString("persistenceConfig")]);
    m_persistence_config_isSet = !json[QString("persistenceConfig")].isNull() && m_persistence_config_isValid;

    m_persistence_iam_identity_isValid = ::OpenAPI::fromJsonValue(m_persistence_iam_identity, json[QString("persistenceIamIdentity")]);
    m_persistence_iam_identity_isSet = !json[QString("persistenceIamIdentity")].isNull() && m_persistence_iam_identity_isValid;

    m_port_isValid = ::OpenAPI::fromJsonValue(m_port, json[QString("port")]);
    m_port_isSet = !json[QString("port")].isNull() && m_port_isValid;

    m_read_endpoint_isValid = ::OpenAPI::fromJsonValue(m_read_endpoint, json[QString("readEndpoint")]);
    m_read_endpoint_isSet = !json[QString("readEndpoint")].isNull() && m_read_endpoint_isValid;

    m_read_endpoint_port_isValid = ::OpenAPI::fromJsonValue(m_read_endpoint_port, json[QString("readEndpointPort")]);
    m_read_endpoint_port_isSet = !json[QString("readEndpointPort")].isNull() && m_read_endpoint_port_isValid;

    m_read_replicas_mode_isValid = ::OpenAPI::fromJsonValue(m_read_replicas_mode, json[QString("readReplicasMode")]);
    m_read_replicas_mode_isSet = !json[QString("readReplicasMode")].isNull() && m_read_replicas_mode_isValid;

    m_redis_configs_isValid = ::OpenAPI::fromJsonValue(m_redis_configs, json[QString("redisConfigs")]);
    m_redis_configs_isSet = !json[QString("redisConfigs")].isNull() && m_redis_configs_isValid;

    m_redis_version_isValid = ::OpenAPI::fromJsonValue(m_redis_version, json[QString("redisVersion")]);
    m_redis_version_isSet = !json[QString("redisVersion")].isNull() && m_redis_version_isValid;

    m_replica_count_isValid = ::OpenAPI::fromJsonValue(m_replica_count, json[QString("replicaCount")]);
    m_replica_count_isSet = !json[QString("replicaCount")].isNull() && m_replica_count_isValid;

    m_reserved_ip_range_isValid = ::OpenAPI::fromJsonValue(m_reserved_ip_range, json[QString("reservedIpRange")]);
    m_reserved_ip_range_isSet = !json[QString("reservedIpRange")].isNull() && m_reserved_ip_range_isValid;

    m_satisfies_pzi_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzi, json[QString("satisfiesPzi")]);
    m_satisfies_pzi_isSet = !json[QString("satisfiesPzi")].isNull() && m_satisfies_pzi_isValid;

    m_satisfies_pzs_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzs, json[QString("satisfiesPzs")]);
    m_satisfies_pzs_isSet = !json[QString("satisfiesPzs")].isNull() && m_satisfies_pzs_isValid;

    m_secondary_ip_range_isValid = ::OpenAPI::fromJsonValue(m_secondary_ip_range, json[QString("secondaryIpRange")]);
    m_secondary_ip_range_isSet = !json[QString("secondaryIpRange")].isNull() && m_secondary_ip_range_isValid;

    m_server_ca_certs_isValid = ::OpenAPI::fromJsonValue(m_server_ca_certs, json[QString("serverCaCerts")]);
    m_server_ca_certs_isSet = !json[QString("serverCaCerts")].isNull() && m_server_ca_certs_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_status_message_isValid = ::OpenAPI::fromJsonValue(m_status_message, json[QString("statusMessage")]);
    m_status_message_isSet = !json[QString("statusMessage")].isNull() && m_status_message_isValid;

    m_suspension_reasons_isValid = ::OpenAPI::fromJsonValue(m_suspension_reasons, json[QString("suspensionReasons")]);
    m_suspension_reasons_isSet = !json[QString("suspensionReasons")].isNull() && m_suspension_reasons_isValid;

    m_tier_isValid = ::OpenAPI::fromJsonValue(m_tier, json[QString("tier")]);
    m_tier_isSet = !json[QString("tier")].isNull() && m_tier_isValid;

    m_transit_encryption_mode_isValid = ::OpenAPI::fromJsonValue(m_transit_encryption_mode, json[QString("transitEncryptionMode")]);
    m_transit_encryption_mode_isSet = !json[QString("transitEncryptionMode")].isNull() && m_transit_encryption_mode_isValid;
}

QString OAIInstance::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIInstance::asJsonObject() const {
    QJsonObject obj;
    if (m_alternative_location_id_isSet) {
        obj.insert(QString("alternativeLocationId"), ::OpenAPI::toJsonValue(m_alternative_location_id));
    }
    if (m_auth_enabled_isSet) {
        obj.insert(QString("authEnabled"), ::OpenAPI::toJsonValue(m_auth_enabled));
    }
    if (m_authorized_network_isSet) {
        obj.insert(QString("authorizedNetwork"), ::OpenAPI::toJsonValue(m_authorized_network));
    }
    if (m_available_maintenance_versions.size() > 0) {
        obj.insert(QString("availableMaintenanceVersions"), ::OpenAPI::toJsonValue(m_available_maintenance_versions));
    }
    if (m_connect_mode_isSet) {
        obj.insert(QString("connectMode"), ::OpenAPI::toJsonValue(m_connect_mode));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_current_location_id_isSet) {
        obj.insert(QString("currentLocationId"), ::OpenAPI::toJsonValue(m_current_location_id));
    }
    if (m_customer_managed_key_isSet) {
        obj.insert(QString("customerManagedKey"), ::OpenAPI::toJsonValue(m_customer_managed_key));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_host_isSet) {
        obj.insert(QString("host"), ::OpenAPI::toJsonValue(m_host));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_location_id_isSet) {
        obj.insert(QString("locationId"), ::OpenAPI::toJsonValue(m_location_id));
    }
    if (m_maintenance_policy.isSet()) {
        obj.insert(QString("maintenancePolicy"), ::OpenAPI::toJsonValue(m_maintenance_policy));
    }
    if (m_maintenance_schedule.isSet()) {
        obj.insert(QString("maintenanceSchedule"), ::OpenAPI::toJsonValue(m_maintenance_schedule));
    }
    if (m_maintenance_version_isSet) {
        obj.insert(QString("maintenanceVersion"), ::OpenAPI::toJsonValue(m_maintenance_version));
    }
    if (m_memory_size_gb_isSet) {
        obj.insert(QString("memorySizeGb"), ::OpenAPI::toJsonValue(m_memory_size_gb));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_nodes.size() > 0) {
        obj.insert(QString("nodes"), ::OpenAPI::toJsonValue(m_nodes));
    }
    if (m_persistence_config.isSet()) {
        obj.insert(QString("persistenceConfig"), ::OpenAPI::toJsonValue(m_persistence_config));
    }
    if (m_persistence_iam_identity_isSet) {
        obj.insert(QString("persistenceIamIdentity"), ::OpenAPI::toJsonValue(m_persistence_iam_identity));
    }
    if (m_port_isSet) {
        obj.insert(QString("port"), ::OpenAPI::toJsonValue(m_port));
    }
    if (m_read_endpoint_isSet) {
        obj.insert(QString("readEndpoint"), ::OpenAPI::toJsonValue(m_read_endpoint));
    }
    if (m_read_endpoint_port_isSet) {
        obj.insert(QString("readEndpointPort"), ::OpenAPI::toJsonValue(m_read_endpoint_port));
    }
    if (m_read_replicas_mode_isSet) {
        obj.insert(QString("readReplicasMode"), ::OpenAPI::toJsonValue(m_read_replicas_mode));
    }
    if (m_redis_configs.size() > 0) {
        obj.insert(QString("redisConfigs"), ::OpenAPI::toJsonValue(m_redis_configs));
    }
    if (m_redis_version_isSet) {
        obj.insert(QString("redisVersion"), ::OpenAPI::toJsonValue(m_redis_version));
    }
    if (m_replica_count_isSet) {
        obj.insert(QString("replicaCount"), ::OpenAPI::toJsonValue(m_replica_count));
    }
    if (m_reserved_ip_range_isSet) {
        obj.insert(QString("reservedIpRange"), ::OpenAPI::toJsonValue(m_reserved_ip_range));
    }
    if (m_satisfies_pzi_isSet) {
        obj.insert(QString("satisfiesPzi"), ::OpenAPI::toJsonValue(m_satisfies_pzi));
    }
    if (m_satisfies_pzs_isSet) {
        obj.insert(QString("satisfiesPzs"), ::OpenAPI::toJsonValue(m_satisfies_pzs));
    }
    if (m_secondary_ip_range_isSet) {
        obj.insert(QString("secondaryIpRange"), ::OpenAPI::toJsonValue(m_secondary_ip_range));
    }
    if (m_server_ca_certs.size() > 0) {
        obj.insert(QString("serverCaCerts"), ::OpenAPI::toJsonValue(m_server_ca_certs));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_status_message_isSet) {
        obj.insert(QString("statusMessage"), ::OpenAPI::toJsonValue(m_status_message));
    }
    if (m_suspension_reasons.size() > 0) {
        obj.insert(QString("suspensionReasons"), ::OpenAPI::toJsonValue(m_suspension_reasons));
    }
    if (m_tier_isSet) {
        obj.insert(QString("tier"), ::OpenAPI::toJsonValue(m_tier));
    }
    if (m_transit_encryption_mode_isSet) {
        obj.insert(QString("transitEncryptionMode"), ::OpenAPI::toJsonValue(m_transit_encryption_mode));
    }
    return obj;
}

QString OAIInstance::getAlternativeLocationId() const {
    return m_alternative_location_id;
}
void OAIInstance::setAlternativeLocationId(const QString &alternative_location_id) {
    m_alternative_location_id = alternative_location_id;
    m_alternative_location_id_isSet = true;
}

bool OAIInstance::is_alternative_location_id_Set() const{
    return m_alternative_location_id_isSet;
}

bool OAIInstance::is_alternative_location_id_Valid() const{
    return m_alternative_location_id_isValid;
}

bool OAIInstance::isAuthEnabled() const {
    return m_auth_enabled;
}
void OAIInstance::setAuthEnabled(const bool &auth_enabled) {
    m_auth_enabled = auth_enabled;
    m_auth_enabled_isSet = true;
}

bool OAIInstance::is_auth_enabled_Set() const{
    return m_auth_enabled_isSet;
}

bool OAIInstance::is_auth_enabled_Valid() const{
    return m_auth_enabled_isValid;
}

QString OAIInstance::getAuthorizedNetwork() const {
    return m_authorized_network;
}
void OAIInstance::setAuthorizedNetwork(const QString &authorized_network) {
    m_authorized_network = authorized_network;
    m_authorized_network_isSet = true;
}

bool OAIInstance::is_authorized_network_Set() const{
    return m_authorized_network_isSet;
}

bool OAIInstance::is_authorized_network_Valid() const{
    return m_authorized_network_isValid;
}

QList<QString> OAIInstance::getAvailableMaintenanceVersions() const {
    return m_available_maintenance_versions;
}
void OAIInstance::setAvailableMaintenanceVersions(const QList<QString> &available_maintenance_versions) {
    m_available_maintenance_versions = available_maintenance_versions;
    m_available_maintenance_versions_isSet = true;
}

bool OAIInstance::is_available_maintenance_versions_Set() const{
    return m_available_maintenance_versions_isSet;
}

bool OAIInstance::is_available_maintenance_versions_Valid() const{
    return m_available_maintenance_versions_isValid;
}

QString OAIInstance::getConnectMode() const {
    return m_connect_mode;
}
void OAIInstance::setConnectMode(const QString &connect_mode) {
    m_connect_mode = connect_mode;
    m_connect_mode_isSet = true;
}

bool OAIInstance::is_connect_mode_Set() const{
    return m_connect_mode_isSet;
}

bool OAIInstance::is_connect_mode_Valid() const{
    return m_connect_mode_isValid;
}

QString OAIInstance::getCreateTime() const {
    return m_create_time;
}
void OAIInstance::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAIInstance::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAIInstance::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QString OAIInstance::getCurrentLocationId() const {
    return m_current_location_id;
}
void OAIInstance::setCurrentLocationId(const QString &current_location_id) {
    m_current_location_id = current_location_id;
    m_current_location_id_isSet = true;
}

bool OAIInstance::is_current_location_id_Set() const{
    return m_current_location_id_isSet;
}

bool OAIInstance::is_current_location_id_Valid() const{
    return m_current_location_id_isValid;
}

QString OAIInstance::getCustomerManagedKey() const {
    return m_customer_managed_key;
}
void OAIInstance::setCustomerManagedKey(const QString &customer_managed_key) {
    m_customer_managed_key = customer_managed_key;
    m_customer_managed_key_isSet = true;
}

bool OAIInstance::is_customer_managed_key_Set() const{
    return m_customer_managed_key_isSet;
}

bool OAIInstance::is_customer_managed_key_Valid() const{
    return m_customer_managed_key_isValid;
}

QString OAIInstance::getDisplayName() const {
    return m_display_name;
}
void OAIInstance::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIInstance::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIInstance::is_display_name_Valid() const{
    return m_display_name_isValid;
}

QString OAIInstance::getHost() const {
    return m_host;
}
void OAIInstance::setHost(const QString &host) {
    m_host = host;
    m_host_isSet = true;
}

bool OAIInstance::is_host_Set() const{
    return m_host_isSet;
}

bool OAIInstance::is_host_Valid() const{
    return m_host_isValid;
}

QMap<QString, QString> OAIInstance::getLabels() const {
    return m_labels;
}
void OAIInstance::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIInstance::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIInstance::is_labels_Valid() const{
    return m_labels_isValid;
}

QString OAIInstance::getLocationId() const {
    return m_location_id;
}
void OAIInstance::setLocationId(const QString &location_id) {
    m_location_id = location_id;
    m_location_id_isSet = true;
}

bool OAIInstance::is_location_id_Set() const{
    return m_location_id_isSet;
}

bool OAIInstance::is_location_id_Valid() const{
    return m_location_id_isValid;
}

OAIMaintenancePolicy OAIInstance::getMaintenancePolicy() const {
    return m_maintenance_policy;
}
void OAIInstance::setMaintenancePolicy(const OAIMaintenancePolicy &maintenance_policy) {
    m_maintenance_policy = maintenance_policy;
    m_maintenance_policy_isSet = true;
}

bool OAIInstance::is_maintenance_policy_Set() const{
    return m_maintenance_policy_isSet;
}

bool OAIInstance::is_maintenance_policy_Valid() const{
    return m_maintenance_policy_isValid;
}

OAIMaintenanceSchedule OAIInstance::getMaintenanceSchedule() const {
    return m_maintenance_schedule;
}
void OAIInstance::setMaintenanceSchedule(const OAIMaintenanceSchedule &maintenance_schedule) {
    m_maintenance_schedule = maintenance_schedule;
    m_maintenance_schedule_isSet = true;
}

bool OAIInstance::is_maintenance_schedule_Set() const{
    return m_maintenance_schedule_isSet;
}

bool OAIInstance::is_maintenance_schedule_Valid() const{
    return m_maintenance_schedule_isValid;
}

QString OAIInstance::getMaintenanceVersion() const {
    return m_maintenance_version;
}
void OAIInstance::setMaintenanceVersion(const QString &maintenance_version) {
    m_maintenance_version = maintenance_version;
    m_maintenance_version_isSet = true;
}

bool OAIInstance::is_maintenance_version_Set() const{
    return m_maintenance_version_isSet;
}

bool OAIInstance::is_maintenance_version_Valid() const{
    return m_maintenance_version_isValid;
}

qint32 OAIInstance::getMemorySizeGb() const {
    return m_memory_size_gb;
}
void OAIInstance::setMemorySizeGb(const qint32 &memory_size_gb) {
    m_memory_size_gb = memory_size_gb;
    m_memory_size_gb_isSet = true;
}

bool OAIInstance::is_memory_size_gb_Set() const{
    return m_memory_size_gb_isSet;
}

bool OAIInstance::is_memory_size_gb_Valid() const{
    return m_memory_size_gb_isValid;
}

QString OAIInstance::getName() const {
    return m_name;
}
void OAIInstance::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIInstance::is_name_Set() const{
    return m_name_isSet;
}

bool OAIInstance::is_name_Valid() const{
    return m_name_isValid;
}

QList<OAINodeInfo> OAIInstance::getNodes() const {
    return m_nodes;
}
void OAIInstance::setNodes(const QList<OAINodeInfo> &nodes) {
    m_nodes = nodes;
    m_nodes_isSet = true;
}

bool OAIInstance::is_nodes_Set() const{
    return m_nodes_isSet;
}

bool OAIInstance::is_nodes_Valid() const{
    return m_nodes_isValid;
}

OAIPersistenceConfig OAIInstance::getPersistenceConfig() const {
    return m_persistence_config;
}
void OAIInstance::setPersistenceConfig(const OAIPersistenceConfig &persistence_config) {
    m_persistence_config = persistence_config;
    m_persistence_config_isSet = true;
}

bool OAIInstance::is_persistence_config_Set() const{
    return m_persistence_config_isSet;
}

bool OAIInstance::is_persistence_config_Valid() const{
    return m_persistence_config_isValid;
}

QString OAIInstance::getPersistenceIamIdentity() const {
    return m_persistence_iam_identity;
}
void OAIInstance::setPersistenceIamIdentity(const QString &persistence_iam_identity) {
    m_persistence_iam_identity = persistence_iam_identity;
    m_persistence_iam_identity_isSet = true;
}

bool OAIInstance::is_persistence_iam_identity_Set() const{
    return m_persistence_iam_identity_isSet;
}

bool OAIInstance::is_persistence_iam_identity_Valid() const{
    return m_persistence_iam_identity_isValid;
}

qint32 OAIInstance::getPort() const {
    return m_port;
}
void OAIInstance::setPort(const qint32 &port) {
    m_port = port;
    m_port_isSet = true;
}

bool OAIInstance::is_port_Set() const{
    return m_port_isSet;
}

bool OAIInstance::is_port_Valid() const{
    return m_port_isValid;
}

QString OAIInstance::getReadEndpoint() const {
    return m_read_endpoint;
}
void OAIInstance::setReadEndpoint(const QString &read_endpoint) {
    m_read_endpoint = read_endpoint;
    m_read_endpoint_isSet = true;
}

bool OAIInstance::is_read_endpoint_Set() const{
    return m_read_endpoint_isSet;
}

bool OAIInstance::is_read_endpoint_Valid() const{
    return m_read_endpoint_isValid;
}

qint32 OAIInstance::getReadEndpointPort() const {
    return m_read_endpoint_port;
}
void OAIInstance::setReadEndpointPort(const qint32 &read_endpoint_port) {
    m_read_endpoint_port = read_endpoint_port;
    m_read_endpoint_port_isSet = true;
}

bool OAIInstance::is_read_endpoint_port_Set() const{
    return m_read_endpoint_port_isSet;
}

bool OAIInstance::is_read_endpoint_port_Valid() const{
    return m_read_endpoint_port_isValid;
}

QString OAIInstance::getReadReplicasMode() const {
    return m_read_replicas_mode;
}
void OAIInstance::setReadReplicasMode(const QString &read_replicas_mode) {
    m_read_replicas_mode = read_replicas_mode;
    m_read_replicas_mode_isSet = true;
}

bool OAIInstance::is_read_replicas_mode_Set() const{
    return m_read_replicas_mode_isSet;
}

bool OAIInstance::is_read_replicas_mode_Valid() const{
    return m_read_replicas_mode_isValid;
}

QMap<QString, QString> OAIInstance::getRedisConfigs() const {
    return m_redis_configs;
}
void OAIInstance::setRedisConfigs(const QMap<QString, QString> &redis_configs) {
    m_redis_configs = redis_configs;
    m_redis_configs_isSet = true;
}

bool OAIInstance::is_redis_configs_Set() const{
    return m_redis_configs_isSet;
}

bool OAIInstance::is_redis_configs_Valid() const{
    return m_redis_configs_isValid;
}

QString OAIInstance::getRedisVersion() const {
    return m_redis_version;
}
void OAIInstance::setRedisVersion(const QString &redis_version) {
    m_redis_version = redis_version;
    m_redis_version_isSet = true;
}

bool OAIInstance::is_redis_version_Set() const{
    return m_redis_version_isSet;
}

bool OAIInstance::is_redis_version_Valid() const{
    return m_redis_version_isValid;
}

qint32 OAIInstance::getReplicaCount() const {
    return m_replica_count;
}
void OAIInstance::setReplicaCount(const qint32 &replica_count) {
    m_replica_count = replica_count;
    m_replica_count_isSet = true;
}

bool OAIInstance::is_replica_count_Set() const{
    return m_replica_count_isSet;
}

bool OAIInstance::is_replica_count_Valid() const{
    return m_replica_count_isValid;
}

QString OAIInstance::getReservedIpRange() const {
    return m_reserved_ip_range;
}
void OAIInstance::setReservedIpRange(const QString &reserved_ip_range) {
    m_reserved_ip_range = reserved_ip_range;
    m_reserved_ip_range_isSet = true;
}

bool OAIInstance::is_reserved_ip_range_Set() const{
    return m_reserved_ip_range_isSet;
}

bool OAIInstance::is_reserved_ip_range_Valid() const{
    return m_reserved_ip_range_isValid;
}

bool OAIInstance::isSatisfiesPzi() const {
    return m_satisfies_pzi;
}
void OAIInstance::setSatisfiesPzi(const bool &satisfies_pzi) {
    m_satisfies_pzi = satisfies_pzi;
    m_satisfies_pzi_isSet = true;
}

bool OAIInstance::is_satisfies_pzi_Set() const{
    return m_satisfies_pzi_isSet;
}

bool OAIInstance::is_satisfies_pzi_Valid() const{
    return m_satisfies_pzi_isValid;
}

bool OAIInstance::isSatisfiesPzs() const {
    return m_satisfies_pzs;
}
void OAIInstance::setSatisfiesPzs(const bool &satisfies_pzs) {
    m_satisfies_pzs = satisfies_pzs;
    m_satisfies_pzs_isSet = true;
}

bool OAIInstance::is_satisfies_pzs_Set() const{
    return m_satisfies_pzs_isSet;
}

bool OAIInstance::is_satisfies_pzs_Valid() const{
    return m_satisfies_pzs_isValid;
}

QString OAIInstance::getSecondaryIpRange() const {
    return m_secondary_ip_range;
}
void OAIInstance::setSecondaryIpRange(const QString &secondary_ip_range) {
    m_secondary_ip_range = secondary_ip_range;
    m_secondary_ip_range_isSet = true;
}

bool OAIInstance::is_secondary_ip_range_Set() const{
    return m_secondary_ip_range_isSet;
}

bool OAIInstance::is_secondary_ip_range_Valid() const{
    return m_secondary_ip_range_isValid;
}

QList<OAITlsCertificate> OAIInstance::getServerCaCerts() const {
    return m_server_ca_certs;
}
void OAIInstance::setServerCaCerts(const QList<OAITlsCertificate> &server_ca_certs) {
    m_server_ca_certs = server_ca_certs;
    m_server_ca_certs_isSet = true;
}

bool OAIInstance::is_server_ca_certs_Set() const{
    return m_server_ca_certs_isSet;
}

bool OAIInstance::is_server_ca_certs_Valid() const{
    return m_server_ca_certs_isValid;
}

QString OAIInstance::getState() const {
    return m_state;
}
void OAIInstance::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIInstance::is_state_Set() const{
    return m_state_isSet;
}

bool OAIInstance::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIInstance::getStatusMessage() const {
    return m_status_message;
}
void OAIInstance::setStatusMessage(const QString &status_message) {
    m_status_message = status_message;
    m_status_message_isSet = true;
}

bool OAIInstance::is_status_message_Set() const{
    return m_status_message_isSet;
}

bool OAIInstance::is_status_message_Valid() const{
    return m_status_message_isValid;
}

QList<QString> OAIInstance::getSuspensionReasons() const {
    return m_suspension_reasons;
}
void OAIInstance::setSuspensionReasons(const QList<QString> &suspension_reasons) {
    m_suspension_reasons = suspension_reasons;
    m_suspension_reasons_isSet = true;
}

bool OAIInstance::is_suspension_reasons_Set() const{
    return m_suspension_reasons_isSet;
}

bool OAIInstance::is_suspension_reasons_Valid() const{
    return m_suspension_reasons_isValid;
}

QString OAIInstance::getTier() const {
    return m_tier;
}
void OAIInstance::setTier(const QString &tier) {
    m_tier = tier;
    m_tier_isSet = true;
}

bool OAIInstance::is_tier_Set() const{
    return m_tier_isSet;
}

bool OAIInstance::is_tier_Valid() const{
    return m_tier_isValid;
}

QString OAIInstance::getTransitEncryptionMode() const {
    return m_transit_encryption_mode;
}
void OAIInstance::setTransitEncryptionMode(const QString &transit_encryption_mode) {
    m_transit_encryption_mode = transit_encryption_mode;
    m_transit_encryption_mode_isSet = true;
}

bool OAIInstance::is_transit_encryption_mode_Set() const{
    return m_transit_encryption_mode_isSet;
}

bool OAIInstance::is_transit_encryption_mode_Valid() const{
    return m_transit_encryption_mode_isValid;
}

bool OAIInstance::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alternative_location_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auth_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_authorized_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_maintenance_versions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_connect_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_current_location_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_customer_managed_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_host_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_location_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maintenance_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_maintenance_schedule.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_maintenance_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nodes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_persistence_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_persistence_iam_identity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_endpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_endpoint_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_replicas_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_redis_configs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_redis_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_replica_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reserved_ip_range_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzi_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzs_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secondary_ip_range_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_server_ca_certs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_message_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suspension_reasons.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_tier_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transit_encryption_mode_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIInstance::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
