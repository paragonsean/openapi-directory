/*
 * GKE Hub API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.CommonFeatureSpec;
import org.openapitools.client.model.CommonFeatureState;
import org.openapitools.client.model.CommonFleetDefaultMemberConfigSpec;
import org.openapitools.client.model.FeatureResourceState;
import org.openapitools.client.model.MembershipFeatureSpec;
import org.openapitools.client.model.MembershipFeatureState;
import org.openapitools.client.model.ScopeFeatureState;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Feature represents the settings and status of any Hub Feature.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:31:02.202070-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Feature {
  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DELETE_TIME = "deleteTime";
  @SerializedName(SERIALIZED_NAME_DELETE_TIME)
  private String deleteTime;

  public static final String SERIALIZED_NAME_FLEET_DEFAULT_MEMBER_CONFIG = "fleetDefaultMemberConfig";
  @SerializedName(SERIALIZED_NAME_FLEET_DEFAULT_MEMBER_CONFIG)
  private CommonFleetDefaultMemberConfigSpec fleetDefaultMemberConfig;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MEMBERSHIP_SPECS = "membershipSpecs";
  @SerializedName(SERIALIZED_NAME_MEMBERSHIP_SPECS)
  private Map<String, MembershipFeatureSpec> membershipSpecs = new HashMap<>();

  public static final String SERIALIZED_NAME_MEMBERSHIP_STATES = "membershipStates";
  @SerializedName(SERIALIZED_NAME_MEMBERSHIP_STATES)
  private Map<String, MembershipFeatureState> membershipStates = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RESOURCE_STATE = "resourceState";
  @SerializedName(SERIALIZED_NAME_RESOURCE_STATE)
  private FeatureResourceState resourceState;

  public static final String SERIALIZED_NAME_SCOPE_SPECS = "scopeSpecs";
  @SerializedName(SERIALIZED_NAME_SCOPE_SPECS)
  private Map<String, Object> scopeSpecs = new HashMap<>();

  public static final String SERIALIZED_NAME_SCOPE_STATES = "scopeStates";
  @SerializedName(SERIALIZED_NAME_SCOPE_STATES)
  private Map<String, ScopeFeatureState> scopeStates = new HashMap<>();

  public static final String SERIALIZED_NAME_SPEC = "spec";
  @SerializedName(SERIALIZED_NAME_SPEC)
  private CommonFeatureSpec spec;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private CommonFeatureState state;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Feature() {
  }

  public Feature(
     String createTime, 
     String deleteTime, 
     Map<String, MembershipFeatureState> membershipStates, 
     String name, 
     Map<String, ScopeFeatureState> scopeStates, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.deleteTime = deleteTime;
    this.membershipStates = membershipStates;
    this.name = name;
    this.scopeStates = scopeStates;
    this.updateTime = updateTime;
  }

  /**
   * Output only. When the Feature resource was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. When the Feature resource was deleted.
   * @return deleteTime
   */
  @javax.annotation.Nullable
  public String getDeleteTime() {
    return deleteTime;
  }



  public Feature fleetDefaultMemberConfig(CommonFleetDefaultMemberConfigSpec fleetDefaultMemberConfig) {
    this.fleetDefaultMemberConfig = fleetDefaultMemberConfig;
    return this;
  }

  /**
   * Get fleetDefaultMemberConfig
   * @return fleetDefaultMemberConfig
   */
  @javax.annotation.Nullable
  public CommonFleetDefaultMemberConfigSpec getFleetDefaultMemberConfig() {
    return fleetDefaultMemberConfig;
  }

  public void setFleetDefaultMemberConfig(CommonFleetDefaultMemberConfigSpec fleetDefaultMemberConfig) {
    this.fleetDefaultMemberConfig = fleetDefaultMemberConfig;
  }


  public Feature labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Feature putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels for this Feature.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Feature membershipSpecs(Map<String, MembershipFeatureSpec> membershipSpecs) {
    this.membershipSpecs = membershipSpecs;
    return this;
  }

  public Feature putMembershipSpecsItem(String key, MembershipFeatureSpec membershipSpecsItem) {
    if (this.membershipSpecs == null) {
      this.membershipSpecs = new HashMap<>();
    }
    this.membershipSpecs.put(key, membershipSpecsItem);
    return this;
  }

  /**
   * Optional. Membership-specific configuration for this Feature. If this Feature does not support any per-Membership configuration, this field may be unused. The keys indicate which Membership the configuration is for, in the form: &#x60;projects/{p}/locations/{l}/memberships/{m}&#x60; Where {p} is the project, {l} is a valid location and {m} is a valid Membership in this project at that location. {p} WILL match the Feature&#39;s project. {p} will always be returned as the project number, but the project ID is also accepted during input. If the same Membership is specified in the map twice (using the project ID form, and the project number form), exactly ONE of the entries will be saved, with no guarantees as to which. For this reason, it is recommended the same format be used for all entries when mutating a Feature.
   * @return membershipSpecs
   */
  @javax.annotation.Nullable
  public Map<String, MembershipFeatureSpec> getMembershipSpecs() {
    return membershipSpecs;
  }

  public void setMembershipSpecs(Map<String, MembershipFeatureSpec> membershipSpecs) {
    this.membershipSpecs = membershipSpecs;
  }


  /**
   * Output only. Membership-specific Feature status. If this Feature does report any per-Membership status, this field may be unused. The keys indicate which Membership the state is for, in the form: &#x60;projects/{p}/locations/{l}/memberships/{m}&#x60; Where {p} is the project number, {l} is a valid location and {m} is a valid Membership in this project at that location. {p} MUST match the Feature&#39;s project number.
   * @return membershipStates
   */
  @javax.annotation.Nullable
  public Map<String, MembershipFeatureState> getMembershipStates() {
    return membershipStates;
  }



  /**
   * Output only. The full, unique name of this Feature resource in the format &#x60;projects/_*_/locations/_*_/features/_*&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public Feature resourceState(FeatureResourceState resourceState) {
    this.resourceState = resourceState;
    return this;
  }

  /**
   * Get resourceState
   * @return resourceState
   */
  @javax.annotation.Nullable
  public FeatureResourceState getResourceState() {
    return resourceState;
  }

  public void setResourceState(FeatureResourceState resourceState) {
    this.resourceState = resourceState;
  }


  public Feature scopeSpecs(Map<String, Object> scopeSpecs) {
    this.scopeSpecs = scopeSpecs;
    return this;
  }

  public Feature putScopeSpecsItem(String key, Object scopeSpecsItem) {
    if (this.scopeSpecs == null) {
      this.scopeSpecs = new HashMap<>();
    }
    this.scopeSpecs.put(key, scopeSpecsItem);
    return this;
  }

  /**
   * Optional. Scope-specific configuration for this Feature. If this Feature does not support any per-Scope configuration, this field may be unused. The keys indicate which Scope the configuration is for, in the form: &#x60;projects/{p}/locations/global/scopes/{s}&#x60; Where {p} is the project, {s} is a valid Scope in this project. {p} WILL match the Feature&#39;s project. {p} will always be returned as the project number, but the project ID is also accepted during input. If the same Scope is specified in the map twice (using the project ID form, and the project number form), exactly ONE of the entries will be saved, with no guarantees as to which. For this reason, it is recommended the same format be used for all entries when mutating a Feature.
   * @return scopeSpecs
   */
  @javax.annotation.Nullable
  public Map<String, Object> getScopeSpecs() {
    return scopeSpecs;
  }

  public void setScopeSpecs(Map<String, Object> scopeSpecs) {
    this.scopeSpecs = scopeSpecs;
  }


  /**
   * Output only. Scope-specific Feature status. If this Feature does report any per-Scope status, this field may be unused. The keys indicate which Scope the state is for, in the form: &#x60;projects/{p}/locations/global/scopes/{s}&#x60; Where {p} is the project, {s} is a valid Scope in this project. {p} WILL match the Feature&#39;s project.
   * @return scopeStates
   */
  @javax.annotation.Nullable
  public Map<String, ScopeFeatureState> getScopeStates() {
    return scopeStates;
  }



  public Feature spec(CommonFeatureSpec spec) {
    this.spec = spec;
    return this;
  }

  /**
   * Get spec
   * @return spec
   */
  @javax.annotation.Nullable
  public CommonFeatureSpec getSpec() {
    return spec;
  }

  public void setSpec(CommonFeatureSpec spec) {
    this.spec = spec;
  }


  public Feature state(CommonFeatureState state) {
    this.state = state;
    return this;
  }

  /**
   * Get state
   * @return state
   */
  @javax.annotation.Nullable
  public CommonFeatureState getState() {
    return state;
  }

  public void setState(CommonFeatureState state) {
    this.state = state;
  }


  /**
   * Output only. When the Feature resource was last updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Feature feature = (Feature) o;
    return Objects.equals(this.createTime, feature.createTime) &&
        Objects.equals(this.deleteTime, feature.deleteTime) &&
        Objects.equals(this.fleetDefaultMemberConfig, feature.fleetDefaultMemberConfig) &&
        Objects.equals(this.labels, feature.labels) &&
        Objects.equals(this.membershipSpecs, feature.membershipSpecs) &&
        Objects.equals(this.membershipStates, feature.membershipStates) &&
        Objects.equals(this.name, feature.name) &&
        Objects.equals(this.resourceState, feature.resourceState) &&
        Objects.equals(this.scopeSpecs, feature.scopeSpecs) &&
        Objects.equals(this.scopeStates, feature.scopeStates) &&
        Objects.equals(this.spec, feature.spec) &&
        Objects.equals(this.state, feature.state) &&
        Objects.equals(this.updateTime, feature.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createTime, deleteTime, fleetDefaultMemberConfig, labels, membershipSpecs, membershipStates, name, resourceState, scopeSpecs, scopeStates, spec, state, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Feature {\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    deleteTime: ").append(toIndentedString(deleteTime)).append("\n");
    sb.append("    fleetDefaultMemberConfig: ").append(toIndentedString(fleetDefaultMemberConfig)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    membershipSpecs: ").append(toIndentedString(membershipSpecs)).append("\n");
    sb.append("    membershipStates: ").append(toIndentedString(membershipStates)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    resourceState: ").append(toIndentedString(resourceState)).append("\n");
    sb.append("    scopeSpecs: ").append(toIndentedString(scopeSpecs)).append("\n");
    sb.append("    scopeStates: ").append(toIndentedString(scopeStates)).append("\n");
    sb.append("    spec: ").append(toIndentedString(spec)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createTime");
    openapiFields.add("deleteTime");
    openapiFields.add("fleetDefaultMemberConfig");
    openapiFields.add("labels");
    openapiFields.add("membershipSpecs");
    openapiFields.add("membershipStates");
    openapiFields.add("name");
    openapiFields.add("resourceState");
    openapiFields.add("scopeSpecs");
    openapiFields.add("scopeStates");
    openapiFields.add("spec");
    openapiFields.add("state");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Feature
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Feature.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Feature is not found in the empty JSON string", Feature.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Feature.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Feature` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("deleteTime") != null && !jsonObj.get("deleteTime").isJsonNull()) && !jsonObj.get("deleteTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deleteTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deleteTime").toString()));
      }
      // validate the optional field `fleetDefaultMemberConfig`
      if (jsonObj.get("fleetDefaultMemberConfig") != null && !jsonObj.get("fleetDefaultMemberConfig").isJsonNull()) {
        CommonFleetDefaultMemberConfigSpec.validateJsonElement(jsonObj.get("fleetDefaultMemberConfig"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `resourceState`
      if (jsonObj.get("resourceState") != null && !jsonObj.get("resourceState").isJsonNull()) {
        FeatureResourceState.validateJsonElement(jsonObj.get("resourceState"));
      }
      // validate the optional field `spec`
      if (jsonObj.get("spec") != null && !jsonObj.get("spec").isJsonNull()) {
        CommonFeatureSpec.validateJsonElement(jsonObj.get("spec"));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        CommonFeatureState.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Feature.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Feature' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Feature> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Feature.class));

       return (TypeAdapter<T>) new TypeAdapter<Feature>() {
           @Override
           public void write(JsonWriter out, Feature value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Feature read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Feature given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Feature
   * @throws IOException if the JSON string is invalid with respect to Feature
   */
  public static Feature fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Feature.class);
  }

  /**
   * Convert an instance of Feature to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

