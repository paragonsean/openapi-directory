/*
 * OS Config API
 * OS management tools that can be used for patch management, patch compliance, and configuration management on VM instances.
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Copies the artifact to the specified path on the instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:00.971702-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SoftwareRecipeStepCopyFile {
  public static final String SERIALIZED_NAME_ARTIFACT_ID = "artifactId";
  @SerializedName(SERIALIZED_NAME_ARTIFACT_ID)
  private String artifactId;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private String destination;

  public static final String SERIALIZED_NAME_OVERWRITE = "overwrite";
  @SerializedName(SERIALIZED_NAME_OVERWRITE)
  private Boolean overwrite;

  public static final String SERIALIZED_NAME_PERMISSIONS = "permissions";
  @SerializedName(SERIALIZED_NAME_PERMISSIONS)
  private String permissions;

  public SoftwareRecipeStepCopyFile() {
  }

  public SoftwareRecipeStepCopyFile artifactId(String artifactId) {
    this.artifactId = artifactId;
    return this;
  }

  /**
   * Required. The id of the relevant artifact in the recipe.
   * @return artifactId
   */
  @javax.annotation.Nullable
  public String getArtifactId() {
    return artifactId;
  }

  public void setArtifactId(String artifactId) {
    this.artifactId = artifactId;
  }


  public SoftwareRecipeStepCopyFile destination(String destination) {
    this.destination = destination;
    return this;
  }

  /**
   * Required. The absolute path on the instance to put the file.
   * @return destination
   */
  @javax.annotation.Nullable
  public String getDestination() {
    return destination;
  }

  public void setDestination(String destination) {
    this.destination = destination;
  }


  public SoftwareRecipeStepCopyFile overwrite(Boolean overwrite) {
    this.overwrite = overwrite;
    return this;
  }

  /**
   * Whether to allow this step to overwrite existing files. If this is false and the file already exists the file is not overwritten and the step is considered a success. Defaults to false.
   * @return overwrite
   */
  @javax.annotation.Nullable
  public Boolean getOverwrite() {
    return overwrite;
  }

  public void setOverwrite(Boolean overwrite) {
    this.overwrite = overwrite;
  }


  public SoftwareRecipeStepCopyFile permissions(String permissions) {
    this.permissions = permissions;
    return this;
  }

  /**
   * Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4
   * @return permissions
   */
  @javax.annotation.Nullable
  public String getPermissions() {
    return permissions;
  }

  public void setPermissions(String permissions) {
    this.permissions = permissions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SoftwareRecipeStepCopyFile softwareRecipeStepCopyFile = (SoftwareRecipeStepCopyFile) o;
    return Objects.equals(this.artifactId, softwareRecipeStepCopyFile.artifactId) &&
        Objects.equals(this.destination, softwareRecipeStepCopyFile.destination) &&
        Objects.equals(this.overwrite, softwareRecipeStepCopyFile.overwrite) &&
        Objects.equals(this.permissions, softwareRecipeStepCopyFile.permissions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(artifactId, destination, overwrite, permissions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SoftwareRecipeStepCopyFile {\n");
    sb.append("    artifactId: ").append(toIndentedString(artifactId)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    overwrite: ").append(toIndentedString(overwrite)).append("\n");
    sb.append("    permissions: ").append(toIndentedString(permissions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("artifactId");
    openapiFields.add("destination");
    openapiFields.add("overwrite");
    openapiFields.add("permissions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SoftwareRecipeStepCopyFile
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SoftwareRecipeStepCopyFile.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SoftwareRecipeStepCopyFile is not found in the empty JSON string", SoftwareRecipeStepCopyFile.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SoftwareRecipeStepCopyFile.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SoftwareRecipeStepCopyFile` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("artifactId") != null && !jsonObj.get("artifactId").isJsonNull()) && !jsonObj.get("artifactId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `artifactId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("artifactId").toString()));
      }
      if ((jsonObj.get("destination") != null && !jsonObj.get("destination").isJsonNull()) && !jsonObj.get("destination").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destination` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination").toString()));
      }
      if ((jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) && !jsonObj.get("permissions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `permissions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("permissions").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SoftwareRecipeStepCopyFile.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SoftwareRecipeStepCopyFile' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SoftwareRecipeStepCopyFile> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SoftwareRecipeStepCopyFile.class));

       return (TypeAdapter<T>) new TypeAdapter<SoftwareRecipeStepCopyFile>() {
           @Override
           public void write(JsonWriter out, SoftwareRecipeStepCopyFile value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SoftwareRecipeStepCopyFile read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SoftwareRecipeStepCopyFile given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SoftwareRecipeStepCopyFile
   * @throws IOException if the JSON string is invalid with respect to SoftwareRecipeStepCopyFile
   */
  public static SoftwareRecipeStepCopyFile fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SoftwareRecipeStepCopyFile.class);
  }

  /**
   * Convert an instance of SoftwareRecipeStepCopyFile to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

