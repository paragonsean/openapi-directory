/*
 * OS Config API
 * OS management tools that can be used for patch management, patch compliance, and configuration management on VM instances.
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.SoftwareRecipeArtifact;
import org.openapitools.client.model.SoftwareRecipeStep;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A software recipe is a set of instructions for installing and configuring a piece of software. It consists of a set of artifacts that are downloaded, and a set of steps that install, configure, and/or update the software. Recipes support installing and updating software from artifacts in the following formats: Zip archive, Tar archive, Windows MSI, Debian package, and RPM package. Additionally, recipes support executing a script (either defined in a file or directly in this api) in bash, sh, cmd, and powershell. Updating a software recipe If a recipe is assigned to an instance and there is a recipe with the same name but a lower version already installed and the assigned state of the recipe is &#x60;UPDATED&#x60;, then the recipe is updated to the new version. Script Working Directories Each script or execution step is run in its own temporary directory which is deleted after completing the step.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:00.971702-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SoftwareRecipe {
  public static final String SERIALIZED_NAME_ARTIFACTS = "artifacts";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS)
  private List<SoftwareRecipeArtifact> artifacts = new ArrayList<>();

  /**
   * Default is INSTALLED. The desired state the agent should maintain for this recipe. INSTALLED: The software recipe is installed on the instance but won&#39;t be updated to new versions. UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version, if a higher version of the recipe is assigned to this instance. REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected.
   */
  @JsonAdapter(DesiredStateEnum.Adapter.class)
  public enum DesiredStateEnum {
    DESIRED_STATE_UNSPECIFIED("DESIRED_STATE_UNSPECIFIED"),
    
    INSTALLED("INSTALLED"),
    
    UPDATED("UPDATED"),
    
    REMOVED("REMOVED");

    private String value;

    DesiredStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DesiredStateEnum fromValue(String value) {
      for (DesiredStateEnum b : DesiredStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DesiredStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DesiredStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DesiredStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DesiredStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DesiredStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DESIRED_STATE = "desiredState";
  @SerializedName(SERIALIZED_NAME_DESIRED_STATE)
  private DesiredStateEnum desiredState;

  public static final String SERIALIZED_NAME_INSTALL_STEPS = "installSteps";
  @SerializedName(SERIALIZED_NAME_INSTALL_STEPS)
  private List<SoftwareRecipeStep> installSteps = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_UPDATE_STEPS = "updateSteps";
  @SerializedName(SERIALIZED_NAME_UPDATE_STEPS)
  private List<SoftwareRecipeStep> updateSteps = new ArrayList<>();

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public SoftwareRecipe() {
  }

  public SoftwareRecipe artifacts(List<SoftwareRecipeArtifact> artifacts) {
    this.artifacts = artifacts;
    return this;
  }

  public SoftwareRecipe addArtifactsItem(SoftwareRecipeArtifact artifactsItem) {
    if (this.artifacts == null) {
      this.artifacts = new ArrayList<>();
    }
    this.artifacts.add(artifactsItem);
    return this;
  }

  /**
   * Resources available to be used in the steps in the recipe.
   * @return artifacts
   */
  @javax.annotation.Nullable
  public List<SoftwareRecipeArtifact> getArtifacts() {
    return artifacts;
  }

  public void setArtifacts(List<SoftwareRecipeArtifact> artifacts) {
    this.artifacts = artifacts;
  }


  public SoftwareRecipe desiredState(DesiredStateEnum desiredState) {
    this.desiredState = desiredState;
    return this;
  }

  /**
   * Default is INSTALLED. The desired state the agent should maintain for this recipe. INSTALLED: The software recipe is installed on the instance but won&#39;t be updated to new versions. UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version, if a higher version of the recipe is assigned to this instance. REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected.
   * @return desiredState
   */
  @javax.annotation.Nullable
  public DesiredStateEnum getDesiredState() {
    return desiredState;
  }

  public void setDesiredState(DesiredStateEnum desiredState) {
    this.desiredState = desiredState;
  }


  public SoftwareRecipe installSteps(List<SoftwareRecipeStep> installSteps) {
    this.installSteps = installSteps;
    return this;
  }

  public SoftwareRecipe addInstallStepsItem(SoftwareRecipeStep installStepsItem) {
    if (this.installSteps == null) {
      this.installSteps = new ArrayList<>();
    }
    this.installSteps.add(installStepsItem);
    return this;
  }

  /**
   * Actions to be taken for installing this recipe. On failure it stops executing steps and does not attempt another installation. Any steps taken (including partially completed steps) are not rolled back.
   * @return installSteps
   */
  @javax.annotation.Nullable
  public List<SoftwareRecipeStep> getInstallSteps() {
    return installSteps;
  }

  public void setInstallSteps(List<SoftwareRecipeStep> installSteps) {
    this.installSteps = installSteps;
  }


  public SoftwareRecipe name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. Unique identifier for the recipe. Only one recipe with a given name is installed on an instance. Names are also used to identify resources which helps to determine whether guest policies have conflicts. This means that requests to create multiple recipes with the same name and version are rejected since they could potentially have conflicting assignments.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public SoftwareRecipe updateSteps(List<SoftwareRecipeStep> updateSteps) {
    this.updateSteps = updateSteps;
    return this;
  }

  public SoftwareRecipe addUpdateStepsItem(SoftwareRecipeStep updateStepsItem) {
    if (this.updateSteps == null) {
      this.updateSteps = new ArrayList<>();
    }
    this.updateSteps.add(updateStepsItem);
    return this;
  }

  /**
   * Actions to be taken for updating this recipe. On failure it stops executing steps and does not attempt another update for this recipe. Any steps taken (including partially completed steps) are not rolled back.
   * @return updateSteps
   */
  @javax.annotation.Nullable
  public List<SoftwareRecipeStep> getUpdateSteps() {
    return updateSteps;
  }

  public void setUpdateSteps(List<SoftwareRecipeStep> updateSteps) {
    this.updateSteps = updateSteps;
  }


  public SoftwareRecipe version(String version) {
    this.version = version;
    return this;
  }

  /**
   * The version of this software recipe. Version can be up to 4 period separated numbers (e.g. 12.34.56.78).
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SoftwareRecipe softwareRecipe = (SoftwareRecipe) o;
    return Objects.equals(this.artifacts, softwareRecipe.artifacts) &&
        Objects.equals(this.desiredState, softwareRecipe.desiredState) &&
        Objects.equals(this.installSteps, softwareRecipe.installSteps) &&
        Objects.equals(this.name, softwareRecipe.name) &&
        Objects.equals(this.updateSteps, softwareRecipe.updateSteps) &&
        Objects.equals(this.version, softwareRecipe.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(artifacts, desiredState, installSteps, name, updateSteps, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SoftwareRecipe {\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    desiredState: ").append(toIndentedString(desiredState)).append("\n");
    sb.append("    installSteps: ").append(toIndentedString(installSteps)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    updateSteps: ").append(toIndentedString(updateSteps)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("artifacts");
    openapiFields.add("desiredState");
    openapiFields.add("installSteps");
    openapiFields.add("name");
    openapiFields.add("updateSteps");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SoftwareRecipe
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SoftwareRecipe.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SoftwareRecipe is not found in the empty JSON string", SoftwareRecipe.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SoftwareRecipe.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SoftwareRecipe` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("artifacts") != null && !jsonObj.get("artifacts").isJsonNull()) {
        JsonArray jsonArrayartifacts = jsonObj.getAsJsonArray("artifacts");
        if (jsonArrayartifacts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("artifacts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `artifacts` to be an array in the JSON string but got `%s`", jsonObj.get("artifacts").toString()));
          }

          // validate the optional field `artifacts` (array)
          for (int i = 0; i < jsonArrayartifacts.size(); i++) {
            SoftwareRecipeArtifact.validateJsonElement(jsonArrayartifacts.get(i));
          };
        }
      }
      if ((jsonObj.get("desiredState") != null && !jsonObj.get("desiredState").isJsonNull()) && !jsonObj.get("desiredState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `desiredState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("desiredState").toString()));
      }
      // validate the optional field `desiredState`
      if (jsonObj.get("desiredState") != null && !jsonObj.get("desiredState").isJsonNull()) {
        DesiredStateEnum.validateJsonElement(jsonObj.get("desiredState"));
      }
      if (jsonObj.get("installSteps") != null && !jsonObj.get("installSteps").isJsonNull()) {
        JsonArray jsonArrayinstallSteps = jsonObj.getAsJsonArray("installSteps");
        if (jsonArrayinstallSteps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("installSteps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `installSteps` to be an array in the JSON string but got `%s`", jsonObj.get("installSteps").toString()));
          }

          // validate the optional field `installSteps` (array)
          for (int i = 0; i < jsonArrayinstallSteps.size(); i++) {
            SoftwareRecipeStep.validateJsonElement(jsonArrayinstallSteps.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("updateSteps") != null && !jsonObj.get("updateSteps").isJsonNull()) {
        JsonArray jsonArrayupdateSteps = jsonObj.getAsJsonArray("updateSteps");
        if (jsonArrayupdateSteps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("updateSteps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `updateSteps` to be an array in the JSON string but got `%s`", jsonObj.get("updateSteps").toString()));
          }

          // validate the optional field `updateSteps` (array)
          for (int i = 0; i < jsonArrayupdateSteps.size(); i++) {
            SoftwareRecipeStep.validateJsonElement(jsonArrayupdateSteps.get(i));
          };
        }
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SoftwareRecipe.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SoftwareRecipe' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SoftwareRecipe> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SoftwareRecipe.class));

       return (TypeAdapter<T>) new TypeAdapter<SoftwareRecipe>() {
           @Override
           public void write(JsonWriter out, SoftwareRecipe value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SoftwareRecipe read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SoftwareRecipe given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SoftwareRecipe
   * @throws IOException if the JSON string is invalid with respect to SoftwareRecipe
   */
  public static SoftwareRecipe fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SoftwareRecipe.class);
  }

  /**
   * Convert an instance of SoftwareRecipe to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

