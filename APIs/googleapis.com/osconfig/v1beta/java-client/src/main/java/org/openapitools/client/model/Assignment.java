/*
 * OS Config API
 * OS management tools that can be used for patch management, patch compliance, and configuration management on VM instances.
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AssignmentGroupLabel;
import org.openapitools.client.model.AssignmentOsType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An assignment represents the group or groups of VM instances that the policy applies to. If an assignment is empty, it applies to all VM instances. Otherwise, the targeted VM instances must meet all the criteria specified. So if both labels and zones are specified, the policy applies to VM instances with those labels and in those zones.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:00.971702-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Assignment {
  public static final String SERIALIZED_NAME_GROUP_LABELS = "groupLabels";
  @SerializedName(SERIALIZED_NAME_GROUP_LABELS)
  private List<AssignmentGroupLabel> groupLabels = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTANCE_NAME_PREFIXES = "instanceNamePrefixes";
  @SerializedName(SERIALIZED_NAME_INSTANCE_NAME_PREFIXES)
  private List<String> instanceNamePrefixes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTANCES = "instances";
  @SerializedName(SERIALIZED_NAME_INSTANCES)
  private List<String> instances = new ArrayList<>();

  public static final String SERIALIZED_NAME_OS_TYPES = "osTypes";
  @SerializedName(SERIALIZED_NAME_OS_TYPES)
  private List<AssignmentOsType> osTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_ZONES = "zones";
  @SerializedName(SERIALIZED_NAME_ZONES)
  private List<String> zones = new ArrayList<>();

  public Assignment() {
  }

  public Assignment groupLabels(List<AssignmentGroupLabel> groupLabels) {
    this.groupLabels = groupLabels;
    return this;
  }

  public Assignment addGroupLabelsItem(AssignmentGroupLabel groupLabelsItem) {
    if (this.groupLabels == null) {
      this.groupLabels = new ArrayList<>();
    }
    this.groupLabels.add(groupLabelsItem);
    return this;
  }

  /**
   * Targets instances matching at least one of these label sets. This allows an assignment to target disparate groups, for example \&quot;env&#x3D;prod or env&#x3D;staging\&quot;.
   * @return groupLabels
   */
  @javax.annotation.Nullable
  public List<AssignmentGroupLabel> getGroupLabels() {
    return groupLabels;
  }

  public void setGroupLabels(List<AssignmentGroupLabel> groupLabels) {
    this.groupLabels = groupLabels;
  }


  public Assignment instanceNamePrefixes(List<String> instanceNamePrefixes) {
    this.instanceNamePrefixes = instanceNamePrefixes;
    return this;
  }

  public Assignment addInstanceNamePrefixesItem(String instanceNamePrefixesItem) {
    if (this.instanceNamePrefixes == null) {
      this.instanceNamePrefixes = new ArrayList<>();
    }
    this.instanceNamePrefixes.add(instanceNamePrefixesItem);
    return this;
  }

  /**
   * Targets VM instances whose name starts with one of these prefixes. Like labels, this is another way to group VM instances when targeting configs, for example prefix&#x3D;\&quot;prod-\&quot;. Only supported for project-level policies.
   * @return instanceNamePrefixes
   */
  @javax.annotation.Nullable
  public List<String> getInstanceNamePrefixes() {
    return instanceNamePrefixes;
  }

  public void setInstanceNamePrefixes(List<String> instanceNamePrefixes) {
    this.instanceNamePrefixes = instanceNamePrefixes;
  }


  public Assignment instances(List<String> instances) {
    this.instances = instances;
    return this;
  }

  public Assignment addInstancesItem(String instancesItem) {
    if (this.instances == null) {
      this.instances = new ArrayList<>();
    }
    this.instances.add(instancesItem);
    return this;
  }

  /**
   * Targets any of the instances specified. Instances are specified by their URI in the form &#x60;zones/[ZONE]/instances/[INSTANCE_NAME]&#x60;. Instance targeting is uncommon and is supported to facilitate the management of changes by the instance or to target specific VM instances for development and testing. Only supported for project-level policies and must reference instances within this project.
   * @return instances
   */
  @javax.annotation.Nullable
  public List<String> getInstances() {
    return instances;
  }

  public void setInstances(List<String> instances) {
    this.instances = instances;
  }


  public Assignment osTypes(List<AssignmentOsType> osTypes) {
    this.osTypes = osTypes;
    return this;
  }

  public Assignment addOsTypesItem(AssignmentOsType osTypesItem) {
    if (this.osTypes == null) {
      this.osTypes = new ArrayList<>();
    }
    this.osTypes.add(osTypesItem);
    return this;
  }

  /**
   * Targets VM instances matching at least one of the following OS types. VM instances must match all supplied criteria for a given OsType to be included.
   * @return osTypes
   */
  @javax.annotation.Nullable
  public List<AssignmentOsType> getOsTypes() {
    return osTypes;
  }

  public void setOsTypes(List<AssignmentOsType> osTypes) {
    this.osTypes = osTypes;
  }


  public Assignment zones(List<String> zones) {
    this.zones = zones;
    return this;
  }

  public Assignment addZonesItem(String zonesItem) {
    if (this.zones == null) {
      this.zones = new ArrayList<>();
    }
    this.zones.add(zonesItem);
    return this;
  }

  /**
   * Targets instances in any of these zones. Leave empty to target instances in any zone. Zonal targeting is uncommon and is supported to facilitate the management of changes by zone.
   * @return zones
   */
  @javax.annotation.Nullable
  public List<String> getZones() {
    return zones;
  }

  public void setZones(List<String> zones) {
    this.zones = zones;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Assignment assignment = (Assignment) o;
    return Objects.equals(this.groupLabels, assignment.groupLabels) &&
        Objects.equals(this.instanceNamePrefixes, assignment.instanceNamePrefixes) &&
        Objects.equals(this.instances, assignment.instances) &&
        Objects.equals(this.osTypes, assignment.osTypes) &&
        Objects.equals(this.zones, assignment.zones);
  }

  @Override
  public int hashCode() {
    return Objects.hash(groupLabels, instanceNamePrefixes, instances, osTypes, zones);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Assignment {\n");
    sb.append("    groupLabels: ").append(toIndentedString(groupLabels)).append("\n");
    sb.append("    instanceNamePrefixes: ").append(toIndentedString(instanceNamePrefixes)).append("\n");
    sb.append("    instances: ").append(toIndentedString(instances)).append("\n");
    sb.append("    osTypes: ").append(toIndentedString(osTypes)).append("\n");
    sb.append("    zones: ").append(toIndentedString(zones)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("groupLabels");
    openapiFields.add("instanceNamePrefixes");
    openapiFields.add("instances");
    openapiFields.add("osTypes");
    openapiFields.add("zones");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Assignment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Assignment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Assignment is not found in the empty JSON string", Assignment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Assignment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Assignment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("groupLabels") != null && !jsonObj.get("groupLabels").isJsonNull()) {
        JsonArray jsonArraygroupLabels = jsonObj.getAsJsonArray("groupLabels");
        if (jsonArraygroupLabels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("groupLabels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `groupLabels` to be an array in the JSON string but got `%s`", jsonObj.get("groupLabels").toString()));
          }

          // validate the optional field `groupLabels` (array)
          for (int i = 0; i < jsonArraygroupLabels.size(); i++) {
            AssignmentGroupLabel.validateJsonElement(jsonArraygroupLabels.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instanceNamePrefixes") != null && !jsonObj.get("instanceNamePrefixes").isJsonNull() && !jsonObj.get("instanceNamePrefixes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceNamePrefixes` to be an array in the JSON string but got `%s`", jsonObj.get("instanceNamePrefixes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instances") != null && !jsonObj.get("instances").isJsonNull() && !jsonObj.get("instances").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instances` to be an array in the JSON string but got `%s`", jsonObj.get("instances").toString()));
      }
      if (jsonObj.get("osTypes") != null && !jsonObj.get("osTypes").isJsonNull()) {
        JsonArray jsonArrayosTypes = jsonObj.getAsJsonArray("osTypes");
        if (jsonArrayosTypes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("osTypes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `osTypes` to be an array in the JSON string but got `%s`", jsonObj.get("osTypes").toString()));
          }

          // validate the optional field `osTypes` (array)
          for (int i = 0; i < jsonArrayosTypes.size(); i++) {
            AssignmentOsType.validateJsonElement(jsonArrayosTypes.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("zones") != null && !jsonObj.get("zones").isJsonNull() && !jsonObj.get("zones").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `zones` to be an array in the JSON string but got `%s`", jsonObj.get("zones").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Assignment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Assignment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Assignment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Assignment.class));

       return (TypeAdapter<T>) new TypeAdapter<Assignment>() {
           @Override
           public void write(JsonWriter out, Assignment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Assignment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Assignment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Assignment
   * @throws IOException if the JSON string is invalid with respect to Assignment
   */
  public static Assignment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Assignment.class);
  }

  /**
   * Convert an instance of Assignment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

