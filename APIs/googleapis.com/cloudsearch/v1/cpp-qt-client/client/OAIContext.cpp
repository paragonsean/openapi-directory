/**
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIContext.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIContext::OAIContext(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIContext::OAIContext() {
    this->initializeModel();
}

OAIContext::~OAIContext() {}

void OAIContext::initializeModel() {

    m_app_isSet = false;
    m_app_isValid = false;

    m_day_of_week_isSet = false;
    m_day_of_week_isValid = false;

    m_end_date_sec_isSet = false;
    m_end_date_sec_isValid = false;

    m_end_day_offset_sec_isSet = false;
    m_end_day_offset_sec_isValid = false;

    m_locale_isSet = false;
    m_locale_isValid = false;

    m_location_isSet = false;
    m_location_isValid = false;

    m_query_isSet = false;
    m_query_isValid = false;

    m_start_date_sec_isSet = false;
    m_start_date_sec_isValid = false;

    m_start_day_offset_sec_isSet = false;
    m_start_day_offset_sec_isValid = false;

    m_surface_isSet = false;
    m_surface_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIContext::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIContext::fromJsonObject(QJsonObject json) {

    m_app_isValid = ::OpenAPI::fromJsonValue(m_app, json[QString("app")]);
    m_app_isSet = !json[QString("app")].isNull() && m_app_isValid;

    m_day_of_week_isValid = ::OpenAPI::fromJsonValue(m_day_of_week, json[QString("dayOfWeek")]);
    m_day_of_week_isSet = !json[QString("dayOfWeek")].isNull() && m_day_of_week_isValid;

    m_end_date_sec_isValid = ::OpenAPI::fromJsonValue(m_end_date_sec, json[QString("endDateSec")]);
    m_end_date_sec_isSet = !json[QString("endDateSec")].isNull() && m_end_date_sec_isValid;

    m_end_day_offset_sec_isValid = ::OpenAPI::fromJsonValue(m_end_day_offset_sec, json[QString("endDayOffsetSec")]);
    m_end_day_offset_sec_isSet = !json[QString("endDayOffsetSec")].isNull() && m_end_day_offset_sec_isValid;

    m_locale_isValid = ::OpenAPI::fromJsonValue(m_locale, json[QString("locale")]);
    m_locale_isSet = !json[QString("locale")].isNull() && m_locale_isValid;

    m_location_isValid = ::OpenAPI::fromJsonValue(m_location, json[QString("location")]);
    m_location_isSet = !json[QString("location")].isNull() && m_location_isValid;

    m_query_isValid = ::OpenAPI::fromJsonValue(m_query, json[QString("query")]);
    m_query_isSet = !json[QString("query")].isNull() && m_query_isValid;

    m_start_date_sec_isValid = ::OpenAPI::fromJsonValue(m_start_date_sec, json[QString("startDateSec")]);
    m_start_date_sec_isSet = !json[QString("startDateSec")].isNull() && m_start_date_sec_isValid;

    m_start_day_offset_sec_isValid = ::OpenAPI::fromJsonValue(m_start_day_offset_sec, json[QString("startDayOffsetSec")]);
    m_start_day_offset_sec_isSet = !json[QString("startDayOffsetSec")].isNull() && m_start_day_offset_sec_isValid;

    m_surface_isValid = ::OpenAPI::fromJsonValue(m_surface, json[QString("surface")]);
    m_surface_isSet = !json[QString("surface")].isNull() && m_surface_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIContext::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIContext::asJsonObject() const {
    QJsonObject obj;
    if (m_app.size() > 0) {
        obj.insert(QString("app"), ::OpenAPI::toJsonValue(m_app));
    }
    if (m_day_of_week.size() > 0) {
        obj.insert(QString("dayOfWeek"), ::OpenAPI::toJsonValue(m_day_of_week));
    }
    if (m_end_date_sec_isSet) {
        obj.insert(QString("endDateSec"), ::OpenAPI::toJsonValue(m_end_date_sec));
    }
    if (m_end_day_offset_sec_isSet) {
        obj.insert(QString("endDayOffsetSec"), ::OpenAPI::toJsonValue(m_end_day_offset_sec));
    }
    if (m_locale.size() > 0) {
        obj.insert(QString("locale"), ::OpenAPI::toJsonValue(m_locale));
    }
    if (m_location.size() > 0) {
        obj.insert(QString("location"), ::OpenAPI::toJsonValue(m_location));
    }
    if (m_query.size() > 0) {
        obj.insert(QString("query"), ::OpenAPI::toJsonValue(m_query));
    }
    if (m_start_date_sec_isSet) {
        obj.insert(QString("startDateSec"), ::OpenAPI::toJsonValue(m_start_date_sec));
    }
    if (m_start_day_offset_sec_isSet) {
        obj.insert(QString("startDayOffsetSec"), ::OpenAPI::toJsonValue(m_start_day_offset_sec));
    }
    if (m_surface.size() > 0) {
        obj.insert(QString("surface"), ::OpenAPI::toJsonValue(m_surface));
    }
    if (m_type.size() > 0) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QList<QString> OAIContext::getApp() const {
    return m_app;
}
void OAIContext::setApp(const QList<QString> &app) {
    m_app = app;
    m_app_isSet = true;
}

bool OAIContext::is_app_Set() const{
    return m_app_isSet;
}

bool OAIContext::is_app_Valid() const{
    return m_app_isValid;
}

QList<qint32> OAIContext::getDayOfWeek() const {
    return m_day_of_week;
}
void OAIContext::setDayOfWeek(const QList<qint32> &day_of_week) {
    m_day_of_week = day_of_week;
    m_day_of_week_isSet = true;
}

bool OAIContext::is_day_of_week_Set() const{
    return m_day_of_week_isSet;
}

bool OAIContext::is_day_of_week_Valid() const{
    return m_day_of_week_isValid;
}

QString OAIContext::getEndDateSec() const {
    return m_end_date_sec;
}
void OAIContext::setEndDateSec(const QString &end_date_sec) {
    m_end_date_sec = end_date_sec;
    m_end_date_sec_isSet = true;
}

bool OAIContext::is_end_date_sec_Set() const{
    return m_end_date_sec_isSet;
}

bool OAIContext::is_end_date_sec_Valid() const{
    return m_end_date_sec_isValid;
}

QString OAIContext::getEndDayOffsetSec() const {
    return m_end_day_offset_sec;
}
void OAIContext::setEndDayOffsetSec(const QString &end_day_offset_sec) {
    m_end_day_offset_sec = end_day_offset_sec;
    m_end_day_offset_sec_isSet = true;
}

bool OAIContext::is_end_day_offset_sec_Set() const{
    return m_end_day_offset_sec_isSet;
}

bool OAIContext::is_end_day_offset_sec_Valid() const{
    return m_end_day_offset_sec_isValid;
}

QList<QString> OAIContext::getLocale() const {
    return m_locale;
}
void OAIContext::setLocale(const QList<QString> &locale) {
    m_locale = locale;
    m_locale_isSet = true;
}

bool OAIContext::is_locale_Set() const{
    return m_locale_isSet;
}

bool OAIContext::is_locale_Valid() const{
    return m_locale_isValid;
}

QList<QString> OAIContext::getLocation() const {
    return m_location;
}
void OAIContext::setLocation(const QList<QString> &location) {
    m_location = location;
    m_location_isSet = true;
}

bool OAIContext::is_location_Set() const{
    return m_location_isSet;
}

bool OAIContext::is_location_Valid() const{
    return m_location_isValid;
}

QList<QString> OAIContext::getQuery() const {
    return m_query;
}
void OAIContext::setQuery(const QList<QString> &query) {
    m_query = query;
    m_query_isSet = true;
}

bool OAIContext::is_query_Set() const{
    return m_query_isSet;
}

bool OAIContext::is_query_Valid() const{
    return m_query_isValid;
}

QString OAIContext::getStartDateSec() const {
    return m_start_date_sec;
}
void OAIContext::setStartDateSec(const QString &start_date_sec) {
    m_start_date_sec = start_date_sec;
    m_start_date_sec_isSet = true;
}

bool OAIContext::is_start_date_sec_Set() const{
    return m_start_date_sec_isSet;
}

bool OAIContext::is_start_date_sec_Valid() const{
    return m_start_date_sec_isValid;
}

QString OAIContext::getStartDayOffsetSec() const {
    return m_start_day_offset_sec;
}
void OAIContext::setStartDayOffsetSec(const QString &start_day_offset_sec) {
    m_start_day_offset_sec = start_day_offset_sec;
    m_start_day_offset_sec_isSet = true;
}

bool OAIContext::is_start_day_offset_sec_Set() const{
    return m_start_day_offset_sec_isSet;
}

bool OAIContext::is_start_day_offset_sec_Valid() const{
    return m_start_day_offset_sec_isValid;
}

QList<QString> OAIContext::getSurface() const {
    return m_surface;
}
void OAIContext::setSurface(const QList<QString> &surface) {
    m_surface = surface;
    m_surface_isSet = true;
}

bool OAIContext::is_surface_Set() const{
    return m_surface_isSet;
}

bool OAIContext::is_surface_Valid() const{
    return m_surface_isValid;
}

QList<QString> OAIContext::getType() const {
    return m_type;
}
void OAIContext::setType(const QList<QString> &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIContext::is_type_Set() const{
    return m_type_isSet;
}

bool OAIContext::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIContext::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_app.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_day_of_week.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_date_sec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_day_offset_sec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_locale.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_location.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_query.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_date_sec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_day_offset_sec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_surface.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIContext::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
