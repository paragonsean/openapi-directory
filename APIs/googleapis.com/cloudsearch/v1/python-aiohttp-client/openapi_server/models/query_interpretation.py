# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class QueryInterpretation(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, interpretation_type: str=None, interpreted_query: str=None, reason: str=None):
        """QueryInterpretation - a model defined in OpenAPI

        :param interpretation_type: The interpretation_type of this QueryInterpretation.
        :param interpreted_query: The interpreted_query of this QueryInterpretation.
        :param reason: The reason of this QueryInterpretation.
        """
        self.openapi_types = {
            'interpretation_type': str,
            'interpreted_query': str,
            'reason': str
        }

        self.attribute_map = {
            'interpretation_type': 'interpretationType',
            'interpreted_query': 'interpretedQuery',
            'reason': 'reason'
        }

        self._interpretation_type = interpretation_type
        self._interpreted_query = interpreted_query
        self._reason = reason

    @classmethod
    def from_dict(cls, dikt: dict) -> 'QueryInterpretation':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The QueryInterpretation of this QueryInterpretation.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def interpretation_type(self):
        """Gets the interpretation_type of this QueryInterpretation.


        :return: The interpretation_type of this QueryInterpretation.
        :rtype: str
        """
        return self._interpretation_type

    @interpretation_type.setter
    def interpretation_type(self, interpretation_type):
        """Sets the interpretation_type of this QueryInterpretation.


        :param interpretation_type: The interpretation_type of this QueryInterpretation.
        :type interpretation_type: str
        """
        allowed_values = ["NONE", "BLEND", "REPLACE"]  # noqa: E501
        if interpretation_type not in allowed_values:
            raise ValueError(
                "Invalid value for `interpretation_type` ({0}), must be one of {1}"
                .format(interpretation_type, allowed_values)
            )

        self._interpretation_type = interpretation_type

    @property
    def interpreted_query(self):
        """Gets the interpreted_query of this QueryInterpretation.

        The interpretation of the query used in search. For example, queries with natural language intent like \"email from john\" will be interpreted as \"from:john source:mail\". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY.

        :return: The interpreted_query of this QueryInterpretation.
        :rtype: str
        """
        return self._interpreted_query

    @interpreted_query.setter
    def interpreted_query(self, interpreted_query):
        """Sets the interpreted_query of this QueryInterpretation.

        The interpretation of the query used in search. For example, queries with natural language intent like \"email from john\" will be interpreted as \"from:john source:mail\". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY.

        :param interpreted_query: The interpreted_query of this QueryInterpretation.
        :type interpreted_query: str
        """

        self._interpreted_query = interpreted_query

    @property
    def reason(self):
        """Gets the reason of this QueryInterpretation.

        The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.

        :return: The reason of this QueryInterpretation.
        :rtype: str
        """
        return self._reason

    @reason.setter
    def reason(self, reason):
        """Sets the reason of this QueryInterpretation.

        The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.

        :param reason: The reason of this QueryInterpretation.
        :type reason: str
        """
        allowed_values = ["UNSPECIFIED", "QUERY_HAS_NATURAL_LANGUAGE_INTENT", "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY"]  # noqa: E501
        if reason not in allowed_values:
            raise ValueError(
                "Invalid value for `reason` ({0}), must be one of {1}"
                .format(reason, allowed_values)
            )

        self._reason = reason
