# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Context(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, app: List[str]=None, day_of_week: List[int]=None, end_date_sec: str=None, end_day_offset_sec: str=None, locale: List[str]=None, location: List[str]=None, query: List[str]=None, start_date_sec: str=None, start_day_offset_sec: str=None, surface: List[str]=None, type: List[str]=None):
        """Context - a model defined in OpenAPI

        :param app: The app of this Context.
        :param day_of_week: The day_of_week of this Context.
        :param end_date_sec: The end_date_sec of this Context.
        :param end_day_offset_sec: The end_day_offset_sec of this Context.
        :param locale: The locale of this Context.
        :param location: The location of this Context.
        :param query: The query of this Context.
        :param start_date_sec: The start_date_sec of this Context.
        :param start_day_offset_sec: The start_day_offset_sec of this Context.
        :param surface: The surface of this Context.
        :param type: The type of this Context.
        """
        self.openapi_types = {
            'app': List[str],
            'day_of_week': List[int],
            'end_date_sec': str,
            'end_day_offset_sec': str,
            'locale': List[str],
            'location': List[str],
            'query': List[str],
            'start_date_sec': str,
            'start_day_offset_sec': str,
            'surface': List[str],
            'type': List[str]
        }

        self.attribute_map = {
            'app': 'app',
            'day_of_week': 'dayOfWeek',
            'end_date_sec': 'endDateSec',
            'end_day_offset_sec': 'endDayOffsetSec',
            'locale': 'locale',
            'location': 'location',
            'query': 'query',
            'start_date_sec': 'startDateSec',
            'start_day_offset_sec': 'startDayOffsetSec',
            'surface': 'surface',
            'type': 'type'
        }

        self._app = app
        self._day_of_week = day_of_week
        self._end_date_sec = end_date_sec
        self._end_day_offset_sec = end_day_offset_sec
        self._locale = locale
        self._location = location
        self._query = query
        self._start_date_sec = start_date_sec
        self._start_day_offset_sec = start_day_offset_sec
        self._surface = surface
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Context':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Context of this Context.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def app(self):
        """Gets the app of this Context.

        [Optional] App where the card should be shown. If missing, the card will be shown in TOPAZ.

        :return: The app of this Context.
        :rtype: List[str]
        """
        return self._app

    @app.setter
    def app(self, app):
        """Sets the app of this Context.

        [Optional] App where the card should be shown. If missing, the card will be shown in TOPAZ.

        :param app: The app of this Context.
        :type app: List[str]
        """
        allowed_values = ["UNKNOWN_APP", "TOPAZ", "MOMA"]  # noqa: E501
        if not set(app).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `app` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(app) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._app = app

    @property
    def day_of_week(self):
        """Gets the day_of_week of this Context.

        [Optional] Day of week when the card should be shown, where 0 is Monday.

        :return: The day_of_week of this Context.
        :rtype: List[int]
        """
        return self._day_of_week

    @day_of_week.setter
    def day_of_week(self, day_of_week):
        """Sets the day_of_week of this Context.

        [Optional] Day of week when the card should be shown, where 0 is Monday.

        :param day_of_week: The day_of_week of this Context.
        :type day_of_week: List[int]
        """

        self._day_of_week = day_of_week

    @property
    def end_date_sec(self):
        """Gets the end_date_sec of this Context.

        [Optional] Date (in seconds since epoch) when the card should stop being shown. If missing, end_date_sec will be set to Jan 1st, 2100.

        :return: The end_date_sec of this Context.
        :rtype: str
        """
        return self._end_date_sec

    @end_date_sec.setter
    def end_date_sec(self, end_date_sec):
        """Sets the end_date_sec of this Context.

        [Optional] Date (in seconds since epoch) when the card should stop being shown. If missing, end_date_sec will be set to Jan 1st, 2100.

        :param end_date_sec: The end_date_sec of this Context.
        :type end_date_sec: str
        """

        self._end_date_sec = end_date_sec

    @property
    def end_day_offset_sec(self):
        """Gets the end_day_offset_sec of this Context.

        [Optional] End time in seconds, within a day, when the card should stop being shown if it's within [start_date_sec, end_date_sec]. If missing, this is set to 86400 (24 hours x 3600 sec/hour), i.e., midnight next day.

        :return: The end_day_offset_sec of this Context.
        :rtype: str
        """
        return self._end_day_offset_sec

    @end_day_offset_sec.setter
    def end_day_offset_sec(self, end_day_offset_sec):
        """Sets the end_day_offset_sec of this Context.

        [Optional] End time in seconds, within a day, when the card should stop being shown if it's within [start_date_sec, end_date_sec]. If missing, this is set to 86400 (24 hours x 3600 sec/hour), i.e., midnight next day.

        :param end_day_offset_sec: The end_day_offset_sec of this Context.
        :type end_day_offset_sec: str
        """

        self._end_day_offset_sec = end_day_offset_sec

    @property
    def locale(self):
        """Gets the locale of this Context.

        [Optional] The locales for which the card should be triggered (e.g., en_US and en_CA). If missing, the card is going to show to clients regardless of their locale.

        :return: The locale of this Context.
        :rtype: List[str]
        """
        return self._locale

    @locale.setter
    def locale(self, locale):
        """Sets the locale of this Context.

        [Optional] The locales for which the card should be triggered (e.g., en_US and en_CA). If missing, the card is going to show to clients regardless of their locale.

        :param locale: The locale of this Context.
        :type locale: List[str]
        """

        self._locale = locale

    @property
    def location(self):
        """Gets the location of this Context.

        [Optional] Text-free locations where the card should be shown. This is expected to match the user's location in focus. If no location is specified, the card will be shown for any location.

        :return: The location of this Context.
        :rtype: List[str]
        """
        return self._location

    @location.setter
    def location(self, location):
        """Sets the location of this Context.

        [Optional] Text-free locations where the card should be shown. This is expected to match the user's location in focus. If no location is specified, the card will be shown for any location.

        :param location: The location of this Context.
        :type location: List[str]
        """

        self._location = location

    @property
    def query(self):
        """Gets the query of this Context.

        [Required only for Answer and RHS cards - will be ignored for Homepage] cards. It's the exact case-insensitive queries that will trigger the Answer or RHS card.

        :return: The query of this Context.
        :rtype: List[str]
        """
        return self._query

    @query.setter
    def query(self, query):
        """Sets the query of this Context.

        [Required only for Answer and RHS cards - will be ignored for Homepage] cards. It's the exact case-insensitive queries that will trigger the Answer or RHS card.

        :param query: The query of this Context.
        :type query: List[str]
        """

        self._query = query

    @property
    def start_date_sec(self):
        """Gets the start_date_sec of this Context.

        [Optional] Date (in seconds since epoch) when the card should start being shown. If missing, start_date_sec will be Jan 1st, 1970 UTC.

        :return: The start_date_sec of this Context.
        :rtype: str
        """
        return self._start_date_sec

    @start_date_sec.setter
    def start_date_sec(self, start_date_sec):
        """Sets the start_date_sec of this Context.

        [Optional] Date (in seconds since epoch) when the card should start being shown. If missing, start_date_sec will be Jan 1st, 1970 UTC.

        :param start_date_sec: The start_date_sec of this Context.
        :type start_date_sec: str
        """

        self._start_date_sec = start_date_sec

    @property
    def start_day_offset_sec(self):
        """Gets the start_day_offset_sec of this Context.

        [Optional] Start time in seconds, within a day, when the card should be shown if it's within [start_date_sec, end_date_sec]. If 0, the card will be shown from 12:00am on.

        :return: The start_day_offset_sec of this Context.
        :rtype: str
        """
        return self._start_day_offset_sec

    @start_day_offset_sec.setter
    def start_day_offset_sec(self, start_day_offset_sec):
        """Sets the start_day_offset_sec of this Context.

        [Optional] Start time in seconds, within a day, when the card should be shown if it's within [start_date_sec, end_date_sec]. If 0, the card will be shown from 12:00am on.

        :param start_day_offset_sec: The start_day_offset_sec of this Context.
        :type start_day_offset_sec: str
        """

        self._start_day_offset_sec = start_day_offset_sec

    @property
    def surface(self):
        """Gets the surface of this Context.

        [Optional] Surface where the card should be shown in. If missing, the card will be shown in any surface.

        :return: The surface of this Context.
        :rtype: List[str]
        """
        return self._surface

    @surface.setter
    def surface(self, surface):
        """Sets the surface of this Context.

        [Optional] Surface where the card should be shown in. If missing, the card will be shown in any surface.

        :param surface: The surface of this Context.
        :type surface: List[str]
        """
        allowed_values = ["UNKNOWN_SURFACE", "DESKTOP", "ANDROID", "IOS", "MOBILE", "ANY"]  # noqa: E501
        if not set(surface).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `surface` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(surface) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._surface = surface

    @property
    def type(self):
        """Gets the type of this Context.

        [Required] Type of the card (homepage, Answer or RHS).

        :return: The type of this Context.
        :rtype: List[str]
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Context.

        [Required] Type of the card (homepage, Answer or RHS).

        :param type: The type of this Context.
        :type type: List[str]
        """
        allowed_values = ["UNKNOWN_CARD_TYPE", "HOMEPAGE_CARD", "ANSWER_CARD", "RHS_CARD"]  # noqa: E501
        if not set(type).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `type` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(type) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._type = type
