/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Principal;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Access control list information for the item. For more information see [Map ACLs](https://developers.google.com/cloud-search/docs/guides/acls).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ItemAcl {
  /**
   * Sets the type of access rules to apply when an item inherits its ACL from a parent. This should always be set in tandem with the inheritAclFrom field. Also, when the inheritAclFrom field is set, this field should be set to a valid AclInheritanceType.
   */
  @JsonAdapter(AclInheritanceTypeEnum.Adapter.class)
  public enum AclInheritanceTypeEnum {
    NOT_APPLICABLE("NOT_APPLICABLE"),
    
    CHILD_OVERRIDE("CHILD_OVERRIDE"),
    
    PARENT_OVERRIDE("PARENT_OVERRIDE"),
    
    BOTH_PERMIT("BOTH_PERMIT");

    private String value;

    AclInheritanceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AclInheritanceTypeEnum fromValue(String value) {
      for (AclInheritanceTypeEnum b : AclInheritanceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AclInheritanceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AclInheritanceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AclInheritanceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AclInheritanceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AclInheritanceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACL_INHERITANCE_TYPE = "aclInheritanceType";
  @SerializedName(SERIALIZED_NAME_ACL_INHERITANCE_TYPE)
  private AclInheritanceTypeEnum aclInheritanceType;

  public static final String SERIALIZED_NAME_DENIED_READERS = "deniedReaders";
  @SerializedName(SERIALIZED_NAME_DENIED_READERS)
  private List<Principal> deniedReaders = new ArrayList<>();

  public static final String SERIALIZED_NAME_INHERIT_ACL_FROM = "inheritAclFrom";
  @SerializedName(SERIALIZED_NAME_INHERIT_ACL_FROM)
  private String inheritAclFrom;

  public static final String SERIALIZED_NAME_OWNERS = "owners";
  @SerializedName(SERIALIZED_NAME_OWNERS)
  private List<Principal> owners = new ArrayList<>();

  public static final String SERIALIZED_NAME_READERS = "readers";
  @SerializedName(SERIALIZED_NAME_READERS)
  private List<Principal> readers = new ArrayList<>();

  public ItemAcl() {
  }

  public ItemAcl aclInheritanceType(AclInheritanceTypeEnum aclInheritanceType) {
    this.aclInheritanceType = aclInheritanceType;
    return this;
  }

  /**
   * Sets the type of access rules to apply when an item inherits its ACL from a parent. This should always be set in tandem with the inheritAclFrom field. Also, when the inheritAclFrom field is set, this field should be set to a valid AclInheritanceType.
   * @return aclInheritanceType
   */
  @javax.annotation.Nullable
  public AclInheritanceTypeEnum getAclInheritanceType() {
    return aclInheritanceType;
  }

  public void setAclInheritanceType(AclInheritanceTypeEnum aclInheritanceType) {
    this.aclInheritanceType = aclInheritanceType;
  }


  public ItemAcl deniedReaders(List<Principal> deniedReaders) {
    this.deniedReaders = deniedReaders;
    return this;
  }

  public ItemAcl addDeniedReadersItem(Principal deniedReadersItem) {
    if (this.deniedReaders == null) {
      this.deniedReaders = new ArrayList<>();
    }
    this.deniedReaders.add(deniedReadersItem);
    return this;
  }

  /**
   * List of principals who are explicitly denied access to the item in search results. While principals are denied access by default, use denied readers to handle exceptions and override the list allowed readers. The maximum number of elements is 100.
   * @return deniedReaders
   */
  @javax.annotation.Nullable
  public List<Principal> getDeniedReaders() {
    return deniedReaders;
  }

  public void setDeniedReaders(List<Principal> deniedReaders) {
    this.deniedReaders = deniedReaders;
  }


  public ItemAcl inheritAclFrom(String inheritAclFrom) {
    this.inheritAclFrom = inheritAclFrom;
    return this;
  }

  /**
   * The name of the item to inherit the Access Permission List (ACL) from. Note: ACL inheritance *only* provides access permissions to child items and does not define structural relationships, nor does it provide convenient ways to delete large groups of items. Deleting an ACL parent from the index only alters the access permissions of child items that reference the parent in the inheritAclFrom field. The item is still in the index, but may not visible in search results. By contrast, deletion of a container item also deletes all items that reference the container via the containerName field. The maximum length for this field is 1536 characters.
   * @return inheritAclFrom
   */
  @javax.annotation.Nullable
  public String getInheritAclFrom() {
    return inheritAclFrom;
  }

  public void setInheritAclFrom(String inheritAclFrom) {
    this.inheritAclFrom = inheritAclFrom;
  }


  public ItemAcl owners(List<Principal> owners) {
    this.owners = owners;
    return this;
  }

  public ItemAcl addOwnersItem(Principal ownersItem) {
    if (this.owners == null) {
      this.owners = new ArrayList<>();
    }
    this.owners.add(ownersItem);
    return this;
  }

  /**
   * Optional. List of owners for the item. This field has no bearing on document access permissions. It does, however, offer a slight ranking boosts items where the querying user is an owner. The maximum number of elements is 5.
   * @return owners
   */
  @javax.annotation.Nullable
  public List<Principal> getOwners() {
    return owners;
  }

  public void setOwners(List<Principal> owners) {
    this.owners = owners;
  }


  public ItemAcl readers(List<Principal> readers) {
    this.readers = readers;
    return this;
  }

  public ItemAcl addReadersItem(Principal readersItem) {
    if (this.readers == null) {
      this.readers = new ArrayList<>();
    }
    this.readers.add(readersItem);
    return this;
  }

  /**
   * List of principals who are allowed to see the item in search results. Optional if inheriting permissions from another item or if the item is not intended to be visible, such as virtual containers. The maximum number of elements is 1000.
   * @return readers
   */
  @javax.annotation.Nullable
  public List<Principal> getReaders() {
    return readers;
  }

  public void setReaders(List<Principal> readers) {
    this.readers = readers;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ItemAcl itemAcl = (ItemAcl) o;
    return Objects.equals(this.aclInheritanceType, itemAcl.aclInheritanceType) &&
        Objects.equals(this.deniedReaders, itemAcl.deniedReaders) &&
        Objects.equals(this.inheritAclFrom, itemAcl.inheritAclFrom) &&
        Objects.equals(this.owners, itemAcl.owners) &&
        Objects.equals(this.readers, itemAcl.readers);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aclInheritanceType, deniedReaders, inheritAclFrom, owners, readers);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ItemAcl {\n");
    sb.append("    aclInheritanceType: ").append(toIndentedString(aclInheritanceType)).append("\n");
    sb.append("    deniedReaders: ").append(toIndentedString(deniedReaders)).append("\n");
    sb.append("    inheritAclFrom: ").append(toIndentedString(inheritAclFrom)).append("\n");
    sb.append("    owners: ").append(toIndentedString(owners)).append("\n");
    sb.append("    readers: ").append(toIndentedString(readers)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("aclInheritanceType");
    openapiFields.add("deniedReaders");
    openapiFields.add("inheritAclFrom");
    openapiFields.add("owners");
    openapiFields.add("readers");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ItemAcl
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ItemAcl.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ItemAcl is not found in the empty JSON string", ItemAcl.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ItemAcl.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ItemAcl` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("aclInheritanceType") != null && !jsonObj.get("aclInheritanceType").isJsonNull()) && !jsonObj.get("aclInheritanceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aclInheritanceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aclInheritanceType").toString()));
      }
      // validate the optional field `aclInheritanceType`
      if (jsonObj.get("aclInheritanceType") != null && !jsonObj.get("aclInheritanceType").isJsonNull()) {
        AclInheritanceTypeEnum.validateJsonElement(jsonObj.get("aclInheritanceType"));
      }
      if (jsonObj.get("deniedReaders") != null && !jsonObj.get("deniedReaders").isJsonNull()) {
        JsonArray jsonArraydeniedReaders = jsonObj.getAsJsonArray("deniedReaders");
        if (jsonArraydeniedReaders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("deniedReaders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `deniedReaders` to be an array in the JSON string but got `%s`", jsonObj.get("deniedReaders").toString()));
          }

          // validate the optional field `deniedReaders` (array)
          for (int i = 0; i < jsonArraydeniedReaders.size(); i++) {
            Principal.validateJsonElement(jsonArraydeniedReaders.get(i));
          };
        }
      }
      if ((jsonObj.get("inheritAclFrom") != null && !jsonObj.get("inheritAclFrom").isJsonNull()) && !jsonObj.get("inheritAclFrom").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inheritAclFrom` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inheritAclFrom").toString()));
      }
      if (jsonObj.get("owners") != null && !jsonObj.get("owners").isJsonNull()) {
        JsonArray jsonArrayowners = jsonObj.getAsJsonArray("owners");
        if (jsonArrayowners != null) {
          // ensure the json data is an array
          if (!jsonObj.get("owners").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `owners` to be an array in the JSON string but got `%s`", jsonObj.get("owners").toString()));
          }

          // validate the optional field `owners` (array)
          for (int i = 0; i < jsonArrayowners.size(); i++) {
            Principal.validateJsonElement(jsonArrayowners.get(i));
          };
        }
      }
      if (jsonObj.get("readers") != null && !jsonObj.get("readers").isJsonNull()) {
        JsonArray jsonArrayreaders = jsonObj.getAsJsonArray("readers");
        if (jsonArrayreaders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("readers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `readers` to be an array in the JSON string but got `%s`", jsonObj.get("readers").toString()));
          }

          // validate the optional field `readers` (array)
          for (int i = 0; i < jsonArrayreaders.size(); i++) {
            Principal.validateJsonElement(jsonArrayreaders.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ItemAcl.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ItemAcl' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ItemAcl> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ItemAcl.class));

       return (TypeAdapter<T>) new TypeAdapter<ItemAcl>() {
           @Override
           public void write(JsonWriter out, ItemAcl value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ItemAcl read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ItemAcl given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ItemAcl
   * @throws IOException if the JSON string is invalid with respect to ItemAcl
   */
  public static ItemAcl fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ItemAcl.class);
  }

  /**
   * Convert an instance of ItemAcl to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

