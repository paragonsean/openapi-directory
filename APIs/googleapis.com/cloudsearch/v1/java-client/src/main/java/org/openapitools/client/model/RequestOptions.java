/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DebugOptions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Shared request options for all RPC methods.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RequestOptions {
  public static final String SERIALIZED_NAME_DEBUG_OPTIONS = "debugOptions";
  @SerializedName(SERIALIZED_NAME_DEBUG_OPTIONS)
  private DebugOptions debugOptions;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "languageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private String languageCode;

  public static final String SERIALIZED_NAME_SEARCH_APPLICATION_ID = "searchApplicationId";
  @SerializedName(SERIALIZED_NAME_SEARCH_APPLICATION_ID)
  private String searchApplicationId;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public RequestOptions() {
  }

  public RequestOptions debugOptions(DebugOptions debugOptions) {
    this.debugOptions = debugOptions;
    return this;
  }

  /**
   * Get debugOptions
   * @return debugOptions
   */
  @javax.annotation.Nullable
  public DebugOptions getDebugOptions() {
    return debugOptions;
  }

  public void setDebugOptions(DebugOptions debugOptions) {
    this.debugOptions = debugOptions;
  }


  public RequestOptions languageCode(String languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * The BCP-47 language code, such as \&quot;en-US\&quot; or \&quot;sr-Latn\&quot;. For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user&#39;s language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. The Suggest API uses this field as a hint to make better third-party autocomplete predictions.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public String getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(String languageCode) {
    this.languageCode = languageCode;
  }


  public RequestOptions searchApplicationId(String searchApplicationId) {
    this.searchApplicationId = searchApplicationId;
    return this;
  }

  /**
   * The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922).
   * @return searchApplicationId
   */
  @javax.annotation.Nullable
  public String getSearchApplicationId() {
    return searchApplicationId;
  }

  public void setSearchApplicationId(String searchApplicationId) {
    this.searchApplicationId = searchApplicationId;
  }


  public RequestOptions timeZone(String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * Current user&#39;s time zone id, such as \&quot;America/Los_Angeles\&quot; or \&quot;Australia/Sydney\&quot;. These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RequestOptions requestOptions = (RequestOptions) o;
    return Objects.equals(this.debugOptions, requestOptions.debugOptions) &&
        Objects.equals(this.languageCode, requestOptions.languageCode) &&
        Objects.equals(this.searchApplicationId, requestOptions.searchApplicationId) &&
        Objects.equals(this.timeZone, requestOptions.timeZone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(debugOptions, languageCode, searchApplicationId, timeZone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RequestOptions {\n");
    sb.append("    debugOptions: ").append(toIndentedString(debugOptions)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    searchApplicationId: ").append(toIndentedString(searchApplicationId)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("debugOptions");
    openapiFields.add("languageCode");
    openapiFields.add("searchApplicationId");
    openapiFields.add("timeZone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RequestOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RequestOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RequestOptions is not found in the empty JSON string", RequestOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RequestOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RequestOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `debugOptions`
      if (jsonObj.get("debugOptions") != null && !jsonObj.get("debugOptions").isJsonNull()) {
        DebugOptions.validateJsonElement(jsonObj.get("debugOptions"));
      }
      if ((jsonObj.get("languageCode") != null && !jsonObj.get("languageCode").isJsonNull()) && !jsonObj.get("languageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languageCode").toString()));
      }
      if ((jsonObj.get("searchApplicationId") != null && !jsonObj.get("searchApplicationId").isJsonNull()) && !jsonObj.get("searchApplicationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchApplicationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchApplicationId").toString()));
      }
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RequestOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RequestOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RequestOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RequestOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<RequestOptions>() {
           @Override
           public void write(JsonWriter out, RequestOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RequestOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RequestOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RequestOptions
   * @throws IOException if the JSON string is invalid with respect to RequestOptions
   */
  public static RequestOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RequestOptions.class);
  }

  /**
   * Convert an instance of RequestOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

