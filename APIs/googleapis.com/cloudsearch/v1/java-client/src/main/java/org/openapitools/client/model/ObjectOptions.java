/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.FreshnessOptions;
import org.openapitools.client.model.ObjectDisplayOptions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The options for an object.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ObjectOptions {
  public static final String SERIALIZED_NAME_DISPLAY_OPTIONS = "displayOptions";
  @SerializedName(SERIALIZED_NAME_DISPLAY_OPTIONS)
  private ObjectDisplayOptions displayOptions;

  public static final String SERIALIZED_NAME_FRESHNESS_OPTIONS = "freshnessOptions";
  @SerializedName(SERIALIZED_NAME_FRESHNESS_OPTIONS)
  private FreshnessOptions freshnessOptions;

  public static final String SERIALIZED_NAME_SUGGESTION_FILTERING_OPERATORS = "suggestionFilteringOperators";
  @SerializedName(SERIALIZED_NAME_SUGGESTION_FILTERING_OPERATORS)
  private List<String> suggestionFilteringOperators = new ArrayList<>();

  public ObjectOptions() {
  }

  public ObjectOptions displayOptions(ObjectDisplayOptions displayOptions) {
    this.displayOptions = displayOptions;
    return this;
  }

  /**
   * Get displayOptions
   * @return displayOptions
   */
  @javax.annotation.Nullable
  public ObjectDisplayOptions getDisplayOptions() {
    return displayOptions;
  }

  public void setDisplayOptions(ObjectDisplayOptions displayOptions) {
    this.displayOptions = displayOptions;
  }


  public ObjectOptions freshnessOptions(FreshnessOptions freshnessOptions) {
    this.freshnessOptions = freshnessOptions;
    return this;
  }

  /**
   * Get freshnessOptions
   * @return freshnessOptions
   */
  @javax.annotation.Nullable
  public FreshnessOptions getFreshnessOptions() {
    return freshnessOptions;
  }

  public void setFreshnessOptions(FreshnessOptions freshnessOptions) {
    this.freshnessOptions = freshnessOptions;
  }


  public ObjectOptions suggestionFilteringOperators(List<String> suggestionFilteringOperators) {
    this.suggestionFilteringOperators = suggestionFilteringOperators;
    return this;
  }

  public ObjectOptions addSuggestionFilteringOperatorsItem(String suggestionFilteringOperatorsItem) {
    if (this.suggestionFilteringOperators == null) {
      this.suggestionFilteringOperators = new ArrayList<>();
    }
    this.suggestionFilteringOperators.add(suggestionFilteringOperatorsItem);
    return this;
  }

  /**
   * Operators that can be used to filter suggestions. For Suggest API, only operators mentioned here will be honored in the FilterOptions. Only TEXT and ENUM operators are supported. NOTE: \&quot;objecttype\&quot;, \&quot;type\&quot; and \&quot;mimetype\&quot; are already supported. This property is to configure schema specific operators. Even though this is an array, only one operator can be specified. This is an array for future extensibility. Operators mapping to multiple properties within the same object are not supported. If the operator spans across different object types, this option has to be set once for each object definition.
   * @return suggestionFilteringOperators
   */
  @javax.annotation.Nullable
  public List<String> getSuggestionFilteringOperators() {
    return suggestionFilteringOperators;
  }

  public void setSuggestionFilteringOperators(List<String> suggestionFilteringOperators) {
    this.suggestionFilteringOperators = suggestionFilteringOperators;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjectOptions objectOptions = (ObjectOptions) o;
    return Objects.equals(this.displayOptions, objectOptions.displayOptions) &&
        Objects.equals(this.freshnessOptions, objectOptions.freshnessOptions) &&
        Objects.equals(this.suggestionFilteringOperators, objectOptions.suggestionFilteringOperators);
  }

  @Override
  public int hashCode() {
    return Objects.hash(displayOptions, freshnessOptions, suggestionFilteringOperators);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjectOptions {\n");
    sb.append("    displayOptions: ").append(toIndentedString(displayOptions)).append("\n");
    sb.append("    freshnessOptions: ").append(toIndentedString(freshnessOptions)).append("\n");
    sb.append("    suggestionFilteringOperators: ").append(toIndentedString(suggestionFilteringOperators)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("displayOptions");
    openapiFields.add("freshnessOptions");
    openapiFields.add("suggestionFilteringOperators");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ObjectOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ObjectOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ObjectOptions is not found in the empty JSON string", ObjectOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ObjectOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ObjectOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `displayOptions`
      if (jsonObj.get("displayOptions") != null && !jsonObj.get("displayOptions").isJsonNull()) {
        ObjectDisplayOptions.validateJsonElement(jsonObj.get("displayOptions"));
      }
      // validate the optional field `freshnessOptions`
      if (jsonObj.get("freshnessOptions") != null && !jsonObj.get("freshnessOptions").isJsonNull()) {
        FreshnessOptions.validateJsonElement(jsonObj.get("freshnessOptions"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("suggestionFilteringOperators") != null && !jsonObj.get("suggestionFilteringOperators").isJsonNull() && !jsonObj.get("suggestionFilteringOperators").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `suggestionFilteringOperators` to be an array in the JSON string but got `%s`", jsonObj.get("suggestionFilteringOperators").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ObjectOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ObjectOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ObjectOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ObjectOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<ObjectOptions>() {
           @Override
           public void write(JsonWriter out, ObjectOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ObjectOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ObjectOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ObjectOptions
   * @throws IOException if the JSON string is invalid with respect to ObjectOptions
   */
  public static ObjectOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ObjectOptions.class);
  }

  /**
   * Convert an instance of ObjectOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

