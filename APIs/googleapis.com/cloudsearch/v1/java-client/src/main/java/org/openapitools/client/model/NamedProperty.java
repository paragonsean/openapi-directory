/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DateValues;
import org.openapitools.client.model.DoubleValues;
import org.openapitools.client.model.EnumValues;
import org.openapitools.client.model.HtmlValues;
import org.openapitools.client.model.IntegerValues;
import org.openapitools.client.model.ObjectValues;
import org.openapitools.client.model.TextValues;
import org.openapitools.client.model.TimestampValues;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A typed name-value pair for structured data. The type of the value should be the same as the registered type for the &#x60;name&#x60; property in the object definition of &#x60;objectType&#x60;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamedProperty {
  public static final String SERIALIZED_NAME_BOOLEAN_VALUE = "booleanValue";
  @SerializedName(SERIALIZED_NAME_BOOLEAN_VALUE)
  private Boolean booleanValue;

  public static final String SERIALIZED_NAME_DATE_VALUES = "dateValues";
  @SerializedName(SERIALIZED_NAME_DATE_VALUES)
  private DateValues dateValues;

  public static final String SERIALIZED_NAME_DOUBLE_VALUES = "doubleValues";
  @SerializedName(SERIALIZED_NAME_DOUBLE_VALUES)
  private DoubleValues doubleValues;

  public static final String SERIALIZED_NAME_ENUM_VALUES = "enumValues";
  @SerializedName(SERIALIZED_NAME_ENUM_VALUES)
  private EnumValues enumValues;

  public static final String SERIALIZED_NAME_HTML_VALUES = "htmlValues";
  @SerializedName(SERIALIZED_NAME_HTML_VALUES)
  private HtmlValues htmlValues;

  public static final String SERIALIZED_NAME_INTEGER_VALUES = "integerValues";
  @SerializedName(SERIALIZED_NAME_INTEGER_VALUES)
  private IntegerValues integerValues;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OBJECT_VALUES = "objectValues";
  @SerializedName(SERIALIZED_NAME_OBJECT_VALUES)
  private ObjectValues objectValues;

  public static final String SERIALIZED_NAME_TEXT_VALUES = "textValues";
  @SerializedName(SERIALIZED_NAME_TEXT_VALUES)
  private TextValues textValues;

  public static final String SERIALIZED_NAME_TIMESTAMP_VALUES = "timestampValues";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_VALUES)
  private TimestampValues timestampValues;

  public NamedProperty() {
  }

  public NamedProperty booleanValue(Boolean booleanValue) {
    this.booleanValue = booleanValue;
    return this;
  }

  /**
   * Get booleanValue
   * @return booleanValue
   */
  @javax.annotation.Nullable
  public Boolean getBooleanValue() {
    return booleanValue;
  }

  public void setBooleanValue(Boolean booleanValue) {
    this.booleanValue = booleanValue;
  }


  public NamedProperty dateValues(DateValues dateValues) {
    this.dateValues = dateValues;
    return this;
  }

  /**
   * Get dateValues
   * @return dateValues
   */
  @javax.annotation.Nullable
  public DateValues getDateValues() {
    return dateValues;
  }

  public void setDateValues(DateValues dateValues) {
    this.dateValues = dateValues;
  }


  public NamedProperty doubleValues(DoubleValues doubleValues) {
    this.doubleValues = doubleValues;
    return this;
  }

  /**
   * Get doubleValues
   * @return doubleValues
   */
  @javax.annotation.Nullable
  public DoubleValues getDoubleValues() {
    return doubleValues;
  }

  public void setDoubleValues(DoubleValues doubleValues) {
    this.doubleValues = doubleValues;
  }


  public NamedProperty enumValues(EnumValues enumValues) {
    this.enumValues = enumValues;
    return this;
  }

  /**
   * Get enumValues
   * @return enumValues
   */
  @javax.annotation.Nullable
  public EnumValues getEnumValues() {
    return enumValues;
  }

  public void setEnumValues(EnumValues enumValues) {
    this.enumValues = enumValues;
  }


  public NamedProperty htmlValues(HtmlValues htmlValues) {
    this.htmlValues = htmlValues;
    return this;
  }

  /**
   * Get htmlValues
   * @return htmlValues
   */
  @javax.annotation.Nullable
  public HtmlValues getHtmlValues() {
    return htmlValues;
  }

  public void setHtmlValues(HtmlValues htmlValues) {
    this.htmlValues = htmlValues;
  }


  public NamedProperty integerValues(IntegerValues integerValues) {
    this.integerValues = integerValues;
    return this;
  }

  /**
   * Get integerValues
   * @return integerValues
   */
  @javax.annotation.Nullable
  public IntegerValues getIntegerValues() {
    return integerValues;
  }

  public void setIntegerValues(IntegerValues integerValues) {
    this.integerValues = integerValues;
  }


  public NamedProperty name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the property. This name should correspond to the name of the property that was registered for object definition in the schema. The maximum allowable length for this property is 256 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NamedProperty objectValues(ObjectValues objectValues) {
    this.objectValues = objectValues;
    return this;
  }

  /**
   * Get objectValues
   * @return objectValues
   */
  @javax.annotation.Nullable
  public ObjectValues getObjectValues() {
    return objectValues;
  }

  public void setObjectValues(ObjectValues objectValues) {
    this.objectValues = objectValues;
  }


  public NamedProperty textValues(TextValues textValues) {
    this.textValues = textValues;
    return this;
  }

  /**
   * Get textValues
   * @return textValues
   */
  @javax.annotation.Nullable
  public TextValues getTextValues() {
    return textValues;
  }

  public void setTextValues(TextValues textValues) {
    this.textValues = textValues;
  }


  public NamedProperty timestampValues(TimestampValues timestampValues) {
    this.timestampValues = timestampValues;
    return this;
  }

  /**
   * Get timestampValues
   * @return timestampValues
   */
  @javax.annotation.Nullable
  public TimestampValues getTimestampValues() {
    return timestampValues;
  }

  public void setTimestampValues(TimestampValues timestampValues) {
    this.timestampValues = timestampValues;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamedProperty namedProperty = (NamedProperty) o;
    return Objects.equals(this.booleanValue, namedProperty.booleanValue) &&
        Objects.equals(this.dateValues, namedProperty.dateValues) &&
        Objects.equals(this.doubleValues, namedProperty.doubleValues) &&
        Objects.equals(this.enumValues, namedProperty.enumValues) &&
        Objects.equals(this.htmlValues, namedProperty.htmlValues) &&
        Objects.equals(this.integerValues, namedProperty.integerValues) &&
        Objects.equals(this.name, namedProperty.name) &&
        Objects.equals(this.objectValues, namedProperty.objectValues) &&
        Objects.equals(this.textValues, namedProperty.textValues) &&
        Objects.equals(this.timestampValues, namedProperty.timestampValues);
  }

  @Override
  public int hashCode() {
    return Objects.hash(booleanValue, dateValues, doubleValues, enumValues, htmlValues, integerValues, name, objectValues, textValues, timestampValues);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamedProperty {\n");
    sb.append("    booleanValue: ").append(toIndentedString(booleanValue)).append("\n");
    sb.append("    dateValues: ").append(toIndentedString(dateValues)).append("\n");
    sb.append("    doubleValues: ").append(toIndentedString(doubleValues)).append("\n");
    sb.append("    enumValues: ").append(toIndentedString(enumValues)).append("\n");
    sb.append("    htmlValues: ").append(toIndentedString(htmlValues)).append("\n");
    sb.append("    integerValues: ").append(toIndentedString(integerValues)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    objectValues: ").append(toIndentedString(objectValues)).append("\n");
    sb.append("    textValues: ").append(toIndentedString(textValues)).append("\n");
    sb.append("    timestampValues: ").append(toIndentedString(timestampValues)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("booleanValue");
    openapiFields.add("dateValues");
    openapiFields.add("doubleValues");
    openapiFields.add("enumValues");
    openapiFields.add("htmlValues");
    openapiFields.add("integerValues");
    openapiFields.add("name");
    openapiFields.add("objectValues");
    openapiFields.add("textValues");
    openapiFields.add("timestampValues");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamedProperty
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamedProperty.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamedProperty is not found in the empty JSON string", NamedProperty.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamedProperty.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamedProperty` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `dateValues`
      if (jsonObj.get("dateValues") != null && !jsonObj.get("dateValues").isJsonNull()) {
        DateValues.validateJsonElement(jsonObj.get("dateValues"));
      }
      // validate the optional field `doubleValues`
      if (jsonObj.get("doubleValues") != null && !jsonObj.get("doubleValues").isJsonNull()) {
        DoubleValues.validateJsonElement(jsonObj.get("doubleValues"));
      }
      // validate the optional field `enumValues`
      if (jsonObj.get("enumValues") != null && !jsonObj.get("enumValues").isJsonNull()) {
        EnumValues.validateJsonElement(jsonObj.get("enumValues"));
      }
      // validate the optional field `htmlValues`
      if (jsonObj.get("htmlValues") != null && !jsonObj.get("htmlValues").isJsonNull()) {
        HtmlValues.validateJsonElement(jsonObj.get("htmlValues"));
      }
      // validate the optional field `integerValues`
      if (jsonObj.get("integerValues") != null && !jsonObj.get("integerValues").isJsonNull()) {
        IntegerValues.validateJsonElement(jsonObj.get("integerValues"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `objectValues`
      if (jsonObj.get("objectValues") != null && !jsonObj.get("objectValues").isJsonNull()) {
        ObjectValues.validateJsonElement(jsonObj.get("objectValues"));
      }
      // validate the optional field `textValues`
      if (jsonObj.get("textValues") != null && !jsonObj.get("textValues").isJsonNull()) {
        TextValues.validateJsonElement(jsonObj.get("textValues"));
      }
      // validate the optional field `timestampValues`
      if (jsonObj.get("timestampValues") != null && !jsonObj.get("timestampValues").isJsonNull()) {
        TimestampValues.validateJsonElement(jsonObj.get("timestampValues"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamedProperty.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamedProperty' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamedProperty> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamedProperty.class));

       return (TypeAdapter<T>) new TypeAdapter<NamedProperty>() {
           @Override
           public void write(JsonWriter out, NamedProperty value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamedProperty read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamedProperty given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamedProperty
   * @throws IOException if the JSON string is invalid with respect to NamedProperty
   */
  public static NamedProperty fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamedProperty.class);
  }

  /**
   * Convert an instance of NamedProperty to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

