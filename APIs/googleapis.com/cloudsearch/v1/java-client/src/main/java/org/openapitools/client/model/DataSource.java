/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GSuitePrincipal;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Datasource is a logical namespace for items to be indexed. All items must belong to a datasource. This is the prerequisite before items can be indexed into Cloud Search. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DataSource {
  public static final String SERIALIZED_NAME_DISABLE_MODIFICATIONS = "disableModifications";
  @SerializedName(SERIALIZED_NAME_DISABLE_MODIFICATIONS)
  private Boolean disableModifications;

  public static final String SERIALIZED_NAME_DISABLE_SERVING = "disableServing";
  @SerializedName(SERIALIZED_NAME_DISABLE_SERVING)
  private Boolean disableServing;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_INDEXING_SERVICE_ACCOUNTS = "indexingServiceAccounts";
  @SerializedName(SERIALIZED_NAME_INDEXING_SERVICE_ACCOUNTS)
  private List<String> indexingServiceAccounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_ITEMS_VISIBILITY = "itemsVisibility";
  @SerializedName(SERIALIZED_NAME_ITEMS_VISIBILITY)
  private List<GSuitePrincipal> itemsVisibility = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OPERATION_IDS = "operationIds";
  @SerializedName(SERIALIZED_NAME_OPERATION_IDS)
  private List<String> operationIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_RETURN_THUMBNAIL_URLS = "returnThumbnailUrls";
  @SerializedName(SERIALIZED_NAME_RETURN_THUMBNAIL_URLS)
  private Boolean returnThumbnailUrls;

  public static final String SERIALIZED_NAME_SHORT_NAME = "shortName";
  @SerializedName(SERIALIZED_NAME_SHORT_NAME)
  private String shortName;

  public DataSource() {
  }

  public DataSource disableModifications(Boolean disableModifications) {
    this.disableModifications = disableModifications;
    return this;
  }

  /**
   * If true, sets the datasource to read-only mode. In read-only mode, the Indexing API rejects any requests to index or delete items in this source. Enabling read-only mode does not stop the processing of previously accepted data.
   * @return disableModifications
   */
  @javax.annotation.Nullable
  public Boolean getDisableModifications() {
    return disableModifications;
  }

  public void setDisableModifications(Boolean disableModifications) {
    this.disableModifications = disableModifications;
  }


  public DataSource disableServing(Boolean disableServing) {
    this.disableServing = disableServing;
    return this;
  }

  /**
   * Disable serving any search or assist results.
   * @return disableServing
   */
  @javax.annotation.Nullable
  public Boolean getDisableServing() {
    return disableServing;
  }

  public void setDisableServing(Boolean disableServing) {
    this.disableServing = disableServing;
  }


  public DataSource displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Required. Display name of the datasource The maximum length is 300 characters.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public DataSource indexingServiceAccounts(List<String> indexingServiceAccounts) {
    this.indexingServiceAccounts = indexingServiceAccounts;
    return this;
  }

  public DataSource addIndexingServiceAccountsItem(String indexingServiceAccountsItem) {
    if (this.indexingServiceAccounts == null) {
      this.indexingServiceAccounts = new ArrayList<>();
    }
    this.indexingServiceAccounts.add(indexingServiceAccountsItem);
    return this;
  }

  /**
   * List of service accounts that have indexing access.
   * @return indexingServiceAccounts
   */
  @javax.annotation.Nullable
  public List<String> getIndexingServiceAccounts() {
    return indexingServiceAccounts;
  }

  public void setIndexingServiceAccounts(List<String> indexingServiceAccounts) {
    this.indexingServiceAccounts = indexingServiceAccounts;
  }


  public DataSource itemsVisibility(List<GSuitePrincipal> itemsVisibility) {
    this.itemsVisibility = itemsVisibility;
    return this;
  }

  public DataSource addItemsVisibilityItem(GSuitePrincipal itemsVisibilityItem) {
    if (this.itemsVisibility == null) {
      this.itemsVisibility = new ArrayList<>();
    }
    this.itemsVisibility.add(itemsVisibilityItem);
    return this;
  }

  /**
   * This field restricts visibility to items at the datasource level. Items within the datasource are restricted to the union of users and groups included in this field. Note that, this does not ensure access to a specific item, as users need to have ACL permissions on the contained items. This ensures a high level access on the entire datasource, and that the individual items are not shared outside this visibility.
   * @return itemsVisibility
   */
  @javax.annotation.Nullable
  public List<GSuitePrincipal> getItemsVisibility() {
    return itemsVisibility;
  }

  public void setItemsVisibility(List<GSuitePrincipal> itemsVisibility) {
    this.itemsVisibility = itemsVisibility;
  }


  public DataSource name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the datasource resource. Format: datasources/{source_id}. The name is ignored when creating a datasource.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public DataSource operationIds(List<String> operationIds) {
    this.operationIds = operationIds;
    return this;
  }

  public DataSource addOperationIdsItem(String operationIdsItem) {
    if (this.operationIds == null) {
      this.operationIds = new ArrayList<>();
    }
    this.operationIds.add(operationIdsItem);
    return this;
  }

  /**
   * IDs of the Long Running Operations (LROs) currently running for this schema.
   * @return operationIds
   */
  @javax.annotation.Nullable
  public List<String> getOperationIds() {
    return operationIds;
  }

  public void setOperationIds(List<String> operationIds) {
    this.operationIds = operationIds;
  }


  public DataSource returnThumbnailUrls(Boolean returnThumbnailUrls) {
    this.returnThumbnailUrls = returnThumbnailUrls;
    return this;
  }

  /**
   * Can a user request to get thumbnail URI for Items indexed in this data source.
   * @return returnThumbnailUrls
   */
  @javax.annotation.Nullable
  public Boolean getReturnThumbnailUrls() {
    return returnThumbnailUrls;
  }

  public void setReturnThumbnailUrls(Boolean returnThumbnailUrls) {
    this.returnThumbnailUrls = returnThumbnailUrls;
  }


  public DataSource shortName(String shortName) {
    this.shortName = shortName;
    return this;
  }

  /**
   * A short name or alias for the source. This value will be used to match the &#39;source&#39; operator. For example, if the short name is *&lt;value&gt;* then queries like *source:&lt;value&gt;* will only return results for this source. The value must be unique across all datasources. The value must only contain alphanumeric characters (a-zA-Z0-9). The value cannot start with &#39;google&#39; and cannot be one of the following: mail, gmail, docs, drive, groups, sites, calendar, hangouts, gplus, keep, people, teams. Its maximum length is 32 characters.
   * @return shortName
   */
  @javax.annotation.Nullable
  public String getShortName() {
    return shortName;
  }

  public void setShortName(String shortName) {
    this.shortName = shortName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataSource dataSource = (DataSource) o;
    return Objects.equals(this.disableModifications, dataSource.disableModifications) &&
        Objects.equals(this.disableServing, dataSource.disableServing) &&
        Objects.equals(this.displayName, dataSource.displayName) &&
        Objects.equals(this.indexingServiceAccounts, dataSource.indexingServiceAccounts) &&
        Objects.equals(this.itemsVisibility, dataSource.itemsVisibility) &&
        Objects.equals(this.name, dataSource.name) &&
        Objects.equals(this.operationIds, dataSource.operationIds) &&
        Objects.equals(this.returnThumbnailUrls, dataSource.returnThumbnailUrls) &&
        Objects.equals(this.shortName, dataSource.shortName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(disableModifications, disableServing, displayName, indexingServiceAccounts, itemsVisibility, name, operationIds, returnThumbnailUrls, shortName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataSource {\n");
    sb.append("    disableModifications: ").append(toIndentedString(disableModifications)).append("\n");
    sb.append("    disableServing: ").append(toIndentedString(disableServing)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    indexingServiceAccounts: ").append(toIndentedString(indexingServiceAccounts)).append("\n");
    sb.append("    itemsVisibility: ").append(toIndentedString(itemsVisibility)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    operationIds: ").append(toIndentedString(operationIds)).append("\n");
    sb.append("    returnThumbnailUrls: ").append(toIndentedString(returnThumbnailUrls)).append("\n");
    sb.append("    shortName: ").append(toIndentedString(shortName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("disableModifications");
    openapiFields.add("disableServing");
    openapiFields.add("displayName");
    openapiFields.add("indexingServiceAccounts");
    openapiFields.add("itemsVisibility");
    openapiFields.add("name");
    openapiFields.add("operationIds");
    openapiFields.add("returnThumbnailUrls");
    openapiFields.add("shortName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DataSource
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DataSource.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataSource is not found in the empty JSON string", DataSource.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DataSource.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DataSource` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("indexingServiceAccounts") != null && !jsonObj.get("indexingServiceAccounts").isJsonNull() && !jsonObj.get("indexingServiceAccounts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `indexingServiceAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("indexingServiceAccounts").toString()));
      }
      if (jsonObj.get("itemsVisibility") != null && !jsonObj.get("itemsVisibility").isJsonNull()) {
        JsonArray jsonArrayitemsVisibility = jsonObj.getAsJsonArray("itemsVisibility");
        if (jsonArrayitemsVisibility != null) {
          // ensure the json data is an array
          if (!jsonObj.get("itemsVisibility").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `itemsVisibility` to be an array in the JSON string but got `%s`", jsonObj.get("itemsVisibility").toString()));
          }

          // validate the optional field `itemsVisibility` (array)
          for (int i = 0; i < jsonArrayitemsVisibility.size(); i++) {
            GSuitePrincipal.validateJsonElement(jsonArrayitemsVisibility.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("operationIds") != null && !jsonObj.get("operationIds").isJsonNull() && !jsonObj.get("operationIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `operationIds` to be an array in the JSON string but got `%s`", jsonObj.get("operationIds").toString()));
      }
      if ((jsonObj.get("shortName") != null && !jsonObj.get("shortName").isJsonNull()) && !jsonObj.get("shortName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shortName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shortName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataSource.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataSource' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataSource> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataSource.class));

       return (TypeAdapter<T>) new TypeAdapter<DataSource>() {
           @Override
           public void write(JsonWriter out, DataSource value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataSource read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DataSource given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DataSource
   * @throws IOException if the JSON string is invalid with respect to DataSource
   */
  public static DataSource fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataSource.class);
  }

  /**
   * Convert an instance of DataSource to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

