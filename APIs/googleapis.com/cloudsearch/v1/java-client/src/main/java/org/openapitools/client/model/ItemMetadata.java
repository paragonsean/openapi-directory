/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ContextAttribute;
import org.openapitools.client.model.Interaction;
import org.openapitools.client.model.SearchQualityMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Available metadata fields for the item.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ItemMetadata {
  public static final String SERIALIZED_NAME_CONTAINER_NAME = "containerName";
  @SerializedName(SERIALIZED_NAME_CONTAINER_NAME)
  private String containerName;

  public static final String SERIALIZED_NAME_CONTENT_LANGUAGE = "contentLanguage";
  @SerializedName(SERIALIZED_NAME_CONTENT_LANGUAGE)
  private String contentLanguage;

  public static final String SERIALIZED_NAME_CONTEXT_ATTRIBUTES = "contextAttributes";
  @SerializedName(SERIALIZED_NAME_CONTEXT_ATTRIBUTES)
  private List<ContextAttribute> contextAttributes = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_INTERACTIONS = "interactions";
  @SerializedName(SERIALIZED_NAME_INTERACTIONS)
  private List<Interaction> interactions = new ArrayList<>();

  public static final String SERIALIZED_NAME_KEYWORDS = "keywords";
  @SerializedName(SERIALIZED_NAME_KEYWORDS)
  private List<String> keywords = new ArrayList<>();

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_OBJECT_TYPE = "objectType";
  @SerializedName(SERIALIZED_NAME_OBJECT_TYPE)
  private String objectType;

  public static final String SERIALIZED_NAME_SEARCH_QUALITY_METADATA = "searchQualityMetadata";
  @SerializedName(SERIALIZED_NAME_SEARCH_QUALITY_METADATA)
  private SearchQualityMetadata searchQualityMetadata;

  public static final String SERIALIZED_NAME_SOURCE_REPOSITORY_URL = "sourceRepositoryUrl";
  @SerializedName(SERIALIZED_NAME_SOURCE_REPOSITORY_URL)
  private String sourceRepositoryUrl;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public ItemMetadata() {
  }

  public ItemMetadata containerName(String containerName) {
    this.containerName = containerName;
    return this;
  }

  /**
   * The name of the container for this item. Deletion of the container item leads to automatic deletion of this item. Note: ACLs are not inherited from a container item. To provide ACL inheritance for an item, use the inheritAclFrom field. The maximum length is 1536 characters.
   * @return containerName
   */
  @javax.annotation.Nullable
  public String getContainerName() {
    return containerName;
  }

  public void setContainerName(String containerName) {
    this.containerName = containerName;
  }


  public ItemMetadata contentLanguage(String contentLanguage) {
    this.contentLanguage = contentLanguage;
    return this;
  }

  /**
   * The BCP-47 language code for the item, such as \&quot;en-US\&quot; or \&quot;sr-Latn\&quot;. For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. The maximum length is 32 characters.
   * @return contentLanguage
   */
  @javax.annotation.Nullable
  public String getContentLanguage() {
    return contentLanguage;
  }

  public void setContentLanguage(String contentLanguage) {
    this.contentLanguage = contentLanguage;
  }


  public ItemMetadata contextAttributes(List<ContextAttribute> contextAttributes) {
    this.contextAttributes = contextAttributes;
    return this;
  }

  public ItemMetadata addContextAttributesItem(ContextAttribute contextAttributesItem) {
    if (this.contextAttributes == null) {
      this.contextAttributes = new ArrayList<>();
    }
    this.contextAttributes.add(contextAttributesItem);
    return this;
  }

  /**
   * A set of named attributes associated with the item. This can be used for influencing the ranking of the item based on the context in the request. The maximum number of elements is 10.
   * @return contextAttributes
   */
  @javax.annotation.Nullable
  public List<ContextAttribute> getContextAttributes() {
    return contextAttributes;
  }

  public void setContextAttributes(List<ContextAttribute> contextAttributes) {
    this.contextAttributes = contextAttributes;
  }


  public ItemMetadata createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * The time when the item was created in the source repository.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  public ItemMetadata hash(String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  public void setHash(String hash) {
    this.hash = hash;
  }


  public ItemMetadata interactions(List<Interaction> interactions) {
    this.interactions = interactions;
    return this;
  }

  public ItemMetadata addInteractionsItem(Interaction interactionsItem) {
    if (this.interactions == null) {
      this.interactions = new ArrayList<>();
    }
    this.interactions.add(interactionsItem);
    return this;
  }

  /**
   * A list of interactions for the item. Interactions are used to improve Search quality, but are not exposed to end users. The maximum number of elements is 1000.
   * @return interactions
   */
  @javax.annotation.Nullable
  public List<Interaction> getInteractions() {
    return interactions;
  }

  public void setInteractions(List<Interaction> interactions) {
    this.interactions = interactions;
  }


  public ItemMetadata keywords(List<String> keywords) {
    this.keywords = keywords;
    return this;
  }

  public ItemMetadata addKeywordsItem(String keywordsItem) {
    if (this.keywords == null) {
      this.keywords = new ArrayList<>();
    }
    this.keywords.add(keywordsItem);
    return this;
  }

  /**
   * Additional keywords or phrases that should match the item. Used internally for user generated content. The maximum number of elements is 100. The maximum length is 8192 characters.
   * @return keywords
   */
  @javax.annotation.Nullable
  public List<String> getKeywords() {
    return keywords;
  }

  public void setKeywords(List<String> keywords) {
    this.keywords = keywords;
  }


  public ItemMetadata mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * The original mime-type of ItemContent.content in the source repository. The maximum length is 256 characters.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public ItemMetadata objectType(String objectType) {
    this.objectType = objectType;
    return this;
  }

  /**
   * The type of the item. This should correspond to the name of an object definition in the schema registered for the data source. For example, if the schema for the data source contains an object definition with name &#39;document&#39;, then item indexing requests for objects of that type should set objectType to &#39;document&#39;. The maximum length is 256 characters.
   * @return objectType
   */
  @javax.annotation.Nullable
  public String getObjectType() {
    return objectType;
  }

  public void setObjectType(String objectType) {
    this.objectType = objectType;
  }


  public ItemMetadata searchQualityMetadata(SearchQualityMetadata searchQualityMetadata) {
    this.searchQualityMetadata = searchQualityMetadata;
    return this;
  }

  /**
   * Get searchQualityMetadata
   * @return searchQualityMetadata
   */
  @javax.annotation.Nullable
  public SearchQualityMetadata getSearchQualityMetadata() {
    return searchQualityMetadata;
  }

  public void setSearchQualityMetadata(SearchQualityMetadata searchQualityMetadata) {
    this.searchQualityMetadata = searchQualityMetadata;
  }


  public ItemMetadata sourceRepositoryUrl(String sourceRepositoryUrl) {
    this.sourceRepositoryUrl = sourceRepositoryUrl;
    return this;
  }

  /**
   * Link to the source repository serving the data. Seach results apply this link to the title. Whitespace or special characters may cause Cloud Seach result links to trigger a redirect notice; to avoid this, encode the URL. The maximum length is 2048 characters.
   * @return sourceRepositoryUrl
   */
  @javax.annotation.Nullable
  public String getSourceRepositoryUrl() {
    return sourceRepositoryUrl;
  }

  public void setSourceRepositoryUrl(String sourceRepositoryUrl) {
    this.sourceRepositoryUrl = sourceRepositoryUrl;
  }


  public ItemMetadata title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the item. If given, this will be the displayed title of the Search result. The maximum length is 2048 characters.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public ItemMetadata updateTime(String updateTime) {
    this.updateTime = updateTime;
    return this;
  }

  /**
   * The time when the item was last modified in the source repository.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }

  public void setUpdateTime(String updateTime) {
    this.updateTime = updateTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ItemMetadata itemMetadata = (ItemMetadata) o;
    return Objects.equals(this.containerName, itemMetadata.containerName) &&
        Objects.equals(this.contentLanguage, itemMetadata.contentLanguage) &&
        Objects.equals(this.contextAttributes, itemMetadata.contextAttributes) &&
        Objects.equals(this.createTime, itemMetadata.createTime) &&
        Objects.equals(this.hash, itemMetadata.hash) &&
        Objects.equals(this.interactions, itemMetadata.interactions) &&
        Objects.equals(this.keywords, itemMetadata.keywords) &&
        Objects.equals(this.mimeType, itemMetadata.mimeType) &&
        Objects.equals(this.objectType, itemMetadata.objectType) &&
        Objects.equals(this.searchQualityMetadata, itemMetadata.searchQualityMetadata) &&
        Objects.equals(this.sourceRepositoryUrl, itemMetadata.sourceRepositoryUrl) &&
        Objects.equals(this.title, itemMetadata.title) &&
        Objects.equals(this.updateTime, itemMetadata.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(containerName, contentLanguage, contextAttributes, createTime, hash, interactions, keywords, mimeType, objectType, searchQualityMetadata, sourceRepositoryUrl, title, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ItemMetadata {\n");
    sb.append("    containerName: ").append(toIndentedString(containerName)).append("\n");
    sb.append("    contentLanguage: ").append(toIndentedString(contentLanguage)).append("\n");
    sb.append("    contextAttributes: ").append(toIndentedString(contextAttributes)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    interactions: ").append(toIndentedString(interactions)).append("\n");
    sb.append("    keywords: ").append(toIndentedString(keywords)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    objectType: ").append(toIndentedString(objectType)).append("\n");
    sb.append("    searchQualityMetadata: ").append(toIndentedString(searchQualityMetadata)).append("\n");
    sb.append("    sourceRepositoryUrl: ").append(toIndentedString(sourceRepositoryUrl)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("containerName");
    openapiFields.add("contentLanguage");
    openapiFields.add("contextAttributes");
    openapiFields.add("createTime");
    openapiFields.add("hash");
    openapiFields.add("interactions");
    openapiFields.add("keywords");
    openapiFields.add("mimeType");
    openapiFields.add("objectType");
    openapiFields.add("searchQualityMetadata");
    openapiFields.add("sourceRepositoryUrl");
    openapiFields.add("title");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ItemMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ItemMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ItemMetadata is not found in the empty JSON string", ItemMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ItemMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ItemMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("containerName") != null && !jsonObj.get("containerName").isJsonNull()) && !jsonObj.get("containerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("containerName").toString()));
      }
      if ((jsonObj.get("contentLanguage") != null && !jsonObj.get("contentLanguage").isJsonNull()) && !jsonObj.get("contentLanguage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentLanguage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentLanguage").toString()));
      }
      if (jsonObj.get("contextAttributes") != null && !jsonObj.get("contextAttributes").isJsonNull()) {
        JsonArray jsonArraycontextAttributes = jsonObj.getAsJsonArray("contextAttributes");
        if (jsonArraycontextAttributes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("contextAttributes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `contextAttributes` to be an array in the JSON string but got `%s`", jsonObj.get("contextAttributes").toString()));
          }

          // validate the optional field `contextAttributes` (array)
          for (int i = 0; i < jsonArraycontextAttributes.size(); i++) {
            ContextAttribute.validateJsonElement(jsonArraycontextAttributes.get(i));
          };
        }
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      if (jsonObj.get("interactions") != null && !jsonObj.get("interactions").isJsonNull()) {
        JsonArray jsonArrayinteractions = jsonObj.getAsJsonArray("interactions");
        if (jsonArrayinteractions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("interactions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `interactions` to be an array in the JSON string but got `%s`", jsonObj.get("interactions").toString()));
          }

          // validate the optional field `interactions` (array)
          for (int i = 0; i < jsonArrayinteractions.size(); i++) {
            Interaction.validateJsonElement(jsonArrayinteractions.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("keywords") != null && !jsonObj.get("keywords").isJsonNull() && !jsonObj.get("keywords").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `keywords` to be an array in the JSON string but got `%s`", jsonObj.get("keywords").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("objectType") != null && !jsonObj.get("objectType").isJsonNull()) && !jsonObj.get("objectType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `objectType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("objectType").toString()));
      }
      // validate the optional field `searchQualityMetadata`
      if (jsonObj.get("searchQualityMetadata") != null && !jsonObj.get("searchQualityMetadata").isJsonNull()) {
        SearchQualityMetadata.validateJsonElement(jsonObj.get("searchQualityMetadata"));
      }
      if ((jsonObj.get("sourceRepositoryUrl") != null && !jsonObj.get("sourceRepositoryUrl").isJsonNull()) && !jsonObj.get("sourceRepositoryUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceRepositoryUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceRepositoryUrl").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ItemMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ItemMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ItemMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ItemMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<ItemMetadata>() {
           @Override
           public void write(JsonWriter out, ItemMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ItemMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ItemMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ItemMetadata
   * @throws IOException if the JSON string is invalid with respect to ItemMetadata
   */
  public static ItemMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ItemMetadata.class);
  }

  /**
   * Convert an instance of ItemMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

