/*
 * Cloud Search API
 * Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ItemAcl;
import org.openapitools.client.model.ItemContent;
import org.openapitools.client.model.ItemMetadata;
import org.openapitools.client.model.ItemStatus;
import org.openapitools.client.model.ItemStructuredData;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a single object that is an item in the search index, such as a file, folder, or a database record.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:46.641752-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Item {
  public static final String SERIALIZED_NAME_ACL = "acl";
  @SerializedName(SERIALIZED_NAME_ACL)
  private ItemAcl acl;

  public static final String SERIALIZED_NAME_CONTENT = "content";
  @SerializedName(SERIALIZED_NAME_CONTENT)
  private ItemContent content;

  /**
   * The type for this item.
   */
  @JsonAdapter(ItemTypeEnum.Adapter.class)
  public enum ItemTypeEnum {
    UNSPECIFIED("UNSPECIFIED"),
    
    CONTENT_ITEM("CONTENT_ITEM"),
    
    CONTAINER_ITEM("CONTAINER_ITEM"),
    
    VIRTUAL_CONTAINER_ITEM("VIRTUAL_CONTAINER_ITEM");

    private String value;

    ItemTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ItemTypeEnum fromValue(String value) {
      for (ItemTypeEnum b : ItemTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ItemTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ItemTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ItemTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ItemTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ItemTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ITEM_TYPE = "itemType";
  @SerializedName(SERIALIZED_NAME_ITEM_TYPE)
  private ItemTypeEnum itemType;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private ItemMetadata metadata;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PAYLOAD = "payload";
  @SerializedName(SERIALIZED_NAME_PAYLOAD)
  private byte[] payload;

  public static final String SERIALIZED_NAME_QUEUE = "queue";
  @SerializedName(SERIALIZED_NAME_QUEUE)
  private String queue;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private ItemStatus status;

  public static final String SERIALIZED_NAME_STRUCTURED_DATA = "structuredData";
  @SerializedName(SERIALIZED_NAME_STRUCTURED_DATA)
  private ItemStructuredData structuredData;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private byte[] version;

  public Item() {
  }

  public Item acl(ItemAcl acl) {
    this.acl = acl;
    return this;
  }

  /**
   * Get acl
   * @return acl
   */
  @javax.annotation.Nullable
  public ItemAcl getAcl() {
    return acl;
  }

  public void setAcl(ItemAcl acl) {
    this.acl = acl;
  }


  public Item content(ItemContent content) {
    this.content = content;
    return this;
  }

  /**
   * Get content
   * @return content
   */
  @javax.annotation.Nullable
  public ItemContent getContent() {
    return content;
  }

  public void setContent(ItemContent content) {
    this.content = content;
  }


  public Item itemType(ItemTypeEnum itemType) {
    this.itemType = itemType;
    return this;
  }

  /**
   * The type for this item.
   * @return itemType
   */
  @javax.annotation.Nullable
  public ItemTypeEnum getItemType() {
    return itemType;
  }

  public void setItemType(ItemTypeEnum itemType) {
    this.itemType = itemType;
  }


  public Item metadata(ItemMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  public ItemMetadata getMetadata() {
    return metadata;
  }

  public void setMetadata(ItemMetadata metadata) {
    this.metadata = metadata;
  }


  public Item name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the Item. Format: datasources/{source_id}/items/{item_id} This is a required field. The maximum length is 1536 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Item payload(byte[] payload) {
    this.payload = payload;
    return this;
  }

  /**
   * Additional state connector can store for this item. The maximum length is 10000 bytes.
   * @return payload
   */
  @javax.annotation.Nullable
  public byte[] getPayload() {
    return payload;
  }

  public void setPayload(byte[] payload) {
    this.payload = payload;
  }


  public Item queue(String queue) {
    this.queue = queue;
    return this;
  }

  /**
   * Queue this item belongs to. The maximum length is 100 characters.
   * @return queue
   */
  @javax.annotation.Nullable
  public String getQueue() {
    return queue;
  }

  public void setQueue(String queue) {
    this.queue = queue;
  }


  public Item status(ItemStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public ItemStatus getStatus() {
    return status;
  }

  public void setStatus(ItemStatus status) {
    this.status = status;
  }


  public Item structuredData(ItemStructuredData structuredData) {
    this.structuredData = structuredData;
    return this;
  }

  /**
   * Get structuredData
   * @return structuredData
   */
  @javax.annotation.Nullable
  public ItemStructuredData getStructuredData() {
    return structuredData;
  }

  public void setStructuredData(ItemStructuredData structuredData) {
    this.structuredData = structuredData;
  }


  public Item version(byte[] version) {
    this.version = version;
    return this;
  }

  /**
   * Required. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won&#39;t index or delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations).
   * @return version
   */
  @javax.annotation.Nullable
  public byte[] getVersion() {
    return version;
  }

  public void setVersion(byte[] version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Item item = (Item) o;
    return Objects.equals(this.acl, item.acl) &&
        Objects.equals(this.content, item.content) &&
        Objects.equals(this.itemType, item.itemType) &&
        Objects.equals(this.metadata, item.metadata) &&
        Objects.equals(this.name, item.name) &&
        Arrays.equals(this.payload, item.payload) &&
        Objects.equals(this.queue, item.queue) &&
        Objects.equals(this.status, item.status) &&
        Objects.equals(this.structuredData, item.structuredData) &&
        Arrays.equals(this.version, item.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acl, content, itemType, metadata, name, Arrays.hashCode(payload), queue, status, structuredData, Arrays.hashCode(version));
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Item {\n");
    sb.append("    acl: ").append(toIndentedString(acl)).append("\n");
    sb.append("    content: ").append(toIndentedString(content)).append("\n");
    sb.append("    itemType: ").append(toIndentedString(itemType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    payload: ").append(toIndentedString(payload)).append("\n");
    sb.append("    queue: ").append(toIndentedString(queue)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    structuredData: ").append(toIndentedString(structuredData)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acl");
    openapiFields.add("content");
    openapiFields.add("itemType");
    openapiFields.add("metadata");
    openapiFields.add("name");
    openapiFields.add("payload");
    openapiFields.add("queue");
    openapiFields.add("status");
    openapiFields.add("structuredData");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Item
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Item.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Item is not found in the empty JSON string", Item.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Item.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Item` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `acl`
      if (jsonObj.get("acl") != null && !jsonObj.get("acl").isJsonNull()) {
        ItemAcl.validateJsonElement(jsonObj.get("acl"));
      }
      // validate the optional field `content`
      if (jsonObj.get("content") != null && !jsonObj.get("content").isJsonNull()) {
        ItemContent.validateJsonElement(jsonObj.get("content"));
      }
      if ((jsonObj.get("itemType") != null && !jsonObj.get("itemType").isJsonNull()) && !jsonObj.get("itemType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("itemType").toString()));
      }
      // validate the optional field `itemType`
      if (jsonObj.get("itemType") != null && !jsonObj.get("itemType").isJsonNull()) {
        ItemTypeEnum.validateJsonElement(jsonObj.get("itemType"));
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        ItemMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("queue") != null && !jsonObj.get("queue").isJsonNull()) && !jsonObj.get("queue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queue").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        ItemStatus.validateJsonElement(jsonObj.get("status"));
      }
      // validate the optional field `structuredData`
      if (jsonObj.get("structuredData") != null && !jsonObj.get("structuredData").isJsonNull()) {
        ItemStructuredData.validateJsonElement(jsonObj.get("structuredData"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Item.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Item' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Item> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Item.class));

       return (TypeAdapter<T>) new TypeAdapter<Item>() {
           @Override
           public void write(JsonWriter out, Item value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Item read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Item given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Item
   * @throws IOException if the JSON string is invalid with respect to Item
   */
  public static Item fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Item.class);
  }

  /**
   * Convert an instance of Item to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

