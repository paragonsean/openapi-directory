/*
 * Cloud Storage JSON API
 * Lets you store and retrieve potentially-large, immutable data objects.
 *
 * The version of the OpenAPI document: v1beta2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BucketAccessControl;
import org.openapitools.client.model.BucketCorsInner;
import org.openapitools.client.model.BucketLifecycle;
import org.openapitools.client.model.BucketLogging;
import org.openapitools.client.model.BucketOwner;
import org.openapitools.client.model.BucketVersioning;
import org.openapitools.client.model.BucketWebsite;
import org.openapitools.client.model.ObjectAccessControl;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A bucket.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:12.695403-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Bucket {
  public static final String SERIALIZED_NAME_ACL = "acl";
  @SerializedName(SERIALIZED_NAME_ACL)
  private List<BucketAccessControl> acl = new ArrayList<>();

  public static final String SERIALIZED_NAME_CORS = "cors";
  @SerializedName(SERIALIZED_NAME_CORS)
  private List<BucketCorsInner> cors = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEFAULT_OBJECT_ACL = "defaultObjectAcl";
  @SerializedName(SERIALIZED_NAME_DEFAULT_OBJECT_ACL)
  private List<ObjectAccessControl> defaultObjectAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "storage#bucket";

  public static final String SERIALIZED_NAME_LIFECYCLE = "lifecycle";
  @SerializedName(SERIALIZED_NAME_LIFECYCLE)
  private BucketLifecycle lifecycle;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_LOGGING = "logging";
  @SerializedName(SERIALIZED_NAME_LOGGING)
  private BucketLogging logging;

  public static final String SERIALIZED_NAME_METAGENERATION = "metageneration";
  @SerializedName(SERIALIZED_NAME_METAGENERATION)
  private String metageneration;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OWNER = "owner";
  @SerializedName(SERIALIZED_NAME_OWNER)
  private BucketOwner owner;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public static final String SERIALIZED_NAME_STORAGE_CLASS = "storageClass";
  @SerializedName(SERIALIZED_NAME_STORAGE_CLASS)
  private String storageClass;

  public static final String SERIALIZED_NAME_TIME_CREATED = "timeCreated";
  @SerializedName(SERIALIZED_NAME_TIME_CREATED)
  private OffsetDateTime timeCreated;

  public static final String SERIALIZED_NAME_VERSIONING = "versioning";
  @SerializedName(SERIALIZED_NAME_VERSIONING)
  private BucketVersioning versioning;

  public static final String SERIALIZED_NAME_WEBSITE = "website";
  @SerializedName(SERIALIZED_NAME_WEBSITE)
  private BucketWebsite website;

  public Bucket() {
  }

  public Bucket acl(List<BucketAccessControl> acl) {
    this.acl = acl;
    return this;
  }

  public Bucket addAclItem(BucketAccessControl aclItem) {
    if (this.acl == null) {
      this.acl = new ArrayList<>();
    }
    this.acl.add(aclItem);
    return this;
  }

  /**
   * Access controls on the bucket.
   * @return acl
   */
  @javax.annotation.Nullable
  public List<BucketAccessControl> getAcl() {
    return acl;
  }

  public void setAcl(List<BucketAccessControl> acl) {
    this.acl = acl;
  }


  public Bucket cors(List<BucketCorsInner> cors) {
    this.cors = cors;
    return this;
  }

  public Bucket addCorsItem(BucketCorsInner corsItem) {
    if (this.cors == null) {
      this.cors = new ArrayList<>();
    }
    this.cors.add(corsItem);
    return this;
  }

  /**
   * The bucket&#39;s Cross-Origin Resource Sharing (CORS) configuration.
   * @return cors
   */
  @javax.annotation.Nullable
  public List<BucketCorsInner> getCors() {
    return cors;
  }

  public void setCors(List<BucketCorsInner> cors) {
    this.cors = cors;
  }


  public Bucket defaultObjectAcl(List<ObjectAccessControl> defaultObjectAcl) {
    this.defaultObjectAcl = defaultObjectAcl;
    return this;
  }

  public Bucket addDefaultObjectAclItem(ObjectAccessControl defaultObjectAclItem) {
    if (this.defaultObjectAcl == null) {
      this.defaultObjectAcl = new ArrayList<>();
    }
    this.defaultObjectAcl.add(defaultObjectAclItem);
    return this;
  }

  /**
   * Default access controls to apply to new objects when no ACL is provided.
   * @return defaultObjectAcl
   */
  @javax.annotation.Nullable
  public List<ObjectAccessControl> getDefaultObjectAcl() {
    return defaultObjectAcl;
  }

  public void setDefaultObjectAcl(List<ObjectAccessControl> defaultObjectAcl) {
    this.defaultObjectAcl = defaultObjectAcl;
  }


  public Bucket etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * HTTP 1.1 Entity tag for the bucket.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public Bucket id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of the bucket.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Bucket kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * The kind of item this is. For buckets, this is always storage#bucket.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Bucket lifecycle(BucketLifecycle lifecycle) {
    this.lifecycle = lifecycle;
    return this;
  }

  /**
   * Get lifecycle
   * @return lifecycle
   */
  @javax.annotation.Nullable
  public BucketLifecycle getLifecycle() {
    return lifecycle;
  }

  public void setLifecycle(BucketLifecycle lifecycle) {
    this.lifecycle = lifecycle;
  }


  public Bucket location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Typical values are US and EU. Defaults to US. See the developer&#39;s guide for the authoritative list.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public Bucket logging(BucketLogging logging) {
    this.logging = logging;
    return this;
  }

  /**
   * Get logging
   * @return logging
   */
  @javax.annotation.Nullable
  public BucketLogging getLogging() {
    return logging;
  }

  public void setLogging(BucketLogging logging) {
    this.logging = logging;
  }


  public Bucket metageneration(String metageneration) {
    this.metageneration = metageneration;
    return this;
  }

  /**
   * The metadata generation of this bucket.
   * @return metageneration
   */
  @javax.annotation.Nullable
  public String getMetageneration() {
    return metageneration;
  }

  public void setMetageneration(String metageneration) {
    this.metageneration = metageneration;
  }


  public Bucket name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the bucket.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Bucket owner(BucketOwner owner) {
    this.owner = owner;
    return this;
  }

  /**
   * Get owner
   * @return owner
   */
  @javax.annotation.Nullable
  public BucketOwner getOwner() {
    return owner;
  }

  public void setOwner(BucketOwner owner) {
    this.owner = owner;
  }


  public Bucket selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * The URI of this bucket.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }


  public Bucket storageClass(String storageClass) {
    this.storageClass = storageClass;
    return this;
  }

  /**
   * The bucket&#39;s storage class. This defines how objects in the bucket are stored and determines the SLA and the cost of storage. Typical values are STANDARD and DURABLE_REDUCED_AVAILABILITY. Defaults to STANDARD. See the developer&#39;s guide for the authoritative list.
   * @return storageClass
   */
  @javax.annotation.Nullable
  public String getStorageClass() {
    return storageClass;
  }

  public void setStorageClass(String storageClass) {
    this.storageClass = storageClass;
  }


  public Bucket timeCreated(OffsetDateTime timeCreated) {
    this.timeCreated = timeCreated;
    return this;
  }

  /**
   * Creation time of the bucket in RFC 3339 format.
   * @return timeCreated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTimeCreated() {
    return timeCreated;
  }

  public void setTimeCreated(OffsetDateTime timeCreated) {
    this.timeCreated = timeCreated;
  }


  public Bucket versioning(BucketVersioning versioning) {
    this.versioning = versioning;
    return this;
  }

  /**
   * Get versioning
   * @return versioning
   */
  @javax.annotation.Nullable
  public BucketVersioning getVersioning() {
    return versioning;
  }

  public void setVersioning(BucketVersioning versioning) {
    this.versioning = versioning;
  }


  public Bucket website(BucketWebsite website) {
    this.website = website;
    return this;
  }

  /**
   * Get website
   * @return website
   */
  @javax.annotation.Nullable
  public BucketWebsite getWebsite() {
    return website;
  }

  public void setWebsite(BucketWebsite website) {
    this.website = website;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Bucket bucket = (Bucket) o;
    return Objects.equals(this.acl, bucket.acl) &&
        Objects.equals(this.cors, bucket.cors) &&
        Objects.equals(this.defaultObjectAcl, bucket.defaultObjectAcl) &&
        Objects.equals(this.etag, bucket.etag) &&
        Objects.equals(this.id, bucket.id) &&
        Objects.equals(this.kind, bucket.kind) &&
        Objects.equals(this.lifecycle, bucket.lifecycle) &&
        Objects.equals(this.location, bucket.location) &&
        Objects.equals(this.logging, bucket.logging) &&
        Objects.equals(this.metageneration, bucket.metageneration) &&
        Objects.equals(this.name, bucket.name) &&
        Objects.equals(this.owner, bucket.owner) &&
        Objects.equals(this.selfLink, bucket.selfLink) &&
        Objects.equals(this.storageClass, bucket.storageClass) &&
        Objects.equals(this.timeCreated, bucket.timeCreated) &&
        Objects.equals(this.versioning, bucket.versioning) &&
        Objects.equals(this.website, bucket.website);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acl, cors, defaultObjectAcl, etag, id, kind, lifecycle, location, logging, metageneration, name, owner, selfLink, storageClass, timeCreated, versioning, website);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Bucket {\n");
    sb.append("    acl: ").append(toIndentedString(acl)).append("\n");
    sb.append("    cors: ").append(toIndentedString(cors)).append("\n");
    sb.append("    defaultObjectAcl: ").append(toIndentedString(defaultObjectAcl)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    lifecycle: ").append(toIndentedString(lifecycle)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    logging: ").append(toIndentedString(logging)).append("\n");
    sb.append("    metageneration: ").append(toIndentedString(metageneration)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    storageClass: ").append(toIndentedString(storageClass)).append("\n");
    sb.append("    timeCreated: ").append(toIndentedString(timeCreated)).append("\n");
    sb.append("    versioning: ").append(toIndentedString(versioning)).append("\n");
    sb.append("    website: ").append(toIndentedString(website)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acl");
    openapiFields.add("cors");
    openapiFields.add("defaultObjectAcl");
    openapiFields.add("etag");
    openapiFields.add("id");
    openapiFields.add("kind");
    openapiFields.add("lifecycle");
    openapiFields.add("location");
    openapiFields.add("logging");
    openapiFields.add("metageneration");
    openapiFields.add("name");
    openapiFields.add("owner");
    openapiFields.add("selfLink");
    openapiFields.add("storageClass");
    openapiFields.add("timeCreated");
    openapiFields.add("versioning");
    openapiFields.add("website");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Bucket
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Bucket.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Bucket is not found in the empty JSON string", Bucket.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Bucket.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Bucket` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("acl") != null && !jsonObj.get("acl").isJsonNull()) {
        JsonArray jsonArrayacl = jsonObj.getAsJsonArray("acl");
        if (jsonArrayacl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `acl` to be an array in the JSON string but got `%s`", jsonObj.get("acl").toString()));
          }

          // validate the optional field `acl` (array)
          for (int i = 0; i < jsonArrayacl.size(); i++) {
            BucketAccessControl.validateJsonElement(jsonArrayacl.get(i));
          };
        }
      }
      if (jsonObj.get("cors") != null && !jsonObj.get("cors").isJsonNull()) {
        JsonArray jsonArraycors = jsonObj.getAsJsonArray("cors");
        if (jsonArraycors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("cors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `cors` to be an array in the JSON string but got `%s`", jsonObj.get("cors").toString()));
          }

          // validate the optional field `cors` (array)
          for (int i = 0; i < jsonArraycors.size(); i++) {
            BucketCorsInner.validateJsonElement(jsonArraycors.get(i));
          };
        }
      }
      if (jsonObj.get("defaultObjectAcl") != null && !jsonObj.get("defaultObjectAcl").isJsonNull()) {
        JsonArray jsonArraydefaultObjectAcl = jsonObj.getAsJsonArray("defaultObjectAcl");
        if (jsonArraydefaultObjectAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("defaultObjectAcl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `defaultObjectAcl` to be an array in the JSON string but got `%s`", jsonObj.get("defaultObjectAcl").toString()));
          }

          // validate the optional field `defaultObjectAcl` (array)
          for (int i = 0; i < jsonArraydefaultObjectAcl.size(); i++) {
            ObjectAccessControl.validateJsonElement(jsonArraydefaultObjectAcl.get(i));
          };
        }
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `lifecycle`
      if (jsonObj.get("lifecycle") != null && !jsonObj.get("lifecycle").isJsonNull()) {
        BucketLifecycle.validateJsonElement(jsonObj.get("lifecycle"));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      // validate the optional field `logging`
      if (jsonObj.get("logging") != null && !jsonObj.get("logging").isJsonNull()) {
        BucketLogging.validateJsonElement(jsonObj.get("logging"));
      }
      if ((jsonObj.get("metageneration") != null && !jsonObj.get("metageneration").isJsonNull()) && !jsonObj.get("metageneration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metageneration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metageneration").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `owner`
      if (jsonObj.get("owner") != null && !jsonObj.get("owner").isJsonNull()) {
        BucketOwner.validateJsonElement(jsonObj.get("owner"));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      if ((jsonObj.get("storageClass") != null && !jsonObj.get("storageClass").isJsonNull()) && !jsonObj.get("storageClass").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageClass` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageClass").toString()));
      }
      // validate the optional field `versioning`
      if (jsonObj.get("versioning") != null && !jsonObj.get("versioning").isJsonNull()) {
        BucketVersioning.validateJsonElement(jsonObj.get("versioning"));
      }
      // validate the optional field `website`
      if (jsonObj.get("website") != null && !jsonObj.get("website").isJsonNull()) {
        BucketWebsite.validateJsonElement(jsonObj.get("website"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Bucket.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Bucket' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Bucket> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Bucket.class));

       return (TypeAdapter<T>) new TypeAdapter<Bucket>() {
           @Override
           public void write(JsonWriter out, Bucket value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Bucket read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Bucket given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Bucket
   * @throws IOException if the JSON string is invalid with respect to Bucket
   */
  public static Bucket fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Bucket.class);
  }

  /**
   * Convert an instance of Bucket to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

