/**
 * Cloud Storage JSON API
 * Lets you store and retrieve potentially-large, immutable data objects.
 *
 * The version of the OpenAPI document: v1beta2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIObject.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIObject::OAIObject(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIObject::OAIObject() {
    this->initializeModel();
}

OAIObject::~OAIObject() {}

void OAIObject::initializeModel() {

    m_acl_isSet = false;
    m_acl_isValid = false;

    m_bucket_isSet = false;
    m_bucket_isValid = false;

    m_cache_control_isSet = false;
    m_cache_control_isValid = false;

    m_component_count_isSet = false;
    m_component_count_isValid = false;

    m_content_disposition_isSet = false;
    m_content_disposition_isValid = false;

    m_content_encoding_isSet = false;
    m_content_encoding_isValid = false;

    m_content_language_isSet = false;
    m_content_language_isValid = false;

    m_content_type_isSet = false;
    m_content_type_isValid = false;

    m_crc32c_isSet = false;
    m_crc32c_isValid = false;

    m_etag_isSet = false;
    m_etag_isValid = false;

    m_generation_isSet = false;
    m_generation_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_kind_isSet = false;
    m_kind_isValid = false;

    m_md5_hash_isSet = false;
    m_md5_hash_isValid = false;

    m_media_link_isSet = false;
    m_media_link_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_metageneration_isSet = false;
    m_metageneration_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_owner_isSet = false;
    m_owner_isValid = false;

    m_self_link_isSet = false;
    m_self_link_isValid = false;

    m_size_isSet = false;
    m_size_isValid = false;

    m_storage_class_isSet = false;
    m_storage_class_isValid = false;

    m_time_deleted_isSet = false;
    m_time_deleted_isValid = false;

    m_updated_isSet = false;
    m_updated_isValid = false;
}

void OAIObject::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIObject::fromJsonObject(QJsonObject json) {

    m_acl_isValid = ::OpenAPI::fromJsonValue(m_acl, json[QString("acl")]);
    m_acl_isSet = !json[QString("acl")].isNull() && m_acl_isValid;

    m_bucket_isValid = ::OpenAPI::fromJsonValue(m_bucket, json[QString("bucket")]);
    m_bucket_isSet = !json[QString("bucket")].isNull() && m_bucket_isValid;

    m_cache_control_isValid = ::OpenAPI::fromJsonValue(m_cache_control, json[QString("cacheControl")]);
    m_cache_control_isSet = !json[QString("cacheControl")].isNull() && m_cache_control_isValid;

    m_component_count_isValid = ::OpenAPI::fromJsonValue(m_component_count, json[QString("componentCount")]);
    m_component_count_isSet = !json[QString("componentCount")].isNull() && m_component_count_isValid;

    m_content_disposition_isValid = ::OpenAPI::fromJsonValue(m_content_disposition, json[QString("contentDisposition")]);
    m_content_disposition_isSet = !json[QString("contentDisposition")].isNull() && m_content_disposition_isValid;

    m_content_encoding_isValid = ::OpenAPI::fromJsonValue(m_content_encoding, json[QString("contentEncoding")]);
    m_content_encoding_isSet = !json[QString("contentEncoding")].isNull() && m_content_encoding_isValid;

    m_content_language_isValid = ::OpenAPI::fromJsonValue(m_content_language, json[QString("contentLanguage")]);
    m_content_language_isSet = !json[QString("contentLanguage")].isNull() && m_content_language_isValid;

    m_content_type_isValid = ::OpenAPI::fromJsonValue(m_content_type, json[QString("contentType")]);
    m_content_type_isSet = !json[QString("contentType")].isNull() && m_content_type_isValid;

    m_crc32c_isValid = ::OpenAPI::fromJsonValue(m_crc32c, json[QString("crc32c")]);
    m_crc32c_isSet = !json[QString("crc32c")].isNull() && m_crc32c_isValid;

    m_etag_isValid = ::OpenAPI::fromJsonValue(m_etag, json[QString("etag")]);
    m_etag_isSet = !json[QString("etag")].isNull() && m_etag_isValid;

    m_generation_isValid = ::OpenAPI::fromJsonValue(m_generation, json[QString("generation")]);
    m_generation_isSet = !json[QString("generation")].isNull() && m_generation_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_kind_isValid = ::OpenAPI::fromJsonValue(m_kind, json[QString("kind")]);
    m_kind_isSet = !json[QString("kind")].isNull() && m_kind_isValid;

    m_md5_hash_isValid = ::OpenAPI::fromJsonValue(m_md5_hash, json[QString("md5Hash")]);
    m_md5_hash_isSet = !json[QString("md5Hash")].isNull() && m_md5_hash_isValid;

    m_media_link_isValid = ::OpenAPI::fromJsonValue(m_media_link, json[QString("mediaLink")]);
    m_media_link_isSet = !json[QString("mediaLink")].isNull() && m_media_link_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_metageneration_isValid = ::OpenAPI::fromJsonValue(m_metageneration, json[QString("metageneration")]);
    m_metageneration_isSet = !json[QString("metageneration")].isNull() && m_metageneration_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_owner_isValid = ::OpenAPI::fromJsonValue(m_owner, json[QString("owner")]);
    m_owner_isSet = !json[QString("owner")].isNull() && m_owner_isValid;

    m_self_link_isValid = ::OpenAPI::fromJsonValue(m_self_link, json[QString("selfLink")]);
    m_self_link_isSet = !json[QString("selfLink")].isNull() && m_self_link_isValid;

    m_size_isValid = ::OpenAPI::fromJsonValue(m_size, json[QString("size")]);
    m_size_isSet = !json[QString("size")].isNull() && m_size_isValid;

    m_storage_class_isValid = ::OpenAPI::fromJsonValue(m_storage_class, json[QString("storageClass")]);
    m_storage_class_isSet = !json[QString("storageClass")].isNull() && m_storage_class_isValid;

    m_time_deleted_isValid = ::OpenAPI::fromJsonValue(m_time_deleted, json[QString("timeDeleted")]);
    m_time_deleted_isSet = !json[QString("timeDeleted")].isNull() && m_time_deleted_isValid;

    m_updated_isValid = ::OpenAPI::fromJsonValue(m_updated, json[QString("updated")]);
    m_updated_isSet = !json[QString("updated")].isNull() && m_updated_isValid;
}

QString OAIObject::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIObject::asJsonObject() const {
    QJsonObject obj;
    if (m_acl.size() > 0) {
        obj.insert(QString("acl"), ::OpenAPI::toJsonValue(m_acl));
    }
    if (m_bucket_isSet) {
        obj.insert(QString("bucket"), ::OpenAPI::toJsonValue(m_bucket));
    }
    if (m_cache_control_isSet) {
        obj.insert(QString("cacheControl"), ::OpenAPI::toJsonValue(m_cache_control));
    }
    if (m_component_count_isSet) {
        obj.insert(QString("componentCount"), ::OpenAPI::toJsonValue(m_component_count));
    }
    if (m_content_disposition_isSet) {
        obj.insert(QString("contentDisposition"), ::OpenAPI::toJsonValue(m_content_disposition));
    }
    if (m_content_encoding_isSet) {
        obj.insert(QString("contentEncoding"), ::OpenAPI::toJsonValue(m_content_encoding));
    }
    if (m_content_language_isSet) {
        obj.insert(QString("contentLanguage"), ::OpenAPI::toJsonValue(m_content_language));
    }
    if (m_content_type_isSet) {
        obj.insert(QString("contentType"), ::OpenAPI::toJsonValue(m_content_type));
    }
    if (m_crc32c_isSet) {
        obj.insert(QString("crc32c"), ::OpenAPI::toJsonValue(m_crc32c));
    }
    if (m_etag_isSet) {
        obj.insert(QString("etag"), ::OpenAPI::toJsonValue(m_etag));
    }
    if (m_generation_isSet) {
        obj.insert(QString("generation"), ::OpenAPI::toJsonValue(m_generation));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_kind_isSet) {
        obj.insert(QString("kind"), ::OpenAPI::toJsonValue(m_kind));
    }
    if (m_md5_hash_isSet) {
        obj.insert(QString("md5Hash"), ::OpenAPI::toJsonValue(m_md5_hash));
    }
    if (m_media_link_isSet) {
        obj.insert(QString("mediaLink"), ::OpenAPI::toJsonValue(m_media_link));
    }
    if (m_metadata.size() > 0) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_metageneration_isSet) {
        obj.insert(QString("metageneration"), ::OpenAPI::toJsonValue(m_metageneration));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_owner.isSet()) {
        obj.insert(QString("owner"), ::OpenAPI::toJsonValue(m_owner));
    }
    if (m_self_link_isSet) {
        obj.insert(QString("selfLink"), ::OpenAPI::toJsonValue(m_self_link));
    }
    if (m_size_isSet) {
        obj.insert(QString("size"), ::OpenAPI::toJsonValue(m_size));
    }
    if (m_storage_class_isSet) {
        obj.insert(QString("storageClass"), ::OpenAPI::toJsonValue(m_storage_class));
    }
    if (m_time_deleted_isSet) {
        obj.insert(QString("timeDeleted"), ::OpenAPI::toJsonValue(m_time_deleted));
    }
    if (m_updated_isSet) {
        obj.insert(QString("updated"), ::OpenAPI::toJsonValue(m_updated));
    }
    return obj;
}

QList<OAIObjectAccessControl> OAIObject::getAcl() const {
    return m_acl;
}
void OAIObject::setAcl(const QList<OAIObjectAccessControl> &acl) {
    m_acl = acl;
    m_acl_isSet = true;
}

bool OAIObject::is_acl_Set() const{
    return m_acl_isSet;
}

bool OAIObject::is_acl_Valid() const{
    return m_acl_isValid;
}

QString OAIObject::getBucket() const {
    return m_bucket;
}
void OAIObject::setBucket(const QString &bucket) {
    m_bucket = bucket;
    m_bucket_isSet = true;
}

bool OAIObject::is_bucket_Set() const{
    return m_bucket_isSet;
}

bool OAIObject::is_bucket_Valid() const{
    return m_bucket_isValid;
}

QString OAIObject::getCacheControl() const {
    return m_cache_control;
}
void OAIObject::setCacheControl(const QString &cache_control) {
    m_cache_control = cache_control;
    m_cache_control_isSet = true;
}

bool OAIObject::is_cache_control_Set() const{
    return m_cache_control_isSet;
}

bool OAIObject::is_cache_control_Valid() const{
    return m_cache_control_isValid;
}

qint32 OAIObject::getComponentCount() const {
    return m_component_count;
}
void OAIObject::setComponentCount(const qint32 &component_count) {
    m_component_count = component_count;
    m_component_count_isSet = true;
}

bool OAIObject::is_component_count_Set() const{
    return m_component_count_isSet;
}

bool OAIObject::is_component_count_Valid() const{
    return m_component_count_isValid;
}

QString OAIObject::getContentDisposition() const {
    return m_content_disposition;
}
void OAIObject::setContentDisposition(const QString &content_disposition) {
    m_content_disposition = content_disposition;
    m_content_disposition_isSet = true;
}

bool OAIObject::is_content_disposition_Set() const{
    return m_content_disposition_isSet;
}

bool OAIObject::is_content_disposition_Valid() const{
    return m_content_disposition_isValid;
}

QString OAIObject::getContentEncoding() const {
    return m_content_encoding;
}
void OAIObject::setContentEncoding(const QString &content_encoding) {
    m_content_encoding = content_encoding;
    m_content_encoding_isSet = true;
}

bool OAIObject::is_content_encoding_Set() const{
    return m_content_encoding_isSet;
}

bool OAIObject::is_content_encoding_Valid() const{
    return m_content_encoding_isValid;
}

QString OAIObject::getContentLanguage() const {
    return m_content_language;
}
void OAIObject::setContentLanguage(const QString &content_language) {
    m_content_language = content_language;
    m_content_language_isSet = true;
}

bool OAIObject::is_content_language_Set() const{
    return m_content_language_isSet;
}

bool OAIObject::is_content_language_Valid() const{
    return m_content_language_isValid;
}

QString OAIObject::getContentType() const {
    return m_content_type;
}
void OAIObject::setContentType(const QString &content_type) {
    m_content_type = content_type;
    m_content_type_isSet = true;
}

bool OAIObject::is_content_type_Set() const{
    return m_content_type_isSet;
}

bool OAIObject::is_content_type_Valid() const{
    return m_content_type_isValid;
}

QString OAIObject::getCrc32c() const {
    return m_crc32c;
}
void OAIObject::setCrc32c(const QString &crc32c) {
    m_crc32c = crc32c;
    m_crc32c_isSet = true;
}

bool OAIObject::is_crc32c_Set() const{
    return m_crc32c_isSet;
}

bool OAIObject::is_crc32c_Valid() const{
    return m_crc32c_isValid;
}

QString OAIObject::getEtag() const {
    return m_etag;
}
void OAIObject::setEtag(const QString &etag) {
    m_etag = etag;
    m_etag_isSet = true;
}

bool OAIObject::is_etag_Set() const{
    return m_etag_isSet;
}

bool OAIObject::is_etag_Valid() const{
    return m_etag_isValid;
}

QString OAIObject::getGeneration() const {
    return m_generation;
}
void OAIObject::setGeneration(const QString &generation) {
    m_generation = generation;
    m_generation_isSet = true;
}

bool OAIObject::is_generation_Set() const{
    return m_generation_isSet;
}

bool OAIObject::is_generation_Valid() const{
    return m_generation_isValid;
}

QString OAIObject::getId() const {
    return m_id;
}
void OAIObject::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIObject::is_id_Set() const{
    return m_id_isSet;
}

bool OAIObject::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIObject::getKind() const {
    return m_kind;
}
void OAIObject::setKind(const QString &kind) {
    m_kind = kind;
    m_kind_isSet = true;
}

bool OAIObject::is_kind_Set() const{
    return m_kind_isSet;
}

bool OAIObject::is_kind_Valid() const{
    return m_kind_isValid;
}

QString OAIObject::getMd5Hash() const {
    return m_md5_hash;
}
void OAIObject::setMd5Hash(const QString &md5_hash) {
    m_md5_hash = md5_hash;
    m_md5_hash_isSet = true;
}

bool OAIObject::is_md5_hash_Set() const{
    return m_md5_hash_isSet;
}

bool OAIObject::is_md5_hash_Valid() const{
    return m_md5_hash_isValid;
}

QString OAIObject::getMediaLink() const {
    return m_media_link;
}
void OAIObject::setMediaLink(const QString &media_link) {
    m_media_link = media_link;
    m_media_link_isSet = true;
}

bool OAIObject::is_media_link_Set() const{
    return m_media_link_isSet;
}

bool OAIObject::is_media_link_Valid() const{
    return m_media_link_isValid;
}

QMap<QString, QString> OAIObject::getMetadata() const {
    return m_metadata;
}
void OAIObject::setMetadata(const QMap<QString, QString> &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAIObject::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAIObject::is_metadata_Valid() const{
    return m_metadata_isValid;
}

QString OAIObject::getMetageneration() const {
    return m_metageneration;
}
void OAIObject::setMetageneration(const QString &metageneration) {
    m_metageneration = metageneration;
    m_metageneration_isSet = true;
}

bool OAIObject::is_metageneration_Set() const{
    return m_metageneration_isSet;
}

bool OAIObject::is_metageneration_Valid() const{
    return m_metageneration_isValid;
}

QString OAIObject::getName() const {
    return m_name;
}
void OAIObject::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIObject::is_name_Set() const{
    return m_name_isSet;
}

bool OAIObject::is_name_Valid() const{
    return m_name_isValid;
}

OAIObject_owner OAIObject::getOwner() const {
    return m_owner;
}
void OAIObject::setOwner(const OAIObject_owner &owner) {
    m_owner = owner;
    m_owner_isSet = true;
}

bool OAIObject::is_owner_Set() const{
    return m_owner_isSet;
}

bool OAIObject::is_owner_Valid() const{
    return m_owner_isValid;
}

QString OAIObject::getSelfLink() const {
    return m_self_link;
}
void OAIObject::setSelfLink(const QString &self_link) {
    m_self_link = self_link;
    m_self_link_isSet = true;
}

bool OAIObject::is_self_link_Set() const{
    return m_self_link_isSet;
}

bool OAIObject::is_self_link_Valid() const{
    return m_self_link_isValid;
}

QString OAIObject::getSize() const {
    return m_size;
}
void OAIObject::setSize(const QString &size) {
    m_size = size;
    m_size_isSet = true;
}

bool OAIObject::is_size_Set() const{
    return m_size_isSet;
}

bool OAIObject::is_size_Valid() const{
    return m_size_isValid;
}

QString OAIObject::getStorageClass() const {
    return m_storage_class;
}
void OAIObject::setStorageClass(const QString &storage_class) {
    m_storage_class = storage_class;
    m_storage_class_isSet = true;
}

bool OAIObject::is_storage_class_Set() const{
    return m_storage_class_isSet;
}

bool OAIObject::is_storage_class_Valid() const{
    return m_storage_class_isValid;
}

QDateTime OAIObject::getTimeDeleted() const {
    return m_time_deleted;
}
void OAIObject::setTimeDeleted(const QDateTime &time_deleted) {
    m_time_deleted = time_deleted;
    m_time_deleted_isSet = true;
}

bool OAIObject::is_time_deleted_Set() const{
    return m_time_deleted_isSet;
}

bool OAIObject::is_time_deleted_Valid() const{
    return m_time_deleted_isValid;
}

QDateTime OAIObject::getUpdated() const {
    return m_updated;
}
void OAIObject::setUpdated(const QDateTime &updated) {
    m_updated = updated;
    m_updated_isSet = true;
}

bool OAIObject::is_updated_Set() const{
    return m_updated_isSet;
}

bool OAIObject::is_updated_Valid() const{
    return m_updated_isValid;
}

bool OAIObject::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_acl.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache_control_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_component_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_disposition_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_encoding_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_language_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_crc32c_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_etag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_generation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_md5_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_link_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_metageneration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_owner.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_self_link_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_storage_class_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_deleted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIObject::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
