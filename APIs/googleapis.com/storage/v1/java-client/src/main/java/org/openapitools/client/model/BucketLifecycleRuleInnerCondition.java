/*
 * Cloud Storage JSON API
 * Stores and retrieves potentially large, immutable data objects.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The condition(s) under which the action will be taken.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:17.242430-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BucketLifecycleRuleInnerCondition {
  public static final String SERIALIZED_NAME_AGE = "age";
  @SerializedName(SERIALIZED_NAME_AGE)
  private Integer age;

  public static final String SERIALIZED_NAME_CREATED_BEFORE = "createdBefore";
  @SerializedName(SERIALIZED_NAME_CREATED_BEFORE)
  private LocalDate createdBefore;

  public static final String SERIALIZED_NAME_CUSTOM_TIME_BEFORE = "customTimeBefore";
  @SerializedName(SERIALIZED_NAME_CUSTOM_TIME_BEFORE)
  private LocalDate customTimeBefore;

  public static final String SERIALIZED_NAME_DAYS_SINCE_CUSTOM_TIME = "daysSinceCustomTime";
  @SerializedName(SERIALIZED_NAME_DAYS_SINCE_CUSTOM_TIME)
  private Integer daysSinceCustomTime;

  public static final String SERIALIZED_NAME_DAYS_SINCE_NONCURRENT_TIME = "daysSinceNoncurrentTime";
  @SerializedName(SERIALIZED_NAME_DAYS_SINCE_NONCURRENT_TIME)
  private Integer daysSinceNoncurrentTime;

  public static final String SERIALIZED_NAME_IS_LIVE = "isLive";
  @SerializedName(SERIALIZED_NAME_IS_LIVE)
  private Boolean isLive;

  public static final String SERIALIZED_NAME_MATCHES_PATTERN = "matchesPattern";
  @SerializedName(SERIALIZED_NAME_MATCHES_PATTERN)
  private String matchesPattern;

  public static final String SERIALIZED_NAME_MATCHES_PREFIX = "matchesPrefix";
  @SerializedName(SERIALIZED_NAME_MATCHES_PREFIX)
  private List<String> matchesPrefix = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCHES_STORAGE_CLASS = "matchesStorageClass";
  @SerializedName(SERIALIZED_NAME_MATCHES_STORAGE_CLASS)
  private List<String> matchesStorageClass = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCHES_SUFFIX = "matchesSuffix";
  @SerializedName(SERIALIZED_NAME_MATCHES_SUFFIX)
  private List<String> matchesSuffix = new ArrayList<>();

  public static final String SERIALIZED_NAME_NONCURRENT_TIME_BEFORE = "noncurrentTimeBefore";
  @SerializedName(SERIALIZED_NAME_NONCURRENT_TIME_BEFORE)
  private LocalDate noncurrentTimeBefore;

  public static final String SERIALIZED_NAME_NUM_NEWER_VERSIONS = "numNewerVersions";
  @SerializedName(SERIALIZED_NAME_NUM_NEWER_VERSIONS)
  private Integer numNewerVersions;

  public BucketLifecycleRuleInnerCondition() {
  }

  public BucketLifecycleRuleInnerCondition age(Integer age) {
    this.age = age;
    return this;
  }

  /**
   * Age of an object (in days). This condition is satisfied when an object reaches the specified age.
   * @return age
   */
  @javax.annotation.Nullable
  public Integer getAge() {
    return age;
  }

  public void setAge(Integer age) {
    this.age = age;
  }


  public BucketLifecycleRuleInnerCondition createdBefore(LocalDate createdBefore) {
    this.createdBefore = createdBefore;
    return this;
  }

  /**
   * A date in RFC 3339 format with only the date part (for instance, \&quot;2013-01-15\&quot;). This condition is satisfied when an object is created before midnight of the specified date in UTC.
   * @return createdBefore
   */
  @javax.annotation.Nullable
  public LocalDate getCreatedBefore() {
    return createdBefore;
  }

  public void setCreatedBefore(LocalDate createdBefore) {
    this.createdBefore = createdBefore;
  }


  public BucketLifecycleRuleInnerCondition customTimeBefore(LocalDate customTimeBefore) {
    this.customTimeBefore = customTimeBefore;
    return this;
  }

  /**
   * A date in RFC 3339 format with only the date part (for instance, \&quot;2013-01-15\&quot;). This condition is satisfied when the custom time on an object is before this date in UTC.
   * @return customTimeBefore
   */
  @javax.annotation.Nullable
  public LocalDate getCustomTimeBefore() {
    return customTimeBefore;
  }

  public void setCustomTimeBefore(LocalDate customTimeBefore) {
    this.customTimeBefore = customTimeBefore;
  }


  public BucketLifecycleRuleInnerCondition daysSinceCustomTime(Integer daysSinceCustomTime) {
    this.daysSinceCustomTime = daysSinceCustomTime;
    return this;
  }

  /**
   * Number of days elapsed since the user-specified timestamp set on an object. The condition is satisfied if the days elapsed is at least this number. If no custom timestamp is specified on an object, the condition does not apply.
   * @return daysSinceCustomTime
   */
  @javax.annotation.Nullable
  public Integer getDaysSinceCustomTime() {
    return daysSinceCustomTime;
  }

  public void setDaysSinceCustomTime(Integer daysSinceCustomTime) {
    this.daysSinceCustomTime = daysSinceCustomTime;
  }


  public BucketLifecycleRuleInnerCondition daysSinceNoncurrentTime(Integer daysSinceNoncurrentTime) {
    this.daysSinceNoncurrentTime = daysSinceNoncurrentTime;
    return this;
  }

  /**
   * Number of days elapsed since the noncurrent timestamp of an object. The condition is satisfied if the days elapsed is at least this number. This condition is relevant only for versioned objects. The value of the field must be a nonnegative integer. If it&#39;s zero, the object version will become eligible for Lifecycle action as soon as it becomes noncurrent.
   * @return daysSinceNoncurrentTime
   */
  @javax.annotation.Nullable
  public Integer getDaysSinceNoncurrentTime() {
    return daysSinceNoncurrentTime;
  }

  public void setDaysSinceNoncurrentTime(Integer daysSinceNoncurrentTime) {
    this.daysSinceNoncurrentTime = daysSinceNoncurrentTime;
  }


  public BucketLifecycleRuleInnerCondition isLive(Boolean isLive) {
    this.isLive = isLive;
    return this;
  }

  /**
   * Relevant only for versioned objects. If the value is true, this condition matches live objects; if the value is false, it matches archived objects.
   * @return isLive
   */
  @javax.annotation.Nullable
  public Boolean getIsLive() {
    return isLive;
  }

  public void setIsLive(Boolean isLive) {
    this.isLive = isLive;
  }


  public BucketLifecycleRuleInnerCondition matchesPattern(String matchesPattern) {
    this.matchesPattern = matchesPattern;
    return this;
  }

  /**
   * A regular expression that satisfies the RE2 syntax. This condition is satisfied when the name of the object matches the RE2 pattern. Note: This feature is currently in the \&quot;Early Access\&quot; launch stage and is only available to a whitelisted set of users; that means that this feature may be changed in backward-incompatible ways and that it is not guaranteed to be released.
   * @return matchesPattern
   */
  @javax.annotation.Nullable
  public String getMatchesPattern() {
    return matchesPattern;
  }

  public void setMatchesPattern(String matchesPattern) {
    this.matchesPattern = matchesPattern;
  }


  public BucketLifecycleRuleInnerCondition matchesPrefix(List<String> matchesPrefix) {
    this.matchesPrefix = matchesPrefix;
    return this;
  }

  public BucketLifecycleRuleInnerCondition addMatchesPrefixItem(String matchesPrefixItem) {
    if (this.matchesPrefix == null) {
      this.matchesPrefix = new ArrayList<>();
    }
    this.matchesPrefix.add(matchesPrefixItem);
    return this;
  }

  /**
   * List of object name prefixes. This condition will be satisfied when at least one of the prefixes exactly matches the beginning of the object name.
   * @return matchesPrefix
   */
  @javax.annotation.Nullable
  public List<String> getMatchesPrefix() {
    return matchesPrefix;
  }

  public void setMatchesPrefix(List<String> matchesPrefix) {
    this.matchesPrefix = matchesPrefix;
  }


  public BucketLifecycleRuleInnerCondition matchesStorageClass(List<String> matchesStorageClass) {
    this.matchesStorageClass = matchesStorageClass;
    return this;
  }

  public BucketLifecycleRuleInnerCondition addMatchesStorageClassItem(String matchesStorageClassItem) {
    if (this.matchesStorageClass == null) {
      this.matchesStorageClass = new ArrayList<>();
    }
    this.matchesStorageClass.add(matchesStorageClassItem);
    return this;
  }

  /**
   * Objects having any of the storage classes specified by this condition will be matched. Values include MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, STANDARD, and DURABLE_REDUCED_AVAILABILITY.
   * @return matchesStorageClass
   */
  @javax.annotation.Nullable
  public List<String> getMatchesStorageClass() {
    return matchesStorageClass;
  }

  public void setMatchesStorageClass(List<String> matchesStorageClass) {
    this.matchesStorageClass = matchesStorageClass;
  }


  public BucketLifecycleRuleInnerCondition matchesSuffix(List<String> matchesSuffix) {
    this.matchesSuffix = matchesSuffix;
    return this;
  }

  public BucketLifecycleRuleInnerCondition addMatchesSuffixItem(String matchesSuffixItem) {
    if (this.matchesSuffix == null) {
      this.matchesSuffix = new ArrayList<>();
    }
    this.matchesSuffix.add(matchesSuffixItem);
    return this;
  }

  /**
   * List of object name suffixes. This condition will be satisfied when at least one of the suffixes exactly matches the end of the object name.
   * @return matchesSuffix
   */
  @javax.annotation.Nullable
  public List<String> getMatchesSuffix() {
    return matchesSuffix;
  }

  public void setMatchesSuffix(List<String> matchesSuffix) {
    this.matchesSuffix = matchesSuffix;
  }


  public BucketLifecycleRuleInnerCondition noncurrentTimeBefore(LocalDate noncurrentTimeBefore) {
    this.noncurrentTimeBefore = noncurrentTimeBefore;
    return this;
  }

  /**
   * A date in RFC 3339 format with only the date part (for instance, \&quot;2013-01-15\&quot;). This condition is satisfied when the noncurrent time on an object is before this date in UTC. This condition is relevant only for versioned objects.
   * @return noncurrentTimeBefore
   */
  @javax.annotation.Nullable
  public LocalDate getNoncurrentTimeBefore() {
    return noncurrentTimeBefore;
  }

  public void setNoncurrentTimeBefore(LocalDate noncurrentTimeBefore) {
    this.noncurrentTimeBefore = noncurrentTimeBefore;
  }


  public BucketLifecycleRuleInnerCondition numNewerVersions(Integer numNewerVersions) {
    this.numNewerVersions = numNewerVersions;
    return this;
  }

  /**
   * Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.
   * @return numNewerVersions
   */
  @javax.annotation.Nullable
  public Integer getNumNewerVersions() {
    return numNewerVersions;
  }

  public void setNumNewerVersions(Integer numNewerVersions) {
    this.numNewerVersions = numNewerVersions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BucketLifecycleRuleInnerCondition bucketLifecycleRuleInnerCondition = (BucketLifecycleRuleInnerCondition) o;
    return Objects.equals(this.age, bucketLifecycleRuleInnerCondition.age) &&
        Objects.equals(this.createdBefore, bucketLifecycleRuleInnerCondition.createdBefore) &&
        Objects.equals(this.customTimeBefore, bucketLifecycleRuleInnerCondition.customTimeBefore) &&
        Objects.equals(this.daysSinceCustomTime, bucketLifecycleRuleInnerCondition.daysSinceCustomTime) &&
        Objects.equals(this.daysSinceNoncurrentTime, bucketLifecycleRuleInnerCondition.daysSinceNoncurrentTime) &&
        Objects.equals(this.isLive, bucketLifecycleRuleInnerCondition.isLive) &&
        Objects.equals(this.matchesPattern, bucketLifecycleRuleInnerCondition.matchesPattern) &&
        Objects.equals(this.matchesPrefix, bucketLifecycleRuleInnerCondition.matchesPrefix) &&
        Objects.equals(this.matchesStorageClass, bucketLifecycleRuleInnerCondition.matchesStorageClass) &&
        Objects.equals(this.matchesSuffix, bucketLifecycleRuleInnerCondition.matchesSuffix) &&
        Objects.equals(this.noncurrentTimeBefore, bucketLifecycleRuleInnerCondition.noncurrentTimeBefore) &&
        Objects.equals(this.numNewerVersions, bucketLifecycleRuleInnerCondition.numNewerVersions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(age, createdBefore, customTimeBefore, daysSinceCustomTime, daysSinceNoncurrentTime, isLive, matchesPattern, matchesPrefix, matchesStorageClass, matchesSuffix, noncurrentTimeBefore, numNewerVersions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BucketLifecycleRuleInnerCondition {\n");
    sb.append("    age: ").append(toIndentedString(age)).append("\n");
    sb.append("    createdBefore: ").append(toIndentedString(createdBefore)).append("\n");
    sb.append("    customTimeBefore: ").append(toIndentedString(customTimeBefore)).append("\n");
    sb.append("    daysSinceCustomTime: ").append(toIndentedString(daysSinceCustomTime)).append("\n");
    sb.append("    daysSinceNoncurrentTime: ").append(toIndentedString(daysSinceNoncurrentTime)).append("\n");
    sb.append("    isLive: ").append(toIndentedString(isLive)).append("\n");
    sb.append("    matchesPattern: ").append(toIndentedString(matchesPattern)).append("\n");
    sb.append("    matchesPrefix: ").append(toIndentedString(matchesPrefix)).append("\n");
    sb.append("    matchesStorageClass: ").append(toIndentedString(matchesStorageClass)).append("\n");
    sb.append("    matchesSuffix: ").append(toIndentedString(matchesSuffix)).append("\n");
    sb.append("    noncurrentTimeBefore: ").append(toIndentedString(noncurrentTimeBefore)).append("\n");
    sb.append("    numNewerVersions: ").append(toIndentedString(numNewerVersions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("age");
    openapiFields.add("createdBefore");
    openapiFields.add("customTimeBefore");
    openapiFields.add("daysSinceCustomTime");
    openapiFields.add("daysSinceNoncurrentTime");
    openapiFields.add("isLive");
    openapiFields.add("matchesPattern");
    openapiFields.add("matchesPrefix");
    openapiFields.add("matchesStorageClass");
    openapiFields.add("matchesSuffix");
    openapiFields.add("noncurrentTimeBefore");
    openapiFields.add("numNewerVersions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BucketLifecycleRuleInnerCondition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BucketLifecycleRuleInnerCondition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BucketLifecycleRuleInnerCondition is not found in the empty JSON string", BucketLifecycleRuleInnerCondition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BucketLifecycleRuleInnerCondition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BucketLifecycleRuleInnerCondition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("matchesPattern") != null && !jsonObj.get("matchesPattern").isJsonNull()) && !jsonObj.get("matchesPattern").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchesPattern` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchesPattern").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("matchesPrefix") != null && !jsonObj.get("matchesPrefix").isJsonNull() && !jsonObj.get("matchesPrefix").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchesPrefix` to be an array in the JSON string but got `%s`", jsonObj.get("matchesPrefix").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("matchesStorageClass") != null && !jsonObj.get("matchesStorageClass").isJsonNull() && !jsonObj.get("matchesStorageClass").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchesStorageClass` to be an array in the JSON string but got `%s`", jsonObj.get("matchesStorageClass").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("matchesSuffix") != null && !jsonObj.get("matchesSuffix").isJsonNull() && !jsonObj.get("matchesSuffix").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchesSuffix` to be an array in the JSON string but got `%s`", jsonObj.get("matchesSuffix").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BucketLifecycleRuleInnerCondition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BucketLifecycleRuleInnerCondition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BucketLifecycleRuleInnerCondition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BucketLifecycleRuleInnerCondition.class));

       return (TypeAdapter<T>) new TypeAdapter<BucketLifecycleRuleInnerCondition>() {
           @Override
           public void write(JsonWriter out, BucketLifecycleRuleInnerCondition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BucketLifecycleRuleInnerCondition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BucketLifecycleRuleInnerCondition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BucketLifecycleRuleInnerCondition
   * @throws IOException if the JSON string is invalid with respect to BucketLifecycleRuleInnerCondition
   */
  public static BucketLifecycleRuleInnerCondition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BucketLifecycleRuleInnerCondition.class);
  }

  /**
   * Convert an instance of BucketLifecycleRuleInnerCondition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

