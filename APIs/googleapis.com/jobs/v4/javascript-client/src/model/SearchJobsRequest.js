/**
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CustomRankingInfo from './CustomRankingInfo';
import HistogramQuery from './HistogramQuery';
import JobQuery from './JobQuery';
import RequestMetadata from './RequestMetadata';

/**
 * The SearchJobsRequest model module.
 * @module model/SearchJobsRequest
 * @version v4
 */
class SearchJobsRequest {
    /**
     * Constructs a new <code>SearchJobsRequest</code>.
     * The Request body of the &#x60;SearchJobs&#x60; call.
     * @alias module:model/SearchJobsRequest
     */
    constructor() { 
        
        SearchJobsRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>SearchJobsRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/SearchJobsRequest} obj Optional instance to populate.
     * @return {module:model/SearchJobsRequest} The populated <code>SearchJobsRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new SearchJobsRequest();

            if (data.hasOwnProperty('customRankingInfo')) {
                obj['customRankingInfo'] = CustomRankingInfo.constructFromObject(data['customRankingInfo']);
            }
            if (data.hasOwnProperty('disableKeywordMatch')) {
                obj['disableKeywordMatch'] = ApiClient.convertToType(data['disableKeywordMatch'], 'Boolean');
            }
            if (data.hasOwnProperty('diversificationLevel')) {
                obj['diversificationLevel'] = ApiClient.convertToType(data['diversificationLevel'], 'String');
            }
            if (data.hasOwnProperty('enableBroadening')) {
                obj['enableBroadening'] = ApiClient.convertToType(data['enableBroadening'], 'Boolean');
            }
            if (data.hasOwnProperty('histogramQueries')) {
                obj['histogramQueries'] = ApiClient.convertToType(data['histogramQueries'], [HistogramQuery]);
            }
            if (data.hasOwnProperty('jobQuery')) {
                obj['jobQuery'] = JobQuery.constructFromObject(data['jobQuery']);
            }
            if (data.hasOwnProperty('jobView')) {
                obj['jobView'] = ApiClient.convertToType(data['jobView'], 'String');
            }
            if (data.hasOwnProperty('keywordMatchMode')) {
                obj['keywordMatchMode'] = ApiClient.convertToType(data['keywordMatchMode'], 'String');
            }
            if (data.hasOwnProperty('maxPageSize')) {
                obj['maxPageSize'] = ApiClient.convertToType(data['maxPageSize'], 'Number');
            }
            if (data.hasOwnProperty('offset')) {
                obj['offset'] = ApiClient.convertToType(data['offset'], 'Number');
            }
            if (data.hasOwnProperty('orderBy')) {
                obj['orderBy'] = ApiClient.convertToType(data['orderBy'], 'String');
            }
            if (data.hasOwnProperty('pageToken')) {
                obj['pageToken'] = ApiClient.convertToType(data['pageToken'], 'String');
            }
            if (data.hasOwnProperty('requestMetadata')) {
                obj['requestMetadata'] = RequestMetadata.constructFromObject(data['requestMetadata']);
            }
            if (data.hasOwnProperty('searchMode')) {
                obj['searchMode'] = ApiClient.convertToType(data['searchMode'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>SearchJobsRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>SearchJobsRequest</code>.
     */
    static validateJSON(data) {
        // validate the optional field `customRankingInfo`
        if (data['customRankingInfo']) { // data not null
          CustomRankingInfo.validateJSON(data['customRankingInfo']);
        }
        // ensure the json data is a string
        if (data['diversificationLevel'] && !(typeof data['diversificationLevel'] === 'string' || data['diversificationLevel'] instanceof String)) {
            throw new Error("Expected the field `diversificationLevel` to be a primitive type in the JSON string but got " + data['diversificationLevel']);
        }
        if (data['histogramQueries']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['histogramQueries'])) {
                throw new Error("Expected the field `histogramQueries` to be an array in the JSON data but got " + data['histogramQueries']);
            }
            // validate the optional field `histogramQueries` (array)
            for (const item of data['histogramQueries']) {
                HistogramQuery.validateJSON(item);
            };
        }
        // validate the optional field `jobQuery`
        if (data['jobQuery']) { // data not null
          JobQuery.validateJSON(data['jobQuery']);
        }
        // ensure the json data is a string
        if (data['jobView'] && !(typeof data['jobView'] === 'string' || data['jobView'] instanceof String)) {
            throw new Error("Expected the field `jobView` to be a primitive type in the JSON string but got " + data['jobView']);
        }
        // ensure the json data is a string
        if (data['keywordMatchMode'] && !(typeof data['keywordMatchMode'] === 'string' || data['keywordMatchMode'] instanceof String)) {
            throw new Error("Expected the field `keywordMatchMode` to be a primitive type in the JSON string but got " + data['keywordMatchMode']);
        }
        // ensure the json data is a string
        if (data['orderBy'] && !(typeof data['orderBy'] === 'string' || data['orderBy'] instanceof String)) {
            throw new Error("Expected the field `orderBy` to be a primitive type in the JSON string but got " + data['orderBy']);
        }
        // ensure the json data is a string
        if (data['pageToken'] && !(typeof data['pageToken'] === 'string' || data['pageToken'] instanceof String)) {
            throw new Error("Expected the field `pageToken` to be a primitive type in the JSON string but got " + data['pageToken']);
        }
        // validate the optional field `requestMetadata`
        if (data['requestMetadata']) { // data not null
          RequestMetadata.validateJSON(data['requestMetadata']);
        }
        // ensure the json data is a string
        if (data['searchMode'] && !(typeof data['searchMode'] === 'string' || data['searchMode'] instanceof String)) {
            throw new Error("Expected the field `searchMode` to be a primitive type in the JSON string but got " + data['searchMode']);
        }

        return true;
    }


}



/**
 * @member {module:model/CustomRankingInfo} customRankingInfo
 */
SearchJobsRequest.prototype['customRankingInfo'] = undefined;

/**
 * This field is deprecated. Please use SearchJobsRequest.keyword_match_mode going forward. To migrate, disable_keyword_match set to false maps to KeywordMatchMode.KEYWORD_MATCH_ALL, and disable_keyword_match set to true maps to KeywordMatchMode.KEYWORD_MATCH_DISABLED. If SearchJobsRequest.keyword_match_mode is set, this field is ignored. Controls whether to disable exact keyword match on Job.title, Job.description, Job.company_display_name, Job.addresses, Job.qualifications. When disable keyword match is turned off, a keyword match returns jobs that do not match given category filters when there are matching keywords. For example, for the query \"program manager,\" a result is returned even if the job posting has the title \"software developer,\" which doesn't fall into \"program manager\" ontology, but does have \"program manager\" appearing in its description. For queries like \"cloud\" that don't contain title or location specific ontology, jobs with \"cloud\" keyword matches are returned regardless of this flag's value. Use Company.keyword_searchable_job_custom_attributes if company-specific globally matched custom field/attribute string values are needed. Enabling keyword match improves recall of subsequent search requests. Defaults to false.
 * @member {Boolean} disableKeywordMatch
 */
SearchJobsRequest.prototype['disableKeywordMatch'] = undefined;

/**
 * Controls whether highly similar jobs are returned next to each other in the search results. Jobs are identified as highly similar based on their titles, job categories, and locations. Highly similar results are clustered so that only one representative job of the cluster is displayed to the job seeker higher up in the results, with the other jobs being displayed lower down in the results. Defaults to DiversificationLevel.SIMPLE if no value is specified.
 * @member {module:model/SearchJobsRequest.DiversificationLevelEnum} diversificationLevel
 */
SearchJobsRequest.prototype['diversificationLevel'] = undefined;

/**
 * Controls whether to broaden the search when it produces sparse results. Broadened queries append results to the end of the matching results list. Defaults to false.
 * @member {Boolean} enableBroadening
 */
SearchJobsRequest.prototype['enableBroadening'] = undefined;

/**
 * An expression specifies a histogram request against matching jobs. Expression syntax is an aggregation function call with histogram facets and other options. Available aggregation function calls are: * `count(string_histogram_facet)`: Count the number of matching entities, for each distinct attribute value. * `count(numeric_histogram_facet, list of buckets)`: Count the number of matching entities within each bucket. A maximum of 200 histogram buckets are supported. Data types: * Histogram facet: facet names with format `a-zA-Z+`. * String: string like \"any string with backslash escape for quote(\\\").\" * Number: whole number and floating point number like 10, -1 and -0.01. * List: list of elements with comma(,) separator surrounded by square brackets, for example, [1, 2, 3] and [\"one\", \"two\", \"three\"]. Built-in constants: * MIN (minimum number similar to java Double.MIN_VALUE) * MAX (maximum number similar to java Double.MAX_VALUE) Built-in functions: * bucket(start, end[, label]): bucket built-in function creates a bucket with range of start, end). Note that the end is exclusive, for example, bucket(1, MAX, \"positive number\") or bucket(1, 10). Job histogram facets: * company_display_name: histogram by [Job.company_display_name. * employment_type: histogram by Job.employment_types, for example, \"FULL_TIME\", \"PART_TIME\". * company_size (DEPRECATED): histogram by CompanySize, for example, \"SMALL\", \"MEDIUM\", \"BIG\". * publish_time_in_day: histogram by the Job.posting_publish_time in days. Must specify list of numeric buckets in spec. * publish_time_in_month: histogram by the Job.posting_publish_time in months. Must specify list of numeric buckets in spec. * publish_time_in_year: histogram by the Job.posting_publish_time in years. Must specify list of numeric buckets in spec. * degree_types: histogram by the Job.degree_types, for example, \"Bachelors\", \"Masters\". * job_level: histogram by the Job.job_level, for example, \"Entry Level\". * country: histogram by the country code of jobs, for example, \"US\", \"FR\". * admin1: histogram by the admin1 code of jobs, which is a global placeholder referring to the state, province, or the particular term a country uses to define the geographic structure below the country level, for example, \"CA\", \"IL\". * city: histogram by a combination of the \"city name, admin1 code\". For example, \"Mountain View, CA\", \"New York, NY\". * admin1_country: histogram by a combination of the \"admin1 code, country\", for example, \"CA, US\", \"IL, US\". * city_coordinate: histogram by the city center's GPS coordinates (latitude and longitude), for example, 37.4038522,-122.0987765. Since the coordinates of a city center can change, customers may need to refresh them periodically. * locale: histogram by the Job.language_code, for example, \"en-US\", \"fr-FR\". * language: histogram by the language subtag of the Job.language_code, for example, \"en\", \"fr\". * category: histogram by the JobCategory, for example, \"COMPUTER_AND_IT\", \"HEALTHCARE\". * base_compensation_unit: histogram by the CompensationInfo.CompensationUnit of base salary, for example, \"WEEKLY\", \"MONTHLY\". * base_compensation: histogram by the base salary. Must specify list of numeric buckets to group results by. * annualized_base_compensation: histogram by the base annualized salary. Must specify list of numeric buckets to group results by. * annualized_total_compensation: histogram by the total annualized salary. Must specify list of numeric buckets to group results by. * string_custom_attribute: histogram by string Job.custom_attributes. Values can be accessed via square bracket notations like string_custom_attribute[\"key1\"]. * numeric_custom_attribute: histogram by numeric Job.custom_attributes. Values can be accessed via square bracket notations like numeric_custom_attribute[\"key1\"]. Must specify list of numeric buckets to group results by. Example expressions: * `count(admin1)` * `count(base_compensation, [bucket(1000, 10000), bucket(10000, 100000), bucket(100000, MAX)])` * `count(string_custom_attribute[\"some-string-custom-attribute\"])` * `count(numeric_custom_attribute[\"some-numeric-custom-attribute\"], [bucket(MIN, 0, \"negative\"), bucket(0, MAX, \"non-negative\")])`
 * @member {Array.<module:model/HistogramQuery>} histogramQueries
 */
SearchJobsRequest.prototype['histogramQueries'] = undefined;

/**
 * @member {module:model/JobQuery} jobQuery
 */
SearchJobsRequest.prototype['jobQuery'] = undefined;

/**
 * The desired job attributes returned for jobs in the search response. Defaults to JobView.JOB_VIEW_SMALL if no value is specified.
 * @member {module:model/SearchJobsRequest.JobViewEnum} jobView
 */
SearchJobsRequest.prototype['jobView'] = undefined;

/**
 * Controls what keyword match options to use. If both keyword_match_mode and disable_keyword_match are set, keyword_match_mode will take precedence. Defaults to KeywordMatchMode.KEYWORD_MATCH_ALL if no value is specified.
 * @member {module:model/SearchJobsRequest.KeywordMatchModeEnum} keywordMatchMode
 */
SearchJobsRequest.prototype['keywordMatchMode'] = undefined;

/**
 * A limit on the number of jobs returned in the search results. Increasing this value above the default value of 10 can increase search response time. The value can be between 1 and 100.
 * @member {Number} maxPageSize
 */
SearchJobsRequest.prototype['maxPageSize'] = undefined;

/**
 * An integer that specifies the current offset (that is, starting result location, amongst the jobs deemed by the API as relevant) in search results. This field is only considered if page_token is unset. The maximum allowed value is 5000. Otherwise an error is thrown. For example, 0 means to return results starting from the first matching job, and 10 means to return from the 11th job. This can be used for pagination, (for example, pageSize = 10 and offset = 10 means to return from the second page).
 * @member {Number} offset
 */
SearchJobsRequest.prototype['offset'] = undefined;

/**
 * The criteria determining how search results are sorted. Default is `\"relevance desc\"`. Supported options are: * `\"relevance desc\"`: By relevance descending, as determined by the API algorithms. Relevance thresholding of query results is only available with this ordering. * `\"posting_publish_time desc\"`: By Job.posting_publish_time descending. * `\"posting_update_time desc\"`: By Job.posting_update_time descending. * `\"title\"`: By Job.title ascending. * `\"title desc\"`: By Job.title descending. * `\"annualized_base_compensation\"`: By job's CompensationInfo.annualized_base_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_base_compensation desc\"`: By job's CompensationInfo.annualized_base_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_total_compensation\"`: By job's CompensationInfo.annualized_total_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_total_compensation desc\"`: By job's CompensationInfo.annualized_total_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"custom_ranking desc\"`: By the relevance score adjusted to the SearchJobsRequest.CustomRankingInfo.ranking_expression with weight factor assigned by SearchJobsRequest.CustomRankingInfo.importance_level in descending order. * Location sorting: Use the special syntax to order jobs by distance: `\"distance_from('Hawaii')\"`: Order by distance from Hawaii. `\"distance_from(19.89, 155.5)\"`: Order by distance from a coordinate. `\"distance_from('Hawaii'), distance_from('Puerto Rico')\"`: Order by multiple locations. See details below. `\"distance_from('Hawaii'), distance_from(19.89, 155.5)\"`: Order by multiple locations. See details below. The string can have a maximum of 256 characters. When multiple distance centers are provided, a job that is close to any of the distance centers would have a high rank. When a job has multiple locations, the job location closest to one of the distance centers will be used. Jobs that don't have locations will be ranked at the bottom. Distance is calculated with a precision of 11.3 meters (37.4 feet). Diversification strategy is still applied unless explicitly disabled in diversification_level.
 * @member {String} orderBy
 */
SearchJobsRequest.prototype['orderBy'] = undefined;

/**
 * The token specifying the current offset within search results. See SearchJobsResponse.next_page_token for an explanation of how to obtain the next set of query results.
 * @member {String} pageToken
 */
SearchJobsRequest.prototype['pageToken'] = undefined;

/**
 * @member {module:model/RequestMetadata} requestMetadata
 */
SearchJobsRequest.prototype['requestMetadata'] = undefined;

/**
 * Mode of a search. Defaults to SearchMode.JOB_SEARCH.
 * @member {module:model/SearchJobsRequest.SearchModeEnum} searchMode
 */
SearchJobsRequest.prototype['searchMode'] = undefined;





/**
 * Allowed values for the <code>diversificationLevel</code> property.
 * @enum {String}
 * @readonly
 */
SearchJobsRequest['DiversificationLevelEnum'] = {

    /**
     * value: "DIVERSIFICATION_LEVEL_UNSPECIFIED"
     * @const
     */
    "DIVERSIFICATION_LEVEL_UNSPECIFIED": "DIVERSIFICATION_LEVEL_UNSPECIFIED",

    /**
     * value: "DISABLED"
     * @const
     */
    "DISABLED": "DISABLED",

    /**
     * value: "SIMPLE"
     * @const
     */
    "SIMPLE": "SIMPLE",

    /**
     * value: "ONE_PER_COMPANY"
     * @const
     */
    "ONE_PER_COMPANY": "ONE_PER_COMPANY",

    /**
     * value: "TWO_PER_COMPANY"
     * @const
     */
    "TWO_PER_COMPANY": "TWO_PER_COMPANY",

    /**
     * value: "MAX_THREE_PER_COMPANY"
     * @const
     */
    "MAX_THREE_PER_COMPANY": "MAX_THREE_PER_COMPANY",

    /**
     * value: "DIVERSIFY_BY_LOOSER_SIMILARITY"
     * @const
     */
    "DIVERSIFY_BY_LOOSER_SIMILARITY": "DIVERSIFY_BY_LOOSER_SIMILARITY"
};


/**
 * Allowed values for the <code>jobView</code> property.
 * @enum {String}
 * @readonly
 */
SearchJobsRequest['JobViewEnum'] = {

    /**
     * value: "JOB_VIEW_UNSPECIFIED"
     * @const
     */
    "UNSPECIFIED": "JOB_VIEW_UNSPECIFIED",

    /**
     * value: "JOB_VIEW_ID_ONLY"
     * @const
     */
    "ID_ONLY": "JOB_VIEW_ID_ONLY",

    /**
     * value: "JOB_VIEW_MINIMAL"
     * @const
     */
    "MINIMAL": "JOB_VIEW_MINIMAL",

    /**
     * value: "JOB_VIEW_SMALL"
     * @const
     */
    "SMALL": "JOB_VIEW_SMALL",

    /**
     * value: "JOB_VIEW_FULL"
     * @const
     */
    "FULL": "JOB_VIEW_FULL"
};


/**
 * Allowed values for the <code>keywordMatchMode</code> property.
 * @enum {String}
 * @readonly
 */
SearchJobsRequest['KeywordMatchModeEnum'] = {

    /**
     * value: "KEYWORD_MATCH_MODE_UNSPECIFIED"
     * @const
     */
    "MODE_UNSPECIFIED": "KEYWORD_MATCH_MODE_UNSPECIFIED",

    /**
     * value: "KEYWORD_MATCH_DISABLED"
     * @const
     */
    "DISABLED": "KEYWORD_MATCH_DISABLED",

    /**
     * value: "KEYWORD_MATCH_ALL"
     * @const
     */
    "ALL": "KEYWORD_MATCH_ALL",

    /**
     * value: "KEYWORD_MATCH_TITLE_ONLY"
     * @const
     */
    "TITLE_ONLY": "KEYWORD_MATCH_TITLE_ONLY"
};


/**
 * Allowed values for the <code>searchMode</code> property.
 * @enum {String}
 * @readonly
 */
SearchJobsRequest['SearchModeEnum'] = {

    /**
     * value: "SEARCH_MODE_UNSPECIFIED"
     * @const
     */
    "SEARCH_MODE_UNSPECIFIED": "SEARCH_MODE_UNSPECIFIED",

    /**
     * value: "JOB_SEARCH"
     * @const
     */
    "JOB_SEARCH": "JOB_SEARCH",

    /**
     * value: "FEATURED_JOB_SEARCH"
     * @const
     */
    "FEATURED_JOB_SEARCH": "FEATURED_JOB_SEARCH"
};



export default SearchJobsRequest;

