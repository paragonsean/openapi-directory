/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.HistogramQueryResult;
import org.openapitools.client.model.Location;
import org.openapitools.client.model.MatchingJob;
import org.openapitools.client.model.ResponseMetadata;
import org.openapitools.client.model.SpellingCorrection;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Response for SearchJob method.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:21.539627-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SearchJobsResponse {
  public static final String SERIALIZED_NAME_BROADENED_QUERY_JOBS_COUNT = "broadenedQueryJobsCount";
  @SerializedName(SERIALIZED_NAME_BROADENED_QUERY_JOBS_COUNT)
  private Integer broadenedQueryJobsCount;

  public static final String SERIALIZED_NAME_HISTOGRAM_QUERY_RESULTS = "histogramQueryResults";
  @SerializedName(SERIALIZED_NAME_HISTOGRAM_QUERY_RESULTS)
  private List<HistogramQueryResult> histogramQueryResults = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCATION_FILTERS = "locationFilters";
  @SerializedName(SERIALIZED_NAME_LOCATION_FILTERS)
  private List<Location> locationFilters = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCHING_JOBS = "matchingJobs";
  @SerializedName(SERIALIZED_NAME_MATCHING_JOBS)
  private List<MatchingJob> matchingJobs = new ArrayList<>();

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private ResponseMetadata metadata;

  public static final String SERIALIZED_NAME_NEXT_PAGE_TOKEN = "nextPageToken";
  @SerializedName(SERIALIZED_NAME_NEXT_PAGE_TOKEN)
  private String nextPageToken;

  public static final String SERIALIZED_NAME_SPELL_CORRECTION = "spellCorrection";
  @SerializedName(SERIALIZED_NAME_SPELL_CORRECTION)
  private SpellingCorrection spellCorrection;

  public static final String SERIALIZED_NAME_TOTAL_SIZE = "totalSize";
  @SerializedName(SERIALIZED_NAME_TOTAL_SIZE)
  private Integer totalSize;

  public SearchJobsResponse() {
  }

  public SearchJobsResponse broadenedQueryJobsCount(Integer broadenedQueryJobsCount) {
    this.broadenedQueryJobsCount = broadenedQueryJobsCount;
    return this;
  }

  /**
   * If query broadening is enabled, we may append additional results from the broadened query. This number indicates how many of the jobs returned in the jobs field are from the broadened query. These results are always at the end of the jobs list. In particular, a value of 0, or if the field isn&#39;t set, all the jobs in the jobs list are from the original (without broadening) query. If this field is non-zero, subsequent requests with offset after this result set should contain all broadened results.
   * @return broadenedQueryJobsCount
   */
  @javax.annotation.Nullable
  public Integer getBroadenedQueryJobsCount() {
    return broadenedQueryJobsCount;
  }

  public void setBroadenedQueryJobsCount(Integer broadenedQueryJobsCount) {
    this.broadenedQueryJobsCount = broadenedQueryJobsCount;
  }


  public SearchJobsResponse histogramQueryResults(List<HistogramQueryResult> histogramQueryResults) {
    this.histogramQueryResults = histogramQueryResults;
    return this;
  }

  public SearchJobsResponse addHistogramQueryResultsItem(HistogramQueryResult histogramQueryResultsItem) {
    if (this.histogramQueryResults == null) {
      this.histogramQueryResults = new ArrayList<>();
    }
    this.histogramQueryResults.add(histogramQueryResultsItem);
    return this;
  }

  /**
   * The histogram results that match with specified SearchJobsRequest.histogram_queries.
   * @return histogramQueryResults
   */
  @javax.annotation.Nullable
  public List<HistogramQueryResult> getHistogramQueryResults() {
    return histogramQueryResults;
  }

  public void setHistogramQueryResults(List<HistogramQueryResult> histogramQueryResults) {
    this.histogramQueryResults = histogramQueryResults;
  }


  public SearchJobsResponse locationFilters(List<Location> locationFilters) {
    this.locationFilters = locationFilters;
    return this;
  }

  public SearchJobsResponse addLocationFiltersItem(Location locationFiltersItem) {
    if (this.locationFilters == null) {
      this.locationFilters = new ArrayList<>();
    }
    this.locationFilters.add(locationFiltersItem);
    return this;
  }

  /**
   * The location filters that the service applied to the specified query. If any filters are lat-lng based, the Location.location_type is Location.LocationType.LOCATION_TYPE_UNSPECIFIED.
   * @return locationFilters
   */
  @javax.annotation.Nullable
  public List<Location> getLocationFilters() {
    return locationFilters;
  }

  public void setLocationFilters(List<Location> locationFilters) {
    this.locationFilters = locationFilters;
  }


  public SearchJobsResponse matchingJobs(List<MatchingJob> matchingJobs) {
    this.matchingJobs = matchingJobs;
    return this;
  }

  public SearchJobsResponse addMatchingJobsItem(MatchingJob matchingJobsItem) {
    if (this.matchingJobs == null) {
      this.matchingJobs = new ArrayList<>();
    }
    this.matchingJobs.add(matchingJobsItem);
    return this;
  }

  /**
   * The Job entities that match the specified SearchJobsRequest.
   * @return matchingJobs
   */
  @javax.annotation.Nullable
  public List<MatchingJob> getMatchingJobs() {
    return matchingJobs;
  }

  public void setMatchingJobs(List<MatchingJob> matchingJobs) {
    this.matchingJobs = matchingJobs;
  }


  public SearchJobsResponse metadata(ResponseMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  public ResponseMetadata getMetadata() {
    return metadata;
  }

  public void setMetadata(ResponseMetadata metadata) {
    this.metadata = metadata;
  }


  public SearchJobsResponse nextPageToken(String nextPageToken) {
    this.nextPageToken = nextPageToken;
    return this;
  }

  /**
   * The token that specifies the starting position of the next page of results. This field is empty if there are no more results.
   * @return nextPageToken
   */
  @javax.annotation.Nullable
  public String getNextPageToken() {
    return nextPageToken;
  }

  public void setNextPageToken(String nextPageToken) {
    this.nextPageToken = nextPageToken;
  }


  public SearchJobsResponse spellCorrection(SpellingCorrection spellCorrection) {
    this.spellCorrection = spellCorrection;
    return this;
  }

  /**
   * Get spellCorrection
   * @return spellCorrection
   */
  @javax.annotation.Nullable
  public SpellingCorrection getSpellCorrection() {
    return spellCorrection;
  }

  public void setSpellCorrection(SpellingCorrection spellCorrection) {
    this.spellCorrection = spellCorrection;
  }


  public SearchJobsResponse totalSize(Integer totalSize) {
    this.totalSize = totalSize;
    return this;
  }

  /**
   * Number of jobs that match the specified query. Note: This size is precise only if the total is less than 100,000.
   * @return totalSize
   */
  @javax.annotation.Nullable
  public Integer getTotalSize() {
    return totalSize;
  }

  public void setTotalSize(Integer totalSize) {
    this.totalSize = totalSize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchJobsResponse searchJobsResponse = (SearchJobsResponse) o;
    return Objects.equals(this.broadenedQueryJobsCount, searchJobsResponse.broadenedQueryJobsCount) &&
        Objects.equals(this.histogramQueryResults, searchJobsResponse.histogramQueryResults) &&
        Objects.equals(this.locationFilters, searchJobsResponse.locationFilters) &&
        Objects.equals(this.matchingJobs, searchJobsResponse.matchingJobs) &&
        Objects.equals(this.metadata, searchJobsResponse.metadata) &&
        Objects.equals(this.nextPageToken, searchJobsResponse.nextPageToken) &&
        Objects.equals(this.spellCorrection, searchJobsResponse.spellCorrection) &&
        Objects.equals(this.totalSize, searchJobsResponse.totalSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(broadenedQueryJobsCount, histogramQueryResults, locationFilters, matchingJobs, metadata, nextPageToken, spellCorrection, totalSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchJobsResponse {\n");
    sb.append("    broadenedQueryJobsCount: ").append(toIndentedString(broadenedQueryJobsCount)).append("\n");
    sb.append("    histogramQueryResults: ").append(toIndentedString(histogramQueryResults)).append("\n");
    sb.append("    locationFilters: ").append(toIndentedString(locationFilters)).append("\n");
    sb.append("    matchingJobs: ").append(toIndentedString(matchingJobs)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    nextPageToken: ").append(toIndentedString(nextPageToken)).append("\n");
    sb.append("    spellCorrection: ").append(toIndentedString(spellCorrection)).append("\n");
    sb.append("    totalSize: ").append(toIndentedString(totalSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("broadenedQueryJobsCount");
    openapiFields.add("histogramQueryResults");
    openapiFields.add("locationFilters");
    openapiFields.add("matchingJobs");
    openapiFields.add("metadata");
    openapiFields.add("nextPageToken");
    openapiFields.add("spellCorrection");
    openapiFields.add("totalSize");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchJobsResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SearchJobsResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchJobsResponse is not found in the empty JSON string", SearchJobsResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchJobsResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchJobsResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("histogramQueryResults") != null && !jsonObj.get("histogramQueryResults").isJsonNull()) {
        JsonArray jsonArrayhistogramQueryResults = jsonObj.getAsJsonArray("histogramQueryResults");
        if (jsonArrayhistogramQueryResults != null) {
          // ensure the json data is an array
          if (!jsonObj.get("histogramQueryResults").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `histogramQueryResults` to be an array in the JSON string but got `%s`", jsonObj.get("histogramQueryResults").toString()));
          }

          // validate the optional field `histogramQueryResults` (array)
          for (int i = 0; i < jsonArrayhistogramQueryResults.size(); i++) {
            HistogramQueryResult.validateJsonElement(jsonArrayhistogramQueryResults.get(i));
          };
        }
      }
      if (jsonObj.get("locationFilters") != null && !jsonObj.get("locationFilters").isJsonNull()) {
        JsonArray jsonArraylocationFilters = jsonObj.getAsJsonArray("locationFilters");
        if (jsonArraylocationFilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("locationFilters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `locationFilters` to be an array in the JSON string but got `%s`", jsonObj.get("locationFilters").toString()));
          }

          // validate the optional field `locationFilters` (array)
          for (int i = 0; i < jsonArraylocationFilters.size(); i++) {
            Location.validateJsonElement(jsonArraylocationFilters.get(i));
          };
        }
      }
      if (jsonObj.get("matchingJobs") != null && !jsonObj.get("matchingJobs").isJsonNull()) {
        JsonArray jsonArraymatchingJobs = jsonObj.getAsJsonArray("matchingJobs");
        if (jsonArraymatchingJobs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("matchingJobs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `matchingJobs` to be an array in the JSON string but got `%s`", jsonObj.get("matchingJobs").toString()));
          }

          // validate the optional field `matchingJobs` (array)
          for (int i = 0; i < jsonArraymatchingJobs.size(); i++) {
            MatchingJob.validateJsonElement(jsonArraymatchingJobs.get(i));
          };
        }
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        ResponseMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
      if ((jsonObj.get("nextPageToken") != null && !jsonObj.get("nextPageToken").isJsonNull()) && !jsonObj.get("nextPageToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nextPageToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nextPageToken").toString()));
      }
      // validate the optional field `spellCorrection`
      if (jsonObj.get("spellCorrection") != null && !jsonObj.get("spellCorrection").isJsonNull()) {
        SpellingCorrection.validateJsonElement(jsonObj.get("spellCorrection"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchJobsResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchJobsResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchJobsResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchJobsResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchJobsResponse>() {
           @Override
           public void write(JsonWriter out, SearchJobsResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchJobsResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchJobsResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchJobsResponse
   * @throws IOException if the JSON string is invalid with respect to SearchJobsResponse
   */
  public static SearchJobsResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchJobsResponse.class);
  }

  /**
   * Convert an instance of SearchJobsResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

