/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.LatLng;
import org.openapitools.client.model.TimeOfDay;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters needed for commute search.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:21.539627-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CommuteFilter {
  public static final String SERIALIZED_NAME_ALLOW_IMPRECISE_ADDRESSES = "allowImpreciseAddresses";
  @SerializedName(SERIALIZED_NAME_ALLOW_IMPRECISE_ADDRESSES)
  private Boolean allowImpreciseAddresses;

  /**
   * Required. The method of transportation to calculate the commute time for.
   */
  @JsonAdapter(CommuteMethodEnum.Adapter.class)
  public enum CommuteMethodEnum {
    COMMUTE_METHOD_UNSPECIFIED("COMMUTE_METHOD_UNSPECIFIED"),
    
    DRIVING("DRIVING"),
    
    TRANSIT("TRANSIT"),
    
    WALKING("WALKING"),
    
    CYCLING("CYCLING"),
    
    TRANSIT_ACCESSIBLE("TRANSIT_ACCESSIBLE");

    private String value;

    CommuteMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CommuteMethodEnum fromValue(String value) {
      for (CommuteMethodEnum b : CommuteMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CommuteMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CommuteMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CommuteMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CommuteMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CommuteMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMMUTE_METHOD = "commuteMethod";
  @SerializedName(SERIALIZED_NAME_COMMUTE_METHOD)
  private CommuteMethodEnum commuteMethod;

  public static final String SERIALIZED_NAME_DEPARTURE_TIME = "departureTime";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_TIME)
  private TimeOfDay departureTime;

  /**
   * Specifies the traffic density to use when calculating commute time.
   */
  @JsonAdapter(RoadTrafficEnum.Adapter.class)
  public enum RoadTrafficEnum {
    ROAD_TRAFFIC_UNSPECIFIED("ROAD_TRAFFIC_UNSPECIFIED"),
    
    TRAFFIC_FREE("TRAFFIC_FREE"),
    
    BUSY_HOUR("BUSY_HOUR");

    private String value;

    RoadTrafficEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RoadTrafficEnum fromValue(String value) {
      for (RoadTrafficEnum b : RoadTrafficEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RoadTrafficEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RoadTrafficEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RoadTrafficEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RoadTrafficEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RoadTrafficEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ROAD_TRAFFIC = "roadTraffic";
  @SerializedName(SERIALIZED_NAME_ROAD_TRAFFIC)
  private RoadTrafficEnum roadTraffic;

  public static final String SERIALIZED_NAME_START_COORDINATES = "startCoordinates";
  @SerializedName(SERIALIZED_NAME_START_COORDINATES)
  private LatLng startCoordinates;

  public static final String SERIALIZED_NAME_TRAVEL_DURATION = "travelDuration";
  @SerializedName(SERIALIZED_NAME_TRAVEL_DURATION)
  private String travelDuration;

  public CommuteFilter() {
  }

  public CommuteFilter allowImpreciseAddresses(Boolean allowImpreciseAddresses) {
    this.allowImpreciseAddresses = allowImpreciseAddresses;
    return this;
  }

  /**
   * If &#x60;true&#x60;, jobs without street level addresses may also be returned. For city level addresses, the city center is used. For state and coarser level addresses, text matching is used. If this field is set to &#x60;false&#x60; or isn&#39;t specified, only jobs that include street level addresses will be returned by commute search.
   * @return allowImpreciseAddresses
   */
  @javax.annotation.Nullable
  public Boolean getAllowImpreciseAddresses() {
    return allowImpreciseAddresses;
  }

  public void setAllowImpreciseAddresses(Boolean allowImpreciseAddresses) {
    this.allowImpreciseAddresses = allowImpreciseAddresses;
  }


  public CommuteFilter commuteMethod(CommuteMethodEnum commuteMethod) {
    this.commuteMethod = commuteMethod;
    return this;
  }

  /**
   * Required. The method of transportation to calculate the commute time for.
   * @return commuteMethod
   */
  @javax.annotation.Nullable
  public CommuteMethodEnum getCommuteMethod() {
    return commuteMethod;
  }

  public void setCommuteMethod(CommuteMethodEnum commuteMethod) {
    this.commuteMethod = commuteMethod;
  }


  public CommuteFilter departureTime(TimeOfDay departureTime) {
    this.departureTime = departureTime;
    return this;
  }

  /**
   * Get departureTime
   * @return departureTime
   */
  @javax.annotation.Nullable
  public TimeOfDay getDepartureTime() {
    return departureTime;
  }

  public void setDepartureTime(TimeOfDay departureTime) {
    this.departureTime = departureTime;
  }


  public CommuteFilter roadTraffic(RoadTrafficEnum roadTraffic) {
    this.roadTraffic = roadTraffic;
    return this;
  }

  /**
   * Specifies the traffic density to use when calculating commute time.
   * @return roadTraffic
   */
  @javax.annotation.Nullable
  public RoadTrafficEnum getRoadTraffic() {
    return roadTraffic;
  }

  public void setRoadTraffic(RoadTrafficEnum roadTraffic) {
    this.roadTraffic = roadTraffic;
  }


  public CommuteFilter startCoordinates(LatLng startCoordinates) {
    this.startCoordinates = startCoordinates;
    return this;
  }

  /**
   * Get startCoordinates
   * @return startCoordinates
   */
  @javax.annotation.Nullable
  public LatLng getStartCoordinates() {
    return startCoordinates;
  }

  public void setStartCoordinates(LatLng startCoordinates) {
    this.startCoordinates = startCoordinates;
  }


  public CommuteFilter travelDuration(String travelDuration) {
    this.travelDuration = travelDuration;
    return this;
  }

  /**
   * Required. The maximum travel time in seconds. The maximum allowed value is &#x60;3600s&#x60; (one hour). Format is &#x60;123s&#x60;.
   * @return travelDuration
   */
  @javax.annotation.Nullable
  public String getTravelDuration() {
    return travelDuration;
  }

  public void setTravelDuration(String travelDuration) {
    this.travelDuration = travelDuration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CommuteFilter commuteFilter = (CommuteFilter) o;
    return Objects.equals(this.allowImpreciseAddresses, commuteFilter.allowImpreciseAddresses) &&
        Objects.equals(this.commuteMethod, commuteFilter.commuteMethod) &&
        Objects.equals(this.departureTime, commuteFilter.departureTime) &&
        Objects.equals(this.roadTraffic, commuteFilter.roadTraffic) &&
        Objects.equals(this.startCoordinates, commuteFilter.startCoordinates) &&
        Objects.equals(this.travelDuration, commuteFilter.travelDuration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowImpreciseAddresses, commuteMethod, departureTime, roadTraffic, startCoordinates, travelDuration);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CommuteFilter {\n");
    sb.append("    allowImpreciseAddresses: ").append(toIndentedString(allowImpreciseAddresses)).append("\n");
    sb.append("    commuteMethod: ").append(toIndentedString(commuteMethod)).append("\n");
    sb.append("    departureTime: ").append(toIndentedString(departureTime)).append("\n");
    sb.append("    roadTraffic: ").append(toIndentedString(roadTraffic)).append("\n");
    sb.append("    startCoordinates: ").append(toIndentedString(startCoordinates)).append("\n");
    sb.append("    travelDuration: ").append(toIndentedString(travelDuration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowImpreciseAddresses");
    openapiFields.add("commuteMethod");
    openapiFields.add("departureTime");
    openapiFields.add("roadTraffic");
    openapiFields.add("startCoordinates");
    openapiFields.add("travelDuration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CommuteFilter
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CommuteFilter.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CommuteFilter is not found in the empty JSON string", CommuteFilter.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CommuteFilter.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CommuteFilter` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("commuteMethod") != null && !jsonObj.get("commuteMethod").isJsonNull()) && !jsonObj.get("commuteMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commuteMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commuteMethod").toString()));
      }
      // validate the optional field `commuteMethod`
      if (jsonObj.get("commuteMethod") != null && !jsonObj.get("commuteMethod").isJsonNull()) {
        CommuteMethodEnum.validateJsonElement(jsonObj.get("commuteMethod"));
      }
      // validate the optional field `departureTime`
      if (jsonObj.get("departureTime") != null && !jsonObj.get("departureTime").isJsonNull()) {
        TimeOfDay.validateJsonElement(jsonObj.get("departureTime"));
      }
      if ((jsonObj.get("roadTraffic") != null && !jsonObj.get("roadTraffic").isJsonNull()) && !jsonObj.get("roadTraffic").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roadTraffic` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roadTraffic").toString()));
      }
      // validate the optional field `roadTraffic`
      if (jsonObj.get("roadTraffic") != null && !jsonObj.get("roadTraffic").isJsonNull()) {
        RoadTrafficEnum.validateJsonElement(jsonObj.get("roadTraffic"));
      }
      // validate the optional field `startCoordinates`
      if (jsonObj.get("startCoordinates") != null && !jsonObj.get("startCoordinates").isJsonNull()) {
        LatLng.validateJsonElement(jsonObj.get("startCoordinates"));
      }
      if ((jsonObj.get("travelDuration") != null && !jsonObj.get("travelDuration").isJsonNull()) && !jsonObj.get("travelDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `travelDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("travelDuration").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CommuteFilter.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CommuteFilter' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CommuteFilter> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CommuteFilter.class));

       return (TypeAdapter<T>) new TypeAdapter<CommuteFilter>() {
           @Override
           public void write(JsonWriter out, CommuteFilter value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CommuteFilter read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CommuteFilter given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CommuteFilter
   * @throws IOException if the JSON string is invalid with respect to CommuteFilter
   */
  public static CommuteFilter fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CommuteFilter.class);
  }

  /**
   * Convert an instance of CommuteFilter to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

