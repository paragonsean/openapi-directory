/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.LatLng;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Input only. Geographic region of the search.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:22.826388-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LocationFilter {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private String address;

  public static final String SERIALIZED_NAME_DISTANCE_IN_MILES = "distanceInMiles";
  @SerializedName(SERIALIZED_NAME_DISTANCE_IN_MILES)
  private Double distanceInMiles;

  public static final String SERIALIZED_NAME_LAT_LNG = "latLng";
  @SerializedName(SERIALIZED_NAME_LAT_LNG)
  private LatLng latLng;

  public static final String SERIALIZED_NAME_REGION_CODE = "regionCode";
  @SerializedName(SERIALIZED_NAME_REGION_CODE)
  private String regionCode;

  /**
   * Optional. Allows the client to return jobs without a set location, specifically, telecommuting jobs (telecommuting is considered by the service as a special location). Job.posting_region indicates if a job permits telecommuting. If this field is set to TelecommutePreference.TELECOMMUTE_ALLOWED, telecommuting jobs are searched, and address and lat_lng are ignored. If not set or set to TelecommutePreference.TELECOMMUTE_EXCLUDED, the telecommute status of the jobs is ignored. Jobs that have PostingRegion.TELECOMMUTE and have additional Job.addresses may still be matched based on other location filters using address or latlng. This filter can be used by itself to search exclusively for telecommuting jobs, or it can be combined with another location filter to search for a combination of job locations, such as \&quot;Mountain View\&quot; or \&quot;telecommuting\&quot; jobs. However, when used in combination with other location filters, telecommuting jobs can be treated as less relevant than other jobs in the search response.
   */
  @JsonAdapter(TelecommutePreferenceEnum.Adapter.class)
  public enum TelecommutePreferenceEnum {
    PREFERENCE_UNSPECIFIED("TELECOMMUTE_PREFERENCE_UNSPECIFIED"),
    
    EXCLUDED("TELECOMMUTE_EXCLUDED"),
    
    ALLOWED("TELECOMMUTE_ALLOWED"),
    
    JOBS_EXCLUDED("TELECOMMUTE_JOBS_EXCLUDED");

    private String value;

    TelecommutePreferenceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TelecommutePreferenceEnum fromValue(String value) {
      for (TelecommutePreferenceEnum b : TelecommutePreferenceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TelecommutePreferenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TelecommutePreferenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TelecommutePreferenceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TelecommutePreferenceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TelecommutePreferenceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TELECOMMUTE_PREFERENCE = "telecommutePreference";
  @SerializedName(SERIALIZED_NAME_TELECOMMUTE_PREFERENCE)
  private TelecommutePreferenceEnum telecommutePreference;

  public LocationFilter() {
  }

  public LocationFilter address(String address) {
    this.address = address;
    return this;
  }

  /**
   * Optional. The address name, such as \&quot;Mountain View\&quot; or \&quot;Bay Area\&quot;.
   * @return address
   */
  @javax.annotation.Nullable
  public String getAddress() {
    return address;
  }

  public void setAddress(String address) {
    this.address = address;
  }


  public LocationFilter distanceInMiles(Double distanceInMiles) {
    this.distanceInMiles = distanceInMiles;
    return this;
  }

  /**
   * Optional. The distance_in_miles is applied when the location being searched for is identified as a city or smaller. When the location being searched for is a state or larger, this field is ignored.
   * @return distanceInMiles
   */
  @javax.annotation.Nullable
  public Double getDistanceInMiles() {
    return distanceInMiles;
  }

  public void setDistanceInMiles(Double distanceInMiles) {
    this.distanceInMiles = distanceInMiles;
  }


  public LocationFilter latLng(LatLng latLng) {
    this.latLng = latLng;
    return this;
  }

  /**
   * Get latLng
   * @return latLng
   */
  @javax.annotation.Nullable
  public LatLng getLatLng() {
    return latLng;
  }

  public void setLatLng(LatLng latLng) {
    this.latLng = latLng;
  }


  public LocationFilter regionCode(String regionCode) {
    this.regionCode = regionCode;
    return this;
  }

  /**
   * Optional. CLDR region code of the country/region. This field may be used in two ways: 1) If telecommute preference is not set, this field is used address ambiguity of the user-input address. For example, \&quot;Liverpool\&quot; may refer to \&quot;Liverpool, NY, US\&quot; or \&quot;Liverpool, UK\&quot;. This region code biases the address resolution toward a specific country or territory. If this field is not set, address resolution is biased toward the United States by default. 2) If telecommute preference is set to TELECOMMUTE_ALLOWED, the telecommute location filter will be limited to the region specified in this field. If this field is not set, the telecommute job locations will not be limited. See https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/territory_information.html for details. Example: \&quot;CH\&quot; for Switzerland.
   * @return regionCode
   */
  @javax.annotation.Nullable
  public String getRegionCode() {
    return regionCode;
  }

  public void setRegionCode(String regionCode) {
    this.regionCode = regionCode;
  }


  public LocationFilter telecommutePreference(TelecommutePreferenceEnum telecommutePreference) {
    this.telecommutePreference = telecommutePreference;
    return this;
  }

  /**
   * Optional. Allows the client to return jobs without a set location, specifically, telecommuting jobs (telecommuting is considered by the service as a special location). Job.posting_region indicates if a job permits telecommuting. If this field is set to TelecommutePreference.TELECOMMUTE_ALLOWED, telecommuting jobs are searched, and address and lat_lng are ignored. If not set or set to TelecommutePreference.TELECOMMUTE_EXCLUDED, the telecommute status of the jobs is ignored. Jobs that have PostingRegion.TELECOMMUTE and have additional Job.addresses may still be matched based on other location filters using address or latlng. This filter can be used by itself to search exclusively for telecommuting jobs, or it can be combined with another location filter to search for a combination of job locations, such as \&quot;Mountain View\&quot; or \&quot;telecommuting\&quot; jobs. However, when used in combination with other location filters, telecommuting jobs can be treated as less relevant than other jobs in the search response.
   * @return telecommutePreference
   */
  @javax.annotation.Nullable
  public TelecommutePreferenceEnum getTelecommutePreference() {
    return telecommutePreference;
  }

  public void setTelecommutePreference(TelecommutePreferenceEnum telecommutePreference) {
    this.telecommutePreference = telecommutePreference;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LocationFilter locationFilter = (LocationFilter) o;
    return Objects.equals(this.address, locationFilter.address) &&
        Objects.equals(this.distanceInMiles, locationFilter.distanceInMiles) &&
        Objects.equals(this.latLng, locationFilter.latLng) &&
        Objects.equals(this.regionCode, locationFilter.regionCode) &&
        Objects.equals(this.telecommutePreference, locationFilter.telecommutePreference);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, distanceInMiles, latLng, regionCode, telecommutePreference);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LocationFilter {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    distanceInMiles: ").append(toIndentedString(distanceInMiles)).append("\n");
    sb.append("    latLng: ").append(toIndentedString(latLng)).append("\n");
    sb.append("    regionCode: ").append(toIndentedString(regionCode)).append("\n");
    sb.append("    telecommutePreference: ").append(toIndentedString(telecommutePreference)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("distanceInMiles");
    openapiFields.add("latLng");
    openapiFields.add("regionCode");
    openapiFields.add("telecommutePreference");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LocationFilter
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LocationFilter.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LocationFilter is not found in the empty JSON string", LocationFilter.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LocationFilter.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LocationFilter` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) && !jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      // validate the optional field `latLng`
      if (jsonObj.get("latLng") != null && !jsonObj.get("latLng").isJsonNull()) {
        LatLng.validateJsonElement(jsonObj.get("latLng"));
      }
      if ((jsonObj.get("regionCode") != null && !jsonObj.get("regionCode").isJsonNull()) && !jsonObj.get("regionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `regionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("regionCode").toString()));
      }
      if ((jsonObj.get("telecommutePreference") != null && !jsonObj.get("telecommutePreference").isJsonNull()) && !jsonObj.get("telecommutePreference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `telecommutePreference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("telecommutePreference").toString()));
      }
      // validate the optional field `telecommutePreference`
      if (jsonObj.get("telecommutePreference") != null && !jsonObj.get("telecommutePreference").isJsonNull()) {
        TelecommutePreferenceEnum.validateJsonElement(jsonObj.get("telecommutePreference"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LocationFilter.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LocationFilter' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LocationFilter> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LocationFilter.class));

       return (TypeAdapter<T>) new TypeAdapter<LocationFilter>() {
           @Override
           public void write(JsonWriter out, LocationFilter value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LocationFilter read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LocationFilter given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LocationFilter
   * @throws IOException if the JSON string is invalid with respect to LocationFilter
   */
  public static LocationFilter fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LocationFilter.class);
  }

  /**
   * Convert an instance of LocationFilter to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

