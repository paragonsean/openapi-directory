/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.HistogramFacets;
import org.openapitools.client.model.JobQuery;
import org.openapitools.client.model.RequestMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Input only. The Request body of the &#x60;SearchJobs&#x60; call.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:22.826388-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SearchJobsRequest {
  public static final String SERIALIZED_NAME_DISABLE_KEYWORD_MATCH = "disableKeywordMatch";
  @SerializedName(SERIALIZED_NAME_DISABLE_KEYWORD_MATCH)
  private Boolean disableKeywordMatch;

  /**
   * Optional. Controls whether highly similar jobs are returned next to each other in the search results. Jobs are identified as highly similar based on their titles, job categories, and locations. Highly similar results are clustered so that only one representative job of the cluster is displayed to the job seeker higher up in the results, with the other jobs being displayed lower down in the results. Defaults to DiversificationLevel.SIMPLE if no value is specified.
   */
  @JsonAdapter(DiversificationLevelEnum.Adapter.class)
  public enum DiversificationLevelEnum {
    DIVERSIFICATION_LEVEL_UNSPECIFIED("DIVERSIFICATION_LEVEL_UNSPECIFIED"),
    
    DISABLED("DISABLED"),
    
    SIMPLE("SIMPLE");

    private String value;

    DiversificationLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DiversificationLevelEnum fromValue(String value) {
      for (DiversificationLevelEnum b : DiversificationLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DiversificationLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DiversificationLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DiversificationLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DiversificationLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DiversificationLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DIVERSIFICATION_LEVEL = "diversificationLevel";
  @SerializedName(SERIALIZED_NAME_DIVERSIFICATION_LEVEL)
  private DiversificationLevelEnum diversificationLevel;

  public static final String SERIALIZED_NAME_ENABLE_BROADENING = "enableBroadening";
  @SerializedName(SERIALIZED_NAME_ENABLE_BROADENING)
  private Boolean enableBroadening;

  public static final String SERIALIZED_NAME_HISTOGRAM_FACETS = "histogramFacets";
  @SerializedName(SERIALIZED_NAME_HISTOGRAM_FACETS)
  private HistogramFacets histogramFacets;

  public static final String SERIALIZED_NAME_JOB_QUERY = "jobQuery";
  @SerializedName(SERIALIZED_NAME_JOB_QUERY)
  private JobQuery jobQuery;

  /**
   * Optional. The desired job attributes returned for jobs in the search response. Defaults to JobView.SMALL if no value is specified.
   */
  @JsonAdapter(JobViewEnum.Adapter.class)
  public enum JobViewEnum {
    UNSPECIFIED("JOB_VIEW_UNSPECIFIED"),
    
    ID_ONLY("JOB_VIEW_ID_ONLY"),
    
    MINIMAL("JOB_VIEW_MINIMAL"),
    
    SMALL("JOB_VIEW_SMALL"),
    
    FULL("JOB_VIEW_FULL");

    private String value;

    JobViewEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static JobViewEnum fromValue(String value) {
      for (JobViewEnum b : JobViewEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<JobViewEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobViewEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public JobViewEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return JobViewEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      JobViewEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_JOB_VIEW = "jobView";
  @SerializedName(SERIALIZED_NAME_JOB_VIEW)
  private JobViewEnum jobView;

  public static final String SERIALIZED_NAME_OFFSET = "offset";
  @SerializedName(SERIALIZED_NAME_OFFSET)
  private Integer offset;

  public static final String SERIALIZED_NAME_ORDER_BY = "orderBy";
  @SerializedName(SERIALIZED_NAME_ORDER_BY)
  private String orderBy;

  public static final String SERIALIZED_NAME_PAGE_SIZE = "pageSize";
  @SerializedName(SERIALIZED_NAME_PAGE_SIZE)
  private Integer pageSize;

  public static final String SERIALIZED_NAME_PAGE_TOKEN = "pageToken";
  @SerializedName(SERIALIZED_NAME_PAGE_TOKEN)
  private String pageToken;

  public static final String SERIALIZED_NAME_REQUEST_METADATA = "requestMetadata";
  @SerializedName(SERIALIZED_NAME_REQUEST_METADATA)
  private RequestMetadata requestMetadata;

  public static final String SERIALIZED_NAME_REQUIRE_PRECISE_RESULT_SIZE = "requirePreciseResultSize";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_REQUIRE_PRECISE_RESULT_SIZE)
  private Boolean requirePreciseResultSize;

  /**
   * Optional. Mode of a search. Defaults to SearchMode.JOB_SEARCH.
   */
  @JsonAdapter(SearchModeEnum.Adapter.class)
  public enum SearchModeEnum {
    SEARCH_MODE_UNSPECIFIED("SEARCH_MODE_UNSPECIFIED"),
    
    JOB_SEARCH("JOB_SEARCH"),
    
    FEATURED_JOB_SEARCH("FEATURED_JOB_SEARCH");

    private String value;

    SearchModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SearchModeEnum fromValue(String value) {
      for (SearchModeEnum b : SearchModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SearchModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SearchModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SearchModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SearchModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SearchModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEARCH_MODE = "searchMode";
  @SerializedName(SERIALIZED_NAME_SEARCH_MODE)
  private SearchModeEnum searchMode;

  public SearchJobsRequest() {
  }

  public SearchJobsRequest disableKeywordMatch(Boolean disableKeywordMatch) {
    this.disableKeywordMatch = disableKeywordMatch;
    return this;
  }

  /**
   * Optional. Controls whether to disable exact keyword match on Job.job_title, Job.description, Job.company_display_name, Job.locations, Job.qualifications. When disable keyword match is turned off, a keyword match returns jobs that do not match given category filters when there are matching keywords. For example, the query \&quot;program manager,\&quot; a result is returned even if the job posting has the title \&quot;software developer,\&quot; which does not fall into \&quot;program manager\&quot; ontology, but does have \&quot;program manager\&quot; appearing in its description. For queries like \&quot;cloud\&quot; that does not contain title or location specific ontology, jobs with \&quot;cloud\&quot; keyword matches are returned regardless of this flag&#39;s value. Please use Company.keyword_searchable_custom_fields or Company.keyword_searchable_custom_attributes if company specific globally matched custom field/attribute string values is needed. Enabling keyword match improves recall of subsequent search requests. Defaults to false.
   * @return disableKeywordMatch
   */
  @javax.annotation.Nullable
  public Boolean getDisableKeywordMatch() {
    return disableKeywordMatch;
  }

  public void setDisableKeywordMatch(Boolean disableKeywordMatch) {
    this.disableKeywordMatch = disableKeywordMatch;
  }


  public SearchJobsRequest diversificationLevel(DiversificationLevelEnum diversificationLevel) {
    this.diversificationLevel = diversificationLevel;
    return this;
  }

  /**
   * Optional. Controls whether highly similar jobs are returned next to each other in the search results. Jobs are identified as highly similar based on their titles, job categories, and locations. Highly similar results are clustered so that only one representative job of the cluster is displayed to the job seeker higher up in the results, with the other jobs being displayed lower down in the results. Defaults to DiversificationLevel.SIMPLE if no value is specified.
   * @return diversificationLevel
   */
  @javax.annotation.Nullable
  public DiversificationLevelEnum getDiversificationLevel() {
    return diversificationLevel;
  }

  public void setDiversificationLevel(DiversificationLevelEnum diversificationLevel) {
    this.diversificationLevel = diversificationLevel;
  }


  public SearchJobsRequest enableBroadening(Boolean enableBroadening) {
    this.enableBroadening = enableBroadening;
    return this;
  }

  /**
   * Optional. Controls whether to broaden the search when it produces sparse results. Broadened queries append results to the end of the matching results list. Defaults to false.
   * @return enableBroadening
   */
  @javax.annotation.Nullable
  public Boolean getEnableBroadening() {
    return enableBroadening;
  }

  public void setEnableBroadening(Boolean enableBroadening) {
    this.enableBroadening = enableBroadening;
  }


  public SearchJobsRequest histogramFacets(HistogramFacets histogramFacets) {
    this.histogramFacets = histogramFacets;
    return this;
  }

  /**
   * Get histogramFacets
   * @return histogramFacets
   */
  @javax.annotation.Nullable
  public HistogramFacets getHistogramFacets() {
    return histogramFacets;
  }

  public void setHistogramFacets(HistogramFacets histogramFacets) {
    this.histogramFacets = histogramFacets;
  }


  public SearchJobsRequest jobQuery(JobQuery jobQuery) {
    this.jobQuery = jobQuery;
    return this;
  }

  /**
   * Get jobQuery
   * @return jobQuery
   */
  @javax.annotation.Nullable
  public JobQuery getJobQuery() {
    return jobQuery;
  }

  public void setJobQuery(JobQuery jobQuery) {
    this.jobQuery = jobQuery;
  }


  public SearchJobsRequest jobView(JobViewEnum jobView) {
    this.jobView = jobView;
    return this;
  }

  /**
   * Optional. The desired job attributes returned for jobs in the search response. Defaults to JobView.SMALL if no value is specified.
   * @return jobView
   */
  @javax.annotation.Nullable
  public JobViewEnum getJobView() {
    return jobView;
  }

  public void setJobView(JobViewEnum jobView) {
    this.jobView = jobView;
  }


  public SearchJobsRequest offset(Integer offset) {
    this.offset = offset;
    return this;
  }

  /**
   * Optional. An integer that specifies the current offset (that is, starting result location, amongst the jobs deemed by the API as relevant) in search results. This field is only considered if page_token is unset. The maximum allowed value is 5000. Otherwise an error is thrown. For example, 0 means to return results starting from the first matching job, and 10 means to return from the 11th job. This can be used for pagination, (for example, pageSize &#x3D; 10 and offset &#x3D; 10 means to return from the second page).
   * @return offset
   */
  @javax.annotation.Nullable
  public Integer getOffset() {
    return offset;
  }

  public void setOffset(Integer offset) {
    this.offset = offset;
  }


  public SearchJobsRequest orderBy(String orderBy) {
    this.orderBy = orderBy;
    return this;
  }

  /**
   * Optional. The criteria determining how search results are sorted. Default is \&quot;relevance desc\&quot;. Supported options are: * &#x60;\&quot;relevance desc\&quot;&#x60;: By relevance descending, as determined by the API algorithms. Relevance thresholding of query results is only available with this ordering. * &#x60;\&quot;posting_publish_time desc\&quot;&#x60;: By Job.posting_publish_time descending. * &#x60;\&quot;posting_update_time desc\&quot;&#x60;: By Job.posting_update_time descending. * &#x60;\&quot;title\&quot;&#x60;: By Job.title ascending. * &#x60;\&quot;title desc\&quot;&#x60;: By Job.title descending. * &#x60;\&quot;annualized_base_compensation\&quot;&#x60;: By job&#39;s CompensationInfo.annualized_base_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * &#x60;\&quot;annualized_base_compensation desc\&quot;&#x60;: By job&#39;s CompensationInfo.annualized_base_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * &#x60;\&quot;annualized_total_compensation\&quot;&#x60;: By job&#39;s CompensationInfo.annualized_total_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * &#x60;\&quot;annualized_total_compensation desc\&quot;&#x60;: By job&#39;s CompensationInfo.annualized_total_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results.
   * @return orderBy
   */
  @javax.annotation.Nullable
  public String getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(String orderBy) {
    this.orderBy = orderBy;
  }


  public SearchJobsRequest pageSize(Integer pageSize) {
    this.pageSize = pageSize;
    return this;
  }

  /**
   * Optional. A limit on the number of jobs returned in the search results. Increasing this value above the default value of 10 can increase search response time. The value can be between 1 and 100.
   * @return pageSize
   */
  @javax.annotation.Nullable
  public Integer getPageSize() {
    return pageSize;
  }

  public void setPageSize(Integer pageSize) {
    this.pageSize = pageSize;
  }


  public SearchJobsRequest pageToken(String pageToken) {
    this.pageToken = pageToken;
    return this;
  }

  /**
   * Optional. The token specifying the current offset within search results. See SearchJobsResponse.next_page_token for an explanation of how to obtain the next set of query results.
   * @return pageToken
   */
  @javax.annotation.Nullable
  public String getPageToken() {
    return pageToken;
  }

  public void setPageToken(String pageToken) {
    this.pageToken = pageToken;
  }


  public SearchJobsRequest requestMetadata(RequestMetadata requestMetadata) {
    this.requestMetadata = requestMetadata;
    return this;
  }

  /**
   * Get requestMetadata
   * @return requestMetadata
   */
  @javax.annotation.Nullable
  public RequestMetadata getRequestMetadata() {
    return requestMetadata;
  }

  public void setRequestMetadata(RequestMetadata requestMetadata) {
    this.requestMetadata = requestMetadata;
  }


  @Deprecated
  public SearchJobsRequest requirePreciseResultSize(Boolean requirePreciseResultSize) {
    this.requirePreciseResultSize = requirePreciseResultSize;
    return this;
  }

  /**
   * This field is deprecated.
   * @return requirePreciseResultSize
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getRequirePreciseResultSize() {
    return requirePreciseResultSize;
  }

  @Deprecated
  public void setRequirePreciseResultSize(Boolean requirePreciseResultSize) {
    this.requirePreciseResultSize = requirePreciseResultSize;
  }


  public SearchJobsRequest searchMode(SearchModeEnum searchMode) {
    this.searchMode = searchMode;
    return this;
  }

  /**
   * Optional. Mode of a search. Defaults to SearchMode.JOB_SEARCH.
   * @return searchMode
   */
  @javax.annotation.Nullable
  public SearchModeEnum getSearchMode() {
    return searchMode;
  }

  public void setSearchMode(SearchModeEnum searchMode) {
    this.searchMode = searchMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchJobsRequest searchJobsRequest = (SearchJobsRequest) o;
    return Objects.equals(this.disableKeywordMatch, searchJobsRequest.disableKeywordMatch) &&
        Objects.equals(this.diversificationLevel, searchJobsRequest.diversificationLevel) &&
        Objects.equals(this.enableBroadening, searchJobsRequest.enableBroadening) &&
        Objects.equals(this.histogramFacets, searchJobsRequest.histogramFacets) &&
        Objects.equals(this.jobQuery, searchJobsRequest.jobQuery) &&
        Objects.equals(this.jobView, searchJobsRequest.jobView) &&
        Objects.equals(this.offset, searchJobsRequest.offset) &&
        Objects.equals(this.orderBy, searchJobsRequest.orderBy) &&
        Objects.equals(this.pageSize, searchJobsRequest.pageSize) &&
        Objects.equals(this.pageToken, searchJobsRequest.pageToken) &&
        Objects.equals(this.requestMetadata, searchJobsRequest.requestMetadata) &&
        Objects.equals(this.requirePreciseResultSize, searchJobsRequest.requirePreciseResultSize) &&
        Objects.equals(this.searchMode, searchJobsRequest.searchMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(disableKeywordMatch, diversificationLevel, enableBroadening, histogramFacets, jobQuery, jobView, offset, orderBy, pageSize, pageToken, requestMetadata, requirePreciseResultSize, searchMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchJobsRequest {\n");
    sb.append("    disableKeywordMatch: ").append(toIndentedString(disableKeywordMatch)).append("\n");
    sb.append("    diversificationLevel: ").append(toIndentedString(diversificationLevel)).append("\n");
    sb.append("    enableBroadening: ").append(toIndentedString(enableBroadening)).append("\n");
    sb.append("    histogramFacets: ").append(toIndentedString(histogramFacets)).append("\n");
    sb.append("    jobQuery: ").append(toIndentedString(jobQuery)).append("\n");
    sb.append("    jobView: ").append(toIndentedString(jobView)).append("\n");
    sb.append("    offset: ").append(toIndentedString(offset)).append("\n");
    sb.append("    orderBy: ").append(toIndentedString(orderBy)).append("\n");
    sb.append("    pageSize: ").append(toIndentedString(pageSize)).append("\n");
    sb.append("    pageToken: ").append(toIndentedString(pageToken)).append("\n");
    sb.append("    requestMetadata: ").append(toIndentedString(requestMetadata)).append("\n");
    sb.append("    requirePreciseResultSize: ").append(toIndentedString(requirePreciseResultSize)).append("\n");
    sb.append("    searchMode: ").append(toIndentedString(searchMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("disableKeywordMatch");
    openapiFields.add("diversificationLevel");
    openapiFields.add("enableBroadening");
    openapiFields.add("histogramFacets");
    openapiFields.add("jobQuery");
    openapiFields.add("jobView");
    openapiFields.add("offset");
    openapiFields.add("orderBy");
    openapiFields.add("pageSize");
    openapiFields.add("pageToken");
    openapiFields.add("requestMetadata");
    openapiFields.add("requirePreciseResultSize");
    openapiFields.add("searchMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchJobsRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SearchJobsRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchJobsRequest is not found in the empty JSON string", SearchJobsRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchJobsRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchJobsRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("diversificationLevel") != null && !jsonObj.get("diversificationLevel").isJsonNull()) && !jsonObj.get("diversificationLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diversificationLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diversificationLevel").toString()));
      }
      // validate the optional field `diversificationLevel`
      if (jsonObj.get("diversificationLevel") != null && !jsonObj.get("diversificationLevel").isJsonNull()) {
        DiversificationLevelEnum.validateJsonElement(jsonObj.get("diversificationLevel"));
      }
      // validate the optional field `histogramFacets`
      if (jsonObj.get("histogramFacets") != null && !jsonObj.get("histogramFacets").isJsonNull()) {
        HistogramFacets.validateJsonElement(jsonObj.get("histogramFacets"));
      }
      // validate the optional field `jobQuery`
      if (jsonObj.get("jobQuery") != null && !jsonObj.get("jobQuery").isJsonNull()) {
        JobQuery.validateJsonElement(jsonObj.get("jobQuery"));
      }
      if ((jsonObj.get("jobView") != null && !jsonObj.get("jobView").isJsonNull()) && !jsonObj.get("jobView").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobView` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jobView").toString()));
      }
      // validate the optional field `jobView`
      if (jsonObj.get("jobView") != null && !jsonObj.get("jobView").isJsonNull()) {
        JobViewEnum.validateJsonElement(jsonObj.get("jobView"));
      }
      if ((jsonObj.get("orderBy") != null && !jsonObj.get("orderBy").isJsonNull()) && !jsonObj.get("orderBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderBy").toString()));
      }
      if ((jsonObj.get("pageToken") != null && !jsonObj.get("pageToken").isJsonNull()) && !jsonObj.get("pageToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pageToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pageToken").toString()));
      }
      // validate the optional field `requestMetadata`
      if (jsonObj.get("requestMetadata") != null && !jsonObj.get("requestMetadata").isJsonNull()) {
        RequestMetadata.validateJsonElement(jsonObj.get("requestMetadata"));
      }
      if ((jsonObj.get("searchMode") != null && !jsonObj.get("searchMode").isJsonNull()) && !jsonObj.get("searchMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchMode").toString()));
      }
      // validate the optional field `searchMode`
      if (jsonObj.get("searchMode") != null && !jsonObj.get("searchMode").isJsonNull()) {
        SearchModeEnum.validateJsonElement(jsonObj.get("searchMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchJobsRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchJobsRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchJobsRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchJobsRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchJobsRequest>() {
           @Override
           public void write(JsonWriter out, SearchJobsRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchJobsRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchJobsRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchJobsRequest
   * @throws IOException if the JSON string is invalid with respect to SearchJobsRequest
   */
  public static SearchJobsRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchJobsRequest.class);
  }

  /**
   * Convert an instance of SearchJobsRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

