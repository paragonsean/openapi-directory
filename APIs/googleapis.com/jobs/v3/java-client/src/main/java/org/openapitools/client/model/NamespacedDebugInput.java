/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Next ID: 16
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:22.826388-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamespacedDebugInput {
  public static final String SERIALIZED_NAME_ABSOLUTELY_FORCED_EXP_NAMES = "absolutelyForcedExpNames";
  @SerializedName(SERIALIZED_NAME_ABSOLUTELY_FORCED_EXP_NAMES)
  private List<String> absolutelyForcedExpNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_ABSOLUTELY_FORCED_EXP_TAGS = "absolutelyForcedExpTags";
  @SerializedName(SERIALIZED_NAME_ABSOLUTELY_FORCED_EXP_TAGS)
  private List<String> absolutelyForcedExpTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_ABSOLUTELY_FORCED_EXPS = "absolutelyForcedExps";
  @SerializedName(SERIALIZED_NAME_ABSOLUTELY_FORCED_EXPS)
  private List<Integer> absolutelyForcedExps = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONDITIONALLY_FORCED_EXP_NAMES = "conditionallyForcedExpNames";
  @SerializedName(SERIALIZED_NAME_CONDITIONALLY_FORCED_EXP_NAMES)
  private List<String> conditionallyForcedExpNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONDITIONALLY_FORCED_EXP_TAGS = "conditionallyForcedExpTags";
  @SerializedName(SERIALIZED_NAME_CONDITIONALLY_FORCED_EXP_TAGS)
  private List<String> conditionallyForcedExpTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONDITIONALLY_FORCED_EXPS = "conditionallyForcedExps";
  @SerializedName(SERIALIZED_NAME_CONDITIONALLY_FORCED_EXPS)
  private List<Integer> conditionallyForcedExps = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISABLE_AUTOMATIC_ENROLLMENT_SELECTION = "disableAutomaticEnrollmentSelection";
  @SerializedName(SERIALIZED_NAME_DISABLE_AUTOMATIC_ENROLLMENT_SELECTION)
  private Boolean disableAutomaticEnrollmentSelection;

  public static final String SERIALIZED_NAME_DISABLE_EXP_NAMES = "disableExpNames";
  @SerializedName(SERIALIZED_NAME_DISABLE_EXP_NAMES)
  private List<String> disableExpNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISABLE_EXP_TAGS = "disableExpTags";
  @SerializedName(SERIALIZED_NAME_DISABLE_EXP_TAGS)
  private List<String> disableExpTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISABLE_EXPS = "disableExps";
  @SerializedName(SERIALIZED_NAME_DISABLE_EXPS)
  private List<Integer> disableExps = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISABLE_MANUAL_ENROLLMENT_SELECTION = "disableManualEnrollmentSelection";
  @SerializedName(SERIALIZED_NAME_DISABLE_MANUAL_ENROLLMENT_SELECTION)
  private Boolean disableManualEnrollmentSelection;

  public static final String SERIALIZED_NAME_DISABLE_ORGANIC_SELECTION = "disableOrganicSelection";
  @SerializedName(SERIALIZED_NAME_DISABLE_ORGANIC_SELECTION)
  private Boolean disableOrganicSelection;

  public static final String SERIALIZED_NAME_FORCED_FLAGS = "forcedFlags";
  @SerializedName(SERIALIZED_NAME_FORCED_FLAGS)
  private Map<String, String> forcedFlags = new HashMap<>();

  public static final String SERIALIZED_NAME_FORCED_ROLLOUTS = "forcedRollouts";
  @SerializedName(SERIALIZED_NAME_FORCED_ROLLOUTS)
  private Map<String, Boolean> forcedRollouts = new HashMap<>();

  /**
   * Sets different testing modes. See the documentation in the TestingMode message for more information.
   */
  @JsonAdapter(TestingModeEnum.Adapter.class)
  public enum TestingModeEnum {
    UNSPECIFIED("TESTING_MODE_UNSPECIFIED"),
    
    ALL_OFF("TESTING_MODE_ALL_OFF"),
    
    ALL_ON("TESTING_MODE_ALL_ON");

    private String value;

    TestingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TestingModeEnum fromValue(String value) {
      for (TestingModeEnum b : TestingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TestingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TestingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TestingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TestingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TestingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TESTING_MODE = "testingMode";
  @SerializedName(SERIALIZED_NAME_TESTING_MODE)
  private TestingModeEnum testingMode;

  public NamespacedDebugInput() {
  }

  public NamespacedDebugInput absolutelyForcedExpNames(List<String> absolutelyForcedExpNames) {
    this.absolutelyForcedExpNames = absolutelyForcedExpNames;
    return this;
  }

  public NamespacedDebugInput addAbsolutelyForcedExpNamesItem(String absolutelyForcedExpNamesItem) {
    if (this.absolutelyForcedExpNames == null) {
      this.absolutelyForcedExpNames = new ArrayList<>();
    }
    this.absolutelyForcedExpNames.add(absolutelyForcedExpNamesItem);
    return this;
  }

  /**
   * Set of experiment names to be absolutely forced. These experiments will be forced without evaluating the conditions.
   * @return absolutelyForcedExpNames
   */
  @javax.annotation.Nullable
  public List<String> getAbsolutelyForcedExpNames() {
    return absolutelyForcedExpNames;
  }

  public void setAbsolutelyForcedExpNames(List<String> absolutelyForcedExpNames) {
    this.absolutelyForcedExpNames = absolutelyForcedExpNames;
  }


  public NamespacedDebugInput absolutelyForcedExpTags(List<String> absolutelyForcedExpTags) {
    this.absolutelyForcedExpTags = absolutelyForcedExpTags;
    return this;
  }

  public NamespacedDebugInput addAbsolutelyForcedExpTagsItem(String absolutelyForcedExpTagsItem) {
    if (this.absolutelyForcedExpTags == null) {
      this.absolutelyForcedExpTags = new ArrayList<>();
    }
    this.absolutelyForcedExpTags.add(absolutelyForcedExpTagsItem);
    return this;
  }

  /**
   * Set of experiment tags to be absolutely forced. The experiments with these tags will be forced without evaluating the conditions.
   * @return absolutelyForcedExpTags
   */
  @javax.annotation.Nullable
  public List<String> getAbsolutelyForcedExpTags() {
    return absolutelyForcedExpTags;
  }

  public void setAbsolutelyForcedExpTags(List<String> absolutelyForcedExpTags) {
    this.absolutelyForcedExpTags = absolutelyForcedExpTags;
  }


  public NamespacedDebugInput absolutelyForcedExps(List<Integer> absolutelyForcedExps) {
    this.absolutelyForcedExps = absolutelyForcedExps;
    return this;
  }

  public NamespacedDebugInput addAbsolutelyForcedExpsItem(Integer absolutelyForcedExpsItem) {
    if (this.absolutelyForcedExps == null) {
      this.absolutelyForcedExps = new ArrayList<>();
    }
    this.absolutelyForcedExps.add(absolutelyForcedExpsItem);
    return this;
  }

  /**
   * Set of experiment ids to be absolutely forced. These ids will be forced without evaluating the conditions.
   * @return absolutelyForcedExps
   */
  @javax.annotation.Nullable
  public List<Integer> getAbsolutelyForcedExps() {
    return absolutelyForcedExps;
  }

  public void setAbsolutelyForcedExps(List<Integer> absolutelyForcedExps) {
    this.absolutelyForcedExps = absolutelyForcedExps;
  }


  public NamespacedDebugInput conditionallyForcedExpNames(List<String> conditionallyForcedExpNames) {
    this.conditionallyForcedExpNames = conditionallyForcedExpNames;
    return this;
  }

  public NamespacedDebugInput addConditionallyForcedExpNamesItem(String conditionallyForcedExpNamesItem) {
    if (this.conditionallyForcedExpNames == null) {
      this.conditionallyForcedExpNames = new ArrayList<>();
    }
    this.conditionallyForcedExpNames.add(conditionallyForcedExpNamesItem);
    return this;
  }

  /**
   * Set of experiment names to be conditionally forced. These experiments will be forced only if their conditions and their parent domain&#39;s conditions are true.
   * @return conditionallyForcedExpNames
   */
  @javax.annotation.Nullable
  public List<String> getConditionallyForcedExpNames() {
    return conditionallyForcedExpNames;
  }

  public void setConditionallyForcedExpNames(List<String> conditionallyForcedExpNames) {
    this.conditionallyForcedExpNames = conditionallyForcedExpNames;
  }


  public NamespacedDebugInput conditionallyForcedExpTags(List<String> conditionallyForcedExpTags) {
    this.conditionallyForcedExpTags = conditionallyForcedExpTags;
    return this;
  }

  public NamespacedDebugInput addConditionallyForcedExpTagsItem(String conditionallyForcedExpTagsItem) {
    if (this.conditionallyForcedExpTags == null) {
      this.conditionallyForcedExpTags = new ArrayList<>();
    }
    this.conditionallyForcedExpTags.add(conditionallyForcedExpTagsItem);
    return this;
  }

  /**
   * Set of experiment tags to be conditionally forced. The experiments with these tags will be forced only if their conditions and their parent domain&#39;s conditions are true.
   * @return conditionallyForcedExpTags
   */
  @javax.annotation.Nullable
  public List<String> getConditionallyForcedExpTags() {
    return conditionallyForcedExpTags;
  }

  public void setConditionallyForcedExpTags(List<String> conditionallyForcedExpTags) {
    this.conditionallyForcedExpTags = conditionallyForcedExpTags;
  }


  public NamespacedDebugInput conditionallyForcedExps(List<Integer> conditionallyForcedExps) {
    this.conditionallyForcedExps = conditionallyForcedExps;
    return this;
  }

  public NamespacedDebugInput addConditionallyForcedExpsItem(Integer conditionallyForcedExpsItem) {
    if (this.conditionallyForcedExps == null) {
      this.conditionallyForcedExps = new ArrayList<>();
    }
    this.conditionallyForcedExps.add(conditionallyForcedExpsItem);
    return this;
  }

  /**
   * Set of experiment ids to be conditionally forced. These ids will be forced only if their conditions and their parent domain&#39;s conditions are true.
   * @return conditionallyForcedExps
   */
  @javax.annotation.Nullable
  public List<Integer> getConditionallyForcedExps() {
    return conditionallyForcedExps;
  }

  public void setConditionallyForcedExps(List<Integer> conditionallyForcedExps) {
    this.conditionallyForcedExps = conditionallyForcedExps;
  }


  public NamespacedDebugInput disableAutomaticEnrollmentSelection(Boolean disableAutomaticEnrollmentSelection) {
    this.disableAutomaticEnrollmentSelection = disableAutomaticEnrollmentSelection;
    return this;
  }

  /**
   * If true, disable automatic enrollment selection (at all diversion points). Automatic enrollment selection means experiment selection process based on the experiment&#39;s automatic enrollment condition. This does not disable selection of forced experiments. Setting this field to false does not change anything in the experiment selection process.
   * @return disableAutomaticEnrollmentSelection
   */
  @javax.annotation.Nullable
  public Boolean getDisableAutomaticEnrollmentSelection() {
    return disableAutomaticEnrollmentSelection;
  }

  public void setDisableAutomaticEnrollmentSelection(Boolean disableAutomaticEnrollmentSelection) {
    this.disableAutomaticEnrollmentSelection = disableAutomaticEnrollmentSelection;
  }


  public NamespacedDebugInput disableExpNames(List<String> disableExpNames) {
    this.disableExpNames = disableExpNames;
    return this;
  }

  public NamespacedDebugInput addDisableExpNamesItem(String disableExpNamesItem) {
    if (this.disableExpNames == null) {
      this.disableExpNames = new ArrayList<>();
    }
    this.disableExpNames.add(disableExpNamesItem);
    return this;
  }

  /**
   * Set of experiment names to be disabled. If an experiment is disabled, it is never selected nor forced. If an aggregate experiment is disabled, its partitions are disabled together. If an experiment with an enrollment is disabled, the enrollment is disabled together. If a name corresponds to a domain, the domain itself and all descendant experiments and domains are disabled together.
   * @return disableExpNames
   */
  @javax.annotation.Nullable
  public List<String> getDisableExpNames() {
    return disableExpNames;
  }

  public void setDisableExpNames(List<String> disableExpNames) {
    this.disableExpNames = disableExpNames;
  }


  public NamespacedDebugInput disableExpTags(List<String> disableExpTags) {
    this.disableExpTags = disableExpTags;
    return this;
  }

  public NamespacedDebugInput addDisableExpTagsItem(String disableExpTagsItem) {
    if (this.disableExpTags == null) {
      this.disableExpTags = new ArrayList<>();
    }
    this.disableExpTags.add(disableExpTagsItem);
    return this;
  }

  /**
   * Set of experiment tags to be disabled. All experiments that are tagged with one or more of these tags are disabled. If an experiment is disabled, it is never selected nor forced. If an aggregate experiment is disabled, its partitions are disabled together. If an experiment with an enrollment is disabled, the enrollment is disabled together.
   * @return disableExpTags
   */
  @javax.annotation.Nullable
  public List<String> getDisableExpTags() {
    return disableExpTags;
  }

  public void setDisableExpTags(List<String> disableExpTags) {
    this.disableExpTags = disableExpTags;
  }


  public NamespacedDebugInput disableExps(List<Integer> disableExps) {
    this.disableExps = disableExps;
    return this;
  }

  public NamespacedDebugInput addDisableExpsItem(Integer disableExpsItem) {
    if (this.disableExps == null) {
      this.disableExps = new ArrayList<>();
    }
    this.disableExps.add(disableExpsItem);
    return this;
  }

  /**
   * Set of experiment ids to be disabled. If an experiment is disabled, it is never selected nor forced. If an aggregate experiment is disabled, its partitions are disabled together. If an experiment with an enrollment is disabled, the enrollment is disabled together. If an ID corresponds to a domain, the domain itself and all descendant experiments and domains are disabled together.
   * @return disableExps
   */
  @javax.annotation.Nullable
  public List<Integer> getDisableExps() {
    return disableExps;
  }

  public void setDisableExps(List<Integer> disableExps) {
    this.disableExps = disableExps;
  }


  public NamespacedDebugInput disableManualEnrollmentSelection(Boolean disableManualEnrollmentSelection) {
    this.disableManualEnrollmentSelection = disableManualEnrollmentSelection;
    return this;
  }

  /**
   * If true, disable manual enrollment selection (at all diversion points). Manual enrollment selection means experiment selection process based on the request&#39;s manual enrollment states (a.k.a. opt-in experiments). This does not disable selection of forced experiments. Setting this field to false does not change anything in the experiment selection process.
   * @return disableManualEnrollmentSelection
   */
  @javax.annotation.Nullable
  public Boolean getDisableManualEnrollmentSelection() {
    return disableManualEnrollmentSelection;
  }

  public void setDisableManualEnrollmentSelection(Boolean disableManualEnrollmentSelection) {
    this.disableManualEnrollmentSelection = disableManualEnrollmentSelection;
  }


  public NamespacedDebugInput disableOrganicSelection(Boolean disableOrganicSelection) {
    this.disableOrganicSelection = disableOrganicSelection;
    return this;
  }

  /**
   * If true, disable organic experiment selection (at all diversion points). Organic selection means experiment selection process based on traffic allocation and diversion condition evaluation. This does not disable selection of forced experiments. This is useful in cases when it is not known whether experiment selection behavior is responsible for a error or breakage. Disabling organic selection may help to isolate the cause of a given problem. Setting this field to false does not change anything in the experiment selection process.
   * @return disableOrganicSelection
   */
  @javax.annotation.Nullable
  public Boolean getDisableOrganicSelection() {
    return disableOrganicSelection;
  }

  public void setDisableOrganicSelection(Boolean disableOrganicSelection) {
    this.disableOrganicSelection = disableOrganicSelection;
  }


  public NamespacedDebugInput forcedFlags(Map<String, String> forcedFlags) {
    this.forcedFlags = forcedFlags;
    return this;
  }

  public NamespacedDebugInput putForcedFlagsItem(String key, String forcedFlagsItem) {
    if (this.forcedFlags == null) {
      this.forcedFlags = new HashMap<>();
    }
    this.forcedFlags.put(key, forcedFlagsItem);
    return this;
  }

  /**
   * Flags to force in a particular experiment state. Map from flag name to flag value.
   * @return forcedFlags
   */
  @javax.annotation.Nullable
  public Map<String, String> getForcedFlags() {
    return forcedFlags;
  }

  public void setForcedFlags(Map<String, String> forcedFlags) {
    this.forcedFlags = forcedFlags;
  }


  public NamespacedDebugInput forcedRollouts(Map<String, Boolean> forcedRollouts) {
    this.forcedRollouts = forcedRollouts;
    return this;
  }

  public NamespacedDebugInput putForcedRolloutsItem(String key, Boolean forcedRolloutsItem) {
    if (this.forcedRollouts == null) {
      this.forcedRollouts = new HashMap<>();
    }
    this.forcedRollouts.put(key, forcedRolloutsItem);
    return this;
  }

  /**
   * Rollouts to force in a particular experiment state. Map from rollout name to rollout value.
   * @return forcedRollouts
   */
  @javax.annotation.Nullable
  public Map<String, Boolean> getForcedRollouts() {
    return forcedRollouts;
  }

  public void setForcedRollouts(Map<String, Boolean> forcedRollouts) {
    this.forcedRollouts = forcedRollouts;
  }


  public NamespacedDebugInput testingMode(TestingModeEnum testingMode) {
    this.testingMode = testingMode;
    return this;
  }

  /**
   * Sets different testing modes. See the documentation in the TestingMode message for more information.
   * @return testingMode
   */
  @javax.annotation.Nullable
  public TestingModeEnum getTestingMode() {
    return testingMode;
  }

  public void setTestingMode(TestingModeEnum testingMode) {
    this.testingMode = testingMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamespacedDebugInput namespacedDebugInput = (NamespacedDebugInput) o;
    return Objects.equals(this.absolutelyForcedExpNames, namespacedDebugInput.absolutelyForcedExpNames) &&
        Objects.equals(this.absolutelyForcedExpTags, namespacedDebugInput.absolutelyForcedExpTags) &&
        Objects.equals(this.absolutelyForcedExps, namespacedDebugInput.absolutelyForcedExps) &&
        Objects.equals(this.conditionallyForcedExpNames, namespacedDebugInput.conditionallyForcedExpNames) &&
        Objects.equals(this.conditionallyForcedExpTags, namespacedDebugInput.conditionallyForcedExpTags) &&
        Objects.equals(this.conditionallyForcedExps, namespacedDebugInput.conditionallyForcedExps) &&
        Objects.equals(this.disableAutomaticEnrollmentSelection, namespacedDebugInput.disableAutomaticEnrollmentSelection) &&
        Objects.equals(this.disableExpNames, namespacedDebugInput.disableExpNames) &&
        Objects.equals(this.disableExpTags, namespacedDebugInput.disableExpTags) &&
        Objects.equals(this.disableExps, namespacedDebugInput.disableExps) &&
        Objects.equals(this.disableManualEnrollmentSelection, namespacedDebugInput.disableManualEnrollmentSelection) &&
        Objects.equals(this.disableOrganicSelection, namespacedDebugInput.disableOrganicSelection) &&
        Objects.equals(this.forcedFlags, namespacedDebugInput.forcedFlags) &&
        Objects.equals(this.forcedRollouts, namespacedDebugInput.forcedRollouts) &&
        Objects.equals(this.testingMode, namespacedDebugInput.testingMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(absolutelyForcedExpNames, absolutelyForcedExpTags, absolutelyForcedExps, conditionallyForcedExpNames, conditionallyForcedExpTags, conditionallyForcedExps, disableAutomaticEnrollmentSelection, disableExpNames, disableExpTags, disableExps, disableManualEnrollmentSelection, disableOrganicSelection, forcedFlags, forcedRollouts, testingMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamespacedDebugInput {\n");
    sb.append("    absolutelyForcedExpNames: ").append(toIndentedString(absolutelyForcedExpNames)).append("\n");
    sb.append("    absolutelyForcedExpTags: ").append(toIndentedString(absolutelyForcedExpTags)).append("\n");
    sb.append("    absolutelyForcedExps: ").append(toIndentedString(absolutelyForcedExps)).append("\n");
    sb.append("    conditionallyForcedExpNames: ").append(toIndentedString(conditionallyForcedExpNames)).append("\n");
    sb.append("    conditionallyForcedExpTags: ").append(toIndentedString(conditionallyForcedExpTags)).append("\n");
    sb.append("    conditionallyForcedExps: ").append(toIndentedString(conditionallyForcedExps)).append("\n");
    sb.append("    disableAutomaticEnrollmentSelection: ").append(toIndentedString(disableAutomaticEnrollmentSelection)).append("\n");
    sb.append("    disableExpNames: ").append(toIndentedString(disableExpNames)).append("\n");
    sb.append("    disableExpTags: ").append(toIndentedString(disableExpTags)).append("\n");
    sb.append("    disableExps: ").append(toIndentedString(disableExps)).append("\n");
    sb.append("    disableManualEnrollmentSelection: ").append(toIndentedString(disableManualEnrollmentSelection)).append("\n");
    sb.append("    disableOrganicSelection: ").append(toIndentedString(disableOrganicSelection)).append("\n");
    sb.append("    forcedFlags: ").append(toIndentedString(forcedFlags)).append("\n");
    sb.append("    forcedRollouts: ").append(toIndentedString(forcedRollouts)).append("\n");
    sb.append("    testingMode: ").append(toIndentedString(testingMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("absolutelyForcedExpNames");
    openapiFields.add("absolutelyForcedExpTags");
    openapiFields.add("absolutelyForcedExps");
    openapiFields.add("conditionallyForcedExpNames");
    openapiFields.add("conditionallyForcedExpTags");
    openapiFields.add("conditionallyForcedExps");
    openapiFields.add("disableAutomaticEnrollmentSelection");
    openapiFields.add("disableExpNames");
    openapiFields.add("disableExpTags");
    openapiFields.add("disableExps");
    openapiFields.add("disableManualEnrollmentSelection");
    openapiFields.add("disableOrganicSelection");
    openapiFields.add("forcedFlags");
    openapiFields.add("forcedRollouts");
    openapiFields.add("testingMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamespacedDebugInput
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamespacedDebugInput.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamespacedDebugInput is not found in the empty JSON string", NamespacedDebugInput.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamespacedDebugInput.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamespacedDebugInput` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("absolutelyForcedExpNames") != null && !jsonObj.get("absolutelyForcedExpNames").isJsonNull() && !jsonObj.get("absolutelyForcedExpNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `absolutelyForcedExpNames` to be an array in the JSON string but got `%s`", jsonObj.get("absolutelyForcedExpNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("absolutelyForcedExpTags") != null && !jsonObj.get("absolutelyForcedExpTags").isJsonNull() && !jsonObj.get("absolutelyForcedExpTags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `absolutelyForcedExpTags` to be an array in the JSON string but got `%s`", jsonObj.get("absolutelyForcedExpTags").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("absolutelyForcedExps") != null && !jsonObj.get("absolutelyForcedExps").isJsonNull() && !jsonObj.get("absolutelyForcedExps").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `absolutelyForcedExps` to be an array in the JSON string but got `%s`", jsonObj.get("absolutelyForcedExps").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conditionallyForcedExpNames") != null && !jsonObj.get("conditionallyForcedExpNames").isJsonNull() && !jsonObj.get("conditionallyForcedExpNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conditionallyForcedExpNames` to be an array in the JSON string but got `%s`", jsonObj.get("conditionallyForcedExpNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conditionallyForcedExpTags") != null && !jsonObj.get("conditionallyForcedExpTags").isJsonNull() && !jsonObj.get("conditionallyForcedExpTags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conditionallyForcedExpTags` to be an array in the JSON string but got `%s`", jsonObj.get("conditionallyForcedExpTags").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conditionallyForcedExps") != null && !jsonObj.get("conditionallyForcedExps").isJsonNull() && !jsonObj.get("conditionallyForcedExps").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conditionallyForcedExps` to be an array in the JSON string but got `%s`", jsonObj.get("conditionallyForcedExps").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("disableExpNames") != null && !jsonObj.get("disableExpNames").isJsonNull() && !jsonObj.get("disableExpNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `disableExpNames` to be an array in the JSON string but got `%s`", jsonObj.get("disableExpNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("disableExpTags") != null && !jsonObj.get("disableExpTags").isJsonNull() && !jsonObj.get("disableExpTags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `disableExpTags` to be an array in the JSON string but got `%s`", jsonObj.get("disableExpTags").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("disableExps") != null && !jsonObj.get("disableExps").isJsonNull() && !jsonObj.get("disableExps").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `disableExps` to be an array in the JSON string but got `%s`", jsonObj.get("disableExps").toString()));
      }
      if ((jsonObj.get("testingMode") != null && !jsonObj.get("testingMode").isJsonNull()) && !jsonObj.get("testingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testingMode").toString()));
      }
      // validate the optional field `testingMode`
      if (jsonObj.get("testingMode") != null && !jsonObj.get("testingMode").isJsonNull()) {
        TestingModeEnum.validateJsonElement(jsonObj.get("testingMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamespacedDebugInput.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamespacedDebugInput' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamespacedDebugInput> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamespacedDebugInput.class));

       return (TypeAdapter<T>) new TypeAdapter<NamespacedDebugInput>() {
           @Override
           public void write(JsonWriter out, NamespacedDebugInput value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamespacedDebugInput read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamespacedDebugInput given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamespacedDebugInput
   * @throws IOException if the JSON string is invalid with respect to NamespacedDebugInput
   */
  public static NamespacedDebugInput fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamespacedDebugInput.class);
  }

  /**
   * Convert an instance of NamespacedDebugInput to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

