/**
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v3p1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICommuteFilter.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICommuteFilter::OAICommuteFilter(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICommuteFilter::OAICommuteFilter() {
    this->initializeModel();
}

OAICommuteFilter::~OAICommuteFilter() {}

void OAICommuteFilter::initializeModel() {

    m_allow_imprecise_addresses_isSet = false;
    m_allow_imprecise_addresses_isValid = false;

    m_commute_method_isSet = false;
    m_commute_method_isValid = false;

    m_departure_time_isSet = false;
    m_departure_time_isValid = false;

    m_road_traffic_isSet = false;
    m_road_traffic_isValid = false;

    m_start_coordinates_isSet = false;
    m_start_coordinates_isValid = false;

    m_travel_duration_isSet = false;
    m_travel_duration_isValid = false;
}

void OAICommuteFilter::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICommuteFilter::fromJsonObject(QJsonObject json) {

    m_allow_imprecise_addresses_isValid = ::OpenAPI::fromJsonValue(m_allow_imprecise_addresses, json[QString("allowImpreciseAddresses")]);
    m_allow_imprecise_addresses_isSet = !json[QString("allowImpreciseAddresses")].isNull() && m_allow_imprecise_addresses_isValid;

    m_commute_method_isValid = ::OpenAPI::fromJsonValue(m_commute_method, json[QString("commuteMethod")]);
    m_commute_method_isSet = !json[QString("commuteMethod")].isNull() && m_commute_method_isValid;

    m_departure_time_isValid = ::OpenAPI::fromJsonValue(m_departure_time, json[QString("departureTime")]);
    m_departure_time_isSet = !json[QString("departureTime")].isNull() && m_departure_time_isValid;

    m_road_traffic_isValid = ::OpenAPI::fromJsonValue(m_road_traffic, json[QString("roadTraffic")]);
    m_road_traffic_isSet = !json[QString("roadTraffic")].isNull() && m_road_traffic_isValid;

    m_start_coordinates_isValid = ::OpenAPI::fromJsonValue(m_start_coordinates, json[QString("startCoordinates")]);
    m_start_coordinates_isSet = !json[QString("startCoordinates")].isNull() && m_start_coordinates_isValid;

    m_travel_duration_isValid = ::OpenAPI::fromJsonValue(m_travel_duration, json[QString("travelDuration")]);
    m_travel_duration_isSet = !json[QString("travelDuration")].isNull() && m_travel_duration_isValid;
}

QString OAICommuteFilter::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICommuteFilter::asJsonObject() const {
    QJsonObject obj;
    if (m_allow_imprecise_addresses_isSet) {
        obj.insert(QString("allowImpreciseAddresses"), ::OpenAPI::toJsonValue(m_allow_imprecise_addresses));
    }
    if (m_commute_method_isSet) {
        obj.insert(QString("commuteMethod"), ::OpenAPI::toJsonValue(m_commute_method));
    }
    if (m_departure_time.isSet()) {
        obj.insert(QString("departureTime"), ::OpenAPI::toJsonValue(m_departure_time));
    }
    if (m_road_traffic_isSet) {
        obj.insert(QString("roadTraffic"), ::OpenAPI::toJsonValue(m_road_traffic));
    }
    if (m_start_coordinates.isSet()) {
        obj.insert(QString("startCoordinates"), ::OpenAPI::toJsonValue(m_start_coordinates));
    }
    if (m_travel_duration_isSet) {
        obj.insert(QString("travelDuration"), ::OpenAPI::toJsonValue(m_travel_duration));
    }
    return obj;
}

bool OAICommuteFilter::isAllowImpreciseAddresses() const {
    return m_allow_imprecise_addresses;
}
void OAICommuteFilter::setAllowImpreciseAddresses(const bool &allow_imprecise_addresses) {
    m_allow_imprecise_addresses = allow_imprecise_addresses;
    m_allow_imprecise_addresses_isSet = true;
}

bool OAICommuteFilter::is_allow_imprecise_addresses_Set() const{
    return m_allow_imprecise_addresses_isSet;
}

bool OAICommuteFilter::is_allow_imprecise_addresses_Valid() const{
    return m_allow_imprecise_addresses_isValid;
}

QString OAICommuteFilter::getCommuteMethod() const {
    return m_commute_method;
}
void OAICommuteFilter::setCommuteMethod(const QString &commute_method) {
    m_commute_method = commute_method;
    m_commute_method_isSet = true;
}

bool OAICommuteFilter::is_commute_method_Set() const{
    return m_commute_method_isSet;
}

bool OAICommuteFilter::is_commute_method_Valid() const{
    return m_commute_method_isValid;
}

OAITimeOfDay OAICommuteFilter::getDepartureTime() const {
    return m_departure_time;
}
void OAICommuteFilter::setDepartureTime(const OAITimeOfDay &departure_time) {
    m_departure_time = departure_time;
    m_departure_time_isSet = true;
}

bool OAICommuteFilter::is_departure_time_Set() const{
    return m_departure_time_isSet;
}

bool OAICommuteFilter::is_departure_time_Valid() const{
    return m_departure_time_isValid;
}

QString OAICommuteFilter::getRoadTraffic() const {
    return m_road_traffic;
}
void OAICommuteFilter::setRoadTraffic(const QString &road_traffic) {
    m_road_traffic = road_traffic;
    m_road_traffic_isSet = true;
}

bool OAICommuteFilter::is_road_traffic_Set() const{
    return m_road_traffic_isSet;
}

bool OAICommuteFilter::is_road_traffic_Valid() const{
    return m_road_traffic_isValid;
}

OAILatLng OAICommuteFilter::getStartCoordinates() const {
    return m_start_coordinates;
}
void OAICommuteFilter::setStartCoordinates(const OAILatLng &start_coordinates) {
    m_start_coordinates = start_coordinates;
    m_start_coordinates_isSet = true;
}

bool OAICommuteFilter::is_start_coordinates_Set() const{
    return m_start_coordinates_isSet;
}

bool OAICommuteFilter::is_start_coordinates_Valid() const{
    return m_start_coordinates_isValid;
}

QString OAICommuteFilter::getTravelDuration() const {
    return m_travel_duration;
}
void OAICommuteFilter::setTravelDuration(const QString &travel_duration) {
    m_travel_duration = travel_duration;
    m_travel_duration_isSet = true;
}

bool OAICommuteFilter::is_travel_duration_Set() const{
    return m_travel_duration_isSet;
}

bool OAICommuteFilter::is_travel_duration_Valid() const{
    return m_travel_duration_isValid;
}

bool OAICommuteFilter::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allow_imprecise_addresses_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_commute_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_departure_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_road_traffic_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_coordinates.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_travel_duration_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICommuteFilter::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
