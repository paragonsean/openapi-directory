/*
 * Cloud Talent Solution API
 * Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 
 *
 * The version of the OpenAPI document: v3p1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CommuteFilter;
import org.openapitools.client.model.CompensationFilter;
import org.openapitools.client.model.LocationFilter;
import org.openapitools.client.model.TimestampRange;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Input only. The query required to perform a search query.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:17.164896-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class JobQuery {
  public static final String SERIALIZED_NAME_COMMUTE_FILTER = "commuteFilter";
  @SerializedName(SERIALIZED_NAME_COMMUTE_FILTER)
  private CommuteFilter commuteFilter;

  public static final String SERIALIZED_NAME_COMPANY_DISPLAY_NAMES = "companyDisplayNames";
  @SerializedName(SERIALIZED_NAME_COMPANY_DISPLAY_NAMES)
  private List<String> companyDisplayNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_COMPANY_NAMES = "companyNames";
  @SerializedName(SERIALIZED_NAME_COMPANY_NAMES)
  private List<String> companyNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_COMPENSATION_FILTER = "compensationFilter";
  @SerializedName(SERIALIZED_NAME_COMPENSATION_FILTER)
  private CompensationFilter compensationFilter;

  public static final String SERIALIZED_NAME_CUSTOM_ATTRIBUTE_FILTER = "customAttributeFilter";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ATTRIBUTE_FILTER)
  private String customAttributeFilter;

  public static final String SERIALIZED_NAME_DISABLE_SPELL_CHECK = "disableSpellCheck";
  @SerializedName(SERIALIZED_NAME_DISABLE_SPELL_CHECK)
  private Boolean disableSpellCheck;

  /**
   * Gets or Sets employmentTypes
   */
  @JsonAdapter(EmploymentTypesEnum.Adapter.class)
  public enum EmploymentTypesEnum {
    EMPLOYMENT_TYPE_UNSPECIFIED("EMPLOYMENT_TYPE_UNSPECIFIED"),
    
    FULL_TIME("FULL_TIME"),
    
    PART_TIME("PART_TIME"),
    
    CONTRACTOR("CONTRACTOR"),
    
    CONTRACT_TO_HIRE("CONTRACT_TO_HIRE"),
    
    TEMPORARY("TEMPORARY"),
    
    INTERN("INTERN"),
    
    VOLUNTEER("VOLUNTEER"),
    
    PER_DIEM("PER_DIEM"),
    
    FLY_IN_FLY_OUT("FLY_IN_FLY_OUT"),
    
    OTHER_EMPLOYMENT_TYPE("OTHER_EMPLOYMENT_TYPE");

    private String value;

    EmploymentTypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EmploymentTypesEnum fromValue(String value) {
      for (EmploymentTypesEnum b : EmploymentTypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EmploymentTypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EmploymentTypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EmploymentTypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EmploymentTypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EmploymentTypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EMPLOYMENT_TYPES = "employmentTypes";
  @SerializedName(SERIALIZED_NAME_EMPLOYMENT_TYPES)
  private List<EmploymentTypesEnum> employmentTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDED_JOBS = "excludedJobs";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_JOBS)
  private List<String> excludedJobs = new ArrayList<>();

  /**
   * Gets or Sets jobCategories
   */
  @JsonAdapter(JobCategoriesEnum.Adapter.class)
  public enum JobCategoriesEnum {
    JOB_CATEGORY_UNSPECIFIED("JOB_CATEGORY_UNSPECIFIED"),
    
    ACCOUNTING_AND_FINANCE("ACCOUNTING_AND_FINANCE"),
    
    ADMINISTRATIVE_AND_OFFICE("ADMINISTRATIVE_AND_OFFICE"),
    
    ADVERTISING_AND_MARKETING("ADVERTISING_AND_MARKETING"),
    
    ANIMAL_CARE("ANIMAL_CARE"),
    
    ART_FASHION_AND_DESIGN("ART_FASHION_AND_DESIGN"),
    
    BUSINESS_OPERATIONS("BUSINESS_OPERATIONS"),
    
    CLEANING_AND_FACILITIES("CLEANING_AND_FACILITIES"),
    
    COMPUTER_AND_IT("COMPUTER_AND_IT"),
    
    CONSTRUCTION("CONSTRUCTION"),
    
    CUSTOMER_SERVICE("CUSTOMER_SERVICE"),
    
    EDUCATION("EDUCATION"),
    
    ENTERTAINMENT_AND_TRAVEL("ENTERTAINMENT_AND_TRAVEL"),
    
    FARMING_AND_OUTDOORS("FARMING_AND_OUTDOORS"),
    
    HEALTHCARE("HEALTHCARE"),
    
    HUMAN_RESOURCES("HUMAN_RESOURCES"),
    
    INSTALLATION_MAINTENANCE_AND_REPAIR("INSTALLATION_MAINTENANCE_AND_REPAIR"),
    
    LEGAL("LEGAL"),
    
    MANAGEMENT("MANAGEMENT"),
    
    MANUFACTURING_AND_WAREHOUSE("MANUFACTURING_AND_WAREHOUSE"),
    
    MEDIA_COMMUNICATIONS_AND_WRITING("MEDIA_COMMUNICATIONS_AND_WRITING"),
    
    OIL_GAS_AND_MINING("OIL_GAS_AND_MINING"),
    
    PERSONAL_CARE_AND_SERVICES("PERSONAL_CARE_AND_SERVICES"),
    
    PROTECTIVE_SERVICES("PROTECTIVE_SERVICES"),
    
    REAL_ESTATE("REAL_ESTATE"),
    
    RESTAURANT_AND_HOSPITALITY("RESTAURANT_AND_HOSPITALITY"),
    
    SALES_AND_RETAIL("SALES_AND_RETAIL"),
    
    SCIENCE_AND_ENGINEERING("SCIENCE_AND_ENGINEERING"),
    
    SOCIAL_SERVICES_AND_NON_PROFIT("SOCIAL_SERVICES_AND_NON_PROFIT"),
    
    SPORTS_FITNESS_AND_RECREATION("SPORTS_FITNESS_AND_RECREATION"),
    
    TRANSPORTATION_AND_LOGISTICS("TRANSPORTATION_AND_LOGISTICS");

    private String value;

    JobCategoriesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static JobCategoriesEnum fromValue(String value) {
      for (JobCategoriesEnum b : JobCategoriesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<JobCategoriesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobCategoriesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public JobCategoriesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return JobCategoriesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      JobCategoriesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_JOB_CATEGORIES = "jobCategories";
  @SerializedName(SERIALIZED_NAME_JOB_CATEGORIES)
  private List<JobCategoriesEnum> jobCategories = new ArrayList<>();

  public static final String SERIALIZED_NAME_LANGUAGE_CODES = "languageCodes";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODES)
  private List<String> languageCodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCATION_FILTERS = "locationFilters";
  @SerializedName(SERIALIZED_NAME_LOCATION_FILTERS)
  private List<LocationFilter> locationFilters = new ArrayList<>();

  public static final String SERIALIZED_NAME_PUBLISH_TIME_RANGE = "publishTimeRange";
  @SerializedName(SERIALIZED_NAME_PUBLISH_TIME_RANGE)
  private TimestampRange publishTimeRange;

  public static final String SERIALIZED_NAME_QUERY = "query";
  @SerializedName(SERIALIZED_NAME_QUERY)
  private String query;

  public static final String SERIALIZED_NAME_QUERY_LANGUAGE_CODE = "queryLanguageCode";
  @SerializedName(SERIALIZED_NAME_QUERY_LANGUAGE_CODE)
  private String queryLanguageCode;

  public JobQuery() {
  }

  public JobQuery commuteFilter(CommuteFilter commuteFilter) {
    this.commuteFilter = commuteFilter;
    return this;
  }

  /**
   * Get commuteFilter
   * @return commuteFilter
   */
  @javax.annotation.Nullable
  public CommuteFilter getCommuteFilter() {
    return commuteFilter;
  }

  public void setCommuteFilter(CommuteFilter commuteFilter) {
    this.commuteFilter = commuteFilter;
  }


  public JobQuery companyDisplayNames(List<String> companyDisplayNames) {
    this.companyDisplayNames = companyDisplayNames;
    return this;
  }

  public JobQuery addCompanyDisplayNamesItem(String companyDisplayNamesItem) {
    if (this.companyDisplayNames == null) {
      this.companyDisplayNames = new ArrayList<>();
    }
    this.companyDisplayNames.add(companyDisplayNamesItem);
    return this;
  }

  /**
   * Optional. This filter specifies the company Company.display_name of the jobs to search against. The company name must match the value exactly. Alternatively, the value being searched for can be wrapped in different match operators. &#x60;SUBSTRING_MATCH([value])&#x60; The company name must contain a case insensitive substring match of the value. Using this function may increase latency. Sample Value: &#x60;SUBSTRING_MATCH(google)&#x60; &#x60;MULTI_WORD_TOKEN_MATCH([value])&#x60; The value will be treated as a multi word token and the company name must contain a case insensitive match of the value. Using this function may increase latency. Sample Value: &#x60;MULTI_WORD_TOKEN_MATCH(google)&#x60; If a value isn&#39;t specified, jobs within the search results are associated with any company. If multiple values are specified, jobs within the search results may be associated with any of the specified companies. At most 20 company display name filters are allowed.
   * @return companyDisplayNames
   */
  @javax.annotation.Nullable
  public List<String> getCompanyDisplayNames() {
    return companyDisplayNames;
  }

  public void setCompanyDisplayNames(List<String> companyDisplayNames) {
    this.companyDisplayNames = companyDisplayNames;
  }


  public JobQuery companyNames(List<String> companyNames) {
    this.companyNames = companyNames;
    return this;
  }

  public JobQuery addCompanyNamesItem(String companyNamesItem) {
    if (this.companyNames == null) {
      this.companyNames = new ArrayList<>();
    }
    this.companyNames.add(companyNamesItem);
    return this;
  }

  /**
   * Optional. This filter specifies the company entities to search against. If a value isn&#39;t specified, jobs are searched for against all companies. If multiple values are specified, jobs are searched against the companies specified. The format is \&quot;projects/{project_id}/companies/{company_id}\&quot;, for example, \&quot;projects/api-test-project/companies/foo\&quot;. At most 20 company filters are allowed.
   * @return companyNames
   */
  @javax.annotation.Nullable
  public List<String> getCompanyNames() {
    return companyNames;
  }

  public void setCompanyNames(List<String> companyNames) {
    this.companyNames = companyNames;
  }


  public JobQuery compensationFilter(CompensationFilter compensationFilter) {
    this.compensationFilter = compensationFilter;
    return this;
  }

  /**
   * Get compensationFilter
   * @return compensationFilter
   */
  @javax.annotation.Nullable
  public CompensationFilter getCompensationFilter() {
    return compensationFilter;
  }

  public void setCompensationFilter(CompensationFilter compensationFilter) {
    this.compensationFilter = compensationFilter;
  }


  public JobQuery customAttributeFilter(String customAttributeFilter) {
    this.customAttributeFilter = customAttributeFilter;
    return this;
  }

  /**
   * Optional. This filter specifies a structured syntax to match against the Job.custom_attributes marked as &#x60;filterable&#x60;. The syntax for this expression is a subset of SQL syntax. Supported operators are: &#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, and &#x60;&gt;&#x3D;&#x60; where the left of the operator is a custom field key and the right of the operator is a number or a quoted string. You must escape backslash (\\\\) and quote (\\\&quot;) characters. Supported functions are &#x60;LOWER([field_name])&#x60; to perform a case insensitive match and &#x60;EMPTY([field_name])&#x60; to filter on the existence of a key. Boolean expressions (AND/OR/NOT) are supported up to 3 levels of nesting (for example, \&quot;((A AND B AND C) OR NOT D) AND E\&quot;), a maximum of 100 comparisons or functions are allowed in the expression. The expression must be &lt; 10000 bytes in length. Sample Query: &#x60;(LOWER(driving_license)&#x3D;\&quot;class \\\&quot;a\\\&quot;\&quot; OR EMPTY(driving_license)) AND driving_years &gt; 10&#x60;
   * @return customAttributeFilter
   */
  @javax.annotation.Nullable
  public String getCustomAttributeFilter() {
    return customAttributeFilter;
  }

  public void setCustomAttributeFilter(String customAttributeFilter) {
    this.customAttributeFilter = customAttributeFilter;
  }


  public JobQuery disableSpellCheck(Boolean disableSpellCheck) {
    this.disableSpellCheck = disableSpellCheck;
    return this;
  }

  /**
   * Optional. This flag controls the spell-check feature. If false, the service attempts to correct a misspelled query, for example, \&quot;enginee\&quot; is corrected to \&quot;engineer\&quot;. Defaults to false: a spell check is performed.
   * @return disableSpellCheck
   */
  @javax.annotation.Nullable
  public Boolean getDisableSpellCheck() {
    return disableSpellCheck;
  }

  public void setDisableSpellCheck(Boolean disableSpellCheck) {
    this.disableSpellCheck = disableSpellCheck;
  }


  public JobQuery employmentTypes(List<EmploymentTypesEnum> employmentTypes) {
    this.employmentTypes = employmentTypes;
    return this;
  }

  public JobQuery addEmploymentTypesItem(EmploymentTypesEnum employmentTypesItem) {
    if (this.employmentTypes == null) {
      this.employmentTypes = new ArrayList<>();
    }
    this.employmentTypes.add(employmentTypesItem);
    return this;
  }

  /**
   * Optional. The employment type filter specifies the employment type of jobs to search against, such as EmploymentType.FULL_TIME. If a value is not specified, jobs in the search results includes any employment type. If multiple values are specified, jobs in the search results include any of the specified employment types.
   * @return employmentTypes
   */
  @javax.annotation.Nullable
  public List<EmploymentTypesEnum> getEmploymentTypes() {
    return employmentTypes;
  }

  public void setEmploymentTypes(List<EmploymentTypesEnum> employmentTypes) {
    this.employmentTypes = employmentTypes;
  }


  public JobQuery excludedJobs(List<String> excludedJobs) {
    this.excludedJobs = excludedJobs;
    return this;
  }

  public JobQuery addExcludedJobsItem(String excludedJobsItem) {
    if (this.excludedJobs == null) {
      this.excludedJobs = new ArrayList<>();
    }
    this.excludedJobs.add(excludedJobsItem);
    return this;
  }

  /**
   * Optional. This filter specifies a list of job names to be excluded during search. At most 400 excluded job names are allowed.
   * @return excludedJobs
   */
  @javax.annotation.Nullable
  public List<String> getExcludedJobs() {
    return excludedJobs;
  }

  public void setExcludedJobs(List<String> excludedJobs) {
    this.excludedJobs = excludedJobs;
  }


  public JobQuery jobCategories(List<JobCategoriesEnum> jobCategories) {
    this.jobCategories = jobCategories;
    return this;
  }

  public JobQuery addJobCategoriesItem(JobCategoriesEnum jobCategoriesItem) {
    if (this.jobCategories == null) {
      this.jobCategories = new ArrayList<>();
    }
    this.jobCategories.add(jobCategoriesItem);
    return this;
  }

  /**
   * Optional. The category filter specifies the categories of jobs to search against. See Category for more information. If a value is not specified, jobs from any category are searched against. If multiple values are specified, jobs from any of the specified categories are searched against.
   * @return jobCategories
   */
  @javax.annotation.Nullable
  public List<JobCategoriesEnum> getJobCategories() {
    return jobCategories;
  }

  public void setJobCategories(List<JobCategoriesEnum> jobCategories) {
    this.jobCategories = jobCategories;
  }


  public JobQuery languageCodes(List<String> languageCodes) {
    this.languageCodes = languageCodes;
    return this;
  }

  public JobQuery addLanguageCodesItem(String languageCodesItem) {
    if (this.languageCodes == null) {
      this.languageCodes = new ArrayList<>();
    }
    this.languageCodes.add(languageCodesItem);
    return this;
  }

  /**
   * Optional. This filter specifies the locale of jobs to search against, for example, \&quot;en-US\&quot;. If a value isn&#39;t specified, the search results can contain jobs in any locale. Language codes should be in BCP-47 format, such as \&quot;en-US\&quot; or \&quot;sr-Latn\&quot;. For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47). At most 10 language code filters are allowed.
   * @return languageCodes
   */
  @javax.annotation.Nullable
  public List<String> getLanguageCodes() {
    return languageCodes;
  }

  public void setLanguageCodes(List<String> languageCodes) {
    this.languageCodes = languageCodes;
  }


  public JobQuery locationFilters(List<LocationFilter> locationFilters) {
    this.locationFilters = locationFilters;
    return this;
  }

  public JobQuery addLocationFiltersItem(LocationFilter locationFiltersItem) {
    if (this.locationFilters == null) {
      this.locationFilters = new ArrayList<>();
    }
    this.locationFilters.add(locationFiltersItem);
    return this;
  }

  /**
   * Optional. The location filter specifies geo-regions containing the jobs to search against. See LocationFilter for more information. If a location value isn&#39;t specified, jobs fitting the other search criteria are retrieved regardless of where they&#39;re located. If multiple values are specified, jobs are retrieved from any of the specified locations. If different values are specified for the LocationFilter.distance_in_miles parameter, the maximum provided distance is used for all locations. At most 5 location filters are allowed.
   * @return locationFilters
   */
  @javax.annotation.Nullable
  public List<LocationFilter> getLocationFilters() {
    return locationFilters;
  }

  public void setLocationFilters(List<LocationFilter> locationFilters) {
    this.locationFilters = locationFilters;
  }


  public JobQuery publishTimeRange(TimestampRange publishTimeRange) {
    this.publishTimeRange = publishTimeRange;
    return this;
  }

  /**
   * Get publishTimeRange
   * @return publishTimeRange
   */
  @javax.annotation.Nullable
  public TimestampRange getPublishTimeRange() {
    return publishTimeRange;
  }

  public void setPublishTimeRange(TimestampRange publishTimeRange) {
    this.publishTimeRange = publishTimeRange;
  }


  public JobQuery query(String query) {
    this.query = query;
    return this;
  }

  /**
   * Optional. The query string that matches against the job title, description, and location fields. The maximum number of allowed characters is 255.
   * @return query
   */
  @javax.annotation.Nullable
  public String getQuery() {
    return query;
  }

  public void setQuery(String query) {
    this.query = query;
  }


  public JobQuery queryLanguageCode(String queryLanguageCode) {
    this.queryLanguageCode = queryLanguageCode;
    return this;
  }

  /**
   * The language code of query. For example, \&quot;en-US\&quot;. This field helps to better interpret the query. If a value isn&#39;t specified, the query language code is automatically detected, which may not be accurate. Language code should be in BCP-47 format, such as \&quot;en-US\&quot; or \&quot;sr-Latn\&quot;. For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
   * @return queryLanguageCode
   */
  @javax.annotation.Nullable
  public String getQueryLanguageCode() {
    return queryLanguageCode;
  }

  public void setQueryLanguageCode(String queryLanguageCode) {
    this.queryLanguageCode = queryLanguageCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobQuery jobQuery = (JobQuery) o;
    return Objects.equals(this.commuteFilter, jobQuery.commuteFilter) &&
        Objects.equals(this.companyDisplayNames, jobQuery.companyDisplayNames) &&
        Objects.equals(this.companyNames, jobQuery.companyNames) &&
        Objects.equals(this.compensationFilter, jobQuery.compensationFilter) &&
        Objects.equals(this.customAttributeFilter, jobQuery.customAttributeFilter) &&
        Objects.equals(this.disableSpellCheck, jobQuery.disableSpellCheck) &&
        Objects.equals(this.employmentTypes, jobQuery.employmentTypes) &&
        Objects.equals(this.excludedJobs, jobQuery.excludedJobs) &&
        Objects.equals(this.jobCategories, jobQuery.jobCategories) &&
        Objects.equals(this.languageCodes, jobQuery.languageCodes) &&
        Objects.equals(this.locationFilters, jobQuery.locationFilters) &&
        Objects.equals(this.publishTimeRange, jobQuery.publishTimeRange) &&
        Objects.equals(this.query, jobQuery.query) &&
        Objects.equals(this.queryLanguageCode, jobQuery.queryLanguageCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(commuteFilter, companyDisplayNames, companyNames, compensationFilter, customAttributeFilter, disableSpellCheck, employmentTypes, excludedJobs, jobCategories, languageCodes, locationFilters, publishTimeRange, query, queryLanguageCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobQuery {\n");
    sb.append("    commuteFilter: ").append(toIndentedString(commuteFilter)).append("\n");
    sb.append("    companyDisplayNames: ").append(toIndentedString(companyDisplayNames)).append("\n");
    sb.append("    companyNames: ").append(toIndentedString(companyNames)).append("\n");
    sb.append("    compensationFilter: ").append(toIndentedString(compensationFilter)).append("\n");
    sb.append("    customAttributeFilter: ").append(toIndentedString(customAttributeFilter)).append("\n");
    sb.append("    disableSpellCheck: ").append(toIndentedString(disableSpellCheck)).append("\n");
    sb.append("    employmentTypes: ").append(toIndentedString(employmentTypes)).append("\n");
    sb.append("    excludedJobs: ").append(toIndentedString(excludedJobs)).append("\n");
    sb.append("    jobCategories: ").append(toIndentedString(jobCategories)).append("\n");
    sb.append("    languageCodes: ").append(toIndentedString(languageCodes)).append("\n");
    sb.append("    locationFilters: ").append(toIndentedString(locationFilters)).append("\n");
    sb.append("    publishTimeRange: ").append(toIndentedString(publishTimeRange)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    queryLanguageCode: ").append(toIndentedString(queryLanguageCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("commuteFilter");
    openapiFields.add("companyDisplayNames");
    openapiFields.add("companyNames");
    openapiFields.add("compensationFilter");
    openapiFields.add("customAttributeFilter");
    openapiFields.add("disableSpellCheck");
    openapiFields.add("employmentTypes");
    openapiFields.add("excludedJobs");
    openapiFields.add("jobCategories");
    openapiFields.add("languageCodes");
    openapiFields.add("locationFilters");
    openapiFields.add("publishTimeRange");
    openapiFields.add("query");
    openapiFields.add("queryLanguageCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to JobQuery
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JobQuery.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JobQuery is not found in the empty JSON string", JobQuery.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JobQuery.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JobQuery` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `commuteFilter`
      if (jsonObj.get("commuteFilter") != null && !jsonObj.get("commuteFilter").isJsonNull()) {
        CommuteFilter.validateJsonElement(jsonObj.get("commuteFilter"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("companyDisplayNames") != null && !jsonObj.get("companyDisplayNames").isJsonNull() && !jsonObj.get("companyDisplayNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyDisplayNames` to be an array in the JSON string but got `%s`", jsonObj.get("companyDisplayNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("companyNames") != null && !jsonObj.get("companyNames").isJsonNull() && !jsonObj.get("companyNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `companyNames` to be an array in the JSON string but got `%s`", jsonObj.get("companyNames").toString()));
      }
      // validate the optional field `compensationFilter`
      if (jsonObj.get("compensationFilter") != null && !jsonObj.get("compensationFilter").isJsonNull()) {
        CompensationFilter.validateJsonElement(jsonObj.get("compensationFilter"));
      }
      if ((jsonObj.get("customAttributeFilter") != null && !jsonObj.get("customAttributeFilter").isJsonNull()) && !jsonObj.get("customAttributeFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customAttributeFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customAttributeFilter").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("employmentTypes") != null && !jsonObj.get("employmentTypes").isJsonNull() && !jsonObj.get("employmentTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `employmentTypes` to be an array in the JSON string but got `%s`", jsonObj.get("employmentTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedJobs") != null && !jsonObj.get("excludedJobs").isJsonNull() && !jsonObj.get("excludedJobs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedJobs` to be an array in the JSON string but got `%s`", jsonObj.get("excludedJobs").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("jobCategories") != null && !jsonObj.get("jobCategories").isJsonNull() && !jsonObj.get("jobCategories").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobCategories` to be an array in the JSON string but got `%s`", jsonObj.get("jobCategories").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("languageCodes") != null && !jsonObj.get("languageCodes").isJsonNull() && !jsonObj.get("languageCodes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `languageCodes` to be an array in the JSON string but got `%s`", jsonObj.get("languageCodes").toString()));
      }
      if (jsonObj.get("locationFilters") != null && !jsonObj.get("locationFilters").isJsonNull()) {
        JsonArray jsonArraylocationFilters = jsonObj.getAsJsonArray("locationFilters");
        if (jsonArraylocationFilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("locationFilters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `locationFilters` to be an array in the JSON string but got `%s`", jsonObj.get("locationFilters").toString()));
          }

          // validate the optional field `locationFilters` (array)
          for (int i = 0; i < jsonArraylocationFilters.size(); i++) {
            LocationFilter.validateJsonElement(jsonArraylocationFilters.get(i));
          };
        }
      }
      // validate the optional field `publishTimeRange`
      if (jsonObj.get("publishTimeRange") != null && !jsonObj.get("publishTimeRange").isJsonNull()) {
        TimestampRange.validateJsonElement(jsonObj.get("publishTimeRange"));
      }
      if ((jsonObj.get("query") != null && !jsonObj.get("query").isJsonNull()) && !jsonObj.get("query").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `query` to be a primitive type in the JSON string but got `%s`", jsonObj.get("query").toString()));
      }
      if ((jsonObj.get("queryLanguageCode") != null && !jsonObj.get("queryLanguageCode").isJsonNull()) && !jsonObj.get("queryLanguageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queryLanguageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queryLanguageCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JobQuery.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JobQuery' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JobQuery> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JobQuery.class));

       return (TypeAdapter<T>) new TypeAdapter<JobQuery>() {
           @Override
           public void write(JsonWriter out, JobQuery value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JobQuery read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of JobQuery given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of JobQuery
   * @throws IOException if the JSON string is invalid with respect to JobQuery
   */
  public static JobQuery fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JobQuery.class);
  }

  /**
   * Convert an instance of JobQuery to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

