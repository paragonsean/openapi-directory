/**
 * Google Analytics Admin API
 * Manage properties in Google Analytics. Warning: Creating multiple Customer Applications, Accounts, or Projects to simulate or act as a single Customer Application, Account, or Project (respectively) or to circumvent Service-specific usage limits or quotas is a direct violation of Google Cloud Platform Terms of Service as well as Google APIs Terms of Service. These actions can result in immediate termination of your GCP project(s) without any warning.
 *
 * The version of the OpenAPI document: v1alpha
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGoogleAnalyticsAdminV1alphaMatchingCondition.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGoogleAnalyticsAdminV1alphaMatchingCondition::OAIGoogleAnalyticsAdminV1alphaMatchingCondition(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGoogleAnalyticsAdminV1alphaMatchingCondition::OAIGoogleAnalyticsAdminV1alphaMatchingCondition() {
    this->initializeModel();
}

OAIGoogleAnalyticsAdminV1alphaMatchingCondition::~OAIGoogleAnalyticsAdminV1alphaMatchingCondition() {}

void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::initializeModel() {

    m_comparison_type_isSet = false;
    m_comparison_type_isValid = false;

    m_field_isSet = false;
    m_field_isValid = false;

    m_negated_isSet = false;
    m_negated_isValid = false;

    m_value_isSet = false;
    m_value_isValid = false;
}

void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::fromJsonObject(QJsonObject json) {

    m_comparison_type_isValid = ::OpenAPI::fromJsonValue(m_comparison_type, json[QString("comparisonType")]);
    m_comparison_type_isSet = !json[QString("comparisonType")].isNull() && m_comparison_type_isValid;

    m_field_isValid = ::OpenAPI::fromJsonValue(m_field, json[QString("field")]);
    m_field_isSet = !json[QString("field")].isNull() && m_field_isValid;

    m_negated_isValid = ::OpenAPI::fromJsonValue(m_negated, json[QString("negated")]);
    m_negated_isSet = !json[QString("negated")].isNull() && m_negated_isValid;

    m_value_isValid = ::OpenAPI::fromJsonValue(m_value, json[QString("value")]);
    m_value_isSet = !json[QString("value")].isNull() && m_value_isValid;
}

QString OAIGoogleAnalyticsAdminV1alphaMatchingCondition::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGoogleAnalyticsAdminV1alphaMatchingCondition::asJsonObject() const {
    QJsonObject obj;
    if (m_comparison_type_isSet) {
        obj.insert(QString("comparisonType"), ::OpenAPI::toJsonValue(m_comparison_type));
    }
    if (m_field_isSet) {
        obj.insert(QString("field"), ::OpenAPI::toJsonValue(m_field));
    }
    if (m_negated_isSet) {
        obj.insert(QString("negated"), ::OpenAPI::toJsonValue(m_negated));
    }
    if (m_value_isSet) {
        obj.insert(QString("value"), ::OpenAPI::toJsonValue(m_value));
    }
    return obj;
}

QString OAIGoogleAnalyticsAdminV1alphaMatchingCondition::getComparisonType() const {
    return m_comparison_type;
}
void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::setComparisonType(const QString &comparison_type) {
    m_comparison_type = comparison_type;
    m_comparison_type_isSet = true;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_comparison_type_Set() const{
    return m_comparison_type_isSet;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_comparison_type_Valid() const{
    return m_comparison_type_isValid;
}

QString OAIGoogleAnalyticsAdminV1alphaMatchingCondition::getField() const {
    return m_field;
}
void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::setField(const QString &field) {
    m_field = field;
    m_field_isSet = true;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_field_Set() const{
    return m_field_isSet;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_field_Valid() const{
    return m_field_isValid;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::isNegated() const {
    return m_negated;
}
void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::setNegated(const bool &negated) {
    m_negated = negated;
    m_negated_isSet = true;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_negated_Set() const{
    return m_negated_isSet;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_negated_Valid() const{
    return m_negated_isValid;
}

QString OAIGoogleAnalyticsAdminV1alphaMatchingCondition::getValue() const {
    return m_value;
}
void OAIGoogleAnalyticsAdminV1alphaMatchingCondition::setValue(const QString &value) {
    m_value = value;
    m_value_isSet = true;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_value_Set() const{
    return m_value_isSet;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::is_value_Valid() const{
    return m_value_isValid;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_comparison_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_field_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_negated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_value_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGoogleAnalyticsAdminV1alphaMatchingCondition::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
