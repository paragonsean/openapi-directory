# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class RestoreServiceRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, backup: str=None, backup_location: str=None, request_id: str=None, restore_type: str=None):
        """RestoreServiceRequest - a model defined in OpenAPI

        :param backup: The backup of this RestoreServiceRequest.
        :param backup_location: The backup_location of this RestoreServiceRequest.
        :param request_id: The request_id of this RestoreServiceRequest.
        :param restore_type: The restore_type of this RestoreServiceRequest.
        """
        self.openapi_types = {
            'backup': str,
            'backup_location': str,
            'request_id': str,
            'restore_type': str
        }

        self.attribute_map = {
            'backup': 'backup',
            'backup_location': 'backupLocation',
            'request_id': 'requestId',
            'restore_type': 'restoreType'
        }

        self._backup = backup
        self._backup_location = backup_location
        self._request_id = request_id
        self._restore_type = restore_type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'RestoreServiceRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The RestoreServiceRequest of this RestoreServiceRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def backup(self):
        """Gets the backup of this RestoreServiceRequest.

        Optional. The relative resource name of the metastore service backup to restore from, in the following form:projects/{project_id}/locations/{location_id}/services/{service_id}/backups/{backup_id}. Mutually exclusive with backup_location, and exactly one of the two must be set.

        :return: The backup of this RestoreServiceRequest.
        :rtype: str
        """
        return self._backup

    @backup.setter
    def backup(self, backup):
        """Sets the backup of this RestoreServiceRequest.

        Optional. The relative resource name of the metastore service backup to restore from, in the following form:projects/{project_id}/locations/{location_id}/services/{service_id}/backups/{backup_id}. Mutually exclusive with backup_location, and exactly one of the two must be set.

        :param backup: The backup of this RestoreServiceRequest.
        :type backup: str
        """

        self._backup = backup

    @property
    def backup_location(self):
        """Gets the backup_location of this RestoreServiceRequest.

        Optional. A Cloud Storage URI specifying the location of the backup artifacts, namely - backup avro files under \"avro/\", backup_metastore.json and service.json, in the following form:gs://. Mutually exclusive with backup, and exactly one of the two must be set.

        :return: The backup_location of this RestoreServiceRequest.
        :rtype: str
        """
        return self._backup_location

    @backup_location.setter
    def backup_location(self, backup_location):
        """Sets the backup_location of this RestoreServiceRequest.

        Optional. A Cloud Storage URI specifying the location of the backup artifacts, namely - backup avro files under \"avro/\", backup_metastore.json and service.json, in the following form:gs://. Mutually exclusive with backup, and exactly one of the two must be set.

        :param backup_location: The backup_location of this RestoreServiceRequest.
        :type backup_location: str
        """

        self._backup_location = backup_location

    @property
    def request_id(self):
        """Gets the request_id of this RestoreServiceRequest.

        Optional. A request ID. Specify a unique request ID to allow the server to ignore the request if it has completed. The server will ignore subsequent requests that provide a duplicate request ID for at least 60 minutes after the first request.For example, if an initial request times out, followed by another request with the same request ID, the server ignores the second request to prevent the creation of duplicate commitments.The request ID must be a valid UUID (https://en.wikipedia.org/wiki/Universally_unique_identifier#Format). A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.

        :return: The request_id of this RestoreServiceRequest.
        :rtype: str
        """
        return self._request_id

    @request_id.setter
    def request_id(self, request_id):
        """Sets the request_id of this RestoreServiceRequest.

        Optional. A request ID. Specify a unique request ID to allow the server to ignore the request if it has completed. The server will ignore subsequent requests that provide a duplicate request ID for at least 60 minutes after the first request.For example, if an initial request times out, followed by another request with the same request ID, the server ignores the second request to prevent the creation of duplicate commitments.The request ID must be a valid UUID (https://en.wikipedia.org/wiki/Universally_unique_identifier#Format). A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.

        :param request_id: The request_id of this RestoreServiceRequest.
        :type request_id: str
        """

        self._request_id = request_id

    @property
    def restore_type(self):
        """Gets the restore_type of this RestoreServiceRequest.

        Optional. The type of restore. If unspecified, defaults to METADATA_ONLY.

        :return: The restore_type of this RestoreServiceRequest.
        :rtype: str
        """
        return self._restore_type

    @restore_type.setter
    def restore_type(self, restore_type):
        """Sets the restore_type of this RestoreServiceRequest.

        Optional. The type of restore. If unspecified, defaults to METADATA_ONLY.

        :param restore_type: The restore_type of this RestoreServiceRequest.
        :type restore_type: str
        """
        allowed_values = ["RESTORE_TYPE_UNSPECIFIED", "FULL", "METADATA_ONLY"]  # noqa: E501
        if restore_type not in allowed_values:
            raise ValueError(
                "Invalid value for `restore_type` ({0}), must be one of {1}"
                .format(restore_type, allowed_values)
            )

        self._restore_type = restore_type
