/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Duplicates the contents of a sheet.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DuplicateSheetRequest {
  public static final String SERIALIZED_NAME_INSERT_SHEET_INDEX = "insertSheetIndex";
  @SerializedName(SERIALIZED_NAME_INSERT_SHEET_INDEX)
  private Integer insertSheetIndex;

  public static final String SERIALIZED_NAME_NEW_SHEET_ID = "newSheetId";
  @SerializedName(SERIALIZED_NAME_NEW_SHEET_ID)
  private Integer newSheetId;

  public static final String SERIALIZED_NAME_NEW_SHEET_NAME = "newSheetName";
  @SerializedName(SERIALIZED_NAME_NEW_SHEET_NAME)
  private String newSheetName;

  public static final String SERIALIZED_NAME_SOURCE_SHEET_ID = "sourceSheetId";
  @SerializedName(SERIALIZED_NAME_SOURCE_SHEET_ID)
  private Integer sourceSheetId;

  public DuplicateSheetRequest() {
  }

  public DuplicateSheetRequest insertSheetIndex(Integer insertSheetIndex) {
    this.insertSheetIndex = insertSheetIndex;
    return this;
  }

  /**
   * The zero-based index where the new sheet should be inserted. The index of all sheets after this are incremented.
   * @return insertSheetIndex
   */
  @javax.annotation.Nullable
  public Integer getInsertSheetIndex() {
    return insertSheetIndex;
  }

  public void setInsertSheetIndex(Integer insertSheetIndex) {
    this.insertSheetIndex = insertSheetIndex;
  }


  public DuplicateSheetRequest newSheetId(Integer newSheetId) {
    this.newSheetId = newSheetId;
    return this;
  }

  /**
   * If set, the ID of the new sheet. If not set, an ID is chosen. If set, the ID must not conflict with any existing sheet ID. If set, it must be non-negative.
   * @return newSheetId
   */
  @javax.annotation.Nullable
  public Integer getNewSheetId() {
    return newSheetId;
  }

  public void setNewSheetId(Integer newSheetId) {
    this.newSheetId = newSheetId;
  }


  public DuplicateSheetRequest newSheetName(String newSheetName) {
    this.newSheetName = newSheetName;
    return this;
  }

  /**
   * The name of the new sheet. If empty, a new name is chosen for you.
   * @return newSheetName
   */
  @javax.annotation.Nullable
  public String getNewSheetName() {
    return newSheetName;
  }

  public void setNewSheetName(String newSheetName) {
    this.newSheetName = newSheetName;
  }


  public DuplicateSheetRequest sourceSheetId(Integer sourceSheetId) {
    this.sourceSheetId = sourceSheetId;
    return this;
  }

  /**
   * The sheet to duplicate. If the source sheet is of DATA_SOURCE type, its backing DataSource is also duplicated and associated with the new copy of the sheet. No data execution is triggered, the grid data of this sheet is also copied over but only available after the batch request completes.
   * @return sourceSheetId
   */
  @javax.annotation.Nullable
  public Integer getSourceSheetId() {
    return sourceSheetId;
  }

  public void setSourceSheetId(Integer sourceSheetId) {
    this.sourceSheetId = sourceSheetId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DuplicateSheetRequest duplicateSheetRequest = (DuplicateSheetRequest) o;
    return Objects.equals(this.insertSheetIndex, duplicateSheetRequest.insertSheetIndex) &&
        Objects.equals(this.newSheetId, duplicateSheetRequest.newSheetId) &&
        Objects.equals(this.newSheetName, duplicateSheetRequest.newSheetName) &&
        Objects.equals(this.sourceSheetId, duplicateSheetRequest.sourceSheetId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(insertSheetIndex, newSheetId, newSheetName, sourceSheetId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DuplicateSheetRequest {\n");
    sb.append("    insertSheetIndex: ").append(toIndentedString(insertSheetIndex)).append("\n");
    sb.append("    newSheetId: ").append(toIndentedString(newSheetId)).append("\n");
    sb.append("    newSheetName: ").append(toIndentedString(newSheetName)).append("\n");
    sb.append("    sourceSheetId: ").append(toIndentedString(sourceSheetId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("insertSheetIndex");
    openapiFields.add("newSheetId");
    openapiFields.add("newSheetName");
    openapiFields.add("sourceSheetId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DuplicateSheetRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DuplicateSheetRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DuplicateSheetRequest is not found in the empty JSON string", DuplicateSheetRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DuplicateSheetRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DuplicateSheetRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("newSheetName") != null && !jsonObj.get("newSheetName").isJsonNull()) && !jsonObj.get("newSheetName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `newSheetName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("newSheetName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DuplicateSheetRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DuplicateSheetRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DuplicateSheetRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DuplicateSheetRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<DuplicateSheetRequest>() {
           @Override
           public void write(JsonWriter out, DuplicateSheetRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DuplicateSheetRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DuplicateSheetRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DuplicateSheetRequest
   * @throws IOException if the JSON string is invalid with respect to DuplicateSheetRequest
   */
  public static DuplicateSheetRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DuplicateSheetRequest.class);
  }

  /**
   * Convert an instance of DuplicateSheetRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

