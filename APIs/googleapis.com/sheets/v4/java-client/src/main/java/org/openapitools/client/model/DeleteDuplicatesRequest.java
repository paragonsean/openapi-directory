/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DimensionRange;
import org.openapitools.client.model.GridRange;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Removes rows within this range that contain values in the specified columns that are duplicates of values in any previous row. Rows with identical values but different letter cases, formatting, or formulas are considered to be duplicates. This request also removes duplicate rows hidden from view (for example, due to a filter). When removing duplicates, the first instance of each duplicate row scanning from the top downwards is kept in the resulting range. Content outside of the specified range isn&#39;t removed, and rows considered duplicates do not have to be adjacent to each other in the range.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeleteDuplicatesRequest {
  public static final String SERIALIZED_NAME_COMPARISON_COLUMNS = "comparisonColumns";
  @SerializedName(SERIALIZED_NAME_COMPARISON_COLUMNS)
  private List<DimensionRange> comparisonColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_RANGE = "range";
  @SerializedName(SERIALIZED_NAME_RANGE)
  private GridRange range;

  public DeleteDuplicatesRequest() {
  }

  public DeleteDuplicatesRequest comparisonColumns(List<DimensionRange> comparisonColumns) {
    this.comparisonColumns = comparisonColumns;
    return this;
  }

  public DeleteDuplicatesRequest addComparisonColumnsItem(DimensionRange comparisonColumnsItem) {
    if (this.comparisonColumns == null) {
      this.comparisonColumns = new ArrayList<>();
    }
    this.comparisonColumns.add(comparisonColumnsItem);
    return this;
  }

  /**
   * The columns in the range to analyze for duplicate values. If no columns are selected then all columns are analyzed for duplicates.
   * @return comparisonColumns
   */
  @javax.annotation.Nullable
  public List<DimensionRange> getComparisonColumns() {
    return comparisonColumns;
  }

  public void setComparisonColumns(List<DimensionRange> comparisonColumns) {
    this.comparisonColumns = comparisonColumns;
  }


  public DeleteDuplicatesRequest range(GridRange range) {
    this.range = range;
    return this;
  }

  /**
   * Get range
   * @return range
   */
  @javax.annotation.Nullable
  public GridRange getRange() {
    return range;
  }

  public void setRange(GridRange range) {
    this.range = range;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeleteDuplicatesRequest deleteDuplicatesRequest = (DeleteDuplicatesRequest) o;
    return Objects.equals(this.comparisonColumns, deleteDuplicatesRequest.comparisonColumns) &&
        Objects.equals(this.range, deleteDuplicatesRequest.range);
  }

  @Override
  public int hashCode() {
    return Objects.hash(comparisonColumns, range);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeleteDuplicatesRequest {\n");
    sb.append("    comparisonColumns: ").append(toIndentedString(comparisonColumns)).append("\n");
    sb.append("    range: ").append(toIndentedString(range)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("comparisonColumns");
    openapiFields.add("range");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeleteDuplicatesRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeleteDuplicatesRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeleteDuplicatesRequest is not found in the empty JSON string", DeleteDuplicatesRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeleteDuplicatesRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeleteDuplicatesRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("comparisonColumns") != null && !jsonObj.get("comparisonColumns").isJsonNull()) {
        JsonArray jsonArraycomparisonColumns = jsonObj.getAsJsonArray("comparisonColumns");
        if (jsonArraycomparisonColumns != null) {
          // ensure the json data is an array
          if (!jsonObj.get("comparisonColumns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `comparisonColumns` to be an array in the JSON string but got `%s`", jsonObj.get("comparisonColumns").toString()));
          }

          // validate the optional field `comparisonColumns` (array)
          for (int i = 0; i < jsonArraycomparisonColumns.size(); i++) {
            DimensionRange.validateJsonElement(jsonArraycomparisonColumns.get(i));
          };
        }
      }
      // validate the optional field `range`
      if (jsonObj.get("range") != null && !jsonObj.get("range").isJsonNull()) {
        GridRange.validateJsonElement(jsonObj.get("range"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeleteDuplicatesRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeleteDuplicatesRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeleteDuplicatesRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeleteDuplicatesRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<DeleteDuplicatesRequest>() {
           @Override
           public void write(JsonWriter out, DeleteDuplicatesRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeleteDuplicatesRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeleteDuplicatesRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeleteDuplicatesRequest
   * @throws IOException if the JSON string is invalid with respect to DeleteDuplicatesRequest
   */
  public static DeleteDuplicatesRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeleteDuplicatesRequest.class);
  }

  /**
   * Convert an instance of DeleteDuplicatesRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

