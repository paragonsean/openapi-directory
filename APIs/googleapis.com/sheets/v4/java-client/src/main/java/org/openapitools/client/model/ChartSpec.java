/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BasicChartSpec;
import org.openapitools.client.model.BubbleChartSpec;
import org.openapitools.client.model.CandlestickChartSpec;
import org.openapitools.client.model.Color;
import org.openapitools.client.model.ColorStyle;
import org.openapitools.client.model.DataSourceChartProperties;
import org.openapitools.client.model.FilterSpec;
import org.openapitools.client.model.HistogramChartSpec;
import org.openapitools.client.model.OrgChartSpec;
import org.openapitools.client.model.PieChartSpec;
import org.openapitools.client.model.ScorecardChartSpec;
import org.openapitools.client.model.SortSpec;
import org.openapitools.client.model.TextFormat;
import org.openapitools.client.model.TextPosition;
import org.openapitools.client.model.TreemapChartSpec;
import org.openapitools.client.model.WaterfallChartSpec;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The specifications of a chart.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ChartSpec {
  public static final String SERIALIZED_NAME_ALT_TEXT = "altText";
  @SerializedName(SERIALIZED_NAME_ALT_TEXT)
  private String altText;

  public static final String SERIALIZED_NAME_BACKGROUND_COLOR = "backgroundColor";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_COLOR)
  private Color backgroundColor;

  public static final String SERIALIZED_NAME_BACKGROUND_COLOR_STYLE = "backgroundColorStyle";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_COLOR_STYLE)
  private ColorStyle backgroundColorStyle;

  public static final String SERIALIZED_NAME_BASIC_CHART = "basicChart";
  @SerializedName(SERIALIZED_NAME_BASIC_CHART)
  private BasicChartSpec basicChart;

  public static final String SERIALIZED_NAME_BUBBLE_CHART = "bubbleChart";
  @SerializedName(SERIALIZED_NAME_BUBBLE_CHART)
  private BubbleChartSpec bubbleChart;

  public static final String SERIALIZED_NAME_CANDLESTICK_CHART = "candlestickChart";
  @SerializedName(SERIALIZED_NAME_CANDLESTICK_CHART)
  private CandlestickChartSpec candlestickChart;

  public static final String SERIALIZED_NAME_DATA_SOURCE_CHART_PROPERTIES = "dataSourceChartProperties";
  @SerializedName(SERIALIZED_NAME_DATA_SOURCE_CHART_PROPERTIES)
  private DataSourceChartProperties dataSourceChartProperties;

  public static final String SERIALIZED_NAME_FILTER_SPECS = "filterSpecs";
  @SerializedName(SERIALIZED_NAME_FILTER_SPECS)
  private List<FilterSpec> filterSpecs = new ArrayList<>();

  public static final String SERIALIZED_NAME_FONT_NAME = "fontName";
  @SerializedName(SERIALIZED_NAME_FONT_NAME)
  private String fontName;

  /**
   * Determines how the charts will use hidden rows or columns.
   */
  @JsonAdapter(HiddenDimensionStrategyEnum.Adapter.class)
  public enum HiddenDimensionStrategyEnum {
    CHART_HIDDEN_DIMENSION_STRATEGY_UNSPECIFIED("CHART_HIDDEN_DIMENSION_STRATEGY_UNSPECIFIED"),
    
    SKIP_HIDDEN_ROWS_AND_COLUMNS("SKIP_HIDDEN_ROWS_AND_COLUMNS"),
    
    SKIP_HIDDEN_ROWS("SKIP_HIDDEN_ROWS"),
    
    SKIP_HIDDEN_COLUMNS("SKIP_HIDDEN_COLUMNS"),
    
    SHOW_ALL("SHOW_ALL");

    private String value;

    HiddenDimensionStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HiddenDimensionStrategyEnum fromValue(String value) {
      for (HiddenDimensionStrategyEnum b : HiddenDimensionStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HiddenDimensionStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HiddenDimensionStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HiddenDimensionStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HiddenDimensionStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HiddenDimensionStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HIDDEN_DIMENSION_STRATEGY = "hiddenDimensionStrategy";
  @SerializedName(SERIALIZED_NAME_HIDDEN_DIMENSION_STRATEGY)
  private HiddenDimensionStrategyEnum hiddenDimensionStrategy;

  public static final String SERIALIZED_NAME_HISTOGRAM_CHART = "histogramChart";
  @SerializedName(SERIALIZED_NAME_HISTOGRAM_CHART)
  private HistogramChartSpec histogramChart;

  public static final String SERIALIZED_NAME_MAXIMIZED = "maximized";
  @SerializedName(SERIALIZED_NAME_MAXIMIZED)
  private Boolean maximized;

  public static final String SERIALIZED_NAME_ORG_CHART = "orgChart";
  @SerializedName(SERIALIZED_NAME_ORG_CHART)
  private OrgChartSpec orgChart;

  public static final String SERIALIZED_NAME_PIE_CHART = "pieChart";
  @SerializedName(SERIALIZED_NAME_PIE_CHART)
  private PieChartSpec pieChart;

  public static final String SERIALIZED_NAME_SCORECARD_CHART = "scorecardChart";
  @SerializedName(SERIALIZED_NAME_SCORECARD_CHART)
  private ScorecardChartSpec scorecardChart;

  public static final String SERIALIZED_NAME_SORT_SPECS = "sortSpecs";
  @SerializedName(SERIALIZED_NAME_SORT_SPECS)
  private List<SortSpec> sortSpecs = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBTITLE = "subtitle";
  @SerializedName(SERIALIZED_NAME_SUBTITLE)
  private String subtitle;

  public static final String SERIALIZED_NAME_SUBTITLE_TEXT_FORMAT = "subtitleTextFormat";
  @SerializedName(SERIALIZED_NAME_SUBTITLE_TEXT_FORMAT)
  private TextFormat subtitleTextFormat;

  public static final String SERIALIZED_NAME_SUBTITLE_TEXT_POSITION = "subtitleTextPosition";
  @SerializedName(SERIALIZED_NAME_SUBTITLE_TEXT_POSITION)
  private TextPosition subtitleTextPosition;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_TITLE_TEXT_FORMAT = "titleTextFormat";
  @SerializedName(SERIALIZED_NAME_TITLE_TEXT_FORMAT)
  private TextFormat titleTextFormat;

  public static final String SERIALIZED_NAME_TITLE_TEXT_POSITION = "titleTextPosition";
  @SerializedName(SERIALIZED_NAME_TITLE_TEXT_POSITION)
  private TextPosition titleTextPosition;

  public static final String SERIALIZED_NAME_TREEMAP_CHART = "treemapChart";
  @SerializedName(SERIALIZED_NAME_TREEMAP_CHART)
  private TreemapChartSpec treemapChart;

  public static final String SERIALIZED_NAME_WATERFALL_CHART = "waterfallChart";
  @SerializedName(SERIALIZED_NAME_WATERFALL_CHART)
  private WaterfallChartSpec waterfallChart;

  public ChartSpec() {
  }

  public ChartSpec altText(String altText) {
    this.altText = altText;
    return this;
  }

  /**
   * The alternative text that describes the chart. This is often used for accessibility.
   * @return altText
   */
  @javax.annotation.Nullable
  public String getAltText() {
    return altText;
  }

  public void setAltText(String altText) {
    this.altText = altText;
  }


  public ChartSpec backgroundColor(Color backgroundColor) {
    this.backgroundColor = backgroundColor;
    return this;
  }

  /**
   * Get backgroundColor
   * @return backgroundColor
   */
  @javax.annotation.Nullable
  public Color getBackgroundColor() {
    return backgroundColor;
  }

  public void setBackgroundColor(Color backgroundColor) {
    this.backgroundColor = backgroundColor;
  }


  public ChartSpec backgroundColorStyle(ColorStyle backgroundColorStyle) {
    this.backgroundColorStyle = backgroundColorStyle;
    return this;
  }

  /**
   * Get backgroundColorStyle
   * @return backgroundColorStyle
   */
  @javax.annotation.Nullable
  public ColorStyle getBackgroundColorStyle() {
    return backgroundColorStyle;
  }

  public void setBackgroundColorStyle(ColorStyle backgroundColorStyle) {
    this.backgroundColorStyle = backgroundColorStyle;
  }


  public ChartSpec basicChart(BasicChartSpec basicChart) {
    this.basicChart = basicChart;
    return this;
  }

  /**
   * Get basicChart
   * @return basicChart
   */
  @javax.annotation.Nullable
  public BasicChartSpec getBasicChart() {
    return basicChart;
  }

  public void setBasicChart(BasicChartSpec basicChart) {
    this.basicChart = basicChart;
  }


  public ChartSpec bubbleChart(BubbleChartSpec bubbleChart) {
    this.bubbleChart = bubbleChart;
    return this;
  }

  /**
   * Get bubbleChart
   * @return bubbleChart
   */
  @javax.annotation.Nullable
  public BubbleChartSpec getBubbleChart() {
    return bubbleChart;
  }

  public void setBubbleChart(BubbleChartSpec bubbleChart) {
    this.bubbleChart = bubbleChart;
  }


  public ChartSpec candlestickChart(CandlestickChartSpec candlestickChart) {
    this.candlestickChart = candlestickChart;
    return this;
  }

  /**
   * Get candlestickChart
   * @return candlestickChart
   */
  @javax.annotation.Nullable
  public CandlestickChartSpec getCandlestickChart() {
    return candlestickChart;
  }

  public void setCandlestickChart(CandlestickChartSpec candlestickChart) {
    this.candlestickChart = candlestickChart;
  }


  public ChartSpec dataSourceChartProperties(DataSourceChartProperties dataSourceChartProperties) {
    this.dataSourceChartProperties = dataSourceChartProperties;
    return this;
  }

  /**
   * Get dataSourceChartProperties
   * @return dataSourceChartProperties
   */
  @javax.annotation.Nullable
  public DataSourceChartProperties getDataSourceChartProperties() {
    return dataSourceChartProperties;
  }

  public void setDataSourceChartProperties(DataSourceChartProperties dataSourceChartProperties) {
    this.dataSourceChartProperties = dataSourceChartProperties;
  }


  public ChartSpec filterSpecs(List<FilterSpec> filterSpecs) {
    this.filterSpecs = filterSpecs;
    return this;
  }

  public ChartSpec addFilterSpecsItem(FilterSpec filterSpecsItem) {
    if (this.filterSpecs == null) {
      this.filterSpecs = new ArrayList<>();
    }
    this.filterSpecs.add(filterSpecsItem);
    return this;
  }

  /**
   * The filters applied to the source data of the chart. Only supported for data source charts.
   * @return filterSpecs
   */
  @javax.annotation.Nullable
  public List<FilterSpec> getFilterSpecs() {
    return filterSpecs;
  }

  public void setFilterSpecs(List<FilterSpec> filterSpecs) {
    this.filterSpecs = filterSpecs;
  }


  public ChartSpec fontName(String fontName) {
    this.fontName = fontName;
    return this;
  }

  /**
   * The name of the font to use by default for all chart text (e.g. title, axis labels, legend). If a font is specified for a specific part of the chart it will override this font name.
   * @return fontName
   */
  @javax.annotation.Nullable
  public String getFontName() {
    return fontName;
  }

  public void setFontName(String fontName) {
    this.fontName = fontName;
  }


  public ChartSpec hiddenDimensionStrategy(HiddenDimensionStrategyEnum hiddenDimensionStrategy) {
    this.hiddenDimensionStrategy = hiddenDimensionStrategy;
    return this;
  }

  /**
   * Determines how the charts will use hidden rows or columns.
   * @return hiddenDimensionStrategy
   */
  @javax.annotation.Nullable
  public HiddenDimensionStrategyEnum getHiddenDimensionStrategy() {
    return hiddenDimensionStrategy;
  }

  public void setHiddenDimensionStrategy(HiddenDimensionStrategyEnum hiddenDimensionStrategy) {
    this.hiddenDimensionStrategy = hiddenDimensionStrategy;
  }


  public ChartSpec histogramChart(HistogramChartSpec histogramChart) {
    this.histogramChart = histogramChart;
    return this;
  }

  /**
   * Get histogramChart
   * @return histogramChart
   */
  @javax.annotation.Nullable
  public HistogramChartSpec getHistogramChart() {
    return histogramChart;
  }

  public void setHistogramChart(HistogramChartSpec histogramChart) {
    this.histogramChart = histogramChart;
  }


  public ChartSpec maximized(Boolean maximized) {
    this.maximized = maximized;
    return this;
  }

  /**
   * True to make a chart fill the entire space in which it&#39;s rendered with minimum padding. False to use the default padding. (Not applicable to Geo and Org charts.)
   * @return maximized
   */
  @javax.annotation.Nullable
  public Boolean getMaximized() {
    return maximized;
  }

  public void setMaximized(Boolean maximized) {
    this.maximized = maximized;
  }


  public ChartSpec orgChart(OrgChartSpec orgChart) {
    this.orgChart = orgChart;
    return this;
  }

  /**
   * Get orgChart
   * @return orgChart
   */
  @javax.annotation.Nullable
  public OrgChartSpec getOrgChart() {
    return orgChart;
  }

  public void setOrgChart(OrgChartSpec orgChart) {
    this.orgChart = orgChart;
  }


  public ChartSpec pieChart(PieChartSpec pieChart) {
    this.pieChart = pieChart;
    return this;
  }

  /**
   * Get pieChart
   * @return pieChart
   */
  @javax.annotation.Nullable
  public PieChartSpec getPieChart() {
    return pieChart;
  }

  public void setPieChart(PieChartSpec pieChart) {
    this.pieChart = pieChart;
  }


  public ChartSpec scorecardChart(ScorecardChartSpec scorecardChart) {
    this.scorecardChart = scorecardChart;
    return this;
  }

  /**
   * Get scorecardChart
   * @return scorecardChart
   */
  @javax.annotation.Nullable
  public ScorecardChartSpec getScorecardChart() {
    return scorecardChart;
  }

  public void setScorecardChart(ScorecardChartSpec scorecardChart) {
    this.scorecardChart = scorecardChart;
  }


  public ChartSpec sortSpecs(List<SortSpec> sortSpecs) {
    this.sortSpecs = sortSpecs;
    return this;
  }

  public ChartSpec addSortSpecsItem(SortSpec sortSpecsItem) {
    if (this.sortSpecs == null) {
      this.sortSpecs = new ArrayList<>();
    }
    this.sortSpecs.add(sortSpecsItem);
    return this;
  }

  /**
   * The order to sort the chart data by. Only a single sort spec is supported. Only supported for data source charts.
   * @return sortSpecs
   */
  @javax.annotation.Nullable
  public List<SortSpec> getSortSpecs() {
    return sortSpecs;
  }

  public void setSortSpecs(List<SortSpec> sortSpecs) {
    this.sortSpecs = sortSpecs;
  }


  public ChartSpec subtitle(String subtitle) {
    this.subtitle = subtitle;
    return this;
  }

  /**
   * The subtitle of the chart.
   * @return subtitle
   */
  @javax.annotation.Nullable
  public String getSubtitle() {
    return subtitle;
  }

  public void setSubtitle(String subtitle) {
    this.subtitle = subtitle;
  }


  public ChartSpec subtitleTextFormat(TextFormat subtitleTextFormat) {
    this.subtitleTextFormat = subtitleTextFormat;
    return this;
  }

  /**
   * Get subtitleTextFormat
   * @return subtitleTextFormat
   */
  @javax.annotation.Nullable
  public TextFormat getSubtitleTextFormat() {
    return subtitleTextFormat;
  }

  public void setSubtitleTextFormat(TextFormat subtitleTextFormat) {
    this.subtitleTextFormat = subtitleTextFormat;
  }


  public ChartSpec subtitleTextPosition(TextPosition subtitleTextPosition) {
    this.subtitleTextPosition = subtitleTextPosition;
    return this;
  }

  /**
   * Get subtitleTextPosition
   * @return subtitleTextPosition
   */
  @javax.annotation.Nullable
  public TextPosition getSubtitleTextPosition() {
    return subtitleTextPosition;
  }

  public void setSubtitleTextPosition(TextPosition subtitleTextPosition) {
    this.subtitleTextPosition = subtitleTextPosition;
  }


  public ChartSpec title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the chart.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public ChartSpec titleTextFormat(TextFormat titleTextFormat) {
    this.titleTextFormat = titleTextFormat;
    return this;
  }

  /**
   * Get titleTextFormat
   * @return titleTextFormat
   */
  @javax.annotation.Nullable
  public TextFormat getTitleTextFormat() {
    return titleTextFormat;
  }

  public void setTitleTextFormat(TextFormat titleTextFormat) {
    this.titleTextFormat = titleTextFormat;
  }


  public ChartSpec titleTextPosition(TextPosition titleTextPosition) {
    this.titleTextPosition = titleTextPosition;
    return this;
  }

  /**
   * Get titleTextPosition
   * @return titleTextPosition
   */
  @javax.annotation.Nullable
  public TextPosition getTitleTextPosition() {
    return titleTextPosition;
  }

  public void setTitleTextPosition(TextPosition titleTextPosition) {
    this.titleTextPosition = titleTextPosition;
  }


  public ChartSpec treemapChart(TreemapChartSpec treemapChart) {
    this.treemapChart = treemapChart;
    return this;
  }

  /**
   * Get treemapChart
   * @return treemapChart
   */
  @javax.annotation.Nullable
  public TreemapChartSpec getTreemapChart() {
    return treemapChart;
  }

  public void setTreemapChart(TreemapChartSpec treemapChart) {
    this.treemapChart = treemapChart;
  }


  public ChartSpec waterfallChart(WaterfallChartSpec waterfallChart) {
    this.waterfallChart = waterfallChart;
    return this;
  }

  /**
   * Get waterfallChart
   * @return waterfallChart
   */
  @javax.annotation.Nullable
  public WaterfallChartSpec getWaterfallChart() {
    return waterfallChart;
  }

  public void setWaterfallChart(WaterfallChartSpec waterfallChart) {
    this.waterfallChart = waterfallChart;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChartSpec chartSpec = (ChartSpec) o;
    return Objects.equals(this.altText, chartSpec.altText) &&
        Objects.equals(this.backgroundColor, chartSpec.backgroundColor) &&
        Objects.equals(this.backgroundColorStyle, chartSpec.backgroundColorStyle) &&
        Objects.equals(this.basicChart, chartSpec.basicChart) &&
        Objects.equals(this.bubbleChart, chartSpec.bubbleChart) &&
        Objects.equals(this.candlestickChart, chartSpec.candlestickChart) &&
        Objects.equals(this.dataSourceChartProperties, chartSpec.dataSourceChartProperties) &&
        Objects.equals(this.filterSpecs, chartSpec.filterSpecs) &&
        Objects.equals(this.fontName, chartSpec.fontName) &&
        Objects.equals(this.hiddenDimensionStrategy, chartSpec.hiddenDimensionStrategy) &&
        Objects.equals(this.histogramChart, chartSpec.histogramChart) &&
        Objects.equals(this.maximized, chartSpec.maximized) &&
        Objects.equals(this.orgChart, chartSpec.orgChart) &&
        Objects.equals(this.pieChart, chartSpec.pieChart) &&
        Objects.equals(this.scorecardChart, chartSpec.scorecardChart) &&
        Objects.equals(this.sortSpecs, chartSpec.sortSpecs) &&
        Objects.equals(this.subtitle, chartSpec.subtitle) &&
        Objects.equals(this.subtitleTextFormat, chartSpec.subtitleTextFormat) &&
        Objects.equals(this.subtitleTextPosition, chartSpec.subtitleTextPosition) &&
        Objects.equals(this.title, chartSpec.title) &&
        Objects.equals(this.titleTextFormat, chartSpec.titleTextFormat) &&
        Objects.equals(this.titleTextPosition, chartSpec.titleTextPosition) &&
        Objects.equals(this.treemapChart, chartSpec.treemapChart) &&
        Objects.equals(this.waterfallChart, chartSpec.waterfallChart);
  }

  @Override
  public int hashCode() {
    return Objects.hash(altText, backgroundColor, backgroundColorStyle, basicChart, bubbleChart, candlestickChart, dataSourceChartProperties, filterSpecs, fontName, hiddenDimensionStrategy, histogramChart, maximized, orgChart, pieChart, scorecardChart, sortSpecs, subtitle, subtitleTextFormat, subtitleTextPosition, title, titleTextFormat, titleTextPosition, treemapChart, waterfallChart);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChartSpec {\n");
    sb.append("    altText: ").append(toIndentedString(altText)).append("\n");
    sb.append("    backgroundColor: ").append(toIndentedString(backgroundColor)).append("\n");
    sb.append("    backgroundColorStyle: ").append(toIndentedString(backgroundColorStyle)).append("\n");
    sb.append("    basicChart: ").append(toIndentedString(basicChart)).append("\n");
    sb.append("    bubbleChart: ").append(toIndentedString(bubbleChart)).append("\n");
    sb.append("    candlestickChart: ").append(toIndentedString(candlestickChart)).append("\n");
    sb.append("    dataSourceChartProperties: ").append(toIndentedString(dataSourceChartProperties)).append("\n");
    sb.append("    filterSpecs: ").append(toIndentedString(filterSpecs)).append("\n");
    sb.append("    fontName: ").append(toIndentedString(fontName)).append("\n");
    sb.append("    hiddenDimensionStrategy: ").append(toIndentedString(hiddenDimensionStrategy)).append("\n");
    sb.append("    histogramChart: ").append(toIndentedString(histogramChart)).append("\n");
    sb.append("    maximized: ").append(toIndentedString(maximized)).append("\n");
    sb.append("    orgChart: ").append(toIndentedString(orgChart)).append("\n");
    sb.append("    pieChart: ").append(toIndentedString(pieChart)).append("\n");
    sb.append("    scorecardChart: ").append(toIndentedString(scorecardChart)).append("\n");
    sb.append("    sortSpecs: ").append(toIndentedString(sortSpecs)).append("\n");
    sb.append("    subtitle: ").append(toIndentedString(subtitle)).append("\n");
    sb.append("    subtitleTextFormat: ").append(toIndentedString(subtitleTextFormat)).append("\n");
    sb.append("    subtitleTextPosition: ").append(toIndentedString(subtitleTextPosition)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    titleTextFormat: ").append(toIndentedString(titleTextFormat)).append("\n");
    sb.append("    titleTextPosition: ").append(toIndentedString(titleTextPosition)).append("\n");
    sb.append("    treemapChart: ").append(toIndentedString(treemapChart)).append("\n");
    sb.append("    waterfallChart: ").append(toIndentedString(waterfallChart)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("altText");
    openapiFields.add("backgroundColor");
    openapiFields.add("backgroundColorStyle");
    openapiFields.add("basicChart");
    openapiFields.add("bubbleChart");
    openapiFields.add("candlestickChart");
    openapiFields.add("dataSourceChartProperties");
    openapiFields.add("filterSpecs");
    openapiFields.add("fontName");
    openapiFields.add("hiddenDimensionStrategy");
    openapiFields.add("histogramChart");
    openapiFields.add("maximized");
    openapiFields.add("orgChart");
    openapiFields.add("pieChart");
    openapiFields.add("scorecardChart");
    openapiFields.add("sortSpecs");
    openapiFields.add("subtitle");
    openapiFields.add("subtitleTextFormat");
    openapiFields.add("subtitleTextPosition");
    openapiFields.add("title");
    openapiFields.add("titleTextFormat");
    openapiFields.add("titleTextPosition");
    openapiFields.add("treemapChart");
    openapiFields.add("waterfallChart");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ChartSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ChartSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ChartSpec is not found in the empty JSON string", ChartSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ChartSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ChartSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("altText") != null && !jsonObj.get("altText").isJsonNull()) && !jsonObj.get("altText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `altText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("altText").toString()));
      }
      // validate the optional field `backgroundColor`
      if (jsonObj.get("backgroundColor") != null && !jsonObj.get("backgroundColor").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("backgroundColor"));
      }
      // validate the optional field `backgroundColorStyle`
      if (jsonObj.get("backgroundColorStyle") != null && !jsonObj.get("backgroundColorStyle").isJsonNull()) {
        ColorStyle.validateJsonElement(jsonObj.get("backgroundColorStyle"));
      }
      // validate the optional field `basicChart`
      if (jsonObj.get("basicChart") != null && !jsonObj.get("basicChart").isJsonNull()) {
        BasicChartSpec.validateJsonElement(jsonObj.get("basicChart"));
      }
      // validate the optional field `bubbleChart`
      if (jsonObj.get("bubbleChart") != null && !jsonObj.get("bubbleChart").isJsonNull()) {
        BubbleChartSpec.validateJsonElement(jsonObj.get("bubbleChart"));
      }
      // validate the optional field `candlestickChart`
      if (jsonObj.get("candlestickChart") != null && !jsonObj.get("candlestickChart").isJsonNull()) {
        CandlestickChartSpec.validateJsonElement(jsonObj.get("candlestickChart"));
      }
      // validate the optional field `dataSourceChartProperties`
      if (jsonObj.get("dataSourceChartProperties") != null && !jsonObj.get("dataSourceChartProperties").isJsonNull()) {
        DataSourceChartProperties.validateJsonElement(jsonObj.get("dataSourceChartProperties"));
      }
      if (jsonObj.get("filterSpecs") != null && !jsonObj.get("filterSpecs").isJsonNull()) {
        JsonArray jsonArrayfilterSpecs = jsonObj.getAsJsonArray("filterSpecs");
        if (jsonArrayfilterSpecs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filterSpecs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filterSpecs` to be an array in the JSON string but got `%s`", jsonObj.get("filterSpecs").toString()));
          }

          // validate the optional field `filterSpecs` (array)
          for (int i = 0; i < jsonArrayfilterSpecs.size(); i++) {
            FilterSpec.validateJsonElement(jsonArrayfilterSpecs.get(i));
          };
        }
      }
      if ((jsonObj.get("fontName") != null && !jsonObj.get("fontName").isJsonNull()) && !jsonObj.get("fontName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fontName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fontName").toString()));
      }
      if ((jsonObj.get("hiddenDimensionStrategy") != null && !jsonObj.get("hiddenDimensionStrategy").isJsonNull()) && !jsonObj.get("hiddenDimensionStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hiddenDimensionStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hiddenDimensionStrategy").toString()));
      }
      // validate the optional field `hiddenDimensionStrategy`
      if (jsonObj.get("hiddenDimensionStrategy") != null && !jsonObj.get("hiddenDimensionStrategy").isJsonNull()) {
        HiddenDimensionStrategyEnum.validateJsonElement(jsonObj.get("hiddenDimensionStrategy"));
      }
      // validate the optional field `histogramChart`
      if (jsonObj.get("histogramChart") != null && !jsonObj.get("histogramChart").isJsonNull()) {
        HistogramChartSpec.validateJsonElement(jsonObj.get("histogramChart"));
      }
      // validate the optional field `orgChart`
      if (jsonObj.get("orgChart") != null && !jsonObj.get("orgChart").isJsonNull()) {
        OrgChartSpec.validateJsonElement(jsonObj.get("orgChart"));
      }
      // validate the optional field `pieChart`
      if (jsonObj.get("pieChart") != null && !jsonObj.get("pieChart").isJsonNull()) {
        PieChartSpec.validateJsonElement(jsonObj.get("pieChart"));
      }
      // validate the optional field `scorecardChart`
      if (jsonObj.get("scorecardChart") != null && !jsonObj.get("scorecardChart").isJsonNull()) {
        ScorecardChartSpec.validateJsonElement(jsonObj.get("scorecardChart"));
      }
      if (jsonObj.get("sortSpecs") != null && !jsonObj.get("sortSpecs").isJsonNull()) {
        JsonArray jsonArraysortSpecs = jsonObj.getAsJsonArray("sortSpecs");
        if (jsonArraysortSpecs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sortSpecs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sortSpecs` to be an array in the JSON string but got `%s`", jsonObj.get("sortSpecs").toString()));
          }

          // validate the optional field `sortSpecs` (array)
          for (int i = 0; i < jsonArraysortSpecs.size(); i++) {
            SortSpec.validateJsonElement(jsonArraysortSpecs.get(i));
          };
        }
      }
      if ((jsonObj.get("subtitle") != null && !jsonObj.get("subtitle").isJsonNull()) && !jsonObj.get("subtitle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subtitle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subtitle").toString()));
      }
      // validate the optional field `subtitleTextFormat`
      if (jsonObj.get("subtitleTextFormat") != null && !jsonObj.get("subtitleTextFormat").isJsonNull()) {
        TextFormat.validateJsonElement(jsonObj.get("subtitleTextFormat"));
      }
      // validate the optional field `subtitleTextPosition`
      if (jsonObj.get("subtitleTextPosition") != null && !jsonObj.get("subtitleTextPosition").isJsonNull()) {
        TextPosition.validateJsonElement(jsonObj.get("subtitleTextPosition"));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      // validate the optional field `titleTextFormat`
      if (jsonObj.get("titleTextFormat") != null && !jsonObj.get("titleTextFormat").isJsonNull()) {
        TextFormat.validateJsonElement(jsonObj.get("titleTextFormat"));
      }
      // validate the optional field `titleTextPosition`
      if (jsonObj.get("titleTextPosition") != null && !jsonObj.get("titleTextPosition").isJsonNull()) {
        TextPosition.validateJsonElement(jsonObj.get("titleTextPosition"));
      }
      // validate the optional field `treemapChart`
      if (jsonObj.get("treemapChart") != null && !jsonObj.get("treemapChart").isJsonNull()) {
        TreemapChartSpec.validateJsonElement(jsonObj.get("treemapChart"));
      }
      // validate the optional field `waterfallChart`
      if (jsonObj.get("waterfallChart") != null && !jsonObj.get("waterfallChart").isJsonNull()) {
        WaterfallChartSpec.validateJsonElement(jsonObj.get("waterfallChart"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ChartSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ChartSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ChartSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ChartSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<ChartSpec>() {
           @Override
           public void write(JsonWriter out, ChartSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ChartSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ChartSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ChartSpec
   * @throws IOException if the JSON string is invalid with respect to ChartSpec
   */
  public static ChartSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ChartSpec.class);
  }

  /**
   * Convert an instance of ChartSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

