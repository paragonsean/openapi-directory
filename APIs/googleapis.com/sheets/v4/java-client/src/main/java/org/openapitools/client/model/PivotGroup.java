/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DataSourceColumnReference;
import org.openapitools.client.model.PivotGroupLimit;
import org.openapitools.client.model.PivotGroupRule;
import org.openapitools.client.model.PivotGroupSortValueBucket;
import org.openapitools.client.model.PivotGroupValueMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A single grouping (either row or column) in a pivot table.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PivotGroup {
  public static final String SERIALIZED_NAME_DATA_SOURCE_COLUMN_REFERENCE = "dataSourceColumnReference";
  @SerializedName(SERIALIZED_NAME_DATA_SOURCE_COLUMN_REFERENCE)
  private DataSourceColumnReference dataSourceColumnReference;

  public static final String SERIALIZED_NAME_GROUP_LIMIT = "groupLimit";
  @SerializedName(SERIALIZED_NAME_GROUP_LIMIT)
  private PivotGroupLimit groupLimit;

  public static final String SERIALIZED_NAME_GROUP_RULE = "groupRule";
  @SerializedName(SERIALIZED_NAME_GROUP_RULE)
  private PivotGroupRule groupRule;

  public static final String SERIALIZED_NAME_LABEL = "label";
  @SerializedName(SERIALIZED_NAME_LABEL)
  private String label;

  public static final String SERIALIZED_NAME_REPEAT_HEADINGS = "repeatHeadings";
  @SerializedName(SERIALIZED_NAME_REPEAT_HEADINGS)
  private Boolean repeatHeadings;

  public static final String SERIALIZED_NAME_SHOW_TOTALS = "showTotals";
  @SerializedName(SERIALIZED_NAME_SHOW_TOTALS)
  private Boolean showTotals;

  /**
   * The order the values in this group should be sorted.
   */
  @JsonAdapter(SortOrderEnum.Adapter.class)
  public enum SortOrderEnum {
    SORT_ORDER_UNSPECIFIED("SORT_ORDER_UNSPECIFIED"),
    
    ASCENDING("ASCENDING"),
    
    DESCENDING("DESCENDING");

    private String value;

    SortOrderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SortOrderEnum fromValue(String value) {
      for (SortOrderEnum b : SortOrderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SortOrderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SortOrderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SortOrderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SortOrderEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SortOrderEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SORT_ORDER = "sortOrder";
  @SerializedName(SERIALIZED_NAME_SORT_ORDER)
  private SortOrderEnum sortOrder;

  public static final String SERIALIZED_NAME_SOURCE_COLUMN_OFFSET = "sourceColumnOffset";
  @SerializedName(SERIALIZED_NAME_SOURCE_COLUMN_OFFSET)
  private Integer sourceColumnOffset;

  public static final String SERIALIZED_NAME_VALUE_BUCKET = "valueBucket";
  @SerializedName(SERIALIZED_NAME_VALUE_BUCKET)
  private PivotGroupSortValueBucket valueBucket;

  public static final String SERIALIZED_NAME_VALUE_METADATA = "valueMetadata";
  @SerializedName(SERIALIZED_NAME_VALUE_METADATA)
  private List<PivotGroupValueMetadata> valueMetadata = new ArrayList<>();

  public PivotGroup() {
  }

  public PivotGroup dataSourceColumnReference(DataSourceColumnReference dataSourceColumnReference) {
    this.dataSourceColumnReference = dataSourceColumnReference;
    return this;
  }

  /**
   * Get dataSourceColumnReference
   * @return dataSourceColumnReference
   */
  @javax.annotation.Nullable
  public DataSourceColumnReference getDataSourceColumnReference() {
    return dataSourceColumnReference;
  }

  public void setDataSourceColumnReference(DataSourceColumnReference dataSourceColumnReference) {
    this.dataSourceColumnReference = dataSourceColumnReference;
  }


  public PivotGroup groupLimit(PivotGroupLimit groupLimit) {
    this.groupLimit = groupLimit;
    return this;
  }

  /**
   * Get groupLimit
   * @return groupLimit
   */
  @javax.annotation.Nullable
  public PivotGroupLimit getGroupLimit() {
    return groupLimit;
  }

  public void setGroupLimit(PivotGroupLimit groupLimit) {
    this.groupLimit = groupLimit;
  }


  public PivotGroup groupRule(PivotGroupRule groupRule) {
    this.groupRule = groupRule;
    return this;
  }

  /**
   * Get groupRule
   * @return groupRule
   */
  @javax.annotation.Nullable
  public PivotGroupRule getGroupRule() {
    return groupRule;
  }

  public void setGroupRule(PivotGroupRule groupRule) {
    this.groupRule = groupRule;
  }


  public PivotGroup label(String label) {
    this.label = label;
    return this;
  }

  /**
   * The labels to use for the row/column groups which can be customized. For example, in the following pivot table, the row label is &#x60;Region&#x60; (which could be renamed to &#x60;State&#x60;) and the column label is &#x60;Product&#x60; (which could be renamed &#x60;Item&#x60;). Pivot tables created before December 2017 do not have header labels. If you&#39;d like to add header labels to an existing pivot table, please delete the existing pivot table and then create a new pivot table with same parameters. +--------------+---------+-------+ | SUM of Units | Product | | | Region | Pen | Paper | +--------------+---------+-------+ | New York | 345 | 98 | | Oregon | 234 | 123 | | Tennessee | 531 | 415 | +--------------+---------+-------+ | Grand Total | 1110 | 636 | +--------------+---------+-------+
   * @return label
   */
  @javax.annotation.Nullable
  public String getLabel() {
    return label;
  }

  public void setLabel(String label) {
    this.label = label;
  }


  public PivotGroup repeatHeadings(Boolean repeatHeadings) {
    this.repeatHeadings = repeatHeadings;
    return this;
  }

  /**
   * True if the headings in this pivot group should be repeated. This is only valid for row groupings and is ignored by columns. By default, we minimize repetition of headings by not showing higher level headings where they are the same. For example, even though the third row below corresponds to \&quot;Q1 Mar\&quot;, \&quot;Q1\&quot; is not shown because it is redundant with previous rows. Setting repeat_headings to true would cause \&quot;Q1\&quot; to be repeated for \&quot;Feb\&quot; and \&quot;Mar\&quot;. +--------------+ | Q1 | Jan | | | Feb | | | Mar | +--------+-----+ | Q1 Total | +--------------+
   * @return repeatHeadings
   */
  @javax.annotation.Nullable
  public Boolean getRepeatHeadings() {
    return repeatHeadings;
  }

  public void setRepeatHeadings(Boolean repeatHeadings) {
    this.repeatHeadings = repeatHeadings;
  }


  public PivotGroup showTotals(Boolean showTotals) {
    this.showTotals = showTotals;
    return this;
  }

  /**
   * True if the pivot table should include the totals for this grouping.
   * @return showTotals
   */
  @javax.annotation.Nullable
  public Boolean getShowTotals() {
    return showTotals;
  }

  public void setShowTotals(Boolean showTotals) {
    this.showTotals = showTotals;
  }


  public PivotGroup sortOrder(SortOrderEnum sortOrder) {
    this.sortOrder = sortOrder;
    return this;
  }

  /**
   * The order the values in this group should be sorted.
   * @return sortOrder
   */
  @javax.annotation.Nullable
  public SortOrderEnum getSortOrder() {
    return sortOrder;
  }

  public void setSortOrder(SortOrderEnum sortOrder) {
    this.sortOrder = sortOrder;
  }


  public PivotGroup sourceColumnOffset(Integer sourceColumnOffset) {
    this.sourceColumnOffset = sourceColumnOffset;
    return this;
  }

  /**
   * The column offset of the source range that this grouping is based on. For example, if the source was &#x60;C10:E15&#x60;, a &#x60;sourceColumnOffset&#x60; of &#x60;0&#x60; means this group refers to column &#x60;C&#x60;, whereas the offset &#x60;1&#x60; would refer to column &#x60;D&#x60;.
   * @return sourceColumnOffset
   */
  @javax.annotation.Nullable
  public Integer getSourceColumnOffset() {
    return sourceColumnOffset;
  }

  public void setSourceColumnOffset(Integer sourceColumnOffset) {
    this.sourceColumnOffset = sourceColumnOffset;
  }


  public PivotGroup valueBucket(PivotGroupSortValueBucket valueBucket) {
    this.valueBucket = valueBucket;
    return this;
  }

  /**
   * Get valueBucket
   * @return valueBucket
   */
  @javax.annotation.Nullable
  public PivotGroupSortValueBucket getValueBucket() {
    return valueBucket;
  }

  public void setValueBucket(PivotGroupSortValueBucket valueBucket) {
    this.valueBucket = valueBucket;
  }


  public PivotGroup valueMetadata(List<PivotGroupValueMetadata> valueMetadata) {
    this.valueMetadata = valueMetadata;
    return this;
  }

  public PivotGroup addValueMetadataItem(PivotGroupValueMetadata valueMetadataItem) {
    if (this.valueMetadata == null) {
      this.valueMetadata = new ArrayList<>();
    }
    this.valueMetadata.add(valueMetadataItem);
    return this;
  }

  /**
   * Metadata about values in the grouping.
   * @return valueMetadata
   */
  @javax.annotation.Nullable
  public List<PivotGroupValueMetadata> getValueMetadata() {
    return valueMetadata;
  }

  public void setValueMetadata(List<PivotGroupValueMetadata> valueMetadata) {
    this.valueMetadata = valueMetadata;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PivotGroup pivotGroup = (PivotGroup) o;
    return Objects.equals(this.dataSourceColumnReference, pivotGroup.dataSourceColumnReference) &&
        Objects.equals(this.groupLimit, pivotGroup.groupLimit) &&
        Objects.equals(this.groupRule, pivotGroup.groupRule) &&
        Objects.equals(this.label, pivotGroup.label) &&
        Objects.equals(this.repeatHeadings, pivotGroup.repeatHeadings) &&
        Objects.equals(this.showTotals, pivotGroup.showTotals) &&
        Objects.equals(this.sortOrder, pivotGroup.sortOrder) &&
        Objects.equals(this.sourceColumnOffset, pivotGroup.sourceColumnOffset) &&
        Objects.equals(this.valueBucket, pivotGroup.valueBucket) &&
        Objects.equals(this.valueMetadata, pivotGroup.valueMetadata);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataSourceColumnReference, groupLimit, groupRule, label, repeatHeadings, showTotals, sortOrder, sourceColumnOffset, valueBucket, valueMetadata);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PivotGroup {\n");
    sb.append("    dataSourceColumnReference: ").append(toIndentedString(dataSourceColumnReference)).append("\n");
    sb.append("    groupLimit: ").append(toIndentedString(groupLimit)).append("\n");
    sb.append("    groupRule: ").append(toIndentedString(groupRule)).append("\n");
    sb.append("    label: ").append(toIndentedString(label)).append("\n");
    sb.append("    repeatHeadings: ").append(toIndentedString(repeatHeadings)).append("\n");
    sb.append("    showTotals: ").append(toIndentedString(showTotals)).append("\n");
    sb.append("    sortOrder: ").append(toIndentedString(sortOrder)).append("\n");
    sb.append("    sourceColumnOffset: ").append(toIndentedString(sourceColumnOffset)).append("\n");
    sb.append("    valueBucket: ").append(toIndentedString(valueBucket)).append("\n");
    sb.append("    valueMetadata: ").append(toIndentedString(valueMetadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dataSourceColumnReference");
    openapiFields.add("groupLimit");
    openapiFields.add("groupRule");
    openapiFields.add("label");
    openapiFields.add("repeatHeadings");
    openapiFields.add("showTotals");
    openapiFields.add("sortOrder");
    openapiFields.add("sourceColumnOffset");
    openapiFields.add("valueBucket");
    openapiFields.add("valueMetadata");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PivotGroup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PivotGroup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PivotGroup is not found in the empty JSON string", PivotGroup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PivotGroup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PivotGroup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `dataSourceColumnReference`
      if (jsonObj.get("dataSourceColumnReference") != null && !jsonObj.get("dataSourceColumnReference").isJsonNull()) {
        DataSourceColumnReference.validateJsonElement(jsonObj.get("dataSourceColumnReference"));
      }
      // validate the optional field `groupLimit`
      if (jsonObj.get("groupLimit") != null && !jsonObj.get("groupLimit").isJsonNull()) {
        PivotGroupLimit.validateJsonElement(jsonObj.get("groupLimit"));
      }
      // validate the optional field `groupRule`
      if (jsonObj.get("groupRule") != null && !jsonObj.get("groupRule").isJsonNull()) {
        PivotGroupRule.validateJsonElement(jsonObj.get("groupRule"));
      }
      if ((jsonObj.get("label") != null && !jsonObj.get("label").isJsonNull()) && !jsonObj.get("label").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `label` to be a primitive type in the JSON string but got `%s`", jsonObj.get("label").toString()));
      }
      if ((jsonObj.get("sortOrder") != null && !jsonObj.get("sortOrder").isJsonNull()) && !jsonObj.get("sortOrder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sortOrder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sortOrder").toString()));
      }
      // validate the optional field `sortOrder`
      if (jsonObj.get("sortOrder") != null && !jsonObj.get("sortOrder").isJsonNull()) {
        SortOrderEnum.validateJsonElement(jsonObj.get("sortOrder"));
      }
      // validate the optional field `valueBucket`
      if (jsonObj.get("valueBucket") != null && !jsonObj.get("valueBucket").isJsonNull()) {
        PivotGroupSortValueBucket.validateJsonElement(jsonObj.get("valueBucket"));
      }
      if (jsonObj.get("valueMetadata") != null && !jsonObj.get("valueMetadata").isJsonNull()) {
        JsonArray jsonArrayvalueMetadata = jsonObj.getAsJsonArray("valueMetadata");
        if (jsonArrayvalueMetadata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("valueMetadata").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `valueMetadata` to be an array in the JSON string but got `%s`", jsonObj.get("valueMetadata").toString()));
          }

          // validate the optional field `valueMetadata` (array)
          for (int i = 0; i < jsonArrayvalueMetadata.size(); i++) {
            PivotGroupValueMetadata.validateJsonElement(jsonArrayvalueMetadata.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PivotGroup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PivotGroup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PivotGroup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PivotGroup.class));

       return (TypeAdapter<T>) new TypeAdapter<PivotGroup>() {
           @Override
           public void write(JsonWriter out, PivotGroup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PivotGroup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PivotGroup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PivotGroup
   * @throws IOException if the JSON string is invalid with respect to PivotGroup
   */
  public static PivotGroup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PivotGroup.class);
  }

  /**
   * Convert an instance of PivotGroup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

