/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ValueRange;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for updating more than one range of values in a spreadsheet.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BatchUpdateValuesRequest {
  public static final String SERIALIZED_NAME_DATA = "data";
  @SerializedName(SERIALIZED_NAME_DATA)
  private List<ValueRange> data = new ArrayList<>();

  public static final String SERIALIZED_NAME_INCLUDE_VALUES_IN_RESPONSE = "includeValuesInResponse";
  @SerializedName(SERIALIZED_NAME_INCLUDE_VALUES_IN_RESPONSE)
  private Boolean includeValuesInResponse;

  /**
   * Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is SERIAL_NUMBER.
   */
  @JsonAdapter(ResponseDateTimeRenderOptionEnum.Adapter.class)
  public enum ResponseDateTimeRenderOptionEnum {
    SERIAL_NUMBER("SERIAL_NUMBER"),
    
    FORMATTED_STRING("FORMATTED_STRING");

    private String value;

    ResponseDateTimeRenderOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResponseDateTimeRenderOptionEnum fromValue(String value) {
      for (ResponseDateTimeRenderOptionEnum b : ResponseDateTimeRenderOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ResponseDateTimeRenderOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResponseDateTimeRenderOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResponseDateTimeRenderOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ResponseDateTimeRenderOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ResponseDateTimeRenderOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RESPONSE_DATE_TIME_RENDER_OPTION = "responseDateTimeRenderOption";
  @SerializedName(SERIALIZED_NAME_RESPONSE_DATE_TIME_RENDER_OPTION)
  private ResponseDateTimeRenderOptionEnum responseDateTimeRenderOption;

  /**
   * Determines how values in the response should be rendered. The default render option is FORMATTED_VALUE.
   */
  @JsonAdapter(ResponseValueRenderOptionEnum.Adapter.class)
  public enum ResponseValueRenderOptionEnum {
    FORMATTED_VALUE("FORMATTED_VALUE"),
    
    UNFORMATTED_VALUE("UNFORMATTED_VALUE"),
    
    FORMULA("FORMULA");

    private String value;

    ResponseValueRenderOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResponseValueRenderOptionEnum fromValue(String value) {
      for (ResponseValueRenderOptionEnum b : ResponseValueRenderOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ResponseValueRenderOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResponseValueRenderOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResponseValueRenderOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ResponseValueRenderOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ResponseValueRenderOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RESPONSE_VALUE_RENDER_OPTION = "responseValueRenderOption";
  @SerializedName(SERIALIZED_NAME_RESPONSE_VALUE_RENDER_OPTION)
  private ResponseValueRenderOptionEnum responseValueRenderOption;

  /**
   * How the input data should be interpreted.
   */
  @JsonAdapter(ValueInputOptionEnum.Adapter.class)
  public enum ValueInputOptionEnum {
    INPUT_VALUE_OPTION_UNSPECIFIED("INPUT_VALUE_OPTION_UNSPECIFIED"),
    
    RAW("RAW"),
    
    USER_ENTERED("USER_ENTERED");

    private String value;

    ValueInputOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValueInputOptionEnum fromValue(String value) {
      for (ValueInputOptionEnum b : ValueInputOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValueInputOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValueInputOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValueInputOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValueInputOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValueInputOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALUE_INPUT_OPTION = "valueInputOption";
  @SerializedName(SERIALIZED_NAME_VALUE_INPUT_OPTION)
  private ValueInputOptionEnum valueInputOption;

  public BatchUpdateValuesRequest() {
  }

  public BatchUpdateValuesRequest data(List<ValueRange> data) {
    this.data = data;
    return this;
  }

  public BatchUpdateValuesRequest addDataItem(ValueRange dataItem) {
    if (this.data == null) {
      this.data = new ArrayList<>();
    }
    this.data.add(dataItem);
    return this;
  }

  /**
   * The new values to apply to the spreadsheet.
   * @return data
   */
  @javax.annotation.Nullable
  public List<ValueRange> getData() {
    return data;
  }

  public void setData(List<ValueRange> data) {
    this.data = data;
  }


  public BatchUpdateValuesRequest includeValuesInResponse(Boolean includeValuesInResponse) {
    this.includeValuesInResponse = includeValuesInResponse;
    return this;
  }

  /**
   * Determines if the update response should include the values of the cells that were updated. By default, responses do not include the updated values. The &#x60;updatedData&#x60; field within each of the BatchUpdateValuesResponse.responses contains the updated values. If the range to write was larger than the range actually written, the response includes all values in the requested range (excluding trailing empty rows and columns).
   * @return includeValuesInResponse
   */
  @javax.annotation.Nullable
  public Boolean getIncludeValuesInResponse() {
    return includeValuesInResponse;
  }

  public void setIncludeValuesInResponse(Boolean includeValuesInResponse) {
    this.includeValuesInResponse = includeValuesInResponse;
  }


  public BatchUpdateValuesRequest responseDateTimeRenderOption(ResponseDateTimeRenderOptionEnum responseDateTimeRenderOption) {
    this.responseDateTimeRenderOption = responseDateTimeRenderOption;
    return this;
  }

  /**
   * Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is SERIAL_NUMBER.
   * @return responseDateTimeRenderOption
   */
  @javax.annotation.Nullable
  public ResponseDateTimeRenderOptionEnum getResponseDateTimeRenderOption() {
    return responseDateTimeRenderOption;
  }

  public void setResponseDateTimeRenderOption(ResponseDateTimeRenderOptionEnum responseDateTimeRenderOption) {
    this.responseDateTimeRenderOption = responseDateTimeRenderOption;
  }


  public BatchUpdateValuesRequest responseValueRenderOption(ResponseValueRenderOptionEnum responseValueRenderOption) {
    this.responseValueRenderOption = responseValueRenderOption;
    return this;
  }

  /**
   * Determines how values in the response should be rendered. The default render option is FORMATTED_VALUE.
   * @return responseValueRenderOption
   */
  @javax.annotation.Nullable
  public ResponseValueRenderOptionEnum getResponseValueRenderOption() {
    return responseValueRenderOption;
  }

  public void setResponseValueRenderOption(ResponseValueRenderOptionEnum responseValueRenderOption) {
    this.responseValueRenderOption = responseValueRenderOption;
  }


  public BatchUpdateValuesRequest valueInputOption(ValueInputOptionEnum valueInputOption) {
    this.valueInputOption = valueInputOption;
    return this;
  }

  /**
   * How the input data should be interpreted.
   * @return valueInputOption
   */
  @javax.annotation.Nullable
  public ValueInputOptionEnum getValueInputOption() {
    return valueInputOption;
  }

  public void setValueInputOption(ValueInputOptionEnum valueInputOption) {
    this.valueInputOption = valueInputOption;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchUpdateValuesRequest batchUpdateValuesRequest = (BatchUpdateValuesRequest) o;
    return Objects.equals(this.data, batchUpdateValuesRequest.data) &&
        Objects.equals(this.includeValuesInResponse, batchUpdateValuesRequest.includeValuesInResponse) &&
        Objects.equals(this.responseDateTimeRenderOption, batchUpdateValuesRequest.responseDateTimeRenderOption) &&
        Objects.equals(this.responseValueRenderOption, batchUpdateValuesRequest.responseValueRenderOption) &&
        Objects.equals(this.valueInputOption, batchUpdateValuesRequest.valueInputOption);
  }

  @Override
  public int hashCode() {
    return Objects.hash(data, includeValuesInResponse, responseDateTimeRenderOption, responseValueRenderOption, valueInputOption);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchUpdateValuesRequest {\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    includeValuesInResponse: ").append(toIndentedString(includeValuesInResponse)).append("\n");
    sb.append("    responseDateTimeRenderOption: ").append(toIndentedString(responseDateTimeRenderOption)).append("\n");
    sb.append("    responseValueRenderOption: ").append(toIndentedString(responseValueRenderOption)).append("\n");
    sb.append("    valueInputOption: ").append(toIndentedString(valueInputOption)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("data");
    openapiFields.add("includeValuesInResponse");
    openapiFields.add("responseDateTimeRenderOption");
    openapiFields.add("responseValueRenderOption");
    openapiFields.add("valueInputOption");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchUpdateValuesRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchUpdateValuesRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchUpdateValuesRequest is not found in the empty JSON string", BatchUpdateValuesRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchUpdateValuesRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchUpdateValuesRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("data") != null && !jsonObj.get("data").isJsonNull()) {
        JsonArray jsonArraydata = jsonObj.getAsJsonArray("data");
        if (jsonArraydata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("data").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `data` to be an array in the JSON string but got `%s`", jsonObj.get("data").toString()));
          }

          // validate the optional field `data` (array)
          for (int i = 0; i < jsonArraydata.size(); i++) {
            ValueRange.validateJsonElement(jsonArraydata.get(i));
          };
        }
      }
      if ((jsonObj.get("responseDateTimeRenderOption") != null && !jsonObj.get("responseDateTimeRenderOption").isJsonNull()) && !jsonObj.get("responseDateTimeRenderOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `responseDateTimeRenderOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("responseDateTimeRenderOption").toString()));
      }
      // validate the optional field `responseDateTimeRenderOption`
      if (jsonObj.get("responseDateTimeRenderOption") != null && !jsonObj.get("responseDateTimeRenderOption").isJsonNull()) {
        ResponseDateTimeRenderOptionEnum.validateJsonElement(jsonObj.get("responseDateTimeRenderOption"));
      }
      if ((jsonObj.get("responseValueRenderOption") != null && !jsonObj.get("responseValueRenderOption").isJsonNull()) && !jsonObj.get("responseValueRenderOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `responseValueRenderOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("responseValueRenderOption").toString()));
      }
      // validate the optional field `responseValueRenderOption`
      if (jsonObj.get("responseValueRenderOption") != null && !jsonObj.get("responseValueRenderOption").isJsonNull()) {
        ResponseValueRenderOptionEnum.validateJsonElement(jsonObj.get("responseValueRenderOption"));
      }
      if ((jsonObj.get("valueInputOption") != null && !jsonObj.get("valueInputOption").isJsonNull()) && !jsonObj.get("valueInputOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valueInputOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valueInputOption").toString()));
      }
      // validate the optional field `valueInputOption`
      if (jsonObj.get("valueInputOption") != null && !jsonObj.get("valueInputOption").isJsonNull()) {
        ValueInputOptionEnum.validateJsonElement(jsonObj.get("valueInputOption"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchUpdateValuesRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchUpdateValuesRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchUpdateValuesRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchUpdateValuesRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchUpdateValuesRequest>() {
           @Override
           public void write(JsonWriter out, BatchUpdateValuesRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchUpdateValuesRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchUpdateValuesRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchUpdateValuesRequest
   * @throws IOException if the JSON string is invalid with respect to BatchUpdateValuesRequest
   */
  public static BatchUpdateValuesRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchUpdateValuesRequest.class);
  }

  /**
   * Convert an instance of BatchUpdateValuesRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

