/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ChartData;
import org.openapitools.client.model.Color;
import org.openapitools.client.model.ColorStyle;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An org chart. Org charts require a unique set of labels in labels and may optionally include parent_labels and tooltips. parent_labels contain, for each node, the label identifying the parent node. tooltips contain, for each node, an optional tooltip. For example, to describe an OrgChart with Alice as the CEO, Bob as the President (reporting to Alice) and Cathy as VP of Sales (also reporting to Alice), have labels contain \&quot;Alice\&quot;, \&quot;Bob\&quot;, \&quot;Cathy\&quot;, parent_labels contain \&quot;\&quot;, \&quot;Alice\&quot;, \&quot;Alice\&quot; and tooltips contain \&quot;CEO\&quot;, \&quot;President\&quot;, \&quot;VP Sales\&quot;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class OrgChartSpec {
  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private ChartData labels;

  public static final String SERIALIZED_NAME_NODE_COLOR = "nodeColor";
  @SerializedName(SERIALIZED_NAME_NODE_COLOR)
  private Color nodeColor;

  public static final String SERIALIZED_NAME_NODE_COLOR_STYLE = "nodeColorStyle";
  @SerializedName(SERIALIZED_NAME_NODE_COLOR_STYLE)
  private ColorStyle nodeColorStyle;

  /**
   * The size of the org chart nodes.
   */
  @JsonAdapter(NodeSizeEnum.Adapter.class)
  public enum NodeSizeEnum {
    ORG_CHART_LABEL_SIZE_UNSPECIFIED("ORG_CHART_LABEL_SIZE_UNSPECIFIED"),
    
    SMALL("SMALL"),
    
    MEDIUM("MEDIUM"),
    
    LARGE("LARGE");

    private String value;

    NodeSizeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NodeSizeEnum fromValue(String value) {
      for (NodeSizeEnum b : NodeSizeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<NodeSizeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NodeSizeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NodeSizeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NodeSizeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      NodeSizeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_NODE_SIZE = "nodeSize";
  @SerializedName(SERIALIZED_NAME_NODE_SIZE)
  private NodeSizeEnum nodeSize;

  public static final String SERIALIZED_NAME_PARENT_LABELS = "parentLabels";
  @SerializedName(SERIALIZED_NAME_PARENT_LABELS)
  private ChartData parentLabels;

  public static final String SERIALIZED_NAME_SELECTED_NODE_COLOR = "selectedNodeColor";
  @SerializedName(SERIALIZED_NAME_SELECTED_NODE_COLOR)
  private Color selectedNodeColor;

  public static final String SERIALIZED_NAME_SELECTED_NODE_COLOR_STYLE = "selectedNodeColorStyle";
  @SerializedName(SERIALIZED_NAME_SELECTED_NODE_COLOR_STYLE)
  private ColorStyle selectedNodeColorStyle;

  public static final String SERIALIZED_NAME_TOOLTIPS = "tooltips";
  @SerializedName(SERIALIZED_NAME_TOOLTIPS)
  private ChartData tooltips;

  public OrgChartSpec() {
  }

  public OrgChartSpec labels(ChartData labels) {
    this.labels = labels;
    return this;
  }

  /**
   * Get labels
   * @return labels
   */
  @javax.annotation.Nullable
  public ChartData getLabels() {
    return labels;
  }

  public void setLabels(ChartData labels) {
    this.labels = labels;
  }


  public OrgChartSpec nodeColor(Color nodeColor) {
    this.nodeColor = nodeColor;
    return this;
  }

  /**
   * Get nodeColor
   * @return nodeColor
   */
  @javax.annotation.Nullable
  public Color getNodeColor() {
    return nodeColor;
  }

  public void setNodeColor(Color nodeColor) {
    this.nodeColor = nodeColor;
  }


  public OrgChartSpec nodeColorStyle(ColorStyle nodeColorStyle) {
    this.nodeColorStyle = nodeColorStyle;
    return this;
  }

  /**
   * Get nodeColorStyle
   * @return nodeColorStyle
   */
  @javax.annotation.Nullable
  public ColorStyle getNodeColorStyle() {
    return nodeColorStyle;
  }

  public void setNodeColorStyle(ColorStyle nodeColorStyle) {
    this.nodeColorStyle = nodeColorStyle;
  }


  public OrgChartSpec nodeSize(NodeSizeEnum nodeSize) {
    this.nodeSize = nodeSize;
    return this;
  }

  /**
   * The size of the org chart nodes.
   * @return nodeSize
   */
  @javax.annotation.Nullable
  public NodeSizeEnum getNodeSize() {
    return nodeSize;
  }

  public void setNodeSize(NodeSizeEnum nodeSize) {
    this.nodeSize = nodeSize;
  }


  public OrgChartSpec parentLabels(ChartData parentLabels) {
    this.parentLabels = parentLabels;
    return this;
  }

  /**
   * Get parentLabels
   * @return parentLabels
   */
  @javax.annotation.Nullable
  public ChartData getParentLabels() {
    return parentLabels;
  }

  public void setParentLabels(ChartData parentLabels) {
    this.parentLabels = parentLabels;
  }


  public OrgChartSpec selectedNodeColor(Color selectedNodeColor) {
    this.selectedNodeColor = selectedNodeColor;
    return this;
  }

  /**
   * Get selectedNodeColor
   * @return selectedNodeColor
   */
  @javax.annotation.Nullable
  public Color getSelectedNodeColor() {
    return selectedNodeColor;
  }

  public void setSelectedNodeColor(Color selectedNodeColor) {
    this.selectedNodeColor = selectedNodeColor;
  }


  public OrgChartSpec selectedNodeColorStyle(ColorStyle selectedNodeColorStyle) {
    this.selectedNodeColorStyle = selectedNodeColorStyle;
    return this;
  }

  /**
   * Get selectedNodeColorStyle
   * @return selectedNodeColorStyle
   */
  @javax.annotation.Nullable
  public ColorStyle getSelectedNodeColorStyle() {
    return selectedNodeColorStyle;
  }

  public void setSelectedNodeColorStyle(ColorStyle selectedNodeColorStyle) {
    this.selectedNodeColorStyle = selectedNodeColorStyle;
  }


  public OrgChartSpec tooltips(ChartData tooltips) {
    this.tooltips = tooltips;
    return this;
  }

  /**
   * Get tooltips
   * @return tooltips
   */
  @javax.annotation.Nullable
  public ChartData getTooltips() {
    return tooltips;
  }

  public void setTooltips(ChartData tooltips) {
    this.tooltips = tooltips;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OrgChartSpec orgChartSpec = (OrgChartSpec) o;
    return Objects.equals(this.labels, orgChartSpec.labels) &&
        Objects.equals(this.nodeColor, orgChartSpec.nodeColor) &&
        Objects.equals(this.nodeColorStyle, orgChartSpec.nodeColorStyle) &&
        Objects.equals(this.nodeSize, orgChartSpec.nodeSize) &&
        Objects.equals(this.parentLabels, orgChartSpec.parentLabels) &&
        Objects.equals(this.selectedNodeColor, orgChartSpec.selectedNodeColor) &&
        Objects.equals(this.selectedNodeColorStyle, orgChartSpec.selectedNodeColorStyle) &&
        Objects.equals(this.tooltips, orgChartSpec.tooltips);
  }

  @Override
  public int hashCode() {
    return Objects.hash(labels, nodeColor, nodeColorStyle, nodeSize, parentLabels, selectedNodeColor, selectedNodeColorStyle, tooltips);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OrgChartSpec {\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    nodeColor: ").append(toIndentedString(nodeColor)).append("\n");
    sb.append("    nodeColorStyle: ").append(toIndentedString(nodeColorStyle)).append("\n");
    sb.append("    nodeSize: ").append(toIndentedString(nodeSize)).append("\n");
    sb.append("    parentLabels: ").append(toIndentedString(parentLabels)).append("\n");
    sb.append("    selectedNodeColor: ").append(toIndentedString(selectedNodeColor)).append("\n");
    sb.append("    selectedNodeColorStyle: ").append(toIndentedString(selectedNodeColorStyle)).append("\n");
    sb.append("    tooltips: ").append(toIndentedString(tooltips)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("labels");
    openapiFields.add("nodeColor");
    openapiFields.add("nodeColorStyle");
    openapiFields.add("nodeSize");
    openapiFields.add("parentLabels");
    openapiFields.add("selectedNodeColor");
    openapiFields.add("selectedNodeColorStyle");
    openapiFields.add("tooltips");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OrgChartSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OrgChartSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OrgChartSpec is not found in the empty JSON string", OrgChartSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OrgChartSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OrgChartSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `labels`
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("labels"));
      }
      // validate the optional field `nodeColor`
      if (jsonObj.get("nodeColor") != null && !jsonObj.get("nodeColor").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("nodeColor"));
      }
      // validate the optional field `nodeColorStyle`
      if (jsonObj.get("nodeColorStyle") != null && !jsonObj.get("nodeColorStyle").isJsonNull()) {
        ColorStyle.validateJsonElement(jsonObj.get("nodeColorStyle"));
      }
      if ((jsonObj.get("nodeSize") != null && !jsonObj.get("nodeSize").isJsonNull()) && !jsonObj.get("nodeSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeSize").toString()));
      }
      // validate the optional field `nodeSize`
      if (jsonObj.get("nodeSize") != null && !jsonObj.get("nodeSize").isJsonNull()) {
        NodeSizeEnum.validateJsonElement(jsonObj.get("nodeSize"));
      }
      // validate the optional field `parentLabels`
      if (jsonObj.get("parentLabels") != null && !jsonObj.get("parentLabels").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("parentLabels"));
      }
      // validate the optional field `selectedNodeColor`
      if (jsonObj.get("selectedNodeColor") != null && !jsonObj.get("selectedNodeColor").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("selectedNodeColor"));
      }
      // validate the optional field `selectedNodeColorStyle`
      if (jsonObj.get("selectedNodeColorStyle") != null && !jsonObj.get("selectedNodeColorStyle").isJsonNull()) {
        ColorStyle.validateJsonElement(jsonObj.get("selectedNodeColorStyle"));
      }
      // validate the optional field `tooltips`
      if (jsonObj.get("tooltips") != null && !jsonObj.get("tooltips").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("tooltips"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OrgChartSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OrgChartSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OrgChartSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OrgChartSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<OrgChartSpec>() {
           @Override
           public void write(JsonWriter out, OrgChartSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OrgChartSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OrgChartSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OrgChartSpec
   * @throws IOException if the JSON string is invalid with respect to OrgChartSpec
   */
  public static OrgChartSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OrgChartSpec.class);
  }

  /**
   * Convert an instance of OrgChartSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

