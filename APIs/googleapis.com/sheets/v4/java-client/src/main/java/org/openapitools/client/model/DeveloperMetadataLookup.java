/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DeveloperMetadataLocation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeveloperMetadataLookup {
  /**
   * Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
   */
  @JsonAdapter(LocationMatchingStrategyEnum.Adapter.class)
  public enum LocationMatchingStrategyEnum {
    DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED("DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED"),
    
    EXACT_LOCATION("EXACT_LOCATION"),
    
    INTERSECTING_LOCATION("INTERSECTING_LOCATION");

    private String value;

    LocationMatchingStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LocationMatchingStrategyEnum fromValue(String value) {
      for (LocationMatchingStrategyEnum b : LocationMatchingStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LocationMatchingStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LocationMatchingStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LocationMatchingStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LocationMatchingStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LocationMatchingStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOCATION_MATCHING_STRATEGY = "locationMatchingStrategy";
  @SerializedName(SERIALIZED_NAME_LOCATION_MATCHING_STRATEGY)
  private LocationMatchingStrategyEnum locationMatchingStrategy;

  /**
   * Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
   */
  @JsonAdapter(LocationTypeEnum.Adapter.class)
  public enum LocationTypeEnum {
    DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED("DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED"),
    
    ROW("ROW"),
    
    COLUMN("COLUMN"),
    
    SHEET("SHEET"),
    
    SPREADSHEET("SPREADSHEET");

    private String value;

    LocationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LocationTypeEnum fromValue(String value) {
      for (LocationTypeEnum b : LocationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LocationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LocationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LocationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LocationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LocationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOCATION_TYPE = "locationType";
  @SerializedName(SERIALIZED_NAME_LOCATION_TYPE)
  private LocationTypeEnum locationType;

  public static final String SERIALIZED_NAME_METADATA_ID = "metadataId";
  @SerializedName(SERIALIZED_NAME_METADATA_ID)
  private Integer metadataId;

  public static final String SERIALIZED_NAME_METADATA_KEY = "metadataKey";
  @SerializedName(SERIALIZED_NAME_METADATA_KEY)
  private String metadataKey;

  public static final String SERIALIZED_NAME_METADATA_LOCATION = "metadataLocation";
  @SerializedName(SERIALIZED_NAME_METADATA_LOCATION)
  private DeveloperMetadataLocation metadataLocation;

  public static final String SERIALIZED_NAME_METADATA_VALUE = "metadataValue";
  @SerializedName(SERIALIZED_NAME_METADATA_VALUE)
  private String metadataValue;

  /**
   * Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
   */
  @JsonAdapter(VisibilityEnum.Adapter.class)
  public enum VisibilityEnum {
    DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED("DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED"),
    
    DOCUMENT("DOCUMENT"),
    
    PROJECT("PROJECT");

    private String value;

    VisibilityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VisibilityEnum fromValue(String value) {
      for (VisibilityEnum b : VisibilityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VisibilityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VisibilityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VisibilityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VisibilityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VisibilityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VISIBILITY = "visibility";
  @SerializedName(SERIALIZED_NAME_VISIBILITY)
  private VisibilityEnum visibility;

  public DeveloperMetadataLookup() {
  }

  public DeveloperMetadataLookup locationMatchingStrategy(LocationMatchingStrategyEnum locationMatchingStrategy) {
    this.locationMatchingStrategy = locationMatchingStrategy;
    return this;
  }

  /**
   * Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
   * @return locationMatchingStrategy
   */
  @javax.annotation.Nullable
  public LocationMatchingStrategyEnum getLocationMatchingStrategy() {
    return locationMatchingStrategy;
  }

  public void setLocationMatchingStrategy(LocationMatchingStrategyEnum locationMatchingStrategy) {
    this.locationMatchingStrategy = locationMatchingStrategy;
  }


  public DeveloperMetadataLookup locationType(LocationTypeEnum locationType) {
    this.locationType = locationType;
    return this;
  }

  /**
   * Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
   * @return locationType
   */
  @javax.annotation.Nullable
  public LocationTypeEnum getLocationType() {
    return locationType;
  }

  public void setLocationType(LocationTypeEnum locationType) {
    this.locationType = locationType;
  }


  public DeveloperMetadataLookup metadataId(Integer metadataId) {
    this.metadataId = metadataId;
    return this;
  }

  /**
   * Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
   * @return metadataId
   */
  @javax.annotation.Nullable
  public Integer getMetadataId() {
    return metadataId;
  }

  public void setMetadataId(Integer metadataId) {
    this.metadataId = metadataId;
  }


  public DeveloperMetadataLookup metadataKey(String metadataKey) {
    this.metadataKey = metadataKey;
    return this;
  }

  /**
   * Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
   * @return metadataKey
   */
  @javax.annotation.Nullable
  public String getMetadataKey() {
    return metadataKey;
  }

  public void setMetadataKey(String metadataKey) {
    this.metadataKey = metadataKey;
  }


  public DeveloperMetadataLookup metadataLocation(DeveloperMetadataLocation metadataLocation) {
    this.metadataLocation = metadataLocation;
    return this;
  }

  /**
   * Get metadataLocation
   * @return metadataLocation
   */
  @javax.annotation.Nullable
  public DeveloperMetadataLocation getMetadataLocation() {
    return metadataLocation;
  }

  public void setMetadataLocation(DeveloperMetadataLocation metadataLocation) {
    this.metadataLocation = metadataLocation;
  }


  public DeveloperMetadataLookup metadataValue(String metadataValue) {
    this.metadataValue = metadataValue;
    return this;
  }

  /**
   * Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
   * @return metadataValue
   */
  @javax.annotation.Nullable
  public String getMetadataValue() {
    return metadataValue;
  }

  public void setMetadataValue(String metadataValue) {
    this.metadataValue = metadataValue;
  }


  public DeveloperMetadataLookup visibility(VisibilityEnum visibility) {
    this.visibility = visibility;
    return this;
  }

  /**
   * Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
   * @return visibility
   */
  @javax.annotation.Nullable
  public VisibilityEnum getVisibility() {
    return visibility;
  }

  public void setVisibility(VisibilityEnum visibility) {
    this.visibility = visibility;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeveloperMetadataLookup developerMetadataLookup = (DeveloperMetadataLookup) o;
    return Objects.equals(this.locationMatchingStrategy, developerMetadataLookup.locationMatchingStrategy) &&
        Objects.equals(this.locationType, developerMetadataLookup.locationType) &&
        Objects.equals(this.metadataId, developerMetadataLookup.metadataId) &&
        Objects.equals(this.metadataKey, developerMetadataLookup.metadataKey) &&
        Objects.equals(this.metadataLocation, developerMetadataLookup.metadataLocation) &&
        Objects.equals(this.metadataValue, developerMetadataLookup.metadataValue) &&
        Objects.equals(this.visibility, developerMetadataLookup.visibility);
  }

  @Override
  public int hashCode() {
    return Objects.hash(locationMatchingStrategy, locationType, metadataId, metadataKey, metadataLocation, metadataValue, visibility);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeveloperMetadataLookup {\n");
    sb.append("    locationMatchingStrategy: ").append(toIndentedString(locationMatchingStrategy)).append("\n");
    sb.append("    locationType: ").append(toIndentedString(locationType)).append("\n");
    sb.append("    metadataId: ").append(toIndentedString(metadataId)).append("\n");
    sb.append("    metadataKey: ").append(toIndentedString(metadataKey)).append("\n");
    sb.append("    metadataLocation: ").append(toIndentedString(metadataLocation)).append("\n");
    sb.append("    metadataValue: ").append(toIndentedString(metadataValue)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("locationMatchingStrategy");
    openapiFields.add("locationType");
    openapiFields.add("metadataId");
    openapiFields.add("metadataKey");
    openapiFields.add("metadataLocation");
    openapiFields.add("metadataValue");
    openapiFields.add("visibility");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeveloperMetadataLookup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeveloperMetadataLookup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeveloperMetadataLookup is not found in the empty JSON string", DeveloperMetadataLookup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeveloperMetadataLookup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeveloperMetadataLookup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("locationMatchingStrategy") != null && !jsonObj.get("locationMatchingStrategy").isJsonNull()) && !jsonObj.get("locationMatchingStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locationMatchingStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locationMatchingStrategy").toString()));
      }
      // validate the optional field `locationMatchingStrategy`
      if (jsonObj.get("locationMatchingStrategy") != null && !jsonObj.get("locationMatchingStrategy").isJsonNull()) {
        LocationMatchingStrategyEnum.validateJsonElement(jsonObj.get("locationMatchingStrategy"));
      }
      if ((jsonObj.get("locationType") != null && !jsonObj.get("locationType").isJsonNull()) && !jsonObj.get("locationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locationType").toString()));
      }
      // validate the optional field `locationType`
      if (jsonObj.get("locationType") != null && !jsonObj.get("locationType").isJsonNull()) {
        LocationTypeEnum.validateJsonElement(jsonObj.get("locationType"));
      }
      if ((jsonObj.get("metadataKey") != null && !jsonObj.get("metadataKey").isJsonNull()) && !jsonObj.get("metadataKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadataKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadataKey").toString()));
      }
      // validate the optional field `metadataLocation`
      if (jsonObj.get("metadataLocation") != null && !jsonObj.get("metadataLocation").isJsonNull()) {
        DeveloperMetadataLocation.validateJsonElement(jsonObj.get("metadataLocation"));
      }
      if ((jsonObj.get("metadataValue") != null && !jsonObj.get("metadataValue").isJsonNull()) && !jsonObj.get("metadataValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadataValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadataValue").toString()));
      }
      if ((jsonObj.get("visibility") != null && !jsonObj.get("visibility").isJsonNull()) && !jsonObj.get("visibility").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `visibility` to be a primitive type in the JSON string but got `%s`", jsonObj.get("visibility").toString()));
      }
      // validate the optional field `visibility`
      if (jsonObj.get("visibility") != null && !jsonObj.get("visibility").isJsonNull()) {
        VisibilityEnum.validateJsonElement(jsonObj.get("visibility"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeveloperMetadataLookup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeveloperMetadataLookup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeveloperMetadataLookup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeveloperMetadataLookup.class));

       return (TypeAdapter<T>) new TypeAdapter<DeveloperMetadataLookup>() {
           @Override
           public void write(JsonWriter out, DeveloperMetadataLookup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeveloperMetadataLookup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeveloperMetadataLookup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeveloperMetadataLookup
   * @throws IOException if the JSON string is invalid with respect to DeveloperMetadataLookup
   */
  public static DeveloperMetadataLookup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeveloperMetadataLookup.class);
  }

  /**
   * Convert an instance of DeveloperMetadataLookup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

