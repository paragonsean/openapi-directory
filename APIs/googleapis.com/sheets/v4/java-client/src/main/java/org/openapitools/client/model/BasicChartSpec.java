/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BasicChartAxis;
import org.openapitools.client.model.BasicChartDomain;
import org.openapitools.client.model.BasicChartSeries;
import org.openapitools.client.model.DataLabel;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The specification for a basic chart. See BasicChartType for the list of charts this supports.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BasicChartSpec {
  public static final String SERIALIZED_NAME_AXIS = "axis";
  @SerializedName(SERIALIZED_NAME_AXIS)
  private List<BasicChartAxis> axis = new ArrayList<>();

  /**
   * The type of the chart.
   */
  @JsonAdapter(ChartTypeEnum.Adapter.class)
  public enum ChartTypeEnum {
    BASIC_CHART_TYPE_UNSPECIFIED("BASIC_CHART_TYPE_UNSPECIFIED"),
    
    BAR("BAR"),
    
    LINE("LINE"),
    
    AREA("AREA"),
    
    COLUMN("COLUMN"),
    
    SCATTER("SCATTER"),
    
    COMBO("COMBO"),
    
    STEPPED_AREA("STEPPED_AREA");

    private String value;

    ChartTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ChartTypeEnum fromValue(String value) {
      for (ChartTypeEnum b : ChartTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ChartTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ChartTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ChartTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ChartTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ChartTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CHART_TYPE = "chartType";
  @SerializedName(SERIALIZED_NAME_CHART_TYPE)
  private ChartTypeEnum chartType;

  /**
   * The behavior of tooltips and data highlighting when hovering on data and chart area.
   */
  @JsonAdapter(CompareModeEnum.Adapter.class)
  public enum CompareModeEnum {
    BASIC_CHART_COMPARE_MODE_UNSPECIFIED("BASIC_CHART_COMPARE_MODE_UNSPECIFIED"),
    
    DATUM("DATUM"),
    
    CATEGORY("CATEGORY");

    private String value;

    CompareModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CompareModeEnum fromValue(String value) {
      for (CompareModeEnum b : CompareModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CompareModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CompareModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CompareModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CompareModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CompareModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMPARE_MODE = "compareMode";
  @SerializedName(SERIALIZED_NAME_COMPARE_MODE)
  private CompareModeEnum compareMode;

  public static final String SERIALIZED_NAME_DOMAINS = "domains";
  @SerializedName(SERIALIZED_NAME_DOMAINS)
  private List<BasicChartDomain> domains = new ArrayList<>();

  public static final String SERIALIZED_NAME_HEADER_COUNT = "headerCount";
  @SerializedName(SERIALIZED_NAME_HEADER_COUNT)
  private Integer headerCount;

  public static final String SERIALIZED_NAME_INTERPOLATE_NULLS = "interpolateNulls";
  @SerializedName(SERIALIZED_NAME_INTERPOLATE_NULLS)
  private Boolean interpolateNulls;

  /**
   * The position of the chart legend.
   */
  @JsonAdapter(LegendPositionEnum.Adapter.class)
  public enum LegendPositionEnum {
    BASIC_CHART_LEGEND_POSITION_UNSPECIFIED("BASIC_CHART_LEGEND_POSITION_UNSPECIFIED"),
    
    BOTTOM_LEGEND("BOTTOM_LEGEND"),
    
    LEFT_LEGEND("LEFT_LEGEND"),
    
    RIGHT_LEGEND("RIGHT_LEGEND"),
    
    TOP_LEGEND("TOP_LEGEND"),
    
    NO_LEGEND("NO_LEGEND");

    private String value;

    LegendPositionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LegendPositionEnum fromValue(String value) {
      for (LegendPositionEnum b : LegendPositionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LegendPositionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LegendPositionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LegendPositionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LegendPositionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LegendPositionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LEGEND_POSITION = "legendPosition";
  @SerializedName(SERIALIZED_NAME_LEGEND_POSITION)
  private LegendPositionEnum legendPosition;

  public static final String SERIALIZED_NAME_LINE_SMOOTHING = "lineSmoothing";
  @SerializedName(SERIALIZED_NAME_LINE_SMOOTHING)
  private Boolean lineSmoothing;

  public static final String SERIALIZED_NAME_SERIES = "series";
  @SerializedName(SERIALIZED_NAME_SERIES)
  private List<BasicChartSeries> series = new ArrayList<>();

  /**
   * The stacked type for charts that support vertical stacking. Applies to Area, Bar, Column, Combo, and Stepped Area charts.
   */
  @JsonAdapter(StackedTypeEnum.Adapter.class)
  public enum StackedTypeEnum {
    BASIC_CHART_STACKED_TYPE_UNSPECIFIED("BASIC_CHART_STACKED_TYPE_UNSPECIFIED"),
    
    NOT_STACKED("NOT_STACKED"),
    
    STACKED("STACKED"),
    
    PERCENT_STACKED("PERCENT_STACKED");

    private String value;

    StackedTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StackedTypeEnum fromValue(String value) {
      for (StackedTypeEnum b : StackedTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StackedTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StackedTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StackedTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StackedTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StackedTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STACKED_TYPE = "stackedType";
  @SerializedName(SERIALIZED_NAME_STACKED_TYPE)
  private StackedTypeEnum stackedType;

  public static final String SERIALIZED_NAME_THREE_DIMENSIONAL = "threeDimensional";
  @SerializedName(SERIALIZED_NAME_THREE_DIMENSIONAL)
  private Boolean threeDimensional;

  public static final String SERIALIZED_NAME_TOTAL_DATA_LABEL = "totalDataLabel";
  @SerializedName(SERIALIZED_NAME_TOTAL_DATA_LABEL)
  private DataLabel totalDataLabel;

  public BasicChartSpec() {
  }

  public BasicChartSpec axis(List<BasicChartAxis> axis) {
    this.axis = axis;
    return this;
  }

  public BasicChartSpec addAxisItem(BasicChartAxis axisItem) {
    if (this.axis == null) {
      this.axis = new ArrayList<>();
    }
    this.axis.add(axisItem);
    return this;
  }

  /**
   * The axis on the chart.
   * @return axis
   */
  @javax.annotation.Nullable
  public List<BasicChartAxis> getAxis() {
    return axis;
  }

  public void setAxis(List<BasicChartAxis> axis) {
    this.axis = axis;
  }


  public BasicChartSpec chartType(ChartTypeEnum chartType) {
    this.chartType = chartType;
    return this;
  }

  /**
   * The type of the chart.
   * @return chartType
   */
  @javax.annotation.Nullable
  public ChartTypeEnum getChartType() {
    return chartType;
  }

  public void setChartType(ChartTypeEnum chartType) {
    this.chartType = chartType;
  }


  public BasicChartSpec compareMode(CompareModeEnum compareMode) {
    this.compareMode = compareMode;
    return this;
  }

  /**
   * The behavior of tooltips and data highlighting when hovering on data and chart area.
   * @return compareMode
   */
  @javax.annotation.Nullable
  public CompareModeEnum getCompareMode() {
    return compareMode;
  }

  public void setCompareMode(CompareModeEnum compareMode) {
    this.compareMode = compareMode;
  }


  public BasicChartSpec domains(List<BasicChartDomain> domains) {
    this.domains = domains;
    return this;
  }

  public BasicChartSpec addDomainsItem(BasicChartDomain domainsItem) {
    if (this.domains == null) {
      this.domains = new ArrayList<>();
    }
    this.domains.add(domainsItem);
    return this;
  }

  /**
   * The domain of data this is charting. Only a single domain is supported.
   * @return domains
   */
  @javax.annotation.Nullable
  public List<BasicChartDomain> getDomains() {
    return domains;
  }

  public void setDomains(List<BasicChartDomain> domains) {
    this.domains = domains;
  }


  public BasicChartSpec headerCount(Integer headerCount) {
    this.headerCount = headerCount;
    return this;
  }

  /**
   * The number of rows or columns in the data that are \&quot;headers\&quot;. If not set, Google Sheets will guess how many rows are headers based on the data. (Note that BasicChartAxis.title may override the axis title inferred from the header values.)
   * @return headerCount
   */
  @javax.annotation.Nullable
  public Integer getHeaderCount() {
    return headerCount;
  }

  public void setHeaderCount(Integer headerCount) {
    this.headerCount = headerCount;
  }


  public BasicChartSpec interpolateNulls(Boolean interpolateNulls) {
    this.interpolateNulls = interpolateNulls;
    return this;
  }

  /**
   * If some values in a series are missing, gaps may appear in the chart (e.g, segments of lines in a line chart will be missing). To eliminate these gaps set this to true. Applies to Line, Area, and Combo charts.
   * @return interpolateNulls
   */
  @javax.annotation.Nullable
  public Boolean getInterpolateNulls() {
    return interpolateNulls;
  }

  public void setInterpolateNulls(Boolean interpolateNulls) {
    this.interpolateNulls = interpolateNulls;
  }


  public BasicChartSpec legendPosition(LegendPositionEnum legendPosition) {
    this.legendPosition = legendPosition;
    return this;
  }

  /**
   * The position of the chart legend.
   * @return legendPosition
   */
  @javax.annotation.Nullable
  public LegendPositionEnum getLegendPosition() {
    return legendPosition;
  }

  public void setLegendPosition(LegendPositionEnum legendPosition) {
    this.legendPosition = legendPosition;
  }


  public BasicChartSpec lineSmoothing(Boolean lineSmoothing) {
    this.lineSmoothing = lineSmoothing;
    return this;
  }

  /**
   * Gets whether all lines should be rendered smooth or straight by default. Applies to Line charts.
   * @return lineSmoothing
   */
  @javax.annotation.Nullable
  public Boolean getLineSmoothing() {
    return lineSmoothing;
  }

  public void setLineSmoothing(Boolean lineSmoothing) {
    this.lineSmoothing = lineSmoothing;
  }


  public BasicChartSpec series(List<BasicChartSeries> series) {
    this.series = series;
    return this;
  }

  public BasicChartSpec addSeriesItem(BasicChartSeries seriesItem) {
    if (this.series == null) {
      this.series = new ArrayList<>();
    }
    this.series.add(seriesItem);
    return this;
  }

  /**
   * The data this chart is visualizing.
   * @return series
   */
  @javax.annotation.Nullable
  public List<BasicChartSeries> getSeries() {
    return series;
  }

  public void setSeries(List<BasicChartSeries> series) {
    this.series = series;
  }


  public BasicChartSpec stackedType(StackedTypeEnum stackedType) {
    this.stackedType = stackedType;
    return this;
  }

  /**
   * The stacked type for charts that support vertical stacking. Applies to Area, Bar, Column, Combo, and Stepped Area charts.
   * @return stackedType
   */
  @javax.annotation.Nullable
  public StackedTypeEnum getStackedType() {
    return stackedType;
  }

  public void setStackedType(StackedTypeEnum stackedType) {
    this.stackedType = stackedType;
  }


  public BasicChartSpec threeDimensional(Boolean threeDimensional) {
    this.threeDimensional = threeDimensional;
    return this;
  }

  /**
   * True to make the chart 3D. Applies to Bar and Column charts.
   * @return threeDimensional
   */
  @javax.annotation.Nullable
  public Boolean getThreeDimensional() {
    return threeDimensional;
  }

  public void setThreeDimensional(Boolean threeDimensional) {
    this.threeDimensional = threeDimensional;
  }


  public BasicChartSpec totalDataLabel(DataLabel totalDataLabel) {
    this.totalDataLabel = totalDataLabel;
    return this;
  }

  /**
   * Get totalDataLabel
   * @return totalDataLabel
   */
  @javax.annotation.Nullable
  public DataLabel getTotalDataLabel() {
    return totalDataLabel;
  }

  public void setTotalDataLabel(DataLabel totalDataLabel) {
    this.totalDataLabel = totalDataLabel;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BasicChartSpec basicChartSpec = (BasicChartSpec) o;
    return Objects.equals(this.axis, basicChartSpec.axis) &&
        Objects.equals(this.chartType, basicChartSpec.chartType) &&
        Objects.equals(this.compareMode, basicChartSpec.compareMode) &&
        Objects.equals(this.domains, basicChartSpec.domains) &&
        Objects.equals(this.headerCount, basicChartSpec.headerCount) &&
        Objects.equals(this.interpolateNulls, basicChartSpec.interpolateNulls) &&
        Objects.equals(this.legendPosition, basicChartSpec.legendPosition) &&
        Objects.equals(this.lineSmoothing, basicChartSpec.lineSmoothing) &&
        Objects.equals(this.series, basicChartSpec.series) &&
        Objects.equals(this.stackedType, basicChartSpec.stackedType) &&
        Objects.equals(this.threeDimensional, basicChartSpec.threeDimensional) &&
        Objects.equals(this.totalDataLabel, basicChartSpec.totalDataLabel);
  }

  @Override
  public int hashCode() {
    return Objects.hash(axis, chartType, compareMode, domains, headerCount, interpolateNulls, legendPosition, lineSmoothing, series, stackedType, threeDimensional, totalDataLabel);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BasicChartSpec {\n");
    sb.append("    axis: ").append(toIndentedString(axis)).append("\n");
    sb.append("    chartType: ").append(toIndentedString(chartType)).append("\n");
    sb.append("    compareMode: ").append(toIndentedString(compareMode)).append("\n");
    sb.append("    domains: ").append(toIndentedString(domains)).append("\n");
    sb.append("    headerCount: ").append(toIndentedString(headerCount)).append("\n");
    sb.append("    interpolateNulls: ").append(toIndentedString(interpolateNulls)).append("\n");
    sb.append("    legendPosition: ").append(toIndentedString(legendPosition)).append("\n");
    sb.append("    lineSmoothing: ").append(toIndentedString(lineSmoothing)).append("\n");
    sb.append("    series: ").append(toIndentedString(series)).append("\n");
    sb.append("    stackedType: ").append(toIndentedString(stackedType)).append("\n");
    sb.append("    threeDimensional: ").append(toIndentedString(threeDimensional)).append("\n");
    sb.append("    totalDataLabel: ").append(toIndentedString(totalDataLabel)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("axis");
    openapiFields.add("chartType");
    openapiFields.add("compareMode");
    openapiFields.add("domains");
    openapiFields.add("headerCount");
    openapiFields.add("interpolateNulls");
    openapiFields.add("legendPosition");
    openapiFields.add("lineSmoothing");
    openapiFields.add("series");
    openapiFields.add("stackedType");
    openapiFields.add("threeDimensional");
    openapiFields.add("totalDataLabel");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BasicChartSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BasicChartSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BasicChartSpec is not found in the empty JSON string", BasicChartSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BasicChartSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BasicChartSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("axis") != null && !jsonObj.get("axis").isJsonNull()) {
        JsonArray jsonArrayaxis = jsonObj.getAsJsonArray("axis");
        if (jsonArrayaxis != null) {
          // ensure the json data is an array
          if (!jsonObj.get("axis").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `axis` to be an array in the JSON string but got `%s`", jsonObj.get("axis").toString()));
          }

          // validate the optional field `axis` (array)
          for (int i = 0; i < jsonArrayaxis.size(); i++) {
            BasicChartAxis.validateJsonElement(jsonArrayaxis.get(i));
          };
        }
      }
      if ((jsonObj.get("chartType") != null && !jsonObj.get("chartType").isJsonNull()) && !jsonObj.get("chartType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chartType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chartType").toString()));
      }
      // validate the optional field `chartType`
      if (jsonObj.get("chartType") != null && !jsonObj.get("chartType").isJsonNull()) {
        ChartTypeEnum.validateJsonElement(jsonObj.get("chartType"));
      }
      if ((jsonObj.get("compareMode") != null && !jsonObj.get("compareMode").isJsonNull()) && !jsonObj.get("compareMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compareMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compareMode").toString()));
      }
      // validate the optional field `compareMode`
      if (jsonObj.get("compareMode") != null && !jsonObj.get("compareMode").isJsonNull()) {
        CompareModeEnum.validateJsonElement(jsonObj.get("compareMode"));
      }
      if (jsonObj.get("domains") != null && !jsonObj.get("domains").isJsonNull()) {
        JsonArray jsonArraydomains = jsonObj.getAsJsonArray("domains");
        if (jsonArraydomains != null) {
          // ensure the json data is an array
          if (!jsonObj.get("domains").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `domains` to be an array in the JSON string but got `%s`", jsonObj.get("domains").toString()));
          }

          // validate the optional field `domains` (array)
          for (int i = 0; i < jsonArraydomains.size(); i++) {
            BasicChartDomain.validateJsonElement(jsonArraydomains.get(i));
          };
        }
      }
      if ((jsonObj.get("legendPosition") != null && !jsonObj.get("legendPosition").isJsonNull()) && !jsonObj.get("legendPosition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `legendPosition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("legendPosition").toString()));
      }
      // validate the optional field `legendPosition`
      if (jsonObj.get("legendPosition") != null && !jsonObj.get("legendPosition").isJsonNull()) {
        LegendPositionEnum.validateJsonElement(jsonObj.get("legendPosition"));
      }
      if (jsonObj.get("series") != null && !jsonObj.get("series").isJsonNull()) {
        JsonArray jsonArrayseries = jsonObj.getAsJsonArray("series");
        if (jsonArrayseries != null) {
          // ensure the json data is an array
          if (!jsonObj.get("series").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `series` to be an array in the JSON string but got `%s`", jsonObj.get("series").toString()));
          }

          // validate the optional field `series` (array)
          for (int i = 0; i < jsonArrayseries.size(); i++) {
            BasicChartSeries.validateJsonElement(jsonArrayseries.get(i));
          };
        }
      }
      if ((jsonObj.get("stackedType") != null && !jsonObj.get("stackedType").isJsonNull()) && !jsonObj.get("stackedType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stackedType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stackedType").toString()));
      }
      // validate the optional field `stackedType`
      if (jsonObj.get("stackedType") != null && !jsonObj.get("stackedType").isJsonNull()) {
        StackedTypeEnum.validateJsonElement(jsonObj.get("stackedType"));
      }
      // validate the optional field `totalDataLabel`
      if (jsonObj.get("totalDataLabel") != null && !jsonObj.get("totalDataLabel").isJsonNull()) {
        DataLabel.validateJsonElement(jsonObj.get("totalDataLabel"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BasicChartSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BasicChartSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BasicChartSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BasicChartSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<BasicChartSpec>() {
           @Override
           public void write(JsonWriter out, BasicChartSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BasicChartSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BasicChartSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BasicChartSpec
   * @throws IOException if the JSON string is invalid with respect to BasicChartSpec
   */
  public static BasicChartSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BasicChartSpec.class);
  }

  /**
   * Convert an instance of BasicChartSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

