/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Color;
import org.openapitools.client.model.ColorStyle;
import org.openapitools.client.model.DataSourceSheetProperties;
import org.openapitools.client.model.GridProperties;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties of a sheet.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SheetProperties {
  public static final String SERIALIZED_NAME_DATA_SOURCE_SHEET_PROPERTIES = "dataSourceSheetProperties";
  @SerializedName(SERIALIZED_NAME_DATA_SOURCE_SHEET_PROPERTIES)
  private DataSourceSheetProperties dataSourceSheetProperties;

  public static final String SERIALIZED_NAME_GRID_PROPERTIES = "gridProperties";
  @SerializedName(SERIALIZED_NAME_GRID_PROPERTIES)
  private GridProperties gridProperties;

  public static final String SERIALIZED_NAME_HIDDEN = "hidden";
  @SerializedName(SERIALIZED_NAME_HIDDEN)
  private Boolean hidden;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_RIGHT_TO_LEFT = "rightToLeft";
  @SerializedName(SERIALIZED_NAME_RIGHT_TO_LEFT)
  private Boolean rightToLeft;

  public static final String SERIALIZED_NAME_SHEET_ID = "sheetId";
  @SerializedName(SERIALIZED_NAME_SHEET_ID)
  private Integer sheetId;

  /**
   * The type of sheet. Defaults to GRID. This field cannot be changed once set.
   */
  @JsonAdapter(SheetTypeEnum.Adapter.class)
  public enum SheetTypeEnum {
    SHEET_TYPE_UNSPECIFIED("SHEET_TYPE_UNSPECIFIED"),
    
    GRID("GRID"),
    
    OBJECT("OBJECT"),
    
    DATA_SOURCE("DATA_SOURCE");

    private String value;

    SheetTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SheetTypeEnum fromValue(String value) {
      for (SheetTypeEnum b : SheetTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SheetTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SheetTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SheetTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SheetTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SheetTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SHEET_TYPE = "sheetType";
  @SerializedName(SERIALIZED_NAME_SHEET_TYPE)
  private SheetTypeEnum sheetType;

  public static final String SERIALIZED_NAME_TAB_COLOR = "tabColor";
  @SerializedName(SERIALIZED_NAME_TAB_COLOR)
  private Color tabColor;

  public static final String SERIALIZED_NAME_TAB_COLOR_STYLE = "tabColorStyle";
  @SerializedName(SERIALIZED_NAME_TAB_COLOR_STYLE)
  private ColorStyle tabColorStyle;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public SheetProperties() {
  }

  public SheetProperties dataSourceSheetProperties(DataSourceSheetProperties dataSourceSheetProperties) {
    this.dataSourceSheetProperties = dataSourceSheetProperties;
    return this;
  }

  /**
   * Get dataSourceSheetProperties
   * @return dataSourceSheetProperties
   */
  @javax.annotation.Nullable
  public DataSourceSheetProperties getDataSourceSheetProperties() {
    return dataSourceSheetProperties;
  }

  public void setDataSourceSheetProperties(DataSourceSheetProperties dataSourceSheetProperties) {
    this.dataSourceSheetProperties = dataSourceSheetProperties;
  }


  public SheetProperties gridProperties(GridProperties gridProperties) {
    this.gridProperties = gridProperties;
    return this;
  }

  /**
   * Get gridProperties
   * @return gridProperties
   */
  @javax.annotation.Nullable
  public GridProperties getGridProperties() {
    return gridProperties;
  }

  public void setGridProperties(GridProperties gridProperties) {
    this.gridProperties = gridProperties;
  }


  public SheetProperties hidden(Boolean hidden) {
    this.hidden = hidden;
    return this;
  }

  /**
   * True if the sheet is hidden in the UI, false if it&#39;s visible.
   * @return hidden
   */
  @javax.annotation.Nullable
  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }


  public SheetProperties index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the sheet within the spreadsheet. When adding or updating sheet properties, if this field is excluded then the sheet is added or moved to the end of the sheet list. When updating sheet indices or inserting sheets, movement is considered in \&quot;before the move\&quot; indexes. For example, if there were three sheets (S1, S2, S3) in order to move S1 ahead of S2 the index would have to be set to 2. A sheet index update request is ignored if the requested index is identical to the sheets current index or if the requested new index is equal to the current sheet index + 1.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public SheetProperties rightToLeft(Boolean rightToLeft) {
    this.rightToLeft = rightToLeft;
    return this;
  }

  /**
   * True if the sheet is an RTL sheet instead of an LTR sheet.
   * @return rightToLeft
   */
  @javax.annotation.Nullable
  public Boolean getRightToLeft() {
    return rightToLeft;
  }

  public void setRightToLeft(Boolean rightToLeft) {
    this.rightToLeft = rightToLeft;
  }


  public SheetProperties sheetId(Integer sheetId) {
    this.sheetId = sheetId;
    return this;
  }

  /**
   * The ID of the sheet. Must be non-negative. This field cannot be changed once set.
   * @return sheetId
   */
  @javax.annotation.Nullable
  public Integer getSheetId() {
    return sheetId;
  }

  public void setSheetId(Integer sheetId) {
    this.sheetId = sheetId;
  }


  public SheetProperties sheetType(SheetTypeEnum sheetType) {
    this.sheetType = sheetType;
    return this;
  }

  /**
   * The type of sheet. Defaults to GRID. This field cannot be changed once set.
   * @return sheetType
   */
  @javax.annotation.Nullable
  public SheetTypeEnum getSheetType() {
    return sheetType;
  }

  public void setSheetType(SheetTypeEnum sheetType) {
    this.sheetType = sheetType;
  }


  public SheetProperties tabColor(Color tabColor) {
    this.tabColor = tabColor;
    return this;
  }

  /**
   * Get tabColor
   * @return tabColor
   */
  @javax.annotation.Nullable
  public Color getTabColor() {
    return tabColor;
  }

  public void setTabColor(Color tabColor) {
    this.tabColor = tabColor;
  }


  public SheetProperties tabColorStyle(ColorStyle tabColorStyle) {
    this.tabColorStyle = tabColorStyle;
    return this;
  }

  /**
   * Get tabColorStyle
   * @return tabColorStyle
   */
  @javax.annotation.Nullable
  public ColorStyle getTabColorStyle() {
    return tabColorStyle;
  }

  public void setTabColorStyle(ColorStyle tabColorStyle) {
    this.tabColorStyle = tabColorStyle;
  }


  public SheetProperties title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The name of the sheet.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SheetProperties sheetProperties = (SheetProperties) o;
    return Objects.equals(this.dataSourceSheetProperties, sheetProperties.dataSourceSheetProperties) &&
        Objects.equals(this.gridProperties, sheetProperties.gridProperties) &&
        Objects.equals(this.hidden, sheetProperties.hidden) &&
        Objects.equals(this.index, sheetProperties.index) &&
        Objects.equals(this.rightToLeft, sheetProperties.rightToLeft) &&
        Objects.equals(this.sheetId, sheetProperties.sheetId) &&
        Objects.equals(this.sheetType, sheetProperties.sheetType) &&
        Objects.equals(this.tabColor, sheetProperties.tabColor) &&
        Objects.equals(this.tabColorStyle, sheetProperties.tabColorStyle) &&
        Objects.equals(this.title, sheetProperties.title);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataSourceSheetProperties, gridProperties, hidden, index, rightToLeft, sheetId, sheetType, tabColor, tabColorStyle, title);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SheetProperties {\n");
    sb.append("    dataSourceSheetProperties: ").append(toIndentedString(dataSourceSheetProperties)).append("\n");
    sb.append("    gridProperties: ").append(toIndentedString(gridProperties)).append("\n");
    sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    rightToLeft: ").append(toIndentedString(rightToLeft)).append("\n");
    sb.append("    sheetId: ").append(toIndentedString(sheetId)).append("\n");
    sb.append("    sheetType: ").append(toIndentedString(sheetType)).append("\n");
    sb.append("    tabColor: ").append(toIndentedString(tabColor)).append("\n");
    sb.append("    tabColorStyle: ").append(toIndentedString(tabColorStyle)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dataSourceSheetProperties");
    openapiFields.add("gridProperties");
    openapiFields.add("hidden");
    openapiFields.add("index");
    openapiFields.add("rightToLeft");
    openapiFields.add("sheetId");
    openapiFields.add("sheetType");
    openapiFields.add("tabColor");
    openapiFields.add("tabColorStyle");
    openapiFields.add("title");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SheetProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SheetProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SheetProperties is not found in the empty JSON string", SheetProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SheetProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SheetProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `dataSourceSheetProperties`
      if (jsonObj.get("dataSourceSheetProperties") != null && !jsonObj.get("dataSourceSheetProperties").isJsonNull()) {
        DataSourceSheetProperties.validateJsonElement(jsonObj.get("dataSourceSheetProperties"));
      }
      // validate the optional field `gridProperties`
      if (jsonObj.get("gridProperties") != null && !jsonObj.get("gridProperties").isJsonNull()) {
        GridProperties.validateJsonElement(jsonObj.get("gridProperties"));
      }
      if ((jsonObj.get("sheetType") != null && !jsonObj.get("sheetType").isJsonNull()) && !jsonObj.get("sheetType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sheetType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sheetType").toString()));
      }
      // validate the optional field `sheetType`
      if (jsonObj.get("sheetType") != null && !jsonObj.get("sheetType").isJsonNull()) {
        SheetTypeEnum.validateJsonElement(jsonObj.get("sheetType"));
      }
      // validate the optional field `tabColor`
      if (jsonObj.get("tabColor") != null && !jsonObj.get("tabColor").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("tabColor"));
      }
      // validate the optional field `tabColorStyle`
      if (jsonObj.get("tabColorStyle") != null && !jsonObj.get("tabColorStyle").isJsonNull()) {
        ColorStyle.validateJsonElement(jsonObj.get("tabColorStyle"));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SheetProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SheetProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SheetProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SheetProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<SheetProperties>() {
           @Override
           public void write(JsonWriter out, SheetProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SheetProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SheetProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SheetProperties
   * @throws IOException if the JSON string is invalid with respect to SheetProperties
   */
  public static SheetProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SheetProperties.class);
  }

  /**
   * Convert an instance of SheetProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

