/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DeveloperMetadataLocation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Developer metadata associated with a location or object in a spreadsheet. Developer metadata may be used to associate arbitrary data with various parts of a spreadsheet and will remain associated at those locations as they move around and the spreadsheet is edited. For example, if developer metadata is associated with row 5 and another row is then subsequently inserted above row 5, that original metadata will still be associated with the row it was first associated with (what is now row 6). If the associated object is deleted its metadata is deleted too.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeveloperMetadata {
  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private DeveloperMetadataLocation location;

  public static final String SERIALIZED_NAME_METADATA_ID = "metadataId";
  @SerializedName(SERIALIZED_NAME_METADATA_ID)
  private Integer metadataId;

  public static final String SERIALIZED_NAME_METADATA_KEY = "metadataKey";
  @SerializedName(SERIALIZED_NAME_METADATA_KEY)
  private String metadataKey;

  public static final String SERIALIZED_NAME_METADATA_VALUE = "metadataValue";
  @SerializedName(SERIALIZED_NAME_METADATA_VALUE)
  private String metadataValue;

  /**
   * The metadata visibility. Developer metadata must always have a visibility specified.
   */
  @JsonAdapter(VisibilityEnum.Adapter.class)
  public enum VisibilityEnum {
    DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED("DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED"),
    
    DOCUMENT("DOCUMENT"),
    
    PROJECT("PROJECT");

    private String value;

    VisibilityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VisibilityEnum fromValue(String value) {
      for (VisibilityEnum b : VisibilityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VisibilityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VisibilityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VisibilityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VisibilityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VisibilityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VISIBILITY = "visibility";
  @SerializedName(SERIALIZED_NAME_VISIBILITY)
  private VisibilityEnum visibility;

  public DeveloperMetadata() {
  }

  public DeveloperMetadata location(DeveloperMetadataLocation location) {
    this.location = location;
    return this;
  }

  /**
   * Get location
   * @return location
   */
  @javax.annotation.Nullable
  public DeveloperMetadataLocation getLocation() {
    return location;
  }

  public void setLocation(DeveloperMetadataLocation location) {
    this.location = location;
  }


  public DeveloperMetadata metadataId(Integer metadataId) {
    this.metadataId = metadataId;
    return this;
  }

  /**
   * The spreadsheet-scoped unique ID that identifies the metadata. IDs may be specified when metadata is created, otherwise one will be randomly generated and assigned. Must be positive.
   * @return metadataId
   */
  @javax.annotation.Nullable
  public Integer getMetadataId() {
    return metadataId;
  }

  public void setMetadataId(Integer metadataId) {
    this.metadataId = metadataId;
  }


  public DeveloperMetadata metadataKey(String metadataKey) {
    this.metadataKey = metadataKey;
    return this;
  }

  /**
   * The metadata key. There may be multiple metadata in a spreadsheet with the same key. Developer metadata must always have a key specified.
   * @return metadataKey
   */
  @javax.annotation.Nullable
  public String getMetadataKey() {
    return metadataKey;
  }

  public void setMetadataKey(String metadataKey) {
    this.metadataKey = metadataKey;
  }


  public DeveloperMetadata metadataValue(String metadataValue) {
    this.metadataValue = metadataValue;
    return this;
  }

  /**
   * Data associated with the metadata&#39;s key.
   * @return metadataValue
   */
  @javax.annotation.Nullable
  public String getMetadataValue() {
    return metadataValue;
  }

  public void setMetadataValue(String metadataValue) {
    this.metadataValue = metadataValue;
  }


  public DeveloperMetadata visibility(VisibilityEnum visibility) {
    this.visibility = visibility;
    return this;
  }

  /**
   * The metadata visibility. Developer metadata must always have a visibility specified.
   * @return visibility
   */
  @javax.annotation.Nullable
  public VisibilityEnum getVisibility() {
    return visibility;
  }

  public void setVisibility(VisibilityEnum visibility) {
    this.visibility = visibility;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeveloperMetadata developerMetadata = (DeveloperMetadata) o;
    return Objects.equals(this.location, developerMetadata.location) &&
        Objects.equals(this.metadataId, developerMetadata.metadataId) &&
        Objects.equals(this.metadataKey, developerMetadata.metadataKey) &&
        Objects.equals(this.metadataValue, developerMetadata.metadataValue) &&
        Objects.equals(this.visibility, developerMetadata.visibility);
  }

  @Override
  public int hashCode() {
    return Objects.hash(location, metadataId, metadataKey, metadataValue, visibility);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeveloperMetadata {\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    metadataId: ").append(toIndentedString(metadataId)).append("\n");
    sb.append("    metadataKey: ").append(toIndentedString(metadataKey)).append("\n");
    sb.append("    metadataValue: ").append(toIndentedString(metadataValue)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("location");
    openapiFields.add("metadataId");
    openapiFields.add("metadataKey");
    openapiFields.add("metadataValue");
    openapiFields.add("visibility");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeveloperMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeveloperMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeveloperMetadata is not found in the empty JSON string", DeveloperMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeveloperMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeveloperMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `location`
      if (jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) {
        DeveloperMetadataLocation.validateJsonElement(jsonObj.get("location"));
      }
      if ((jsonObj.get("metadataKey") != null && !jsonObj.get("metadataKey").isJsonNull()) && !jsonObj.get("metadataKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadataKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadataKey").toString()));
      }
      if ((jsonObj.get("metadataValue") != null && !jsonObj.get("metadataValue").isJsonNull()) && !jsonObj.get("metadataValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadataValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadataValue").toString()));
      }
      if ((jsonObj.get("visibility") != null && !jsonObj.get("visibility").isJsonNull()) && !jsonObj.get("visibility").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `visibility` to be a primitive type in the JSON string but got `%s`", jsonObj.get("visibility").toString()));
      }
      // validate the optional field `visibility`
      if (jsonObj.get("visibility") != null && !jsonObj.get("visibility").isJsonNull()) {
        VisibilityEnum.validateJsonElement(jsonObj.get("visibility"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeveloperMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeveloperMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeveloperMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeveloperMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<DeveloperMetadata>() {
           @Override
           public void write(JsonWriter out, DeveloperMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeveloperMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeveloperMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeveloperMetadata
   * @throws IOException if the JSON string is invalid with respect to DeveloperMetadata
   */
  public static DeveloperMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeveloperMetadata.class);
  }

  /**
   * Convert an instance of DeveloperMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

