/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CellFormat;
import org.openapitools.client.model.DataSourceFormula;
import org.openapitools.client.model.DataSourceTable;
import org.openapitools.client.model.DataValidationRule;
import org.openapitools.client.model.ExtendedValue;
import org.openapitools.client.model.PivotTable;
import org.openapitools.client.model.TextFormatRun;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Data about a specific cell.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CellData {
  public static final String SERIALIZED_NAME_DATA_SOURCE_FORMULA = "dataSourceFormula";
  @SerializedName(SERIALIZED_NAME_DATA_SOURCE_FORMULA)
  private DataSourceFormula dataSourceFormula;

  public static final String SERIALIZED_NAME_DATA_SOURCE_TABLE = "dataSourceTable";
  @SerializedName(SERIALIZED_NAME_DATA_SOURCE_TABLE)
  private DataSourceTable dataSourceTable;

  public static final String SERIALIZED_NAME_DATA_VALIDATION = "dataValidation";
  @SerializedName(SERIALIZED_NAME_DATA_VALIDATION)
  private DataValidationRule dataValidation;

  public static final String SERIALIZED_NAME_EFFECTIVE_FORMAT = "effectiveFormat";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_FORMAT)
  private CellFormat effectiveFormat;

  public static final String SERIALIZED_NAME_EFFECTIVE_VALUE = "effectiveValue";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_VALUE)
  private ExtendedValue effectiveValue;

  public static final String SERIALIZED_NAME_FORMATTED_VALUE = "formattedValue";
  @SerializedName(SERIALIZED_NAME_FORMATTED_VALUE)
  private String formattedValue;

  public static final String SERIALIZED_NAME_HYPERLINK = "hyperlink";
  @SerializedName(SERIALIZED_NAME_HYPERLINK)
  private String hyperlink;

  public static final String SERIALIZED_NAME_NOTE = "note";
  @SerializedName(SERIALIZED_NAME_NOTE)
  private String note;

  public static final String SERIALIZED_NAME_PIVOT_TABLE = "pivotTable";
  @SerializedName(SERIALIZED_NAME_PIVOT_TABLE)
  private PivotTable pivotTable;

  public static final String SERIALIZED_NAME_TEXT_FORMAT_RUNS = "textFormatRuns";
  @SerializedName(SERIALIZED_NAME_TEXT_FORMAT_RUNS)
  private List<TextFormatRun> textFormatRuns = new ArrayList<>();

  public static final String SERIALIZED_NAME_USER_ENTERED_FORMAT = "userEnteredFormat";
  @SerializedName(SERIALIZED_NAME_USER_ENTERED_FORMAT)
  private CellFormat userEnteredFormat;

  public static final String SERIALIZED_NAME_USER_ENTERED_VALUE = "userEnteredValue";
  @SerializedName(SERIALIZED_NAME_USER_ENTERED_VALUE)
  private ExtendedValue userEnteredValue;

  public CellData() {
  }

  public CellData dataSourceFormula(DataSourceFormula dataSourceFormula) {
    this.dataSourceFormula = dataSourceFormula;
    return this;
  }

  /**
   * Get dataSourceFormula
   * @return dataSourceFormula
   */
  @javax.annotation.Nullable
  public DataSourceFormula getDataSourceFormula() {
    return dataSourceFormula;
  }

  public void setDataSourceFormula(DataSourceFormula dataSourceFormula) {
    this.dataSourceFormula = dataSourceFormula;
  }


  public CellData dataSourceTable(DataSourceTable dataSourceTable) {
    this.dataSourceTable = dataSourceTable;
    return this;
  }

  /**
   * Get dataSourceTable
   * @return dataSourceTable
   */
  @javax.annotation.Nullable
  public DataSourceTable getDataSourceTable() {
    return dataSourceTable;
  }

  public void setDataSourceTable(DataSourceTable dataSourceTable) {
    this.dataSourceTable = dataSourceTable;
  }


  public CellData dataValidation(DataValidationRule dataValidation) {
    this.dataValidation = dataValidation;
    return this;
  }

  /**
   * Get dataValidation
   * @return dataValidation
   */
  @javax.annotation.Nullable
  public DataValidationRule getDataValidation() {
    return dataValidation;
  }

  public void setDataValidation(DataValidationRule dataValidation) {
    this.dataValidation = dataValidation;
  }


  public CellData effectiveFormat(CellFormat effectiveFormat) {
    this.effectiveFormat = effectiveFormat;
    return this;
  }

  /**
   * Get effectiveFormat
   * @return effectiveFormat
   */
  @javax.annotation.Nullable
  public CellFormat getEffectiveFormat() {
    return effectiveFormat;
  }

  public void setEffectiveFormat(CellFormat effectiveFormat) {
    this.effectiveFormat = effectiveFormat;
  }


  public CellData effectiveValue(ExtendedValue effectiveValue) {
    this.effectiveValue = effectiveValue;
    return this;
  }

  /**
   * Get effectiveValue
   * @return effectiveValue
   */
  @javax.annotation.Nullable
  public ExtendedValue getEffectiveValue() {
    return effectiveValue;
  }

  public void setEffectiveValue(ExtendedValue effectiveValue) {
    this.effectiveValue = effectiveValue;
  }


  public CellData formattedValue(String formattedValue) {
    this.formattedValue = formattedValue;
    return this;
  }

  /**
   * The formatted value of the cell. This is the value as it&#39;s shown to the user. This field is read-only.
   * @return formattedValue
   */
  @javax.annotation.Nullable
  public String getFormattedValue() {
    return formattedValue;
  }

  public void setFormattedValue(String formattedValue) {
    this.formattedValue = formattedValue;
  }


  public CellData hyperlink(String hyperlink) {
    this.hyperlink = hyperlink;
    return this;
  }

  /**
   * A hyperlink this cell points to, if any. If the cell contains multiple hyperlinks, this field will be empty. This field is read-only. To set it, use a &#x60;&#x3D;HYPERLINK&#x60; formula in the userEnteredValue.formulaValue field. A cell-level link can also be set from the userEnteredFormat.textFormat field. Alternatively, set a hyperlink in the textFormatRun.format.link field that spans the entire cell.
   * @return hyperlink
   */
  @javax.annotation.Nullable
  public String getHyperlink() {
    return hyperlink;
  }

  public void setHyperlink(String hyperlink) {
    this.hyperlink = hyperlink;
  }


  public CellData note(String note) {
    this.note = note;
    return this;
  }

  /**
   * Any note on the cell.
   * @return note
   */
  @javax.annotation.Nullable
  public String getNote() {
    return note;
  }

  public void setNote(String note) {
    this.note = note;
  }


  public CellData pivotTable(PivotTable pivotTable) {
    this.pivotTable = pivotTable;
    return this;
  }

  /**
   * Get pivotTable
   * @return pivotTable
   */
  @javax.annotation.Nullable
  public PivotTable getPivotTable() {
    return pivotTable;
  }

  public void setPivotTable(PivotTable pivotTable) {
    this.pivotTable = pivotTable;
  }


  public CellData textFormatRuns(List<TextFormatRun> textFormatRuns) {
    this.textFormatRuns = textFormatRuns;
    return this;
  }

  public CellData addTextFormatRunsItem(TextFormatRun textFormatRunsItem) {
    if (this.textFormatRuns == null) {
      this.textFormatRuns = new ArrayList<>();
    }
    this.textFormatRuns.add(textFormatRunsItem);
    return this;
  }

  /**
   * Runs of rich text applied to subsections of the cell. Runs are only valid on user entered strings, not formulas, bools, or numbers. Properties of a run start at a specific index in the text and continue until the next run. Runs will inherit the properties of the cell unless explicitly changed. When writing, the new runs will overwrite any prior runs. When writing a new user_entered_value, previous runs are erased.
   * @return textFormatRuns
   */
  @javax.annotation.Nullable
  public List<TextFormatRun> getTextFormatRuns() {
    return textFormatRuns;
  }

  public void setTextFormatRuns(List<TextFormatRun> textFormatRuns) {
    this.textFormatRuns = textFormatRuns;
  }


  public CellData userEnteredFormat(CellFormat userEnteredFormat) {
    this.userEnteredFormat = userEnteredFormat;
    return this;
  }

  /**
   * Get userEnteredFormat
   * @return userEnteredFormat
   */
  @javax.annotation.Nullable
  public CellFormat getUserEnteredFormat() {
    return userEnteredFormat;
  }

  public void setUserEnteredFormat(CellFormat userEnteredFormat) {
    this.userEnteredFormat = userEnteredFormat;
  }


  public CellData userEnteredValue(ExtendedValue userEnteredValue) {
    this.userEnteredValue = userEnteredValue;
    return this;
  }

  /**
   * Get userEnteredValue
   * @return userEnteredValue
   */
  @javax.annotation.Nullable
  public ExtendedValue getUserEnteredValue() {
    return userEnteredValue;
  }

  public void setUserEnteredValue(ExtendedValue userEnteredValue) {
    this.userEnteredValue = userEnteredValue;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CellData cellData = (CellData) o;
    return Objects.equals(this.dataSourceFormula, cellData.dataSourceFormula) &&
        Objects.equals(this.dataSourceTable, cellData.dataSourceTable) &&
        Objects.equals(this.dataValidation, cellData.dataValidation) &&
        Objects.equals(this.effectiveFormat, cellData.effectiveFormat) &&
        Objects.equals(this.effectiveValue, cellData.effectiveValue) &&
        Objects.equals(this.formattedValue, cellData.formattedValue) &&
        Objects.equals(this.hyperlink, cellData.hyperlink) &&
        Objects.equals(this.note, cellData.note) &&
        Objects.equals(this.pivotTable, cellData.pivotTable) &&
        Objects.equals(this.textFormatRuns, cellData.textFormatRuns) &&
        Objects.equals(this.userEnteredFormat, cellData.userEnteredFormat) &&
        Objects.equals(this.userEnteredValue, cellData.userEnteredValue);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataSourceFormula, dataSourceTable, dataValidation, effectiveFormat, effectiveValue, formattedValue, hyperlink, note, pivotTable, textFormatRuns, userEnteredFormat, userEnteredValue);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CellData {\n");
    sb.append("    dataSourceFormula: ").append(toIndentedString(dataSourceFormula)).append("\n");
    sb.append("    dataSourceTable: ").append(toIndentedString(dataSourceTable)).append("\n");
    sb.append("    dataValidation: ").append(toIndentedString(dataValidation)).append("\n");
    sb.append("    effectiveFormat: ").append(toIndentedString(effectiveFormat)).append("\n");
    sb.append("    effectiveValue: ").append(toIndentedString(effectiveValue)).append("\n");
    sb.append("    formattedValue: ").append(toIndentedString(formattedValue)).append("\n");
    sb.append("    hyperlink: ").append(toIndentedString(hyperlink)).append("\n");
    sb.append("    note: ").append(toIndentedString(note)).append("\n");
    sb.append("    pivotTable: ").append(toIndentedString(pivotTable)).append("\n");
    sb.append("    textFormatRuns: ").append(toIndentedString(textFormatRuns)).append("\n");
    sb.append("    userEnteredFormat: ").append(toIndentedString(userEnteredFormat)).append("\n");
    sb.append("    userEnteredValue: ").append(toIndentedString(userEnteredValue)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dataSourceFormula");
    openapiFields.add("dataSourceTable");
    openapiFields.add("dataValidation");
    openapiFields.add("effectiveFormat");
    openapiFields.add("effectiveValue");
    openapiFields.add("formattedValue");
    openapiFields.add("hyperlink");
    openapiFields.add("note");
    openapiFields.add("pivotTable");
    openapiFields.add("textFormatRuns");
    openapiFields.add("userEnteredFormat");
    openapiFields.add("userEnteredValue");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CellData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CellData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CellData is not found in the empty JSON string", CellData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CellData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CellData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `dataSourceFormula`
      if (jsonObj.get("dataSourceFormula") != null && !jsonObj.get("dataSourceFormula").isJsonNull()) {
        DataSourceFormula.validateJsonElement(jsonObj.get("dataSourceFormula"));
      }
      // validate the optional field `dataSourceTable`
      if (jsonObj.get("dataSourceTable") != null && !jsonObj.get("dataSourceTable").isJsonNull()) {
        DataSourceTable.validateJsonElement(jsonObj.get("dataSourceTable"));
      }
      // validate the optional field `dataValidation`
      if (jsonObj.get("dataValidation") != null && !jsonObj.get("dataValidation").isJsonNull()) {
        DataValidationRule.validateJsonElement(jsonObj.get("dataValidation"));
      }
      // validate the optional field `effectiveFormat`
      if (jsonObj.get("effectiveFormat") != null && !jsonObj.get("effectiveFormat").isJsonNull()) {
        CellFormat.validateJsonElement(jsonObj.get("effectiveFormat"));
      }
      // validate the optional field `effectiveValue`
      if (jsonObj.get("effectiveValue") != null && !jsonObj.get("effectiveValue").isJsonNull()) {
        ExtendedValue.validateJsonElement(jsonObj.get("effectiveValue"));
      }
      if ((jsonObj.get("formattedValue") != null && !jsonObj.get("formattedValue").isJsonNull()) && !jsonObj.get("formattedValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `formattedValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("formattedValue").toString()));
      }
      if ((jsonObj.get("hyperlink") != null && !jsonObj.get("hyperlink").isJsonNull()) && !jsonObj.get("hyperlink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hyperlink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hyperlink").toString()));
      }
      if ((jsonObj.get("note") != null && !jsonObj.get("note").isJsonNull()) && !jsonObj.get("note").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `note` to be a primitive type in the JSON string but got `%s`", jsonObj.get("note").toString()));
      }
      // validate the optional field `pivotTable`
      if (jsonObj.get("pivotTable") != null && !jsonObj.get("pivotTable").isJsonNull()) {
        PivotTable.validateJsonElement(jsonObj.get("pivotTable"));
      }
      if (jsonObj.get("textFormatRuns") != null && !jsonObj.get("textFormatRuns").isJsonNull()) {
        JsonArray jsonArraytextFormatRuns = jsonObj.getAsJsonArray("textFormatRuns");
        if (jsonArraytextFormatRuns != null) {
          // ensure the json data is an array
          if (!jsonObj.get("textFormatRuns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `textFormatRuns` to be an array in the JSON string but got `%s`", jsonObj.get("textFormatRuns").toString()));
          }

          // validate the optional field `textFormatRuns` (array)
          for (int i = 0; i < jsonArraytextFormatRuns.size(); i++) {
            TextFormatRun.validateJsonElement(jsonArraytextFormatRuns.get(i));
          };
        }
      }
      // validate the optional field `userEnteredFormat`
      if (jsonObj.get("userEnteredFormat") != null && !jsonObj.get("userEnteredFormat").isJsonNull()) {
        CellFormat.validateJsonElement(jsonObj.get("userEnteredFormat"));
      }
      // validate the optional field `userEnteredValue`
      if (jsonObj.get("userEnteredValue") != null && !jsonObj.get("userEnteredValue").isJsonNull()) {
        ExtendedValue.validateJsonElement(jsonObj.get("userEnteredValue"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CellData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CellData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CellData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CellData.class));

       return (TypeAdapter<T>) new TypeAdapter<CellData>() {
           @Override
           public void write(JsonWriter out, CellData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CellData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CellData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CellData
   * @throws IOException if the JSON string is invalid with respect to CellData
   */
  public static CellData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CellData.class);
  }

  /**
   * Convert an instance of CellData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

