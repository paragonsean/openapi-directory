/*
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ChartData;
import org.openapitools.client.model.Color;
import org.openapitools.client.model.ColorStyle;
import org.openapitools.client.model.TextFormat;
import org.openapitools.client.model.TreemapChartColorScale;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Treemap chart.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:49.244050-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TreemapChartSpec {
  public static final String SERIALIZED_NAME_COLOR_DATA = "colorData";
  @SerializedName(SERIALIZED_NAME_COLOR_DATA)
  private ChartData colorData;

  public static final String SERIALIZED_NAME_COLOR_SCALE = "colorScale";
  @SerializedName(SERIALIZED_NAME_COLOR_SCALE)
  private TreemapChartColorScale colorScale;

  public static final String SERIALIZED_NAME_HEADER_COLOR = "headerColor";
  @SerializedName(SERIALIZED_NAME_HEADER_COLOR)
  private Color headerColor;

  public static final String SERIALIZED_NAME_HEADER_COLOR_STYLE = "headerColorStyle";
  @SerializedName(SERIALIZED_NAME_HEADER_COLOR_STYLE)
  private ColorStyle headerColorStyle;

  public static final String SERIALIZED_NAME_HIDE_TOOLTIPS = "hideTooltips";
  @SerializedName(SERIALIZED_NAME_HIDE_TOOLTIPS)
  private Boolean hideTooltips;

  public static final String SERIALIZED_NAME_HINTED_LEVELS = "hintedLevels";
  @SerializedName(SERIALIZED_NAME_HINTED_LEVELS)
  private Integer hintedLevels;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private ChartData labels;

  public static final String SERIALIZED_NAME_LEVELS = "levels";
  @SerializedName(SERIALIZED_NAME_LEVELS)
  private Integer levels;

  public static final String SERIALIZED_NAME_MAX_VALUE = "maxValue";
  @SerializedName(SERIALIZED_NAME_MAX_VALUE)
  private Double maxValue;

  public static final String SERIALIZED_NAME_MIN_VALUE = "minValue";
  @SerializedName(SERIALIZED_NAME_MIN_VALUE)
  private Double minValue;

  public static final String SERIALIZED_NAME_PARENT_LABELS = "parentLabels";
  @SerializedName(SERIALIZED_NAME_PARENT_LABELS)
  private ChartData parentLabels;

  public static final String SERIALIZED_NAME_SIZE_DATA = "sizeData";
  @SerializedName(SERIALIZED_NAME_SIZE_DATA)
  private ChartData sizeData;

  public static final String SERIALIZED_NAME_TEXT_FORMAT = "textFormat";
  @SerializedName(SERIALIZED_NAME_TEXT_FORMAT)
  private TextFormat textFormat;

  public TreemapChartSpec() {
  }

  public TreemapChartSpec colorData(ChartData colorData) {
    this.colorData = colorData;
    return this;
  }

  /**
   * Get colorData
   * @return colorData
   */
  @javax.annotation.Nullable
  public ChartData getColorData() {
    return colorData;
  }

  public void setColorData(ChartData colorData) {
    this.colorData = colorData;
  }


  public TreemapChartSpec colorScale(TreemapChartColorScale colorScale) {
    this.colorScale = colorScale;
    return this;
  }

  /**
   * Get colorScale
   * @return colorScale
   */
  @javax.annotation.Nullable
  public TreemapChartColorScale getColorScale() {
    return colorScale;
  }

  public void setColorScale(TreemapChartColorScale colorScale) {
    this.colorScale = colorScale;
  }


  public TreemapChartSpec headerColor(Color headerColor) {
    this.headerColor = headerColor;
    return this;
  }

  /**
   * Get headerColor
   * @return headerColor
   */
  @javax.annotation.Nullable
  public Color getHeaderColor() {
    return headerColor;
  }

  public void setHeaderColor(Color headerColor) {
    this.headerColor = headerColor;
  }


  public TreemapChartSpec headerColorStyle(ColorStyle headerColorStyle) {
    this.headerColorStyle = headerColorStyle;
    return this;
  }

  /**
   * Get headerColorStyle
   * @return headerColorStyle
   */
  @javax.annotation.Nullable
  public ColorStyle getHeaderColorStyle() {
    return headerColorStyle;
  }

  public void setHeaderColorStyle(ColorStyle headerColorStyle) {
    this.headerColorStyle = headerColorStyle;
  }


  public TreemapChartSpec hideTooltips(Boolean hideTooltips) {
    this.hideTooltips = hideTooltips;
    return this;
  }

  /**
   * True to hide tooltips.
   * @return hideTooltips
   */
  @javax.annotation.Nullable
  public Boolean getHideTooltips() {
    return hideTooltips;
  }

  public void setHideTooltips(Boolean hideTooltips) {
    this.hideTooltips = hideTooltips;
  }


  public TreemapChartSpec hintedLevels(Integer hintedLevels) {
    this.hintedLevels = hintedLevels;
    return this;
  }

  /**
   * The number of additional data levels beyond the labeled levels to be shown on the treemap chart. These levels are not interactive and are shown without their labels. Defaults to 0 if not specified.
   * @return hintedLevels
   */
  @javax.annotation.Nullable
  public Integer getHintedLevels() {
    return hintedLevels;
  }

  public void setHintedLevels(Integer hintedLevels) {
    this.hintedLevels = hintedLevels;
  }


  public TreemapChartSpec labels(ChartData labels) {
    this.labels = labels;
    return this;
  }

  /**
   * Get labels
   * @return labels
   */
  @javax.annotation.Nullable
  public ChartData getLabels() {
    return labels;
  }

  public void setLabels(ChartData labels) {
    this.labels = labels;
  }


  public TreemapChartSpec levels(Integer levels) {
    this.levels = levels;
    return this;
  }

  /**
   * The number of data levels to show on the treemap chart. These levels are interactive and are shown with their labels. Defaults to 2 if not specified.
   * @return levels
   */
  @javax.annotation.Nullable
  public Integer getLevels() {
    return levels;
  }

  public void setLevels(Integer levels) {
    this.levels = levels;
  }


  public TreemapChartSpec maxValue(Double maxValue) {
    this.maxValue = maxValue;
    return this;
  }

  /**
   * The maximum possible data value. Cells with values greater than this will have the same color as cells with this value. If not specified, defaults to the actual maximum value from color_data, or the maximum value from size_data if color_data is not specified.
   * @return maxValue
   */
  @javax.annotation.Nullable
  public Double getMaxValue() {
    return maxValue;
  }

  public void setMaxValue(Double maxValue) {
    this.maxValue = maxValue;
  }


  public TreemapChartSpec minValue(Double minValue) {
    this.minValue = minValue;
    return this;
  }

  /**
   * The minimum possible data value. Cells with values less than this will have the same color as cells with this value. If not specified, defaults to the actual minimum value from color_data, or the minimum value from size_data if color_data is not specified.
   * @return minValue
   */
  @javax.annotation.Nullable
  public Double getMinValue() {
    return minValue;
  }

  public void setMinValue(Double minValue) {
    this.minValue = minValue;
  }


  public TreemapChartSpec parentLabels(ChartData parentLabels) {
    this.parentLabels = parentLabels;
    return this;
  }

  /**
   * Get parentLabels
   * @return parentLabels
   */
  @javax.annotation.Nullable
  public ChartData getParentLabels() {
    return parentLabels;
  }

  public void setParentLabels(ChartData parentLabels) {
    this.parentLabels = parentLabels;
  }


  public TreemapChartSpec sizeData(ChartData sizeData) {
    this.sizeData = sizeData;
    return this;
  }

  /**
   * Get sizeData
   * @return sizeData
   */
  @javax.annotation.Nullable
  public ChartData getSizeData() {
    return sizeData;
  }

  public void setSizeData(ChartData sizeData) {
    this.sizeData = sizeData;
  }


  public TreemapChartSpec textFormat(TextFormat textFormat) {
    this.textFormat = textFormat;
    return this;
  }

  /**
   * Get textFormat
   * @return textFormat
   */
  @javax.annotation.Nullable
  public TextFormat getTextFormat() {
    return textFormat;
  }

  public void setTextFormat(TextFormat textFormat) {
    this.textFormat = textFormat;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TreemapChartSpec treemapChartSpec = (TreemapChartSpec) o;
    return Objects.equals(this.colorData, treemapChartSpec.colorData) &&
        Objects.equals(this.colorScale, treemapChartSpec.colorScale) &&
        Objects.equals(this.headerColor, treemapChartSpec.headerColor) &&
        Objects.equals(this.headerColorStyle, treemapChartSpec.headerColorStyle) &&
        Objects.equals(this.hideTooltips, treemapChartSpec.hideTooltips) &&
        Objects.equals(this.hintedLevels, treemapChartSpec.hintedLevels) &&
        Objects.equals(this.labels, treemapChartSpec.labels) &&
        Objects.equals(this.levels, treemapChartSpec.levels) &&
        Objects.equals(this.maxValue, treemapChartSpec.maxValue) &&
        Objects.equals(this.minValue, treemapChartSpec.minValue) &&
        Objects.equals(this.parentLabels, treemapChartSpec.parentLabels) &&
        Objects.equals(this.sizeData, treemapChartSpec.sizeData) &&
        Objects.equals(this.textFormat, treemapChartSpec.textFormat);
  }

  @Override
  public int hashCode() {
    return Objects.hash(colorData, colorScale, headerColor, headerColorStyle, hideTooltips, hintedLevels, labels, levels, maxValue, minValue, parentLabels, sizeData, textFormat);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TreemapChartSpec {\n");
    sb.append("    colorData: ").append(toIndentedString(colorData)).append("\n");
    sb.append("    colorScale: ").append(toIndentedString(colorScale)).append("\n");
    sb.append("    headerColor: ").append(toIndentedString(headerColor)).append("\n");
    sb.append("    headerColorStyle: ").append(toIndentedString(headerColorStyle)).append("\n");
    sb.append("    hideTooltips: ").append(toIndentedString(hideTooltips)).append("\n");
    sb.append("    hintedLevels: ").append(toIndentedString(hintedLevels)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    levels: ").append(toIndentedString(levels)).append("\n");
    sb.append("    maxValue: ").append(toIndentedString(maxValue)).append("\n");
    sb.append("    minValue: ").append(toIndentedString(minValue)).append("\n");
    sb.append("    parentLabels: ").append(toIndentedString(parentLabels)).append("\n");
    sb.append("    sizeData: ").append(toIndentedString(sizeData)).append("\n");
    sb.append("    textFormat: ").append(toIndentedString(textFormat)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("colorData");
    openapiFields.add("colorScale");
    openapiFields.add("headerColor");
    openapiFields.add("headerColorStyle");
    openapiFields.add("hideTooltips");
    openapiFields.add("hintedLevels");
    openapiFields.add("labels");
    openapiFields.add("levels");
    openapiFields.add("maxValue");
    openapiFields.add("minValue");
    openapiFields.add("parentLabels");
    openapiFields.add("sizeData");
    openapiFields.add("textFormat");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TreemapChartSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TreemapChartSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TreemapChartSpec is not found in the empty JSON string", TreemapChartSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TreemapChartSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TreemapChartSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `colorData`
      if (jsonObj.get("colorData") != null && !jsonObj.get("colorData").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("colorData"));
      }
      // validate the optional field `colorScale`
      if (jsonObj.get("colorScale") != null && !jsonObj.get("colorScale").isJsonNull()) {
        TreemapChartColorScale.validateJsonElement(jsonObj.get("colorScale"));
      }
      // validate the optional field `headerColor`
      if (jsonObj.get("headerColor") != null && !jsonObj.get("headerColor").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("headerColor"));
      }
      // validate the optional field `headerColorStyle`
      if (jsonObj.get("headerColorStyle") != null && !jsonObj.get("headerColorStyle").isJsonNull()) {
        ColorStyle.validateJsonElement(jsonObj.get("headerColorStyle"));
      }
      // validate the optional field `labels`
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("labels"));
      }
      // validate the optional field `parentLabels`
      if (jsonObj.get("parentLabels") != null && !jsonObj.get("parentLabels").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("parentLabels"));
      }
      // validate the optional field `sizeData`
      if (jsonObj.get("sizeData") != null && !jsonObj.get("sizeData").isJsonNull()) {
        ChartData.validateJsonElement(jsonObj.get("sizeData"));
      }
      // validate the optional field `textFormat`
      if (jsonObj.get("textFormat") != null && !jsonObj.get("textFormat").isJsonNull()) {
        TextFormat.validateJsonElement(jsonObj.get("textFormat"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TreemapChartSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TreemapChartSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TreemapChartSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TreemapChartSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<TreemapChartSpec>() {
           @Override
           public void write(JsonWriter out, TreemapChartSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TreemapChartSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TreemapChartSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TreemapChartSpec
   * @throws IOException if the JSON string is invalid with respect to TreemapChartSpec
   */
  public static TreemapChartSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TreemapChartSpec.class);
  }

  /**
   * Convert an instance of TreemapChartSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

