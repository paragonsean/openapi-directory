/**
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import BandedRange from './BandedRange';
import BasicFilter from './BasicFilter';
import ConditionalFormatRule from './ConditionalFormatRule';
import DeveloperMetadata from './DeveloperMetadata';
import DimensionGroup from './DimensionGroup';
import EmbeddedChart from './EmbeddedChart';
import FilterView from './FilterView';
import GridData from './GridData';
import GridRange from './GridRange';
import ProtectedRange from './ProtectedRange';
import SheetProperties from './SheetProperties';
import Slicer from './Slicer';

/**
 * The Sheet model module.
 * @module model/Sheet
 * @version v4
 */
class Sheet {
    /**
     * Constructs a new <code>Sheet</code>.
     * A sheet in a spreadsheet.
     * @alias module:model/Sheet
     */
    constructor() { 
        
        Sheet.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Sheet</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Sheet} obj Optional instance to populate.
     * @return {module:model/Sheet} The populated <code>Sheet</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Sheet();

            if (data.hasOwnProperty('bandedRanges')) {
                obj['bandedRanges'] = ApiClient.convertToType(data['bandedRanges'], [BandedRange]);
            }
            if (data.hasOwnProperty('basicFilter')) {
                obj['basicFilter'] = BasicFilter.constructFromObject(data['basicFilter']);
            }
            if (data.hasOwnProperty('charts')) {
                obj['charts'] = ApiClient.convertToType(data['charts'], [EmbeddedChart]);
            }
            if (data.hasOwnProperty('columnGroups')) {
                obj['columnGroups'] = ApiClient.convertToType(data['columnGroups'], [DimensionGroup]);
            }
            if (data.hasOwnProperty('conditionalFormats')) {
                obj['conditionalFormats'] = ApiClient.convertToType(data['conditionalFormats'], [ConditionalFormatRule]);
            }
            if (data.hasOwnProperty('data')) {
                obj['data'] = ApiClient.convertToType(data['data'], [GridData]);
            }
            if (data.hasOwnProperty('developerMetadata')) {
                obj['developerMetadata'] = ApiClient.convertToType(data['developerMetadata'], [DeveloperMetadata]);
            }
            if (data.hasOwnProperty('filterViews')) {
                obj['filterViews'] = ApiClient.convertToType(data['filterViews'], [FilterView]);
            }
            if (data.hasOwnProperty('merges')) {
                obj['merges'] = ApiClient.convertToType(data['merges'], [GridRange]);
            }
            if (data.hasOwnProperty('properties')) {
                obj['properties'] = SheetProperties.constructFromObject(data['properties']);
            }
            if (data.hasOwnProperty('protectedRanges')) {
                obj['protectedRanges'] = ApiClient.convertToType(data['protectedRanges'], [ProtectedRange]);
            }
            if (data.hasOwnProperty('rowGroups')) {
                obj['rowGroups'] = ApiClient.convertToType(data['rowGroups'], [DimensionGroup]);
            }
            if (data.hasOwnProperty('slicers')) {
                obj['slicers'] = ApiClient.convertToType(data['slicers'], [Slicer]);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Sheet</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Sheet</code>.
     */
    static validateJSON(data) {
        if (data['bandedRanges']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['bandedRanges'])) {
                throw new Error("Expected the field `bandedRanges` to be an array in the JSON data but got " + data['bandedRanges']);
            }
            // validate the optional field `bandedRanges` (array)
            for (const item of data['bandedRanges']) {
                BandedRange.validateJSON(item);
            };
        }
        // validate the optional field `basicFilter`
        if (data['basicFilter']) { // data not null
          BasicFilter.validateJSON(data['basicFilter']);
        }
        if (data['charts']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['charts'])) {
                throw new Error("Expected the field `charts` to be an array in the JSON data but got " + data['charts']);
            }
            // validate the optional field `charts` (array)
            for (const item of data['charts']) {
                EmbeddedChart.validateJSON(item);
            };
        }
        if (data['columnGroups']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['columnGroups'])) {
                throw new Error("Expected the field `columnGroups` to be an array in the JSON data but got " + data['columnGroups']);
            }
            // validate the optional field `columnGroups` (array)
            for (const item of data['columnGroups']) {
                DimensionGroup.validateJSON(item);
            };
        }
        if (data['conditionalFormats']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['conditionalFormats'])) {
                throw new Error("Expected the field `conditionalFormats` to be an array in the JSON data but got " + data['conditionalFormats']);
            }
            // validate the optional field `conditionalFormats` (array)
            for (const item of data['conditionalFormats']) {
                ConditionalFormatRule.validateJSON(item);
            };
        }
        if (data['data']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['data'])) {
                throw new Error("Expected the field `data` to be an array in the JSON data but got " + data['data']);
            }
            // validate the optional field `data` (array)
            for (const item of data['data']) {
                GridData.validateJSON(item);
            };
        }
        if (data['developerMetadata']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['developerMetadata'])) {
                throw new Error("Expected the field `developerMetadata` to be an array in the JSON data but got " + data['developerMetadata']);
            }
            // validate the optional field `developerMetadata` (array)
            for (const item of data['developerMetadata']) {
                DeveloperMetadata.validateJSON(item);
            };
        }
        if (data['filterViews']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['filterViews'])) {
                throw new Error("Expected the field `filterViews` to be an array in the JSON data but got " + data['filterViews']);
            }
            // validate the optional field `filterViews` (array)
            for (const item of data['filterViews']) {
                FilterView.validateJSON(item);
            };
        }
        if (data['merges']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['merges'])) {
                throw new Error("Expected the field `merges` to be an array in the JSON data but got " + data['merges']);
            }
            // validate the optional field `merges` (array)
            for (const item of data['merges']) {
                GridRange.validateJSON(item);
            };
        }
        // validate the optional field `properties`
        if (data['properties']) { // data not null
          SheetProperties.validateJSON(data['properties']);
        }
        if (data['protectedRanges']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['protectedRanges'])) {
                throw new Error("Expected the field `protectedRanges` to be an array in the JSON data but got " + data['protectedRanges']);
            }
            // validate the optional field `protectedRanges` (array)
            for (const item of data['protectedRanges']) {
                ProtectedRange.validateJSON(item);
            };
        }
        if (data['rowGroups']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['rowGroups'])) {
                throw new Error("Expected the field `rowGroups` to be an array in the JSON data but got " + data['rowGroups']);
            }
            // validate the optional field `rowGroups` (array)
            for (const item of data['rowGroups']) {
                DimensionGroup.validateJSON(item);
            };
        }
        if (data['slicers']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['slicers'])) {
                throw new Error("Expected the field `slicers` to be an array in the JSON data but got " + data['slicers']);
            }
            // validate the optional field `slicers` (array)
            for (const item of data['slicers']) {
                Slicer.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * The banded (alternating colors) ranges on this sheet.
 * @member {Array.<module:model/BandedRange>} bandedRanges
 */
Sheet.prototype['bandedRanges'] = undefined;

/**
 * @member {module:model/BasicFilter} basicFilter
 */
Sheet.prototype['basicFilter'] = undefined;

/**
 * The specifications of every chart on this sheet.
 * @member {Array.<module:model/EmbeddedChart>} charts
 */
Sheet.prototype['charts'] = undefined;

/**
 * All column groups on this sheet, ordered by increasing range start index, then by group depth.
 * @member {Array.<module:model/DimensionGroup>} columnGroups
 */
Sheet.prototype['columnGroups'] = undefined;

/**
 * The conditional format rules in this sheet.
 * @member {Array.<module:model/ConditionalFormatRule>} conditionalFormats
 */
Sheet.prototype['conditionalFormats'] = undefined;

/**
 * Data in the grid, if this is a grid sheet. The number of GridData objects returned is dependent on the number of ranges requested on this sheet. For example, if this is representing `Sheet1`, and the spreadsheet was requested with ranges `Sheet1!A1:C10` and `Sheet1!D15:E20`, then the first GridData will have a startRow/startColumn of `0`, while the second one will have `startRow 14` (zero-based row 15), and `startColumn 3` (zero-based column D). For a DATA_SOURCE sheet, you can not request a specific range, the GridData contains all the values.
 * @member {Array.<module:model/GridData>} data
 */
Sheet.prototype['data'] = undefined;

/**
 * The developer metadata associated with a sheet.
 * @member {Array.<module:model/DeveloperMetadata>} developerMetadata
 */
Sheet.prototype['developerMetadata'] = undefined;

/**
 * The filter views in this sheet.
 * @member {Array.<module:model/FilterView>} filterViews
 */
Sheet.prototype['filterViews'] = undefined;

/**
 * The ranges that are merged together.
 * @member {Array.<module:model/GridRange>} merges
 */
Sheet.prototype['merges'] = undefined;

/**
 * @member {module:model/SheetProperties} properties
 */
Sheet.prototype['properties'] = undefined;

/**
 * The protected ranges in this sheet.
 * @member {Array.<module:model/ProtectedRange>} protectedRanges
 */
Sheet.prototype['protectedRanges'] = undefined;

/**
 * All row groups on this sheet, ordered by increasing range start index, then by group depth.
 * @member {Array.<module:model/DimensionGroup>} rowGroups
 */
Sheet.prototype['rowGroups'] = undefined;

/**
 * The slicers on this sheet.
 * @member {Array.<module:model/Slicer>} slicers
 */
Sheet.prototype['slicers'] = undefined;






export default Sheet;

