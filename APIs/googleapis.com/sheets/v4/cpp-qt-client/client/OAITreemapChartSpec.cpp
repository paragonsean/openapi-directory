/**
 * Google Sheets API
 * Reads and writes Google Sheets.
 *
 * The version of the OpenAPI document: v4
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITreemapChartSpec.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITreemapChartSpec::OAITreemapChartSpec(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITreemapChartSpec::OAITreemapChartSpec() {
    this->initializeModel();
}

OAITreemapChartSpec::~OAITreemapChartSpec() {}

void OAITreemapChartSpec::initializeModel() {

    m_color_data_isSet = false;
    m_color_data_isValid = false;

    m_color_scale_isSet = false;
    m_color_scale_isValid = false;

    m_header_color_isSet = false;
    m_header_color_isValid = false;

    m_header_color_style_isSet = false;
    m_header_color_style_isValid = false;

    m_hide_tooltips_isSet = false;
    m_hide_tooltips_isValid = false;

    m_hinted_levels_isSet = false;
    m_hinted_levels_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_levels_isSet = false;
    m_levels_isValid = false;

    m_max_value_isSet = false;
    m_max_value_isValid = false;

    m_min_value_isSet = false;
    m_min_value_isValid = false;

    m_parent_labels_isSet = false;
    m_parent_labels_isValid = false;

    m_size_data_isSet = false;
    m_size_data_isValid = false;

    m_text_format_isSet = false;
    m_text_format_isValid = false;
}

void OAITreemapChartSpec::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITreemapChartSpec::fromJsonObject(QJsonObject json) {

    m_color_data_isValid = ::OpenAPI::fromJsonValue(m_color_data, json[QString("colorData")]);
    m_color_data_isSet = !json[QString("colorData")].isNull() && m_color_data_isValid;

    m_color_scale_isValid = ::OpenAPI::fromJsonValue(m_color_scale, json[QString("colorScale")]);
    m_color_scale_isSet = !json[QString("colorScale")].isNull() && m_color_scale_isValid;

    m_header_color_isValid = ::OpenAPI::fromJsonValue(m_header_color, json[QString("headerColor")]);
    m_header_color_isSet = !json[QString("headerColor")].isNull() && m_header_color_isValid;

    m_header_color_style_isValid = ::OpenAPI::fromJsonValue(m_header_color_style, json[QString("headerColorStyle")]);
    m_header_color_style_isSet = !json[QString("headerColorStyle")].isNull() && m_header_color_style_isValid;

    m_hide_tooltips_isValid = ::OpenAPI::fromJsonValue(m_hide_tooltips, json[QString("hideTooltips")]);
    m_hide_tooltips_isSet = !json[QString("hideTooltips")].isNull() && m_hide_tooltips_isValid;

    m_hinted_levels_isValid = ::OpenAPI::fromJsonValue(m_hinted_levels, json[QString("hintedLevels")]);
    m_hinted_levels_isSet = !json[QString("hintedLevels")].isNull() && m_hinted_levels_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_levels_isValid = ::OpenAPI::fromJsonValue(m_levels, json[QString("levels")]);
    m_levels_isSet = !json[QString("levels")].isNull() && m_levels_isValid;

    m_max_value_isValid = ::OpenAPI::fromJsonValue(m_max_value, json[QString("maxValue")]);
    m_max_value_isSet = !json[QString("maxValue")].isNull() && m_max_value_isValid;

    m_min_value_isValid = ::OpenAPI::fromJsonValue(m_min_value, json[QString("minValue")]);
    m_min_value_isSet = !json[QString("minValue")].isNull() && m_min_value_isValid;

    m_parent_labels_isValid = ::OpenAPI::fromJsonValue(m_parent_labels, json[QString("parentLabels")]);
    m_parent_labels_isSet = !json[QString("parentLabels")].isNull() && m_parent_labels_isValid;

    m_size_data_isValid = ::OpenAPI::fromJsonValue(m_size_data, json[QString("sizeData")]);
    m_size_data_isSet = !json[QString("sizeData")].isNull() && m_size_data_isValid;

    m_text_format_isValid = ::OpenAPI::fromJsonValue(m_text_format, json[QString("textFormat")]);
    m_text_format_isSet = !json[QString("textFormat")].isNull() && m_text_format_isValid;
}

QString OAITreemapChartSpec::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITreemapChartSpec::asJsonObject() const {
    QJsonObject obj;
    if (m_color_data.isSet()) {
        obj.insert(QString("colorData"), ::OpenAPI::toJsonValue(m_color_data));
    }
    if (m_color_scale.isSet()) {
        obj.insert(QString("colorScale"), ::OpenAPI::toJsonValue(m_color_scale));
    }
    if (m_header_color.isSet()) {
        obj.insert(QString("headerColor"), ::OpenAPI::toJsonValue(m_header_color));
    }
    if (m_header_color_style.isSet()) {
        obj.insert(QString("headerColorStyle"), ::OpenAPI::toJsonValue(m_header_color_style));
    }
    if (m_hide_tooltips_isSet) {
        obj.insert(QString("hideTooltips"), ::OpenAPI::toJsonValue(m_hide_tooltips));
    }
    if (m_hinted_levels_isSet) {
        obj.insert(QString("hintedLevels"), ::OpenAPI::toJsonValue(m_hinted_levels));
    }
    if (m_labels.isSet()) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_levels_isSet) {
        obj.insert(QString("levels"), ::OpenAPI::toJsonValue(m_levels));
    }
    if (m_max_value_isSet) {
        obj.insert(QString("maxValue"), ::OpenAPI::toJsonValue(m_max_value));
    }
    if (m_min_value_isSet) {
        obj.insert(QString("minValue"), ::OpenAPI::toJsonValue(m_min_value));
    }
    if (m_parent_labels.isSet()) {
        obj.insert(QString("parentLabels"), ::OpenAPI::toJsonValue(m_parent_labels));
    }
    if (m_size_data.isSet()) {
        obj.insert(QString("sizeData"), ::OpenAPI::toJsonValue(m_size_data));
    }
    if (m_text_format.isSet()) {
        obj.insert(QString("textFormat"), ::OpenAPI::toJsonValue(m_text_format));
    }
    return obj;
}

OAIChartData OAITreemapChartSpec::getColorData() const {
    return m_color_data;
}
void OAITreemapChartSpec::setColorData(const OAIChartData &color_data) {
    m_color_data = color_data;
    m_color_data_isSet = true;
}

bool OAITreemapChartSpec::is_color_data_Set() const{
    return m_color_data_isSet;
}

bool OAITreemapChartSpec::is_color_data_Valid() const{
    return m_color_data_isValid;
}

OAITreemapChartColorScale OAITreemapChartSpec::getColorScale() const {
    return m_color_scale;
}
void OAITreemapChartSpec::setColorScale(const OAITreemapChartColorScale &color_scale) {
    m_color_scale = color_scale;
    m_color_scale_isSet = true;
}

bool OAITreemapChartSpec::is_color_scale_Set() const{
    return m_color_scale_isSet;
}

bool OAITreemapChartSpec::is_color_scale_Valid() const{
    return m_color_scale_isValid;
}

OAIColor OAITreemapChartSpec::getHeaderColor() const {
    return m_header_color;
}
void OAITreemapChartSpec::setHeaderColor(const OAIColor &header_color) {
    m_header_color = header_color;
    m_header_color_isSet = true;
}

bool OAITreemapChartSpec::is_header_color_Set() const{
    return m_header_color_isSet;
}

bool OAITreemapChartSpec::is_header_color_Valid() const{
    return m_header_color_isValid;
}

OAIColorStyle OAITreemapChartSpec::getHeaderColorStyle() const {
    return m_header_color_style;
}
void OAITreemapChartSpec::setHeaderColorStyle(const OAIColorStyle &header_color_style) {
    m_header_color_style = header_color_style;
    m_header_color_style_isSet = true;
}

bool OAITreemapChartSpec::is_header_color_style_Set() const{
    return m_header_color_style_isSet;
}

bool OAITreemapChartSpec::is_header_color_style_Valid() const{
    return m_header_color_style_isValid;
}

bool OAITreemapChartSpec::isHideTooltips() const {
    return m_hide_tooltips;
}
void OAITreemapChartSpec::setHideTooltips(const bool &hide_tooltips) {
    m_hide_tooltips = hide_tooltips;
    m_hide_tooltips_isSet = true;
}

bool OAITreemapChartSpec::is_hide_tooltips_Set() const{
    return m_hide_tooltips_isSet;
}

bool OAITreemapChartSpec::is_hide_tooltips_Valid() const{
    return m_hide_tooltips_isValid;
}

qint32 OAITreemapChartSpec::getHintedLevels() const {
    return m_hinted_levels;
}
void OAITreemapChartSpec::setHintedLevels(const qint32 &hinted_levels) {
    m_hinted_levels = hinted_levels;
    m_hinted_levels_isSet = true;
}

bool OAITreemapChartSpec::is_hinted_levels_Set() const{
    return m_hinted_levels_isSet;
}

bool OAITreemapChartSpec::is_hinted_levels_Valid() const{
    return m_hinted_levels_isValid;
}

OAIChartData OAITreemapChartSpec::getLabels() const {
    return m_labels;
}
void OAITreemapChartSpec::setLabels(const OAIChartData &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAITreemapChartSpec::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAITreemapChartSpec::is_labels_Valid() const{
    return m_labels_isValid;
}

qint32 OAITreemapChartSpec::getLevels() const {
    return m_levels;
}
void OAITreemapChartSpec::setLevels(const qint32 &levels) {
    m_levels = levels;
    m_levels_isSet = true;
}

bool OAITreemapChartSpec::is_levels_Set() const{
    return m_levels_isSet;
}

bool OAITreemapChartSpec::is_levels_Valid() const{
    return m_levels_isValid;
}

double OAITreemapChartSpec::getMaxValue() const {
    return m_max_value;
}
void OAITreemapChartSpec::setMaxValue(const double &max_value) {
    m_max_value = max_value;
    m_max_value_isSet = true;
}

bool OAITreemapChartSpec::is_max_value_Set() const{
    return m_max_value_isSet;
}

bool OAITreemapChartSpec::is_max_value_Valid() const{
    return m_max_value_isValid;
}

double OAITreemapChartSpec::getMinValue() const {
    return m_min_value;
}
void OAITreemapChartSpec::setMinValue(const double &min_value) {
    m_min_value = min_value;
    m_min_value_isSet = true;
}

bool OAITreemapChartSpec::is_min_value_Set() const{
    return m_min_value_isSet;
}

bool OAITreemapChartSpec::is_min_value_Valid() const{
    return m_min_value_isValid;
}

OAIChartData OAITreemapChartSpec::getParentLabels() const {
    return m_parent_labels;
}
void OAITreemapChartSpec::setParentLabels(const OAIChartData &parent_labels) {
    m_parent_labels = parent_labels;
    m_parent_labels_isSet = true;
}

bool OAITreemapChartSpec::is_parent_labels_Set() const{
    return m_parent_labels_isSet;
}

bool OAITreemapChartSpec::is_parent_labels_Valid() const{
    return m_parent_labels_isValid;
}

OAIChartData OAITreemapChartSpec::getSizeData() const {
    return m_size_data;
}
void OAITreemapChartSpec::setSizeData(const OAIChartData &size_data) {
    m_size_data = size_data;
    m_size_data_isSet = true;
}

bool OAITreemapChartSpec::is_size_data_Set() const{
    return m_size_data_isSet;
}

bool OAITreemapChartSpec::is_size_data_Valid() const{
    return m_size_data_isValid;
}

OAITextFormat OAITreemapChartSpec::getTextFormat() const {
    return m_text_format;
}
void OAITreemapChartSpec::setTextFormat(const OAITextFormat &text_format) {
    m_text_format = text_format;
    m_text_format_isSet = true;
}

bool OAITreemapChartSpec::is_text_format_Set() const{
    return m_text_format_isSet;
}

bool OAITreemapChartSpec::is_text_format_Valid() const{
    return m_text_format_isValid;
}

bool OAITreemapChartSpec::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_color_data.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_scale.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_header_color.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_header_color_style.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hide_tooltips_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hinted_levels_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_levels_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_parent_labels.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_data.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_format.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITreemapChartSpec::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
