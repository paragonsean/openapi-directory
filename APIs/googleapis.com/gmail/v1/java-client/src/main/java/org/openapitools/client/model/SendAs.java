/*
 * Gmail API
 * The Gmail API lets you view and manage Gmail mailbox data like threads, messages, and labels.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.SmtpMsa;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings associated with a send-as alias, which can be either the primary login address associated with the account or a custom \&quot;from\&quot; address. Send-as aliases correspond to the \&quot;Send Mail As\&quot; feature in the web interface.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:29.920230-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SendAs {
  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_IS_DEFAULT = "isDefault";
  @SerializedName(SERIALIZED_NAME_IS_DEFAULT)
  private Boolean isDefault;

  public static final String SERIALIZED_NAME_IS_PRIMARY = "isPrimary";
  @SerializedName(SERIALIZED_NAME_IS_PRIMARY)
  private Boolean isPrimary;

  public static final String SERIALIZED_NAME_REPLY_TO_ADDRESS = "replyToAddress";
  @SerializedName(SERIALIZED_NAME_REPLY_TO_ADDRESS)
  private String replyToAddress;

  public static final String SERIALIZED_NAME_SEND_AS_EMAIL = "sendAsEmail";
  @SerializedName(SERIALIZED_NAME_SEND_AS_EMAIL)
  private String sendAsEmail;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private String signature;

  public static final String SERIALIZED_NAME_SMTP_MSA = "smtpMsa";
  @SerializedName(SERIALIZED_NAME_SMTP_MSA)
  private SmtpMsa smtpMsa;

  public static final String SERIALIZED_NAME_TREAT_AS_ALIAS = "treatAsAlias";
  @SerializedName(SERIALIZED_NAME_TREAT_AS_ALIAS)
  private Boolean treatAsAlias;

  /**
   * Indicates whether this address has been verified for use as a send-as alias. Read-only. This setting only applies to custom \&quot;from\&quot; aliases.
   */
  @JsonAdapter(VerificationStatusEnum.Adapter.class)
  public enum VerificationStatusEnum {
    VERIFICATION_STATUS_UNSPECIFIED("verificationStatusUnspecified"),
    
    ACCEPTED("accepted"),
    
    PENDING("pending");

    private String value;

    VerificationStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VerificationStatusEnum fromValue(String value) {
      for (VerificationStatusEnum b : VerificationStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VerificationStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VerificationStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VerificationStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VerificationStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VerificationStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VERIFICATION_STATUS = "verificationStatus";
  @SerializedName(SERIALIZED_NAME_VERIFICATION_STATUS)
  private VerificationStatusEnum verificationStatus;

  public SendAs() {
  }

  public SendAs displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * A name that appears in the \&quot;From:\&quot; header for mail sent using this alias. For custom \&quot;from\&quot; addresses, when this is empty, Gmail will populate the \&quot;From:\&quot; header with the name that is used for the primary address associated with the account. If the admin has disabled the ability for users to update their name format, requests to update this field for the primary login will silently fail.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public SendAs isDefault(Boolean isDefault) {
    this.isDefault = isDefault;
    return this;
  }

  /**
   * Whether this address is selected as the default \&quot;From:\&quot; address in situations such as composing a new message or sending a vacation auto-reply. Every Gmail account has exactly one default send-as address, so the only legal value that clients may write to this field is &#x60;true&#x60;. Changing this from &#x60;false&#x60; to &#x60;true&#x60; for an address will result in this field becoming &#x60;false&#x60; for the other previous default address.
   * @return isDefault
   */
  @javax.annotation.Nullable
  public Boolean getIsDefault() {
    return isDefault;
  }

  public void setIsDefault(Boolean isDefault) {
    this.isDefault = isDefault;
  }


  public SendAs isPrimary(Boolean isPrimary) {
    this.isPrimary = isPrimary;
    return this;
  }

  /**
   * Whether this address is the primary address used to login to the account. Every Gmail account has exactly one primary address, and it cannot be deleted from the collection of send-as aliases. This field is read-only.
   * @return isPrimary
   */
  @javax.annotation.Nullable
  public Boolean getIsPrimary() {
    return isPrimary;
  }

  public void setIsPrimary(Boolean isPrimary) {
    this.isPrimary = isPrimary;
  }


  public SendAs replyToAddress(String replyToAddress) {
    this.replyToAddress = replyToAddress;
    return this;
  }

  /**
   * An optional email address that is included in a \&quot;Reply-To:\&quot; header for mail sent using this alias. If this is empty, Gmail will not generate a \&quot;Reply-To:\&quot; header.
   * @return replyToAddress
   */
  @javax.annotation.Nullable
  public String getReplyToAddress() {
    return replyToAddress;
  }

  public void setReplyToAddress(String replyToAddress) {
    this.replyToAddress = replyToAddress;
  }


  public SendAs sendAsEmail(String sendAsEmail) {
    this.sendAsEmail = sendAsEmail;
    return this;
  }

  /**
   * The email address that appears in the \&quot;From:\&quot; header for mail sent using this alias. This is read-only for all operations except create.
   * @return sendAsEmail
   */
  @javax.annotation.Nullable
  public String getSendAsEmail() {
    return sendAsEmail;
  }

  public void setSendAsEmail(String sendAsEmail) {
    this.sendAsEmail = sendAsEmail;
  }


  public SendAs signature(String signature) {
    this.signature = signature;
    return this;
  }

  /**
   * An optional HTML signature that is included in messages composed with this alias in the Gmail web UI. This signature is added to new emails only.
   * @return signature
   */
  @javax.annotation.Nullable
  public String getSignature() {
    return signature;
  }

  public void setSignature(String signature) {
    this.signature = signature;
  }


  public SendAs smtpMsa(SmtpMsa smtpMsa) {
    this.smtpMsa = smtpMsa;
    return this;
  }

  /**
   * Get smtpMsa
   * @return smtpMsa
   */
  @javax.annotation.Nullable
  public SmtpMsa getSmtpMsa() {
    return smtpMsa;
  }

  public void setSmtpMsa(SmtpMsa smtpMsa) {
    this.smtpMsa = smtpMsa;
  }


  public SendAs treatAsAlias(Boolean treatAsAlias) {
    this.treatAsAlias = treatAsAlias;
    return this;
  }

  /**
   * Whether Gmail should treat this address as an alias for the user&#39;s primary email address. This setting only applies to custom \&quot;from\&quot; aliases.
   * @return treatAsAlias
   */
  @javax.annotation.Nullable
  public Boolean getTreatAsAlias() {
    return treatAsAlias;
  }

  public void setTreatAsAlias(Boolean treatAsAlias) {
    this.treatAsAlias = treatAsAlias;
  }


  public SendAs verificationStatus(VerificationStatusEnum verificationStatus) {
    this.verificationStatus = verificationStatus;
    return this;
  }

  /**
   * Indicates whether this address has been verified for use as a send-as alias. Read-only. This setting only applies to custom \&quot;from\&quot; aliases.
   * @return verificationStatus
   */
  @javax.annotation.Nullable
  public VerificationStatusEnum getVerificationStatus() {
    return verificationStatus;
  }

  public void setVerificationStatus(VerificationStatusEnum verificationStatus) {
    this.verificationStatus = verificationStatus;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SendAs sendAs = (SendAs) o;
    return Objects.equals(this.displayName, sendAs.displayName) &&
        Objects.equals(this.isDefault, sendAs.isDefault) &&
        Objects.equals(this.isPrimary, sendAs.isPrimary) &&
        Objects.equals(this.replyToAddress, sendAs.replyToAddress) &&
        Objects.equals(this.sendAsEmail, sendAs.sendAsEmail) &&
        Objects.equals(this.signature, sendAs.signature) &&
        Objects.equals(this.smtpMsa, sendAs.smtpMsa) &&
        Objects.equals(this.treatAsAlias, sendAs.treatAsAlias) &&
        Objects.equals(this.verificationStatus, sendAs.verificationStatus);
  }

  @Override
  public int hashCode() {
    return Objects.hash(displayName, isDefault, isPrimary, replyToAddress, sendAsEmail, signature, smtpMsa, treatAsAlias, verificationStatus);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SendAs {\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    isDefault: ").append(toIndentedString(isDefault)).append("\n");
    sb.append("    isPrimary: ").append(toIndentedString(isPrimary)).append("\n");
    sb.append("    replyToAddress: ").append(toIndentedString(replyToAddress)).append("\n");
    sb.append("    sendAsEmail: ").append(toIndentedString(sendAsEmail)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    smtpMsa: ").append(toIndentedString(smtpMsa)).append("\n");
    sb.append("    treatAsAlias: ").append(toIndentedString(treatAsAlias)).append("\n");
    sb.append("    verificationStatus: ").append(toIndentedString(verificationStatus)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("displayName");
    openapiFields.add("isDefault");
    openapiFields.add("isPrimary");
    openapiFields.add("replyToAddress");
    openapiFields.add("sendAsEmail");
    openapiFields.add("signature");
    openapiFields.add("smtpMsa");
    openapiFields.add("treatAsAlias");
    openapiFields.add("verificationStatus");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SendAs
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SendAs.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SendAs is not found in the empty JSON string", SendAs.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SendAs.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SendAs` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("replyToAddress") != null && !jsonObj.get("replyToAddress").isJsonNull()) && !jsonObj.get("replyToAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replyToAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replyToAddress").toString()));
      }
      if ((jsonObj.get("sendAsEmail") != null && !jsonObj.get("sendAsEmail").isJsonNull()) && !jsonObj.get("sendAsEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendAsEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendAsEmail").toString()));
      }
      if ((jsonObj.get("signature") != null && !jsonObj.get("signature").isJsonNull()) && !jsonObj.get("signature").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `signature` to be a primitive type in the JSON string but got `%s`", jsonObj.get("signature").toString()));
      }
      // validate the optional field `smtpMsa`
      if (jsonObj.get("smtpMsa") != null && !jsonObj.get("smtpMsa").isJsonNull()) {
        SmtpMsa.validateJsonElement(jsonObj.get("smtpMsa"));
      }
      if ((jsonObj.get("verificationStatus") != null && !jsonObj.get("verificationStatus").isJsonNull()) && !jsonObj.get("verificationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `verificationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("verificationStatus").toString()));
      }
      // validate the optional field `verificationStatus`
      if (jsonObj.get("verificationStatus") != null && !jsonObj.get("verificationStatus").isJsonNull()) {
        VerificationStatusEnum.validateJsonElement(jsonObj.get("verificationStatus"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SendAs.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SendAs' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SendAs> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SendAs.class));

       return (TypeAdapter<T>) new TypeAdapter<SendAs>() {
           @Override
           public void write(JsonWriter out, SendAs value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SendAs read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SendAs given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SendAs
   * @throws IOException if the JSON string is invalid with respect to SendAs
   */
  public static SendAs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SendAs.class);
  }

  /**
   * Convert an instance of SendAs to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

