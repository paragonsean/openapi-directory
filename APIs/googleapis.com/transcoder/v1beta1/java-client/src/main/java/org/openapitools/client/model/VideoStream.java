/*
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. 
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Video stream resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:40.503024-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoStream {
  public static final String SERIALIZED_NAME_ALLOW_OPEN_GOP = "allowOpenGop";
  @SerializedName(SERIALIZED_NAME_ALLOW_OPEN_GOP)
  private Boolean allowOpenGop;

  public static final String SERIALIZED_NAME_AQ_STRENGTH = "aqStrength";
  @SerializedName(SERIALIZED_NAME_AQ_STRENGTH)
  private Double aqStrength;

  public static final String SERIALIZED_NAME_B_FRAME_COUNT = "bFrameCount";
  @SerializedName(SERIALIZED_NAME_B_FRAME_COUNT)
  private Integer bFrameCount;

  public static final String SERIALIZED_NAME_B_PYRAMID = "bPyramid";
  @SerializedName(SERIALIZED_NAME_B_PYRAMID)
  private Boolean bPyramid;

  public static final String SERIALIZED_NAME_BITRATE_BPS = "bitrateBps";
  @SerializedName(SERIALIZED_NAME_BITRATE_BPS)
  private Integer bitrateBps;

  public static final String SERIALIZED_NAME_CODEC = "codec";
  @SerializedName(SERIALIZED_NAME_CODEC)
  private String codec;

  public static final String SERIALIZED_NAME_CRF_LEVEL = "crfLevel";
  @SerializedName(SERIALIZED_NAME_CRF_LEVEL)
  private Integer crfLevel;

  public static final String SERIALIZED_NAME_ENABLE_TWO_PASS = "enableTwoPass";
  @SerializedName(SERIALIZED_NAME_ENABLE_TWO_PASS)
  private Boolean enableTwoPass;

  public static final String SERIALIZED_NAME_ENTROPY_CODER = "entropyCoder";
  @SerializedName(SERIALIZED_NAME_ENTROPY_CODER)
  private String entropyCoder;

  public static final String SERIALIZED_NAME_FRAME_RATE = "frameRate";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE)
  private Double frameRate;

  public static final String SERIALIZED_NAME_GOP_DURATION = "gopDuration";
  @SerializedName(SERIALIZED_NAME_GOP_DURATION)
  private String gopDuration;

  public static final String SERIALIZED_NAME_GOP_FRAME_COUNT = "gopFrameCount";
  @SerializedName(SERIALIZED_NAME_GOP_FRAME_COUNT)
  private Integer gopFrameCount;

  public static final String SERIALIZED_NAME_HEIGHT_PIXELS = "heightPixels";
  @SerializedName(SERIALIZED_NAME_HEIGHT_PIXELS)
  private Integer heightPixels;

  public static final String SERIALIZED_NAME_PIXEL_FORMAT = "pixelFormat";
  @SerializedName(SERIALIZED_NAME_PIXEL_FORMAT)
  private String pixelFormat;

  public static final String SERIALIZED_NAME_PRESET = "preset";
  @SerializedName(SERIALIZED_NAME_PRESET)
  private String preset;

  public static final String SERIALIZED_NAME_PROFILE = "profile";
  @SerializedName(SERIALIZED_NAME_PROFILE)
  private String profile;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "rateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private String rateControlMode;

  public static final String SERIALIZED_NAME_TUNE = "tune";
  @SerializedName(SERIALIZED_NAME_TUNE)
  private String tune;

  public static final String SERIALIZED_NAME_VBV_FULLNESS_BITS = "vbvFullnessBits";
  @SerializedName(SERIALIZED_NAME_VBV_FULLNESS_BITS)
  private Integer vbvFullnessBits;

  public static final String SERIALIZED_NAME_VBV_SIZE_BITS = "vbvSizeBits";
  @SerializedName(SERIALIZED_NAME_VBV_SIZE_BITS)
  private Integer vbvSizeBits;

  public static final String SERIALIZED_NAME_WIDTH_PIXELS = "widthPixels";
  @SerializedName(SERIALIZED_NAME_WIDTH_PIXELS)
  private Integer widthPixels;

  public VideoStream() {
  }

  public VideoStream allowOpenGop(Boolean allowOpenGop) {
    this.allowOpenGop = allowOpenGop;
    return this;
  }

  /**
   * Specifies whether an open Group of Pictures (GOP) structure should be allowed or not. The default is &#x60;false&#x60;.
   * @return allowOpenGop
   */
  @javax.annotation.Nullable
  public Boolean getAllowOpenGop() {
    return allowOpenGop;
  }

  public void setAllowOpenGop(Boolean allowOpenGop) {
    this.allowOpenGop = allowOpenGop;
  }


  public VideoStream aqStrength(Double aqStrength) {
    this.aqStrength = aqStrength;
    return this;
  }

  /**
   * Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher value equals a lower bitrate but smoother image. The default is 0.
   * @return aqStrength
   */
  @javax.annotation.Nullable
  public Double getAqStrength() {
    return aqStrength;
  }

  public void setAqStrength(Double aqStrength) {
    this.aqStrength = aqStrength;
  }


  public VideoStream bFrameCount(Integer bFrameCount) {
    this.bFrameCount = bFrameCount;
    return this;
  }

  /**
   * The number of consecutive B-frames. Must be greater than or equal to zero. Must be less than &#x60;VideoStream.gop_frame_count&#x60; if set. The default is 0.
   * @return bFrameCount
   */
  @javax.annotation.Nullable
  public Integer getbFrameCount() {
    return bFrameCount;
  }

  public void setbFrameCount(Integer bFrameCount) {
    this.bFrameCount = bFrameCount;
  }


  public VideoStream bPyramid(Boolean bPyramid) {
    this.bPyramid = bPyramid;
    return this;
  }

  /**
   * Allow B-pyramid for reference frame selection. This may not be supported on all decoders. The default is &#x60;false&#x60;.
   * @return bPyramid
   */
  @javax.annotation.Nullable
  public Boolean getbPyramid() {
    return bPyramid;
  }

  public void setbPyramid(Boolean bPyramid) {
    this.bPyramid = bPyramid;
  }


  public VideoStream bitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
    return this;
  }

  /**
   * Required. The video bitrate in bits per second. The minimum value is 1,000. The maximum value for H264/H265 is 800,000,000. The maximum value for VP9 is 480,000,000.
   * @return bitrateBps
   */
  @javax.annotation.Nullable
  public Integer getBitrateBps() {
    return bitrateBps;
  }

  public void setBitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
  }


  public VideoStream codec(String codec) {
    this.codec = codec;
    return this;
  }

  /**
   * Codec type. The following codecs are supported: * &#x60;h264&#x60; (default) * &#x60;h265&#x60; * &#x60;vp9&#x60;
   * @return codec
   */
  @javax.annotation.Nullable
  public String getCodec() {
    return codec;
  }

  public void setCodec(String codec) {
    this.codec = codec;
  }


  public VideoStream crfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
    return this;
  }

  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest quality and 36 is the most efficient compression. The default is 21.
   * @return crfLevel
   */
  @javax.annotation.Nullable
  public Integer getCrfLevel() {
    return crfLevel;
  }

  public void setCrfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
  }


  public VideoStream enableTwoPass(Boolean enableTwoPass) {
    this.enableTwoPass = enableTwoPass;
    return this;
  }

  /**
   * Use two-pass encoding strategy to achieve better video quality. &#x60;VideoStream.rate_control_mode&#x60; must be &#x60;\&quot;vbr\&quot;&#x60;. The default is &#x60;false&#x60;.
   * @return enableTwoPass
   */
  @javax.annotation.Nullable
  public Boolean getEnableTwoPass() {
    return enableTwoPass;
  }

  public void setEnableTwoPass(Boolean enableTwoPass) {
    this.enableTwoPass = enableTwoPass;
  }


  public VideoStream entropyCoder(String entropyCoder) {
    this.entropyCoder = entropyCoder;
    return this;
  }

  /**
   * The entropy coder to use. The default is &#x60;\&quot;cabac\&quot;&#x60;. Supported entropy coders: - &#39;cavlc&#39; - &#39;cabac&#39;
   * @return entropyCoder
   */
  @javax.annotation.Nullable
  public String getEntropyCoder() {
    return entropyCoder;
  }

  public void setEntropyCoder(String entropyCoder) {
    this.entropyCoder = entropyCoder;
  }


  public VideoStream frameRate(Double frameRate) {
    this.frameRate = frameRate;
    return this;
  }

  /**
   * Required. The target video frame rate in frames per second (FPS). Must be less than or equal to 120. Will default to the input frame rate if larger than the input frame rate. The API will generate an output FPS that is divisible by the input FPS, and smaller or equal to the target FPS. See [Calculate frame rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for more information.
   * @return frameRate
   */
  @javax.annotation.Nullable
  public Double getFrameRate() {
    return frameRate;
  }

  public void setFrameRate(Double frameRate) {
    this.frameRate = frameRate;
  }


  public VideoStream gopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
    return this;
  }

  /**
   * Select the GOP size based on the specified duration. The default is &#x60;\&quot;3s\&quot;&#x60;. Note that &#x60;gopDuration&#x60; must be less than or equal to [&#x60;segmentDuration&#x60;](#SegmentSettings), and [&#x60;segmentDuration&#x60;](#SegmentSettings) must be divisible by &#x60;gopDuration&#x60;.
   * @return gopDuration
   */
  @javax.annotation.Nullable
  public String getGopDuration() {
    return gopDuration;
  }

  public void setGopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
  }


  public VideoStream gopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
    return this;
  }

  /**
   * Select the GOP size based on the specified frame count. Must be greater than zero.
   * @return gopFrameCount
   */
  @javax.annotation.Nullable
  public Integer getGopFrameCount() {
    return gopFrameCount;
  }

  public void setGopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
  }


  public VideoStream heightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
    return this;
  }

  /**
   * The height of the video in pixels. Must be an even integer. When not specified, the height is adjusted to match the specified width and input aspect ratio. If both are omitted, the input height is used.
   * @return heightPixels
   */
  @javax.annotation.Nullable
  public Integer getHeightPixels() {
    return heightPixels;
  }

  public void setHeightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
  }


  public VideoStream pixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
    return this;
  }

  /**
   * Pixel format to use. The default is &#x60;\&quot;yuv420p\&quot;&#x60;. Supported pixel formats: - &#39;yuv420p&#39; pixel format. - &#39;yuv422p&#39; pixel format. - &#39;yuv444p&#39; pixel format. - &#39;yuv420p10&#39; 10-bit HDR pixel format. - &#39;yuv422p10&#39; 10-bit HDR pixel format. - &#39;yuv444p10&#39; 10-bit HDR pixel format. - &#39;yuv420p12&#39; 12-bit HDR pixel format. - &#39;yuv422p12&#39; 12-bit HDR pixel format. - &#39;yuv444p12&#39; 12-bit HDR pixel format.
   * @return pixelFormat
   */
  @javax.annotation.Nullable
  public String getPixelFormat() {
    return pixelFormat;
  }

  public void setPixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
  }


  public VideoStream preset(String preset) {
    this.preset = preset;
    return this;
  }

  /**
   * Enforces the specified codec preset. The default is &#x60;veryfast&#x60;. The available options are FFmpeg-compatible. Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;VideoStream&#x60; message.
   * @return preset
   */
  @javax.annotation.Nullable
  public String getPreset() {
    return preset;
  }

  public void setPreset(String preset) {
    this.preset = preset;
  }


  public VideoStream profile(String profile) {
    this.profile = profile;
    return this;
  }

  /**
   * Enforces the specified codec profile. The following profiles are supported: * &#x60;baseline&#x60; * &#x60;main&#x60; * &#x60;high&#x60; (default) The available options are FFmpeg-compatible. Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;VideoStream&#x60; message.
   * @return profile
   */
  @javax.annotation.Nullable
  public String getProfile() {
    return profile;
  }

  public void setProfile(String profile) {
    this.profile = profile;
  }


  public VideoStream rateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Specify the &#x60;rate_control_mode&#x60;. The default is &#x60;\&quot;vbr\&quot;&#x60;. Supported rate control modes: - &#39;vbr&#39; - variable bitrate - &#39;crf&#39; - constant rate factor
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public String getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public VideoStream tune(String tune) {
    this.tune = tune;
    return this;
  }

  /**
   * Enforces the specified codec tune. The available options are FFmpeg-compatible. Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;VideoStream&#x60; message.
   * @return tune
   */
  @javax.annotation.Nullable
  public String getTune() {
    return tune;
  }

  public void setTune(String tune) {
    this.tune = tune;
  }


  public VideoStream vbvFullnessBits(Integer vbvFullnessBits) {
    this.vbvFullnessBits = vbvFullnessBits;
    return this;
  }

  /**
   * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to 90% of &#x60;VideoStream.vbv_size_bits&#x60;.
   * @return vbvFullnessBits
   */
  @javax.annotation.Nullable
  public Integer getVbvFullnessBits() {
    return vbvFullnessBits;
  }

  public void setVbvFullnessBits(Integer vbvFullnessBits) {
    this.vbvFullnessBits = vbvFullnessBits;
  }


  public VideoStream vbvSizeBits(Integer vbvSizeBits) {
    this.vbvSizeBits = vbvSizeBits;
    return this;
  }

  /**
   * Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to &#x60;VideoStream.bitrate_bps&#x60;.
   * @return vbvSizeBits
   */
  @javax.annotation.Nullable
  public Integer getVbvSizeBits() {
    return vbvSizeBits;
  }

  public void setVbvSizeBits(Integer vbvSizeBits) {
    this.vbvSizeBits = vbvSizeBits;
  }


  public VideoStream widthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
    return this;
  }

  /**
   * The width of the video in pixels. Must be an even integer. When not specified, the width is adjusted to match the specified height and input aspect ratio. If both are omitted, the input width is used.
   * @return widthPixels
   */
  @javax.annotation.Nullable
  public Integer getWidthPixels() {
    return widthPixels;
  }

  public void setWidthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoStream videoStream = (VideoStream) o;
    return Objects.equals(this.allowOpenGop, videoStream.allowOpenGop) &&
        Objects.equals(this.aqStrength, videoStream.aqStrength) &&
        Objects.equals(this.bFrameCount, videoStream.bFrameCount) &&
        Objects.equals(this.bPyramid, videoStream.bPyramid) &&
        Objects.equals(this.bitrateBps, videoStream.bitrateBps) &&
        Objects.equals(this.codec, videoStream.codec) &&
        Objects.equals(this.crfLevel, videoStream.crfLevel) &&
        Objects.equals(this.enableTwoPass, videoStream.enableTwoPass) &&
        Objects.equals(this.entropyCoder, videoStream.entropyCoder) &&
        Objects.equals(this.frameRate, videoStream.frameRate) &&
        Objects.equals(this.gopDuration, videoStream.gopDuration) &&
        Objects.equals(this.gopFrameCount, videoStream.gopFrameCount) &&
        Objects.equals(this.heightPixels, videoStream.heightPixels) &&
        Objects.equals(this.pixelFormat, videoStream.pixelFormat) &&
        Objects.equals(this.preset, videoStream.preset) &&
        Objects.equals(this.profile, videoStream.profile) &&
        Objects.equals(this.rateControlMode, videoStream.rateControlMode) &&
        Objects.equals(this.tune, videoStream.tune) &&
        Objects.equals(this.vbvFullnessBits, videoStream.vbvFullnessBits) &&
        Objects.equals(this.vbvSizeBits, videoStream.vbvSizeBits) &&
        Objects.equals(this.widthPixels, videoStream.widthPixels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowOpenGop, aqStrength, bFrameCount, bPyramid, bitrateBps, codec, crfLevel, enableTwoPass, entropyCoder, frameRate, gopDuration, gopFrameCount, heightPixels, pixelFormat, preset, profile, rateControlMode, tune, vbvFullnessBits, vbvSizeBits, widthPixels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoStream {\n");
    sb.append("    allowOpenGop: ").append(toIndentedString(allowOpenGop)).append("\n");
    sb.append("    aqStrength: ").append(toIndentedString(aqStrength)).append("\n");
    sb.append("    bFrameCount: ").append(toIndentedString(bFrameCount)).append("\n");
    sb.append("    bPyramid: ").append(toIndentedString(bPyramid)).append("\n");
    sb.append("    bitrateBps: ").append(toIndentedString(bitrateBps)).append("\n");
    sb.append("    codec: ").append(toIndentedString(codec)).append("\n");
    sb.append("    crfLevel: ").append(toIndentedString(crfLevel)).append("\n");
    sb.append("    enableTwoPass: ").append(toIndentedString(enableTwoPass)).append("\n");
    sb.append("    entropyCoder: ").append(toIndentedString(entropyCoder)).append("\n");
    sb.append("    frameRate: ").append(toIndentedString(frameRate)).append("\n");
    sb.append("    gopDuration: ").append(toIndentedString(gopDuration)).append("\n");
    sb.append("    gopFrameCount: ").append(toIndentedString(gopFrameCount)).append("\n");
    sb.append("    heightPixels: ").append(toIndentedString(heightPixels)).append("\n");
    sb.append("    pixelFormat: ").append(toIndentedString(pixelFormat)).append("\n");
    sb.append("    preset: ").append(toIndentedString(preset)).append("\n");
    sb.append("    profile: ").append(toIndentedString(profile)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    tune: ").append(toIndentedString(tune)).append("\n");
    sb.append("    vbvFullnessBits: ").append(toIndentedString(vbvFullnessBits)).append("\n");
    sb.append("    vbvSizeBits: ").append(toIndentedString(vbvSizeBits)).append("\n");
    sb.append("    widthPixels: ").append(toIndentedString(widthPixels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowOpenGop");
    openapiFields.add("aqStrength");
    openapiFields.add("bFrameCount");
    openapiFields.add("bPyramid");
    openapiFields.add("bitrateBps");
    openapiFields.add("codec");
    openapiFields.add("crfLevel");
    openapiFields.add("enableTwoPass");
    openapiFields.add("entropyCoder");
    openapiFields.add("frameRate");
    openapiFields.add("gopDuration");
    openapiFields.add("gopFrameCount");
    openapiFields.add("heightPixels");
    openapiFields.add("pixelFormat");
    openapiFields.add("preset");
    openapiFields.add("profile");
    openapiFields.add("rateControlMode");
    openapiFields.add("tune");
    openapiFields.add("vbvFullnessBits");
    openapiFields.add("vbvSizeBits");
    openapiFields.add("widthPixels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoStream
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoStream.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoStream is not found in the empty JSON string", VideoStream.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoStream.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoStream` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("codec") != null && !jsonObj.get("codec").isJsonNull()) && !jsonObj.get("codec").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `codec` to be a primitive type in the JSON string but got `%s`", jsonObj.get("codec").toString()));
      }
      if ((jsonObj.get("entropyCoder") != null && !jsonObj.get("entropyCoder").isJsonNull()) && !jsonObj.get("entropyCoder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entropyCoder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entropyCoder").toString()));
      }
      if ((jsonObj.get("gopDuration") != null && !jsonObj.get("gopDuration").isJsonNull()) && !jsonObj.get("gopDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gopDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gopDuration").toString()));
      }
      if ((jsonObj.get("pixelFormat") != null && !jsonObj.get("pixelFormat").isJsonNull()) && !jsonObj.get("pixelFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pixelFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pixelFormat").toString()));
      }
      if ((jsonObj.get("preset") != null && !jsonObj.get("preset").isJsonNull()) && !jsonObj.get("preset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preset").toString()));
      }
      if ((jsonObj.get("profile") != null && !jsonObj.get("profile").isJsonNull()) && !jsonObj.get("profile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profile").toString()));
      }
      if ((jsonObj.get("rateControlMode") != null && !jsonObj.get("rateControlMode").isJsonNull()) && !jsonObj.get("rateControlMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rateControlMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rateControlMode").toString()));
      }
      if ((jsonObj.get("tune") != null && !jsonObj.get("tune").isJsonNull()) && !jsonObj.get("tune").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tune` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tune").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoStream.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoStream' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoStream> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoStream.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoStream>() {
           @Override
           public void write(JsonWriter out, VideoStream value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoStream read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoStream given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoStream
   * @throws IOException if the JSON string is invalid with respect to VideoStream
   */
  public static VideoStream fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoStream.class);
  }

  /**
   * Convert an instance of VideoStream to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

