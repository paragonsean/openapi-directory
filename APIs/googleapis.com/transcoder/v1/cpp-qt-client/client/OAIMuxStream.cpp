/**
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMuxStream.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMuxStream::OAIMuxStream(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMuxStream::OAIMuxStream() {
    this->initializeModel();
}

OAIMuxStream::~OAIMuxStream() {}

void OAIMuxStream::initializeModel() {

    m_container_isSet = false;
    m_container_isValid = false;

    m_elementary_streams_isSet = false;
    m_elementary_streams_isValid = false;

    m_encryption_id_isSet = false;
    m_encryption_id_isValid = false;

    m_file_name_isSet = false;
    m_file_name_isValid = false;

    m_fmp4_isSet = false;
    m_fmp4_isValid = false;

    m_key_isSet = false;
    m_key_isValid = false;

    m_segment_settings_isSet = false;
    m_segment_settings_isValid = false;
}

void OAIMuxStream::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMuxStream::fromJsonObject(QJsonObject json) {

    m_container_isValid = ::OpenAPI::fromJsonValue(m_container, json[QString("container")]);
    m_container_isSet = !json[QString("container")].isNull() && m_container_isValid;

    m_elementary_streams_isValid = ::OpenAPI::fromJsonValue(m_elementary_streams, json[QString("elementaryStreams")]);
    m_elementary_streams_isSet = !json[QString("elementaryStreams")].isNull() && m_elementary_streams_isValid;

    m_encryption_id_isValid = ::OpenAPI::fromJsonValue(m_encryption_id, json[QString("encryptionId")]);
    m_encryption_id_isSet = !json[QString("encryptionId")].isNull() && m_encryption_id_isValid;

    m_file_name_isValid = ::OpenAPI::fromJsonValue(m_file_name, json[QString("fileName")]);
    m_file_name_isSet = !json[QString("fileName")].isNull() && m_file_name_isValid;

    m_fmp4_isValid = ::OpenAPI::fromJsonValue(m_fmp4, json[QString("fmp4")]);
    m_fmp4_isSet = !json[QString("fmp4")].isNull() && m_fmp4_isValid;

    m_key_isValid = ::OpenAPI::fromJsonValue(m_key, json[QString("key")]);
    m_key_isSet = !json[QString("key")].isNull() && m_key_isValid;

    m_segment_settings_isValid = ::OpenAPI::fromJsonValue(m_segment_settings, json[QString("segmentSettings")]);
    m_segment_settings_isSet = !json[QString("segmentSettings")].isNull() && m_segment_settings_isValid;
}

QString OAIMuxStream::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMuxStream::asJsonObject() const {
    QJsonObject obj;
    if (m_container_isSet) {
        obj.insert(QString("container"), ::OpenAPI::toJsonValue(m_container));
    }
    if (m_elementary_streams.size() > 0) {
        obj.insert(QString("elementaryStreams"), ::OpenAPI::toJsonValue(m_elementary_streams));
    }
    if (m_encryption_id_isSet) {
        obj.insert(QString("encryptionId"), ::OpenAPI::toJsonValue(m_encryption_id));
    }
    if (m_file_name_isSet) {
        obj.insert(QString("fileName"), ::OpenAPI::toJsonValue(m_file_name));
    }
    if (m_fmp4.isSet()) {
        obj.insert(QString("fmp4"), ::OpenAPI::toJsonValue(m_fmp4));
    }
    if (m_key_isSet) {
        obj.insert(QString("key"), ::OpenAPI::toJsonValue(m_key));
    }
    if (m_segment_settings.isSet()) {
        obj.insert(QString("segmentSettings"), ::OpenAPI::toJsonValue(m_segment_settings));
    }
    return obj;
}

QString OAIMuxStream::getContainer() const {
    return m_container;
}
void OAIMuxStream::setContainer(const QString &container) {
    m_container = container;
    m_container_isSet = true;
}

bool OAIMuxStream::is_container_Set() const{
    return m_container_isSet;
}

bool OAIMuxStream::is_container_Valid() const{
    return m_container_isValid;
}

QList<QString> OAIMuxStream::getElementaryStreams() const {
    return m_elementary_streams;
}
void OAIMuxStream::setElementaryStreams(const QList<QString> &elementary_streams) {
    m_elementary_streams = elementary_streams;
    m_elementary_streams_isSet = true;
}

bool OAIMuxStream::is_elementary_streams_Set() const{
    return m_elementary_streams_isSet;
}

bool OAIMuxStream::is_elementary_streams_Valid() const{
    return m_elementary_streams_isValid;
}

QString OAIMuxStream::getEncryptionId() const {
    return m_encryption_id;
}
void OAIMuxStream::setEncryptionId(const QString &encryption_id) {
    m_encryption_id = encryption_id;
    m_encryption_id_isSet = true;
}

bool OAIMuxStream::is_encryption_id_Set() const{
    return m_encryption_id_isSet;
}

bool OAIMuxStream::is_encryption_id_Valid() const{
    return m_encryption_id_isValid;
}

QString OAIMuxStream::getFileName() const {
    return m_file_name;
}
void OAIMuxStream::setFileName(const QString &file_name) {
    m_file_name = file_name;
    m_file_name_isSet = true;
}

bool OAIMuxStream::is_file_name_Set() const{
    return m_file_name_isSet;
}

bool OAIMuxStream::is_file_name_Valid() const{
    return m_file_name_isValid;
}

OAIFmp4Config OAIMuxStream::getFmp4() const {
    return m_fmp4;
}
void OAIMuxStream::setFmp4(const OAIFmp4Config &fmp4) {
    m_fmp4 = fmp4;
    m_fmp4_isSet = true;
}

bool OAIMuxStream::is_fmp4_Set() const{
    return m_fmp4_isSet;
}

bool OAIMuxStream::is_fmp4_Valid() const{
    return m_fmp4_isValid;
}

QString OAIMuxStream::getKey() const {
    return m_key;
}
void OAIMuxStream::setKey(const QString &key) {
    m_key = key;
    m_key_isSet = true;
}

bool OAIMuxStream::is_key_Set() const{
    return m_key_isSet;
}

bool OAIMuxStream::is_key_Valid() const{
    return m_key_isValid;
}

OAISegmentSettings OAIMuxStream::getSegmentSettings() const {
    return m_segment_settings;
}
void OAIMuxStream::setSegmentSettings(const OAISegmentSettings &segment_settings) {
    m_segment_settings = segment_settings;
    m_segment_settings_isSet = true;
}

bool OAIMuxStream::is_segment_settings_Set() const{
    return m_segment_settings_isSet;
}

bool OAIMuxStream::is_segment_settings_Valid() const{
    return m_segment_settings_isValid;
}

bool OAIMuxStream::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_elementary_streams.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_file_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fmp4.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_segment_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMuxStream::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
