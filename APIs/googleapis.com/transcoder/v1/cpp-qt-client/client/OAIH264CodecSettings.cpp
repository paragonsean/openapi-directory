/**
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIH264CodecSettings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIH264CodecSettings::OAIH264CodecSettings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIH264CodecSettings::OAIH264CodecSettings() {
    this->initializeModel();
}

OAIH264CodecSettings::~OAIH264CodecSettings() {}

void OAIH264CodecSettings::initializeModel() {

    m_allow_open_gop_isSet = false;
    m_allow_open_gop_isValid = false;

    m_aq_strength_isSet = false;
    m_aq_strength_isValid = false;

    m_b_frame_count_isSet = false;
    m_b_frame_count_isValid = false;

    m_b_pyramid_isSet = false;
    m_b_pyramid_isValid = false;

    m_bitrate_bps_isSet = false;
    m_bitrate_bps_isValid = false;

    m_crf_level_isSet = false;
    m_crf_level_isValid = false;

    m_enable_two_pass_isSet = false;
    m_enable_two_pass_isValid = false;

    m_entropy_coder_isSet = false;
    m_entropy_coder_isValid = false;

    m_frame_rate_isSet = false;
    m_frame_rate_isValid = false;

    m_frame_rate_conversion_strategy_isSet = false;
    m_frame_rate_conversion_strategy_isValid = false;

    m_gop_duration_isSet = false;
    m_gop_duration_isValid = false;

    m_gop_frame_count_isSet = false;
    m_gop_frame_count_isValid = false;

    m_height_pixels_isSet = false;
    m_height_pixels_isValid = false;

    m_hlg_isSet = false;
    m_hlg_isValid = false;

    m_pixel_format_isSet = false;
    m_pixel_format_isValid = false;

    m_preset_isSet = false;
    m_preset_isValid = false;

    m_profile_isSet = false;
    m_profile_isValid = false;

    m_rate_control_mode_isSet = false;
    m_rate_control_mode_isValid = false;

    m_sdr_isSet = false;
    m_sdr_isValid = false;

    m_tune_isSet = false;
    m_tune_isValid = false;

    m_vbv_fullness_bits_isSet = false;
    m_vbv_fullness_bits_isValid = false;

    m_vbv_size_bits_isSet = false;
    m_vbv_size_bits_isValid = false;

    m_width_pixels_isSet = false;
    m_width_pixels_isValid = false;
}

void OAIH264CodecSettings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIH264CodecSettings::fromJsonObject(QJsonObject json) {

    m_allow_open_gop_isValid = ::OpenAPI::fromJsonValue(m_allow_open_gop, json[QString("allowOpenGop")]);
    m_allow_open_gop_isSet = !json[QString("allowOpenGop")].isNull() && m_allow_open_gop_isValid;

    m_aq_strength_isValid = ::OpenAPI::fromJsonValue(m_aq_strength, json[QString("aqStrength")]);
    m_aq_strength_isSet = !json[QString("aqStrength")].isNull() && m_aq_strength_isValid;

    m_b_frame_count_isValid = ::OpenAPI::fromJsonValue(m_b_frame_count, json[QString("bFrameCount")]);
    m_b_frame_count_isSet = !json[QString("bFrameCount")].isNull() && m_b_frame_count_isValid;

    m_b_pyramid_isValid = ::OpenAPI::fromJsonValue(m_b_pyramid, json[QString("bPyramid")]);
    m_b_pyramid_isSet = !json[QString("bPyramid")].isNull() && m_b_pyramid_isValid;

    m_bitrate_bps_isValid = ::OpenAPI::fromJsonValue(m_bitrate_bps, json[QString("bitrateBps")]);
    m_bitrate_bps_isSet = !json[QString("bitrateBps")].isNull() && m_bitrate_bps_isValid;

    m_crf_level_isValid = ::OpenAPI::fromJsonValue(m_crf_level, json[QString("crfLevel")]);
    m_crf_level_isSet = !json[QString("crfLevel")].isNull() && m_crf_level_isValid;

    m_enable_two_pass_isValid = ::OpenAPI::fromJsonValue(m_enable_two_pass, json[QString("enableTwoPass")]);
    m_enable_two_pass_isSet = !json[QString("enableTwoPass")].isNull() && m_enable_two_pass_isValid;

    m_entropy_coder_isValid = ::OpenAPI::fromJsonValue(m_entropy_coder, json[QString("entropyCoder")]);
    m_entropy_coder_isSet = !json[QString("entropyCoder")].isNull() && m_entropy_coder_isValid;

    m_frame_rate_isValid = ::OpenAPI::fromJsonValue(m_frame_rate, json[QString("frameRate")]);
    m_frame_rate_isSet = !json[QString("frameRate")].isNull() && m_frame_rate_isValid;

    m_frame_rate_conversion_strategy_isValid = ::OpenAPI::fromJsonValue(m_frame_rate_conversion_strategy, json[QString("frameRateConversionStrategy")]);
    m_frame_rate_conversion_strategy_isSet = !json[QString("frameRateConversionStrategy")].isNull() && m_frame_rate_conversion_strategy_isValid;

    m_gop_duration_isValid = ::OpenAPI::fromJsonValue(m_gop_duration, json[QString("gopDuration")]);
    m_gop_duration_isSet = !json[QString("gopDuration")].isNull() && m_gop_duration_isValid;

    m_gop_frame_count_isValid = ::OpenAPI::fromJsonValue(m_gop_frame_count, json[QString("gopFrameCount")]);
    m_gop_frame_count_isSet = !json[QString("gopFrameCount")].isNull() && m_gop_frame_count_isValid;

    m_height_pixels_isValid = ::OpenAPI::fromJsonValue(m_height_pixels, json[QString("heightPixels")]);
    m_height_pixels_isSet = !json[QString("heightPixels")].isNull() && m_height_pixels_isValid;

    m_hlg_isValid = ::OpenAPI::fromJsonValue(m_hlg, json[QString("hlg")]);
    m_hlg_isSet = !json[QString("hlg")].isNull() && m_hlg_isValid;

    m_pixel_format_isValid = ::OpenAPI::fromJsonValue(m_pixel_format, json[QString("pixelFormat")]);
    m_pixel_format_isSet = !json[QString("pixelFormat")].isNull() && m_pixel_format_isValid;

    m_preset_isValid = ::OpenAPI::fromJsonValue(m_preset, json[QString("preset")]);
    m_preset_isSet = !json[QString("preset")].isNull() && m_preset_isValid;

    m_profile_isValid = ::OpenAPI::fromJsonValue(m_profile, json[QString("profile")]);
    m_profile_isSet = !json[QString("profile")].isNull() && m_profile_isValid;

    m_rate_control_mode_isValid = ::OpenAPI::fromJsonValue(m_rate_control_mode, json[QString("rateControlMode")]);
    m_rate_control_mode_isSet = !json[QString("rateControlMode")].isNull() && m_rate_control_mode_isValid;

    m_sdr_isValid = ::OpenAPI::fromJsonValue(m_sdr, json[QString("sdr")]);
    m_sdr_isSet = !json[QString("sdr")].isNull() && m_sdr_isValid;

    m_tune_isValid = ::OpenAPI::fromJsonValue(m_tune, json[QString("tune")]);
    m_tune_isSet = !json[QString("tune")].isNull() && m_tune_isValid;

    m_vbv_fullness_bits_isValid = ::OpenAPI::fromJsonValue(m_vbv_fullness_bits, json[QString("vbvFullnessBits")]);
    m_vbv_fullness_bits_isSet = !json[QString("vbvFullnessBits")].isNull() && m_vbv_fullness_bits_isValid;

    m_vbv_size_bits_isValid = ::OpenAPI::fromJsonValue(m_vbv_size_bits, json[QString("vbvSizeBits")]);
    m_vbv_size_bits_isSet = !json[QString("vbvSizeBits")].isNull() && m_vbv_size_bits_isValid;

    m_width_pixels_isValid = ::OpenAPI::fromJsonValue(m_width_pixels, json[QString("widthPixels")]);
    m_width_pixels_isSet = !json[QString("widthPixels")].isNull() && m_width_pixels_isValid;
}

QString OAIH264CodecSettings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIH264CodecSettings::asJsonObject() const {
    QJsonObject obj;
    if (m_allow_open_gop_isSet) {
        obj.insert(QString("allowOpenGop"), ::OpenAPI::toJsonValue(m_allow_open_gop));
    }
    if (m_aq_strength_isSet) {
        obj.insert(QString("aqStrength"), ::OpenAPI::toJsonValue(m_aq_strength));
    }
    if (m_b_frame_count_isSet) {
        obj.insert(QString("bFrameCount"), ::OpenAPI::toJsonValue(m_b_frame_count));
    }
    if (m_b_pyramid_isSet) {
        obj.insert(QString("bPyramid"), ::OpenAPI::toJsonValue(m_b_pyramid));
    }
    if (m_bitrate_bps_isSet) {
        obj.insert(QString("bitrateBps"), ::OpenAPI::toJsonValue(m_bitrate_bps));
    }
    if (m_crf_level_isSet) {
        obj.insert(QString("crfLevel"), ::OpenAPI::toJsonValue(m_crf_level));
    }
    if (m_enable_two_pass_isSet) {
        obj.insert(QString("enableTwoPass"), ::OpenAPI::toJsonValue(m_enable_two_pass));
    }
    if (m_entropy_coder_isSet) {
        obj.insert(QString("entropyCoder"), ::OpenAPI::toJsonValue(m_entropy_coder));
    }
    if (m_frame_rate_isSet) {
        obj.insert(QString("frameRate"), ::OpenAPI::toJsonValue(m_frame_rate));
    }
    if (m_frame_rate_conversion_strategy_isSet) {
        obj.insert(QString("frameRateConversionStrategy"), ::OpenAPI::toJsonValue(m_frame_rate_conversion_strategy));
    }
    if (m_gop_duration_isSet) {
        obj.insert(QString("gopDuration"), ::OpenAPI::toJsonValue(m_gop_duration));
    }
    if (m_gop_frame_count_isSet) {
        obj.insert(QString("gopFrameCount"), ::OpenAPI::toJsonValue(m_gop_frame_count));
    }
    if (m_height_pixels_isSet) {
        obj.insert(QString("heightPixels"), ::OpenAPI::toJsonValue(m_height_pixels));
    }
    if (m_hlg_isSet) {
        obj.insert(QString("hlg"), ::OpenAPI::toJsonValue(m_hlg));
    }
    if (m_pixel_format_isSet) {
        obj.insert(QString("pixelFormat"), ::OpenAPI::toJsonValue(m_pixel_format));
    }
    if (m_preset_isSet) {
        obj.insert(QString("preset"), ::OpenAPI::toJsonValue(m_preset));
    }
    if (m_profile_isSet) {
        obj.insert(QString("profile"), ::OpenAPI::toJsonValue(m_profile));
    }
    if (m_rate_control_mode_isSet) {
        obj.insert(QString("rateControlMode"), ::OpenAPI::toJsonValue(m_rate_control_mode));
    }
    if (m_sdr_isSet) {
        obj.insert(QString("sdr"), ::OpenAPI::toJsonValue(m_sdr));
    }
    if (m_tune_isSet) {
        obj.insert(QString("tune"), ::OpenAPI::toJsonValue(m_tune));
    }
    if (m_vbv_fullness_bits_isSet) {
        obj.insert(QString("vbvFullnessBits"), ::OpenAPI::toJsonValue(m_vbv_fullness_bits));
    }
    if (m_vbv_size_bits_isSet) {
        obj.insert(QString("vbvSizeBits"), ::OpenAPI::toJsonValue(m_vbv_size_bits));
    }
    if (m_width_pixels_isSet) {
        obj.insert(QString("widthPixels"), ::OpenAPI::toJsonValue(m_width_pixels));
    }
    return obj;
}

bool OAIH264CodecSettings::isAllowOpenGop() const {
    return m_allow_open_gop;
}
void OAIH264CodecSettings::setAllowOpenGop(const bool &allow_open_gop) {
    m_allow_open_gop = allow_open_gop;
    m_allow_open_gop_isSet = true;
}

bool OAIH264CodecSettings::is_allow_open_gop_Set() const{
    return m_allow_open_gop_isSet;
}

bool OAIH264CodecSettings::is_allow_open_gop_Valid() const{
    return m_allow_open_gop_isValid;
}

double OAIH264CodecSettings::getAqStrength() const {
    return m_aq_strength;
}
void OAIH264CodecSettings::setAqStrength(const double &aq_strength) {
    m_aq_strength = aq_strength;
    m_aq_strength_isSet = true;
}

bool OAIH264CodecSettings::is_aq_strength_Set() const{
    return m_aq_strength_isSet;
}

bool OAIH264CodecSettings::is_aq_strength_Valid() const{
    return m_aq_strength_isValid;
}

qint32 OAIH264CodecSettings::getBFrameCount() const {
    return m_b_frame_count;
}
void OAIH264CodecSettings::setBFrameCount(const qint32 &b_frame_count) {
    m_b_frame_count = b_frame_count;
    m_b_frame_count_isSet = true;
}

bool OAIH264CodecSettings::is_b_frame_count_Set() const{
    return m_b_frame_count_isSet;
}

bool OAIH264CodecSettings::is_b_frame_count_Valid() const{
    return m_b_frame_count_isValid;
}

bool OAIH264CodecSettings::isBPyramid() const {
    return m_b_pyramid;
}
void OAIH264CodecSettings::setBPyramid(const bool &b_pyramid) {
    m_b_pyramid = b_pyramid;
    m_b_pyramid_isSet = true;
}

bool OAIH264CodecSettings::is_b_pyramid_Set() const{
    return m_b_pyramid_isSet;
}

bool OAIH264CodecSettings::is_b_pyramid_Valid() const{
    return m_b_pyramid_isValid;
}

qint32 OAIH264CodecSettings::getBitrateBps() const {
    return m_bitrate_bps;
}
void OAIH264CodecSettings::setBitrateBps(const qint32 &bitrate_bps) {
    m_bitrate_bps = bitrate_bps;
    m_bitrate_bps_isSet = true;
}

bool OAIH264CodecSettings::is_bitrate_bps_Set() const{
    return m_bitrate_bps_isSet;
}

bool OAIH264CodecSettings::is_bitrate_bps_Valid() const{
    return m_bitrate_bps_isValid;
}

qint32 OAIH264CodecSettings::getCrfLevel() const {
    return m_crf_level;
}
void OAIH264CodecSettings::setCrfLevel(const qint32 &crf_level) {
    m_crf_level = crf_level;
    m_crf_level_isSet = true;
}

bool OAIH264CodecSettings::is_crf_level_Set() const{
    return m_crf_level_isSet;
}

bool OAIH264CodecSettings::is_crf_level_Valid() const{
    return m_crf_level_isValid;
}

bool OAIH264CodecSettings::isEnableTwoPass() const {
    return m_enable_two_pass;
}
void OAIH264CodecSettings::setEnableTwoPass(const bool &enable_two_pass) {
    m_enable_two_pass = enable_two_pass;
    m_enable_two_pass_isSet = true;
}

bool OAIH264CodecSettings::is_enable_two_pass_Set() const{
    return m_enable_two_pass_isSet;
}

bool OAIH264CodecSettings::is_enable_two_pass_Valid() const{
    return m_enable_two_pass_isValid;
}

QString OAIH264CodecSettings::getEntropyCoder() const {
    return m_entropy_coder;
}
void OAIH264CodecSettings::setEntropyCoder(const QString &entropy_coder) {
    m_entropy_coder = entropy_coder;
    m_entropy_coder_isSet = true;
}

bool OAIH264CodecSettings::is_entropy_coder_Set() const{
    return m_entropy_coder_isSet;
}

bool OAIH264CodecSettings::is_entropy_coder_Valid() const{
    return m_entropy_coder_isValid;
}

double OAIH264CodecSettings::getFrameRate() const {
    return m_frame_rate;
}
void OAIH264CodecSettings::setFrameRate(const double &frame_rate) {
    m_frame_rate = frame_rate;
    m_frame_rate_isSet = true;
}

bool OAIH264CodecSettings::is_frame_rate_Set() const{
    return m_frame_rate_isSet;
}

bool OAIH264CodecSettings::is_frame_rate_Valid() const{
    return m_frame_rate_isValid;
}

QString OAIH264CodecSettings::getFrameRateConversionStrategy() const {
    return m_frame_rate_conversion_strategy;
}
void OAIH264CodecSettings::setFrameRateConversionStrategy(const QString &frame_rate_conversion_strategy) {
    m_frame_rate_conversion_strategy = frame_rate_conversion_strategy;
    m_frame_rate_conversion_strategy_isSet = true;
}

bool OAIH264CodecSettings::is_frame_rate_conversion_strategy_Set() const{
    return m_frame_rate_conversion_strategy_isSet;
}

bool OAIH264CodecSettings::is_frame_rate_conversion_strategy_Valid() const{
    return m_frame_rate_conversion_strategy_isValid;
}

QString OAIH264CodecSettings::getGopDuration() const {
    return m_gop_duration;
}
void OAIH264CodecSettings::setGopDuration(const QString &gop_duration) {
    m_gop_duration = gop_duration;
    m_gop_duration_isSet = true;
}

bool OAIH264CodecSettings::is_gop_duration_Set() const{
    return m_gop_duration_isSet;
}

bool OAIH264CodecSettings::is_gop_duration_Valid() const{
    return m_gop_duration_isValid;
}

qint32 OAIH264CodecSettings::getGopFrameCount() const {
    return m_gop_frame_count;
}
void OAIH264CodecSettings::setGopFrameCount(const qint32 &gop_frame_count) {
    m_gop_frame_count = gop_frame_count;
    m_gop_frame_count_isSet = true;
}

bool OAIH264CodecSettings::is_gop_frame_count_Set() const{
    return m_gop_frame_count_isSet;
}

bool OAIH264CodecSettings::is_gop_frame_count_Valid() const{
    return m_gop_frame_count_isValid;
}

qint32 OAIH264CodecSettings::getHeightPixels() const {
    return m_height_pixels;
}
void OAIH264CodecSettings::setHeightPixels(const qint32 &height_pixels) {
    m_height_pixels = height_pixels;
    m_height_pixels_isSet = true;
}

bool OAIH264CodecSettings::is_height_pixels_Set() const{
    return m_height_pixels_isSet;
}

bool OAIH264CodecSettings::is_height_pixels_Valid() const{
    return m_height_pixels_isValid;
}

OAIObject OAIH264CodecSettings::getHlg() const {
    return m_hlg;
}
void OAIH264CodecSettings::setHlg(const OAIObject &hlg) {
    m_hlg = hlg;
    m_hlg_isSet = true;
}

bool OAIH264CodecSettings::is_hlg_Set() const{
    return m_hlg_isSet;
}

bool OAIH264CodecSettings::is_hlg_Valid() const{
    return m_hlg_isValid;
}

QString OAIH264CodecSettings::getPixelFormat() const {
    return m_pixel_format;
}
void OAIH264CodecSettings::setPixelFormat(const QString &pixel_format) {
    m_pixel_format = pixel_format;
    m_pixel_format_isSet = true;
}

bool OAIH264CodecSettings::is_pixel_format_Set() const{
    return m_pixel_format_isSet;
}

bool OAIH264CodecSettings::is_pixel_format_Valid() const{
    return m_pixel_format_isValid;
}

QString OAIH264CodecSettings::getPreset() const {
    return m_preset;
}
void OAIH264CodecSettings::setPreset(const QString &preset) {
    m_preset = preset;
    m_preset_isSet = true;
}

bool OAIH264CodecSettings::is_preset_Set() const{
    return m_preset_isSet;
}

bool OAIH264CodecSettings::is_preset_Valid() const{
    return m_preset_isValid;
}

QString OAIH264CodecSettings::getProfile() const {
    return m_profile;
}
void OAIH264CodecSettings::setProfile(const QString &profile) {
    m_profile = profile;
    m_profile_isSet = true;
}

bool OAIH264CodecSettings::is_profile_Set() const{
    return m_profile_isSet;
}

bool OAIH264CodecSettings::is_profile_Valid() const{
    return m_profile_isValid;
}

QString OAIH264CodecSettings::getRateControlMode() const {
    return m_rate_control_mode;
}
void OAIH264CodecSettings::setRateControlMode(const QString &rate_control_mode) {
    m_rate_control_mode = rate_control_mode;
    m_rate_control_mode_isSet = true;
}

bool OAIH264CodecSettings::is_rate_control_mode_Set() const{
    return m_rate_control_mode_isSet;
}

bool OAIH264CodecSettings::is_rate_control_mode_Valid() const{
    return m_rate_control_mode_isValid;
}

OAIObject OAIH264CodecSettings::getSdr() const {
    return m_sdr;
}
void OAIH264CodecSettings::setSdr(const OAIObject &sdr) {
    m_sdr = sdr;
    m_sdr_isSet = true;
}

bool OAIH264CodecSettings::is_sdr_Set() const{
    return m_sdr_isSet;
}

bool OAIH264CodecSettings::is_sdr_Valid() const{
    return m_sdr_isValid;
}

QString OAIH264CodecSettings::getTune() const {
    return m_tune;
}
void OAIH264CodecSettings::setTune(const QString &tune) {
    m_tune = tune;
    m_tune_isSet = true;
}

bool OAIH264CodecSettings::is_tune_Set() const{
    return m_tune_isSet;
}

bool OAIH264CodecSettings::is_tune_Valid() const{
    return m_tune_isValid;
}

qint32 OAIH264CodecSettings::getVbvFullnessBits() const {
    return m_vbv_fullness_bits;
}
void OAIH264CodecSettings::setVbvFullnessBits(const qint32 &vbv_fullness_bits) {
    m_vbv_fullness_bits = vbv_fullness_bits;
    m_vbv_fullness_bits_isSet = true;
}

bool OAIH264CodecSettings::is_vbv_fullness_bits_Set() const{
    return m_vbv_fullness_bits_isSet;
}

bool OAIH264CodecSettings::is_vbv_fullness_bits_Valid() const{
    return m_vbv_fullness_bits_isValid;
}

qint32 OAIH264CodecSettings::getVbvSizeBits() const {
    return m_vbv_size_bits;
}
void OAIH264CodecSettings::setVbvSizeBits(const qint32 &vbv_size_bits) {
    m_vbv_size_bits = vbv_size_bits;
    m_vbv_size_bits_isSet = true;
}

bool OAIH264CodecSettings::is_vbv_size_bits_Set() const{
    return m_vbv_size_bits_isSet;
}

bool OAIH264CodecSettings::is_vbv_size_bits_Valid() const{
    return m_vbv_size_bits_isValid;
}

qint32 OAIH264CodecSettings::getWidthPixels() const {
    return m_width_pixels;
}
void OAIH264CodecSettings::setWidthPixels(const qint32 &width_pixels) {
    m_width_pixels = width_pixels;
    m_width_pixels_isSet = true;
}

bool OAIH264CodecSettings::is_width_pixels_Set() const{
    return m_width_pixels_isSet;
}

bool OAIH264CodecSettings::is_width_pixels_Valid() const{
    return m_width_pixels_isValid;
}

bool OAIH264CodecSettings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allow_open_gop_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aq_strength_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_b_frame_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_b_pyramid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bitrate_bps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_crf_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_two_pass_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entropy_coder_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_frame_rate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_frame_rate_conversion_strategy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_duration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_frame_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_height_pixels_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hlg_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pixel_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_profile_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rate_control_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sdr_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tune_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vbv_fullness_bits_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vbv_size_bits_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_width_pixels_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIH264CodecSettings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
