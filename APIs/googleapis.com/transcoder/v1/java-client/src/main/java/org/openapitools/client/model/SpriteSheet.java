/*
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Sprite sheet configuration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:32.039-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SpriteSheet {
  public static final String SERIALIZED_NAME_COLUMN_COUNT = "columnCount";
  @SerializedName(SERIALIZED_NAME_COLUMN_COUNT)
  private Integer columnCount;

  public static final String SERIALIZED_NAME_END_TIME_OFFSET = "endTimeOffset";
  @SerializedName(SERIALIZED_NAME_END_TIME_OFFSET)
  private String endTimeOffset;

  public static final String SERIALIZED_NAME_FILE_PREFIX = "filePrefix";
  @SerializedName(SERIALIZED_NAME_FILE_PREFIX)
  private String filePrefix;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private String format;

  public static final String SERIALIZED_NAME_INTERVAL = "interval";
  @SerializedName(SERIALIZED_NAME_INTERVAL)
  private String interval;

  public static final String SERIALIZED_NAME_QUALITY = "quality";
  @SerializedName(SERIALIZED_NAME_QUALITY)
  private Integer quality;

  public static final String SERIALIZED_NAME_ROW_COUNT = "rowCount";
  @SerializedName(SERIALIZED_NAME_ROW_COUNT)
  private Integer rowCount;

  public static final String SERIALIZED_NAME_SPRITE_HEIGHT_PIXELS = "spriteHeightPixels";
  @SerializedName(SERIALIZED_NAME_SPRITE_HEIGHT_PIXELS)
  private Integer spriteHeightPixels;

  public static final String SERIALIZED_NAME_SPRITE_WIDTH_PIXELS = "spriteWidthPixels";
  @SerializedName(SERIALIZED_NAME_SPRITE_WIDTH_PIXELS)
  private Integer spriteWidthPixels;

  public static final String SERIALIZED_NAME_START_TIME_OFFSET = "startTimeOffset";
  @SerializedName(SERIALIZED_NAME_START_TIME_OFFSET)
  private String startTimeOffset;

  public static final String SERIALIZED_NAME_TOTAL_COUNT = "totalCount";
  @SerializedName(SERIALIZED_NAME_TOTAL_COUNT)
  private Integer totalCount;

  public SpriteSheet() {
  }

  public SpriteSheet columnCount(Integer columnCount) {
    this.columnCount = columnCount;
    return this;
  }

  /**
   * The maximum number of sprites per row in a sprite sheet. The default is 0, which indicates no maximum limit.
   * @return columnCount
   */
  @javax.annotation.Nullable
  public Integer getColumnCount() {
    return columnCount;
  }

  public void setColumnCount(Integer columnCount) {
    this.columnCount = columnCount;
  }


  public SpriteSheet endTimeOffset(String endTimeOffset) {
    this.endTimeOffset = endTimeOffset;
    return this;
  }

  /**
   * End time in seconds, relative to the output file timeline. When &#x60;end_time_offset&#x60; is not specified, the sprites are generated until the end of the output file.
   * @return endTimeOffset
   */
  @javax.annotation.Nullable
  public String getEndTimeOffset() {
    return endTimeOffset;
  }

  public void setEndTimeOffset(String endTimeOffset) {
    this.endTimeOffset = endTimeOffset;
  }


  public SpriteSheet filePrefix(String filePrefix) {
    this.filePrefix = filePrefix;
    return this;
  }

  /**
   * Required. File name prefix for the generated sprite sheets. Each sprite sheet has an incremental 10-digit zero-padded suffix starting from 0 before the extension, such as &#x60;sprite_sheet0000000123.jpeg&#x60;.
   * @return filePrefix
   */
  @javax.annotation.Nullable
  public String getFilePrefix() {
    return filePrefix;
  }

  public void setFilePrefix(String filePrefix) {
    this.filePrefix = filePrefix;
  }


  public SpriteSheet format(String format) {
    this.format = format;
    return this;
  }

  /**
   * Format type. The default is &#x60;jpeg&#x60;. Supported formats: - &#x60;jpeg&#x60;
   * @return format
   */
  @javax.annotation.Nullable
  public String getFormat() {
    return format;
  }

  public void setFormat(String format) {
    this.format = format;
  }


  public SpriteSheet interval(String interval) {
    this.interval = interval;
    return this;
  }

  /**
   * Starting from &#x60;0s&#x60;, create sprites at regular intervals. Specify the interval value in seconds.
   * @return interval
   */
  @javax.annotation.Nullable
  public String getInterval() {
    return interval;
  }

  public void setInterval(String interval) {
    this.interval = interval;
  }


  public SpriteSheet quality(Integer quality) {
    this.quality = quality;
    return this;
  }

  /**
   * The quality of the generated sprite sheet. Enter a value between 1 and 100, where 1 is the lowest quality and 100 is the highest quality. The default is 100. A high quality value corresponds to a low image data compression ratio.
   * @return quality
   */
  @javax.annotation.Nullable
  public Integer getQuality() {
    return quality;
  }

  public void setQuality(Integer quality) {
    this.quality = quality;
  }


  public SpriteSheet rowCount(Integer rowCount) {
    this.rowCount = rowCount;
    return this;
  }

  /**
   * The maximum number of rows per sprite sheet. When the sprite sheet is full, a new sprite sheet is created. The default is 0, which indicates no maximum limit.
   * @return rowCount
   */
  @javax.annotation.Nullable
  public Integer getRowCount() {
    return rowCount;
  }

  public void setRowCount(Integer rowCount) {
    this.rowCount = rowCount;
  }


  public SpriteSheet spriteHeightPixels(Integer spriteHeightPixels) {
    this.spriteHeightPixels = spriteHeightPixels;
    return this;
  }

  /**
   * Required. The height of sprite in pixels. Must be an even integer. To preserve the source aspect ratio, set the SpriteSheet.sprite_height_pixels field or the SpriteSheet.sprite_width_pixels field, but not both (the API will automatically calculate the missing field). For portrait videos that contain horizontal ASR and rotation metadata, provide the height, in pixels, per the horizontal ASR. The API calculates the width per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return spriteHeightPixels
   */
  @javax.annotation.Nullable
  public Integer getSpriteHeightPixels() {
    return spriteHeightPixels;
  }

  public void setSpriteHeightPixels(Integer spriteHeightPixels) {
    this.spriteHeightPixels = spriteHeightPixels;
  }


  public SpriteSheet spriteWidthPixels(Integer spriteWidthPixels) {
    this.spriteWidthPixels = spriteWidthPixels;
    return this;
  }

  /**
   * Required. The width of sprite in pixels. Must be an even integer. To preserve the source aspect ratio, set the SpriteSheet.sprite_width_pixels field or the SpriteSheet.sprite_height_pixels field, but not both (the API will automatically calculate the missing field). For portrait videos that contain horizontal ASR and rotation metadata, provide the width, in pixels, per the horizontal ASR. The API calculates the height per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return spriteWidthPixels
   */
  @javax.annotation.Nullable
  public Integer getSpriteWidthPixels() {
    return spriteWidthPixels;
  }

  public void setSpriteWidthPixels(Integer spriteWidthPixels) {
    this.spriteWidthPixels = spriteWidthPixels;
  }


  public SpriteSheet startTimeOffset(String startTimeOffset) {
    this.startTimeOffset = startTimeOffset;
    return this;
  }

  /**
   * Start time in seconds, relative to the output file timeline. Determines the first sprite to pick. The default is &#x60;0s&#x60;.
   * @return startTimeOffset
   */
  @javax.annotation.Nullable
  public String getStartTimeOffset() {
    return startTimeOffset;
  }

  public void setStartTimeOffset(String startTimeOffset) {
    this.startTimeOffset = startTimeOffset;
  }


  public SpriteSheet totalCount(Integer totalCount) {
    this.totalCount = totalCount;
    return this;
  }

  /**
   * Total number of sprites. Create the specified number of sprites distributed evenly across the timeline of the output media. The default is 100.
   * @return totalCount
   */
  @javax.annotation.Nullable
  public Integer getTotalCount() {
    return totalCount;
  }

  public void setTotalCount(Integer totalCount) {
    this.totalCount = totalCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SpriteSheet spriteSheet = (SpriteSheet) o;
    return Objects.equals(this.columnCount, spriteSheet.columnCount) &&
        Objects.equals(this.endTimeOffset, spriteSheet.endTimeOffset) &&
        Objects.equals(this.filePrefix, spriteSheet.filePrefix) &&
        Objects.equals(this.format, spriteSheet.format) &&
        Objects.equals(this.interval, spriteSheet.interval) &&
        Objects.equals(this.quality, spriteSheet.quality) &&
        Objects.equals(this.rowCount, spriteSheet.rowCount) &&
        Objects.equals(this.spriteHeightPixels, spriteSheet.spriteHeightPixels) &&
        Objects.equals(this.spriteWidthPixels, spriteSheet.spriteWidthPixels) &&
        Objects.equals(this.startTimeOffset, spriteSheet.startTimeOffset) &&
        Objects.equals(this.totalCount, spriteSheet.totalCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columnCount, endTimeOffset, filePrefix, format, interval, quality, rowCount, spriteHeightPixels, spriteWidthPixels, startTimeOffset, totalCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SpriteSheet {\n");
    sb.append("    columnCount: ").append(toIndentedString(columnCount)).append("\n");
    sb.append("    endTimeOffset: ").append(toIndentedString(endTimeOffset)).append("\n");
    sb.append("    filePrefix: ").append(toIndentedString(filePrefix)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    quality: ").append(toIndentedString(quality)).append("\n");
    sb.append("    rowCount: ").append(toIndentedString(rowCount)).append("\n");
    sb.append("    spriteHeightPixels: ").append(toIndentedString(spriteHeightPixels)).append("\n");
    sb.append("    spriteWidthPixels: ").append(toIndentedString(spriteWidthPixels)).append("\n");
    sb.append("    startTimeOffset: ").append(toIndentedString(startTimeOffset)).append("\n");
    sb.append("    totalCount: ").append(toIndentedString(totalCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("columnCount");
    openapiFields.add("endTimeOffset");
    openapiFields.add("filePrefix");
    openapiFields.add("format");
    openapiFields.add("interval");
    openapiFields.add("quality");
    openapiFields.add("rowCount");
    openapiFields.add("spriteHeightPixels");
    openapiFields.add("spriteWidthPixels");
    openapiFields.add("startTimeOffset");
    openapiFields.add("totalCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SpriteSheet
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SpriteSheet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SpriteSheet is not found in the empty JSON string", SpriteSheet.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SpriteSheet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SpriteSheet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("endTimeOffset") != null && !jsonObj.get("endTimeOffset").isJsonNull()) && !jsonObj.get("endTimeOffset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endTimeOffset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endTimeOffset").toString()));
      }
      if ((jsonObj.get("filePrefix") != null && !jsonObj.get("filePrefix").isJsonNull()) && !jsonObj.get("filePrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filePrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filePrefix").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      if ((jsonObj.get("interval") != null && !jsonObj.get("interval").isJsonNull()) && !jsonObj.get("interval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interval").toString()));
      }
      if ((jsonObj.get("startTimeOffset") != null && !jsonObj.get("startTimeOffset").isJsonNull()) && !jsonObj.get("startTimeOffset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTimeOffset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTimeOffset").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SpriteSheet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SpriteSheet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SpriteSheet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SpriteSheet.class));

       return (TypeAdapter<T>) new TypeAdapter<SpriteSheet>() {
           @Override
           public void write(JsonWriter out, SpriteSheet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SpriteSheet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SpriteSheet given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SpriteSheet
   * @throws IOException if the JSON string is invalid with respect to SpriteSheet
   */
  public static SpriteSheet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SpriteSheet.class);
  }

  /**
   * Convert an instance of SpriteSheet to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

