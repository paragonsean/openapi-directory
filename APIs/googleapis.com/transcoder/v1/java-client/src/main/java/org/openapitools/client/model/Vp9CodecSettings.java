/*
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * VP9 codec settings.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:32.039-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Vp9CodecSettings {
  public static final String SERIALIZED_NAME_BITRATE_BPS = "bitrateBps";
  @SerializedName(SERIALIZED_NAME_BITRATE_BPS)
  private Integer bitrateBps;

  public static final String SERIALIZED_NAME_CRF_LEVEL = "crfLevel";
  @SerializedName(SERIALIZED_NAME_CRF_LEVEL)
  private Integer crfLevel;

  public static final String SERIALIZED_NAME_FRAME_RATE = "frameRate";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE)
  private Double frameRate;

  /**
   * Optional. Frame rate conversion strategy for desired frame rate. The default is &#x60;DOWNSAMPLE&#x60;.
   */
  @JsonAdapter(FrameRateConversionStrategyEnum.Adapter.class)
  public enum FrameRateConversionStrategyEnum {
    FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED("FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"),
    
    DOWNSAMPLE("DOWNSAMPLE"),
    
    DROP_DUPLICATE("DROP_DUPLICATE");

    private String value;

    FrameRateConversionStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FrameRateConversionStrategyEnum fromValue(String value) {
      for (FrameRateConversionStrategyEnum b : FrameRateConversionStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FrameRateConversionStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FrameRateConversionStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FrameRateConversionStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FrameRateConversionStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FrameRateConversionStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FRAME_RATE_CONVERSION_STRATEGY = "frameRateConversionStrategy";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE_CONVERSION_STRATEGY)
  private FrameRateConversionStrategyEnum frameRateConversionStrategy;

  public static final String SERIALIZED_NAME_GOP_DURATION = "gopDuration";
  @SerializedName(SERIALIZED_NAME_GOP_DURATION)
  private String gopDuration;

  public static final String SERIALIZED_NAME_GOP_FRAME_COUNT = "gopFrameCount";
  @SerializedName(SERIALIZED_NAME_GOP_FRAME_COUNT)
  private Integer gopFrameCount;

  public static final String SERIALIZED_NAME_HEIGHT_PIXELS = "heightPixels";
  @SerializedName(SERIALIZED_NAME_HEIGHT_PIXELS)
  private Integer heightPixels;

  public static final String SERIALIZED_NAME_HLG = "hlg";
  @SerializedName(SERIALIZED_NAME_HLG)
  private Object hlg;

  public static final String SERIALIZED_NAME_PIXEL_FORMAT = "pixelFormat";
  @SerializedName(SERIALIZED_NAME_PIXEL_FORMAT)
  private String pixelFormat;

  public static final String SERIALIZED_NAME_PROFILE = "profile";
  @SerializedName(SERIALIZED_NAME_PROFILE)
  private String profile;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "rateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private String rateControlMode;

  public static final String SERIALIZED_NAME_SDR = "sdr";
  @SerializedName(SERIALIZED_NAME_SDR)
  private Object sdr;

  public static final String SERIALIZED_NAME_WIDTH_PIXELS = "widthPixels";
  @SerializedName(SERIALIZED_NAME_WIDTH_PIXELS)
  private Integer widthPixels;

  public Vp9CodecSettings() {
  }

  public Vp9CodecSettings bitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
    return this;
  }

  /**
   * Required. The video bitrate in bits per second. The minimum value is 1,000. The maximum value is 480,000,000.
   * @return bitrateBps
   */
  @javax.annotation.Nullable
  public Integer getBitrateBps() {
    return bitrateBps;
  }

  public void setBitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
  }


  public Vp9CodecSettings crfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
    return this;
  }

  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest quality and 36 is the most efficient compression. The default is 21. **Note:** This field is not supported.
   * @return crfLevel
   */
  @javax.annotation.Nullable
  public Integer getCrfLevel() {
    return crfLevel;
  }

  public void setCrfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
  }


  public Vp9CodecSettings frameRate(Double frameRate) {
    this.frameRate = frameRate;
    return this;
  }

  /**
   * Required. The target video frame rate in frames per second (FPS). Must be less than or equal to 120.
   * @return frameRate
   */
  @javax.annotation.Nullable
  public Double getFrameRate() {
    return frameRate;
  }

  public void setFrameRate(Double frameRate) {
    this.frameRate = frameRate;
  }


  public Vp9CodecSettings frameRateConversionStrategy(FrameRateConversionStrategyEnum frameRateConversionStrategy) {
    this.frameRateConversionStrategy = frameRateConversionStrategy;
    return this;
  }

  /**
   * Optional. Frame rate conversion strategy for desired frame rate. The default is &#x60;DOWNSAMPLE&#x60;.
   * @return frameRateConversionStrategy
   */
  @javax.annotation.Nullable
  public FrameRateConversionStrategyEnum getFrameRateConversionStrategy() {
    return frameRateConversionStrategy;
  }

  public void setFrameRateConversionStrategy(FrameRateConversionStrategyEnum frameRateConversionStrategy) {
    this.frameRateConversionStrategy = frameRateConversionStrategy;
  }


  public Vp9CodecSettings gopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
    return this;
  }

  /**
   * Select the GOP size based on the specified duration. The default is &#x60;3s&#x60;. Note that &#x60;gopDuration&#x60; must be less than or equal to [&#x60;segmentDuration&#x60;](#SegmentSettings), and [&#x60;segmentDuration&#x60;](#SegmentSettings) must be divisible by &#x60;gopDuration&#x60;.
   * @return gopDuration
   */
  @javax.annotation.Nullable
  public String getGopDuration() {
    return gopDuration;
  }

  public void setGopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
  }


  public Vp9CodecSettings gopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
    return this;
  }

  /**
   * Select the GOP size based on the specified frame count. Must be greater than zero.
   * @return gopFrameCount
   */
  @javax.annotation.Nullable
  public Integer getGopFrameCount() {
    return gopFrameCount;
  }

  public void setGopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
  }


  public Vp9CodecSettings heightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
    return this;
  }

  /**
   * The height of the video in pixels. Must be an even integer. When not specified, the height is adjusted to match the specified width and input aspect ratio. If both are omitted, the input height is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the height, in pixels, per the horizontal ASR. The API calculates the width per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return heightPixels
   */
  @javax.annotation.Nullable
  public Integer getHeightPixels() {
    return heightPixels;
  }

  public void setHeightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
  }


  public Vp9CodecSettings hlg(Object hlg) {
    this.hlg = hlg;
    return this;
  }

  /**
   * Convert the input video to a Hybrid Log Gamma (HLG) video.
   * @return hlg
   */
  @javax.annotation.Nullable
  public Object getHlg() {
    return hlg;
  }

  public void setHlg(Object hlg) {
    this.hlg = hlg;
  }


  public Vp9CodecSettings pixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
    return this;
  }

  /**
   * Pixel format to use. The default is &#x60;yuv420p&#x60;. Supported pixel formats: - &#x60;yuv420p&#x60; pixel format - &#x60;yuv422p&#x60; pixel format - &#x60;yuv444p&#x60; pixel format - &#x60;yuv420p10&#x60; 10-bit HDR pixel format - &#x60;yuv422p10&#x60; 10-bit HDR pixel format - &#x60;yuv444p10&#x60; 10-bit HDR pixel format - &#x60;yuv420p12&#x60; 12-bit HDR pixel format - &#x60;yuv422p12&#x60; 12-bit HDR pixel format - &#x60;yuv444p12&#x60; 12-bit HDR pixel format
   * @return pixelFormat
   */
  @javax.annotation.Nullable
  public String getPixelFormat() {
    return pixelFormat;
  }

  public void setPixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
  }


  public Vp9CodecSettings profile(String profile) {
    this.profile = profile;
    return this;
  }

  /**
   * Enforces the specified codec profile. The following profiles are supported: * &#x60;profile0&#x60; (default) * &#x60;profile1&#x60; * &#x60;profile2&#x60; * &#x60;profile3&#x60; The available options are [WebM-compatible](https://www.webmproject.org/vp9/profiles/). Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;Vp9CodecSettings&#x60; message.
   * @return profile
   */
  @javax.annotation.Nullable
  public String getProfile() {
    return profile;
  }

  public void setProfile(String profile) {
    this.profile = profile;
  }


  public Vp9CodecSettings rateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Specify the mode. The default is &#x60;vbr&#x60;. Supported rate control modes: - &#x60;vbr&#x60; - variable bitrate
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public String getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public Vp9CodecSettings sdr(Object sdr) {
    this.sdr = sdr;
    return this;
  }

  /**
   * Convert the input video to a Standard Dynamic Range (SDR) video.
   * @return sdr
   */
  @javax.annotation.Nullable
  public Object getSdr() {
    return sdr;
  }

  public void setSdr(Object sdr) {
    this.sdr = sdr;
  }


  public Vp9CodecSettings widthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
    return this;
  }

  /**
   * The width of the video in pixels. Must be an even integer. When not specified, the width is adjusted to match the specified height and input aspect ratio. If both are omitted, the input width is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the width, in pixels, per the horizontal ASR. The API calculates the height per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return widthPixels
   */
  @javax.annotation.Nullable
  public Integer getWidthPixels() {
    return widthPixels;
  }

  public void setWidthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Vp9CodecSettings vp9CodecSettings = (Vp9CodecSettings) o;
    return Objects.equals(this.bitrateBps, vp9CodecSettings.bitrateBps) &&
        Objects.equals(this.crfLevel, vp9CodecSettings.crfLevel) &&
        Objects.equals(this.frameRate, vp9CodecSettings.frameRate) &&
        Objects.equals(this.frameRateConversionStrategy, vp9CodecSettings.frameRateConversionStrategy) &&
        Objects.equals(this.gopDuration, vp9CodecSettings.gopDuration) &&
        Objects.equals(this.gopFrameCount, vp9CodecSettings.gopFrameCount) &&
        Objects.equals(this.heightPixels, vp9CodecSettings.heightPixels) &&
        Objects.equals(this.hlg, vp9CodecSettings.hlg) &&
        Objects.equals(this.pixelFormat, vp9CodecSettings.pixelFormat) &&
        Objects.equals(this.profile, vp9CodecSettings.profile) &&
        Objects.equals(this.rateControlMode, vp9CodecSettings.rateControlMode) &&
        Objects.equals(this.sdr, vp9CodecSettings.sdr) &&
        Objects.equals(this.widthPixels, vp9CodecSettings.widthPixels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bitrateBps, crfLevel, frameRate, frameRateConversionStrategy, gopDuration, gopFrameCount, heightPixels, hlg, pixelFormat, profile, rateControlMode, sdr, widthPixels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Vp9CodecSettings {\n");
    sb.append("    bitrateBps: ").append(toIndentedString(bitrateBps)).append("\n");
    sb.append("    crfLevel: ").append(toIndentedString(crfLevel)).append("\n");
    sb.append("    frameRate: ").append(toIndentedString(frameRate)).append("\n");
    sb.append("    frameRateConversionStrategy: ").append(toIndentedString(frameRateConversionStrategy)).append("\n");
    sb.append("    gopDuration: ").append(toIndentedString(gopDuration)).append("\n");
    sb.append("    gopFrameCount: ").append(toIndentedString(gopFrameCount)).append("\n");
    sb.append("    heightPixels: ").append(toIndentedString(heightPixels)).append("\n");
    sb.append("    hlg: ").append(toIndentedString(hlg)).append("\n");
    sb.append("    pixelFormat: ").append(toIndentedString(pixelFormat)).append("\n");
    sb.append("    profile: ").append(toIndentedString(profile)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    sdr: ").append(toIndentedString(sdr)).append("\n");
    sb.append("    widthPixels: ").append(toIndentedString(widthPixels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bitrateBps");
    openapiFields.add("crfLevel");
    openapiFields.add("frameRate");
    openapiFields.add("frameRateConversionStrategy");
    openapiFields.add("gopDuration");
    openapiFields.add("gopFrameCount");
    openapiFields.add("heightPixels");
    openapiFields.add("hlg");
    openapiFields.add("pixelFormat");
    openapiFields.add("profile");
    openapiFields.add("rateControlMode");
    openapiFields.add("sdr");
    openapiFields.add("widthPixels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Vp9CodecSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Vp9CodecSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Vp9CodecSettings is not found in the empty JSON string", Vp9CodecSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Vp9CodecSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Vp9CodecSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("frameRateConversionStrategy") != null && !jsonObj.get("frameRateConversionStrategy").isJsonNull()) && !jsonObj.get("frameRateConversionStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frameRateConversionStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frameRateConversionStrategy").toString()));
      }
      // validate the optional field `frameRateConversionStrategy`
      if (jsonObj.get("frameRateConversionStrategy") != null && !jsonObj.get("frameRateConversionStrategy").isJsonNull()) {
        FrameRateConversionStrategyEnum.validateJsonElement(jsonObj.get("frameRateConversionStrategy"));
      }
      if ((jsonObj.get("gopDuration") != null && !jsonObj.get("gopDuration").isJsonNull()) && !jsonObj.get("gopDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gopDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gopDuration").toString()));
      }
      if ((jsonObj.get("pixelFormat") != null && !jsonObj.get("pixelFormat").isJsonNull()) && !jsonObj.get("pixelFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pixelFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pixelFormat").toString()));
      }
      if ((jsonObj.get("profile") != null && !jsonObj.get("profile").isJsonNull()) && !jsonObj.get("profile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profile").toString()));
      }
      if ((jsonObj.get("rateControlMode") != null && !jsonObj.get("rateControlMode").isJsonNull()) && !jsonObj.get("rateControlMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rateControlMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rateControlMode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Vp9CodecSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Vp9CodecSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Vp9CodecSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Vp9CodecSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<Vp9CodecSettings>() {
           @Override
           public void write(JsonWriter out, Vp9CodecSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Vp9CodecSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Vp9CodecSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Vp9CodecSettings
   * @throws IOException if the JSON string is invalid with respect to Vp9CodecSettings
   */
  public static Vp9CodecSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Vp9CodecSettings.class);
  }

  /**
   * Convert an instance of Vp9CodecSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

