/*
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * H265 codec settings.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:32.039-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class H265CodecSettings {
  public static final String SERIALIZED_NAME_ALLOW_OPEN_GOP = "allowOpenGop";
  @SerializedName(SERIALIZED_NAME_ALLOW_OPEN_GOP)
  private Boolean allowOpenGop;

  public static final String SERIALIZED_NAME_AQ_STRENGTH = "aqStrength";
  @SerializedName(SERIALIZED_NAME_AQ_STRENGTH)
  private Double aqStrength;

  public static final String SERIALIZED_NAME_B_FRAME_COUNT = "bFrameCount";
  @SerializedName(SERIALIZED_NAME_B_FRAME_COUNT)
  private Integer bFrameCount;

  public static final String SERIALIZED_NAME_B_PYRAMID = "bPyramid";
  @SerializedName(SERIALIZED_NAME_B_PYRAMID)
  private Boolean bPyramid;

  public static final String SERIALIZED_NAME_BITRATE_BPS = "bitrateBps";
  @SerializedName(SERIALIZED_NAME_BITRATE_BPS)
  private Integer bitrateBps;

  public static final String SERIALIZED_NAME_CRF_LEVEL = "crfLevel";
  @SerializedName(SERIALIZED_NAME_CRF_LEVEL)
  private Integer crfLevel;

  public static final String SERIALIZED_NAME_ENABLE_TWO_PASS = "enableTwoPass";
  @SerializedName(SERIALIZED_NAME_ENABLE_TWO_PASS)
  private Boolean enableTwoPass;

  public static final String SERIALIZED_NAME_FRAME_RATE = "frameRate";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE)
  private Double frameRate;

  /**
   * Optional. Frame rate conversion strategy for desired frame rate. The default is &#x60;DOWNSAMPLE&#x60;.
   */
  @JsonAdapter(FrameRateConversionStrategyEnum.Adapter.class)
  public enum FrameRateConversionStrategyEnum {
    FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED("FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"),
    
    DOWNSAMPLE("DOWNSAMPLE"),
    
    DROP_DUPLICATE("DROP_DUPLICATE");

    private String value;

    FrameRateConversionStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FrameRateConversionStrategyEnum fromValue(String value) {
      for (FrameRateConversionStrategyEnum b : FrameRateConversionStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FrameRateConversionStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FrameRateConversionStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FrameRateConversionStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FrameRateConversionStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FrameRateConversionStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FRAME_RATE_CONVERSION_STRATEGY = "frameRateConversionStrategy";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE_CONVERSION_STRATEGY)
  private FrameRateConversionStrategyEnum frameRateConversionStrategy;

  public static final String SERIALIZED_NAME_GOP_DURATION = "gopDuration";
  @SerializedName(SERIALIZED_NAME_GOP_DURATION)
  private String gopDuration;

  public static final String SERIALIZED_NAME_GOP_FRAME_COUNT = "gopFrameCount";
  @SerializedName(SERIALIZED_NAME_GOP_FRAME_COUNT)
  private Integer gopFrameCount;

  public static final String SERIALIZED_NAME_HDR10 = "hdr10";
  @SerializedName(SERIALIZED_NAME_HDR10)
  private Object hdr10;

  public static final String SERIALIZED_NAME_HEIGHT_PIXELS = "heightPixels";
  @SerializedName(SERIALIZED_NAME_HEIGHT_PIXELS)
  private Integer heightPixels;

  public static final String SERIALIZED_NAME_HLG = "hlg";
  @SerializedName(SERIALIZED_NAME_HLG)
  private Object hlg;

  public static final String SERIALIZED_NAME_PIXEL_FORMAT = "pixelFormat";
  @SerializedName(SERIALIZED_NAME_PIXEL_FORMAT)
  private String pixelFormat;

  public static final String SERIALIZED_NAME_PRESET = "preset";
  @SerializedName(SERIALIZED_NAME_PRESET)
  private String preset;

  public static final String SERIALIZED_NAME_PROFILE = "profile";
  @SerializedName(SERIALIZED_NAME_PROFILE)
  private String profile;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "rateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private String rateControlMode;

  public static final String SERIALIZED_NAME_SDR = "sdr";
  @SerializedName(SERIALIZED_NAME_SDR)
  private Object sdr;

  public static final String SERIALIZED_NAME_TUNE = "tune";
  @SerializedName(SERIALIZED_NAME_TUNE)
  private String tune;

  public static final String SERIALIZED_NAME_VBV_FULLNESS_BITS = "vbvFullnessBits";
  @SerializedName(SERIALIZED_NAME_VBV_FULLNESS_BITS)
  private Integer vbvFullnessBits;

  public static final String SERIALIZED_NAME_VBV_SIZE_BITS = "vbvSizeBits";
  @SerializedName(SERIALIZED_NAME_VBV_SIZE_BITS)
  private Integer vbvSizeBits;

  public static final String SERIALIZED_NAME_WIDTH_PIXELS = "widthPixels";
  @SerializedName(SERIALIZED_NAME_WIDTH_PIXELS)
  private Integer widthPixels;

  public H265CodecSettings() {
  }

  public H265CodecSettings allowOpenGop(Boolean allowOpenGop) {
    this.allowOpenGop = allowOpenGop;
    return this;
  }

  /**
   * Specifies whether an open Group of Pictures (GOP) structure should be allowed or not. The default is &#x60;false&#x60;.
   * @return allowOpenGop
   */
  @javax.annotation.Nullable
  public Boolean getAllowOpenGop() {
    return allowOpenGop;
  }

  public void setAllowOpenGop(Boolean allowOpenGop) {
    this.allowOpenGop = allowOpenGop;
  }


  public H265CodecSettings aqStrength(Double aqStrength) {
    this.aqStrength = aqStrength;
    return this;
  }

  /**
   * Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher value equals a lower bitrate but smoother image. The default is 0.
   * @return aqStrength
   */
  @javax.annotation.Nullable
  public Double getAqStrength() {
    return aqStrength;
  }

  public void setAqStrength(Double aqStrength) {
    this.aqStrength = aqStrength;
  }


  public H265CodecSettings bFrameCount(Integer bFrameCount) {
    this.bFrameCount = bFrameCount;
    return this;
  }

  /**
   * The number of consecutive B-frames. Must be greater than or equal to zero. Must be less than H265CodecSettings.gop_frame_count if set. The default is 0.
   * @return bFrameCount
   */
  @javax.annotation.Nullable
  public Integer getbFrameCount() {
    return bFrameCount;
  }

  public void setbFrameCount(Integer bFrameCount) {
    this.bFrameCount = bFrameCount;
  }


  public H265CodecSettings bPyramid(Boolean bPyramid) {
    this.bPyramid = bPyramid;
    return this;
  }

  /**
   * Allow B-pyramid for reference frame selection. This may not be supported on all decoders. The default is &#x60;false&#x60;.
   * @return bPyramid
   */
  @javax.annotation.Nullable
  public Boolean getbPyramid() {
    return bPyramid;
  }

  public void setbPyramid(Boolean bPyramid) {
    this.bPyramid = bPyramid;
  }


  public H265CodecSettings bitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
    return this;
  }

  /**
   * Required. The video bitrate in bits per second. The minimum value is 1,000. The maximum value is 800,000,000.
   * @return bitrateBps
   */
  @javax.annotation.Nullable
  public Integer getBitrateBps() {
    return bitrateBps;
  }

  public void setBitrateBps(Integer bitrateBps) {
    this.bitrateBps = bitrateBps;
  }


  public H265CodecSettings crfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
    return this;
  }

  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest quality and 36 is the most efficient compression. The default is 21.
   * @return crfLevel
   */
  @javax.annotation.Nullable
  public Integer getCrfLevel() {
    return crfLevel;
  }

  public void setCrfLevel(Integer crfLevel) {
    this.crfLevel = crfLevel;
  }


  public H265CodecSettings enableTwoPass(Boolean enableTwoPass) {
    this.enableTwoPass = enableTwoPass;
    return this;
  }

  /**
   * Use two-pass encoding strategy to achieve better video quality. H265CodecSettings.rate_control_mode must be &#x60;vbr&#x60;. The default is &#x60;false&#x60;.
   * @return enableTwoPass
   */
  @javax.annotation.Nullable
  public Boolean getEnableTwoPass() {
    return enableTwoPass;
  }

  public void setEnableTwoPass(Boolean enableTwoPass) {
    this.enableTwoPass = enableTwoPass;
  }


  public H265CodecSettings frameRate(Double frameRate) {
    this.frameRate = frameRate;
    return this;
  }

  /**
   * Required. The target video frame rate in frames per second (FPS). Must be less than or equal to 120.
   * @return frameRate
   */
  @javax.annotation.Nullable
  public Double getFrameRate() {
    return frameRate;
  }

  public void setFrameRate(Double frameRate) {
    this.frameRate = frameRate;
  }


  public H265CodecSettings frameRateConversionStrategy(FrameRateConversionStrategyEnum frameRateConversionStrategy) {
    this.frameRateConversionStrategy = frameRateConversionStrategy;
    return this;
  }

  /**
   * Optional. Frame rate conversion strategy for desired frame rate. The default is &#x60;DOWNSAMPLE&#x60;.
   * @return frameRateConversionStrategy
   */
  @javax.annotation.Nullable
  public FrameRateConversionStrategyEnum getFrameRateConversionStrategy() {
    return frameRateConversionStrategy;
  }

  public void setFrameRateConversionStrategy(FrameRateConversionStrategyEnum frameRateConversionStrategy) {
    this.frameRateConversionStrategy = frameRateConversionStrategy;
  }


  public H265CodecSettings gopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
    return this;
  }

  /**
   * Select the GOP size based on the specified duration. The default is &#x60;3s&#x60;. Note that &#x60;gopDuration&#x60; must be less than or equal to [&#x60;segmentDuration&#x60;](#SegmentSettings), and [&#x60;segmentDuration&#x60;](#SegmentSettings) must be divisible by &#x60;gopDuration&#x60;.
   * @return gopDuration
   */
  @javax.annotation.Nullable
  public String getGopDuration() {
    return gopDuration;
  }

  public void setGopDuration(String gopDuration) {
    this.gopDuration = gopDuration;
  }


  public H265CodecSettings gopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
    return this;
  }

  /**
   * Select the GOP size based on the specified frame count. Must be greater than zero.
   * @return gopFrameCount
   */
  @javax.annotation.Nullable
  public Integer getGopFrameCount() {
    return gopFrameCount;
  }

  public void setGopFrameCount(Integer gopFrameCount) {
    this.gopFrameCount = gopFrameCount;
  }


  public H265CodecSettings hdr10(Object hdr10) {
    this.hdr10 = hdr10;
    return this;
  }

  /**
   * Convert the input video to a High Dynamic Range 10 (HDR10) video.
   * @return hdr10
   */
  @javax.annotation.Nullable
  public Object getHdr10() {
    return hdr10;
  }

  public void setHdr10(Object hdr10) {
    this.hdr10 = hdr10;
  }


  public H265CodecSettings heightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
    return this;
  }

  /**
   * The height of the video in pixels. Must be an even integer. When not specified, the height is adjusted to match the specified width and input aspect ratio. If both are omitted, the input height is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the height, in pixels, per the horizontal ASR. The API calculates the width per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return heightPixels
   */
  @javax.annotation.Nullable
  public Integer getHeightPixels() {
    return heightPixels;
  }

  public void setHeightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
  }


  public H265CodecSettings hlg(Object hlg) {
    this.hlg = hlg;
    return this;
  }

  /**
   * Convert the input video to a Hybrid Log Gamma (HLG) video.
   * @return hlg
   */
  @javax.annotation.Nullable
  public Object getHlg() {
    return hlg;
  }

  public void setHlg(Object hlg) {
    this.hlg = hlg;
  }


  public H265CodecSettings pixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
    return this;
  }

  /**
   * Pixel format to use. The default is &#x60;yuv420p&#x60;. Supported pixel formats: - &#x60;yuv420p&#x60; pixel format - &#x60;yuv422p&#x60; pixel format - &#x60;yuv444p&#x60; pixel format - &#x60;yuv420p10&#x60; 10-bit HDR pixel format - &#x60;yuv422p10&#x60; 10-bit HDR pixel format - &#x60;yuv444p10&#x60; 10-bit HDR pixel format - &#x60;yuv420p12&#x60; 12-bit HDR pixel format - &#x60;yuv422p12&#x60; 12-bit HDR pixel format - &#x60;yuv444p12&#x60; 12-bit HDR pixel format
   * @return pixelFormat
   */
  @javax.annotation.Nullable
  public String getPixelFormat() {
    return pixelFormat;
  }

  public void setPixelFormat(String pixelFormat) {
    this.pixelFormat = pixelFormat;
  }


  public H265CodecSettings preset(String preset) {
    this.preset = preset;
    return this;
  }

  /**
   * Enforces the specified codec preset. The default is &#x60;veryfast&#x60;. The available options are [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;H265CodecSettings&#x60; message.
   * @return preset
   */
  @javax.annotation.Nullable
  public String getPreset() {
    return preset;
  }

  public void setPreset(String preset) {
    this.preset = preset;
  }


  public H265CodecSettings profile(String profile) {
    this.profile = profile;
    return this;
  }

  /**
   * Enforces the specified codec profile. The following profiles are supported: * 8-bit profiles * &#x60;main&#x60; (default) * &#x60;main-intra&#x60; * &#x60;mainstillpicture&#x60; * 10-bit profiles * &#x60;main10&#x60; (default) * &#x60;main10-intra&#x60; * &#x60;main422-10&#x60; * &#x60;main422-10-intra&#x60; * &#x60;main444-10&#x60; * &#x60;main444-10-intra&#x60; * 12-bit profiles * &#x60;main12&#x60; (default) * &#x60;main12-intra&#x60; * &#x60;main422-12&#x60; * &#x60;main422-12-intra&#x60; * &#x60;main444-12&#x60; * &#x60;main444-12-intra&#x60; The available options are [FFmpeg-compatible](https://x265.readthedocs.io/). Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;H265CodecSettings&#x60; message.
   * @return profile
   */
  @javax.annotation.Nullable
  public String getProfile() {
    return profile;
  }

  public void setProfile(String profile) {
    this.profile = profile;
  }


  public H265CodecSettings rateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Specify the mode. The default is &#x60;vbr&#x60;. Supported rate control modes: - &#x60;vbr&#x60; - variable bitrate - &#x60;crf&#x60; - constant rate factor
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public String getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(String rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public H265CodecSettings sdr(Object sdr) {
    this.sdr = sdr;
    return this;
  }

  /**
   * Convert the input video to a Standard Dynamic Range (SDR) video.
   * @return sdr
   */
  @javax.annotation.Nullable
  public Object getSdr() {
    return sdr;
  }

  public void setSdr(Object sdr) {
    this.sdr = sdr;
  }


  public H265CodecSettings tune(String tune) {
    this.tune = tune;
    return this;
  }

  /**
   * Enforces the specified codec tune. The available options are [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that certain values for this field may cause the transcoder to override other fields you set in the &#x60;H265CodecSettings&#x60; message.
   * @return tune
   */
  @javax.annotation.Nullable
  public String getTune() {
    return tune;
  }

  public void setTune(String tune) {
    this.tune = tune;
  }


  public H265CodecSettings vbvFullnessBits(Integer vbvFullnessBits) {
    this.vbvFullnessBits = vbvFullnessBits;
    return this;
  }

  /**
   * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to 90% of H265CodecSettings.vbv_size_bits.
   * @return vbvFullnessBits
   */
  @javax.annotation.Nullable
  public Integer getVbvFullnessBits() {
    return vbvFullnessBits;
  }

  public void setVbvFullnessBits(Integer vbvFullnessBits) {
    this.vbvFullnessBits = vbvFullnessBits;
  }


  public H265CodecSettings vbvSizeBits(Integer vbvSizeBits) {
    this.vbvSizeBits = vbvSizeBits;
    return this;
  }

  /**
   * Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to &#x60;VideoStream.bitrate_bps&#x60;.
   * @return vbvSizeBits
   */
  @javax.annotation.Nullable
  public Integer getVbvSizeBits() {
    return vbvSizeBits;
  }

  public void setVbvSizeBits(Integer vbvSizeBits) {
    this.vbvSizeBits = vbvSizeBits;
  }


  public H265CodecSettings widthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
    return this;
  }

  /**
   * The width of the video in pixels. Must be an even integer. When not specified, the width is adjusted to match the specified height and input aspect ratio. If both are omitted, the input width is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the width, in pixels, per the horizontal ASR. The API calculates the height per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
   * @return widthPixels
   */
  @javax.annotation.Nullable
  public Integer getWidthPixels() {
    return widthPixels;
  }

  public void setWidthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    H265CodecSettings h265CodecSettings = (H265CodecSettings) o;
    return Objects.equals(this.allowOpenGop, h265CodecSettings.allowOpenGop) &&
        Objects.equals(this.aqStrength, h265CodecSettings.aqStrength) &&
        Objects.equals(this.bFrameCount, h265CodecSettings.bFrameCount) &&
        Objects.equals(this.bPyramid, h265CodecSettings.bPyramid) &&
        Objects.equals(this.bitrateBps, h265CodecSettings.bitrateBps) &&
        Objects.equals(this.crfLevel, h265CodecSettings.crfLevel) &&
        Objects.equals(this.enableTwoPass, h265CodecSettings.enableTwoPass) &&
        Objects.equals(this.frameRate, h265CodecSettings.frameRate) &&
        Objects.equals(this.frameRateConversionStrategy, h265CodecSettings.frameRateConversionStrategy) &&
        Objects.equals(this.gopDuration, h265CodecSettings.gopDuration) &&
        Objects.equals(this.gopFrameCount, h265CodecSettings.gopFrameCount) &&
        Objects.equals(this.hdr10, h265CodecSettings.hdr10) &&
        Objects.equals(this.heightPixels, h265CodecSettings.heightPixels) &&
        Objects.equals(this.hlg, h265CodecSettings.hlg) &&
        Objects.equals(this.pixelFormat, h265CodecSettings.pixelFormat) &&
        Objects.equals(this.preset, h265CodecSettings.preset) &&
        Objects.equals(this.profile, h265CodecSettings.profile) &&
        Objects.equals(this.rateControlMode, h265CodecSettings.rateControlMode) &&
        Objects.equals(this.sdr, h265CodecSettings.sdr) &&
        Objects.equals(this.tune, h265CodecSettings.tune) &&
        Objects.equals(this.vbvFullnessBits, h265CodecSettings.vbvFullnessBits) &&
        Objects.equals(this.vbvSizeBits, h265CodecSettings.vbvSizeBits) &&
        Objects.equals(this.widthPixels, h265CodecSettings.widthPixels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowOpenGop, aqStrength, bFrameCount, bPyramid, bitrateBps, crfLevel, enableTwoPass, frameRate, frameRateConversionStrategy, gopDuration, gopFrameCount, hdr10, heightPixels, hlg, pixelFormat, preset, profile, rateControlMode, sdr, tune, vbvFullnessBits, vbvSizeBits, widthPixels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class H265CodecSettings {\n");
    sb.append("    allowOpenGop: ").append(toIndentedString(allowOpenGop)).append("\n");
    sb.append("    aqStrength: ").append(toIndentedString(aqStrength)).append("\n");
    sb.append("    bFrameCount: ").append(toIndentedString(bFrameCount)).append("\n");
    sb.append("    bPyramid: ").append(toIndentedString(bPyramid)).append("\n");
    sb.append("    bitrateBps: ").append(toIndentedString(bitrateBps)).append("\n");
    sb.append("    crfLevel: ").append(toIndentedString(crfLevel)).append("\n");
    sb.append("    enableTwoPass: ").append(toIndentedString(enableTwoPass)).append("\n");
    sb.append("    frameRate: ").append(toIndentedString(frameRate)).append("\n");
    sb.append("    frameRateConversionStrategy: ").append(toIndentedString(frameRateConversionStrategy)).append("\n");
    sb.append("    gopDuration: ").append(toIndentedString(gopDuration)).append("\n");
    sb.append("    gopFrameCount: ").append(toIndentedString(gopFrameCount)).append("\n");
    sb.append("    hdr10: ").append(toIndentedString(hdr10)).append("\n");
    sb.append("    heightPixels: ").append(toIndentedString(heightPixels)).append("\n");
    sb.append("    hlg: ").append(toIndentedString(hlg)).append("\n");
    sb.append("    pixelFormat: ").append(toIndentedString(pixelFormat)).append("\n");
    sb.append("    preset: ").append(toIndentedString(preset)).append("\n");
    sb.append("    profile: ").append(toIndentedString(profile)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    sdr: ").append(toIndentedString(sdr)).append("\n");
    sb.append("    tune: ").append(toIndentedString(tune)).append("\n");
    sb.append("    vbvFullnessBits: ").append(toIndentedString(vbvFullnessBits)).append("\n");
    sb.append("    vbvSizeBits: ").append(toIndentedString(vbvSizeBits)).append("\n");
    sb.append("    widthPixels: ").append(toIndentedString(widthPixels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowOpenGop");
    openapiFields.add("aqStrength");
    openapiFields.add("bFrameCount");
    openapiFields.add("bPyramid");
    openapiFields.add("bitrateBps");
    openapiFields.add("crfLevel");
    openapiFields.add("enableTwoPass");
    openapiFields.add("frameRate");
    openapiFields.add("frameRateConversionStrategy");
    openapiFields.add("gopDuration");
    openapiFields.add("gopFrameCount");
    openapiFields.add("hdr10");
    openapiFields.add("heightPixels");
    openapiFields.add("hlg");
    openapiFields.add("pixelFormat");
    openapiFields.add("preset");
    openapiFields.add("profile");
    openapiFields.add("rateControlMode");
    openapiFields.add("sdr");
    openapiFields.add("tune");
    openapiFields.add("vbvFullnessBits");
    openapiFields.add("vbvSizeBits");
    openapiFields.add("widthPixels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to H265CodecSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!H265CodecSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in H265CodecSettings is not found in the empty JSON string", H265CodecSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!H265CodecSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `H265CodecSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("frameRateConversionStrategy") != null && !jsonObj.get("frameRateConversionStrategy").isJsonNull()) && !jsonObj.get("frameRateConversionStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frameRateConversionStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frameRateConversionStrategy").toString()));
      }
      // validate the optional field `frameRateConversionStrategy`
      if (jsonObj.get("frameRateConversionStrategy") != null && !jsonObj.get("frameRateConversionStrategy").isJsonNull()) {
        FrameRateConversionStrategyEnum.validateJsonElement(jsonObj.get("frameRateConversionStrategy"));
      }
      if ((jsonObj.get("gopDuration") != null && !jsonObj.get("gopDuration").isJsonNull()) && !jsonObj.get("gopDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gopDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gopDuration").toString()));
      }
      if ((jsonObj.get("pixelFormat") != null && !jsonObj.get("pixelFormat").isJsonNull()) && !jsonObj.get("pixelFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pixelFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pixelFormat").toString()));
      }
      if ((jsonObj.get("preset") != null && !jsonObj.get("preset").isJsonNull()) && !jsonObj.get("preset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preset").toString()));
      }
      if ((jsonObj.get("profile") != null && !jsonObj.get("profile").isJsonNull()) && !jsonObj.get("profile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profile").toString()));
      }
      if ((jsonObj.get("rateControlMode") != null && !jsonObj.get("rateControlMode").isJsonNull()) && !jsonObj.get("rateControlMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rateControlMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rateControlMode").toString()));
      }
      if ((jsonObj.get("tune") != null && !jsonObj.get("tune").isJsonNull()) && !jsonObj.get("tune").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tune` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tune").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!H265CodecSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'H265CodecSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<H265CodecSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(H265CodecSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<H265CodecSettings>() {
           @Override
           public void write(JsonWriter out, H265CodecSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public H265CodecSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of H265CodecSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of H265CodecSettings
   * @throws IOException if the JSON string is invalid with respect to H265CodecSettings
   */
  public static H265CodecSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, H265CodecSettings.class);
  }

  /**
   * Convert an instance of H265CodecSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

