/**
 * Transcoder API
 * This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The H264CodecSettings model module.
 * @module model/H264CodecSettings
 * @version v1
 */
class H264CodecSettings {
    /**
     * Constructs a new <code>H264CodecSettings</code>.
     * H264 codec settings.
     * @alias module:model/H264CodecSettings
     */
    constructor() { 
        
        H264CodecSettings.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>H264CodecSettings</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/H264CodecSettings} obj Optional instance to populate.
     * @return {module:model/H264CodecSettings} The populated <code>H264CodecSettings</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new H264CodecSettings();

            if (data.hasOwnProperty('allowOpenGop')) {
                obj['allowOpenGop'] = ApiClient.convertToType(data['allowOpenGop'], 'Boolean');
            }
            if (data.hasOwnProperty('aqStrength')) {
                obj['aqStrength'] = ApiClient.convertToType(data['aqStrength'], 'Number');
            }
            if (data.hasOwnProperty('bFrameCount')) {
                obj['bFrameCount'] = ApiClient.convertToType(data['bFrameCount'], 'Number');
            }
            if (data.hasOwnProperty('bPyramid')) {
                obj['bPyramid'] = ApiClient.convertToType(data['bPyramid'], 'Boolean');
            }
            if (data.hasOwnProperty('bitrateBps')) {
                obj['bitrateBps'] = ApiClient.convertToType(data['bitrateBps'], 'Number');
            }
            if (data.hasOwnProperty('crfLevel')) {
                obj['crfLevel'] = ApiClient.convertToType(data['crfLevel'], 'Number');
            }
            if (data.hasOwnProperty('enableTwoPass')) {
                obj['enableTwoPass'] = ApiClient.convertToType(data['enableTwoPass'], 'Boolean');
            }
            if (data.hasOwnProperty('entropyCoder')) {
                obj['entropyCoder'] = ApiClient.convertToType(data['entropyCoder'], 'String');
            }
            if (data.hasOwnProperty('frameRate')) {
                obj['frameRate'] = ApiClient.convertToType(data['frameRate'], 'Number');
            }
            if (data.hasOwnProperty('frameRateConversionStrategy')) {
                obj['frameRateConversionStrategy'] = ApiClient.convertToType(data['frameRateConversionStrategy'], 'String');
            }
            if (data.hasOwnProperty('gopDuration')) {
                obj['gopDuration'] = ApiClient.convertToType(data['gopDuration'], 'String');
            }
            if (data.hasOwnProperty('gopFrameCount')) {
                obj['gopFrameCount'] = ApiClient.convertToType(data['gopFrameCount'], 'Number');
            }
            if (data.hasOwnProperty('heightPixels')) {
                obj['heightPixels'] = ApiClient.convertToType(data['heightPixels'], 'Number');
            }
            if (data.hasOwnProperty('hlg')) {
                obj['hlg'] = ApiClient.convertToType(data['hlg'], Object);
            }
            if (data.hasOwnProperty('pixelFormat')) {
                obj['pixelFormat'] = ApiClient.convertToType(data['pixelFormat'], 'String');
            }
            if (data.hasOwnProperty('preset')) {
                obj['preset'] = ApiClient.convertToType(data['preset'], 'String');
            }
            if (data.hasOwnProperty('profile')) {
                obj['profile'] = ApiClient.convertToType(data['profile'], 'String');
            }
            if (data.hasOwnProperty('rateControlMode')) {
                obj['rateControlMode'] = ApiClient.convertToType(data['rateControlMode'], 'String');
            }
            if (data.hasOwnProperty('sdr')) {
                obj['sdr'] = ApiClient.convertToType(data['sdr'], Object);
            }
            if (data.hasOwnProperty('tune')) {
                obj['tune'] = ApiClient.convertToType(data['tune'], 'String');
            }
            if (data.hasOwnProperty('vbvFullnessBits')) {
                obj['vbvFullnessBits'] = ApiClient.convertToType(data['vbvFullnessBits'], 'Number');
            }
            if (data.hasOwnProperty('vbvSizeBits')) {
                obj['vbvSizeBits'] = ApiClient.convertToType(data['vbvSizeBits'], 'Number');
            }
            if (data.hasOwnProperty('widthPixels')) {
                obj['widthPixels'] = ApiClient.convertToType(data['widthPixels'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>H264CodecSettings</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>H264CodecSettings</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['entropyCoder'] && !(typeof data['entropyCoder'] === 'string' || data['entropyCoder'] instanceof String)) {
            throw new Error("Expected the field `entropyCoder` to be a primitive type in the JSON string but got " + data['entropyCoder']);
        }
        // ensure the json data is a string
        if (data['frameRateConversionStrategy'] && !(typeof data['frameRateConversionStrategy'] === 'string' || data['frameRateConversionStrategy'] instanceof String)) {
            throw new Error("Expected the field `frameRateConversionStrategy` to be a primitive type in the JSON string but got " + data['frameRateConversionStrategy']);
        }
        // ensure the json data is a string
        if (data['gopDuration'] && !(typeof data['gopDuration'] === 'string' || data['gopDuration'] instanceof String)) {
            throw new Error("Expected the field `gopDuration` to be a primitive type in the JSON string but got " + data['gopDuration']);
        }
        // ensure the json data is a string
        if (data['pixelFormat'] && !(typeof data['pixelFormat'] === 'string' || data['pixelFormat'] instanceof String)) {
            throw new Error("Expected the field `pixelFormat` to be a primitive type in the JSON string but got " + data['pixelFormat']);
        }
        // ensure the json data is a string
        if (data['preset'] && !(typeof data['preset'] === 'string' || data['preset'] instanceof String)) {
            throw new Error("Expected the field `preset` to be a primitive type in the JSON string but got " + data['preset']);
        }
        // ensure the json data is a string
        if (data['profile'] && !(typeof data['profile'] === 'string' || data['profile'] instanceof String)) {
            throw new Error("Expected the field `profile` to be a primitive type in the JSON string but got " + data['profile']);
        }
        // ensure the json data is a string
        if (data['rateControlMode'] && !(typeof data['rateControlMode'] === 'string' || data['rateControlMode'] instanceof String)) {
            throw new Error("Expected the field `rateControlMode` to be a primitive type in the JSON string but got " + data['rateControlMode']);
        }
        // ensure the json data is a string
        if (data['tune'] && !(typeof data['tune'] === 'string' || data['tune'] instanceof String)) {
            throw new Error("Expected the field `tune` to be a primitive type in the JSON string but got " + data['tune']);
        }

        return true;
    }


}



/**
 * Specifies whether an open Group of Pictures (GOP) structure should be allowed or not. The default is `false`.
 * @member {Boolean} allowOpenGop
 */
H264CodecSettings.prototype['allowOpenGop'] = undefined;

/**
 * Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher value equals a lower bitrate but smoother image. The default is 0.
 * @member {Number} aqStrength
 */
H264CodecSettings.prototype['aqStrength'] = undefined;

/**
 * The number of consecutive B-frames. Must be greater than or equal to zero. Must be less than H264CodecSettings.gop_frame_count if set. The default is 0.
 * @member {Number} bFrameCount
 */
H264CodecSettings.prototype['bFrameCount'] = undefined;

/**
 * Allow B-pyramid for reference frame selection. This may not be supported on all decoders. The default is `false`.
 * @member {Boolean} bPyramid
 */
H264CodecSettings.prototype['bPyramid'] = undefined;

/**
 * Required. The video bitrate in bits per second. The minimum value is 1,000. The maximum value is 800,000,000.
 * @member {Number} bitrateBps
 */
H264CodecSettings.prototype['bitrateBps'] = undefined;

/**
 * Target CRF level. Must be between 10 and 36, where 10 is the highest quality and 36 is the most efficient compression. The default is 21.
 * @member {Number} crfLevel
 */
H264CodecSettings.prototype['crfLevel'] = undefined;

/**
 * Use two-pass encoding strategy to achieve better video quality. H264CodecSettings.rate_control_mode must be `vbr`. The default is `false`.
 * @member {Boolean} enableTwoPass
 */
H264CodecSettings.prototype['enableTwoPass'] = undefined;

/**
 * The entropy coder to use. The default is `cabac`. Supported entropy coders: - `cavlc` - `cabac`
 * @member {String} entropyCoder
 */
H264CodecSettings.prototype['entropyCoder'] = undefined;

/**
 * Required. The target video frame rate in frames per second (FPS). Must be less than or equal to 120.
 * @member {Number} frameRate
 */
H264CodecSettings.prototype['frameRate'] = undefined;

/**
 * Optional. Frame rate conversion strategy for desired frame rate. The default is `DOWNSAMPLE`.
 * @member {module:model/H264CodecSettings.FrameRateConversionStrategyEnum} frameRateConversionStrategy
 */
H264CodecSettings.prototype['frameRateConversionStrategy'] = undefined;

/**
 * Select the GOP size based on the specified duration. The default is `3s`. Note that `gopDuration` must be less than or equal to [`segmentDuration`](#SegmentSettings), and [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 * @member {String} gopDuration
 */
H264CodecSettings.prototype['gopDuration'] = undefined;

/**
 * Select the GOP size based on the specified frame count. Must be greater than zero.
 * @member {Number} gopFrameCount
 */
H264CodecSettings.prototype['gopFrameCount'] = undefined;

/**
 * The height of the video in pixels. Must be an even integer. When not specified, the height is adjusted to match the specified width and input aspect ratio. If both are omitted, the input height is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the height, in pixels, per the horizontal ASR. The API calculates the width per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
 * @member {Number} heightPixels
 */
H264CodecSettings.prototype['heightPixels'] = undefined;

/**
 * Convert the input video to a Hybrid Log Gamma (HLG) video.
 * @member {Object} hlg
 */
H264CodecSettings.prototype['hlg'] = undefined;

/**
 * Pixel format to use. The default is `yuv420p`. Supported pixel formats: - `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format - `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format - `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format - `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 * @member {String} pixelFormat
 */
H264CodecSettings.prototype['pixelFormat'] = undefined;

/**
 * Enforces the specified codec preset. The default is `veryfast`. The available options are [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Preset). Note that certain values for this field may cause the transcoder to override other fields you set in the `H264CodecSettings` message.
 * @member {String} preset
 */
H264CodecSettings.prototype['preset'] = undefined;

/**
 * Enforces the specified codec profile. The following profiles are supported: * `baseline` * `main` * `high` (default) The available options are [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note that certain values for this field may cause the transcoder to override other fields you set in the `H264CodecSettings` message.
 * @member {String} profile
 */
H264CodecSettings.prototype['profile'] = undefined;

/**
 * Specify the mode. The default is `vbr`. Supported rate control modes: - `vbr` - variable bitrate - `crf` - constant rate factor
 * @member {String} rateControlMode
 */
H264CodecSettings.prototype['rateControlMode'] = undefined;

/**
 * Convert the input video to a Standard Dynamic Range (SDR) video.
 * @member {Object} sdr
 */
H264CodecSettings.prototype['sdr'] = undefined;

/**
 * Enforces the specified codec tune. The available options are [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note that certain values for this field may cause the transcoder to override other fields you set in the `H264CodecSettings` message.
 * @member {String} tune
 */
H264CodecSettings.prototype['tune'] = undefined;

/**
 * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to 90% of H264CodecSettings.vbv_size_bits.
 * @member {Number} vbvFullnessBits
 */
H264CodecSettings.prototype['vbvFullnessBits'] = undefined;

/**
 * Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater than zero. The default is equal to H264CodecSettings.bitrate_bps.
 * @member {Number} vbvSizeBits
 */
H264CodecSettings.prototype['vbvSizeBits'] = undefined;

/**
 * The width of the video in pixels. Must be an even integer. When not specified, the width is adjusted to match the specified height and input aspect ratio. If both are omitted, the input width is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the width, in pixels, per the horizontal ASR. The API calculates the height per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.
 * @member {Number} widthPixels
 */
H264CodecSettings.prototype['widthPixels'] = undefined;





/**
 * Allowed values for the <code>frameRateConversionStrategy</code> property.
 * @enum {String}
 * @readonly
 */
H264CodecSettings['FrameRateConversionStrategyEnum'] = {

    /**
     * value: "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"
     * @const
     */
    "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED": "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED",

    /**
     * value: "DOWNSAMPLE"
     * @const
     */
    "DOWNSAMPLE": "DOWNSAMPLE",

    /**
     * value: "DROP_DUPLICATE"
     * @const
     */
    "DROP_DUPLICATE": "DROP_DUPLICATE"
};



export default H264CodecSettings;

