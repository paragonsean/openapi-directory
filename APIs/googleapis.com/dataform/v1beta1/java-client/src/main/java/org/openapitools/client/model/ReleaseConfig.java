/*
 * Dataform API
 * Service to develop, version control, and operationalize SQL pipelines in BigQuery.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CodeCompilationConfig;
import org.openapitools.client.model.ScheduledReleaseRecord;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a Dataform release configuration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:07.077200-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReleaseConfig {
  public static final String SERIALIZED_NAME_CODE_COMPILATION_CONFIG = "codeCompilationConfig";
  @SerializedName(SERIALIZED_NAME_CODE_COMPILATION_CONFIG)
  private CodeCompilationConfig codeCompilationConfig;

  public static final String SERIALIZED_NAME_CRON_SCHEDULE = "cronSchedule";
  @SerializedName(SERIALIZED_NAME_CRON_SCHEDULE)
  private String cronSchedule;

  public static final String SERIALIZED_NAME_DISABLED = "disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  private Boolean disabled;

  public static final String SERIALIZED_NAME_GIT_COMMITISH = "gitCommitish";
  @SerializedName(SERIALIZED_NAME_GIT_COMMITISH)
  private String gitCommitish;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RECENT_SCHEDULED_RELEASE_RECORDS = "recentScheduledReleaseRecords";
  @SerializedName(SERIALIZED_NAME_RECENT_SCHEDULED_RELEASE_RECORDS)
  private List<ScheduledReleaseRecord> recentScheduledReleaseRecords = new ArrayList<>();

  public static final String SERIALIZED_NAME_RELEASE_COMPILATION_RESULT = "releaseCompilationResult";
  @SerializedName(SERIALIZED_NAME_RELEASE_COMPILATION_RESULT)
  private String releaseCompilationResult;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public ReleaseConfig() {
  }

  public ReleaseConfig(
     String name, 
     List<ScheduledReleaseRecord> recentScheduledReleaseRecords
  ) {
    this();
    this.name = name;
    this.recentScheduledReleaseRecords = recentScheduledReleaseRecords;
  }

  public ReleaseConfig codeCompilationConfig(CodeCompilationConfig codeCompilationConfig) {
    this.codeCompilationConfig = codeCompilationConfig;
    return this;
  }

  /**
   * Get codeCompilationConfig
   * @return codeCompilationConfig
   */
  @javax.annotation.Nullable
  public CodeCompilationConfig getCodeCompilationConfig() {
    return codeCompilationConfig;
  }

  public void setCodeCompilationConfig(CodeCompilationConfig codeCompilationConfig) {
    this.codeCompilationConfig = codeCompilationConfig;
  }


  public ReleaseConfig cronSchedule(String cronSchedule) {
    this.cronSchedule = cronSchedule;
    return this;
  }

  /**
   * Optional. Optional schedule (in cron format) for automatic creation of compilation results.
   * @return cronSchedule
   */
  @javax.annotation.Nullable
  public String getCronSchedule() {
    return cronSchedule;
  }

  public void setCronSchedule(String cronSchedule) {
    this.cronSchedule = cronSchedule;
  }


  public ReleaseConfig disabled(Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Optional. Disables automatic creation of compilation results.
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(Boolean disabled) {
    this.disabled = disabled;
  }


  public ReleaseConfig gitCommitish(String gitCommitish) {
    this.gitCommitish = gitCommitish;
    return this;
  }

  /**
   * Required. Git commit/tag/branch name at which the repository should be compiled. Must exist in the remote repository. Examples: - a commit SHA: &#x60;12ade345&#x60; - a tag: &#x60;tag1&#x60; - a branch name: &#x60;branch1&#x60;
   * @return gitCommitish
   */
  @javax.annotation.Nullable
  public String getGitCommitish() {
    return gitCommitish;
  }

  public void setGitCommitish(String gitCommitish) {
    this.gitCommitish = gitCommitish;
  }


  /**
   * Output only. The release config&#39;s name.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  /**
   * Output only. Records of the 10 most recent scheduled release attempts, ordered in in descending order of &#x60;release_time&#x60;. Updated whenever automatic creation of a compilation result is triggered by cron_schedule.
   * @return recentScheduledReleaseRecords
   */
  @javax.annotation.Nullable
  public List<ScheduledReleaseRecord> getRecentScheduledReleaseRecords() {
    return recentScheduledReleaseRecords;
  }



  public ReleaseConfig releaseCompilationResult(String releaseCompilationResult) {
    this.releaseCompilationResult = releaseCompilationResult;
    return this;
  }

  /**
   * Optional. The name of the currently released compilation result for this release config. This value is updated when a compilation result is automatically created from this release config (using cron_schedule), or when this resource is updated by API call (perhaps to roll back to an earlier release). The compilation result must have been created using this release config. Must be in the format &#x60;projects/_*_/locations/_*_/repositories/_*_/compilationResults/_*&#x60;.
   * @return releaseCompilationResult
   */
  @javax.annotation.Nullable
  public String getReleaseCompilationResult() {
    return releaseCompilationResult;
  }

  public void setReleaseCompilationResult(String releaseCompilationResult) {
    this.releaseCompilationResult = releaseCompilationResult;
  }


  public ReleaseConfig timeZone(String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * Optional. Specifies the time zone to be used when interpreting cron_schedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). If left unspecified, the default is UTC.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReleaseConfig releaseConfig = (ReleaseConfig) o;
    return Objects.equals(this.codeCompilationConfig, releaseConfig.codeCompilationConfig) &&
        Objects.equals(this.cronSchedule, releaseConfig.cronSchedule) &&
        Objects.equals(this.disabled, releaseConfig.disabled) &&
        Objects.equals(this.gitCommitish, releaseConfig.gitCommitish) &&
        Objects.equals(this.name, releaseConfig.name) &&
        Objects.equals(this.recentScheduledReleaseRecords, releaseConfig.recentScheduledReleaseRecords) &&
        Objects.equals(this.releaseCompilationResult, releaseConfig.releaseCompilationResult) &&
        Objects.equals(this.timeZone, releaseConfig.timeZone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(codeCompilationConfig, cronSchedule, disabled, gitCommitish, name, recentScheduledReleaseRecords, releaseCompilationResult, timeZone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReleaseConfig {\n");
    sb.append("    codeCompilationConfig: ").append(toIndentedString(codeCompilationConfig)).append("\n");
    sb.append("    cronSchedule: ").append(toIndentedString(cronSchedule)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    gitCommitish: ").append(toIndentedString(gitCommitish)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    recentScheduledReleaseRecords: ").append(toIndentedString(recentScheduledReleaseRecords)).append("\n");
    sb.append("    releaseCompilationResult: ").append(toIndentedString(releaseCompilationResult)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("codeCompilationConfig");
    openapiFields.add("cronSchedule");
    openapiFields.add("disabled");
    openapiFields.add("gitCommitish");
    openapiFields.add("name");
    openapiFields.add("recentScheduledReleaseRecords");
    openapiFields.add("releaseCompilationResult");
    openapiFields.add("timeZone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReleaseConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReleaseConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReleaseConfig is not found in the empty JSON string", ReleaseConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReleaseConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReleaseConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `codeCompilationConfig`
      if (jsonObj.get("codeCompilationConfig") != null && !jsonObj.get("codeCompilationConfig").isJsonNull()) {
        CodeCompilationConfig.validateJsonElement(jsonObj.get("codeCompilationConfig"));
      }
      if ((jsonObj.get("cronSchedule") != null && !jsonObj.get("cronSchedule").isJsonNull()) && !jsonObj.get("cronSchedule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cronSchedule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cronSchedule").toString()));
      }
      if ((jsonObj.get("gitCommitish") != null && !jsonObj.get("gitCommitish").isJsonNull()) && !jsonObj.get("gitCommitish").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gitCommitish` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gitCommitish").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("recentScheduledReleaseRecords") != null && !jsonObj.get("recentScheduledReleaseRecords").isJsonNull()) {
        JsonArray jsonArrayrecentScheduledReleaseRecords = jsonObj.getAsJsonArray("recentScheduledReleaseRecords");
        if (jsonArrayrecentScheduledReleaseRecords != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recentScheduledReleaseRecords").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recentScheduledReleaseRecords` to be an array in the JSON string but got `%s`", jsonObj.get("recentScheduledReleaseRecords").toString()));
          }

          // validate the optional field `recentScheduledReleaseRecords` (array)
          for (int i = 0; i < jsonArrayrecentScheduledReleaseRecords.size(); i++) {
            ScheduledReleaseRecord.validateJsonElement(jsonArrayrecentScheduledReleaseRecords.get(i));
          };
        }
      }
      if ((jsonObj.get("releaseCompilationResult") != null && !jsonObj.get("releaseCompilationResult").isJsonNull()) && !jsonObj.get("releaseCompilationResult").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `releaseCompilationResult` to be a primitive type in the JSON string but got `%s`", jsonObj.get("releaseCompilationResult").toString()));
      }
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReleaseConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReleaseConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReleaseConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReleaseConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ReleaseConfig>() {
           @Override
           public void write(JsonWriter out, ReleaseConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReleaseConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReleaseConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReleaseConfig
   * @throws IOException if the JSON string is invalid with respect to ReleaseConfig
   */
  public static ReleaseConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReleaseConfig.class);
  }

  /**
   * Convert an instance of ReleaseConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

