/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ArimaOrder from './ArimaOrder';

/**
 * The TrainingOptions model module.
 * @module model/TrainingOptions
 * @version v2
 */
class TrainingOptions {
    /**
     * Constructs a new <code>TrainingOptions</code>.
     * Options used in model training.
     * @alias module:model/TrainingOptions
     */
    constructor() { 
        
        TrainingOptions.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>TrainingOptions</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/TrainingOptions} obj Optional instance to populate.
     * @return {module:model/TrainingOptions} The populated <code>TrainingOptions</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new TrainingOptions();

            if (data.hasOwnProperty('activationFn')) {
                obj['activationFn'] = ApiClient.convertToType(data['activationFn'], 'String');
            }
            if (data.hasOwnProperty('adjustStepChanges')) {
                obj['adjustStepChanges'] = ApiClient.convertToType(data['adjustStepChanges'], 'Boolean');
            }
            if (data.hasOwnProperty('approxGlobalFeatureContrib')) {
                obj['approxGlobalFeatureContrib'] = ApiClient.convertToType(data['approxGlobalFeatureContrib'], 'Boolean');
            }
            if (data.hasOwnProperty('autoArima')) {
                obj['autoArima'] = ApiClient.convertToType(data['autoArima'], 'Boolean');
            }
            if (data.hasOwnProperty('autoArimaMaxOrder')) {
                obj['autoArimaMaxOrder'] = ApiClient.convertToType(data['autoArimaMaxOrder'], 'String');
            }
            if (data.hasOwnProperty('autoArimaMinOrder')) {
                obj['autoArimaMinOrder'] = ApiClient.convertToType(data['autoArimaMinOrder'], 'String');
            }
            if (data.hasOwnProperty('autoClassWeights')) {
                obj['autoClassWeights'] = ApiClient.convertToType(data['autoClassWeights'], 'Boolean');
            }
            if (data.hasOwnProperty('batchSize')) {
                obj['batchSize'] = ApiClient.convertToType(data['batchSize'], 'String');
            }
            if (data.hasOwnProperty('boosterType')) {
                obj['boosterType'] = ApiClient.convertToType(data['boosterType'], 'String');
            }
            if (data.hasOwnProperty('budgetHours')) {
                obj['budgetHours'] = ApiClient.convertToType(data['budgetHours'], 'Number');
            }
            if (data.hasOwnProperty('calculatePValues')) {
                obj['calculatePValues'] = ApiClient.convertToType(data['calculatePValues'], 'Boolean');
            }
            if (data.hasOwnProperty('categoryEncodingMethod')) {
                obj['categoryEncodingMethod'] = ApiClient.convertToType(data['categoryEncodingMethod'], 'String');
            }
            if (data.hasOwnProperty('cleanSpikesAndDips')) {
                obj['cleanSpikesAndDips'] = ApiClient.convertToType(data['cleanSpikesAndDips'], 'Boolean');
            }
            if (data.hasOwnProperty('colorSpace')) {
                obj['colorSpace'] = ApiClient.convertToType(data['colorSpace'], 'String');
            }
            if (data.hasOwnProperty('colsampleBylevel')) {
                obj['colsampleBylevel'] = ApiClient.convertToType(data['colsampleBylevel'], 'Number');
            }
            if (data.hasOwnProperty('colsampleBynode')) {
                obj['colsampleBynode'] = ApiClient.convertToType(data['colsampleBynode'], 'Number');
            }
            if (data.hasOwnProperty('colsampleBytree')) {
                obj['colsampleBytree'] = ApiClient.convertToType(data['colsampleBytree'], 'Number');
            }
            if (data.hasOwnProperty('dartNormalizeType')) {
                obj['dartNormalizeType'] = ApiClient.convertToType(data['dartNormalizeType'], 'String');
            }
            if (data.hasOwnProperty('dataFrequency')) {
                obj['dataFrequency'] = ApiClient.convertToType(data['dataFrequency'], 'String');
            }
            if (data.hasOwnProperty('dataSplitColumn')) {
                obj['dataSplitColumn'] = ApiClient.convertToType(data['dataSplitColumn'], 'String');
            }
            if (data.hasOwnProperty('dataSplitEvalFraction')) {
                obj['dataSplitEvalFraction'] = ApiClient.convertToType(data['dataSplitEvalFraction'], 'Number');
            }
            if (data.hasOwnProperty('dataSplitMethod')) {
                obj['dataSplitMethod'] = ApiClient.convertToType(data['dataSplitMethod'], 'String');
            }
            if (data.hasOwnProperty('decomposeTimeSeries')) {
                obj['decomposeTimeSeries'] = ApiClient.convertToType(data['decomposeTimeSeries'], 'Boolean');
            }
            if (data.hasOwnProperty('distanceType')) {
                obj['distanceType'] = ApiClient.convertToType(data['distanceType'], 'String');
            }
            if (data.hasOwnProperty('dropout')) {
                obj['dropout'] = ApiClient.convertToType(data['dropout'], 'Number');
            }
            if (data.hasOwnProperty('earlyStop')) {
                obj['earlyStop'] = ApiClient.convertToType(data['earlyStop'], 'Boolean');
            }
            if (data.hasOwnProperty('enableGlobalExplain')) {
                obj['enableGlobalExplain'] = ApiClient.convertToType(data['enableGlobalExplain'], 'Boolean');
            }
            if (data.hasOwnProperty('feedbackType')) {
                obj['feedbackType'] = ApiClient.convertToType(data['feedbackType'], 'String');
            }
            if (data.hasOwnProperty('fitIntercept')) {
                obj['fitIntercept'] = ApiClient.convertToType(data['fitIntercept'], 'Boolean');
            }
            if (data.hasOwnProperty('hiddenUnits')) {
                obj['hiddenUnits'] = ApiClient.convertToType(data['hiddenUnits'], ['String']);
            }
            if (data.hasOwnProperty('holidayRegion')) {
                obj['holidayRegion'] = ApiClient.convertToType(data['holidayRegion'], 'String');
            }
            if (data.hasOwnProperty('holidayRegions')) {
                obj['holidayRegions'] = ApiClient.convertToType(data['holidayRegions'], ['String']);
            }
            if (data.hasOwnProperty('horizon')) {
                obj['horizon'] = ApiClient.convertToType(data['horizon'], 'String');
            }
            if (data.hasOwnProperty('hparamTuningObjectives')) {
                obj['hparamTuningObjectives'] = ApiClient.convertToType(data['hparamTuningObjectives'], ['String']);
            }
            if (data.hasOwnProperty('includeDrift')) {
                obj['includeDrift'] = ApiClient.convertToType(data['includeDrift'], 'Boolean');
            }
            if (data.hasOwnProperty('initialLearnRate')) {
                obj['initialLearnRate'] = ApiClient.convertToType(data['initialLearnRate'], 'Number');
            }
            if (data.hasOwnProperty('inputLabelColumns')) {
                obj['inputLabelColumns'] = ApiClient.convertToType(data['inputLabelColumns'], ['String']);
            }
            if (data.hasOwnProperty('instanceWeightColumn')) {
                obj['instanceWeightColumn'] = ApiClient.convertToType(data['instanceWeightColumn'], 'String');
            }
            if (data.hasOwnProperty('integratedGradientsNumSteps')) {
                obj['integratedGradientsNumSteps'] = ApiClient.convertToType(data['integratedGradientsNumSteps'], 'String');
            }
            if (data.hasOwnProperty('itemColumn')) {
                obj['itemColumn'] = ApiClient.convertToType(data['itemColumn'], 'String');
            }
            if (data.hasOwnProperty('kmeansInitializationColumn')) {
                obj['kmeansInitializationColumn'] = ApiClient.convertToType(data['kmeansInitializationColumn'], 'String');
            }
            if (data.hasOwnProperty('kmeansInitializationMethod')) {
                obj['kmeansInitializationMethod'] = ApiClient.convertToType(data['kmeansInitializationMethod'], 'String');
            }
            if (data.hasOwnProperty('l1RegActivation')) {
                obj['l1RegActivation'] = ApiClient.convertToType(data['l1RegActivation'], 'Number');
            }
            if (data.hasOwnProperty('l1Regularization')) {
                obj['l1Regularization'] = ApiClient.convertToType(data['l1Regularization'], 'Number');
            }
            if (data.hasOwnProperty('l2Regularization')) {
                obj['l2Regularization'] = ApiClient.convertToType(data['l2Regularization'], 'Number');
            }
            if (data.hasOwnProperty('labelClassWeights')) {
                obj['labelClassWeights'] = ApiClient.convertToType(data['labelClassWeights'], {'String': 'Number'});
            }
            if (data.hasOwnProperty('learnRate')) {
                obj['learnRate'] = ApiClient.convertToType(data['learnRate'], 'Number');
            }
            if (data.hasOwnProperty('learnRateStrategy')) {
                obj['learnRateStrategy'] = ApiClient.convertToType(data['learnRateStrategy'], 'String');
            }
            if (data.hasOwnProperty('lossType')) {
                obj['lossType'] = ApiClient.convertToType(data['lossType'], 'String');
            }
            if (data.hasOwnProperty('maxIterations')) {
                obj['maxIterations'] = ApiClient.convertToType(data['maxIterations'], 'String');
            }
            if (data.hasOwnProperty('maxParallelTrials')) {
                obj['maxParallelTrials'] = ApiClient.convertToType(data['maxParallelTrials'], 'String');
            }
            if (data.hasOwnProperty('maxTimeSeriesLength')) {
                obj['maxTimeSeriesLength'] = ApiClient.convertToType(data['maxTimeSeriesLength'], 'String');
            }
            if (data.hasOwnProperty('maxTreeDepth')) {
                obj['maxTreeDepth'] = ApiClient.convertToType(data['maxTreeDepth'], 'String');
            }
            if (data.hasOwnProperty('minRelativeProgress')) {
                obj['minRelativeProgress'] = ApiClient.convertToType(data['minRelativeProgress'], 'Number');
            }
            if (data.hasOwnProperty('minSplitLoss')) {
                obj['minSplitLoss'] = ApiClient.convertToType(data['minSplitLoss'], 'Number');
            }
            if (data.hasOwnProperty('minTimeSeriesLength')) {
                obj['minTimeSeriesLength'] = ApiClient.convertToType(data['minTimeSeriesLength'], 'String');
            }
            if (data.hasOwnProperty('minTreeChildWeight')) {
                obj['minTreeChildWeight'] = ApiClient.convertToType(data['minTreeChildWeight'], 'String');
            }
            if (data.hasOwnProperty('modelRegistry')) {
                obj['modelRegistry'] = ApiClient.convertToType(data['modelRegistry'], 'String');
            }
            if (data.hasOwnProperty('modelUri')) {
                obj['modelUri'] = ApiClient.convertToType(data['modelUri'], 'String');
            }
            if (data.hasOwnProperty('nonSeasonalOrder')) {
                obj['nonSeasonalOrder'] = ArimaOrder.constructFromObject(data['nonSeasonalOrder']);
            }
            if (data.hasOwnProperty('numClusters')) {
                obj['numClusters'] = ApiClient.convertToType(data['numClusters'], 'String');
            }
            if (data.hasOwnProperty('numFactors')) {
                obj['numFactors'] = ApiClient.convertToType(data['numFactors'], 'String');
            }
            if (data.hasOwnProperty('numParallelTree')) {
                obj['numParallelTree'] = ApiClient.convertToType(data['numParallelTree'], 'String');
            }
            if (data.hasOwnProperty('numPrincipalComponents')) {
                obj['numPrincipalComponents'] = ApiClient.convertToType(data['numPrincipalComponents'], 'String');
            }
            if (data.hasOwnProperty('numTrials')) {
                obj['numTrials'] = ApiClient.convertToType(data['numTrials'], 'String');
            }
            if (data.hasOwnProperty('optimizationStrategy')) {
                obj['optimizationStrategy'] = ApiClient.convertToType(data['optimizationStrategy'], 'String');
            }
            if (data.hasOwnProperty('optimizer')) {
                obj['optimizer'] = ApiClient.convertToType(data['optimizer'], 'String');
            }
            if (data.hasOwnProperty('pcaExplainedVarianceRatio')) {
                obj['pcaExplainedVarianceRatio'] = ApiClient.convertToType(data['pcaExplainedVarianceRatio'], 'Number');
            }
            if (data.hasOwnProperty('pcaSolver')) {
                obj['pcaSolver'] = ApiClient.convertToType(data['pcaSolver'], 'String');
            }
            if (data.hasOwnProperty('sampledShapleyNumPaths')) {
                obj['sampledShapleyNumPaths'] = ApiClient.convertToType(data['sampledShapleyNumPaths'], 'String');
            }
            if (data.hasOwnProperty('scaleFeatures')) {
                obj['scaleFeatures'] = ApiClient.convertToType(data['scaleFeatures'], 'Boolean');
            }
            if (data.hasOwnProperty('standardizeFeatures')) {
                obj['standardizeFeatures'] = ApiClient.convertToType(data['standardizeFeatures'], 'Boolean');
            }
            if (data.hasOwnProperty('subsample')) {
                obj['subsample'] = ApiClient.convertToType(data['subsample'], 'Number');
            }
            if (data.hasOwnProperty('tfVersion')) {
                obj['tfVersion'] = ApiClient.convertToType(data['tfVersion'], 'String');
            }
            if (data.hasOwnProperty('timeSeriesDataColumn')) {
                obj['timeSeriesDataColumn'] = ApiClient.convertToType(data['timeSeriesDataColumn'], 'String');
            }
            if (data.hasOwnProperty('timeSeriesIdColumn')) {
                obj['timeSeriesIdColumn'] = ApiClient.convertToType(data['timeSeriesIdColumn'], 'String');
            }
            if (data.hasOwnProperty('timeSeriesIdColumns')) {
                obj['timeSeriesIdColumns'] = ApiClient.convertToType(data['timeSeriesIdColumns'], ['String']);
            }
            if (data.hasOwnProperty('timeSeriesLengthFraction')) {
                obj['timeSeriesLengthFraction'] = ApiClient.convertToType(data['timeSeriesLengthFraction'], 'Number');
            }
            if (data.hasOwnProperty('timeSeriesTimestampColumn')) {
                obj['timeSeriesTimestampColumn'] = ApiClient.convertToType(data['timeSeriesTimestampColumn'], 'String');
            }
            if (data.hasOwnProperty('treeMethod')) {
                obj['treeMethod'] = ApiClient.convertToType(data['treeMethod'], 'String');
            }
            if (data.hasOwnProperty('trendSmoothingWindowSize')) {
                obj['trendSmoothingWindowSize'] = ApiClient.convertToType(data['trendSmoothingWindowSize'], 'String');
            }
            if (data.hasOwnProperty('userColumn')) {
                obj['userColumn'] = ApiClient.convertToType(data['userColumn'], 'String');
            }
            if (data.hasOwnProperty('vertexAiModelVersionAliases')) {
                obj['vertexAiModelVersionAliases'] = ApiClient.convertToType(data['vertexAiModelVersionAliases'], ['String']);
            }
            if (data.hasOwnProperty('walsAlpha')) {
                obj['walsAlpha'] = ApiClient.convertToType(data['walsAlpha'], 'Number');
            }
            if (data.hasOwnProperty('warmStart')) {
                obj['warmStart'] = ApiClient.convertToType(data['warmStart'], 'Boolean');
            }
            if (data.hasOwnProperty('xgboostVersion')) {
                obj['xgboostVersion'] = ApiClient.convertToType(data['xgboostVersion'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>TrainingOptions</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>TrainingOptions</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['activationFn'] && !(typeof data['activationFn'] === 'string' || data['activationFn'] instanceof String)) {
            throw new Error("Expected the field `activationFn` to be a primitive type in the JSON string but got " + data['activationFn']);
        }
        // ensure the json data is a string
        if (data['autoArimaMaxOrder'] && !(typeof data['autoArimaMaxOrder'] === 'string' || data['autoArimaMaxOrder'] instanceof String)) {
            throw new Error("Expected the field `autoArimaMaxOrder` to be a primitive type in the JSON string but got " + data['autoArimaMaxOrder']);
        }
        // ensure the json data is a string
        if (data['autoArimaMinOrder'] && !(typeof data['autoArimaMinOrder'] === 'string' || data['autoArimaMinOrder'] instanceof String)) {
            throw new Error("Expected the field `autoArimaMinOrder` to be a primitive type in the JSON string but got " + data['autoArimaMinOrder']);
        }
        // ensure the json data is a string
        if (data['batchSize'] && !(typeof data['batchSize'] === 'string' || data['batchSize'] instanceof String)) {
            throw new Error("Expected the field `batchSize` to be a primitive type in the JSON string but got " + data['batchSize']);
        }
        // ensure the json data is a string
        if (data['boosterType'] && !(typeof data['boosterType'] === 'string' || data['boosterType'] instanceof String)) {
            throw new Error("Expected the field `boosterType` to be a primitive type in the JSON string but got " + data['boosterType']);
        }
        // ensure the json data is a string
        if (data['categoryEncodingMethod'] && !(typeof data['categoryEncodingMethod'] === 'string' || data['categoryEncodingMethod'] instanceof String)) {
            throw new Error("Expected the field `categoryEncodingMethod` to be a primitive type in the JSON string but got " + data['categoryEncodingMethod']);
        }
        // ensure the json data is a string
        if (data['colorSpace'] && !(typeof data['colorSpace'] === 'string' || data['colorSpace'] instanceof String)) {
            throw new Error("Expected the field `colorSpace` to be a primitive type in the JSON string but got " + data['colorSpace']);
        }
        // ensure the json data is a string
        if (data['dartNormalizeType'] && !(typeof data['dartNormalizeType'] === 'string' || data['dartNormalizeType'] instanceof String)) {
            throw new Error("Expected the field `dartNormalizeType` to be a primitive type in the JSON string but got " + data['dartNormalizeType']);
        }
        // ensure the json data is a string
        if (data['dataFrequency'] && !(typeof data['dataFrequency'] === 'string' || data['dataFrequency'] instanceof String)) {
            throw new Error("Expected the field `dataFrequency` to be a primitive type in the JSON string but got " + data['dataFrequency']);
        }
        // ensure the json data is a string
        if (data['dataSplitColumn'] && !(typeof data['dataSplitColumn'] === 'string' || data['dataSplitColumn'] instanceof String)) {
            throw new Error("Expected the field `dataSplitColumn` to be a primitive type in the JSON string but got " + data['dataSplitColumn']);
        }
        // ensure the json data is a string
        if (data['dataSplitMethod'] && !(typeof data['dataSplitMethod'] === 'string' || data['dataSplitMethod'] instanceof String)) {
            throw new Error("Expected the field `dataSplitMethod` to be a primitive type in the JSON string but got " + data['dataSplitMethod']);
        }
        // ensure the json data is a string
        if (data['distanceType'] && !(typeof data['distanceType'] === 'string' || data['distanceType'] instanceof String)) {
            throw new Error("Expected the field `distanceType` to be a primitive type in the JSON string but got " + data['distanceType']);
        }
        // ensure the json data is a string
        if (data['feedbackType'] && !(typeof data['feedbackType'] === 'string' || data['feedbackType'] instanceof String)) {
            throw new Error("Expected the field `feedbackType` to be a primitive type in the JSON string but got " + data['feedbackType']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['hiddenUnits'])) {
            throw new Error("Expected the field `hiddenUnits` to be an array in the JSON data but got " + data['hiddenUnits']);
        }
        // ensure the json data is a string
        if (data['holidayRegion'] && !(typeof data['holidayRegion'] === 'string' || data['holidayRegion'] instanceof String)) {
            throw new Error("Expected the field `holidayRegion` to be a primitive type in the JSON string but got " + data['holidayRegion']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['holidayRegions'])) {
            throw new Error("Expected the field `holidayRegions` to be an array in the JSON data but got " + data['holidayRegions']);
        }
        // ensure the json data is a string
        if (data['horizon'] && !(typeof data['horizon'] === 'string' || data['horizon'] instanceof String)) {
            throw new Error("Expected the field `horizon` to be a primitive type in the JSON string but got " + data['horizon']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['hparamTuningObjectives'])) {
            throw new Error("Expected the field `hparamTuningObjectives` to be an array in the JSON data but got " + data['hparamTuningObjectives']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['inputLabelColumns'])) {
            throw new Error("Expected the field `inputLabelColumns` to be an array in the JSON data but got " + data['inputLabelColumns']);
        }
        // ensure the json data is a string
        if (data['instanceWeightColumn'] && !(typeof data['instanceWeightColumn'] === 'string' || data['instanceWeightColumn'] instanceof String)) {
            throw new Error("Expected the field `instanceWeightColumn` to be a primitive type in the JSON string but got " + data['instanceWeightColumn']);
        }
        // ensure the json data is a string
        if (data['integratedGradientsNumSteps'] && !(typeof data['integratedGradientsNumSteps'] === 'string' || data['integratedGradientsNumSteps'] instanceof String)) {
            throw new Error("Expected the field `integratedGradientsNumSteps` to be a primitive type in the JSON string but got " + data['integratedGradientsNumSteps']);
        }
        // ensure the json data is a string
        if (data['itemColumn'] && !(typeof data['itemColumn'] === 'string' || data['itemColumn'] instanceof String)) {
            throw new Error("Expected the field `itemColumn` to be a primitive type in the JSON string but got " + data['itemColumn']);
        }
        // ensure the json data is a string
        if (data['kmeansInitializationColumn'] && !(typeof data['kmeansInitializationColumn'] === 'string' || data['kmeansInitializationColumn'] instanceof String)) {
            throw new Error("Expected the field `kmeansInitializationColumn` to be a primitive type in the JSON string but got " + data['kmeansInitializationColumn']);
        }
        // ensure the json data is a string
        if (data['kmeansInitializationMethod'] && !(typeof data['kmeansInitializationMethod'] === 'string' || data['kmeansInitializationMethod'] instanceof String)) {
            throw new Error("Expected the field `kmeansInitializationMethod` to be a primitive type in the JSON string but got " + data['kmeansInitializationMethod']);
        }
        // ensure the json data is a string
        if (data['learnRateStrategy'] && !(typeof data['learnRateStrategy'] === 'string' || data['learnRateStrategy'] instanceof String)) {
            throw new Error("Expected the field `learnRateStrategy` to be a primitive type in the JSON string but got " + data['learnRateStrategy']);
        }
        // ensure the json data is a string
        if (data['lossType'] && !(typeof data['lossType'] === 'string' || data['lossType'] instanceof String)) {
            throw new Error("Expected the field `lossType` to be a primitive type in the JSON string but got " + data['lossType']);
        }
        // ensure the json data is a string
        if (data['maxIterations'] && !(typeof data['maxIterations'] === 'string' || data['maxIterations'] instanceof String)) {
            throw new Error("Expected the field `maxIterations` to be a primitive type in the JSON string but got " + data['maxIterations']);
        }
        // ensure the json data is a string
        if (data['maxParallelTrials'] && !(typeof data['maxParallelTrials'] === 'string' || data['maxParallelTrials'] instanceof String)) {
            throw new Error("Expected the field `maxParallelTrials` to be a primitive type in the JSON string but got " + data['maxParallelTrials']);
        }
        // ensure the json data is a string
        if (data['maxTimeSeriesLength'] && !(typeof data['maxTimeSeriesLength'] === 'string' || data['maxTimeSeriesLength'] instanceof String)) {
            throw new Error("Expected the field `maxTimeSeriesLength` to be a primitive type in the JSON string but got " + data['maxTimeSeriesLength']);
        }
        // ensure the json data is a string
        if (data['maxTreeDepth'] && !(typeof data['maxTreeDepth'] === 'string' || data['maxTreeDepth'] instanceof String)) {
            throw new Error("Expected the field `maxTreeDepth` to be a primitive type in the JSON string but got " + data['maxTreeDepth']);
        }
        // ensure the json data is a string
        if (data['minTimeSeriesLength'] && !(typeof data['minTimeSeriesLength'] === 'string' || data['minTimeSeriesLength'] instanceof String)) {
            throw new Error("Expected the field `minTimeSeriesLength` to be a primitive type in the JSON string but got " + data['minTimeSeriesLength']);
        }
        // ensure the json data is a string
        if (data['minTreeChildWeight'] && !(typeof data['minTreeChildWeight'] === 'string' || data['minTreeChildWeight'] instanceof String)) {
            throw new Error("Expected the field `minTreeChildWeight` to be a primitive type in the JSON string but got " + data['minTreeChildWeight']);
        }
        // ensure the json data is a string
        if (data['modelRegistry'] && !(typeof data['modelRegistry'] === 'string' || data['modelRegistry'] instanceof String)) {
            throw new Error("Expected the field `modelRegistry` to be a primitive type in the JSON string but got " + data['modelRegistry']);
        }
        // ensure the json data is a string
        if (data['modelUri'] && !(typeof data['modelUri'] === 'string' || data['modelUri'] instanceof String)) {
            throw new Error("Expected the field `modelUri` to be a primitive type in the JSON string but got " + data['modelUri']);
        }
        // validate the optional field `nonSeasonalOrder`
        if (data['nonSeasonalOrder']) { // data not null
          ArimaOrder.validateJSON(data['nonSeasonalOrder']);
        }
        // ensure the json data is a string
        if (data['numClusters'] && !(typeof data['numClusters'] === 'string' || data['numClusters'] instanceof String)) {
            throw new Error("Expected the field `numClusters` to be a primitive type in the JSON string but got " + data['numClusters']);
        }
        // ensure the json data is a string
        if (data['numFactors'] && !(typeof data['numFactors'] === 'string' || data['numFactors'] instanceof String)) {
            throw new Error("Expected the field `numFactors` to be a primitive type in the JSON string but got " + data['numFactors']);
        }
        // ensure the json data is a string
        if (data['numParallelTree'] && !(typeof data['numParallelTree'] === 'string' || data['numParallelTree'] instanceof String)) {
            throw new Error("Expected the field `numParallelTree` to be a primitive type in the JSON string but got " + data['numParallelTree']);
        }
        // ensure the json data is a string
        if (data['numPrincipalComponents'] && !(typeof data['numPrincipalComponents'] === 'string' || data['numPrincipalComponents'] instanceof String)) {
            throw new Error("Expected the field `numPrincipalComponents` to be a primitive type in the JSON string but got " + data['numPrincipalComponents']);
        }
        // ensure the json data is a string
        if (data['numTrials'] && !(typeof data['numTrials'] === 'string' || data['numTrials'] instanceof String)) {
            throw new Error("Expected the field `numTrials` to be a primitive type in the JSON string but got " + data['numTrials']);
        }
        // ensure the json data is a string
        if (data['optimizationStrategy'] && !(typeof data['optimizationStrategy'] === 'string' || data['optimizationStrategy'] instanceof String)) {
            throw new Error("Expected the field `optimizationStrategy` to be a primitive type in the JSON string but got " + data['optimizationStrategy']);
        }
        // ensure the json data is a string
        if (data['optimizer'] && !(typeof data['optimizer'] === 'string' || data['optimizer'] instanceof String)) {
            throw new Error("Expected the field `optimizer` to be a primitive type in the JSON string but got " + data['optimizer']);
        }
        // ensure the json data is a string
        if (data['pcaSolver'] && !(typeof data['pcaSolver'] === 'string' || data['pcaSolver'] instanceof String)) {
            throw new Error("Expected the field `pcaSolver` to be a primitive type in the JSON string but got " + data['pcaSolver']);
        }
        // ensure the json data is a string
        if (data['sampledShapleyNumPaths'] && !(typeof data['sampledShapleyNumPaths'] === 'string' || data['sampledShapleyNumPaths'] instanceof String)) {
            throw new Error("Expected the field `sampledShapleyNumPaths` to be a primitive type in the JSON string but got " + data['sampledShapleyNumPaths']);
        }
        // ensure the json data is a string
        if (data['tfVersion'] && !(typeof data['tfVersion'] === 'string' || data['tfVersion'] instanceof String)) {
            throw new Error("Expected the field `tfVersion` to be a primitive type in the JSON string but got " + data['tfVersion']);
        }
        // ensure the json data is a string
        if (data['timeSeriesDataColumn'] && !(typeof data['timeSeriesDataColumn'] === 'string' || data['timeSeriesDataColumn'] instanceof String)) {
            throw new Error("Expected the field `timeSeriesDataColumn` to be a primitive type in the JSON string but got " + data['timeSeriesDataColumn']);
        }
        // ensure the json data is a string
        if (data['timeSeriesIdColumn'] && !(typeof data['timeSeriesIdColumn'] === 'string' || data['timeSeriesIdColumn'] instanceof String)) {
            throw new Error("Expected the field `timeSeriesIdColumn` to be a primitive type in the JSON string but got " + data['timeSeriesIdColumn']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['timeSeriesIdColumns'])) {
            throw new Error("Expected the field `timeSeriesIdColumns` to be an array in the JSON data but got " + data['timeSeriesIdColumns']);
        }
        // ensure the json data is a string
        if (data['timeSeriesTimestampColumn'] && !(typeof data['timeSeriesTimestampColumn'] === 'string' || data['timeSeriesTimestampColumn'] instanceof String)) {
            throw new Error("Expected the field `timeSeriesTimestampColumn` to be a primitive type in the JSON string but got " + data['timeSeriesTimestampColumn']);
        }
        // ensure the json data is a string
        if (data['treeMethod'] && !(typeof data['treeMethod'] === 'string' || data['treeMethod'] instanceof String)) {
            throw new Error("Expected the field `treeMethod` to be a primitive type in the JSON string but got " + data['treeMethod']);
        }
        // ensure the json data is a string
        if (data['trendSmoothingWindowSize'] && !(typeof data['trendSmoothingWindowSize'] === 'string' || data['trendSmoothingWindowSize'] instanceof String)) {
            throw new Error("Expected the field `trendSmoothingWindowSize` to be a primitive type in the JSON string but got " + data['trendSmoothingWindowSize']);
        }
        // ensure the json data is a string
        if (data['userColumn'] && !(typeof data['userColumn'] === 'string' || data['userColumn'] instanceof String)) {
            throw new Error("Expected the field `userColumn` to be a primitive type in the JSON string but got " + data['userColumn']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['vertexAiModelVersionAliases'])) {
            throw new Error("Expected the field `vertexAiModelVersionAliases` to be an array in the JSON data but got " + data['vertexAiModelVersionAliases']);
        }
        // ensure the json data is a string
        if (data['xgboostVersion'] && !(typeof data['xgboostVersion'] === 'string' || data['xgboostVersion'] instanceof String)) {
            throw new Error("Expected the field `xgboostVersion` to be a primitive type in the JSON string but got " + data['xgboostVersion']);
        }

        return true;
    }


}



/**
 * Activation function of the neural nets.
 * @member {String} activationFn
 */
TrainingOptions.prototype['activationFn'] = undefined;

/**
 * If true, detect step changes and make data adjustment in the input time series.
 * @member {Boolean} adjustStepChanges
 */
TrainingOptions.prototype['adjustStepChanges'] = undefined;

/**
 * Whether to use approximate feature contribution method in XGBoost model explanation for global explain.
 * @member {Boolean} approxGlobalFeatureContrib
 */
TrainingOptions.prototype['approxGlobalFeatureContrib'] = undefined;

/**
 * Whether to enable auto ARIMA or not.
 * @member {Boolean} autoArima
 */
TrainingOptions.prototype['autoArima'] = undefined;

/**
 * The max value of the sum of non-seasonal p and q.
 * @member {String} autoArimaMaxOrder
 */
TrainingOptions.prototype['autoArimaMaxOrder'] = undefined;

/**
 * The min value of the sum of non-seasonal p and q.
 * @member {String} autoArimaMinOrder
 */
TrainingOptions.prototype['autoArimaMinOrder'] = undefined;

/**
 * Whether to calculate class weights automatically based on the popularity of each label.
 * @member {Boolean} autoClassWeights
 */
TrainingOptions.prototype['autoClassWeights'] = undefined;

/**
 * Batch size for dnn models.
 * @member {String} batchSize
 */
TrainingOptions.prototype['batchSize'] = undefined;

/**
 * Booster type for boosted tree models.
 * @member {module:model/TrainingOptions.BoosterTypeEnum} boosterType
 */
TrainingOptions.prototype['boosterType'] = undefined;

/**
 * Budget in hours for AutoML training.
 * @member {Number} budgetHours
 */
TrainingOptions.prototype['budgetHours'] = undefined;

/**
 * Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.
 * @member {Boolean} calculatePValues
 */
TrainingOptions.prototype['calculatePValues'] = undefined;

/**
 * Categorical feature encoding method.
 * @member {module:model/TrainingOptions.CategoryEncodingMethodEnum} categoryEncodingMethod
 */
TrainingOptions.prototype['categoryEncodingMethod'] = undefined;

/**
 * If true, clean spikes and dips in the input time series.
 * @member {Boolean} cleanSpikesAndDips
 */
TrainingOptions.prototype['cleanSpikesAndDips'] = undefined;

/**
 * Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
 * @member {module:model/TrainingOptions.ColorSpaceEnum} colorSpace
 */
TrainingOptions.prototype['colorSpace'] = undefined;

/**
 * Subsample ratio of columns for each level for boosted tree models.
 * @member {Number} colsampleBylevel
 */
TrainingOptions.prototype['colsampleBylevel'] = undefined;

/**
 * Subsample ratio of columns for each node(split) for boosted tree models.
 * @member {Number} colsampleBynode
 */
TrainingOptions.prototype['colsampleBynode'] = undefined;

/**
 * Subsample ratio of columns when constructing each tree for boosted tree models.
 * @member {Number} colsampleBytree
 */
TrainingOptions.prototype['colsampleBytree'] = undefined;

/**
 * Type of normalization algorithm for boosted tree models using dart booster.
 * @member {module:model/TrainingOptions.DartNormalizeTypeEnum} dartNormalizeType
 */
TrainingOptions.prototype['dartNormalizeType'] = undefined;

/**
 * The data frequency of a time series.
 * @member {module:model/TrainingOptions.DataFrequencyEnum} dataFrequency
 */
TrainingOptions.prototype['dataFrequency'] = undefined;

/**
 * The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
 * @member {String} dataSplitColumn
 */
TrainingOptions.prototype['dataSplitColumn'] = undefined;

/**
 * The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
 * @member {Number} dataSplitEvalFraction
 */
TrainingOptions.prototype['dataSplitEvalFraction'] = undefined;

/**
 * The data split type for training and evaluation, e.g. RANDOM.
 * @member {module:model/TrainingOptions.DataSplitMethodEnum} dataSplitMethod
 */
TrainingOptions.prototype['dataSplitMethod'] = undefined;

/**
 * If true, perform decompose time series and save the results.
 * @member {Boolean} decomposeTimeSeries
 */
TrainingOptions.prototype['decomposeTimeSeries'] = undefined;

/**
 * Distance type for clustering models.
 * @member {module:model/TrainingOptions.DistanceTypeEnum} distanceType
 */
TrainingOptions.prototype['distanceType'] = undefined;

/**
 * Dropout probability for dnn models.
 * @member {Number} dropout
 */
TrainingOptions.prototype['dropout'] = undefined;

/**
 * Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
 * @member {Boolean} earlyStop
 */
TrainingOptions.prototype['earlyStop'] = undefined;

/**
 * If true, enable global explanation during training.
 * @member {Boolean} enableGlobalExplain
 */
TrainingOptions.prototype['enableGlobalExplain'] = undefined;

/**
 * Feedback type that specifies which algorithm to run for matrix factorization.
 * @member {module:model/TrainingOptions.FeedbackTypeEnum} feedbackType
 */
TrainingOptions.prototype['feedbackType'] = undefined;

/**
 * Whether the model should include intercept during model training.
 * @member {Boolean} fitIntercept
 */
TrainingOptions.prototype['fitIntercept'] = undefined;

/**
 * Hidden units for dnn models.
 * @member {Array.<String>} hiddenUnits
 */
TrainingOptions.prototype['hiddenUnits'] = undefined;

/**
 * The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
 * @member {module:model/TrainingOptions.HolidayRegionEnum} holidayRegion
 */
TrainingOptions.prototype['holidayRegion'] = undefined;

/**
 * A list of geographical regions that are used for time series modeling.
 * @member {Array.<module:model/TrainingOptions.HolidayRegionsEnum>} holidayRegions
 */
TrainingOptions.prototype['holidayRegions'] = undefined;

/**
 * The number of periods ahead that need to be forecasted.
 * @member {String} horizon
 */
TrainingOptions.prototype['horizon'] = undefined;

/**
 * The target evaluation metrics to optimize the hyperparameters for.
 * @member {Array.<module:model/TrainingOptions.HparamTuningObjectivesEnum>} hparamTuningObjectives
 */
TrainingOptions.prototype['hparamTuningObjectives'] = undefined;

/**
 * Include drift when fitting an ARIMA model.
 * @member {Boolean} includeDrift
 */
TrainingOptions.prototype['includeDrift'] = undefined;

/**
 * Specifies the initial learning rate for the line search learn rate strategy.
 * @member {Number} initialLearnRate
 */
TrainingOptions.prototype['initialLearnRate'] = undefined;

/**
 * Name of input label columns in training data.
 * @member {Array.<String>} inputLabelColumns
 */
TrainingOptions.prototype['inputLabelColumns'] = undefined;

/**
 * Name of the instance weight column for training data. This column isn't be used as a feature.
 * @member {String} instanceWeightColumn
 */
TrainingOptions.prototype['instanceWeightColumn'] = undefined;

/**
 * Number of integral steps for the integrated gradients explain method.
 * @member {String} integratedGradientsNumSteps
 */
TrainingOptions.prototype['integratedGradientsNumSteps'] = undefined;

/**
 * Item column specified for matrix factorization models.
 * @member {String} itemColumn
 */
TrainingOptions.prototype['itemColumn'] = undefined;

/**
 * The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
 * @member {String} kmeansInitializationColumn
 */
TrainingOptions.prototype['kmeansInitializationColumn'] = undefined;

/**
 * The method used to initialize the centroids for kmeans algorithm.
 * @member {module:model/TrainingOptions.KmeansInitializationMethodEnum} kmeansInitializationMethod
 */
TrainingOptions.prototype['kmeansInitializationMethod'] = undefined;

/**
 * L1 regularization coefficient to activations.
 * @member {Number} l1RegActivation
 */
TrainingOptions.prototype['l1RegActivation'] = undefined;

/**
 * L1 regularization coefficient.
 * @member {Number} l1Regularization
 */
TrainingOptions.prototype['l1Regularization'] = undefined;

/**
 * L2 regularization coefficient.
 * @member {Number} l2Regularization
 */
TrainingOptions.prototype['l2Regularization'] = undefined;

/**
 * Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
 * @member {Object.<String, Number>} labelClassWeights
 */
TrainingOptions.prototype['labelClassWeights'] = undefined;

/**
 * Learning rate in training. Used only for iterative training algorithms.
 * @member {Number} learnRate
 */
TrainingOptions.prototype['learnRate'] = undefined;

/**
 * The strategy to determine learn rate for the current iteration.
 * @member {module:model/TrainingOptions.LearnRateStrategyEnum} learnRateStrategy
 */
TrainingOptions.prototype['learnRateStrategy'] = undefined;

/**
 * Type of loss function used during training run.
 * @member {module:model/TrainingOptions.LossTypeEnum} lossType
 */
TrainingOptions.prototype['lossType'] = undefined;

/**
 * The maximum number of iterations in training. Used only for iterative training algorithms.
 * @member {String} maxIterations
 */
TrainingOptions.prototype['maxIterations'] = undefined;

/**
 * Maximum number of trials to run in parallel.
 * @member {String} maxParallelTrials
 */
TrainingOptions.prototype['maxParallelTrials'] = undefined;

/**
 * The maximum number of time points in a time series that can be used in modeling the trend component of the time series. Don't use this option with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.
 * @member {String} maxTimeSeriesLength
 */
TrainingOptions.prototype['maxTimeSeriesLength'] = undefined;

/**
 * Maximum depth of a tree for boosted tree models.
 * @member {String} maxTreeDepth
 */
TrainingOptions.prototype['maxTreeDepth'] = undefined;

/**
 * When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.
 * @member {Number} minRelativeProgress
 */
TrainingOptions.prototype['minRelativeProgress'] = undefined;

/**
 * Minimum split loss for boosted tree models.
 * @member {Number} minSplitLoss
 */
TrainingOptions.prototype['minSplitLoss'] = undefined;

/**
 * The minimum number of time points in a time series that are used in modeling the trend component of the time series. If you use this option you must also set the `timeSeriesLengthFraction` option. This training option ensures that enough time points are available when you use `timeSeriesLengthFraction` in trend modeling. This is particularly important when forecasting multiple time series in a single query using `timeSeriesIdColumn`. If the total number of time points is less than the `minTimeSeriesLength` value, then the query uses all available time points.
 * @member {String} minTimeSeriesLength
 */
TrainingOptions.prototype['minTimeSeriesLength'] = undefined;

/**
 * Minimum sum of instance weight needed in a child for boosted tree models.
 * @member {String} minTreeChildWeight
 */
TrainingOptions.prototype['minTreeChildWeight'] = undefined;

/**
 * The model registry.
 * @member {module:model/TrainingOptions.ModelRegistryEnum} modelRegistry
 */
TrainingOptions.prototype['modelRegistry'] = undefined;

/**
 * Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
 * @member {String} modelUri
 */
TrainingOptions.prototype['modelUri'] = undefined;

/**
 * @member {module:model/ArimaOrder} nonSeasonalOrder
 */
TrainingOptions.prototype['nonSeasonalOrder'] = undefined;

/**
 * Number of clusters for clustering models.
 * @member {String} numClusters
 */
TrainingOptions.prototype['numClusters'] = undefined;

/**
 * Num factors specified for matrix factorization models.
 * @member {String} numFactors
 */
TrainingOptions.prototype['numFactors'] = undefined;

/**
 * Number of parallel trees constructed during each iteration for boosted tree models.
 * @member {String} numParallelTree
 */
TrainingOptions.prototype['numParallelTree'] = undefined;

/**
 * Number of principal components to keep in the PCA model. Must be <= the number of features.
 * @member {String} numPrincipalComponents
 */
TrainingOptions.prototype['numPrincipalComponents'] = undefined;

/**
 * Number of trials to run this hyperparameter tuning job.
 * @member {String} numTrials
 */
TrainingOptions.prototype['numTrials'] = undefined;

/**
 * Optimization strategy for training linear regression models.
 * @member {module:model/TrainingOptions.OptimizationStrategyEnum} optimizationStrategy
 */
TrainingOptions.prototype['optimizationStrategy'] = undefined;

/**
 * Optimizer used for training the neural nets.
 * @member {String} optimizer
 */
TrainingOptions.prototype['optimizer'] = undefined;

/**
 * The minimum ratio of cumulative explained variance that needs to be given by the PCA model.
 * @member {Number} pcaExplainedVarianceRatio
 */
TrainingOptions.prototype['pcaExplainedVarianceRatio'] = undefined;

/**
 * The solver for PCA.
 * @member {module:model/TrainingOptions.PcaSolverEnum} pcaSolver
 */
TrainingOptions.prototype['pcaSolver'] = undefined;

/**
 * Number of paths for the sampled Shapley explain method.
 * @member {String} sampledShapleyNumPaths
 */
TrainingOptions.prototype['sampledShapleyNumPaths'] = undefined;

/**
 * If true, scale the feature values by dividing the feature standard deviation. Currently only apply to PCA.
 * @member {Boolean} scaleFeatures
 */
TrainingOptions.prototype['scaleFeatures'] = undefined;

/**
 * Whether to standardize numerical features. Default to true.
 * @member {Boolean} standardizeFeatures
 */
TrainingOptions.prototype['standardizeFeatures'] = undefined;

/**
 * Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
 * @member {Number} subsample
 */
TrainingOptions.prototype['subsample'] = undefined;

/**
 * Based on the selected TF version, the corresponding docker image is used to train external models.
 * @member {String} tfVersion
 */
TrainingOptions.prototype['tfVersion'] = undefined;

/**
 * Column to be designated as time series data for ARIMA model.
 * @member {String} timeSeriesDataColumn
 */
TrainingOptions.prototype['timeSeriesDataColumn'] = undefined;

/**
 * The time series id column that was used during ARIMA model training.
 * @member {String} timeSeriesIdColumn
 */
TrainingOptions.prototype['timeSeriesIdColumn'] = undefined;

/**
 * The time series id columns that were used during ARIMA model training.
 * @member {Array.<String>} timeSeriesIdColumns
 */
TrainingOptions.prototype['timeSeriesIdColumns'] = undefined;

/**
 * The fraction of the interpolated length of the time series that's used to model the time series trend component. All of the time points of the time series are used to model the non-trend component. This training option accelerates modeling training without sacrificing much forecasting accuracy. You can use this option with `minTimeSeriesLength` but not with `maxTimeSeriesLength`.
 * @member {Number} timeSeriesLengthFraction
 */
TrainingOptions.prototype['timeSeriesLengthFraction'] = undefined;

/**
 * Column to be designated as time series timestamp for ARIMA model.
 * @member {String} timeSeriesTimestampColumn
 */
TrainingOptions.prototype['timeSeriesTimestampColumn'] = undefined;

/**
 * Tree construction algorithm for boosted tree models.
 * @member {module:model/TrainingOptions.TreeMethodEnum} treeMethod
 */
TrainingOptions.prototype['treeMethod'] = undefined;

/**
 * Smoothing window size for the trend component. When a positive value is specified, a center moving average smoothing is applied on the history trend. When the smoothing window is out of the boundary at the beginning or the end of the trend, the first element or the last element is padded to fill the smoothing window before the average is applied.
 * @member {String} trendSmoothingWindowSize
 */
TrainingOptions.prototype['trendSmoothingWindowSize'] = undefined;

/**
 * User column specified for matrix factorization models.
 * @member {String} userColumn
 */
TrainingOptions.prototype['userColumn'] = undefined;

/**
 * The version aliases to apply in Vertex AI model registry. Always overwrite if the version aliases exists in a existing model.
 * @member {Array.<String>} vertexAiModelVersionAliases
 */
TrainingOptions.prototype['vertexAiModelVersionAliases'] = undefined;

/**
 * Hyperparameter for matrix factoration when implicit feedback type is specified.
 * @member {Number} walsAlpha
 */
TrainingOptions.prototype['walsAlpha'] = undefined;

/**
 * Whether to train a model from the last checkpoint.
 * @member {Boolean} warmStart
 */
TrainingOptions.prototype['warmStart'] = undefined;

/**
 * User-selected XGBoost versions for training of XGBoost models.
 * @member {String} xgboostVersion
 */
TrainingOptions.prototype['xgboostVersion'] = undefined;





/**
 * Allowed values for the <code>boosterType</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['BoosterTypeEnum'] = {

    /**
     * value: "BOOSTER_TYPE_UNSPECIFIED"
     * @const
     */
    "BOOSTER_TYPE_UNSPECIFIED": "BOOSTER_TYPE_UNSPECIFIED",

    /**
     * value: "GBTREE"
     * @const
     */
    "GBTREE": "GBTREE",

    /**
     * value: "DART"
     * @const
     */
    "DART": "DART"
};


/**
 * Allowed values for the <code>categoryEncodingMethod</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['CategoryEncodingMethodEnum'] = {

    /**
     * value: "ENCODING_METHOD_UNSPECIFIED"
     * @const
     */
    "ENCODING_METHOD_UNSPECIFIED": "ENCODING_METHOD_UNSPECIFIED",

    /**
     * value: "ONE_HOT_ENCODING"
     * @const
     */
    "ONE_HOT_ENCODING": "ONE_HOT_ENCODING",

    /**
     * value: "LABEL_ENCODING"
     * @const
     */
    "LABEL_ENCODING": "LABEL_ENCODING",

    /**
     * value: "DUMMY_ENCODING"
     * @const
     */
    "DUMMY_ENCODING": "DUMMY_ENCODING"
};


/**
 * Allowed values for the <code>colorSpace</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['ColorSpaceEnum'] = {

    /**
     * value: "COLOR_SPACE_UNSPECIFIED"
     * @const
     */
    "COLOR_SPACE_UNSPECIFIED": "COLOR_SPACE_UNSPECIFIED",

    /**
     * value: "RGB"
     * @const
     */
    "RGB": "RGB",

    /**
     * value: "HSV"
     * @const
     */
    "HSV": "HSV",

    /**
     * value: "YIQ"
     * @const
     */
    "YIQ": "YIQ",

    /**
     * value: "YUV"
     * @const
     */
    "YUV": "YUV",

    /**
     * value: "GRAYSCALE"
     * @const
     */
    "GRAYSCALE": "GRAYSCALE"
};


/**
 * Allowed values for the <code>dartNormalizeType</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['DartNormalizeTypeEnum'] = {

    /**
     * value: "DART_NORMALIZE_TYPE_UNSPECIFIED"
     * @const
     */
    "DART_NORMALIZE_TYPE_UNSPECIFIED": "DART_NORMALIZE_TYPE_UNSPECIFIED",

    /**
     * value: "TREE"
     * @const
     */
    "TREE": "TREE",

    /**
     * value: "FOREST"
     * @const
     */
    "FOREST": "FOREST"
};


/**
 * Allowed values for the <code>dataFrequency</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['DataFrequencyEnum'] = {

    /**
     * value: "DATA_FREQUENCY_UNSPECIFIED"
     * @const
     */
    "DATA_FREQUENCY_UNSPECIFIED": "DATA_FREQUENCY_UNSPECIFIED",

    /**
     * value: "AUTO_FREQUENCY"
     * @const
     */
    "AUTO_FREQUENCY": "AUTO_FREQUENCY",

    /**
     * value: "YEARLY"
     * @const
     */
    "YEARLY": "YEARLY",

    /**
     * value: "QUARTERLY"
     * @const
     */
    "QUARTERLY": "QUARTERLY",

    /**
     * value: "MONTHLY"
     * @const
     */
    "MONTHLY": "MONTHLY",

    /**
     * value: "WEEKLY"
     * @const
     */
    "WEEKLY": "WEEKLY",

    /**
     * value: "DAILY"
     * @const
     */
    "DAILY": "DAILY",

    /**
     * value: "HOURLY"
     * @const
     */
    "HOURLY": "HOURLY",

    /**
     * value: "PER_MINUTE"
     * @const
     */
    "PER_MINUTE": "PER_MINUTE"
};


/**
 * Allowed values for the <code>dataSplitMethod</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['DataSplitMethodEnum'] = {

    /**
     * value: "DATA_SPLIT_METHOD_UNSPECIFIED"
     * @const
     */
    "DATA_SPLIT_METHOD_UNSPECIFIED": "DATA_SPLIT_METHOD_UNSPECIFIED",

    /**
     * value: "RANDOM"
     * @const
     */
    "RANDOM": "RANDOM",

    /**
     * value: "CUSTOM"
     * @const
     */
    "CUSTOM": "CUSTOM",

    /**
     * value: "SEQUENTIAL"
     * @const
     */
    "SEQUENTIAL": "SEQUENTIAL",

    /**
     * value: "NO_SPLIT"
     * @const
     */
    "NO_SPLIT": "NO_SPLIT",

    /**
     * value: "AUTO_SPLIT"
     * @const
     */
    "AUTO_SPLIT": "AUTO_SPLIT"
};


/**
 * Allowed values for the <code>distanceType</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['DistanceTypeEnum'] = {

    /**
     * value: "DISTANCE_TYPE_UNSPECIFIED"
     * @const
     */
    "DISTANCE_TYPE_UNSPECIFIED": "DISTANCE_TYPE_UNSPECIFIED",

    /**
     * value: "EUCLIDEAN"
     * @const
     */
    "EUCLIDEAN": "EUCLIDEAN",

    /**
     * value: "COSINE"
     * @const
     */
    "COSINE": "COSINE"
};


/**
 * Allowed values for the <code>feedbackType</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['FeedbackTypeEnum'] = {

    /**
     * value: "FEEDBACK_TYPE_UNSPECIFIED"
     * @const
     */
    "FEEDBACK_TYPE_UNSPECIFIED": "FEEDBACK_TYPE_UNSPECIFIED",

    /**
     * value: "IMPLICIT"
     * @const
     */
    "IMPLICIT": "IMPLICIT",

    /**
     * value: "EXPLICIT"
     * @const
     */
    "EXPLICIT": "EXPLICIT"
};


/**
 * Allowed values for the <code>holidayRegion</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['HolidayRegionEnum'] = {

    /**
     * value: "HOLIDAY_REGION_UNSPECIFIED"
     * @const
     */
    "HOLIDAY_REGION_UNSPECIFIED": "HOLIDAY_REGION_UNSPECIFIED",

    /**
     * value: "GLOBAL"
     * @const
     */
    "GLOBAL": "GLOBAL",

    /**
     * value: "NA"
     * @const
     */
    "NA": "NA",

    /**
     * value: "JAPAC"
     * @const
     */
    "JAPAC": "JAPAC",

    /**
     * value: "EMEA"
     * @const
     */
    "EMEA": "EMEA",

    /**
     * value: "LAC"
     * @const
     */
    "LAC": "LAC",

    /**
     * value: "AE"
     * @const
     */
    "AE": "AE",

    /**
     * value: "AR"
     * @const
     */
    "AR": "AR",

    /**
     * value: "AT"
     * @const
     */
    "AT": "AT",

    /**
     * value: "AU"
     * @const
     */
    "AU": "AU",

    /**
     * value: "BE"
     * @const
     */
    "BE": "BE",

    /**
     * value: "BR"
     * @const
     */
    "BR": "BR",

    /**
     * value: "CA"
     * @const
     */
    "CA": "CA",

    /**
     * value: "CH"
     * @const
     */
    "CH": "CH",

    /**
     * value: "CL"
     * @const
     */
    "CL": "CL",

    /**
     * value: "CN"
     * @const
     */
    "CN": "CN",

    /**
     * value: "CO"
     * @const
     */
    "CO": "CO",

    /**
     * value: "CS"
     * @const
     */
    "CS": "CS",

    /**
     * value: "CZ"
     * @const
     */
    "CZ": "CZ",

    /**
     * value: "DE"
     * @const
     */
    "DE": "DE",

    /**
     * value: "DK"
     * @const
     */
    "DK": "DK",

    /**
     * value: "DZ"
     * @const
     */
    "DZ": "DZ",

    /**
     * value: "EC"
     * @const
     */
    "EC": "EC",

    /**
     * value: "EE"
     * @const
     */
    "EE": "EE",

    /**
     * value: "EG"
     * @const
     */
    "EG": "EG",

    /**
     * value: "ES"
     * @const
     */
    "ES": "ES",

    /**
     * value: "FI"
     * @const
     */
    "FI": "FI",

    /**
     * value: "FR"
     * @const
     */
    "FR": "FR",

    /**
     * value: "GB"
     * @const
     */
    "GB": "GB",

    /**
     * value: "GR"
     * @const
     */
    "GR": "GR",

    /**
     * value: "HK"
     * @const
     */
    "HK": "HK",

    /**
     * value: "HU"
     * @const
     */
    "HU": "HU",

    /**
     * value: "ID"
     * @const
     */
    "ID": "ID",

    /**
     * value: "IE"
     * @const
     */
    "IE": "IE",

    /**
     * value: "IL"
     * @const
     */
    "IL": "IL",

    /**
     * value: "IN"
     * @const
     */
    "IN": "IN",

    /**
     * value: "IR"
     * @const
     */
    "IR": "IR",

    /**
     * value: "IT"
     * @const
     */
    "IT": "IT",

    /**
     * value: "JP"
     * @const
     */
    "JP": "JP",

    /**
     * value: "KR"
     * @const
     */
    "KR": "KR",

    /**
     * value: "LV"
     * @const
     */
    "LV": "LV",

    /**
     * value: "MA"
     * @const
     */
    "MA": "MA",

    /**
     * value: "MX"
     * @const
     */
    "MX": "MX",

    /**
     * value: "MY"
     * @const
     */
    "MY": "MY",

    /**
     * value: "NG"
     * @const
     */
    "NG": "NG",

    /**
     * value: "NL"
     * @const
     */
    "NL": "NL",

    /**
     * value: "false"
     * @const
     */
    "false": "false",

    /**
     * value: "NZ"
     * @const
     */
    "NZ": "NZ",

    /**
     * value: "PE"
     * @const
     */
    "PE": "PE",

    /**
     * value: "PH"
     * @const
     */
    "PH": "PH",

    /**
     * value: "PK"
     * @const
     */
    "PK": "PK",

    /**
     * value: "PL"
     * @const
     */
    "PL": "PL",

    /**
     * value: "PT"
     * @const
     */
    "PT": "PT",

    /**
     * value: "RO"
     * @const
     */
    "RO": "RO",

    /**
     * value: "RS"
     * @const
     */
    "RS": "RS",

    /**
     * value: "RU"
     * @const
     */
    "RU": "RU",

    /**
     * value: "SA"
     * @const
     */
    "SA": "SA",

    /**
     * value: "SE"
     * @const
     */
    "SE": "SE",

    /**
     * value: "SG"
     * @const
     */
    "SG": "SG",

    /**
     * value: "SI"
     * @const
     */
    "SI": "SI",

    /**
     * value: "SK"
     * @const
     */
    "SK": "SK",

    /**
     * value: "TH"
     * @const
     */
    "TH": "TH",

    /**
     * value: "TR"
     * @const
     */
    "TR": "TR",

    /**
     * value: "TW"
     * @const
     */
    "TW": "TW",

    /**
     * value: "UA"
     * @const
     */
    "UA": "UA",

    /**
     * value: "US"
     * @const
     */
    "US": "US",

    /**
     * value: "VE"
     * @const
     */
    "VE": "VE",

    /**
     * value: "VN"
     * @const
     */
    "VN": "VN",

    /**
     * value: "ZA"
     * @const
     */
    "ZA": "ZA"
};


/**
 * Allowed values for the <code>holidayRegions</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['HolidayRegionsEnum'] = {

    /**
     * value: "HOLIDAY_REGION_UNSPECIFIED"
     * @const
     */
    "HOLIDAY_REGION_UNSPECIFIED": "HOLIDAY_REGION_UNSPECIFIED",

    /**
     * value: "GLOBAL"
     * @const
     */
    "GLOBAL": "GLOBAL",

    /**
     * value: "NA"
     * @const
     */
    "NA": "NA",

    /**
     * value: "JAPAC"
     * @const
     */
    "JAPAC": "JAPAC",

    /**
     * value: "EMEA"
     * @const
     */
    "EMEA": "EMEA",

    /**
     * value: "LAC"
     * @const
     */
    "LAC": "LAC",

    /**
     * value: "AE"
     * @const
     */
    "AE": "AE",

    /**
     * value: "AR"
     * @const
     */
    "AR": "AR",

    /**
     * value: "AT"
     * @const
     */
    "AT": "AT",

    /**
     * value: "AU"
     * @const
     */
    "AU": "AU",

    /**
     * value: "BE"
     * @const
     */
    "BE": "BE",

    /**
     * value: "BR"
     * @const
     */
    "BR": "BR",

    /**
     * value: "CA"
     * @const
     */
    "CA": "CA",

    /**
     * value: "CH"
     * @const
     */
    "CH": "CH",

    /**
     * value: "CL"
     * @const
     */
    "CL": "CL",

    /**
     * value: "CN"
     * @const
     */
    "CN": "CN",

    /**
     * value: "CO"
     * @const
     */
    "CO": "CO",

    /**
     * value: "CS"
     * @const
     */
    "CS": "CS",

    /**
     * value: "CZ"
     * @const
     */
    "CZ": "CZ",

    /**
     * value: "DE"
     * @const
     */
    "DE": "DE",

    /**
     * value: "DK"
     * @const
     */
    "DK": "DK",

    /**
     * value: "DZ"
     * @const
     */
    "DZ": "DZ",

    /**
     * value: "EC"
     * @const
     */
    "EC": "EC",

    /**
     * value: "EE"
     * @const
     */
    "EE": "EE",

    /**
     * value: "EG"
     * @const
     */
    "EG": "EG",

    /**
     * value: "ES"
     * @const
     */
    "ES": "ES",

    /**
     * value: "FI"
     * @const
     */
    "FI": "FI",

    /**
     * value: "FR"
     * @const
     */
    "FR": "FR",

    /**
     * value: "GB"
     * @const
     */
    "GB": "GB",

    /**
     * value: "GR"
     * @const
     */
    "GR": "GR",

    /**
     * value: "HK"
     * @const
     */
    "HK": "HK",

    /**
     * value: "HU"
     * @const
     */
    "HU": "HU",

    /**
     * value: "ID"
     * @const
     */
    "ID": "ID",

    /**
     * value: "IE"
     * @const
     */
    "IE": "IE",

    /**
     * value: "IL"
     * @const
     */
    "IL": "IL",

    /**
     * value: "IN"
     * @const
     */
    "IN": "IN",

    /**
     * value: "IR"
     * @const
     */
    "IR": "IR",

    /**
     * value: "IT"
     * @const
     */
    "IT": "IT",

    /**
     * value: "JP"
     * @const
     */
    "JP": "JP",

    /**
     * value: "KR"
     * @const
     */
    "KR": "KR",

    /**
     * value: "LV"
     * @const
     */
    "LV": "LV",

    /**
     * value: "MA"
     * @const
     */
    "MA": "MA",

    /**
     * value: "MX"
     * @const
     */
    "MX": "MX",

    /**
     * value: "MY"
     * @const
     */
    "MY": "MY",

    /**
     * value: "NG"
     * @const
     */
    "NG": "NG",

    /**
     * value: "NL"
     * @const
     */
    "NL": "NL",

    /**
     * value: "false"
     * @const
     */
    "false": "false",

    /**
     * value: "NZ"
     * @const
     */
    "NZ": "NZ",

    /**
     * value: "PE"
     * @const
     */
    "PE": "PE",

    /**
     * value: "PH"
     * @const
     */
    "PH": "PH",

    /**
     * value: "PK"
     * @const
     */
    "PK": "PK",

    /**
     * value: "PL"
     * @const
     */
    "PL": "PL",

    /**
     * value: "PT"
     * @const
     */
    "PT": "PT",

    /**
     * value: "RO"
     * @const
     */
    "RO": "RO",

    /**
     * value: "RS"
     * @const
     */
    "RS": "RS",

    /**
     * value: "RU"
     * @const
     */
    "RU": "RU",

    /**
     * value: "SA"
     * @const
     */
    "SA": "SA",

    /**
     * value: "SE"
     * @const
     */
    "SE": "SE",

    /**
     * value: "SG"
     * @const
     */
    "SG": "SG",

    /**
     * value: "SI"
     * @const
     */
    "SI": "SI",

    /**
     * value: "SK"
     * @const
     */
    "SK": "SK",

    /**
     * value: "TH"
     * @const
     */
    "TH": "TH",

    /**
     * value: "TR"
     * @const
     */
    "TR": "TR",

    /**
     * value: "TW"
     * @const
     */
    "TW": "TW",

    /**
     * value: "UA"
     * @const
     */
    "UA": "UA",

    /**
     * value: "US"
     * @const
     */
    "US": "US",

    /**
     * value: "VE"
     * @const
     */
    "VE": "VE",

    /**
     * value: "VN"
     * @const
     */
    "VN": "VN",

    /**
     * value: "ZA"
     * @const
     */
    "ZA": "ZA"
};


/**
 * Allowed values for the <code>hparamTuningObjectives</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['HparamTuningObjectivesEnum'] = {

    /**
     * value: "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED"
     * @const
     */
    "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED": "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED",

    /**
     * value: "MEAN_ABSOLUTE_ERROR"
     * @const
     */
    "MEAN_ABSOLUTE_ERROR": "MEAN_ABSOLUTE_ERROR",

    /**
     * value: "MEAN_SQUARED_ERROR"
     * @const
     */
    "MEAN_SQUARED_ERROR": "MEAN_SQUARED_ERROR",

    /**
     * value: "MEAN_SQUARED_LOG_ERROR"
     * @const
     */
    "MEAN_SQUARED_LOG_ERROR": "MEAN_SQUARED_LOG_ERROR",

    /**
     * value: "MEDIAN_ABSOLUTE_ERROR"
     * @const
     */
    "MEDIAN_ABSOLUTE_ERROR": "MEDIAN_ABSOLUTE_ERROR",

    /**
     * value: "R_SQUARED"
     * @const
     */
    "R_SQUARED": "R_SQUARED",

    /**
     * value: "EXPLAINED_VARIANCE"
     * @const
     */
    "EXPLAINED_VARIANCE": "EXPLAINED_VARIANCE",

    /**
     * value: "PRECISION"
     * @const
     */
    "PRECISION": "PRECISION",

    /**
     * value: "RECALL"
     * @const
     */
    "RECALL": "RECALL",

    /**
     * value: "ACCURACY"
     * @const
     */
    "ACCURACY": "ACCURACY",

    /**
     * value: "F1_SCORE"
     * @const
     */
    "F1_SCORE": "F1_SCORE",

    /**
     * value: "LOG_LOSS"
     * @const
     */
    "LOG_LOSS": "LOG_LOSS",

    /**
     * value: "ROC_AUC"
     * @const
     */
    "ROC_AUC": "ROC_AUC",

    /**
     * value: "DAVIES_BOULDIN_INDEX"
     * @const
     */
    "DAVIES_BOULDIN_INDEX": "DAVIES_BOULDIN_INDEX",

    /**
     * value: "MEAN_AVERAGE_PRECISION"
     * @const
     */
    "MEAN_AVERAGE_PRECISION": "MEAN_AVERAGE_PRECISION",

    /**
     * value: "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN"
     * @const
     */
    "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN": "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN",

    /**
     * value: "AVERAGE_RANK"
     * @const
     */
    "AVERAGE_RANK": "AVERAGE_RANK"
};


/**
 * Allowed values for the <code>kmeansInitializationMethod</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['KmeansInitializationMethodEnum'] = {

    /**
     * value: "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED"
     * @const
     */
    "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED": "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED",

    /**
     * value: "RANDOM"
     * @const
     */
    "RANDOM": "RANDOM",

    /**
     * value: "CUSTOM"
     * @const
     */
    "CUSTOM": "CUSTOM",

    /**
     * value: "KMEANS_PLUS_PLUS"
     * @const
     */
    "KMEANS_PLUS_PLUS": "KMEANS_PLUS_PLUS"
};


/**
 * Allowed values for the <code>learnRateStrategy</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['LearnRateStrategyEnum'] = {

    /**
     * value: "LEARN_RATE_STRATEGY_UNSPECIFIED"
     * @const
     */
    "LEARN_RATE_STRATEGY_UNSPECIFIED": "LEARN_RATE_STRATEGY_UNSPECIFIED",

    /**
     * value: "LINE_SEARCH"
     * @const
     */
    "LINE_SEARCH": "LINE_SEARCH",

    /**
     * value: "CONSTANT"
     * @const
     */
    "CONSTANT": "CONSTANT"
};


/**
 * Allowed values for the <code>lossType</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['LossTypeEnum'] = {

    /**
     * value: "LOSS_TYPE_UNSPECIFIED"
     * @const
     */
    "LOSS_TYPE_UNSPECIFIED": "LOSS_TYPE_UNSPECIFIED",

    /**
     * value: "MEAN_SQUARED_LOSS"
     * @const
     */
    "MEAN_SQUARED_LOSS": "MEAN_SQUARED_LOSS",

    /**
     * value: "MEAN_LOG_LOSS"
     * @const
     */
    "MEAN_LOG_LOSS": "MEAN_LOG_LOSS"
};


/**
 * Allowed values for the <code>modelRegistry</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['ModelRegistryEnum'] = {

    /**
     * value: "MODEL_REGISTRY_UNSPECIFIED"
     * @const
     */
    "MODEL_REGISTRY_UNSPECIFIED": "MODEL_REGISTRY_UNSPECIFIED",

    /**
     * value: "VERTEX_AI"
     * @const
     */
    "VERTEX_AI": "VERTEX_AI"
};


/**
 * Allowed values for the <code>optimizationStrategy</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['OptimizationStrategyEnum'] = {

    /**
     * value: "OPTIMIZATION_STRATEGY_UNSPECIFIED"
     * @const
     */
    "OPTIMIZATION_STRATEGY_UNSPECIFIED": "OPTIMIZATION_STRATEGY_UNSPECIFIED",

    /**
     * value: "BATCH_GRADIENT_DESCENT"
     * @const
     */
    "BATCH_GRADIENT_DESCENT": "BATCH_GRADIENT_DESCENT",

    /**
     * value: "NORMAL_EQUATION"
     * @const
     */
    "NORMAL_EQUATION": "NORMAL_EQUATION"
};


/**
 * Allowed values for the <code>pcaSolver</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['PcaSolverEnum'] = {

    /**
     * value: "UNSPECIFIED"
     * @const
     */
    "UNSPECIFIED": "UNSPECIFIED",

    /**
     * value: "FULL"
     * @const
     */
    "FULL": "FULL",

    /**
     * value: "RANDOMIZED"
     * @const
     */
    "RANDOMIZED": "RANDOMIZED",

    /**
     * value: "AUTO"
     * @const
     */
    "AUTO": "AUTO"
};


/**
 * Allowed values for the <code>treeMethod</code> property.
 * @enum {String}
 * @readonly
 */
TrainingOptions['TreeMethodEnum'] = {

    /**
     * value: "TREE_METHOD_UNSPECIFIED"
     * @const
     */
    "TREE_METHOD_UNSPECIFIED": "TREE_METHOD_UNSPECIFIED",

    /**
     * value: "AUTO"
     * @const
     */
    "AUTO": "AUTO",

    /**
     * value: "EXACT"
     * @const
     */
    "EXACT": "EXACT",

    /**
     * value: "APPROX"
     * @const
     */
    "APPROX": "APPROX",

    /**
     * value: "HIST"
     * @const
     */
    "HIST": "HIST"
};



export default TrainingOptions;

