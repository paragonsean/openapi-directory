/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ConnectionProperty from './ConnectionProperty';
import DataFormatOptions from './DataFormatOptions';
import DatasetReference from './DatasetReference';
import QueryParameter from './QueryParameter';

/**
 * The QueryRequest model module.
 * @module model/QueryRequest
 * @version v2
 */
class QueryRequest {
    /**
     * Constructs a new <code>QueryRequest</code>.
     * Describes the format of the jobs.query request.
     * @alias module:model/QueryRequest
     */
    constructor() { 
        
        QueryRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
        obj['kind'] = 'bigquery#queryRequest';
        obj['useLegacySql'] = true;
        obj['useQueryCache'] = true;
    }

    /**
     * Constructs a <code>QueryRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/QueryRequest} obj Optional instance to populate.
     * @return {module:model/QueryRequest} The populated <code>QueryRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new QueryRequest();

            if (data.hasOwnProperty('connectionProperties')) {
                obj['connectionProperties'] = ApiClient.convertToType(data['connectionProperties'], [ConnectionProperty]);
            }
            if (data.hasOwnProperty('continuous')) {
                obj['continuous'] = ApiClient.convertToType(data['continuous'], 'Boolean');
            }
            if (data.hasOwnProperty('createSession')) {
                obj['createSession'] = ApiClient.convertToType(data['createSession'], 'Boolean');
            }
            if (data.hasOwnProperty('defaultDataset')) {
                obj['defaultDataset'] = DatasetReference.constructFromObject(data['defaultDataset']);
            }
            if (data.hasOwnProperty('dryRun')) {
                obj['dryRun'] = ApiClient.convertToType(data['dryRun'], 'Boolean');
            }
            if (data.hasOwnProperty('formatOptions')) {
                obj['formatOptions'] = DataFormatOptions.constructFromObject(data['formatOptions']);
            }
            if (data.hasOwnProperty('jobCreationMode')) {
                obj['jobCreationMode'] = ApiClient.convertToType(data['jobCreationMode'], 'String');
            }
            if (data.hasOwnProperty('kind')) {
                obj['kind'] = ApiClient.convertToType(data['kind'], 'String');
            }
            if (data.hasOwnProperty('labels')) {
                obj['labels'] = ApiClient.convertToType(data['labels'], {'String': 'String'});
            }
            if (data.hasOwnProperty('location')) {
                obj['location'] = ApiClient.convertToType(data['location'], 'String');
            }
            if (data.hasOwnProperty('maxResults')) {
                obj['maxResults'] = ApiClient.convertToType(data['maxResults'], 'Number');
            }
            if (data.hasOwnProperty('maximumBytesBilled')) {
                obj['maximumBytesBilled'] = ApiClient.convertToType(data['maximumBytesBilled'], 'String');
            }
            if (data.hasOwnProperty('parameterMode')) {
                obj['parameterMode'] = ApiClient.convertToType(data['parameterMode'], 'String');
            }
            if (data.hasOwnProperty('preserveNulls')) {
                obj['preserveNulls'] = ApiClient.convertToType(data['preserveNulls'], 'Boolean');
            }
            if (data.hasOwnProperty('query')) {
                obj['query'] = ApiClient.convertToType(data['query'], 'String');
            }
            if (data.hasOwnProperty('queryParameters')) {
                obj['queryParameters'] = ApiClient.convertToType(data['queryParameters'], [QueryParameter]);
            }
            if (data.hasOwnProperty('requestId')) {
                obj['requestId'] = ApiClient.convertToType(data['requestId'], 'String');
            }
            if (data.hasOwnProperty('timeoutMs')) {
                obj['timeoutMs'] = ApiClient.convertToType(data['timeoutMs'], 'Number');
            }
            if (data.hasOwnProperty('useLegacySql')) {
                obj['useLegacySql'] = ApiClient.convertToType(data['useLegacySql'], 'Boolean');
            }
            if (data.hasOwnProperty('useQueryCache')) {
                obj['useQueryCache'] = ApiClient.convertToType(data['useQueryCache'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>QueryRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>QueryRequest</code>.
     */
    static validateJSON(data) {
        if (data['connectionProperties']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['connectionProperties'])) {
                throw new Error("Expected the field `connectionProperties` to be an array in the JSON data but got " + data['connectionProperties']);
            }
            // validate the optional field `connectionProperties` (array)
            for (const item of data['connectionProperties']) {
                ConnectionProperty.validateJSON(item);
            };
        }
        // validate the optional field `defaultDataset`
        if (data['defaultDataset']) { // data not null
          DatasetReference.validateJSON(data['defaultDataset']);
        }
        // validate the optional field `formatOptions`
        if (data['formatOptions']) { // data not null
          DataFormatOptions.validateJSON(data['formatOptions']);
        }
        // ensure the json data is a string
        if (data['jobCreationMode'] && !(typeof data['jobCreationMode'] === 'string' || data['jobCreationMode'] instanceof String)) {
            throw new Error("Expected the field `jobCreationMode` to be a primitive type in the JSON string but got " + data['jobCreationMode']);
        }
        // ensure the json data is a string
        if (data['kind'] && !(typeof data['kind'] === 'string' || data['kind'] instanceof String)) {
            throw new Error("Expected the field `kind` to be a primitive type in the JSON string but got " + data['kind']);
        }
        // ensure the json data is a string
        if (data['location'] && !(typeof data['location'] === 'string' || data['location'] instanceof String)) {
            throw new Error("Expected the field `location` to be a primitive type in the JSON string but got " + data['location']);
        }
        // ensure the json data is a string
        if (data['maximumBytesBilled'] && !(typeof data['maximumBytesBilled'] === 'string' || data['maximumBytesBilled'] instanceof String)) {
            throw new Error("Expected the field `maximumBytesBilled` to be a primitive type in the JSON string but got " + data['maximumBytesBilled']);
        }
        // ensure the json data is a string
        if (data['parameterMode'] && !(typeof data['parameterMode'] === 'string' || data['parameterMode'] instanceof String)) {
            throw new Error("Expected the field `parameterMode` to be a primitive type in the JSON string but got " + data['parameterMode']);
        }
        // ensure the json data is a string
        if (data['query'] && !(typeof data['query'] === 'string' || data['query'] instanceof String)) {
            throw new Error("Expected the field `query` to be a primitive type in the JSON string but got " + data['query']);
        }
        if (data['queryParameters']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['queryParameters'])) {
                throw new Error("Expected the field `queryParameters` to be an array in the JSON data but got " + data['queryParameters']);
            }
            // validate the optional field `queryParameters` (array)
            for (const item of data['queryParameters']) {
                QueryParameter.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['requestId'] && !(typeof data['requestId'] === 'string' || data['requestId'] instanceof String)) {
            throw new Error("Expected the field `requestId` to be a primitive type in the JSON string but got " + data['requestId']);
        }

        return true;
    }


}



/**
 * Optional. Connection properties which can modify the query behavior.
 * @member {Array.<module:model/ConnectionProperty>} connectionProperties
 */
QueryRequest.prototype['connectionProperties'] = undefined;

/**
 * [Optional] Specifies whether the query should be executed as a continuous query. The default value is false.
 * @member {Boolean} continuous
 */
QueryRequest.prototype['continuous'] = undefined;

/**
 * Optional. If true, creates a new session using a randomly generated session_id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode. The session location will be set to QueryRequest.location if it is present, otherwise it's set to the default location based on existing routing logic.
 * @member {Boolean} createSession
 */
QueryRequest.prototype['createSession'] = undefined;

/**
 * @member {module:model/DatasetReference} defaultDataset
 */
QueryRequest.prototype['defaultDataset'] = undefined;

/**
 * Optional. If set to true, BigQuery doesn't run the job. Instead, if the query is valid, BigQuery returns statistics about the job such as how many bytes would be processed. If the query is invalid, an error returns. The default value is false.
 * @member {Boolean} dryRun
 */
QueryRequest.prototype['dryRun'] = undefined;

/**
 * @member {module:model/DataFormatOptions} formatOptions
 */
QueryRequest.prototype['formatOptions'] = undefined;

/**
 * Optional. If not set, jobs are always required. If set, the query request will follow the behavior described JobCreationMode. This feature is not yet available. Jobs will always be created.
 * @member {module:model/QueryRequest.JobCreationModeEnum} jobCreationMode
 */
QueryRequest.prototype['jobCreationMode'] = undefined;

/**
 * The resource type of the request.
 * @member {String} kind
 * @default 'bigquery#queryRequest'
 */
QueryRequest.prototype['kind'] = 'bigquery#queryRequest';

/**
 * Optional. The labels associated with this query. Labels can be used to organize and group query jobs. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label keys must start with a letter and each label in the list must have a different key.
 * @member {Object.<String, String>} labels
 */
QueryRequest.prototype['labels'] = undefined;

/**
 * The geographic location where the job should run. See details at https://cloud.google.com/bigquery/docs/locations#specifying_your_location.
 * @member {String} location
 */
QueryRequest.prototype['location'] = undefined;

/**
 * Optional. The maximum number of rows of data to return per page of results. Setting this flag to a small value such as 1000 and then paging through results might improve reliability when the query result set is large. In addition to this limit, responses are also limited to 10 MB. By default, there is no maximum row count, and only the byte limit applies.
 * @member {Number} maxResults
 */
QueryRequest.prototype['maxResults'] = undefined;

/**
 * Optional. Limits the bytes billed for this query. Queries with bytes billed above this limit will fail (without incurring a charge). If unspecified, the project default is used.
 * @member {String} maximumBytesBilled
 */
QueryRequest.prototype['maximumBytesBilled'] = undefined;

/**
 * GoogleSQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
 * @member {String} parameterMode
 */
QueryRequest.prototype['parameterMode'] = undefined;

/**
 * This property is deprecated.
 * @member {Boolean} preserveNulls
 */
QueryRequest.prototype['preserveNulls'] = undefined;

/**
 * Required. A query string to execute, using Google Standard SQL or legacy SQL syntax. Example: \"SELECT COUNT(f1) FROM myProjectId.myDatasetId.myTableId\".
 * @member {String} query
 */
QueryRequest.prototype['query'] = undefined;

/**
 * Query parameters for GoogleSQL queries.
 * @member {Array.<module:model/QueryParameter>} queryParameters
 */
QueryRequest.prototype['queryParameters'] = undefined;

/**
 * Optional. A unique user provided identifier to ensure idempotent behavior for queries. Note that this is different from the job_id. It has the following properties: 1. It is case-sensitive, limited to up to 36 ASCII characters. A UUID is recommended. 2. Read only queries can ignore this token since they are nullipotent by definition. 3. For the purposes of idempotency ensured by the request_id, a request is considered duplicate of another only if they have the same request_id and are actually duplicates. When determining whether a request is a duplicate of another request, all parameters in the request that may affect the result are considered. For example, query, connection_properties, query_parameters, use_legacy_sql are parameters that affect the result and are considered when determining whether a request is a duplicate, but properties like timeout_ms don't affect the result and are thus not considered. Dry run query requests are never considered duplicate of another request. 4. When a duplicate mutating query request is detected, it returns: a. the results of the mutation if it completes successfully within the timeout. b. the running operation if it is still in progress at the end of the timeout. 5. Its lifetime is limited to 15 minutes. In other words, if two requests are sent with the same request_id, but more than 15 minutes apart, idempotency is not guaranteed.
 * @member {String} requestId
 */
QueryRequest.prototype['requestId'] = undefined;

/**
 * Optional. Optional: Specifies the maximum amount of time, in milliseconds, that the client is willing to wait for the query to complete. By default, this limit is 10 seconds (10,000 milliseconds). If the query is complete, the jobComplete field in the response is true. If the query has not yet completed, jobComplete is false. You can request a longer timeout period in the timeoutMs field. However, the call is not guaranteed to wait for the specified timeout; it typically returns after around 200 seconds (200,000 milliseconds), even if the query is not complete. If jobComplete is false, you can continue to wait for the query to complete by calling the getQueryResults method until the jobComplete field in the getQueryResults response is true.
 * @member {Number} timeoutMs
 */
QueryRequest.prototype['timeoutMs'] = undefined;

/**
 * Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery's GoogleSQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
 * @member {Boolean} useLegacySql
 * @default true
 */
QueryRequest.prototype['useLegacySql'] = true;

/**
 * Optional. Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. The default value is true.
 * @member {Boolean} useQueryCache
 * @default true
 */
QueryRequest.prototype['useQueryCache'] = true;





/**
 * Allowed values for the <code>jobCreationMode</code> property.
 * @enum {String}
 * @readonly
 */
QueryRequest['JobCreationModeEnum'] = {

    /**
     * value: "JOB_CREATION_MODE_UNSPECIFIED"
     * @const
     */
    "MODE_UNSPECIFIED": "JOB_CREATION_MODE_UNSPECIFIED",

    /**
     * value: "JOB_CREATION_REQUIRED"
     * @const
     */
    "REQUIRED": "JOB_CREATION_REQUIRED",

    /**
     * value: "JOB_CREATION_OPTIONAL"
     * @const
     */
    "OPTIONAL": "JOB_CREATION_OPTIONAL"
};



export default QueryRequest;

