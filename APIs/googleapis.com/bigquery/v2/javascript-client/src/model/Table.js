/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import BigLakeConfiguration from './BigLakeConfiguration';
import CloneDefinition from './CloneDefinition';
import Clustering from './Clustering';
import EncryptionConfiguration from './EncryptionConfiguration';
import ExternalDataConfiguration from './ExternalDataConfiguration';
import MaterializedViewDefinition from './MaterializedViewDefinition';
import MaterializedViewStatus from './MaterializedViewStatus';
import ModelDefinition from './ModelDefinition';
import RangePartitioning from './RangePartitioning';
import SnapshotDefinition from './SnapshotDefinition';
import Streamingbuffer from './Streamingbuffer';
import TableConstraints from './TableConstraints';
import TableReference from './TableReference';
import TableReplicationInfo from './TableReplicationInfo';
import TableSchema from './TableSchema';
import TimePartitioning from './TimePartitioning';
import ViewDefinition from './ViewDefinition';

/**
 * The Table model module.
 * @module model/Table
 * @version v2
 */
class Table {
    /**
     * Constructs a new <code>Table</code>.
     * @alias module:model/Table
     */
    constructor() { 
        
        Table.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
        obj['kind'] = 'bigquery#table';
        obj['requirePartitionFilter'] = false;
    }

    /**
     * Constructs a <code>Table</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Table} obj Optional instance to populate.
     * @return {module:model/Table} The populated <code>Table</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Table();

            if (data.hasOwnProperty('biglakeConfiguration')) {
                obj['biglakeConfiguration'] = BigLakeConfiguration.constructFromObject(data['biglakeConfiguration']);
            }
            if (data.hasOwnProperty('cloneDefinition')) {
                obj['cloneDefinition'] = CloneDefinition.constructFromObject(data['cloneDefinition']);
            }
            if (data.hasOwnProperty('clustering')) {
                obj['clustering'] = Clustering.constructFromObject(data['clustering']);
            }
            if (data.hasOwnProperty('creationTime')) {
                obj['creationTime'] = ApiClient.convertToType(data['creationTime'], 'String');
            }
            if (data.hasOwnProperty('defaultCollation')) {
                obj['defaultCollation'] = ApiClient.convertToType(data['defaultCollation'], 'String');
            }
            if (data.hasOwnProperty('defaultRoundingMode')) {
                obj['defaultRoundingMode'] = ApiClient.convertToType(data['defaultRoundingMode'], 'String');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('encryptionConfiguration')) {
                obj['encryptionConfiguration'] = EncryptionConfiguration.constructFromObject(data['encryptionConfiguration']);
            }
            if (data.hasOwnProperty('etag')) {
                obj['etag'] = ApiClient.convertToType(data['etag'], 'String');
            }
            if (data.hasOwnProperty('expirationTime')) {
                obj['expirationTime'] = ApiClient.convertToType(data['expirationTime'], 'String');
            }
            if (data.hasOwnProperty('externalDataConfiguration')) {
                obj['externalDataConfiguration'] = ExternalDataConfiguration.constructFromObject(data['externalDataConfiguration']);
            }
            if (data.hasOwnProperty('friendlyName')) {
                obj['friendlyName'] = ApiClient.convertToType(data['friendlyName'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('kind')) {
                obj['kind'] = ApiClient.convertToType(data['kind'], 'String');
            }
            if (data.hasOwnProperty('labels')) {
                obj['labels'] = ApiClient.convertToType(data['labels'], {'String': 'String'});
            }
            if (data.hasOwnProperty('lastModifiedTime')) {
                obj['lastModifiedTime'] = ApiClient.convertToType(data['lastModifiedTime'], 'String');
            }
            if (data.hasOwnProperty('location')) {
                obj['location'] = ApiClient.convertToType(data['location'], 'String');
            }
            if (data.hasOwnProperty('materializedView')) {
                obj['materializedView'] = MaterializedViewDefinition.constructFromObject(data['materializedView']);
            }
            if (data.hasOwnProperty('materializedViewStatus')) {
                obj['materializedViewStatus'] = MaterializedViewStatus.constructFromObject(data['materializedViewStatus']);
            }
            if (data.hasOwnProperty('maxStaleness')) {
                obj['maxStaleness'] = ApiClient.convertToType(data['maxStaleness'], 'String');
            }
            if (data.hasOwnProperty('model')) {
                obj['model'] = ModelDefinition.constructFromObject(data['model']);
            }
            if (data.hasOwnProperty('numActiveLogicalBytes')) {
                obj['numActiveLogicalBytes'] = ApiClient.convertToType(data['numActiveLogicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numActivePhysicalBytes')) {
                obj['numActivePhysicalBytes'] = ApiClient.convertToType(data['numActivePhysicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numBytes')) {
                obj['numBytes'] = ApiClient.convertToType(data['numBytes'], 'String');
            }
            if (data.hasOwnProperty('numLongTermBytes')) {
                obj['numLongTermBytes'] = ApiClient.convertToType(data['numLongTermBytes'], 'String');
            }
            if (data.hasOwnProperty('numLongTermLogicalBytes')) {
                obj['numLongTermLogicalBytes'] = ApiClient.convertToType(data['numLongTermLogicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numLongTermPhysicalBytes')) {
                obj['numLongTermPhysicalBytes'] = ApiClient.convertToType(data['numLongTermPhysicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numPartitions')) {
                obj['numPartitions'] = ApiClient.convertToType(data['numPartitions'], 'String');
            }
            if (data.hasOwnProperty('numPhysicalBytes')) {
                obj['numPhysicalBytes'] = ApiClient.convertToType(data['numPhysicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numRows')) {
                obj['numRows'] = ApiClient.convertToType(data['numRows'], 'String');
            }
            if (data.hasOwnProperty('numTimeTravelPhysicalBytes')) {
                obj['numTimeTravelPhysicalBytes'] = ApiClient.convertToType(data['numTimeTravelPhysicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numTotalLogicalBytes')) {
                obj['numTotalLogicalBytes'] = ApiClient.convertToType(data['numTotalLogicalBytes'], 'String');
            }
            if (data.hasOwnProperty('numTotalPhysicalBytes')) {
                obj['numTotalPhysicalBytes'] = ApiClient.convertToType(data['numTotalPhysicalBytes'], 'String');
            }
            if (data.hasOwnProperty('rangePartitioning')) {
                obj['rangePartitioning'] = RangePartitioning.constructFromObject(data['rangePartitioning']);
            }
            if (data.hasOwnProperty('replicas')) {
                obj['replicas'] = ApiClient.convertToType(data['replicas'], [TableReference]);
            }
            if (data.hasOwnProperty('requirePartitionFilter')) {
                obj['requirePartitionFilter'] = ApiClient.convertToType(data['requirePartitionFilter'], 'Boolean');
            }
            if (data.hasOwnProperty('resourceTags')) {
                obj['resourceTags'] = ApiClient.convertToType(data['resourceTags'], {'String': 'String'});
            }
            if (data.hasOwnProperty('schema')) {
                obj['schema'] = TableSchema.constructFromObject(data['schema']);
            }
            if (data.hasOwnProperty('selfLink')) {
                obj['selfLink'] = ApiClient.convertToType(data['selfLink'], 'String');
            }
            if (data.hasOwnProperty('snapshotDefinition')) {
                obj['snapshotDefinition'] = SnapshotDefinition.constructFromObject(data['snapshotDefinition']);
            }
            if (data.hasOwnProperty('streamingBuffer')) {
                obj['streamingBuffer'] = Streamingbuffer.constructFromObject(data['streamingBuffer']);
            }
            if (data.hasOwnProperty('tableConstraints')) {
                obj['tableConstraints'] = TableConstraints.constructFromObject(data['tableConstraints']);
            }
            if (data.hasOwnProperty('tableReference')) {
                obj['tableReference'] = TableReference.constructFromObject(data['tableReference']);
            }
            if (data.hasOwnProperty('tableReplicationInfo')) {
                obj['tableReplicationInfo'] = TableReplicationInfo.constructFromObject(data['tableReplicationInfo']);
            }
            if (data.hasOwnProperty('timePartitioning')) {
                obj['timePartitioning'] = TimePartitioning.constructFromObject(data['timePartitioning']);
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
            if (data.hasOwnProperty('view')) {
                obj['view'] = ViewDefinition.constructFromObject(data['view']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Table</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Table</code>.
     */
    static validateJSON(data) {
        // validate the optional field `biglakeConfiguration`
        if (data['biglakeConfiguration']) { // data not null
          BigLakeConfiguration.validateJSON(data['biglakeConfiguration']);
        }
        // validate the optional field `cloneDefinition`
        if (data['cloneDefinition']) { // data not null
          CloneDefinition.validateJSON(data['cloneDefinition']);
        }
        // validate the optional field `clustering`
        if (data['clustering']) { // data not null
          Clustering.validateJSON(data['clustering']);
        }
        // ensure the json data is a string
        if (data['creationTime'] && !(typeof data['creationTime'] === 'string' || data['creationTime'] instanceof String)) {
            throw new Error("Expected the field `creationTime` to be a primitive type in the JSON string but got " + data['creationTime']);
        }
        // ensure the json data is a string
        if (data['defaultCollation'] && !(typeof data['defaultCollation'] === 'string' || data['defaultCollation'] instanceof String)) {
            throw new Error("Expected the field `defaultCollation` to be a primitive type in the JSON string but got " + data['defaultCollation']);
        }
        // ensure the json data is a string
        if (data['defaultRoundingMode'] && !(typeof data['defaultRoundingMode'] === 'string' || data['defaultRoundingMode'] instanceof String)) {
            throw new Error("Expected the field `defaultRoundingMode` to be a primitive type in the JSON string but got " + data['defaultRoundingMode']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // validate the optional field `encryptionConfiguration`
        if (data['encryptionConfiguration']) { // data not null
          EncryptionConfiguration.validateJSON(data['encryptionConfiguration']);
        }
        // ensure the json data is a string
        if (data['etag'] && !(typeof data['etag'] === 'string' || data['etag'] instanceof String)) {
            throw new Error("Expected the field `etag` to be a primitive type in the JSON string but got " + data['etag']);
        }
        // ensure the json data is a string
        if (data['expirationTime'] && !(typeof data['expirationTime'] === 'string' || data['expirationTime'] instanceof String)) {
            throw new Error("Expected the field `expirationTime` to be a primitive type in the JSON string but got " + data['expirationTime']);
        }
        // validate the optional field `externalDataConfiguration`
        if (data['externalDataConfiguration']) { // data not null
          ExternalDataConfiguration.validateJSON(data['externalDataConfiguration']);
        }
        // ensure the json data is a string
        if (data['friendlyName'] && !(typeof data['friendlyName'] === 'string' || data['friendlyName'] instanceof String)) {
            throw new Error("Expected the field `friendlyName` to be a primitive type in the JSON string but got " + data['friendlyName']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['kind'] && !(typeof data['kind'] === 'string' || data['kind'] instanceof String)) {
            throw new Error("Expected the field `kind` to be a primitive type in the JSON string but got " + data['kind']);
        }
        // ensure the json data is a string
        if (data['lastModifiedTime'] && !(typeof data['lastModifiedTime'] === 'string' || data['lastModifiedTime'] instanceof String)) {
            throw new Error("Expected the field `lastModifiedTime` to be a primitive type in the JSON string but got " + data['lastModifiedTime']);
        }
        // ensure the json data is a string
        if (data['location'] && !(typeof data['location'] === 'string' || data['location'] instanceof String)) {
            throw new Error("Expected the field `location` to be a primitive type in the JSON string but got " + data['location']);
        }
        // validate the optional field `materializedView`
        if (data['materializedView']) { // data not null
          MaterializedViewDefinition.validateJSON(data['materializedView']);
        }
        // validate the optional field `materializedViewStatus`
        if (data['materializedViewStatus']) { // data not null
          MaterializedViewStatus.validateJSON(data['materializedViewStatus']);
        }
        // ensure the json data is a string
        if (data['maxStaleness'] && !(typeof data['maxStaleness'] === 'string' || data['maxStaleness'] instanceof String)) {
            throw new Error("Expected the field `maxStaleness` to be a primitive type in the JSON string but got " + data['maxStaleness']);
        }
        // validate the optional field `model`
        if (data['model']) { // data not null
          ModelDefinition.validateJSON(data['model']);
        }
        // ensure the json data is a string
        if (data['numActiveLogicalBytes'] && !(typeof data['numActiveLogicalBytes'] === 'string' || data['numActiveLogicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numActiveLogicalBytes` to be a primitive type in the JSON string but got " + data['numActiveLogicalBytes']);
        }
        // ensure the json data is a string
        if (data['numActivePhysicalBytes'] && !(typeof data['numActivePhysicalBytes'] === 'string' || data['numActivePhysicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numActivePhysicalBytes` to be a primitive type in the JSON string but got " + data['numActivePhysicalBytes']);
        }
        // ensure the json data is a string
        if (data['numBytes'] && !(typeof data['numBytes'] === 'string' || data['numBytes'] instanceof String)) {
            throw new Error("Expected the field `numBytes` to be a primitive type in the JSON string but got " + data['numBytes']);
        }
        // ensure the json data is a string
        if (data['numLongTermBytes'] && !(typeof data['numLongTermBytes'] === 'string' || data['numLongTermBytes'] instanceof String)) {
            throw new Error("Expected the field `numLongTermBytes` to be a primitive type in the JSON string but got " + data['numLongTermBytes']);
        }
        // ensure the json data is a string
        if (data['numLongTermLogicalBytes'] && !(typeof data['numLongTermLogicalBytes'] === 'string' || data['numLongTermLogicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numLongTermLogicalBytes` to be a primitive type in the JSON string but got " + data['numLongTermLogicalBytes']);
        }
        // ensure the json data is a string
        if (data['numLongTermPhysicalBytes'] && !(typeof data['numLongTermPhysicalBytes'] === 'string' || data['numLongTermPhysicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numLongTermPhysicalBytes` to be a primitive type in the JSON string but got " + data['numLongTermPhysicalBytes']);
        }
        // ensure the json data is a string
        if (data['numPartitions'] && !(typeof data['numPartitions'] === 'string' || data['numPartitions'] instanceof String)) {
            throw new Error("Expected the field `numPartitions` to be a primitive type in the JSON string but got " + data['numPartitions']);
        }
        // ensure the json data is a string
        if (data['numPhysicalBytes'] && !(typeof data['numPhysicalBytes'] === 'string' || data['numPhysicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numPhysicalBytes` to be a primitive type in the JSON string but got " + data['numPhysicalBytes']);
        }
        // ensure the json data is a string
        if (data['numRows'] && !(typeof data['numRows'] === 'string' || data['numRows'] instanceof String)) {
            throw new Error("Expected the field `numRows` to be a primitive type in the JSON string but got " + data['numRows']);
        }
        // ensure the json data is a string
        if (data['numTimeTravelPhysicalBytes'] && !(typeof data['numTimeTravelPhysicalBytes'] === 'string' || data['numTimeTravelPhysicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numTimeTravelPhysicalBytes` to be a primitive type in the JSON string but got " + data['numTimeTravelPhysicalBytes']);
        }
        // ensure the json data is a string
        if (data['numTotalLogicalBytes'] && !(typeof data['numTotalLogicalBytes'] === 'string' || data['numTotalLogicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numTotalLogicalBytes` to be a primitive type in the JSON string but got " + data['numTotalLogicalBytes']);
        }
        // ensure the json data is a string
        if (data['numTotalPhysicalBytes'] && !(typeof data['numTotalPhysicalBytes'] === 'string' || data['numTotalPhysicalBytes'] instanceof String)) {
            throw new Error("Expected the field `numTotalPhysicalBytes` to be a primitive type in the JSON string but got " + data['numTotalPhysicalBytes']);
        }
        // validate the optional field `rangePartitioning`
        if (data['rangePartitioning']) { // data not null
          RangePartitioning.validateJSON(data['rangePartitioning']);
        }
        if (data['replicas']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['replicas'])) {
                throw new Error("Expected the field `replicas` to be an array in the JSON data but got " + data['replicas']);
            }
            // validate the optional field `replicas` (array)
            for (const item of data['replicas']) {
                TableReference.validateJSON(item);
            };
        }
        // validate the optional field `schema`
        if (data['schema']) { // data not null
          TableSchema.validateJSON(data['schema']);
        }
        // ensure the json data is a string
        if (data['selfLink'] && !(typeof data['selfLink'] === 'string' || data['selfLink'] instanceof String)) {
            throw new Error("Expected the field `selfLink` to be a primitive type in the JSON string but got " + data['selfLink']);
        }
        // validate the optional field `snapshotDefinition`
        if (data['snapshotDefinition']) { // data not null
          SnapshotDefinition.validateJSON(data['snapshotDefinition']);
        }
        // validate the optional field `streamingBuffer`
        if (data['streamingBuffer']) { // data not null
          Streamingbuffer.validateJSON(data['streamingBuffer']);
        }
        // validate the optional field `tableConstraints`
        if (data['tableConstraints']) { // data not null
          TableConstraints.validateJSON(data['tableConstraints']);
        }
        // validate the optional field `tableReference`
        if (data['tableReference']) { // data not null
          TableReference.validateJSON(data['tableReference']);
        }
        // validate the optional field `tableReplicationInfo`
        if (data['tableReplicationInfo']) { // data not null
          TableReplicationInfo.validateJSON(data['tableReplicationInfo']);
        }
        // validate the optional field `timePartitioning`
        if (data['timePartitioning']) { // data not null
          TimePartitioning.validateJSON(data['timePartitioning']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }
        // validate the optional field `view`
        if (data['view']) { // data not null
          ViewDefinition.validateJSON(data['view']);
        }

        return true;
    }


}



/**
 * @member {module:model/BigLakeConfiguration} biglakeConfiguration
 */
Table.prototype['biglakeConfiguration'] = undefined;

/**
 * @member {module:model/CloneDefinition} cloneDefinition
 */
Table.prototype['cloneDefinition'] = undefined;

/**
 * @member {module:model/Clustering} clustering
 */
Table.prototype['clustering'] = undefined;

/**
 * Output only. The time when this table was created, in milliseconds since the epoch.
 * @member {String} creationTime
 */
Table.prototype['creationTime'] = undefined;

/**
 * Optional. Defines the default collation specification of new STRING fields in the table. During table creation or update, if a STRING field is added to this table without explicit collation specified, then the table inherits the table default collation. A change to this field affects only fields added afterwards, and does not alter the existing fields. The following values are supported: * 'und:ci': undetermined locale, case insensitive. * '': empty string. Default to case-sensitive behavior.
 * @member {String} defaultCollation
 */
Table.prototype['defaultCollation'] = undefined;

/**
 * Optional. Defines the default rounding mode specification of new decimal fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or update, if a decimal field is added to this table without an explicit rounding mode specified, then the field inherits the table default rounding mode. Changing this field doesn't affect existing fields.
 * @member {module:model/Table.DefaultRoundingModeEnum} defaultRoundingMode
 */
Table.prototype['defaultRoundingMode'] = undefined;

/**
 * Optional. A user-friendly description of this table.
 * @member {String} description
 */
Table.prototype['description'] = undefined;

/**
 * @member {module:model/EncryptionConfiguration} encryptionConfiguration
 */
Table.prototype['encryptionConfiguration'] = undefined;

/**
 * Output only. A hash of this resource.
 * @member {String} etag
 */
Table.prototype['etag'] = undefined;

/**
 * Optional. The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
 * @member {String} expirationTime
 */
Table.prototype['expirationTime'] = undefined;

/**
 * @member {module:model/ExternalDataConfiguration} externalDataConfiguration
 */
Table.prototype['externalDataConfiguration'] = undefined;

/**
 * Optional. A descriptive name for this table.
 * @member {String} friendlyName
 */
Table.prototype['friendlyName'] = undefined;

/**
 * Output only. An opaque ID uniquely identifying the table.
 * @member {String} id
 */
Table.prototype['id'] = undefined;

/**
 * The type of resource ID.
 * @member {String} kind
 * @default 'bigquery#table'
 */
Table.prototype['kind'] = 'bigquery#table';

/**
 * The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
 * @member {Object.<String, String>} labels
 */
Table.prototype['labels'] = undefined;

/**
 * Output only. The time when this table was last modified, in milliseconds since the epoch.
 * @member {String} lastModifiedTime
 */
Table.prototype['lastModifiedTime'] = undefined;

/**
 * Output only. The geographic location where the table resides. This value is inherited from the dataset.
 * @member {String} location
 */
Table.prototype['location'] = undefined;

/**
 * @member {module:model/MaterializedViewDefinition} materializedView
 */
Table.prototype['materializedView'] = undefined;

/**
 * @member {module:model/MaterializedViewStatus} materializedViewStatus
 */
Table.prototype['materializedViewStatus'] = undefined;

/**
 * Optional. The maximum staleness of data that could be returned when the table (or stale MV) is queried. Staleness encoded as a string encoding of sql IntervalValue type.
 * @member {String} maxStaleness
 */
Table.prototype['maxStaleness'] = undefined;

/**
 * @member {module:model/ModelDefinition} model
 */
Table.prototype['model'] = undefined;

/**
 * Output only. Number of logical bytes that are less than 90 days old.
 * @member {String} numActiveLogicalBytes
 */
Table.prototype['numActiveLogicalBytes'] = undefined;

/**
 * Output only. Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
 * @member {String} numActivePhysicalBytes
 */
Table.prototype['numActivePhysicalBytes'] = undefined;

/**
 * Output only. The size of this table in logical bytes, excluding any data in the streaming buffer.
 * @member {String} numBytes
 */
Table.prototype['numBytes'] = undefined;

/**
 * Output only. The number of logical bytes in the table that are considered \"long-term storage\".
 * @member {String} numLongTermBytes
 */
Table.prototype['numLongTermBytes'] = undefined;

/**
 * Output only. Number of logical bytes that are more than 90 days old.
 * @member {String} numLongTermLogicalBytes
 */
Table.prototype['numLongTermLogicalBytes'] = undefined;

/**
 * Output only. Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
 * @member {String} numLongTermPhysicalBytes
 */
Table.prototype['numLongTermPhysicalBytes'] = undefined;

/**
 * Output only. The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
 * @member {String} numPartitions
 */
Table.prototype['numPartitions'] = undefined;

/**
 * Output only. The physical size of this table in bytes. This includes storage used for time travel.
 * @member {String} numPhysicalBytes
 */
Table.prototype['numPhysicalBytes'] = undefined;

/**
 * Output only. The number of rows of data in this table, excluding any data in the streaming buffer.
 * @member {String} numRows
 */
Table.prototype['numRows'] = undefined;

/**
 * Output only. Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
 * @member {String} numTimeTravelPhysicalBytes
 */
Table.prototype['numTimeTravelPhysicalBytes'] = undefined;

/**
 * Output only. Total number of logical bytes in the table or materialized view.
 * @member {String} numTotalLogicalBytes
 */
Table.prototype['numTotalLogicalBytes'] = undefined;

/**
 * Output only. The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
 * @member {String} numTotalPhysicalBytes
 */
Table.prototype['numTotalPhysicalBytes'] = undefined;

/**
 * @member {module:model/RangePartitioning} rangePartitioning
 */
Table.prototype['rangePartitioning'] = undefined;

/**
 * Optional. Output only. Table references of all replicas currently active on the table.
 * @member {Array.<module:model/TableReference>} replicas
 */
Table.prototype['replicas'] = undefined;

/**
 * Optional. If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
 * @member {Boolean} requirePartitionFilter
 * @default false
 */
Table.prototype['requirePartitionFilter'] = false;

/**
 * [Optional] The tags associated with this table. Tag keys are globally unique. See additional information on [tags](https://cloud.google.com/iam/docs/tags-access-control#definitions). An object containing a list of \"key\": value pairs. The key is the namespaced friendly name of the tag key, e.g. \"12345/environment\" where 12345 is parent id. The value is the friendly short name of the tag value, e.g. \"production\".
 * @member {Object.<String, String>} resourceTags
 */
Table.prototype['resourceTags'] = undefined;

/**
 * @member {module:model/TableSchema} schema
 */
Table.prototype['schema'] = undefined;

/**
 * Output only. A URL that can be used to access this resource again.
 * @member {String} selfLink
 */
Table.prototype['selfLink'] = undefined;

/**
 * @member {module:model/SnapshotDefinition} snapshotDefinition
 */
Table.prototype['snapshotDefinition'] = undefined;

/**
 * @member {module:model/Streamingbuffer} streamingBuffer
 */
Table.prototype['streamingBuffer'] = undefined;

/**
 * @member {module:model/TableConstraints} tableConstraints
 */
Table.prototype['tableConstraints'] = undefined;

/**
 * @member {module:model/TableReference} tableReference
 */
Table.prototype['tableReference'] = undefined;

/**
 * @member {module:model/TableReplicationInfo} tableReplicationInfo
 */
Table.prototype['tableReplicationInfo'] = undefined;

/**
 * @member {module:model/TimePartitioning} timePartitioning
 */
Table.prototype['timePartitioning'] = undefined;

/**
 * Output only. Describes the table type. The following values are supported: * `TABLE`: A normal BigQuery table. * `VIEW`: A virtual table defined by a SQL query. * `EXTERNAL`: A table that references data stored in an external storage system, such as Google Cloud Storage. * `MATERIALIZED_VIEW`: A precomputed view defined by a SQL query. * `SNAPSHOT`: An immutable BigQuery table that preserves the contents of a base table at a particular time. See additional information on [table snapshots](/bigquery/docs/table-snapshots-intro). The default value is `TABLE`.
 * @member {String} type
 */
Table.prototype['type'] = undefined;

/**
 * @member {module:model/ViewDefinition} view
 */
Table.prototype['view'] = undefined;





/**
 * Allowed values for the <code>defaultRoundingMode</code> property.
 * @enum {String}
 * @readonly
 */
Table['DefaultRoundingModeEnum'] = {

    /**
     * value: "ROUNDING_MODE_UNSPECIFIED"
     * @const
     */
    "ROUNDING_MODE_UNSPECIFIED": "ROUNDING_MODE_UNSPECIFIED",

    /**
     * value: "ROUND_HALF_AWAY_FROM_ZERO"
     * @const
     */
    "ROUND_HALF_AWAY_FROM_ZERO": "ROUND_HALF_AWAY_FROM_ZERO",

    /**
     * value: "ROUND_HALF_EVEN"
     * @const
     */
    "ROUND_HALF_EVEN": "ROUND_HALF_EVEN"
};



export default Table;

