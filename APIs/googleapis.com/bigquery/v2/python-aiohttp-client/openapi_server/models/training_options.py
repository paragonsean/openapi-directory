# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.arima_order import ArimaOrder
from openapi_server import util


class TrainingOptions(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, activation_fn: str=None, adjust_step_changes: bool=None, approx_global_feature_contrib: bool=None, auto_arima: bool=None, auto_arima_max_order: str=None, auto_arima_min_order: str=None, auto_class_weights: bool=None, batch_size: str=None, booster_type: str=None, budget_hours: float=None, calculate_p_values: bool=None, category_encoding_method: str=None, clean_spikes_and_dips: bool=None, color_space: str=None, colsample_bylevel: float=None, colsample_bynode: float=None, colsample_bytree: float=None, dart_normalize_type: str=None, data_frequency: str=None, data_split_column: str=None, data_split_eval_fraction: float=None, data_split_method: str=None, decompose_time_series: bool=None, distance_type: str=None, dropout: float=None, early_stop: bool=None, enable_global_explain: bool=None, feedback_type: str=None, fit_intercept: bool=None, hidden_units: List[str]=None, holiday_region: str=None, holiday_regions: List[str]=None, horizon: str=None, hparam_tuning_objectives: List[str]=None, include_drift: bool=None, initial_learn_rate: float=None, input_label_columns: List[str]=None, instance_weight_column: str=None, integrated_gradients_num_steps: str=None, item_column: str=None, kmeans_initialization_column: str=None, kmeans_initialization_method: str=None, l1_reg_activation: float=None, l1_regularization: float=None, l2_regularization: float=None, label_class_weights: Dict[str, float]=None, learn_rate: float=None, learn_rate_strategy: str=None, loss_type: str=None, max_iterations: str=None, max_parallel_trials: str=None, max_time_series_length: str=None, max_tree_depth: str=None, min_relative_progress: float=None, min_split_loss: float=None, min_time_series_length: str=None, min_tree_child_weight: str=None, model_registry: str=None, model_uri: str=None, non_seasonal_order: ArimaOrder=None, num_clusters: str=None, num_factors: str=None, num_parallel_tree: str=None, num_principal_components: str=None, num_trials: str=None, optimization_strategy: str=None, optimizer: str=None, pca_explained_variance_ratio: float=None, pca_solver: str=None, sampled_shapley_num_paths: str=None, scale_features: bool=None, standardize_features: bool=None, subsample: float=None, tf_version: str=None, time_series_data_column: str=None, time_series_id_column: str=None, time_series_id_columns: List[str]=None, time_series_length_fraction: float=None, time_series_timestamp_column: str=None, tree_method: str=None, trend_smoothing_window_size: str=None, user_column: str=None, vertex_ai_model_version_aliases: List[str]=None, wals_alpha: float=None, warm_start: bool=None, xgboost_version: str=None):
        """TrainingOptions - a model defined in OpenAPI

        :param activation_fn: The activation_fn of this TrainingOptions.
        :param adjust_step_changes: The adjust_step_changes of this TrainingOptions.
        :param approx_global_feature_contrib: The approx_global_feature_contrib of this TrainingOptions.
        :param auto_arima: The auto_arima of this TrainingOptions.
        :param auto_arima_max_order: The auto_arima_max_order of this TrainingOptions.
        :param auto_arima_min_order: The auto_arima_min_order of this TrainingOptions.
        :param auto_class_weights: The auto_class_weights of this TrainingOptions.
        :param batch_size: The batch_size of this TrainingOptions.
        :param booster_type: The booster_type of this TrainingOptions.
        :param budget_hours: The budget_hours of this TrainingOptions.
        :param calculate_p_values: The calculate_p_values of this TrainingOptions.
        :param category_encoding_method: The category_encoding_method of this TrainingOptions.
        :param clean_spikes_and_dips: The clean_spikes_and_dips of this TrainingOptions.
        :param color_space: The color_space of this TrainingOptions.
        :param colsample_bylevel: The colsample_bylevel of this TrainingOptions.
        :param colsample_bynode: The colsample_bynode of this TrainingOptions.
        :param colsample_bytree: The colsample_bytree of this TrainingOptions.
        :param dart_normalize_type: The dart_normalize_type of this TrainingOptions.
        :param data_frequency: The data_frequency of this TrainingOptions.
        :param data_split_column: The data_split_column of this TrainingOptions.
        :param data_split_eval_fraction: The data_split_eval_fraction of this TrainingOptions.
        :param data_split_method: The data_split_method of this TrainingOptions.
        :param decompose_time_series: The decompose_time_series of this TrainingOptions.
        :param distance_type: The distance_type of this TrainingOptions.
        :param dropout: The dropout of this TrainingOptions.
        :param early_stop: The early_stop of this TrainingOptions.
        :param enable_global_explain: The enable_global_explain of this TrainingOptions.
        :param feedback_type: The feedback_type of this TrainingOptions.
        :param fit_intercept: The fit_intercept of this TrainingOptions.
        :param hidden_units: The hidden_units of this TrainingOptions.
        :param holiday_region: The holiday_region of this TrainingOptions.
        :param holiday_regions: The holiday_regions of this TrainingOptions.
        :param horizon: The horizon of this TrainingOptions.
        :param hparam_tuning_objectives: The hparam_tuning_objectives of this TrainingOptions.
        :param include_drift: The include_drift of this TrainingOptions.
        :param initial_learn_rate: The initial_learn_rate of this TrainingOptions.
        :param input_label_columns: The input_label_columns of this TrainingOptions.
        :param instance_weight_column: The instance_weight_column of this TrainingOptions.
        :param integrated_gradients_num_steps: The integrated_gradients_num_steps of this TrainingOptions.
        :param item_column: The item_column of this TrainingOptions.
        :param kmeans_initialization_column: The kmeans_initialization_column of this TrainingOptions.
        :param kmeans_initialization_method: The kmeans_initialization_method of this TrainingOptions.
        :param l1_reg_activation: The l1_reg_activation of this TrainingOptions.
        :param l1_regularization: The l1_regularization of this TrainingOptions.
        :param l2_regularization: The l2_regularization of this TrainingOptions.
        :param label_class_weights: The label_class_weights of this TrainingOptions.
        :param learn_rate: The learn_rate of this TrainingOptions.
        :param learn_rate_strategy: The learn_rate_strategy of this TrainingOptions.
        :param loss_type: The loss_type of this TrainingOptions.
        :param max_iterations: The max_iterations of this TrainingOptions.
        :param max_parallel_trials: The max_parallel_trials of this TrainingOptions.
        :param max_time_series_length: The max_time_series_length of this TrainingOptions.
        :param max_tree_depth: The max_tree_depth of this TrainingOptions.
        :param min_relative_progress: The min_relative_progress of this TrainingOptions.
        :param min_split_loss: The min_split_loss of this TrainingOptions.
        :param min_time_series_length: The min_time_series_length of this TrainingOptions.
        :param min_tree_child_weight: The min_tree_child_weight of this TrainingOptions.
        :param model_registry: The model_registry of this TrainingOptions.
        :param model_uri: The model_uri of this TrainingOptions.
        :param non_seasonal_order: The non_seasonal_order of this TrainingOptions.
        :param num_clusters: The num_clusters of this TrainingOptions.
        :param num_factors: The num_factors of this TrainingOptions.
        :param num_parallel_tree: The num_parallel_tree of this TrainingOptions.
        :param num_principal_components: The num_principal_components of this TrainingOptions.
        :param num_trials: The num_trials of this TrainingOptions.
        :param optimization_strategy: The optimization_strategy of this TrainingOptions.
        :param optimizer: The optimizer of this TrainingOptions.
        :param pca_explained_variance_ratio: The pca_explained_variance_ratio of this TrainingOptions.
        :param pca_solver: The pca_solver of this TrainingOptions.
        :param sampled_shapley_num_paths: The sampled_shapley_num_paths of this TrainingOptions.
        :param scale_features: The scale_features of this TrainingOptions.
        :param standardize_features: The standardize_features of this TrainingOptions.
        :param subsample: The subsample of this TrainingOptions.
        :param tf_version: The tf_version of this TrainingOptions.
        :param time_series_data_column: The time_series_data_column of this TrainingOptions.
        :param time_series_id_column: The time_series_id_column of this TrainingOptions.
        :param time_series_id_columns: The time_series_id_columns of this TrainingOptions.
        :param time_series_length_fraction: The time_series_length_fraction of this TrainingOptions.
        :param time_series_timestamp_column: The time_series_timestamp_column of this TrainingOptions.
        :param tree_method: The tree_method of this TrainingOptions.
        :param trend_smoothing_window_size: The trend_smoothing_window_size of this TrainingOptions.
        :param user_column: The user_column of this TrainingOptions.
        :param vertex_ai_model_version_aliases: The vertex_ai_model_version_aliases of this TrainingOptions.
        :param wals_alpha: The wals_alpha of this TrainingOptions.
        :param warm_start: The warm_start of this TrainingOptions.
        :param xgboost_version: The xgboost_version of this TrainingOptions.
        """
        self.openapi_types = {
            'activation_fn': str,
            'adjust_step_changes': bool,
            'approx_global_feature_contrib': bool,
            'auto_arima': bool,
            'auto_arima_max_order': str,
            'auto_arima_min_order': str,
            'auto_class_weights': bool,
            'batch_size': str,
            'booster_type': str,
            'budget_hours': float,
            'calculate_p_values': bool,
            'category_encoding_method': str,
            'clean_spikes_and_dips': bool,
            'color_space': str,
            'colsample_bylevel': float,
            'colsample_bynode': float,
            'colsample_bytree': float,
            'dart_normalize_type': str,
            'data_frequency': str,
            'data_split_column': str,
            'data_split_eval_fraction': float,
            'data_split_method': str,
            'decompose_time_series': bool,
            'distance_type': str,
            'dropout': float,
            'early_stop': bool,
            'enable_global_explain': bool,
            'feedback_type': str,
            'fit_intercept': bool,
            'hidden_units': List[str],
            'holiday_region': str,
            'holiday_regions': List[str],
            'horizon': str,
            'hparam_tuning_objectives': List[str],
            'include_drift': bool,
            'initial_learn_rate': float,
            'input_label_columns': List[str],
            'instance_weight_column': str,
            'integrated_gradients_num_steps': str,
            'item_column': str,
            'kmeans_initialization_column': str,
            'kmeans_initialization_method': str,
            'l1_reg_activation': float,
            'l1_regularization': float,
            'l2_regularization': float,
            'label_class_weights': Dict[str, float],
            'learn_rate': float,
            'learn_rate_strategy': str,
            'loss_type': str,
            'max_iterations': str,
            'max_parallel_trials': str,
            'max_time_series_length': str,
            'max_tree_depth': str,
            'min_relative_progress': float,
            'min_split_loss': float,
            'min_time_series_length': str,
            'min_tree_child_weight': str,
            'model_registry': str,
            'model_uri': str,
            'non_seasonal_order': ArimaOrder,
            'num_clusters': str,
            'num_factors': str,
            'num_parallel_tree': str,
            'num_principal_components': str,
            'num_trials': str,
            'optimization_strategy': str,
            'optimizer': str,
            'pca_explained_variance_ratio': float,
            'pca_solver': str,
            'sampled_shapley_num_paths': str,
            'scale_features': bool,
            'standardize_features': bool,
            'subsample': float,
            'tf_version': str,
            'time_series_data_column': str,
            'time_series_id_column': str,
            'time_series_id_columns': List[str],
            'time_series_length_fraction': float,
            'time_series_timestamp_column': str,
            'tree_method': str,
            'trend_smoothing_window_size': str,
            'user_column': str,
            'vertex_ai_model_version_aliases': List[str],
            'wals_alpha': float,
            'warm_start': bool,
            'xgboost_version': str
        }

        self.attribute_map = {
            'activation_fn': 'activationFn',
            'adjust_step_changes': 'adjustStepChanges',
            'approx_global_feature_contrib': 'approxGlobalFeatureContrib',
            'auto_arima': 'autoArima',
            'auto_arima_max_order': 'autoArimaMaxOrder',
            'auto_arima_min_order': 'autoArimaMinOrder',
            'auto_class_weights': 'autoClassWeights',
            'batch_size': 'batchSize',
            'booster_type': 'boosterType',
            'budget_hours': 'budgetHours',
            'calculate_p_values': 'calculatePValues',
            'category_encoding_method': 'categoryEncodingMethod',
            'clean_spikes_and_dips': 'cleanSpikesAndDips',
            'color_space': 'colorSpace',
            'colsample_bylevel': 'colsampleBylevel',
            'colsample_bynode': 'colsampleBynode',
            'colsample_bytree': 'colsampleBytree',
            'dart_normalize_type': 'dartNormalizeType',
            'data_frequency': 'dataFrequency',
            'data_split_column': 'dataSplitColumn',
            'data_split_eval_fraction': 'dataSplitEvalFraction',
            'data_split_method': 'dataSplitMethod',
            'decompose_time_series': 'decomposeTimeSeries',
            'distance_type': 'distanceType',
            'dropout': 'dropout',
            'early_stop': 'earlyStop',
            'enable_global_explain': 'enableGlobalExplain',
            'feedback_type': 'feedbackType',
            'fit_intercept': 'fitIntercept',
            'hidden_units': 'hiddenUnits',
            'holiday_region': 'holidayRegion',
            'holiday_regions': 'holidayRegions',
            'horizon': 'horizon',
            'hparam_tuning_objectives': 'hparamTuningObjectives',
            'include_drift': 'includeDrift',
            'initial_learn_rate': 'initialLearnRate',
            'input_label_columns': 'inputLabelColumns',
            'instance_weight_column': 'instanceWeightColumn',
            'integrated_gradients_num_steps': 'integratedGradientsNumSteps',
            'item_column': 'itemColumn',
            'kmeans_initialization_column': 'kmeansInitializationColumn',
            'kmeans_initialization_method': 'kmeansInitializationMethod',
            'l1_reg_activation': 'l1RegActivation',
            'l1_regularization': 'l1Regularization',
            'l2_regularization': 'l2Regularization',
            'label_class_weights': 'labelClassWeights',
            'learn_rate': 'learnRate',
            'learn_rate_strategy': 'learnRateStrategy',
            'loss_type': 'lossType',
            'max_iterations': 'maxIterations',
            'max_parallel_trials': 'maxParallelTrials',
            'max_time_series_length': 'maxTimeSeriesLength',
            'max_tree_depth': 'maxTreeDepth',
            'min_relative_progress': 'minRelativeProgress',
            'min_split_loss': 'minSplitLoss',
            'min_time_series_length': 'minTimeSeriesLength',
            'min_tree_child_weight': 'minTreeChildWeight',
            'model_registry': 'modelRegistry',
            'model_uri': 'modelUri',
            'non_seasonal_order': 'nonSeasonalOrder',
            'num_clusters': 'numClusters',
            'num_factors': 'numFactors',
            'num_parallel_tree': 'numParallelTree',
            'num_principal_components': 'numPrincipalComponents',
            'num_trials': 'numTrials',
            'optimization_strategy': 'optimizationStrategy',
            'optimizer': 'optimizer',
            'pca_explained_variance_ratio': 'pcaExplainedVarianceRatio',
            'pca_solver': 'pcaSolver',
            'sampled_shapley_num_paths': 'sampledShapleyNumPaths',
            'scale_features': 'scaleFeatures',
            'standardize_features': 'standardizeFeatures',
            'subsample': 'subsample',
            'tf_version': 'tfVersion',
            'time_series_data_column': 'timeSeriesDataColumn',
            'time_series_id_column': 'timeSeriesIdColumn',
            'time_series_id_columns': 'timeSeriesIdColumns',
            'time_series_length_fraction': 'timeSeriesLengthFraction',
            'time_series_timestamp_column': 'timeSeriesTimestampColumn',
            'tree_method': 'treeMethod',
            'trend_smoothing_window_size': 'trendSmoothingWindowSize',
            'user_column': 'userColumn',
            'vertex_ai_model_version_aliases': 'vertexAiModelVersionAliases',
            'wals_alpha': 'walsAlpha',
            'warm_start': 'warmStart',
            'xgboost_version': 'xgboostVersion'
        }

        self._activation_fn = activation_fn
        self._adjust_step_changes = adjust_step_changes
        self._approx_global_feature_contrib = approx_global_feature_contrib
        self._auto_arima = auto_arima
        self._auto_arima_max_order = auto_arima_max_order
        self._auto_arima_min_order = auto_arima_min_order
        self._auto_class_weights = auto_class_weights
        self._batch_size = batch_size
        self._booster_type = booster_type
        self._budget_hours = budget_hours
        self._calculate_p_values = calculate_p_values
        self._category_encoding_method = category_encoding_method
        self._clean_spikes_and_dips = clean_spikes_and_dips
        self._color_space = color_space
        self._colsample_bylevel = colsample_bylevel
        self._colsample_bynode = colsample_bynode
        self._colsample_bytree = colsample_bytree
        self._dart_normalize_type = dart_normalize_type
        self._data_frequency = data_frequency
        self._data_split_column = data_split_column
        self._data_split_eval_fraction = data_split_eval_fraction
        self._data_split_method = data_split_method
        self._decompose_time_series = decompose_time_series
        self._distance_type = distance_type
        self._dropout = dropout
        self._early_stop = early_stop
        self._enable_global_explain = enable_global_explain
        self._feedback_type = feedback_type
        self._fit_intercept = fit_intercept
        self._hidden_units = hidden_units
        self._holiday_region = holiday_region
        self._holiday_regions = holiday_regions
        self._horizon = horizon
        self._hparam_tuning_objectives = hparam_tuning_objectives
        self._include_drift = include_drift
        self._initial_learn_rate = initial_learn_rate
        self._input_label_columns = input_label_columns
        self._instance_weight_column = instance_weight_column
        self._integrated_gradients_num_steps = integrated_gradients_num_steps
        self._item_column = item_column
        self._kmeans_initialization_column = kmeans_initialization_column
        self._kmeans_initialization_method = kmeans_initialization_method
        self._l1_reg_activation = l1_reg_activation
        self._l1_regularization = l1_regularization
        self._l2_regularization = l2_regularization
        self._label_class_weights = label_class_weights
        self._learn_rate = learn_rate
        self._learn_rate_strategy = learn_rate_strategy
        self._loss_type = loss_type
        self._max_iterations = max_iterations
        self._max_parallel_trials = max_parallel_trials
        self._max_time_series_length = max_time_series_length
        self._max_tree_depth = max_tree_depth
        self._min_relative_progress = min_relative_progress
        self._min_split_loss = min_split_loss
        self._min_time_series_length = min_time_series_length
        self._min_tree_child_weight = min_tree_child_weight
        self._model_registry = model_registry
        self._model_uri = model_uri
        self._non_seasonal_order = non_seasonal_order
        self._num_clusters = num_clusters
        self._num_factors = num_factors
        self._num_parallel_tree = num_parallel_tree
        self._num_principal_components = num_principal_components
        self._num_trials = num_trials
        self._optimization_strategy = optimization_strategy
        self._optimizer = optimizer
        self._pca_explained_variance_ratio = pca_explained_variance_ratio
        self._pca_solver = pca_solver
        self._sampled_shapley_num_paths = sampled_shapley_num_paths
        self._scale_features = scale_features
        self._standardize_features = standardize_features
        self._subsample = subsample
        self._tf_version = tf_version
        self._time_series_data_column = time_series_data_column
        self._time_series_id_column = time_series_id_column
        self._time_series_id_columns = time_series_id_columns
        self._time_series_length_fraction = time_series_length_fraction
        self._time_series_timestamp_column = time_series_timestamp_column
        self._tree_method = tree_method
        self._trend_smoothing_window_size = trend_smoothing_window_size
        self._user_column = user_column
        self._vertex_ai_model_version_aliases = vertex_ai_model_version_aliases
        self._wals_alpha = wals_alpha
        self._warm_start = warm_start
        self._xgboost_version = xgboost_version

    @classmethod
    def from_dict(cls, dikt: dict) -> 'TrainingOptions':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The TrainingOptions of this TrainingOptions.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def activation_fn(self):
        """Gets the activation_fn of this TrainingOptions.

        Activation function of the neural nets.

        :return: The activation_fn of this TrainingOptions.
        :rtype: str
        """
        return self._activation_fn

    @activation_fn.setter
    def activation_fn(self, activation_fn):
        """Sets the activation_fn of this TrainingOptions.

        Activation function of the neural nets.

        :param activation_fn: The activation_fn of this TrainingOptions.
        :type activation_fn: str
        """

        self._activation_fn = activation_fn

    @property
    def adjust_step_changes(self):
        """Gets the adjust_step_changes of this TrainingOptions.

        If true, detect step changes and make data adjustment in the input time series.

        :return: The adjust_step_changes of this TrainingOptions.
        :rtype: bool
        """
        return self._adjust_step_changes

    @adjust_step_changes.setter
    def adjust_step_changes(self, adjust_step_changes):
        """Sets the adjust_step_changes of this TrainingOptions.

        If true, detect step changes and make data adjustment in the input time series.

        :param adjust_step_changes: The adjust_step_changes of this TrainingOptions.
        :type adjust_step_changes: bool
        """

        self._adjust_step_changes = adjust_step_changes

    @property
    def approx_global_feature_contrib(self):
        """Gets the approx_global_feature_contrib of this TrainingOptions.

        Whether to use approximate feature contribution method in XGBoost model explanation for global explain.

        :return: The approx_global_feature_contrib of this TrainingOptions.
        :rtype: bool
        """
        return self._approx_global_feature_contrib

    @approx_global_feature_contrib.setter
    def approx_global_feature_contrib(self, approx_global_feature_contrib):
        """Sets the approx_global_feature_contrib of this TrainingOptions.

        Whether to use approximate feature contribution method in XGBoost model explanation for global explain.

        :param approx_global_feature_contrib: The approx_global_feature_contrib of this TrainingOptions.
        :type approx_global_feature_contrib: bool
        """

        self._approx_global_feature_contrib = approx_global_feature_contrib

    @property
    def auto_arima(self):
        """Gets the auto_arima of this TrainingOptions.

        Whether to enable auto ARIMA or not.

        :return: The auto_arima of this TrainingOptions.
        :rtype: bool
        """
        return self._auto_arima

    @auto_arima.setter
    def auto_arima(self, auto_arima):
        """Sets the auto_arima of this TrainingOptions.

        Whether to enable auto ARIMA or not.

        :param auto_arima: The auto_arima of this TrainingOptions.
        :type auto_arima: bool
        """

        self._auto_arima = auto_arima

    @property
    def auto_arima_max_order(self):
        """Gets the auto_arima_max_order of this TrainingOptions.

        The max value of the sum of non-seasonal p and q.

        :return: The auto_arima_max_order of this TrainingOptions.
        :rtype: str
        """
        return self._auto_arima_max_order

    @auto_arima_max_order.setter
    def auto_arima_max_order(self, auto_arima_max_order):
        """Sets the auto_arima_max_order of this TrainingOptions.

        The max value of the sum of non-seasonal p and q.

        :param auto_arima_max_order: The auto_arima_max_order of this TrainingOptions.
        :type auto_arima_max_order: str
        """

        self._auto_arima_max_order = auto_arima_max_order

    @property
    def auto_arima_min_order(self):
        """Gets the auto_arima_min_order of this TrainingOptions.

        The min value of the sum of non-seasonal p and q.

        :return: The auto_arima_min_order of this TrainingOptions.
        :rtype: str
        """
        return self._auto_arima_min_order

    @auto_arima_min_order.setter
    def auto_arima_min_order(self, auto_arima_min_order):
        """Sets the auto_arima_min_order of this TrainingOptions.

        The min value of the sum of non-seasonal p and q.

        :param auto_arima_min_order: The auto_arima_min_order of this TrainingOptions.
        :type auto_arima_min_order: str
        """

        self._auto_arima_min_order = auto_arima_min_order

    @property
    def auto_class_weights(self):
        """Gets the auto_class_weights of this TrainingOptions.

        Whether to calculate class weights automatically based on the popularity of each label.

        :return: The auto_class_weights of this TrainingOptions.
        :rtype: bool
        """
        return self._auto_class_weights

    @auto_class_weights.setter
    def auto_class_weights(self, auto_class_weights):
        """Sets the auto_class_weights of this TrainingOptions.

        Whether to calculate class weights automatically based on the popularity of each label.

        :param auto_class_weights: The auto_class_weights of this TrainingOptions.
        :type auto_class_weights: bool
        """

        self._auto_class_weights = auto_class_weights

    @property
    def batch_size(self):
        """Gets the batch_size of this TrainingOptions.

        Batch size for dnn models.

        :return: The batch_size of this TrainingOptions.
        :rtype: str
        """
        return self._batch_size

    @batch_size.setter
    def batch_size(self, batch_size):
        """Sets the batch_size of this TrainingOptions.

        Batch size for dnn models.

        :param batch_size: The batch_size of this TrainingOptions.
        :type batch_size: str
        """

        self._batch_size = batch_size

    @property
    def booster_type(self):
        """Gets the booster_type of this TrainingOptions.

        Booster type for boosted tree models.

        :return: The booster_type of this TrainingOptions.
        :rtype: str
        """
        return self._booster_type

    @booster_type.setter
    def booster_type(self, booster_type):
        """Sets the booster_type of this TrainingOptions.

        Booster type for boosted tree models.

        :param booster_type: The booster_type of this TrainingOptions.
        :type booster_type: str
        """
        allowed_values = ["BOOSTER_TYPE_UNSPECIFIED", "GBTREE", "DART"]  # noqa: E501
        if booster_type not in allowed_values:
            raise ValueError(
                "Invalid value for `booster_type` ({0}), must be one of {1}"
                .format(booster_type, allowed_values)
            )

        self._booster_type = booster_type

    @property
    def budget_hours(self):
        """Gets the budget_hours of this TrainingOptions.

        Budget in hours for AutoML training.

        :return: The budget_hours of this TrainingOptions.
        :rtype: float
        """
        return self._budget_hours

    @budget_hours.setter
    def budget_hours(self, budget_hours):
        """Sets the budget_hours of this TrainingOptions.

        Budget in hours for AutoML training.

        :param budget_hours: The budget_hours of this TrainingOptions.
        :type budget_hours: float
        """

        self._budget_hours = budget_hours

    @property
    def calculate_p_values(self):
        """Gets the calculate_p_values of this TrainingOptions.

        Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.

        :return: The calculate_p_values of this TrainingOptions.
        :rtype: bool
        """
        return self._calculate_p_values

    @calculate_p_values.setter
    def calculate_p_values(self, calculate_p_values):
        """Sets the calculate_p_values of this TrainingOptions.

        Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.

        :param calculate_p_values: The calculate_p_values of this TrainingOptions.
        :type calculate_p_values: bool
        """

        self._calculate_p_values = calculate_p_values

    @property
    def category_encoding_method(self):
        """Gets the category_encoding_method of this TrainingOptions.

        Categorical feature encoding method.

        :return: The category_encoding_method of this TrainingOptions.
        :rtype: str
        """
        return self._category_encoding_method

    @category_encoding_method.setter
    def category_encoding_method(self, category_encoding_method):
        """Sets the category_encoding_method of this TrainingOptions.

        Categorical feature encoding method.

        :param category_encoding_method: The category_encoding_method of this TrainingOptions.
        :type category_encoding_method: str
        """
        allowed_values = ["ENCODING_METHOD_UNSPECIFIED", "ONE_HOT_ENCODING", "LABEL_ENCODING", "DUMMY_ENCODING"]  # noqa: E501
        if category_encoding_method not in allowed_values:
            raise ValueError(
                "Invalid value for `category_encoding_method` ({0}), must be one of {1}"
                .format(category_encoding_method, allowed_values)
            )

        self._category_encoding_method = category_encoding_method

    @property
    def clean_spikes_and_dips(self):
        """Gets the clean_spikes_and_dips of this TrainingOptions.

        If true, clean spikes and dips in the input time series.

        :return: The clean_spikes_and_dips of this TrainingOptions.
        :rtype: bool
        """
        return self._clean_spikes_and_dips

    @clean_spikes_and_dips.setter
    def clean_spikes_and_dips(self, clean_spikes_and_dips):
        """Sets the clean_spikes_and_dips of this TrainingOptions.

        If true, clean spikes and dips in the input time series.

        :param clean_spikes_and_dips: The clean_spikes_and_dips of this TrainingOptions.
        :type clean_spikes_and_dips: bool
        """

        self._clean_spikes_and_dips = clean_spikes_and_dips

    @property
    def color_space(self):
        """Gets the color_space of this TrainingOptions.

        Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.

        :return: The color_space of this TrainingOptions.
        :rtype: str
        """
        return self._color_space

    @color_space.setter
    def color_space(self, color_space):
        """Sets the color_space of this TrainingOptions.

        Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.

        :param color_space: The color_space of this TrainingOptions.
        :type color_space: str
        """
        allowed_values = ["COLOR_SPACE_UNSPECIFIED", "RGB", "HSV", "YIQ", "YUV", "GRAYSCALE"]  # noqa: E501
        if color_space not in allowed_values:
            raise ValueError(
                "Invalid value for `color_space` ({0}), must be one of {1}"
                .format(color_space, allowed_values)
            )

        self._color_space = color_space

    @property
    def colsample_bylevel(self):
        """Gets the colsample_bylevel of this TrainingOptions.

        Subsample ratio of columns for each level for boosted tree models.

        :return: The colsample_bylevel of this TrainingOptions.
        :rtype: float
        """
        return self._colsample_bylevel

    @colsample_bylevel.setter
    def colsample_bylevel(self, colsample_bylevel):
        """Sets the colsample_bylevel of this TrainingOptions.

        Subsample ratio of columns for each level for boosted tree models.

        :param colsample_bylevel: The colsample_bylevel of this TrainingOptions.
        :type colsample_bylevel: float
        """

        self._colsample_bylevel = colsample_bylevel

    @property
    def colsample_bynode(self):
        """Gets the colsample_bynode of this TrainingOptions.

        Subsample ratio of columns for each node(split) for boosted tree models.

        :return: The colsample_bynode of this TrainingOptions.
        :rtype: float
        """
        return self._colsample_bynode

    @colsample_bynode.setter
    def colsample_bynode(self, colsample_bynode):
        """Sets the colsample_bynode of this TrainingOptions.

        Subsample ratio of columns for each node(split) for boosted tree models.

        :param colsample_bynode: The colsample_bynode of this TrainingOptions.
        :type colsample_bynode: float
        """

        self._colsample_bynode = colsample_bynode

    @property
    def colsample_bytree(self):
        """Gets the colsample_bytree of this TrainingOptions.

        Subsample ratio of columns when constructing each tree for boosted tree models.

        :return: The colsample_bytree of this TrainingOptions.
        :rtype: float
        """
        return self._colsample_bytree

    @colsample_bytree.setter
    def colsample_bytree(self, colsample_bytree):
        """Sets the colsample_bytree of this TrainingOptions.

        Subsample ratio of columns when constructing each tree for boosted tree models.

        :param colsample_bytree: The colsample_bytree of this TrainingOptions.
        :type colsample_bytree: float
        """

        self._colsample_bytree = colsample_bytree

    @property
    def dart_normalize_type(self):
        """Gets the dart_normalize_type of this TrainingOptions.

        Type of normalization algorithm for boosted tree models using dart booster.

        :return: The dart_normalize_type of this TrainingOptions.
        :rtype: str
        """
        return self._dart_normalize_type

    @dart_normalize_type.setter
    def dart_normalize_type(self, dart_normalize_type):
        """Sets the dart_normalize_type of this TrainingOptions.

        Type of normalization algorithm for boosted tree models using dart booster.

        :param dart_normalize_type: The dart_normalize_type of this TrainingOptions.
        :type dart_normalize_type: str
        """
        allowed_values = ["DART_NORMALIZE_TYPE_UNSPECIFIED", "TREE", "FOREST"]  # noqa: E501
        if dart_normalize_type not in allowed_values:
            raise ValueError(
                "Invalid value for `dart_normalize_type` ({0}), must be one of {1}"
                .format(dart_normalize_type, allowed_values)
            )

        self._dart_normalize_type = dart_normalize_type

    @property
    def data_frequency(self):
        """Gets the data_frequency of this TrainingOptions.

        The data frequency of a time series.

        :return: The data_frequency of this TrainingOptions.
        :rtype: str
        """
        return self._data_frequency

    @data_frequency.setter
    def data_frequency(self, data_frequency):
        """Sets the data_frequency of this TrainingOptions.

        The data frequency of a time series.

        :param data_frequency: The data_frequency of this TrainingOptions.
        :type data_frequency: str
        """
        allowed_values = ["DATA_FREQUENCY_UNSPECIFIED", "AUTO_FREQUENCY", "YEARLY", "QUARTERLY", "MONTHLY", "WEEKLY", "DAILY", "HOURLY", "PER_MINUTE"]  # noqa: E501
        if data_frequency not in allowed_values:
            raise ValueError(
                "Invalid value for `data_frequency` ({0}), must be one of {1}"
                .format(data_frequency, allowed_values)
            )

        self._data_frequency = data_frequency

    @property
    def data_split_column(self):
        """Gets the data_split_column of this TrainingOptions.

        The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties

        :return: The data_split_column of this TrainingOptions.
        :rtype: str
        """
        return self._data_split_column

    @data_split_column.setter
    def data_split_column(self, data_split_column):
        """Sets the data_split_column of this TrainingOptions.

        The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties

        :param data_split_column: The data_split_column of this TrainingOptions.
        :type data_split_column: str
        """

        self._data_split_column = data_split_column

    @property
    def data_split_eval_fraction(self):
        """Gets the data_split_eval_fraction of this TrainingOptions.

        The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.

        :return: The data_split_eval_fraction of this TrainingOptions.
        :rtype: float
        """
        return self._data_split_eval_fraction

    @data_split_eval_fraction.setter
    def data_split_eval_fraction(self, data_split_eval_fraction):
        """Sets the data_split_eval_fraction of this TrainingOptions.

        The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.

        :param data_split_eval_fraction: The data_split_eval_fraction of this TrainingOptions.
        :type data_split_eval_fraction: float
        """

        self._data_split_eval_fraction = data_split_eval_fraction

    @property
    def data_split_method(self):
        """Gets the data_split_method of this TrainingOptions.

        The data split type for training and evaluation, e.g. RANDOM.

        :return: The data_split_method of this TrainingOptions.
        :rtype: str
        """
        return self._data_split_method

    @data_split_method.setter
    def data_split_method(self, data_split_method):
        """Sets the data_split_method of this TrainingOptions.

        The data split type for training and evaluation, e.g. RANDOM.

        :param data_split_method: The data_split_method of this TrainingOptions.
        :type data_split_method: str
        """
        allowed_values = ["DATA_SPLIT_METHOD_UNSPECIFIED", "RANDOM", "CUSTOM", "SEQUENTIAL", "NO_SPLIT", "AUTO_SPLIT"]  # noqa: E501
        if data_split_method not in allowed_values:
            raise ValueError(
                "Invalid value for `data_split_method` ({0}), must be one of {1}"
                .format(data_split_method, allowed_values)
            )

        self._data_split_method = data_split_method

    @property
    def decompose_time_series(self):
        """Gets the decompose_time_series of this TrainingOptions.

        If true, perform decompose time series and save the results.

        :return: The decompose_time_series of this TrainingOptions.
        :rtype: bool
        """
        return self._decompose_time_series

    @decompose_time_series.setter
    def decompose_time_series(self, decompose_time_series):
        """Sets the decompose_time_series of this TrainingOptions.

        If true, perform decompose time series and save the results.

        :param decompose_time_series: The decompose_time_series of this TrainingOptions.
        :type decompose_time_series: bool
        """

        self._decompose_time_series = decompose_time_series

    @property
    def distance_type(self):
        """Gets the distance_type of this TrainingOptions.

        Distance type for clustering models.

        :return: The distance_type of this TrainingOptions.
        :rtype: str
        """
        return self._distance_type

    @distance_type.setter
    def distance_type(self, distance_type):
        """Sets the distance_type of this TrainingOptions.

        Distance type for clustering models.

        :param distance_type: The distance_type of this TrainingOptions.
        :type distance_type: str
        """
        allowed_values = ["DISTANCE_TYPE_UNSPECIFIED", "EUCLIDEAN", "COSINE"]  # noqa: E501
        if distance_type not in allowed_values:
            raise ValueError(
                "Invalid value for `distance_type` ({0}), must be one of {1}"
                .format(distance_type, allowed_values)
            )

        self._distance_type = distance_type

    @property
    def dropout(self):
        """Gets the dropout of this TrainingOptions.

        Dropout probability for dnn models.

        :return: The dropout of this TrainingOptions.
        :rtype: float
        """
        return self._dropout

    @dropout.setter
    def dropout(self, dropout):
        """Sets the dropout of this TrainingOptions.

        Dropout probability for dnn models.

        :param dropout: The dropout of this TrainingOptions.
        :type dropout: float
        """

        self._dropout = dropout

    @property
    def early_stop(self):
        """Gets the early_stop of this TrainingOptions.

        Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.

        :return: The early_stop of this TrainingOptions.
        :rtype: bool
        """
        return self._early_stop

    @early_stop.setter
    def early_stop(self, early_stop):
        """Sets the early_stop of this TrainingOptions.

        Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.

        :param early_stop: The early_stop of this TrainingOptions.
        :type early_stop: bool
        """

        self._early_stop = early_stop

    @property
    def enable_global_explain(self):
        """Gets the enable_global_explain of this TrainingOptions.

        If true, enable global explanation during training.

        :return: The enable_global_explain of this TrainingOptions.
        :rtype: bool
        """
        return self._enable_global_explain

    @enable_global_explain.setter
    def enable_global_explain(self, enable_global_explain):
        """Sets the enable_global_explain of this TrainingOptions.

        If true, enable global explanation during training.

        :param enable_global_explain: The enable_global_explain of this TrainingOptions.
        :type enable_global_explain: bool
        """

        self._enable_global_explain = enable_global_explain

    @property
    def feedback_type(self):
        """Gets the feedback_type of this TrainingOptions.

        Feedback type that specifies which algorithm to run for matrix factorization.

        :return: The feedback_type of this TrainingOptions.
        :rtype: str
        """
        return self._feedback_type

    @feedback_type.setter
    def feedback_type(self, feedback_type):
        """Sets the feedback_type of this TrainingOptions.

        Feedback type that specifies which algorithm to run for matrix factorization.

        :param feedback_type: The feedback_type of this TrainingOptions.
        :type feedback_type: str
        """
        allowed_values = ["FEEDBACK_TYPE_UNSPECIFIED", "IMPLICIT", "EXPLICIT"]  # noqa: E501
        if feedback_type not in allowed_values:
            raise ValueError(
                "Invalid value for `feedback_type` ({0}), must be one of {1}"
                .format(feedback_type, allowed_values)
            )

        self._feedback_type = feedback_type

    @property
    def fit_intercept(self):
        """Gets the fit_intercept of this TrainingOptions.

        Whether the model should include intercept during model training.

        :return: The fit_intercept of this TrainingOptions.
        :rtype: bool
        """
        return self._fit_intercept

    @fit_intercept.setter
    def fit_intercept(self, fit_intercept):
        """Sets the fit_intercept of this TrainingOptions.

        Whether the model should include intercept during model training.

        :param fit_intercept: The fit_intercept of this TrainingOptions.
        :type fit_intercept: bool
        """

        self._fit_intercept = fit_intercept

    @property
    def hidden_units(self):
        """Gets the hidden_units of this TrainingOptions.

        Hidden units for dnn models.

        :return: The hidden_units of this TrainingOptions.
        :rtype: List[str]
        """
        return self._hidden_units

    @hidden_units.setter
    def hidden_units(self, hidden_units):
        """Sets the hidden_units of this TrainingOptions.

        Hidden units for dnn models.

        :param hidden_units: The hidden_units of this TrainingOptions.
        :type hidden_units: List[str]
        """

        self._hidden_units = hidden_units

    @property
    def holiday_region(self):
        """Gets the holiday_region of this TrainingOptions.

        The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.

        :return: The holiday_region of this TrainingOptions.
        :rtype: str
        """
        return self._holiday_region

    @holiday_region.setter
    def holiday_region(self, holiday_region):
        """Sets the holiday_region of this TrainingOptions.

        The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.

        :param holiday_region: The holiday_region of this TrainingOptions.
        :type holiday_region: str
        """
        allowed_values = ["HOLIDAY_REGION_UNSPECIFIED", "GLOBAL", "NA", "JAPAC", "EMEA", "LAC", "AE", "AR", "AT", "AU", "BE", "BR", "CA", "CH", "CL", "CN", "CO", "CS", "CZ", "DE", "DK", "DZ", "EC", "EE", "EG", "ES", "FI", "FR", "GB", "GR", "HK", "HU", "ID", "IE", "IL", "IN", "IR", "IT", "JP", "KR", "LV", "MA", "MX", "MY", "NG", "NL", "false", "NZ", "PE", "PH", "PK", "PL", "PT", "RO", "RS", "RU", "SA", "SE", "SG", "SI", "SK", "TH", "TR", "TW", "UA", "US", "VE", "VN", "ZA"]  # noqa: E501
        if holiday_region not in allowed_values:
            raise ValueError(
                "Invalid value for `holiday_region` ({0}), must be one of {1}"
                .format(holiday_region, allowed_values)
            )

        self._holiday_region = holiday_region

    @property
    def holiday_regions(self):
        """Gets the holiday_regions of this TrainingOptions.

        A list of geographical regions that are used for time series modeling.

        :return: The holiday_regions of this TrainingOptions.
        :rtype: List[str]
        """
        return self._holiday_regions

    @holiday_regions.setter
    def holiday_regions(self, holiday_regions):
        """Sets the holiday_regions of this TrainingOptions.

        A list of geographical regions that are used for time series modeling.

        :param holiday_regions: The holiday_regions of this TrainingOptions.
        :type holiday_regions: List[str]
        """
        allowed_values = ["HOLIDAY_REGION_UNSPECIFIED", "GLOBAL", "NA", "JAPAC", "EMEA", "LAC", "AE", "AR", "AT", "AU", "BE", "BR", "CA", "CH", "CL", "CN", "CO", "CS", "CZ", "DE", "DK", "DZ", "EC", "EE", "EG", "ES", "FI", "FR", "GB", "GR", "HK", "HU", "ID", "IE", "IL", "IN", "IR", "IT", "JP", "KR", "LV", "MA", "MX", "MY", "NG", "NL", "false", "NZ", "PE", "PH", "PK", "PL", "PT", "RO", "RS", "RU", "SA", "SE", "SG", "SI", "SK", "TH", "TR", "TW", "UA", "US", "VE", "VN", "ZA"]  # noqa: E501
        if not set(holiday_regions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `holiday_regions` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(holiday_regions) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._holiday_regions = holiday_regions

    @property
    def horizon(self):
        """Gets the horizon of this TrainingOptions.

        The number of periods ahead that need to be forecasted.

        :return: The horizon of this TrainingOptions.
        :rtype: str
        """
        return self._horizon

    @horizon.setter
    def horizon(self, horizon):
        """Sets the horizon of this TrainingOptions.

        The number of periods ahead that need to be forecasted.

        :param horizon: The horizon of this TrainingOptions.
        :type horizon: str
        """

        self._horizon = horizon

    @property
    def hparam_tuning_objectives(self):
        """Gets the hparam_tuning_objectives of this TrainingOptions.

        The target evaluation metrics to optimize the hyperparameters for.

        :return: The hparam_tuning_objectives of this TrainingOptions.
        :rtype: List[str]
        """
        return self._hparam_tuning_objectives

    @hparam_tuning_objectives.setter
    def hparam_tuning_objectives(self, hparam_tuning_objectives):
        """Sets the hparam_tuning_objectives of this TrainingOptions.

        The target evaluation metrics to optimize the hyperparameters for.

        :param hparam_tuning_objectives: The hparam_tuning_objectives of this TrainingOptions.
        :type hparam_tuning_objectives: List[str]
        """
        allowed_values = ["HPARAM_TUNING_OBJECTIVE_UNSPECIFIED", "MEAN_ABSOLUTE_ERROR", "MEAN_SQUARED_ERROR", "MEAN_SQUARED_LOG_ERROR", "MEDIAN_ABSOLUTE_ERROR", "R_SQUARED", "EXPLAINED_VARIANCE", "PRECISION", "RECALL", "ACCURACY", "F1_SCORE", "LOG_LOSS", "ROC_AUC", "DAVIES_BOULDIN_INDEX", "MEAN_AVERAGE_PRECISION", "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN", "AVERAGE_RANK"]  # noqa: E501
        if not set(hparam_tuning_objectives).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `hparam_tuning_objectives` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(hparam_tuning_objectives) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._hparam_tuning_objectives = hparam_tuning_objectives

    @property
    def include_drift(self):
        """Gets the include_drift of this TrainingOptions.

        Include drift when fitting an ARIMA model.

        :return: The include_drift of this TrainingOptions.
        :rtype: bool
        """
        return self._include_drift

    @include_drift.setter
    def include_drift(self, include_drift):
        """Sets the include_drift of this TrainingOptions.

        Include drift when fitting an ARIMA model.

        :param include_drift: The include_drift of this TrainingOptions.
        :type include_drift: bool
        """

        self._include_drift = include_drift

    @property
    def initial_learn_rate(self):
        """Gets the initial_learn_rate of this TrainingOptions.

        Specifies the initial learning rate for the line search learn rate strategy.

        :return: The initial_learn_rate of this TrainingOptions.
        :rtype: float
        """
        return self._initial_learn_rate

    @initial_learn_rate.setter
    def initial_learn_rate(self, initial_learn_rate):
        """Sets the initial_learn_rate of this TrainingOptions.

        Specifies the initial learning rate for the line search learn rate strategy.

        :param initial_learn_rate: The initial_learn_rate of this TrainingOptions.
        :type initial_learn_rate: float
        """

        self._initial_learn_rate = initial_learn_rate

    @property
    def input_label_columns(self):
        """Gets the input_label_columns of this TrainingOptions.

        Name of input label columns in training data.

        :return: The input_label_columns of this TrainingOptions.
        :rtype: List[str]
        """
        return self._input_label_columns

    @input_label_columns.setter
    def input_label_columns(self, input_label_columns):
        """Sets the input_label_columns of this TrainingOptions.

        Name of input label columns in training data.

        :param input_label_columns: The input_label_columns of this TrainingOptions.
        :type input_label_columns: List[str]
        """

        self._input_label_columns = input_label_columns

    @property
    def instance_weight_column(self):
        """Gets the instance_weight_column of this TrainingOptions.

        Name of the instance weight column for training data. This column isn't be used as a feature.

        :return: The instance_weight_column of this TrainingOptions.
        :rtype: str
        """
        return self._instance_weight_column

    @instance_weight_column.setter
    def instance_weight_column(self, instance_weight_column):
        """Sets the instance_weight_column of this TrainingOptions.

        Name of the instance weight column for training data. This column isn't be used as a feature.

        :param instance_weight_column: The instance_weight_column of this TrainingOptions.
        :type instance_weight_column: str
        """

        self._instance_weight_column = instance_weight_column

    @property
    def integrated_gradients_num_steps(self):
        """Gets the integrated_gradients_num_steps of this TrainingOptions.

        Number of integral steps for the integrated gradients explain method.

        :return: The integrated_gradients_num_steps of this TrainingOptions.
        :rtype: str
        """
        return self._integrated_gradients_num_steps

    @integrated_gradients_num_steps.setter
    def integrated_gradients_num_steps(self, integrated_gradients_num_steps):
        """Sets the integrated_gradients_num_steps of this TrainingOptions.

        Number of integral steps for the integrated gradients explain method.

        :param integrated_gradients_num_steps: The integrated_gradients_num_steps of this TrainingOptions.
        :type integrated_gradients_num_steps: str
        """

        self._integrated_gradients_num_steps = integrated_gradients_num_steps

    @property
    def item_column(self):
        """Gets the item_column of this TrainingOptions.

        Item column specified for matrix factorization models.

        :return: The item_column of this TrainingOptions.
        :rtype: str
        """
        return self._item_column

    @item_column.setter
    def item_column(self, item_column):
        """Sets the item_column of this TrainingOptions.

        Item column specified for matrix factorization models.

        :param item_column: The item_column of this TrainingOptions.
        :type item_column: str
        """

        self._item_column = item_column

    @property
    def kmeans_initialization_column(self):
        """Gets the kmeans_initialization_column of this TrainingOptions.

        The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.

        :return: The kmeans_initialization_column of this TrainingOptions.
        :rtype: str
        """
        return self._kmeans_initialization_column

    @kmeans_initialization_column.setter
    def kmeans_initialization_column(self, kmeans_initialization_column):
        """Sets the kmeans_initialization_column of this TrainingOptions.

        The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.

        :param kmeans_initialization_column: The kmeans_initialization_column of this TrainingOptions.
        :type kmeans_initialization_column: str
        """

        self._kmeans_initialization_column = kmeans_initialization_column

    @property
    def kmeans_initialization_method(self):
        """Gets the kmeans_initialization_method of this TrainingOptions.

        The method used to initialize the centroids for kmeans algorithm.

        :return: The kmeans_initialization_method of this TrainingOptions.
        :rtype: str
        """
        return self._kmeans_initialization_method

    @kmeans_initialization_method.setter
    def kmeans_initialization_method(self, kmeans_initialization_method):
        """Sets the kmeans_initialization_method of this TrainingOptions.

        The method used to initialize the centroids for kmeans algorithm.

        :param kmeans_initialization_method: The kmeans_initialization_method of this TrainingOptions.
        :type kmeans_initialization_method: str
        """
        allowed_values = ["KMEANS_INITIALIZATION_METHOD_UNSPECIFIED", "RANDOM", "CUSTOM", "KMEANS_PLUS_PLUS"]  # noqa: E501
        if kmeans_initialization_method not in allowed_values:
            raise ValueError(
                "Invalid value for `kmeans_initialization_method` ({0}), must be one of {1}"
                .format(kmeans_initialization_method, allowed_values)
            )

        self._kmeans_initialization_method = kmeans_initialization_method

    @property
    def l1_reg_activation(self):
        """Gets the l1_reg_activation of this TrainingOptions.

        L1 regularization coefficient to activations.

        :return: The l1_reg_activation of this TrainingOptions.
        :rtype: float
        """
        return self._l1_reg_activation

    @l1_reg_activation.setter
    def l1_reg_activation(self, l1_reg_activation):
        """Sets the l1_reg_activation of this TrainingOptions.

        L1 regularization coefficient to activations.

        :param l1_reg_activation: The l1_reg_activation of this TrainingOptions.
        :type l1_reg_activation: float
        """

        self._l1_reg_activation = l1_reg_activation

    @property
    def l1_regularization(self):
        """Gets the l1_regularization of this TrainingOptions.

        L1 regularization coefficient.

        :return: The l1_regularization of this TrainingOptions.
        :rtype: float
        """
        return self._l1_regularization

    @l1_regularization.setter
    def l1_regularization(self, l1_regularization):
        """Sets the l1_regularization of this TrainingOptions.

        L1 regularization coefficient.

        :param l1_regularization: The l1_regularization of this TrainingOptions.
        :type l1_regularization: float
        """

        self._l1_regularization = l1_regularization

    @property
    def l2_regularization(self):
        """Gets the l2_regularization of this TrainingOptions.

        L2 regularization coefficient.

        :return: The l2_regularization of this TrainingOptions.
        :rtype: float
        """
        return self._l2_regularization

    @l2_regularization.setter
    def l2_regularization(self, l2_regularization):
        """Sets the l2_regularization of this TrainingOptions.

        L2 regularization coefficient.

        :param l2_regularization: The l2_regularization of this TrainingOptions.
        :type l2_regularization: float
        """

        self._l2_regularization = l2_regularization

    @property
    def label_class_weights(self):
        """Gets the label_class_weights of this TrainingOptions.

        Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.

        :return: The label_class_weights of this TrainingOptions.
        :rtype: Dict[str, float]
        """
        return self._label_class_weights

    @label_class_weights.setter
    def label_class_weights(self, label_class_weights):
        """Sets the label_class_weights of this TrainingOptions.

        Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.

        :param label_class_weights: The label_class_weights of this TrainingOptions.
        :type label_class_weights: Dict[str, float]
        """

        self._label_class_weights = label_class_weights

    @property
    def learn_rate(self):
        """Gets the learn_rate of this TrainingOptions.

        Learning rate in training. Used only for iterative training algorithms.

        :return: The learn_rate of this TrainingOptions.
        :rtype: float
        """
        return self._learn_rate

    @learn_rate.setter
    def learn_rate(self, learn_rate):
        """Sets the learn_rate of this TrainingOptions.

        Learning rate in training. Used only for iterative training algorithms.

        :param learn_rate: The learn_rate of this TrainingOptions.
        :type learn_rate: float
        """

        self._learn_rate = learn_rate

    @property
    def learn_rate_strategy(self):
        """Gets the learn_rate_strategy of this TrainingOptions.

        The strategy to determine learn rate for the current iteration.

        :return: The learn_rate_strategy of this TrainingOptions.
        :rtype: str
        """
        return self._learn_rate_strategy

    @learn_rate_strategy.setter
    def learn_rate_strategy(self, learn_rate_strategy):
        """Sets the learn_rate_strategy of this TrainingOptions.

        The strategy to determine learn rate for the current iteration.

        :param learn_rate_strategy: The learn_rate_strategy of this TrainingOptions.
        :type learn_rate_strategy: str
        """
        allowed_values = ["LEARN_RATE_STRATEGY_UNSPECIFIED", "LINE_SEARCH", "CONSTANT"]  # noqa: E501
        if learn_rate_strategy not in allowed_values:
            raise ValueError(
                "Invalid value for `learn_rate_strategy` ({0}), must be one of {1}"
                .format(learn_rate_strategy, allowed_values)
            )

        self._learn_rate_strategy = learn_rate_strategy

    @property
    def loss_type(self):
        """Gets the loss_type of this TrainingOptions.

        Type of loss function used during training run.

        :return: The loss_type of this TrainingOptions.
        :rtype: str
        """
        return self._loss_type

    @loss_type.setter
    def loss_type(self, loss_type):
        """Sets the loss_type of this TrainingOptions.

        Type of loss function used during training run.

        :param loss_type: The loss_type of this TrainingOptions.
        :type loss_type: str
        """
        allowed_values = ["LOSS_TYPE_UNSPECIFIED", "MEAN_SQUARED_LOSS", "MEAN_LOG_LOSS"]  # noqa: E501
        if loss_type not in allowed_values:
            raise ValueError(
                "Invalid value for `loss_type` ({0}), must be one of {1}"
                .format(loss_type, allowed_values)
            )

        self._loss_type = loss_type

    @property
    def max_iterations(self):
        """Gets the max_iterations of this TrainingOptions.

        The maximum number of iterations in training. Used only for iterative training algorithms.

        :return: The max_iterations of this TrainingOptions.
        :rtype: str
        """
        return self._max_iterations

    @max_iterations.setter
    def max_iterations(self, max_iterations):
        """Sets the max_iterations of this TrainingOptions.

        The maximum number of iterations in training. Used only for iterative training algorithms.

        :param max_iterations: The max_iterations of this TrainingOptions.
        :type max_iterations: str
        """

        self._max_iterations = max_iterations

    @property
    def max_parallel_trials(self):
        """Gets the max_parallel_trials of this TrainingOptions.

        Maximum number of trials to run in parallel.

        :return: The max_parallel_trials of this TrainingOptions.
        :rtype: str
        """
        return self._max_parallel_trials

    @max_parallel_trials.setter
    def max_parallel_trials(self, max_parallel_trials):
        """Sets the max_parallel_trials of this TrainingOptions.

        Maximum number of trials to run in parallel.

        :param max_parallel_trials: The max_parallel_trials of this TrainingOptions.
        :type max_parallel_trials: str
        """

        self._max_parallel_trials = max_parallel_trials

    @property
    def max_time_series_length(self):
        """Gets the max_time_series_length of this TrainingOptions.

        The maximum number of time points in a time series that can be used in modeling the trend component of the time series. Don't use this option with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.

        :return: The max_time_series_length of this TrainingOptions.
        :rtype: str
        """
        return self._max_time_series_length

    @max_time_series_length.setter
    def max_time_series_length(self, max_time_series_length):
        """Sets the max_time_series_length of this TrainingOptions.

        The maximum number of time points in a time series that can be used in modeling the trend component of the time series. Don't use this option with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.

        :param max_time_series_length: The max_time_series_length of this TrainingOptions.
        :type max_time_series_length: str
        """

        self._max_time_series_length = max_time_series_length

    @property
    def max_tree_depth(self):
        """Gets the max_tree_depth of this TrainingOptions.

        Maximum depth of a tree for boosted tree models.

        :return: The max_tree_depth of this TrainingOptions.
        :rtype: str
        """
        return self._max_tree_depth

    @max_tree_depth.setter
    def max_tree_depth(self, max_tree_depth):
        """Sets the max_tree_depth of this TrainingOptions.

        Maximum depth of a tree for boosted tree models.

        :param max_tree_depth: The max_tree_depth of this TrainingOptions.
        :type max_tree_depth: str
        """

        self._max_tree_depth = max_tree_depth

    @property
    def min_relative_progress(self):
        """Gets the min_relative_progress of this TrainingOptions.

        When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.

        :return: The min_relative_progress of this TrainingOptions.
        :rtype: float
        """
        return self._min_relative_progress

    @min_relative_progress.setter
    def min_relative_progress(self, min_relative_progress):
        """Sets the min_relative_progress of this TrainingOptions.

        When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.

        :param min_relative_progress: The min_relative_progress of this TrainingOptions.
        :type min_relative_progress: float
        """

        self._min_relative_progress = min_relative_progress

    @property
    def min_split_loss(self):
        """Gets the min_split_loss of this TrainingOptions.

        Minimum split loss for boosted tree models.

        :return: The min_split_loss of this TrainingOptions.
        :rtype: float
        """
        return self._min_split_loss

    @min_split_loss.setter
    def min_split_loss(self, min_split_loss):
        """Sets the min_split_loss of this TrainingOptions.

        Minimum split loss for boosted tree models.

        :param min_split_loss: The min_split_loss of this TrainingOptions.
        :type min_split_loss: float
        """

        self._min_split_loss = min_split_loss

    @property
    def min_time_series_length(self):
        """Gets the min_time_series_length of this TrainingOptions.

        The minimum number of time points in a time series that are used in modeling the trend component of the time series. If you use this option you must also set the `timeSeriesLengthFraction` option. This training option ensures that enough time points are available when you use `timeSeriesLengthFraction` in trend modeling. This is particularly important when forecasting multiple time series in a single query using `timeSeriesIdColumn`. If the total number of time points is less than the `minTimeSeriesLength` value, then the query uses all available time points.

        :return: The min_time_series_length of this TrainingOptions.
        :rtype: str
        """
        return self._min_time_series_length

    @min_time_series_length.setter
    def min_time_series_length(self, min_time_series_length):
        """Sets the min_time_series_length of this TrainingOptions.

        The minimum number of time points in a time series that are used in modeling the trend component of the time series. If you use this option you must also set the `timeSeriesLengthFraction` option. This training option ensures that enough time points are available when you use `timeSeriesLengthFraction` in trend modeling. This is particularly important when forecasting multiple time series in a single query using `timeSeriesIdColumn`. If the total number of time points is less than the `minTimeSeriesLength` value, then the query uses all available time points.

        :param min_time_series_length: The min_time_series_length of this TrainingOptions.
        :type min_time_series_length: str
        """

        self._min_time_series_length = min_time_series_length

    @property
    def min_tree_child_weight(self):
        """Gets the min_tree_child_weight of this TrainingOptions.

        Minimum sum of instance weight needed in a child for boosted tree models.

        :return: The min_tree_child_weight of this TrainingOptions.
        :rtype: str
        """
        return self._min_tree_child_weight

    @min_tree_child_weight.setter
    def min_tree_child_weight(self, min_tree_child_weight):
        """Sets the min_tree_child_weight of this TrainingOptions.

        Minimum sum of instance weight needed in a child for boosted tree models.

        :param min_tree_child_weight: The min_tree_child_weight of this TrainingOptions.
        :type min_tree_child_weight: str
        """

        self._min_tree_child_weight = min_tree_child_weight

    @property
    def model_registry(self):
        """Gets the model_registry of this TrainingOptions.

        The model registry.

        :return: The model_registry of this TrainingOptions.
        :rtype: str
        """
        return self._model_registry

    @model_registry.setter
    def model_registry(self, model_registry):
        """Sets the model_registry of this TrainingOptions.

        The model registry.

        :param model_registry: The model_registry of this TrainingOptions.
        :type model_registry: str
        """
        allowed_values = ["MODEL_REGISTRY_UNSPECIFIED", "VERTEX_AI"]  # noqa: E501
        if model_registry not in allowed_values:
            raise ValueError(
                "Invalid value for `model_registry` ({0}), must be one of {1}"
                .format(model_registry, allowed_values)
            )

        self._model_registry = model_registry

    @property
    def model_uri(self):
        """Gets the model_uri of this TrainingOptions.

        Google Cloud Storage URI from which the model was imported. Only applicable for imported models.

        :return: The model_uri of this TrainingOptions.
        :rtype: str
        """
        return self._model_uri

    @model_uri.setter
    def model_uri(self, model_uri):
        """Sets the model_uri of this TrainingOptions.

        Google Cloud Storage URI from which the model was imported. Only applicable for imported models.

        :param model_uri: The model_uri of this TrainingOptions.
        :type model_uri: str
        """

        self._model_uri = model_uri

    @property
    def non_seasonal_order(self):
        """Gets the non_seasonal_order of this TrainingOptions.


        :return: The non_seasonal_order of this TrainingOptions.
        :rtype: ArimaOrder
        """
        return self._non_seasonal_order

    @non_seasonal_order.setter
    def non_seasonal_order(self, non_seasonal_order):
        """Sets the non_seasonal_order of this TrainingOptions.


        :param non_seasonal_order: The non_seasonal_order of this TrainingOptions.
        :type non_seasonal_order: ArimaOrder
        """

        self._non_seasonal_order = non_seasonal_order

    @property
    def num_clusters(self):
        """Gets the num_clusters of this TrainingOptions.

        Number of clusters for clustering models.

        :return: The num_clusters of this TrainingOptions.
        :rtype: str
        """
        return self._num_clusters

    @num_clusters.setter
    def num_clusters(self, num_clusters):
        """Sets the num_clusters of this TrainingOptions.

        Number of clusters for clustering models.

        :param num_clusters: The num_clusters of this TrainingOptions.
        :type num_clusters: str
        """

        self._num_clusters = num_clusters

    @property
    def num_factors(self):
        """Gets the num_factors of this TrainingOptions.

        Num factors specified for matrix factorization models.

        :return: The num_factors of this TrainingOptions.
        :rtype: str
        """
        return self._num_factors

    @num_factors.setter
    def num_factors(self, num_factors):
        """Sets the num_factors of this TrainingOptions.

        Num factors specified for matrix factorization models.

        :param num_factors: The num_factors of this TrainingOptions.
        :type num_factors: str
        """

        self._num_factors = num_factors

    @property
    def num_parallel_tree(self):
        """Gets the num_parallel_tree of this TrainingOptions.

        Number of parallel trees constructed during each iteration for boosted tree models.

        :return: The num_parallel_tree of this TrainingOptions.
        :rtype: str
        """
        return self._num_parallel_tree

    @num_parallel_tree.setter
    def num_parallel_tree(self, num_parallel_tree):
        """Sets the num_parallel_tree of this TrainingOptions.

        Number of parallel trees constructed during each iteration for boosted tree models.

        :param num_parallel_tree: The num_parallel_tree of this TrainingOptions.
        :type num_parallel_tree: str
        """

        self._num_parallel_tree = num_parallel_tree

    @property
    def num_principal_components(self):
        """Gets the num_principal_components of this TrainingOptions.

        Number of principal components to keep in the PCA model. Must be <= the number of features.

        :return: The num_principal_components of this TrainingOptions.
        :rtype: str
        """
        return self._num_principal_components

    @num_principal_components.setter
    def num_principal_components(self, num_principal_components):
        """Sets the num_principal_components of this TrainingOptions.

        Number of principal components to keep in the PCA model. Must be <= the number of features.

        :param num_principal_components: The num_principal_components of this TrainingOptions.
        :type num_principal_components: str
        """

        self._num_principal_components = num_principal_components

    @property
    def num_trials(self):
        """Gets the num_trials of this TrainingOptions.

        Number of trials to run this hyperparameter tuning job.

        :return: The num_trials of this TrainingOptions.
        :rtype: str
        """
        return self._num_trials

    @num_trials.setter
    def num_trials(self, num_trials):
        """Sets the num_trials of this TrainingOptions.

        Number of trials to run this hyperparameter tuning job.

        :param num_trials: The num_trials of this TrainingOptions.
        :type num_trials: str
        """

        self._num_trials = num_trials

    @property
    def optimization_strategy(self):
        """Gets the optimization_strategy of this TrainingOptions.

        Optimization strategy for training linear regression models.

        :return: The optimization_strategy of this TrainingOptions.
        :rtype: str
        """
        return self._optimization_strategy

    @optimization_strategy.setter
    def optimization_strategy(self, optimization_strategy):
        """Sets the optimization_strategy of this TrainingOptions.

        Optimization strategy for training linear regression models.

        :param optimization_strategy: The optimization_strategy of this TrainingOptions.
        :type optimization_strategy: str
        """
        allowed_values = ["OPTIMIZATION_STRATEGY_UNSPECIFIED", "BATCH_GRADIENT_DESCENT", "NORMAL_EQUATION"]  # noqa: E501
        if optimization_strategy not in allowed_values:
            raise ValueError(
                "Invalid value for `optimization_strategy` ({0}), must be one of {1}"
                .format(optimization_strategy, allowed_values)
            )

        self._optimization_strategy = optimization_strategy

    @property
    def optimizer(self):
        """Gets the optimizer of this TrainingOptions.

        Optimizer used for training the neural nets.

        :return: The optimizer of this TrainingOptions.
        :rtype: str
        """
        return self._optimizer

    @optimizer.setter
    def optimizer(self, optimizer):
        """Sets the optimizer of this TrainingOptions.

        Optimizer used for training the neural nets.

        :param optimizer: The optimizer of this TrainingOptions.
        :type optimizer: str
        """

        self._optimizer = optimizer

    @property
    def pca_explained_variance_ratio(self):
        """Gets the pca_explained_variance_ratio of this TrainingOptions.

        The minimum ratio of cumulative explained variance that needs to be given by the PCA model.

        :return: The pca_explained_variance_ratio of this TrainingOptions.
        :rtype: float
        """
        return self._pca_explained_variance_ratio

    @pca_explained_variance_ratio.setter
    def pca_explained_variance_ratio(self, pca_explained_variance_ratio):
        """Sets the pca_explained_variance_ratio of this TrainingOptions.

        The minimum ratio of cumulative explained variance that needs to be given by the PCA model.

        :param pca_explained_variance_ratio: The pca_explained_variance_ratio of this TrainingOptions.
        :type pca_explained_variance_ratio: float
        """

        self._pca_explained_variance_ratio = pca_explained_variance_ratio

    @property
    def pca_solver(self):
        """Gets the pca_solver of this TrainingOptions.

        The solver for PCA.

        :return: The pca_solver of this TrainingOptions.
        :rtype: str
        """
        return self._pca_solver

    @pca_solver.setter
    def pca_solver(self, pca_solver):
        """Sets the pca_solver of this TrainingOptions.

        The solver for PCA.

        :param pca_solver: The pca_solver of this TrainingOptions.
        :type pca_solver: str
        """
        allowed_values = ["UNSPECIFIED", "FULL", "RANDOMIZED", "AUTO"]  # noqa: E501
        if pca_solver not in allowed_values:
            raise ValueError(
                "Invalid value for `pca_solver` ({0}), must be one of {1}"
                .format(pca_solver, allowed_values)
            )

        self._pca_solver = pca_solver

    @property
    def sampled_shapley_num_paths(self):
        """Gets the sampled_shapley_num_paths of this TrainingOptions.

        Number of paths for the sampled Shapley explain method.

        :return: The sampled_shapley_num_paths of this TrainingOptions.
        :rtype: str
        """
        return self._sampled_shapley_num_paths

    @sampled_shapley_num_paths.setter
    def sampled_shapley_num_paths(self, sampled_shapley_num_paths):
        """Sets the sampled_shapley_num_paths of this TrainingOptions.

        Number of paths for the sampled Shapley explain method.

        :param sampled_shapley_num_paths: The sampled_shapley_num_paths of this TrainingOptions.
        :type sampled_shapley_num_paths: str
        """

        self._sampled_shapley_num_paths = sampled_shapley_num_paths

    @property
    def scale_features(self):
        """Gets the scale_features of this TrainingOptions.

        If true, scale the feature values by dividing the feature standard deviation. Currently only apply to PCA.

        :return: The scale_features of this TrainingOptions.
        :rtype: bool
        """
        return self._scale_features

    @scale_features.setter
    def scale_features(self, scale_features):
        """Sets the scale_features of this TrainingOptions.

        If true, scale the feature values by dividing the feature standard deviation. Currently only apply to PCA.

        :param scale_features: The scale_features of this TrainingOptions.
        :type scale_features: bool
        """

        self._scale_features = scale_features

    @property
    def standardize_features(self):
        """Gets the standardize_features of this TrainingOptions.

        Whether to standardize numerical features. Default to true.

        :return: The standardize_features of this TrainingOptions.
        :rtype: bool
        """
        return self._standardize_features

    @standardize_features.setter
    def standardize_features(self, standardize_features):
        """Sets the standardize_features of this TrainingOptions.

        Whether to standardize numerical features. Default to true.

        :param standardize_features: The standardize_features of this TrainingOptions.
        :type standardize_features: bool
        """

        self._standardize_features = standardize_features

    @property
    def subsample(self):
        """Gets the subsample of this TrainingOptions.

        Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.

        :return: The subsample of this TrainingOptions.
        :rtype: float
        """
        return self._subsample

    @subsample.setter
    def subsample(self, subsample):
        """Sets the subsample of this TrainingOptions.

        Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.

        :param subsample: The subsample of this TrainingOptions.
        :type subsample: float
        """

        self._subsample = subsample

    @property
    def tf_version(self):
        """Gets the tf_version of this TrainingOptions.

        Based on the selected TF version, the corresponding docker image is used to train external models.

        :return: The tf_version of this TrainingOptions.
        :rtype: str
        """
        return self._tf_version

    @tf_version.setter
    def tf_version(self, tf_version):
        """Sets the tf_version of this TrainingOptions.

        Based on the selected TF version, the corresponding docker image is used to train external models.

        :param tf_version: The tf_version of this TrainingOptions.
        :type tf_version: str
        """

        self._tf_version = tf_version

    @property
    def time_series_data_column(self):
        """Gets the time_series_data_column of this TrainingOptions.

        Column to be designated as time series data for ARIMA model.

        :return: The time_series_data_column of this TrainingOptions.
        :rtype: str
        """
        return self._time_series_data_column

    @time_series_data_column.setter
    def time_series_data_column(self, time_series_data_column):
        """Sets the time_series_data_column of this TrainingOptions.

        Column to be designated as time series data for ARIMA model.

        :param time_series_data_column: The time_series_data_column of this TrainingOptions.
        :type time_series_data_column: str
        """

        self._time_series_data_column = time_series_data_column

    @property
    def time_series_id_column(self):
        """Gets the time_series_id_column of this TrainingOptions.

        The time series id column that was used during ARIMA model training.

        :return: The time_series_id_column of this TrainingOptions.
        :rtype: str
        """
        return self._time_series_id_column

    @time_series_id_column.setter
    def time_series_id_column(self, time_series_id_column):
        """Sets the time_series_id_column of this TrainingOptions.

        The time series id column that was used during ARIMA model training.

        :param time_series_id_column: The time_series_id_column of this TrainingOptions.
        :type time_series_id_column: str
        """

        self._time_series_id_column = time_series_id_column

    @property
    def time_series_id_columns(self):
        """Gets the time_series_id_columns of this TrainingOptions.

        The time series id columns that were used during ARIMA model training.

        :return: The time_series_id_columns of this TrainingOptions.
        :rtype: List[str]
        """
        return self._time_series_id_columns

    @time_series_id_columns.setter
    def time_series_id_columns(self, time_series_id_columns):
        """Sets the time_series_id_columns of this TrainingOptions.

        The time series id columns that were used during ARIMA model training.

        :param time_series_id_columns: The time_series_id_columns of this TrainingOptions.
        :type time_series_id_columns: List[str]
        """

        self._time_series_id_columns = time_series_id_columns

    @property
    def time_series_length_fraction(self):
        """Gets the time_series_length_fraction of this TrainingOptions.

        The fraction of the interpolated length of the time series that's used to model the time series trend component. All of the time points of the time series are used to model the non-trend component. This training option accelerates modeling training without sacrificing much forecasting accuracy. You can use this option with `minTimeSeriesLength` but not with `maxTimeSeriesLength`.

        :return: The time_series_length_fraction of this TrainingOptions.
        :rtype: float
        """
        return self._time_series_length_fraction

    @time_series_length_fraction.setter
    def time_series_length_fraction(self, time_series_length_fraction):
        """Sets the time_series_length_fraction of this TrainingOptions.

        The fraction of the interpolated length of the time series that's used to model the time series trend component. All of the time points of the time series are used to model the non-trend component. This training option accelerates modeling training without sacrificing much forecasting accuracy. You can use this option with `minTimeSeriesLength` but not with `maxTimeSeriesLength`.

        :param time_series_length_fraction: The time_series_length_fraction of this TrainingOptions.
        :type time_series_length_fraction: float
        """

        self._time_series_length_fraction = time_series_length_fraction

    @property
    def time_series_timestamp_column(self):
        """Gets the time_series_timestamp_column of this TrainingOptions.

        Column to be designated as time series timestamp for ARIMA model.

        :return: The time_series_timestamp_column of this TrainingOptions.
        :rtype: str
        """
        return self._time_series_timestamp_column

    @time_series_timestamp_column.setter
    def time_series_timestamp_column(self, time_series_timestamp_column):
        """Sets the time_series_timestamp_column of this TrainingOptions.

        Column to be designated as time series timestamp for ARIMA model.

        :param time_series_timestamp_column: The time_series_timestamp_column of this TrainingOptions.
        :type time_series_timestamp_column: str
        """

        self._time_series_timestamp_column = time_series_timestamp_column

    @property
    def tree_method(self):
        """Gets the tree_method of this TrainingOptions.

        Tree construction algorithm for boosted tree models.

        :return: The tree_method of this TrainingOptions.
        :rtype: str
        """
        return self._tree_method

    @tree_method.setter
    def tree_method(self, tree_method):
        """Sets the tree_method of this TrainingOptions.

        Tree construction algorithm for boosted tree models.

        :param tree_method: The tree_method of this TrainingOptions.
        :type tree_method: str
        """
        allowed_values = ["TREE_METHOD_UNSPECIFIED", "AUTO", "EXACT", "APPROX", "HIST"]  # noqa: E501
        if tree_method not in allowed_values:
            raise ValueError(
                "Invalid value for `tree_method` ({0}), must be one of {1}"
                .format(tree_method, allowed_values)
            )

        self._tree_method = tree_method

    @property
    def trend_smoothing_window_size(self):
        """Gets the trend_smoothing_window_size of this TrainingOptions.

        Smoothing window size for the trend component. When a positive value is specified, a center moving average smoothing is applied on the history trend. When the smoothing window is out of the boundary at the beginning or the end of the trend, the first element or the last element is padded to fill the smoothing window before the average is applied.

        :return: The trend_smoothing_window_size of this TrainingOptions.
        :rtype: str
        """
        return self._trend_smoothing_window_size

    @trend_smoothing_window_size.setter
    def trend_smoothing_window_size(self, trend_smoothing_window_size):
        """Sets the trend_smoothing_window_size of this TrainingOptions.

        Smoothing window size for the trend component. When a positive value is specified, a center moving average smoothing is applied on the history trend. When the smoothing window is out of the boundary at the beginning or the end of the trend, the first element or the last element is padded to fill the smoothing window before the average is applied.

        :param trend_smoothing_window_size: The trend_smoothing_window_size of this TrainingOptions.
        :type trend_smoothing_window_size: str
        """

        self._trend_smoothing_window_size = trend_smoothing_window_size

    @property
    def user_column(self):
        """Gets the user_column of this TrainingOptions.

        User column specified for matrix factorization models.

        :return: The user_column of this TrainingOptions.
        :rtype: str
        """
        return self._user_column

    @user_column.setter
    def user_column(self, user_column):
        """Sets the user_column of this TrainingOptions.

        User column specified for matrix factorization models.

        :param user_column: The user_column of this TrainingOptions.
        :type user_column: str
        """

        self._user_column = user_column

    @property
    def vertex_ai_model_version_aliases(self):
        """Gets the vertex_ai_model_version_aliases of this TrainingOptions.

        The version aliases to apply in Vertex AI model registry. Always overwrite if the version aliases exists in a existing model.

        :return: The vertex_ai_model_version_aliases of this TrainingOptions.
        :rtype: List[str]
        """
        return self._vertex_ai_model_version_aliases

    @vertex_ai_model_version_aliases.setter
    def vertex_ai_model_version_aliases(self, vertex_ai_model_version_aliases):
        """Sets the vertex_ai_model_version_aliases of this TrainingOptions.

        The version aliases to apply in Vertex AI model registry. Always overwrite if the version aliases exists in a existing model.

        :param vertex_ai_model_version_aliases: The vertex_ai_model_version_aliases of this TrainingOptions.
        :type vertex_ai_model_version_aliases: List[str]
        """

        self._vertex_ai_model_version_aliases = vertex_ai_model_version_aliases

    @property
    def wals_alpha(self):
        """Gets the wals_alpha of this TrainingOptions.

        Hyperparameter for matrix factoration when implicit feedback type is specified.

        :return: The wals_alpha of this TrainingOptions.
        :rtype: float
        """
        return self._wals_alpha

    @wals_alpha.setter
    def wals_alpha(self, wals_alpha):
        """Sets the wals_alpha of this TrainingOptions.

        Hyperparameter for matrix factoration when implicit feedback type is specified.

        :param wals_alpha: The wals_alpha of this TrainingOptions.
        :type wals_alpha: float
        """

        self._wals_alpha = wals_alpha

    @property
    def warm_start(self):
        """Gets the warm_start of this TrainingOptions.

        Whether to train a model from the last checkpoint.

        :return: The warm_start of this TrainingOptions.
        :rtype: bool
        """
        return self._warm_start

    @warm_start.setter
    def warm_start(self, warm_start):
        """Sets the warm_start of this TrainingOptions.

        Whether to train a model from the last checkpoint.

        :param warm_start: The warm_start of this TrainingOptions.
        :type warm_start: bool
        """

        self._warm_start = warm_start

    @property
    def xgboost_version(self):
        """Gets the xgboost_version of this TrainingOptions.

        User-selected XGBoost versions for training of XGBoost models.

        :return: The xgboost_version of this TrainingOptions.
        :rtype: str
        """
        return self._xgboost_version

    @xgboost_version.setter
    def xgboost_version(self, xgboost_version):
        """Sets the xgboost_version of this TrainingOptions.

        User-selected XGBoost versions for training of XGBoost models.

        :param xgboost_version: The xgboost_version of this TrainingOptions.
        :type xgboost_version: str
        """

        self._xgboost_version = xgboost_version
