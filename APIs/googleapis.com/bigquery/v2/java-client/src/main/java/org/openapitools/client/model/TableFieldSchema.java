/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.TableFieldSchemaCategories;
import org.openapitools.client.model.TableFieldSchemaPolicyTags;
import org.openapitools.client.model.TableFieldSchemaRangeElementType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A field in TableSchema
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TableFieldSchema {
  public static final String SERIALIZED_NAME_CATEGORIES = "categories";
  @SerializedName(SERIALIZED_NAME_CATEGORIES)
  private TableFieldSchemaCategories categories;

  public static final String SERIALIZED_NAME_COLLATION = "collation";
  @SerializedName(SERIALIZED_NAME_COLLATION)
  private String collation;

  public static final String SERIALIZED_NAME_DEFAULT_VALUE_EXPRESSION = "defaultValueExpression";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VALUE_EXPRESSION)
  private String defaultValueExpression;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_FIELDS = "fields";
  @SerializedName(SERIALIZED_NAME_FIELDS)
  private List<TableFieldSchema> fields = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAX_LENGTH = "maxLength";
  @SerializedName(SERIALIZED_NAME_MAX_LENGTH)
  private String maxLength;

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private String mode;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_POLICY_TAGS = "policyTags";
  @SerializedName(SERIALIZED_NAME_POLICY_TAGS)
  private TableFieldSchemaPolicyTags policyTags;

  public static final String SERIALIZED_NAME_PRECISION = "precision";
  @SerializedName(SERIALIZED_NAME_PRECISION)
  private String precision;

  public static final String SERIALIZED_NAME_RANGE_ELEMENT_TYPE = "rangeElementType";
  @SerializedName(SERIALIZED_NAME_RANGE_ELEMENT_TYPE)
  private TableFieldSchemaRangeElementType rangeElementType;

  /**
   * Optional. Specifies the rounding mode to be used when storing values of NUMERIC and BIGNUMERIC type.
   */
  @JsonAdapter(RoundingModeEnum.Adapter.class)
  public enum RoundingModeEnum {
    ROUNDING_MODE_UNSPECIFIED("ROUNDING_MODE_UNSPECIFIED"),
    
    ROUND_HALF_AWAY_FROM_ZERO("ROUND_HALF_AWAY_FROM_ZERO"),
    
    ROUND_HALF_EVEN("ROUND_HALF_EVEN");

    private String value;

    RoundingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RoundingModeEnum fromValue(String value) {
      for (RoundingModeEnum b : RoundingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RoundingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RoundingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RoundingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RoundingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RoundingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ROUNDING_MODE = "roundingMode";
  @SerializedName(SERIALIZED_NAME_ROUNDING_MODE)
  private RoundingModeEnum roundingMode;

  public static final String SERIALIZED_NAME_SCALE = "scale";
  @SerializedName(SERIALIZED_NAME_SCALE)
  private String scale;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public TableFieldSchema() {
  }

  public TableFieldSchema categories(TableFieldSchemaCategories categories) {
    this.categories = categories;
    return this;
  }

  /**
   * Get categories
   * @return categories
   */
  @javax.annotation.Nullable
  public TableFieldSchemaCategories getCategories() {
    return categories;
  }

  public void setCategories(TableFieldSchemaCategories categories) {
    this.categories = categories;
  }


  public TableFieldSchema collation(String collation) {
    this.collation = collation;
    return this;
  }

  /**
   * Optional. Field collation can be set only when the type of field is STRING. The following values are supported: * &#39;und:ci&#39;: undetermined locale, case insensitive. * &#39;&#39;: empty string. Default to case-sensitive behavior.
   * @return collation
   */
  @javax.annotation.Nullable
  public String getCollation() {
    return collation;
  }

  public void setCollation(String collation) {
    this.collation = collation;
  }


  public TableFieldSchema defaultValueExpression(String defaultValueExpression) {
    this.defaultValueExpression = defaultValueExpression;
    return this;
  }

  /**
   * Optional. A SQL expression to specify the [default value] (https://cloud.google.com/bigquery/docs/default-values) for this field.
   * @return defaultValueExpression
   */
  @javax.annotation.Nullable
  public String getDefaultValueExpression() {
    return defaultValueExpression;
  }

  public void setDefaultValueExpression(String defaultValueExpression) {
    this.defaultValueExpression = defaultValueExpression;
  }


  public TableFieldSchema description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. The field description. The maximum length is 1,024 characters.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public TableFieldSchema fields(List<TableFieldSchema> fields) {
    this.fields = fields;
    return this;
  }

  public TableFieldSchema addFieldsItem(TableFieldSchema fieldsItem) {
    if (this.fields == null) {
      this.fields = new ArrayList<>();
    }
    this.fields.add(fieldsItem);
    return this;
  }

  /**
   * Optional. Describes the nested schema fields if the type property is set to RECORD.
   * @return fields
   */
  @javax.annotation.Nullable
  public List<TableFieldSchema> getFields() {
    return fields;
  }

  public void setFields(List<TableFieldSchema> fields) {
    this.fields = fields;
  }


  public TableFieldSchema maxLength(String maxLength) {
    this.maxLength = maxLength;
    return this;
  }

  /**
   * Optional. Maximum length of values of this field for STRINGS or BYTES. If max_length is not specified, no maximum length constraint is imposed on this field. If type &#x3D; \&quot;STRING\&quot;, then max_length represents the maximum UTF-8 length of strings in this field. If type &#x3D; \&quot;BYTES\&quot;, then max_length represents the maximum number of bytes in this field. It is invalid to set this field if type ≠ \&quot;STRING\&quot; and ≠ \&quot;BYTES\&quot;.
   * @return maxLength
   */
  @javax.annotation.Nullable
  public String getMaxLength() {
    return maxLength;
  }

  public void setMaxLength(String maxLength) {
    this.maxLength = maxLength;
  }


  public TableFieldSchema mode(String mode) {
    this.mode = mode;
    return this;
  }

  /**
   * Optional. The field mode. Possible values include NULLABLE, REQUIRED and REPEATED. The default value is NULLABLE.
   * @return mode
   */
  @javax.annotation.Nullable
  public String getMode() {
    return mode;
  }

  public void setMode(String mode) {
    this.mode = mode;
  }


  public TableFieldSchema name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. The field name. The name must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_), and must start with a letter or underscore. The maximum length is 300 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TableFieldSchema policyTags(TableFieldSchemaPolicyTags policyTags) {
    this.policyTags = policyTags;
    return this;
  }

  /**
   * Get policyTags
   * @return policyTags
   */
  @javax.annotation.Nullable
  public TableFieldSchemaPolicyTags getPolicyTags() {
    return policyTags;
  }

  public void setPolicyTags(TableFieldSchemaPolicyTags policyTags) {
    this.policyTags = policyTags;
  }


  public TableFieldSchema precision(String precision) {
    this.precision = precision;
    return this;
  }

  /**
   * Optional. Precision (maximum number of total digits in base 10) and scale (maximum number of digits in the fractional part in base 10) constraints for values of this field for NUMERIC or BIGNUMERIC. It is invalid to set precision or scale if type ≠ \&quot;NUMERIC\&quot; and ≠ \&quot;BIGNUMERIC\&quot;. If precision and scale are not specified, no value range constraint is imposed on this field insofar as values are permitted by the type. Values of this NUMERIC or BIGNUMERIC field must be in this range when: * Precision (P) and scale (S) are specified: [-10P-S + 10-S, 10P-S - 10-S] * Precision (P) is specified but not scale (and thus scale is interpreted to be equal to zero): [-10P + 1, 10P - 1]. Acceptable values for precision and scale if both are specified: * If type &#x3D; \&quot;NUMERIC\&quot;: 1 ≤ precision - scale ≤ 29 and 0 ≤ scale ≤ 9. * If type &#x3D; \&quot;BIGNUMERIC\&quot;: 1 ≤ precision - scale ≤ 38 and 0 ≤ scale ≤ 38. Acceptable values for precision if only precision is specified but not scale (and thus scale is interpreted to be equal to zero): * If type &#x3D; \&quot;NUMERIC\&quot;: 1 ≤ precision ≤ 29. * If type &#x3D; \&quot;BIGNUMERIC\&quot;: 1 ≤ precision ≤ 38. If scale is specified but not precision, then it is invalid.
   * @return precision
   */
  @javax.annotation.Nullable
  public String getPrecision() {
    return precision;
  }

  public void setPrecision(String precision) {
    this.precision = precision;
  }


  public TableFieldSchema rangeElementType(TableFieldSchemaRangeElementType rangeElementType) {
    this.rangeElementType = rangeElementType;
    return this;
  }

  /**
   * Get rangeElementType
   * @return rangeElementType
   */
  @javax.annotation.Nullable
  public TableFieldSchemaRangeElementType getRangeElementType() {
    return rangeElementType;
  }

  public void setRangeElementType(TableFieldSchemaRangeElementType rangeElementType) {
    this.rangeElementType = rangeElementType;
  }


  public TableFieldSchema roundingMode(RoundingModeEnum roundingMode) {
    this.roundingMode = roundingMode;
    return this;
  }

  /**
   * Optional. Specifies the rounding mode to be used when storing values of NUMERIC and BIGNUMERIC type.
   * @return roundingMode
   */
  @javax.annotation.Nullable
  public RoundingModeEnum getRoundingMode() {
    return roundingMode;
  }

  public void setRoundingMode(RoundingModeEnum roundingMode) {
    this.roundingMode = roundingMode;
  }


  public TableFieldSchema scale(String scale) {
    this.scale = scale;
    return this;
  }

  /**
   * Optional. See documentation for precision.
   * @return scale
   */
  @javax.annotation.Nullable
  public String getScale() {
    return scale;
  }

  public void setScale(String scale) {
    this.scale = scale;
  }


  public TableFieldSchema type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Required. The field data type. Possible values include: * STRING * BYTES * INTEGER (or INT64) * FLOAT (or FLOAT64) * BOOLEAN (or BOOL) * TIMESTAMP * DATE * TIME * DATETIME * GEOGRAPHY * NUMERIC * BIGNUMERIC * JSON * RECORD (or STRUCT) Use of RECORD/STRUCT indicates that the field contains a nested schema.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TableFieldSchema tableFieldSchema = (TableFieldSchema) o;
    return Objects.equals(this.categories, tableFieldSchema.categories) &&
        Objects.equals(this.collation, tableFieldSchema.collation) &&
        Objects.equals(this.defaultValueExpression, tableFieldSchema.defaultValueExpression) &&
        Objects.equals(this.description, tableFieldSchema.description) &&
        Objects.equals(this.fields, tableFieldSchema.fields) &&
        Objects.equals(this.maxLength, tableFieldSchema.maxLength) &&
        Objects.equals(this.mode, tableFieldSchema.mode) &&
        Objects.equals(this.name, tableFieldSchema.name) &&
        Objects.equals(this.policyTags, tableFieldSchema.policyTags) &&
        Objects.equals(this.precision, tableFieldSchema.precision) &&
        Objects.equals(this.rangeElementType, tableFieldSchema.rangeElementType) &&
        Objects.equals(this.roundingMode, tableFieldSchema.roundingMode) &&
        Objects.equals(this.scale, tableFieldSchema.scale) &&
        Objects.equals(this.type, tableFieldSchema.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(categories, collation, defaultValueExpression, description, fields, maxLength, mode, name, policyTags, precision, rangeElementType, roundingMode, scale, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TableFieldSchema {\n");
    sb.append("    categories: ").append(toIndentedString(categories)).append("\n");
    sb.append("    collation: ").append(toIndentedString(collation)).append("\n");
    sb.append("    defaultValueExpression: ").append(toIndentedString(defaultValueExpression)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    maxLength: ").append(toIndentedString(maxLength)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    policyTags: ").append(toIndentedString(policyTags)).append("\n");
    sb.append("    precision: ").append(toIndentedString(precision)).append("\n");
    sb.append("    rangeElementType: ").append(toIndentedString(rangeElementType)).append("\n");
    sb.append("    roundingMode: ").append(toIndentedString(roundingMode)).append("\n");
    sb.append("    scale: ").append(toIndentedString(scale)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("categories");
    openapiFields.add("collation");
    openapiFields.add("defaultValueExpression");
    openapiFields.add("description");
    openapiFields.add("fields");
    openapiFields.add("maxLength");
    openapiFields.add("mode");
    openapiFields.add("name");
    openapiFields.add("policyTags");
    openapiFields.add("precision");
    openapiFields.add("rangeElementType");
    openapiFields.add("roundingMode");
    openapiFields.add("scale");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TableFieldSchema
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TableFieldSchema.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TableFieldSchema is not found in the empty JSON string", TableFieldSchema.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TableFieldSchema.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TableFieldSchema` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `categories`
      if (jsonObj.get("categories") != null && !jsonObj.get("categories").isJsonNull()) {
        TableFieldSchemaCategories.validateJsonElement(jsonObj.get("categories"));
      }
      if ((jsonObj.get("collation") != null && !jsonObj.get("collation").isJsonNull()) && !jsonObj.get("collation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `collation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("collation").toString()));
      }
      if ((jsonObj.get("defaultValueExpression") != null && !jsonObj.get("defaultValueExpression").isJsonNull()) && !jsonObj.get("defaultValueExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultValueExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultValueExpression").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (jsonObj.get("fields") != null && !jsonObj.get("fields").isJsonNull()) {
        JsonArray jsonArrayfields = jsonObj.getAsJsonArray("fields");
        if (jsonArrayfields != null) {
          // ensure the json data is an array
          if (!jsonObj.get("fields").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `fields` to be an array in the JSON string but got `%s`", jsonObj.get("fields").toString()));
          }

          // validate the optional field `fields` (array)
          for (int i = 0; i < jsonArrayfields.size(); i++) {
            TableFieldSchema.validateJsonElement(jsonArrayfields.get(i));
          };
        }
      }
      if ((jsonObj.get("maxLength") != null && !jsonObj.get("maxLength").isJsonNull()) && !jsonObj.get("maxLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxLength` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxLength").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `policyTags`
      if (jsonObj.get("policyTags") != null && !jsonObj.get("policyTags").isJsonNull()) {
        TableFieldSchemaPolicyTags.validateJsonElement(jsonObj.get("policyTags"));
      }
      if ((jsonObj.get("precision") != null && !jsonObj.get("precision").isJsonNull()) && !jsonObj.get("precision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `precision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("precision").toString()));
      }
      // validate the optional field `rangeElementType`
      if (jsonObj.get("rangeElementType") != null && !jsonObj.get("rangeElementType").isJsonNull()) {
        TableFieldSchemaRangeElementType.validateJsonElement(jsonObj.get("rangeElementType"));
      }
      if ((jsonObj.get("roundingMode") != null && !jsonObj.get("roundingMode").isJsonNull()) && !jsonObj.get("roundingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roundingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roundingMode").toString()));
      }
      // validate the optional field `roundingMode`
      if (jsonObj.get("roundingMode") != null && !jsonObj.get("roundingMode").isJsonNull()) {
        RoundingModeEnum.validateJsonElement(jsonObj.get("roundingMode"));
      }
      if ((jsonObj.get("scale") != null && !jsonObj.get("scale").isJsonNull()) && !jsonObj.get("scale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scale").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TableFieldSchema.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TableFieldSchema' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TableFieldSchema> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TableFieldSchema.class));

       return (TypeAdapter<T>) new TypeAdapter<TableFieldSchema>() {
           @Override
           public void write(JsonWriter out, TableFieldSchema value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TableFieldSchema read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TableFieldSchema given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TableFieldSchema
   * @throws IOException if the JSON string is invalid with respect to TableFieldSchema
   */
  public static TableFieldSchema fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TableFieldSchema.class);
  }

  /**
   * Convert an instance of TableFieldSchema to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

