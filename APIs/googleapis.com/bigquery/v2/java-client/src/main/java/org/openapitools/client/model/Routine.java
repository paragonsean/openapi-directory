/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Argument;
import org.openapitools.client.model.RemoteFunctionOptions;
import org.openapitools.client.model.RoutineReference;
import org.openapitools.client.model.SparkOptions;
import org.openapitools.client.model.StandardSqlDataType;
import org.openapitools.client.model.StandardSqlTableType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A user-defined function or a stored procedure.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Routine {
  public static final String SERIALIZED_NAME_ARGUMENTS = "arguments";
  @SerializedName(SERIALIZED_NAME_ARGUMENTS)
  private List<Argument> arguments = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATION_TIME = "creationTime";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private String creationTime;

  /**
   * Optional. If set to &#x60;DATA_MASKING&#x60;, the function is validated and made available as a masking function. For more information, see [Create custom masking routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
   */
  @JsonAdapter(DataGovernanceTypeEnum.Adapter.class)
  public enum DataGovernanceTypeEnum {
    GOVERNANCE_TYPE_UNSPECIFIED("DATA_GOVERNANCE_TYPE_UNSPECIFIED"),
    
    MASKING("DATA_MASKING");

    private String value;

    DataGovernanceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataGovernanceTypeEnum fromValue(String value) {
      for (DataGovernanceTypeEnum b : DataGovernanceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataGovernanceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataGovernanceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataGovernanceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataGovernanceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataGovernanceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_GOVERNANCE_TYPE = "dataGovernanceType";
  @SerializedName(SERIALIZED_NAME_DATA_GOVERNANCE_TYPE)
  private DataGovernanceTypeEnum dataGovernanceType;

  public static final String SERIALIZED_NAME_DEFINITION_BODY = "definitionBody";
  @SerializedName(SERIALIZED_NAME_DEFINITION_BODY)
  private String definitionBody;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  /**
   * Optional. The determinism level of the JavaScript UDF, if defined.
   */
  @JsonAdapter(DeterminismLevelEnum.Adapter.class)
  public enum DeterminismLevelEnum {
    DETERMINISM_LEVEL_UNSPECIFIED("DETERMINISM_LEVEL_UNSPECIFIED"),
    
    DETERMINISTIC("DETERMINISTIC"),
    
    NOT_DETERMINISTIC("NOT_DETERMINISTIC");

    private String value;

    DeterminismLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeterminismLevelEnum fromValue(String value) {
      for (DeterminismLevelEnum b : DeterminismLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeterminismLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeterminismLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeterminismLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeterminismLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeterminismLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DETERMINISM_LEVEL = "determinismLevel";
  @SerializedName(SERIALIZED_NAME_DETERMINISM_LEVEL)
  private DeterminismLevelEnum determinismLevel;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_IMPORTED_LIBRARIES = "importedLibraries";
  @SerializedName(SERIALIZED_NAME_IMPORTED_LIBRARIES)
  private List<String> importedLibraries = new ArrayList<>();

  /**
   * Optional. Defaults to \&quot;SQL\&quot; if remote_function_options field is absent, not set otherwise.
   */
  @JsonAdapter(LanguageEnum.Adapter.class)
  public enum LanguageEnum {
    LANGUAGE_UNSPECIFIED("LANGUAGE_UNSPECIFIED"),
    
    SQL("SQL"),
    
    JAVASCRIPT("JAVASCRIPT"),
    
    PYTHON("PYTHON"),
    
    JAVA("JAVA"),
    
    SCALA("SCALA");

    private String value;

    LanguageEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LanguageEnum fromValue(String value) {
      for (LanguageEnum b : LanguageEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LanguageEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LanguageEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LanguageEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LanguageEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LanguageEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LANGUAGE = "language";
  @SerializedName(SERIALIZED_NAME_LANGUAGE)
  private LanguageEnum language;

  public static final String SERIALIZED_NAME_LAST_MODIFIED_TIME = "lastModifiedTime";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED_TIME)
  private String lastModifiedTime;

  public static final String SERIALIZED_NAME_REMOTE_FUNCTION_OPTIONS = "remoteFunctionOptions";
  @SerializedName(SERIALIZED_NAME_REMOTE_FUNCTION_OPTIONS)
  private RemoteFunctionOptions remoteFunctionOptions;

  public static final String SERIALIZED_NAME_RETURN_TABLE_TYPE = "returnTableType";
  @SerializedName(SERIALIZED_NAME_RETURN_TABLE_TYPE)
  private StandardSqlTableType returnTableType;

  public static final String SERIALIZED_NAME_RETURN_TYPE = "returnType";
  @SerializedName(SERIALIZED_NAME_RETURN_TYPE)
  private StandardSqlDataType returnType;

  public static final String SERIALIZED_NAME_ROUTINE_REFERENCE = "routineReference";
  @SerializedName(SERIALIZED_NAME_ROUTINE_REFERENCE)
  private RoutineReference routineReference;

  /**
   * Required. The type of routine.
   */
  @JsonAdapter(RoutineTypeEnum.Adapter.class)
  public enum RoutineTypeEnum {
    ROUTINE_TYPE_UNSPECIFIED("ROUTINE_TYPE_UNSPECIFIED"),
    
    SCALAR_FUNCTION("SCALAR_FUNCTION"),
    
    PROCEDURE("PROCEDURE"),
    
    TABLE_VALUED_FUNCTION("TABLE_VALUED_FUNCTION"),
    
    AGGREGATE_FUNCTION("AGGREGATE_FUNCTION");

    private String value;

    RoutineTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RoutineTypeEnum fromValue(String value) {
      for (RoutineTypeEnum b : RoutineTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RoutineTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RoutineTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RoutineTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RoutineTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RoutineTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ROUTINE_TYPE = "routineType";
  @SerializedName(SERIALIZED_NAME_ROUTINE_TYPE)
  private RoutineTypeEnum routineType;

  /**
   * Optional. The security mode of the routine, if defined. If not defined, the security mode is automatically determined from the routine&#39;s configuration.
   */
  @JsonAdapter(SecurityModeEnum.Adapter.class)
  public enum SecurityModeEnum {
    SECURITY_MODE_UNSPECIFIED("SECURITY_MODE_UNSPECIFIED"),
    
    DEFINER("DEFINER"),
    
    INVOKER("INVOKER");

    private String value;

    SecurityModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecurityModeEnum fromValue(String value) {
      for (SecurityModeEnum b : SecurityModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SecurityModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecurityModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecurityModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SecurityModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SecurityModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECURITY_MODE = "securityMode";
  @SerializedName(SERIALIZED_NAME_SECURITY_MODE)
  private SecurityModeEnum securityMode;

  public static final String SERIALIZED_NAME_SPARK_OPTIONS = "sparkOptions";
  @SerializedName(SERIALIZED_NAME_SPARK_OPTIONS)
  private SparkOptions sparkOptions;

  public static final String SERIALIZED_NAME_STRICT_MODE = "strictMode";
  @SerializedName(SERIALIZED_NAME_STRICT_MODE)
  private Boolean strictMode;

  public Routine() {
  }

  public Routine(
     String creationTime, 
     String etag, 
     String lastModifiedTime
  ) {
    this();
    this.creationTime = creationTime;
    this.etag = etag;
    this.lastModifiedTime = lastModifiedTime;
  }

  public Routine arguments(List<Argument> arguments) {
    this.arguments = arguments;
    return this;
  }

  public Routine addArgumentsItem(Argument argumentsItem) {
    if (this.arguments == null) {
      this.arguments = new ArrayList<>();
    }
    this.arguments.add(argumentsItem);
    return this;
  }

  /**
   * Optional.
   * @return arguments
   */
  @javax.annotation.Nullable
  public List<Argument> getArguments() {
    return arguments;
  }

  public void setArguments(List<Argument> arguments) {
    this.arguments = arguments;
  }


  /**
   * Output only. The time when this routine was created, in milliseconds since the epoch.
   * @return creationTime
   */
  @javax.annotation.Nullable
  public String getCreationTime() {
    return creationTime;
  }



  public Routine dataGovernanceType(DataGovernanceTypeEnum dataGovernanceType) {
    this.dataGovernanceType = dataGovernanceType;
    return this;
  }

  /**
   * Optional. If set to &#x60;DATA_MASKING&#x60;, the function is validated and made available as a masking function. For more information, see [Create custom masking routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
   * @return dataGovernanceType
   */
  @javax.annotation.Nullable
  public DataGovernanceTypeEnum getDataGovernanceType() {
    return dataGovernanceType;
  }

  public void setDataGovernanceType(DataGovernanceTypeEnum dataGovernanceType) {
    this.dataGovernanceType = dataGovernanceType;
  }


  public Routine definitionBody(String definitionBody) {
    this.definitionBody = definitionBody;
    return this;
  }

  /**
   * Required. The body of the routine. For functions, this is the expression in the AS clause. If language&#x3D;SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: &#x60;CREATE FUNCTION JoinLines(x string, y string) as (concat(x, \&quot;\\n\&quot;, y))&#x60; The definition_body is &#x60;concat(x, \&quot;\\n\&quot;, y)&#x60; (\\n is not replaced with linebreak). If language&#x3D;JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: &#x60;CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#39;return \&quot;\\n\&quot;;\\n&#39;&#x60; The definition_body is &#x60;return \&quot;\\n\&quot;;\\n&#x60; Note that both \\n are replaced with linebreaks.
   * @return definitionBody
   */
  @javax.annotation.Nullable
  public String getDefinitionBody() {
    return definitionBody;
  }

  public void setDefinitionBody(String definitionBody) {
    this.definitionBody = definitionBody;
  }


  public Routine description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. The description of the routine, if defined.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Routine determinismLevel(DeterminismLevelEnum determinismLevel) {
    this.determinismLevel = determinismLevel;
    return this;
  }

  /**
   * Optional. The determinism level of the JavaScript UDF, if defined.
   * @return determinismLevel
   */
  @javax.annotation.Nullable
  public DeterminismLevelEnum getDeterminismLevel() {
    return determinismLevel;
  }

  public void setDeterminismLevel(DeterminismLevelEnum determinismLevel) {
    this.determinismLevel = determinismLevel;
  }


  /**
   * Output only. A hash of this resource.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }



  public Routine importedLibraries(List<String> importedLibraries) {
    this.importedLibraries = importedLibraries;
    return this;
  }

  public Routine addImportedLibrariesItem(String importedLibrariesItem) {
    if (this.importedLibraries == null) {
      this.importedLibraries = new ArrayList<>();
    }
    this.importedLibraries.add(importedLibrariesItem);
    return this;
  }

  /**
   * Optional. If language &#x3D; \&quot;JAVASCRIPT\&quot;, this field stores the path of the imported JAVASCRIPT libraries.
   * @return importedLibraries
   */
  @javax.annotation.Nullable
  public List<String> getImportedLibraries() {
    return importedLibraries;
  }

  public void setImportedLibraries(List<String> importedLibraries) {
    this.importedLibraries = importedLibraries;
  }


  public Routine language(LanguageEnum language) {
    this.language = language;
    return this;
  }

  /**
   * Optional. Defaults to \&quot;SQL\&quot; if remote_function_options field is absent, not set otherwise.
   * @return language
   */
  @javax.annotation.Nullable
  public LanguageEnum getLanguage() {
    return language;
  }

  public void setLanguage(LanguageEnum language) {
    this.language = language;
  }


  /**
   * Output only. The time when this routine was last modified, in milliseconds since the epoch.
   * @return lastModifiedTime
   */
  @javax.annotation.Nullable
  public String getLastModifiedTime() {
    return lastModifiedTime;
  }



  public Routine remoteFunctionOptions(RemoteFunctionOptions remoteFunctionOptions) {
    this.remoteFunctionOptions = remoteFunctionOptions;
    return this;
  }

  /**
   * Get remoteFunctionOptions
   * @return remoteFunctionOptions
   */
  @javax.annotation.Nullable
  public RemoteFunctionOptions getRemoteFunctionOptions() {
    return remoteFunctionOptions;
  }

  public void setRemoteFunctionOptions(RemoteFunctionOptions remoteFunctionOptions) {
    this.remoteFunctionOptions = remoteFunctionOptions;
  }


  public Routine returnTableType(StandardSqlTableType returnTableType) {
    this.returnTableType = returnTableType;
    return this;
  }

  /**
   * Get returnTableType
   * @return returnTableType
   */
  @javax.annotation.Nullable
  public StandardSqlTableType getReturnTableType() {
    return returnTableType;
  }

  public void setReturnTableType(StandardSqlTableType returnTableType) {
    this.returnTableType = returnTableType;
  }


  public Routine returnType(StandardSqlDataType returnType) {
    this.returnType = returnType;
    return this;
  }

  /**
   * Get returnType
   * @return returnType
   */
  @javax.annotation.Nullable
  public StandardSqlDataType getReturnType() {
    return returnType;
  }

  public void setReturnType(StandardSqlDataType returnType) {
    this.returnType = returnType;
  }


  public Routine routineReference(RoutineReference routineReference) {
    this.routineReference = routineReference;
    return this;
  }

  /**
   * Get routineReference
   * @return routineReference
   */
  @javax.annotation.Nullable
  public RoutineReference getRoutineReference() {
    return routineReference;
  }

  public void setRoutineReference(RoutineReference routineReference) {
    this.routineReference = routineReference;
  }


  public Routine routineType(RoutineTypeEnum routineType) {
    this.routineType = routineType;
    return this;
  }

  /**
   * Required. The type of routine.
   * @return routineType
   */
  @javax.annotation.Nullable
  public RoutineTypeEnum getRoutineType() {
    return routineType;
  }

  public void setRoutineType(RoutineTypeEnum routineType) {
    this.routineType = routineType;
  }


  public Routine securityMode(SecurityModeEnum securityMode) {
    this.securityMode = securityMode;
    return this;
  }

  /**
   * Optional. The security mode of the routine, if defined. If not defined, the security mode is automatically determined from the routine&#39;s configuration.
   * @return securityMode
   */
  @javax.annotation.Nullable
  public SecurityModeEnum getSecurityMode() {
    return securityMode;
  }

  public void setSecurityMode(SecurityModeEnum securityMode) {
    this.securityMode = securityMode;
  }


  public Routine sparkOptions(SparkOptions sparkOptions) {
    this.sparkOptions = sparkOptions;
    return this;
  }

  /**
   * Get sparkOptions
   * @return sparkOptions
   */
  @javax.annotation.Nullable
  public SparkOptions getSparkOptions() {
    return sparkOptions;
  }

  public void setSparkOptions(SparkOptions sparkOptions) {
    this.sparkOptions = sparkOptions;
  }


  public Routine strictMode(Boolean strictMode) {
    this.strictMode = strictMode;
    return this;
  }

  /**
   * Optional. Use this option to catch many common errors. Error checking is not exhaustive, and successfully creating a procedure doesn&#39;t guarantee that the procedure will successfully execute at runtime. If &#x60;strictMode&#x60; is set to &#x60;TRUE&#x60;, the procedure body is further checked for errors such as non-existent tables or columns. The &#x60;CREATE PROCEDURE&#x60; statement fails if the body fails any of these checks. If &#x60;strictMode&#x60; is set to &#x60;FALSE&#x60;, the procedure body is checked only for syntax. For procedures that invoke themselves recursively, specify &#x60;strictMode&#x3D;FALSE&#x60; to avoid non-existent procedure errors during validation. Default value is &#x60;TRUE&#x60;.
   * @return strictMode
   */
  @javax.annotation.Nullable
  public Boolean getStrictMode() {
    return strictMode;
  }

  public void setStrictMode(Boolean strictMode) {
    this.strictMode = strictMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Routine routine = (Routine) o;
    return Objects.equals(this.arguments, routine.arguments) &&
        Objects.equals(this.creationTime, routine.creationTime) &&
        Objects.equals(this.dataGovernanceType, routine.dataGovernanceType) &&
        Objects.equals(this.definitionBody, routine.definitionBody) &&
        Objects.equals(this.description, routine.description) &&
        Objects.equals(this.determinismLevel, routine.determinismLevel) &&
        Objects.equals(this.etag, routine.etag) &&
        Objects.equals(this.importedLibraries, routine.importedLibraries) &&
        Objects.equals(this.language, routine.language) &&
        Objects.equals(this.lastModifiedTime, routine.lastModifiedTime) &&
        Objects.equals(this.remoteFunctionOptions, routine.remoteFunctionOptions) &&
        Objects.equals(this.returnTableType, routine.returnTableType) &&
        Objects.equals(this.returnType, routine.returnType) &&
        Objects.equals(this.routineReference, routine.routineReference) &&
        Objects.equals(this.routineType, routine.routineType) &&
        Objects.equals(this.securityMode, routine.securityMode) &&
        Objects.equals(this.sparkOptions, routine.sparkOptions) &&
        Objects.equals(this.strictMode, routine.strictMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arguments, creationTime, dataGovernanceType, definitionBody, description, determinismLevel, etag, importedLibraries, language, lastModifiedTime, remoteFunctionOptions, returnTableType, returnType, routineReference, routineType, securityMode, sparkOptions, strictMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Routine {\n");
    sb.append("    arguments: ").append(toIndentedString(arguments)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    dataGovernanceType: ").append(toIndentedString(dataGovernanceType)).append("\n");
    sb.append("    definitionBody: ").append(toIndentedString(definitionBody)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    determinismLevel: ").append(toIndentedString(determinismLevel)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    importedLibraries: ").append(toIndentedString(importedLibraries)).append("\n");
    sb.append("    language: ").append(toIndentedString(language)).append("\n");
    sb.append("    lastModifiedTime: ").append(toIndentedString(lastModifiedTime)).append("\n");
    sb.append("    remoteFunctionOptions: ").append(toIndentedString(remoteFunctionOptions)).append("\n");
    sb.append("    returnTableType: ").append(toIndentedString(returnTableType)).append("\n");
    sb.append("    returnType: ").append(toIndentedString(returnType)).append("\n");
    sb.append("    routineReference: ").append(toIndentedString(routineReference)).append("\n");
    sb.append("    routineType: ").append(toIndentedString(routineType)).append("\n");
    sb.append("    securityMode: ").append(toIndentedString(securityMode)).append("\n");
    sb.append("    sparkOptions: ").append(toIndentedString(sparkOptions)).append("\n");
    sb.append("    strictMode: ").append(toIndentedString(strictMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("arguments");
    openapiFields.add("creationTime");
    openapiFields.add("dataGovernanceType");
    openapiFields.add("definitionBody");
    openapiFields.add("description");
    openapiFields.add("determinismLevel");
    openapiFields.add("etag");
    openapiFields.add("importedLibraries");
    openapiFields.add("language");
    openapiFields.add("lastModifiedTime");
    openapiFields.add("remoteFunctionOptions");
    openapiFields.add("returnTableType");
    openapiFields.add("returnType");
    openapiFields.add("routineReference");
    openapiFields.add("routineType");
    openapiFields.add("securityMode");
    openapiFields.add("sparkOptions");
    openapiFields.add("strictMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Routine
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Routine.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Routine is not found in the empty JSON string", Routine.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Routine.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Routine` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("arguments") != null && !jsonObj.get("arguments").isJsonNull()) {
        JsonArray jsonArrayarguments = jsonObj.getAsJsonArray("arguments");
        if (jsonArrayarguments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("arguments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `arguments` to be an array in the JSON string but got `%s`", jsonObj.get("arguments").toString()));
          }

          // validate the optional field `arguments` (array)
          for (int i = 0; i < jsonArrayarguments.size(); i++) {
            Argument.validateJsonElement(jsonArrayarguments.get(i));
          };
        }
      }
      if ((jsonObj.get("creationTime") != null && !jsonObj.get("creationTime").isJsonNull()) && !jsonObj.get("creationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creationTime").toString()));
      }
      if ((jsonObj.get("dataGovernanceType") != null && !jsonObj.get("dataGovernanceType").isJsonNull()) && !jsonObj.get("dataGovernanceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataGovernanceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataGovernanceType").toString()));
      }
      // validate the optional field `dataGovernanceType`
      if (jsonObj.get("dataGovernanceType") != null && !jsonObj.get("dataGovernanceType").isJsonNull()) {
        DataGovernanceTypeEnum.validateJsonElement(jsonObj.get("dataGovernanceType"));
      }
      if ((jsonObj.get("definitionBody") != null && !jsonObj.get("definitionBody").isJsonNull()) && !jsonObj.get("definitionBody").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definitionBody` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definitionBody").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("determinismLevel") != null && !jsonObj.get("determinismLevel").isJsonNull()) && !jsonObj.get("determinismLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `determinismLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("determinismLevel").toString()));
      }
      // validate the optional field `determinismLevel`
      if (jsonObj.get("determinismLevel") != null && !jsonObj.get("determinismLevel").isJsonNull()) {
        DeterminismLevelEnum.validateJsonElement(jsonObj.get("determinismLevel"));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("importedLibraries") != null && !jsonObj.get("importedLibraries").isJsonNull() && !jsonObj.get("importedLibraries").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `importedLibraries` to be an array in the JSON string but got `%s`", jsonObj.get("importedLibraries").toString()));
      }
      if ((jsonObj.get("language") != null && !jsonObj.get("language").isJsonNull()) && !jsonObj.get("language").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `language` to be a primitive type in the JSON string but got `%s`", jsonObj.get("language").toString()));
      }
      // validate the optional field `language`
      if (jsonObj.get("language") != null && !jsonObj.get("language").isJsonNull()) {
        LanguageEnum.validateJsonElement(jsonObj.get("language"));
      }
      if ((jsonObj.get("lastModifiedTime") != null && !jsonObj.get("lastModifiedTime").isJsonNull()) && !jsonObj.get("lastModifiedTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastModifiedTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastModifiedTime").toString()));
      }
      // validate the optional field `remoteFunctionOptions`
      if (jsonObj.get("remoteFunctionOptions") != null && !jsonObj.get("remoteFunctionOptions").isJsonNull()) {
        RemoteFunctionOptions.validateJsonElement(jsonObj.get("remoteFunctionOptions"));
      }
      // validate the optional field `returnTableType`
      if (jsonObj.get("returnTableType") != null && !jsonObj.get("returnTableType").isJsonNull()) {
        StandardSqlTableType.validateJsonElement(jsonObj.get("returnTableType"));
      }
      // validate the optional field `returnType`
      if (jsonObj.get("returnType") != null && !jsonObj.get("returnType").isJsonNull()) {
        StandardSqlDataType.validateJsonElement(jsonObj.get("returnType"));
      }
      // validate the optional field `routineReference`
      if (jsonObj.get("routineReference") != null && !jsonObj.get("routineReference").isJsonNull()) {
        RoutineReference.validateJsonElement(jsonObj.get("routineReference"));
      }
      if ((jsonObj.get("routineType") != null && !jsonObj.get("routineType").isJsonNull()) && !jsonObj.get("routineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `routineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("routineType").toString()));
      }
      // validate the optional field `routineType`
      if (jsonObj.get("routineType") != null && !jsonObj.get("routineType").isJsonNull()) {
        RoutineTypeEnum.validateJsonElement(jsonObj.get("routineType"));
      }
      if ((jsonObj.get("securityMode") != null && !jsonObj.get("securityMode").isJsonNull()) && !jsonObj.get("securityMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityMode").toString()));
      }
      // validate the optional field `securityMode`
      if (jsonObj.get("securityMode") != null && !jsonObj.get("securityMode").isJsonNull()) {
        SecurityModeEnum.validateJsonElement(jsonObj.get("securityMode"));
      }
      // validate the optional field `sparkOptions`
      if (jsonObj.get("sparkOptions") != null && !jsonObj.get("sparkOptions").isJsonNull()) {
        SparkOptions.validateJsonElement(jsonObj.get("sparkOptions"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Routine.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Routine' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Routine> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Routine.class));

       return (TypeAdapter<T>) new TypeAdapter<Routine>() {
           @Override
           public void write(JsonWriter out, Routine value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Routine read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Routine given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Routine
   * @throws IOException if the JSON string is invalid with respect to Routine
   */
  public static Routine fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Routine.class);
  }

  /**
   * Convert an instance of Routine to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

