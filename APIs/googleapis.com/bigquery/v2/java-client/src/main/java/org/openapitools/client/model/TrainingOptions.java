/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ArimaOrder;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options used in model training.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TrainingOptions {
  public static final String SERIALIZED_NAME_ACTIVATION_FN = "activationFn";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_FN)
  private String activationFn;

  public static final String SERIALIZED_NAME_ADJUST_STEP_CHANGES = "adjustStepChanges";
  @SerializedName(SERIALIZED_NAME_ADJUST_STEP_CHANGES)
  private Boolean adjustStepChanges;

  public static final String SERIALIZED_NAME_APPROX_GLOBAL_FEATURE_CONTRIB = "approxGlobalFeatureContrib";
  @SerializedName(SERIALIZED_NAME_APPROX_GLOBAL_FEATURE_CONTRIB)
  private Boolean approxGlobalFeatureContrib;

  public static final String SERIALIZED_NAME_AUTO_ARIMA = "autoArima";
  @SerializedName(SERIALIZED_NAME_AUTO_ARIMA)
  private Boolean autoArima;

  public static final String SERIALIZED_NAME_AUTO_ARIMA_MAX_ORDER = "autoArimaMaxOrder";
  @SerializedName(SERIALIZED_NAME_AUTO_ARIMA_MAX_ORDER)
  private String autoArimaMaxOrder;

  public static final String SERIALIZED_NAME_AUTO_ARIMA_MIN_ORDER = "autoArimaMinOrder";
  @SerializedName(SERIALIZED_NAME_AUTO_ARIMA_MIN_ORDER)
  private String autoArimaMinOrder;

  public static final String SERIALIZED_NAME_AUTO_CLASS_WEIGHTS = "autoClassWeights";
  @SerializedName(SERIALIZED_NAME_AUTO_CLASS_WEIGHTS)
  private Boolean autoClassWeights;

  public static final String SERIALIZED_NAME_BATCH_SIZE = "batchSize";
  @SerializedName(SERIALIZED_NAME_BATCH_SIZE)
  private String batchSize;

  /**
   * Booster type for boosted tree models.
   */
  @JsonAdapter(BoosterTypeEnum.Adapter.class)
  public enum BoosterTypeEnum {
    BOOSTER_TYPE_UNSPECIFIED("BOOSTER_TYPE_UNSPECIFIED"),
    
    GBTREE("GBTREE"),
    
    DART("DART");

    private String value;

    BoosterTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BoosterTypeEnum fromValue(String value) {
      for (BoosterTypeEnum b : BoosterTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BoosterTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BoosterTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BoosterTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BoosterTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BoosterTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BOOSTER_TYPE = "boosterType";
  @SerializedName(SERIALIZED_NAME_BOOSTER_TYPE)
  private BoosterTypeEnum boosterType;

  public static final String SERIALIZED_NAME_BUDGET_HOURS = "budgetHours";
  @SerializedName(SERIALIZED_NAME_BUDGET_HOURS)
  private Double budgetHours;

  public static final String SERIALIZED_NAME_CALCULATE_P_VALUES = "calculatePValues";
  @SerializedName(SERIALIZED_NAME_CALCULATE_P_VALUES)
  private Boolean calculatePValues;

  /**
   * Categorical feature encoding method.
   */
  @JsonAdapter(CategoryEncodingMethodEnum.Adapter.class)
  public enum CategoryEncodingMethodEnum {
    ENCODING_METHOD_UNSPECIFIED("ENCODING_METHOD_UNSPECIFIED"),
    
    ONE_HOT_ENCODING("ONE_HOT_ENCODING"),
    
    LABEL_ENCODING("LABEL_ENCODING"),
    
    DUMMY_ENCODING("DUMMY_ENCODING");

    private String value;

    CategoryEncodingMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CategoryEncodingMethodEnum fromValue(String value) {
      for (CategoryEncodingMethodEnum b : CategoryEncodingMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CategoryEncodingMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CategoryEncodingMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CategoryEncodingMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CategoryEncodingMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CategoryEncodingMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CATEGORY_ENCODING_METHOD = "categoryEncodingMethod";
  @SerializedName(SERIALIZED_NAME_CATEGORY_ENCODING_METHOD)
  private CategoryEncodingMethodEnum categoryEncodingMethod;

  public static final String SERIALIZED_NAME_CLEAN_SPIKES_AND_DIPS = "cleanSpikesAndDips";
  @SerializedName(SERIALIZED_NAME_CLEAN_SPIKES_AND_DIPS)
  private Boolean cleanSpikesAndDips;

  /**
   * Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
   */
  @JsonAdapter(ColorSpaceEnum.Adapter.class)
  public enum ColorSpaceEnum {
    COLOR_SPACE_UNSPECIFIED("COLOR_SPACE_UNSPECIFIED"),
    
    RGB("RGB"),
    
    HSV("HSV"),
    
    YIQ("YIQ"),
    
    YUV("YUV"),
    
    GRAYSCALE("GRAYSCALE");

    private String value;

    ColorSpaceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ColorSpaceEnum fromValue(String value) {
      for (ColorSpaceEnum b : ColorSpaceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ColorSpaceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ColorSpaceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ColorSpaceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ColorSpaceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ColorSpaceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COLOR_SPACE = "colorSpace";
  @SerializedName(SERIALIZED_NAME_COLOR_SPACE)
  private ColorSpaceEnum colorSpace;

  public static final String SERIALIZED_NAME_COLSAMPLE_BYLEVEL = "colsampleBylevel";
  @SerializedName(SERIALIZED_NAME_COLSAMPLE_BYLEVEL)
  private Double colsampleBylevel;

  public static final String SERIALIZED_NAME_COLSAMPLE_BYNODE = "colsampleBynode";
  @SerializedName(SERIALIZED_NAME_COLSAMPLE_BYNODE)
  private Double colsampleBynode;

  public static final String SERIALIZED_NAME_COLSAMPLE_BYTREE = "colsampleBytree";
  @SerializedName(SERIALIZED_NAME_COLSAMPLE_BYTREE)
  private Double colsampleBytree;

  /**
   * Type of normalization algorithm for boosted tree models using dart booster.
   */
  @JsonAdapter(DartNormalizeTypeEnum.Adapter.class)
  public enum DartNormalizeTypeEnum {
    DART_NORMALIZE_TYPE_UNSPECIFIED("DART_NORMALIZE_TYPE_UNSPECIFIED"),
    
    TREE("TREE"),
    
    FOREST("FOREST");

    private String value;

    DartNormalizeTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DartNormalizeTypeEnum fromValue(String value) {
      for (DartNormalizeTypeEnum b : DartNormalizeTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DartNormalizeTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DartNormalizeTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DartNormalizeTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DartNormalizeTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DartNormalizeTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DART_NORMALIZE_TYPE = "dartNormalizeType";
  @SerializedName(SERIALIZED_NAME_DART_NORMALIZE_TYPE)
  private DartNormalizeTypeEnum dartNormalizeType;

  /**
   * The data frequency of a time series.
   */
  @JsonAdapter(DataFrequencyEnum.Adapter.class)
  public enum DataFrequencyEnum {
    DATA_FREQUENCY_UNSPECIFIED("DATA_FREQUENCY_UNSPECIFIED"),
    
    AUTO_FREQUENCY("AUTO_FREQUENCY"),
    
    YEARLY("YEARLY"),
    
    QUARTERLY("QUARTERLY"),
    
    MONTHLY("MONTHLY"),
    
    WEEKLY("WEEKLY"),
    
    DAILY("DAILY"),
    
    HOURLY("HOURLY"),
    
    PER_MINUTE("PER_MINUTE");

    private String value;

    DataFrequencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataFrequencyEnum fromValue(String value) {
      for (DataFrequencyEnum b : DataFrequencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataFrequencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataFrequencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataFrequencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataFrequencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataFrequencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_FREQUENCY = "dataFrequency";
  @SerializedName(SERIALIZED_NAME_DATA_FREQUENCY)
  private DataFrequencyEnum dataFrequency;

  public static final String SERIALIZED_NAME_DATA_SPLIT_COLUMN = "dataSplitColumn";
  @SerializedName(SERIALIZED_NAME_DATA_SPLIT_COLUMN)
  private String dataSplitColumn;

  public static final String SERIALIZED_NAME_DATA_SPLIT_EVAL_FRACTION = "dataSplitEvalFraction";
  @SerializedName(SERIALIZED_NAME_DATA_SPLIT_EVAL_FRACTION)
  private Double dataSplitEvalFraction;

  /**
   * The data split type for training and evaluation, e.g. RANDOM.
   */
  @JsonAdapter(DataSplitMethodEnum.Adapter.class)
  public enum DataSplitMethodEnum {
    DATA_SPLIT_METHOD_UNSPECIFIED("DATA_SPLIT_METHOD_UNSPECIFIED"),
    
    RANDOM("RANDOM"),
    
    CUSTOM("CUSTOM"),
    
    SEQUENTIAL("SEQUENTIAL"),
    
    NO_SPLIT("NO_SPLIT"),
    
    AUTO_SPLIT("AUTO_SPLIT");

    private String value;

    DataSplitMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataSplitMethodEnum fromValue(String value) {
      for (DataSplitMethodEnum b : DataSplitMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataSplitMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataSplitMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataSplitMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataSplitMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataSplitMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_SPLIT_METHOD = "dataSplitMethod";
  @SerializedName(SERIALIZED_NAME_DATA_SPLIT_METHOD)
  private DataSplitMethodEnum dataSplitMethod;

  public static final String SERIALIZED_NAME_DECOMPOSE_TIME_SERIES = "decomposeTimeSeries";
  @SerializedName(SERIALIZED_NAME_DECOMPOSE_TIME_SERIES)
  private Boolean decomposeTimeSeries;

  /**
   * Distance type for clustering models.
   */
  @JsonAdapter(DistanceTypeEnum.Adapter.class)
  public enum DistanceTypeEnum {
    DISTANCE_TYPE_UNSPECIFIED("DISTANCE_TYPE_UNSPECIFIED"),
    
    EUCLIDEAN("EUCLIDEAN"),
    
    COSINE("COSINE");

    private String value;

    DistanceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DistanceTypeEnum fromValue(String value) {
      for (DistanceTypeEnum b : DistanceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DistanceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DistanceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DistanceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DistanceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DistanceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISTANCE_TYPE = "distanceType";
  @SerializedName(SERIALIZED_NAME_DISTANCE_TYPE)
  private DistanceTypeEnum distanceType;

  public static final String SERIALIZED_NAME_DROPOUT = "dropout";
  @SerializedName(SERIALIZED_NAME_DROPOUT)
  private Double dropout;

  public static final String SERIALIZED_NAME_EARLY_STOP = "earlyStop";
  @SerializedName(SERIALIZED_NAME_EARLY_STOP)
  private Boolean earlyStop;

  public static final String SERIALIZED_NAME_ENABLE_GLOBAL_EXPLAIN = "enableGlobalExplain";
  @SerializedName(SERIALIZED_NAME_ENABLE_GLOBAL_EXPLAIN)
  private Boolean enableGlobalExplain;

  /**
   * Feedback type that specifies which algorithm to run for matrix factorization.
   */
  @JsonAdapter(FeedbackTypeEnum.Adapter.class)
  public enum FeedbackTypeEnum {
    FEEDBACK_TYPE_UNSPECIFIED("FEEDBACK_TYPE_UNSPECIFIED"),
    
    IMPLICIT("IMPLICIT"),
    
    EXPLICIT("EXPLICIT");

    private String value;

    FeedbackTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FeedbackTypeEnum fromValue(String value) {
      for (FeedbackTypeEnum b : FeedbackTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FeedbackTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FeedbackTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FeedbackTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FeedbackTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FeedbackTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FEEDBACK_TYPE = "feedbackType";
  @SerializedName(SERIALIZED_NAME_FEEDBACK_TYPE)
  private FeedbackTypeEnum feedbackType;

  public static final String SERIALIZED_NAME_FIT_INTERCEPT = "fitIntercept";
  @SerializedName(SERIALIZED_NAME_FIT_INTERCEPT)
  private Boolean fitIntercept;

  public static final String SERIALIZED_NAME_HIDDEN_UNITS = "hiddenUnits";
  @SerializedName(SERIALIZED_NAME_HIDDEN_UNITS)
  private List<String> hiddenUnits = new ArrayList<>();

  /**
   * The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
   */
  @JsonAdapter(HolidayRegionEnum.Adapter.class)
  public enum HolidayRegionEnum {
    HOLIDAY_REGION_UNSPECIFIED("HOLIDAY_REGION_UNSPECIFIED"),
    
    GLOBAL("GLOBAL"),
    
    NA("NA"),
    
    JAPAC("JAPAC"),
    
    EMEA("EMEA"),
    
    LAC("LAC"),
    
    AE("AE"),
    
    AR("AR"),
    
    AT("AT"),
    
    AU("AU"),
    
    BE("BE"),
    
    BR("BR"),
    
    CA("CA"),
    
    CH("CH"),
    
    CL("CL"),
    
    CN("CN"),
    
    CO("CO"),
    
    CS("CS"),
    
    CZ("CZ"),
    
    DE("DE"),
    
    DK("DK"),
    
    DZ("DZ"),
    
    EC("EC"),
    
    EE("EE"),
    
    EG("EG"),
    
    ES("ES"),
    
    FI("FI"),
    
    FR("FR"),
    
    GB("GB"),
    
    GR("GR"),
    
    HK("HK"),
    
    HU("HU"),
    
    ID("ID"),
    
    IE("IE"),
    
    IL("IL"),
    
    IN("IN"),
    
    IR("IR"),
    
    IT("IT"),
    
    JP("JP"),
    
    KR("KR"),
    
    LV("LV"),
    
    MA("MA"),
    
    MX("MX"),
    
    MY("MY"),
    
    NG("NG"),
    
    NL("NL"),
    
    FALSE("false"),
    
    NZ("NZ"),
    
    PE("PE"),
    
    PH("PH"),
    
    PK("PK"),
    
    PL("PL"),
    
    PT("PT"),
    
    RO("RO"),
    
    RS("RS"),
    
    RU("RU"),
    
    SA("SA"),
    
    SE("SE"),
    
    SG("SG"),
    
    SI("SI"),
    
    SK("SK"),
    
    TH("TH"),
    
    TR("TR"),
    
    TW("TW"),
    
    UA("UA"),
    
    US("US"),
    
    VE("VE"),
    
    VN("VN"),
    
    ZA("ZA");

    private String value;

    HolidayRegionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HolidayRegionEnum fromValue(String value) {
      for (HolidayRegionEnum b : HolidayRegionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HolidayRegionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HolidayRegionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HolidayRegionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HolidayRegionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HolidayRegionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HOLIDAY_REGION = "holidayRegion";
  @SerializedName(SERIALIZED_NAME_HOLIDAY_REGION)
  private HolidayRegionEnum holidayRegion;

  /**
   * Gets or Sets holidayRegions
   */
  @JsonAdapter(HolidayRegionsEnum.Adapter.class)
  public enum HolidayRegionsEnum {
    HOLIDAY_REGION_UNSPECIFIED("HOLIDAY_REGION_UNSPECIFIED"),
    
    GLOBAL("GLOBAL"),
    
    NA("NA"),
    
    JAPAC("JAPAC"),
    
    EMEA("EMEA"),
    
    LAC("LAC"),
    
    AE("AE"),
    
    AR("AR"),
    
    AT("AT"),
    
    AU("AU"),
    
    BE("BE"),
    
    BR("BR"),
    
    CA("CA"),
    
    CH("CH"),
    
    CL("CL"),
    
    CN("CN"),
    
    CO("CO"),
    
    CS("CS"),
    
    CZ("CZ"),
    
    DE("DE"),
    
    DK("DK"),
    
    DZ("DZ"),
    
    EC("EC"),
    
    EE("EE"),
    
    EG("EG"),
    
    ES("ES"),
    
    FI("FI"),
    
    FR("FR"),
    
    GB("GB"),
    
    GR("GR"),
    
    HK("HK"),
    
    HU("HU"),
    
    ID("ID"),
    
    IE("IE"),
    
    IL("IL"),
    
    IN("IN"),
    
    IR("IR"),
    
    IT("IT"),
    
    JP("JP"),
    
    KR("KR"),
    
    LV("LV"),
    
    MA("MA"),
    
    MX("MX"),
    
    MY("MY"),
    
    NG("NG"),
    
    NL("NL"),
    
    FALSE("false"),
    
    NZ("NZ"),
    
    PE("PE"),
    
    PH("PH"),
    
    PK("PK"),
    
    PL("PL"),
    
    PT("PT"),
    
    RO("RO"),
    
    RS("RS"),
    
    RU("RU"),
    
    SA("SA"),
    
    SE("SE"),
    
    SG("SG"),
    
    SI("SI"),
    
    SK("SK"),
    
    TH("TH"),
    
    TR("TR"),
    
    TW("TW"),
    
    UA("UA"),
    
    US("US"),
    
    VE("VE"),
    
    VN("VN"),
    
    ZA("ZA");

    private String value;

    HolidayRegionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HolidayRegionsEnum fromValue(String value) {
      for (HolidayRegionsEnum b : HolidayRegionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HolidayRegionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HolidayRegionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HolidayRegionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HolidayRegionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HolidayRegionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HOLIDAY_REGIONS = "holidayRegions";
  @SerializedName(SERIALIZED_NAME_HOLIDAY_REGIONS)
  private List<HolidayRegionsEnum> holidayRegions = new ArrayList<>();

  public static final String SERIALIZED_NAME_HORIZON = "horizon";
  @SerializedName(SERIALIZED_NAME_HORIZON)
  private String horizon;

  /**
   * Gets or Sets hparamTuningObjectives
   */
  @JsonAdapter(HparamTuningObjectivesEnum.Adapter.class)
  public enum HparamTuningObjectivesEnum {
    HPARAM_TUNING_OBJECTIVE_UNSPECIFIED("HPARAM_TUNING_OBJECTIVE_UNSPECIFIED"),
    
    MEAN_ABSOLUTE_ERROR("MEAN_ABSOLUTE_ERROR"),
    
    MEAN_SQUARED_ERROR("MEAN_SQUARED_ERROR"),
    
    MEAN_SQUARED_LOG_ERROR("MEAN_SQUARED_LOG_ERROR"),
    
    MEDIAN_ABSOLUTE_ERROR("MEDIAN_ABSOLUTE_ERROR"),
    
    R_SQUARED("R_SQUARED"),
    
    EXPLAINED_VARIANCE("EXPLAINED_VARIANCE"),
    
    PRECISION("PRECISION"),
    
    RECALL("RECALL"),
    
    ACCURACY("ACCURACY"),
    
    F1_SCORE("F1_SCORE"),
    
    LOG_LOSS("LOG_LOSS"),
    
    ROC_AUC("ROC_AUC"),
    
    DAVIES_BOULDIN_INDEX("DAVIES_BOULDIN_INDEX"),
    
    MEAN_AVERAGE_PRECISION("MEAN_AVERAGE_PRECISION"),
    
    NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN("NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN"),
    
    AVERAGE_RANK("AVERAGE_RANK");

    private String value;

    HparamTuningObjectivesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HparamTuningObjectivesEnum fromValue(String value) {
      for (HparamTuningObjectivesEnum b : HparamTuningObjectivesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HparamTuningObjectivesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HparamTuningObjectivesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HparamTuningObjectivesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HparamTuningObjectivesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HparamTuningObjectivesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HPARAM_TUNING_OBJECTIVES = "hparamTuningObjectives";
  @SerializedName(SERIALIZED_NAME_HPARAM_TUNING_OBJECTIVES)
  private List<HparamTuningObjectivesEnum> hparamTuningObjectives = new ArrayList<>();

  public static final String SERIALIZED_NAME_INCLUDE_DRIFT = "includeDrift";
  @SerializedName(SERIALIZED_NAME_INCLUDE_DRIFT)
  private Boolean includeDrift;

  public static final String SERIALIZED_NAME_INITIAL_LEARN_RATE = "initialLearnRate";
  @SerializedName(SERIALIZED_NAME_INITIAL_LEARN_RATE)
  private Double initialLearnRate;

  public static final String SERIALIZED_NAME_INPUT_LABEL_COLUMNS = "inputLabelColumns";
  @SerializedName(SERIALIZED_NAME_INPUT_LABEL_COLUMNS)
  private List<String> inputLabelColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTANCE_WEIGHT_COLUMN = "instanceWeightColumn";
  @SerializedName(SERIALIZED_NAME_INSTANCE_WEIGHT_COLUMN)
  private String instanceWeightColumn;

  public static final String SERIALIZED_NAME_INTEGRATED_GRADIENTS_NUM_STEPS = "integratedGradientsNumSteps";
  @SerializedName(SERIALIZED_NAME_INTEGRATED_GRADIENTS_NUM_STEPS)
  private String integratedGradientsNumSteps;

  public static final String SERIALIZED_NAME_ITEM_COLUMN = "itemColumn";
  @SerializedName(SERIALIZED_NAME_ITEM_COLUMN)
  private String itemColumn;

  public static final String SERIALIZED_NAME_KMEANS_INITIALIZATION_COLUMN = "kmeansInitializationColumn";
  @SerializedName(SERIALIZED_NAME_KMEANS_INITIALIZATION_COLUMN)
  private String kmeansInitializationColumn;

  /**
   * The method used to initialize the centroids for kmeans algorithm.
   */
  @JsonAdapter(KmeansInitializationMethodEnum.Adapter.class)
  public enum KmeansInitializationMethodEnum {
    KMEANS_INITIALIZATION_METHOD_UNSPECIFIED("KMEANS_INITIALIZATION_METHOD_UNSPECIFIED"),
    
    RANDOM("RANDOM"),
    
    CUSTOM("CUSTOM"),
    
    KMEANS_PLUS_PLUS("KMEANS_PLUS_PLUS");

    private String value;

    KmeansInitializationMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static KmeansInitializationMethodEnum fromValue(String value) {
      for (KmeansInitializationMethodEnum b : KmeansInitializationMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<KmeansInitializationMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final KmeansInitializationMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public KmeansInitializationMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return KmeansInitializationMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      KmeansInitializationMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_KMEANS_INITIALIZATION_METHOD = "kmeansInitializationMethod";
  @SerializedName(SERIALIZED_NAME_KMEANS_INITIALIZATION_METHOD)
  private KmeansInitializationMethodEnum kmeansInitializationMethod;

  public static final String SERIALIZED_NAME_L1_REG_ACTIVATION = "l1RegActivation";
  @SerializedName(SERIALIZED_NAME_L1_REG_ACTIVATION)
  private Double l1RegActivation;

  public static final String SERIALIZED_NAME_L1_REGULARIZATION = "l1Regularization";
  @SerializedName(SERIALIZED_NAME_L1_REGULARIZATION)
  private Double l1Regularization;

  public static final String SERIALIZED_NAME_L2_REGULARIZATION = "l2Regularization";
  @SerializedName(SERIALIZED_NAME_L2_REGULARIZATION)
  private Double l2Regularization;

  public static final String SERIALIZED_NAME_LABEL_CLASS_WEIGHTS = "labelClassWeights";
  @SerializedName(SERIALIZED_NAME_LABEL_CLASS_WEIGHTS)
  private Map<String, Double> labelClassWeights = new HashMap<>();

  public static final String SERIALIZED_NAME_LEARN_RATE = "learnRate";
  @SerializedName(SERIALIZED_NAME_LEARN_RATE)
  private Double learnRate;

  /**
   * The strategy to determine learn rate for the current iteration.
   */
  @JsonAdapter(LearnRateStrategyEnum.Adapter.class)
  public enum LearnRateStrategyEnum {
    LEARN_RATE_STRATEGY_UNSPECIFIED("LEARN_RATE_STRATEGY_UNSPECIFIED"),
    
    LINE_SEARCH("LINE_SEARCH"),
    
    CONSTANT("CONSTANT");

    private String value;

    LearnRateStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LearnRateStrategyEnum fromValue(String value) {
      for (LearnRateStrategyEnum b : LearnRateStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LearnRateStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LearnRateStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LearnRateStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LearnRateStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LearnRateStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LEARN_RATE_STRATEGY = "learnRateStrategy";
  @SerializedName(SERIALIZED_NAME_LEARN_RATE_STRATEGY)
  private LearnRateStrategyEnum learnRateStrategy;

  /**
   * Type of loss function used during training run.
   */
  @JsonAdapter(LossTypeEnum.Adapter.class)
  public enum LossTypeEnum {
    LOSS_TYPE_UNSPECIFIED("LOSS_TYPE_UNSPECIFIED"),
    
    MEAN_SQUARED_LOSS("MEAN_SQUARED_LOSS"),
    
    MEAN_LOG_LOSS("MEAN_LOG_LOSS");

    private String value;

    LossTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LossTypeEnum fromValue(String value) {
      for (LossTypeEnum b : LossTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LossTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LossTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LossTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LossTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LossTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOSS_TYPE = "lossType";
  @SerializedName(SERIALIZED_NAME_LOSS_TYPE)
  private LossTypeEnum lossType;

  public static final String SERIALIZED_NAME_MAX_ITERATIONS = "maxIterations";
  @SerializedName(SERIALIZED_NAME_MAX_ITERATIONS)
  private String maxIterations;

  public static final String SERIALIZED_NAME_MAX_PARALLEL_TRIALS = "maxParallelTrials";
  @SerializedName(SERIALIZED_NAME_MAX_PARALLEL_TRIALS)
  private String maxParallelTrials;

  public static final String SERIALIZED_NAME_MAX_TIME_SERIES_LENGTH = "maxTimeSeriesLength";
  @SerializedName(SERIALIZED_NAME_MAX_TIME_SERIES_LENGTH)
  private String maxTimeSeriesLength;

  public static final String SERIALIZED_NAME_MAX_TREE_DEPTH = "maxTreeDepth";
  @SerializedName(SERIALIZED_NAME_MAX_TREE_DEPTH)
  private String maxTreeDepth;

  public static final String SERIALIZED_NAME_MIN_RELATIVE_PROGRESS = "minRelativeProgress";
  @SerializedName(SERIALIZED_NAME_MIN_RELATIVE_PROGRESS)
  private Double minRelativeProgress;

  public static final String SERIALIZED_NAME_MIN_SPLIT_LOSS = "minSplitLoss";
  @SerializedName(SERIALIZED_NAME_MIN_SPLIT_LOSS)
  private Double minSplitLoss;

  public static final String SERIALIZED_NAME_MIN_TIME_SERIES_LENGTH = "minTimeSeriesLength";
  @SerializedName(SERIALIZED_NAME_MIN_TIME_SERIES_LENGTH)
  private String minTimeSeriesLength;

  public static final String SERIALIZED_NAME_MIN_TREE_CHILD_WEIGHT = "minTreeChildWeight";
  @SerializedName(SERIALIZED_NAME_MIN_TREE_CHILD_WEIGHT)
  private String minTreeChildWeight;

  /**
   * The model registry.
   */
  @JsonAdapter(ModelRegistryEnum.Adapter.class)
  public enum ModelRegistryEnum {
    MODEL_REGISTRY_UNSPECIFIED("MODEL_REGISTRY_UNSPECIFIED"),
    
    VERTEX_AI("VERTEX_AI");

    private String value;

    ModelRegistryEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModelRegistryEnum fromValue(String value) {
      for (ModelRegistryEnum b : ModelRegistryEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ModelRegistryEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModelRegistryEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModelRegistryEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ModelRegistryEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ModelRegistryEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MODEL_REGISTRY = "modelRegistry";
  @SerializedName(SERIALIZED_NAME_MODEL_REGISTRY)
  private ModelRegistryEnum modelRegistry;

  public static final String SERIALIZED_NAME_MODEL_URI = "modelUri";
  @SerializedName(SERIALIZED_NAME_MODEL_URI)
  private String modelUri;

  public static final String SERIALIZED_NAME_NON_SEASONAL_ORDER = "nonSeasonalOrder";
  @SerializedName(SERIALIZED_NAME_NON_SEASONAL_ORDER)
  private ArimaOrder nonSeasonalOrder;

  public static final String SERIALIZED_NAME_NUM_CLUSTERS = "numClusters";
  @SerializedName(SERIALIZED_NAME_NUM_CLUSTERS)
  private String numClusters;

  public static final String SERIALIZED_NAME_NUM_FACTORS = "numFactors";
  @SerializedName(SERIALIZED_NAME_NUM_FACTORS)
  private String numFactors;

  public static final String SERIALIZED_NAME_NUM_PARALLEL_TREE = "numParallelTree";
  @SerializedName(SERIALIZED_NAME_NUM_PARALLEL_TREE)
  private String numParallelTree;

  public static final String SERIALIZED_NAME_NUM_PRINCIPAL_COMPONENTS = "numPrincipalComponents";
  @SerializedName(SERIALIZED_NAME_NUM_PRINCIPAL_COMPONENTS)
  private String numPrincipalComponents;

  public static final String SERIALIZED_NAME_NUM_TRIALS = "numTrials";
  @SerializedName(SERIALIZED_NAME_NUM_TRIALS)
  private String numTrials;

  /**
   * Optimization strategy for training linear regression models.
   */
  @JsonAdapter(OptimizationStrategyEnum.Adapter.class)
  public enum OptimizationStrategyEnum {
    OPTIMIZATION_STRATEGY_UNSPECIFIED("OPTIMIZATION_STRATEGY_UNSPECIFIED"),
    
    BATCH_GRADIENT_DESCENT("BATCH_GRADIENT_DESCENT"),
    
    NORMAL_EQUATION("NORMAL_EQUATION");

    private String value;

    OptimizationStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OptimizationStrategyEnum fromValue(String value) {
      for (OptimizationStrategyEnum b : OptimizationStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OptimizationStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OptimizationStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OptimizationStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OptimizationStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OptimizationStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OPTIMIZATION_STRATEGY = "optimizationStrategy";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_STRATEGY)
  private OptimizationStrategyEnum optimizationStrategy;

  public static final String SERIALIZED_NAME_OPTIMIZER = "optimizer";
  @SerializedName(SERIALIZED_NAME_OPTIMIZER)
  private String optimizer;

  public static final String SERIALIZED_NAME_PCA_EXPLAINED_VARIANCE_RATIO = "pcaExplainedVarianceRatio";
  @SerializedName(SERIALIZED_NAME_PCA_EXPLAINED_VARIANCE_RATIO)
  private Double pcaExplainedVarianceRatio;

  /**
   * The solver for PCA.
   */
  @JsonAdapter(PcaSolverEnum.Adapter.class)
  public enum PcaSolverEnum {
    UNSPECIFIED("UNSPECIFIED"),
    
    FULL("FULL"),
    
    RANDOMIZED("RANDOMIZED"),
    
    AUTO("AUTO");

    private String value;

    PcaSolverEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PcaSolverEnum fromValue(String value) {
      for (PcaSolverEnum b : PcaSolverEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PcaSolverEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PcaSolverEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PcaSolverEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PcaSolverEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PcaSolverEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PCA_SOLVER = "pcaSolver";
  @SerializedName(SERIALIZED_NAME_PCA_SOLVER)
  private PcaSolverEnum pcaSolver;

  public static final String SERIALIZED_NAME_SAMPLED_SHAPLEY_NUM_PATHS = "sampledShapleyNumPaths";
  @SerializedName(SERIALIZED_NAME_SAMPLED_SHAPLEY_NUM_PATHS)
  private String sampledShapleyNumPaths;

  public static final String SERIALIZED_NAME_SCALE_FEATURES = "scaleFeatures";
  @SerializedName(SERIALIZED_NAME_SCALE_FEATURES)
  private Boolean scaleFeatures;

  public static final String SERIALIZED_NAME_STANDARDIZE_FEATURES = "standardizeFeatures";
  @SerializedName(SERIALIZED_NAME_STANDARDIZE_FEATURES)
  private Boolean standardizeFeatures;

  public static final String SERIALIZED_NAME_SUBSAMPLE = "subsample";
  @SerializedName(SERIALIZED_NAME_SUBSAMPLE)
  private Double subsample;

  public static final String SERIALIZED_NAME_TF_VERSION = "tfVersion";
  @SerializedName(SERIALIZED_NAME_TF_VERSION)
  private String tfVersion;

  public static final String SERIALIZED_NAME_TIME_SERIES_DATA_COLUMN = "timeSeriesDataColumn";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_DATA_COLUMN)
  private String timeSeriesDataColumn;

  public static final String SERIALIZED_NAME_TIME_SERIES_ID_COLUMN = "timeSeriesIdColumn";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_ID_COLUMN)
  private String timeSeriesIdColumn;

  public static final String SERIALIZED_NAME_TIME_SERIES_ID_COLUMNS = "timeSeriesIdColumns";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_ID_COLUMNS)
  private List<String> timeSeriesIdColumns = new ArrayList<>();

  public static final String SERIALIZED_NAME_TIME_SERIES_LENGTH_FRACTION = "timeSeriesLengthFraction";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_LENGTH_FRACTION)
  private Double timeSeriesLengthFraction;

  public static final String SERIALIZED_NAME_TIME_SERIES_TIMESTAMP_COLUMN = "timeSeriesTimestampColumn";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES_TIMESTAMP_COLUMN)
  private String timeSeriesTimestampColumn;

  /**
   * Tree construction algorithm for boosted tree models.
   */
  @JsonAdapter(TreeMethodEnum.Adapter.class)
  public enum TreeMethodEnum {
    TREE_METHOD_UNSPECIFIED("TREE_METHOD_UNSPECIFIED"),
    
    AUTO("AUTO"),
    
    EXACT("EXACT"),
    
    APPROX("APPROX"),
    
    HIST("HIST");

    private String value;

    TreeMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TreeMethodEnum fromValue(String value) {
      for (TreeMethodEnum b : TreeMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TreeMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TreeMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TreeMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TreeMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TreeMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TREE_METHOD = "treeMethod";
  @SerializedName(SERIALIZED_NAME_TREE_METHOD)
  private TreeMethodEnum treeMethod;

  public static final String SERIALIZED_NAME_TREND_SMOOTHING_WINDOW_SIZE = "trendSmoothingWindowSize";
  @SerializedName(SERIALIZED_NAME_TREND_SMOOTHING_WINDOW_SIZE)
  private String trendSmoothingWindowSize;

  public static final String SERIALIZED_NAME_USER_COLUMN = "userColumn";
  @SerializedName(SERIALIZED_NAME_USER_COLUMN)
  private String userColumn;

  public static final String SERIALIZED_NAME_VERTEX_AI_MODEL_VERSION_ALIASES = "vertexAiModelVersionAliases";
  @SerializedName(SERIALIZED_NAME_VERTEX_AI_MODEL_VERSION_ALIASES)
  private List<String> vertexAiModelVersionAliases = new ArrayList<>();

  public static final String SERIALIZED_NAME_WALS_ALPHA = "walsAlpha";
  @SerializedName(SERIALIZED_NAME_WALS_ALPHA)
  private Double walsAlpha;

  public static final String SERIALIZED_NAME_WARM_START = "warmStart";
  @SerializedName(SERIALIZED_NAME_WARM_START)
  private Boolean warmStart;

  public static final String SERIALIZED_NAME_XGBOOST_VERSION = "xgboostVersion";
  @SerializedName(SERIALIZED_NAME_XGBOOST_VERSION)
  private String xgboostVersion;

  public TrainingOptions() {
  }

  public TrainingOptions activationFn(String activationFn) {
    this.activationFn = activationFn;
    return this;
  }

  /**
   * Activation function of the neural nets.
   * @return activationFn
   */
  @javax.annotation.Nullable
  public String getActivationFn() {
    return activationFn;
  }

  public void setActivationFn(String activationFn) {
    this.activationFn = activationFn;
  }


  public TrainingOptions adjustStepChanges(Boolean adjustStepChanges) {
    this.adjustStepChanges = adjustStepChanges;
    return this;
  }

  /**
   * If true, detect step changes and make data adjustment in the input time series.
   * @return adjustStepChanges
   */
  @javax.annotation.Nullable
  public Boolean getAdjustStepChanges() {
    return adjustStepChanges;
  }

  public void setAdjustStepChanges(Boolean adjustStepChanges) {
    this.adjustStepChanges = adjustStepChanges;
  }


  public TrainingOptions approxGlobalFeatureContrib(Boolean approxGlobalFeatureContrib) {
    this.approxGlobalFeatureContrib = approxGlobalFeatureContrib;
    return this;
  }

  /**
   * Whether to use approximate feature contribution method in XGBoost model explanation for global explain.
   * @return approxGlobalFeatureContrib
   */
  @javax.annotation.Nullable
  public Boolean getApproxGlobalFeatureContrib() {
    return approxGlobalFeatureContrib;
  }

  public void setApproxGlobalFeatureContrib(Boolean approxGlobalFeatureContrib) {
    this.approxGlobalFeatureContrib = approxGlobalFeatureContrib;
  }


  public TrainingOptions autoArima(Boolean autoArima) {
    this.autoArima = autoArima;
    return this;
  }

  /**
   * Whether to enable auto ARIMA or not.
   * @return autoArima
   */
  @javax.annotation.Nullable
  public Boolean getAutoArima() {
    return autoArima;
  }

  public void setAutoArima(Boolean autoArima) {
    this.autoArima = autoArima;
  }


  public TrainingOptions autoArimaMaxOrder(String autoArimaMaxOrder) {
    this.autoArimaMaxOrder = autoArimaMaxOrder;
    return this;
  }

  /**
   * The max value of the sum of non-seasonal p and q.
   * @return autoArimaMaxOrder
   */
  @javax.annotation.Nullable
  public String getAutoArimaMaxOrder() {
    return autoArimaMaxOrder;
  }

  public void setAutoArimaMaxOrder(String autoArimaMaxOrder) {
    this.autoArimaMaxOrder = autoArimaMaxOrder;
  }


  public TrainingOptions autoArimaMinOrder(String autoArimaMinOrder) {
    this.autoArimaMinOrder = autoArimaMinOrder;
    return this;
  }

  /**
   * The min value of the sum of non-seasonal p and q.
   * @return autoArimaMinOrder
   */
  @javax.annotation.Nullable
  public String getAutoArimaMinOrder() {
    return autoArimaMinOrder;
  }

  public void setAutoArimaMinOrder(String autoArimaMinOrder) {
    this.autoArimaMinOrder = autoArimaMinOrder;
  }


  public TrainingOptions autoClassWeights(Boolean autoClassWeights) {
    this.autoClassWeights = autoClassWeights;
    return this;
  }

  /**
   * Whether to calculate class weights automatically based on the popularity of each label.
   * @return autoClassWeights
   */
  @javax.annotation.Nullable
  public Boolean getAutoClassWeights() {
    return autoClassWeights;
  }

  public void setAutoClassWeights(Boolean autoClassWeights) {
    this.autoClassWeights = autoClassWeights;
  }


  public TrainingOptions batchSize(String batchSize) {
    this.batchSize = batchSize;
    return this;
  }

  /**
   * Batch size for dnn models.
   * @return batchSize
   */
  @javax.annotation.Nullable
  public String getBatchSize() {
    return batchSize;
  }

  public void setBatchSize(String batchSize) {
    this.batchSize = batchSize;
  }


  public TrainingOptions boosterType(BoosterTypeEnum boosterType) {
    this.boosterType = boosterType;
    return this;
  }

  /**
   * Booster type for boosted tree models.
   * @return boosterType
   */
  @javax.annotation.Nullable
  public BoosterTypeEnum getBoosterType() {
    return boosterType;
  }

  public void setBoosterType(BoosterTypeEnum boosterType) {
    this.boosterType = boosterType;
  }


  public TrainingOptions budgetHours(Double budgetHours) {
    this.budgetHours = budgetHours;
    return this;
  }

  /**
   * Budget in hours for AutoML training.
   * @return budgetHours
   */
  @javax.annotation.Nullable
  public Double getBudgetHours() {
    return budgetHours;
  }

  public void setBudgetHours(Double budgetHours) {
    this.budgetHours = budgetHours;
  }


  public TrainingOptions calculatePValues(Boolean calculatePValues) {
    this.calculatePValues = calculatePValues;
    return this;
  }

  /**
   * Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.
   * @return calculatePValues
   */
  @javax.annotation.Nullable
  public Boolean getCalculatePValues() {
    return calculatePValues;
  }

  public void setCalculatePValues(Boolean calculatePValues) {
    this.calculatePValues = calculatePValues;
  }


  public TrainingOptions categoryEncodingMethod(CategoryEncodingMethodEnum categoryEncodingMethod) {
    this.categoryEncodingMethod = categoryEncodingMethod;
    return this;
  }

  /**
   * Categorical feature encoding method.
   * @return categoryEncodingMethod
   */
  @javax.annotation.Nullable
  public CategoryEncodingMethodEnum getCategoryEncodingMethod() {
    return categoryEncodingMethod;
  }

  public void setCategoryEncodingMethod(CategoryEncodingMethodEnum categoryEncodingMethod) {
    this.categoryEncodingMethod = categoryEncodingMethod;
  }


  public TrainingOptions cleanSpikesAndDips(Boolean cleanSpikesAndDips) {
    this.cleanSpikesAndDips = cleanSpikesAndDips;
    return this;
  }

  /**
   * If true, clean spikes and dips in the input time series.
   * @return cleanSpikesAndDips
   */
  @javax.annotation.Nullable
  public Boolean getCleanSpikesAndDips() {
    return cleanSpikesAndDips;
  }

  public void setCleanSpikesAndDips(Boolean cleanSpikesAndDips) {
    this.cleanSpikesAndDips = cleanSpikesAndDips;
  }


  public TrainingOptions colorSpace(ColorSpaceEnum colorSpace) {
    this.colorSpace = colorSpace;
    return this;
  }

  /**
   * Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
   * @return colorSpace
   */
  @javax.annotation.Nullable
  public ColorSpaceEnum getColorSpace() {
    return colorSpace;
  }

  public void setColorSpace(ColorSpaceEnum colorSpace) {
    this.colorSpace = colorSpace;
  }


  public TrainingOptions colsampleBylevel(Double colsampleBylevel) {
    this.colsampleBylevel = colsampleBylevel;
    return this;
  }

  /**
   * Subsample ratio of columns for each level for boosted tree models.
   * @return colsampleBylevel
   */
  @javax.annotation.Nullable
  public Double getColsampleBylevel() {
    return colsampleBylevel;
  }

  public void setColsampleBylevel(Double colsampleBylevel) {
    this.colsampleBylevel = colsampleBylevel;
  }


  public TrainingOptions colsampleBynode(Double colsampleBynode) {
    this.colsampleBynode = colsampleBynode;
    return this;
  }

  /**
   * Subsample ratio of columns for each node(split) for boosted tree models.
   * @return colsampleBynode
   */
  @javax.annotation.Nullable
  public Double getColsampleBynode() {
    return colsampleBynode;
  }

  public void setColsampleBynode(Double colsampleBynode) {
    this.colsampleBynode = colsampleBynode;
  }


  public TrainingOptions colsampleBytree(Double colsampleBytree) {
    this.colsampleBytree = colsampleBytree;
    return this;
  }

  /**
   * Subsample ratio of columns when constructing each tree for boosted tree models.
   * @return colsampleBytree
   */
  @javax.annotation.Nullable
  public Double getColsampleBytree() {
    return colsampleBytree;
  }

  public void setColsampleBytree(Double colsampleBytree) {
    this.colsampleBytree = colsampleBytree;
  }


  public TrainingOptions dartNormalizeType(DartNormalizeTypeEnum dartNormalizeType) {
    this.dartNormalizeType = dartNormalizeType;
    return this;
  }

  /**
   * Type of normalization algorithm for boosted tree models using dart booster.
   * @return dartNormalizeType
   */
  @javax.annotation.Nullable
  public DartNormalizeTypeEnum getDartNormalizeType() {
    return dartNormalizeType;
  }

  public void setDartNormalizeType(DartNormalizeTypeEnum dartNormalizeType) {
    this.dartNormalizeType = dartNormalizeType;
  }


  public TrainingOptions dataFrequency(DataFrequencyEnum dataFrequency) {
    this.dataFrequency = dataFrequency;
    return this;
  }

  /**
   * The data frequency of a time series.
   * @return dataFrequency
   */
  @javax.annotation.Nullable
  public DataFrequencyEnum getDataFrequency() {
    return dataFrequency;
  }

  public void setDataFrequency(DataFrequencyEnum dataFrequency) {
    this.dataFrequency = dataFrequency;
  }


  public TrainingOptions dataSplitColumn(String dataSplitColumn) {
    this.dataSplitColumn = dataSplitColumn;
    return this;
  }

  /**
   * The column to split data with. This column won&#39;t be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
   * @return dataSplitColumn
   */
  @javax.annotation.Nullable
  public String getDataSplitColumn() {
    return dataSplitColumn;
  }

  public void setDataSplitColumn(String dataSplitColumn) {
    this.dataSplitColumn = dataSplitColumn;
  }


  public TrainingOptions dataSplitEvalFraction(Double dataSplitEvalFraction) {
    this.dataSplitEvalFraction = dataSplitEvalFraction;
    return this;
  }

  /**
   * The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
   * @return dataSplitEvalFraction
   */
  @javax.annotation.Nullable
  public Double getDataSplitEvalFraction() {
    return dataSplitEvalFraction;
  }

  public void setDataSplitEvalFraction(Double dataSplitEvalFraction) {
    this.dataSplitEvalFraction = dataSplitEvalFraction;
  }


  public TrainingOptions dataSplitMethod(DataSplitMethodEnum dataSplitMethod) {
    this.dataSplitMethod = dataSplitMethod;
    return this;
  }

  /**
   * The data split type for training and evaluation, e.g. RANDOM.
   * @return dataSplitMethod
   */
  @javax.annotation.Nullable
  public DataSplitMethodEnum getDataSplitMethod() {
    return dataSplitMethod;
  }

  public void setDataSplitMethod(DataSplitMethodEnum dataSplitMethod) {
    this.dataSplitMethod = dataSplitMethod;
  }


  public TrainingOptions decomposeTimeSeries(Boolean decomposeTimeSeries) {
    this.decomposeTimeSeries = decomposeTimeSeries;
    return this;
  }

  /**
   * If true, perform decompose time series and save the results.
   * @return decomposeTimeSeries
   */
  @javax.annotation.Nullable
  public Boolean getDecomposeTimeSeries() {
    return decomposeTimeSeries;
  }

  public void setDecomposeTimeSeries(Boolean decomposeTimeSeries) {
    this.decomposeTimeSeries = decomposeTimeSeries;
  }


  public TrainingOptions distanceType(DistanceTypeEnum distanceType) {
    this.distanceType = distanceType;
    return this;
  }

  /**
   * Distance type for clustering models.
   * @return distanceType
   */
  @javax.annotation.Nullable
  public DistanceTypeEnum getDistanceType() {
    return distanceType;
  }

  public void setDistanceType(DistanceTypeEnum distanceType) {
    this.distanceType = distanceType;
  }


  public TrainingOptions dropout(Double dropout) {
    this.dropout = dropout;
    return this;
  }

  /**
   * Dropout probability for dnn models.
   * @return dropout
   */
  @javax.annotation.Nullable
  public Double getDropout() {
    return dropout;
  }

  public void setDropout(Double dropout) {
    this.dropout = dropout;
  }


  public TrainingOptions earlyStop(Boolean earlyStop) {
    this.earlyStop = earlyStop;
    return this;
  }

  /**
   * Whether to stop early when the loss doesn&#39;t improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
   * @return earlyStop
   */
  @javax.annotation.Nullable
  public Boolean getEarlyStop() {
    return earlyStop;
  }

  public void setEarlyStop(Boolean earlyStop) {
    this.earlyStop = earlyStop;
  }


  public TrainingOptions enableGlobalExplain(Boolean enableGlobalExplain) {
    this.enableGlobalExplain = enableGlobalExplain;
    return this;
  }

  /**
   * If true, enable global explanation during training.
   * @return enableGlobalExplain
   */
  @javax.annotation.Nullable
  public Boolean getEnableGlobalExplain() {
    return enableGlobalExplain;
  }

  public void setEnableGlobalExplain(Boolean enableGlobalExplain) {
    this.enableGlobalExplain = enableGlobalExplain;
  }


  public TrainingOptions feedbackType(FeedbackTypeEnum feedbackType) {
    this.feedbackType = feedbackType;
    return this;
  }

  /**
   * Feedback type that specifies which algorithm to run for matrix factorization.
   * @return feedbackType
   */
  @javax.annotation.Nullable
  public FeedbackTypeEnum getFeedbackType() {
    return feedbackType;
  }

  public void setFeedbackType(FeedbackTypeEnum feedbackType) {
    this.feedbackType = feedbackType;
  }


  public TrainingOptions fitIntercept(Boolean fitIntercept) {
    this.fitIntercept = fitIntercept;
    return this;
  }

  /**
   * Whether the model should include intercept during model training.
   * @return fitIntercept
   */
  @javax.annotation.Nullable
  public Boolean getFitIntercept() {
    return fitIntercept;
  }

  public void setFitIntercept(Boolean fitIntercept) {
    this.fitIntercept = fitIntercept;
  }


  public TrainingOptions hiddenUnits(List<String> hiddenUnits) {
    this.hiddenUnits = hiddenUnits;
    return this;
  }

  public TrainingOptions addHiddenUnitsItem(String hiddenUnitsItem) {
    if (this.hiddenUnits == null) {
      this.hiddenUnits = new ArrayList<>();
    }
    this.hiddenUnits.add(hiddenUnitsItem);
    return this;
  }

  /**
   * Hidden units for dnn models.
   * @return hiddenUnits
   */
  @javax.annotation.Nullable
  public List<String> getHiddenUnits() {
    return hiddenUnits;
  }

  public void setHiddenUnits(List<String> hiddenUnits) {
    this.hiddenUnits = hiddenUnits;
  }


  public TrainingOptions holidayRegion(HolidayRegionEnum holidayRegion) {
    this.holidayRegion = holidayRegion;
    return this;
  }

  /**
   * The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
   * @return holidayRegion
   */
  @javax.annotation.Nullable
  public HolidayRegionEnum getHolidayRegion() {
    return holidayRegion;
  }

  public void setHolidayRegion(HolidayRegionEnum holidayRegion) {
    this.holidayRegion = holidayRegion;
  }


  public TrainingOptions holidayRegions(List<HolidayRegionsEnum> holidayRegions) {
    this.holidayRegions = holidayRegions;
    return this;
  }

  public TrainingOptions addHolidayRegionsItem(HolidayRegionsEnum holidayRegionsItem) {
    if (this.holidayRegions == null) {
      this.holidayRegions = new ArrayList<>();
    }
    this.holidayRegions.add(holidayRegionsItem);
    return this;
  }

  /**
   * A list of geographical regions that are used for time series modeling.
   * @return holidayRegions
   */
  @javax.annotation.Nullable
  public List<HolidayRegionsEnum> getHolidayRegions() {
    return holidayRegions;
  }

  public void setHolidayRegions(List<HolidayRegionsEnum> holidayRegions) {
    this.holidayRegions = holidayRegions;
  }


  public TrainingOptions horizon(String horizon) {
    this.horizon = horizon;
    return this;
  }

  /**
   * The number of periods ahead that need to be forecasted.
   * @return horizon
   */
  @javax.annotation.Nullable
  public String getHorizon() {
    return horizon;
  }

  public void setHorizon(String horizon) {
    this.horizon = horizon;
  }


  public TrainingOptions hparamTuningObjectives(List<HparamTuningObjectivesEnum> hparamTuningObjectives) {
    this.hparamTuningObjectives = hparamTuningObjectives;
    return this;
  }

  public TrainingOptions addHparamTuningObjectivesItem(HparamTuningObjectivesEnum hparamTuningObjectivesItem) {
    if (this.hparamTuningObjectives == null) {
      this.hparamTuningObjectives = new ArrayList<>();
    }
    this.hparamTuningObjectives.add(hparamTuningObjectivesItem);
    return this;
  }

  /**
   * The target evaluation metrics to optimize the hyperparameters for.
   * @return hparamTuningObjectives
   */
  @javax.annotation.Nullable
  public List<HparamTuningObjectivesEnum> getHparamTuningObjectives() {
    return hparamTuningObjectives;
  }

  public void setHparamTuningObjectives(List<HparamTuningObjectivesEnum> hparamTuningObjectives) {
    this.hparamTuningObjectives = hparamTuningObjectives;
  }


  public TrainingOptions includeDrift(Boolean includeDrift) {
    this.includeDrift = includeDrift;
    return this;
  }

  /**
   * Include drift when fitting an ARIMA model.
   * @return includeDrift
   */
  @javax.annotation.Nullable
  public Boolean getIncludeDrift() {
    return includeDrift;
  }

  public void setIncludeDrift(Boolean includeDrift) {
    this.includeDrift = includeDrift;
  }


  public TrainingOptions initialLearnRate(Double initialLearnRate) {
    this.initialLearnRate = initialLearnRate;
    return this;
  }

  /**
   * Specifies the initial learning rate for the line search learn rate strategy.
   * @return initialLearnRate
   */
  @javax.annotation.Nullable
  public Double getInitialLearnRate() {
    return initialLearnRate;
  }

  public void setInitialLearnRate(Double initialLearnRate) {
    this.initialLearnRate = initialLearnRate;
  }


  public TrainingOptions inputLabelColumns(List<String> inputLabelColumns) {
    this.inputLabelColumns = inputLabelColumns;
    return this;
  }

  public TrainingOptions addInputLabelColumnsItem(String inputLabelColumnsItem) {
    if (this.inputLabelColumns == null) {
      this.inputLabelColumns = new ArrayList<>();
    }
    this.inputLabelColumns.add(inputLabelColumnsItem);
    return this;
  }

  /**
   * Name of input label columns in training data.
   * @return inputLabelColumns
   */
  @javax.annotation.Nullable
  public List<String> getInputLabelColumns() {
    return inputLabelColumns;
  }

  public void setInputLabelColumns(List<String> inputLabelColumns) {
    this.inputLabelColumns = inputLabelColumns;
  }


  public TrainingOptions instanceWeightColumn(String instanceWeightColumn) {
    this.instanceWeightColumn = instanceWeightColumn;
    return this;
  }

  /**
   * Name of the instance weight column for training data. This column isn&#39;t be used as a feature.
   * @return instanceWeightColumn
   */
  @javax.annotation.Nullable
  public String getInstanceWeightColumn() {
    return instanceWeightColumn;
  }

  public void setInstanceWeightColumn(String instanceWeightColumn) {
    this.instanceWeightColumn = instanceWeightColumn;
  }


  public TrainingOptions integratedGradientsNumSteps(String integratedGradientsNumSteps) {
    this.integratedGradientsNumSteps = integratedGradientsNumSteps;
    return this;
  }

  /**
   * Number of integral steps for the integrated gradients explain method.
   * @return integratedGradientsNumSteps
   */
  @javax.annotation.Nullable
  public String getIntegratedGradientsNumSteps() {
    return integratedGradientsNumSteps;
  }

  public void setIntegratedGradientsNumSteps(String integratedGradientsNumSteps) {
    this.integratedGradientsNumSteps = integratedGradientsNumSteps;
  }


  public TrainingOptions itemColumn(String itemColumn) {
    this.itemColumn = itemColumn;
    return this;
  }

  /**
   * Item column specified for matrix factorization models.
   * @return itemColumn
   */
  @javax.annotation.Nullable
  public String getItemColumn() {
    return itemColumn;
  }

  public void setItemColumn(String itemColumn) {
    this.itemColumn = itemColumn;
  }


  public TrainingOptions kmeansInitializationColumn(String kmeansInitializationColumn) {
    this.kmeansInitializationColumn = kmeansInitializationColumn;
    return this;
  }

  /**
   * The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
   * @return kmeansInitializationColumn
   */
  @javax.annotation.Nullable
  public String getKmeansInitializationColumn() {
    return kmeansInitializationColumn;
  }

  public void setKmeansInitializationColumn(String kmeansInitializationColumn) {
    this.kmeansInitializationColumn = kmeansInitializationColumn;
  }


  public TrainingOptions kmeansInitializationMethod(KmeansInitializationMethodEnum kmeansInitializationMethod) {
    this.kmeansInitializationMethod = kmeansInitializationMethod;
    return this;
  }

  /**
   * The method used to initialize the centroids for kmeans algorithm.
   * @return kmeansInitializationMethod
   */
  @javax.annotation.Nullable
  public KmeansInitializationMethodEnum getKmeansInitializationMethod() {
    return kmeansInitializationMethod;
  }

  public void setKmeansInitializationMethod(KmeansInitializationMethodEnum kmeansInitializationMethod) {
    this.kmeansInitializationMethod = kmeansInitializationMethod;
  }


  public TrainingOptions l1RegActivation(Double l1RegActivation) {
    this.l1RegActivation = l1RegActivation;
    return this;
  }

  /**
   * L1 regularization coefficient to activations.
   * @return l1RegActivation
   */
  @javax.annotation.Nullable
  public Double getL1RegActivation() {
    return l1RegActivation;
  }

  public void setL1RegActivation(Double l1RegActivation) {
    this.l1RegActivation = l1RegActivation;
  }


  public TrainingOptions l1Regularization(Double l1Regularization) {
    this.l1Regularization = l1Regularization;
    return this;
  }

  /**
   * L1 regularization coefficient.
   * @return l1Regularization
   */
  @javax.annotation.Nullable
  public Double getL1Regularization() {
    return l1Regularization;
  }

  public void setL1Regularization(Double l1Regularization) {
    this.l1Regularization = l1Regularization;
  }


  public TrainingOptions l2Regularization(Double l2Regularization) {
    this.l2Regularization = l2Regularization;
    return this;
  }

  /**
   * L2 regularization coefficient.
   * @return l2Regularization
   */
  @javax.annotation.Nullable
  public Double getL2Regularization() {
    return l2Regularization;
  }

  public void setL2Regularization(Double l2Regularization) {
    this.l2Regularization = l2Regularization;
  }


  public TrainingOptions labelClassWeights(Map<String, Double> labelClassWeights) {
    this.labelClassWeights = labelClassWeights;
    return this;
  }

  public TrainingOptions putLabelClassWeightsItem(String key, Double labelClassWeightsItem) {
    if (this.labelClassWeights == null) {
      this.labelClassWeights = new HashMap<>();
    }
    this.labelClassWeights.put(key, labelClassWeightsItem);
    return this;
  }

  /**
   * Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
   * @return labelClassWeights
   */
  @javax.annotation.Nullable
  public Map<String, Double> getLabelClassWeights() {
    return labelClassWeights;
  }

  public void setLabelClassWeights(Map<String, Double> labelClassWeights) {
    this.labelClassWeights = labelClassWeights;
  }


  public TrainingOptions learnRate(Double learnRate) {
    this.learnRate = learnRate;
    return this;
  }

  /**
   * Learning rate in training. Used only for iterative training algorithms.
   * @return learnRate
   */
  @javax.annotation.Nullable
  public Double getLearnRate() {
    return learnRate;
  }

  public void setLearnRate(Double learnRate) {
    this.learnRate = learnRate;
  }


  public TrainingOptions learnRateStrategy(LearnRateStrategyEnum learnRateStrategy) {
    this.learnRateStrategy = learnRateStrategy;
    return this;
  }

  /**
   * The strategy to determine learn rate for the current iteration.
   * @return learnRateStrategy
   */
  @javax.annotation.Nullable
  public LearnRateStrategyEnum getLearnRateStrategy() {
    return learnRateStrategy;
  }

  public void setLearnRateStrategy(LearnRateStrategyEnum learnRateStrategy) {
    this.learnRateStrategy = learnRateStrategy;
  }


  public TrainingOptions lossType(LossTypeEnum lossType) {
    this.lossType = lossType;
    return this;
  }

  /**
   * Type of loss function used during training run.
   * @return lossType
   */
  @javax.annotation.Nullable
  public LossTypeEnum getLossType() {
    return lossType;
  }

  public void setLossType(LossTypeEnum lossType) {
    this.lossType = lossType;
  }


  public TrainingOptions maxIterations(String maxIterations) {
    this.maxIterations = maxIterations;
    return this;
  }

  /**
   * The maximum number of iterations in training. Used only for iterative training algorithms.
   * @return maxIterations
   */
  @javax.annotation.Nullable
  public String getMaxIterations() {
    return maxIterations;
  }

  public void setMaxIterations(String maxIterations) {
    this.maxIterations = maxIterations;
  }


  public TrainingOptions maxParallelTrials(String maxParallelTrials) {
    this.maxParallelTrials = maxParallelTrials;
    return this;
  }

  /**
   * Maximum number of trials to run in parallel.
   * @return maxParallelTrials
   */
  @javax.annotation.Nullable
  public String getMaxParallelTrials() {
    return maxParallelTrials;
  }

  public void setMaxParallelTrials(String maxParallelTrials) {
    this.maxParallelTrials = maxParallelTrials;
  }


  public TrainingOptions maxTimeSeriesLength(String maxTimeSeriesLength) {
    this.maxTimeSeriesLength = maxTimeSeriesLength;
    return this;
  }

  /**
   * The maximum number of time points in a time series that can be used in modeling the trend component of the time series. Don&#39;t use this option with the &#x60;timeSeriesLengthFraction&#x60; or &#x60;minTimeSeriesLength&#x60; options.
   * @return maxTimeSeriesLength
   */
  @javax.annotation.Nullable
  public String getMaxTimeSeriesLength() {
    return maxTimeSeriesLength;
  }

  public void setMaxTimeSeriesLength(String maxTimeSeriesLength) {
    this.maxTimeSeriesLength = maxTimeSeriesLength;
  }


  public TrainingOptions maxTreeDepth(String maxTreeDepth) {
    this.maxTreeDepth = maxTreeDepth;
    return this;
  }

  /**
   * Maximum depth of a tree for boosted tree models.
   * @return maxTreeDepth
   */
  @javax.annotation.Nullable
  public String getMaxTreeDepth() {
    return maxTreeDepth;
  }

  public void setMaxTreeDepth(String maxTreeDepth) {
    this.maxTreeDepth = maxTreeDepth;
  }


  public TrainingOptions minRelativeProgress(Double minRelativeProgress) {
    this.minRelativeProgress = minRelativeProgress;
    return this;
  }

  /**
   * When early_stop is true, stops training when accuracy improvement is less than &#39;min_relative_progress&#39;. Used only for iterative training algorithms.
   * @return minRelativeProgress
   */
  @javax.annotation.Nullable
  public Double getMinRelativeProgress() {
    return minRelativeProgress;
  }

  public void setMinRelativeProgress(Double minRelativeProgress) {
    this.minRelativeProgress = minRelativeProgress;
  }


  public TrainingOptions minSplitLoss(Double minSplitLoss) {
    this.minSplitLoss = minSplitLoss;
    return this;
  }

  /**
   * Minimum split loss for boosted tree models.
   * @return minSplitLoss
   */
  @javax.annotation.Nullable
  public Double getMinSplitLoss() {
    return minSplitLoss;
  }

  public void setMinSplitLoss(Double minSplitLoss) {
    this.minSplitLoss = minSplitLoss;
  }


  public TrainingOptions minTimeSeriesLength(String minTimeSeriesLength) {
    this.minTimeSeriesLength = minTimeSeriesLength;
    return this;
  }

  /**
   * The minimum number of time points in a time series that are used in modeling the trend component of the time series. If you use this option you must also set the &#x60;timeSeriesLengthFraction&#x60; option. This training option ensures that enough time points are available when you use &#x60;timeSeriesLengthFraction&#x60; in trend modeling. This is particularly important when forecasting multiple time series in a single query using &#x60;timeSeriesIdColumn&#x60;. If the total number of time points is less than the &#x60;minTimeSeriesLength&#x60; value, then the query uses all available time points.
   * @return minTimeSeriesLength
   */
  @javax.annotation.Nullable
  public String getMinTimeSeriesLength() {
    return minTimeSeriesLength;
  }

  public void setMinTimeSeriesLength(String minTimeSeriesLength) {
    this.minTimeSeriesLength = minTimeSeriesLength;
  }


  public TrainingOptions minTreeChildWeight(String minTreeChildWeight) {
    this.minTreeChildWeight = minTreeChildWeight;
    return this;
  }

  /**
   * Minimum sum of instance weight needed in a child for boosted tree models.
   * @return minTreeChildWeight
   */
  @javax.annotation.Nullable
  public String getMinTreeChildWeight() {
    return minTreeChildWeight;
  }

  public void setMinTreeChildWeight(String minTreeChildWeight) {
    this.minTreeChildWeight = minTreeChildWeight;
  }


  public TrainingOptions modelRegistry(ModelRegistryEnum modelRegistry) {
    this.modelRegistry = modelRegistry;
    return this;
  }

  /**
   * The model registry.
   * @return modelRegistry
   */
  @javax.annotation.Nullable
  public ModelRegistryEnum getModelRegistry() {
    return modelRegistry;
  }

  public void setModelRegistry(ModelRegistryEnum modelRegistry) {
    this.modelRegistry = modelRegistry;
  }


  public TrainingOptions modelUri(String modelUri) {
    this.modelUri = modelUri;
    return this;
  }

  /**
   * Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
   * @return modelUri
   */
  @javax.annotation.Nullable
  public String getModelUri() {
    return modelUri;
  }

  public void setModelUri(String modelUri) {
    this.modelUri = modelUri;
  }


  public TrainingOptions nonSeasonalOrder(ArimaOrder nonSeasonalOrder) {
    this.nonSeasonalOrder = nonSeasonalOrder;
    return this;
  }

  /**
   * Get nonSeasonalOrder
   * @return nonSeasonalOrder
   */
  @javax.annotation.Nullable
  public ArimaOrder getNonSeasonalOrder() {
    return nonSeasonalOrder;
  }

  public void setNonSeasonalOrder(ArimaOrder nonSeasonalOrder) {
    this.nonSeasonalOrder = nonSeasonalOrder;
  }


  public TrainingOptions numClusters(String numClusters) {
    this.numClusters = numClusters;
    return this;
  }

  /**
   * Number of clusters for clustering models.
   * @return numClusters
   */
  @javax.annotation.Nullable
  public String getNumClusters() {
    return numClusters;
  }

  public void setNumClusters(String numClusters) {
    this.numClusters = numClusters;
  }


  public TrainingOptions numFactors(String numFactors) {
    this.numFactors = numFactors;
    return this;
  }

  /**
   * Num factors specified for matrix factorization models.
   * @return numFactors
   */
  @javax.annotation.Nullable
  public String getNumFactors() {
    return numFactors;
  }

  public void setNumFactors(String numFactors) {
    this.numFactors = numFactors;
  }


  public TrainingOptions numParallelTree(String numParallelTree) {
    this.numParallelTree = numParallelTree;
    return this;
  }

  /**
   * Number of parallel trees constructed during each iteration for boosted tree models.
   * @return numParallelTree
   */
  @javax.annotation.Nullable
  public String getNumParallelTree() {
    return numParallelTree;
  }

  public void setNumParallelTree(String numParallelTree) {
    this.numParallelTree = numParallelTree;
  }


  public TrainingOptions numPrincipalComponents(String numPrincipalComponents) {
    this.numPrincipalComponents = numPrincipalComponents;
    return this;
  }

  /**
   * Number of principal components to keep in the PCA model. Must be &lt;&#x3D; the number of features.
   * @return numPrincipalComponents
   */
  @javax.annotation.Nullable
  public String getNumPrincipalComponents() {
    return numPrincipalComponents;
  }

  public void setNumPrincipalComponents(String numPrincipalComponents) {
    this.numPrincipalComponents = numPrincipalComponents;
  }


  public TrainingOptions numTrials(String numTrials) {
    this.numTrials = numTrials;
    return this;
  }

  /**
   * Number of trials to run this hyperparameter tuning job.
   * @return numTrials
   */
  @javax.annotation.Nullable
  public String getNumTrials() {
    return numTrials;
  }

  public void setNumTrials(String numTrials) {
    this.numTrials = numTrials;
  }


  public TrainingOptions optimizationStrategy(OptimizationStrategyEnum optimizationStrategy) {
    this.optimizationStrategy = optimizationStrategy;
    return this;
  }

  /**
   * Optimization strategy for training linear regression models.
   * @return optimizationStrategy
   */
  @javax.annotation.Nullable
  public OptimizationStrategyEnum getOptimizationStrategy() {
    return optimizationStrategy;
  }

  public void setOptimizationStrategy(OptimizationStrategyEnum optimizationStrategy) {
    this.optimizationStrategy = optimizationStrategy;
  }


  public TrainingOptions optimizer(String optimizer) {
    this.optimizer = optimizer;
    return this;
  }

  /**
   * Optimizer used for training the neural nets.
   * @return optimizer
   */
  @javax.annotation.Nullable
  public String getOptimizer() {
    return optimizer;
  }

  public void setOptimizer(String optimizer) {
    this.optimizer = optimizer;
  }


  public TrainingOptions pcaExplainedVarianceRatio(Double pcaExplainedVarianceRatio) {
    this.pcaExplainedVarianceRatio = pcaExplainedVarianceRatio;
    return this;
  }

  /**
   * The minimum ratio of cumulative explained variance that needs to be given by the PCA model.
   * @return pcaExplainedVarianceRatio
   */
  @javax.annotation.Nullable
  public Double getPcaExplainedVarianceRatio() {
    return pcaExplainedVarianceRatio;
  }

  public void setPcaExplainedVarianceRatio(Double pcaExplainedVarianceRatio) {
    this.pcaExplainedVarianceRatio = pcaExplainedVarianceRatio;
  }


  public TrainingOptions pcaSolver(PcaSolverEnum pcaSolver) {
    this.pcaSolver = pcaSolver;
    return this;
  }

  /**
   * The solver for PCA.
   * @return pcaSolver
   */
  @javax.annotation.Nullable
  public PcaSolverEnum getPcaSolver() {
    return pcaSolver;
  }

  public void setPcaSolver(PcaSolverEnum pcaSolver) {
    this.pcaSolver = pcaSolver;
  }


  public TrainingOptions sampledShapleyNumPaths(String sampledShapleyNumPaths) {
    this.sampledShapleyNumPaths = sampledShapleyNumPaths;
    return this;
  }

  /**
   * Number of paths for the sampled Shapley explain method.
   * @return sampledShapleyNumPaths
   */
  @javax.annotation.Nullable
  public String getSampledShapleyNumPaths() {
    return sampledShapleyNumPaths;
  }

  public void setSampledShapleyNumPaths(String sampledShapleyNumPaths) {
    this.sampledShapleyNumPaths = sampledShapleyNumPaths;
  }


  public TrainingOptions scaleFeatures(Boolean scaleFeatures) {
    this.scaleFeatures = scaleFeatures;
    return this;
  }

  /**
   * If true, scale the feature values by dividing the feature standard deviation. Currently only apply to PCA.
   * @return scaleFeatures
   */
  @javax.annotation.Nullable
  public Boolean getScaleFeatures() {
    return scaleFeatures;
  }

  public void setScaleFeatures(Boolean scaleFeatures) {
    this.scaleFeatures = scaleFeatures;
  }


  public TrainingOptions standardizeFeatures(Boolean standardizeFeatures) {
    this.standardizeFeatures = standardizeFeatures;
    return this;
  }

  /**
   * Whether to standardize numerical features. Default to true.
   * @return standardizeFeatures
   */
  @javax.annotation.Nullable
  public Boolean getStandardizeFeatures() {
    return standardizeFeatures;
  }

  public void setStandardizeFeatures(Boolean standardizeFeatures) {
    this.standardizeFeatures = standardizeFeatures;
  }


  public TrainingOptions subsample(Double subsample) {
    this.subsample = subsample;
    return this;
  }

  /**
   * Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
   * @return subsample
   */
  @javax.annotation.Nullable
  public Double getSubsample() {
    return subsample;
  }

  public void setSubsample(Double subsample) {
    this.subsample = subsample;
  }


  public TrainingOptions tfVersion(String tfVersion) {
    this.tfVersion = tfVersion;
    return this;
  }

  /**
   * Based on the selected TF version, the corresponding docker image is used to train external models.
   * @return tfVersion
   */
  @javax.annotation.Nullable
  public String getTfVersion() {
    return tfVersion;
  }

  public void setTfVersion(String tfVersion) {
    this.tfVersion = tfVersion;
  }


  public TrainingOptions timeSeriesDataColumn(String timeSeriesDataColumn) {
    this.timeSeriesDataColumn = timeSeriesDataColumn;
    return this;
  }

  /**
   * Column to be designated as time series data for ARIMA model.
   * @return timeSeriesDataColumn
   */
  @javax.annotation.Nullable
  public String getTimeSeriesDataColumn() {
    return timeSeriesDataColumn;
  }

  public void setTimeSeriesDataColumn(String timeSeriesDataColumn) {
    this.timeSeriesDataColumn = timeSeriesDataColumn;
  }


  public TrainingOptions timeSeriesIdColumn(String timeSeriesIdColumn) {
    this.timeSeriesIdColumn = timeSeriesIdColumn;
    return this;
  }

  /**
   * The time series id column that was used during ARIMA model training.
   * @return timeSeriesIdColumn
   */
  @javax.annotation.Nullable
  public String getTimeSeriesIdColumn() {
    return timeSeriesIdColumn;
  }

  public void setTimeSeriesIdColumn(String timeSeriesIdColumn) {
    this.timeSeriesIdColumn = timeSeriesIdColumn;
  }


  public TrainingOptions timeSeriesIdColumns(List<String> timeSeriesIdColumns) {
    this.timeSeriesIdColumns = timeSeriesIdColumns;
    return this;
  }

  public TrainingOptions addTimeSeriesIdColumnsItem(String timeSeriesIdColumnsItem) {
    if (this.timeSeriesIdColumns == null) {
      this.timeSeriesIdColumns = new ArrayList<>();
    }
    this.timeSeriesIdColumns.add(timeSeriesIdColumnsItem);
    return this;
  }

  /**
   * The time series id columns that were used during ARIMA model training.
   * @return timeSeriesIdColumns
   */
  @javax.annotation.Nullable
  public List<String> getTimeSeriesIdColumns() {
    return timeSeriesIdColumns;
  }

  public void setTimeSeriesIdColumns(List<String> timeSeriesIdColumns) {
    this.timeSeriesIdColumns = timeSeriesIdColumns;
  }


  public TrainingOptions timeSeriesLengthFraction(Double timeSeriesLengthFraction) {
    this.timeSeriesLengthFraction = timeSeriesLengthFraction;
    return this;
  }

  /**
   * The fraction of the interpolated length of the time series that&#39;s used to model the time series trend component. All of the time points of the time series are used to model the non-trend component. This training option accelerates modeling training without sacrificing much forecasting accuracy. You can use this option with &#x60;minTimeSeriesLength&#x60; but not with &#x60;maxTimeSeriesLength&#x60;.
   * @return timeSeriesLengthFraction
   */
  @javax.annotation.Nullable
  public Double getTimeSeriesLengthFraction() {
    return timeSeriesLengthFraction;
  }

  public void setTimeSeriesLengthFraction(Double timeSeriesLengthFraction) {
    this.timeSeriesLengthFraction = timeSeriesLengthFraction;
  }


  public TrainingOptions timeSeriesTimestampColumn(String timeSeriesTimestampColumn) {
    this.timeSeriesTimestampColumn = timeSeriesTimestampColumn;
    return this;
  }

  /**
   * Column to be designated as time series timestamp for ARIMA model.
   * @return timeSeriesTimestampColumn
   */
  @javax.annotation.Nullable
  public String getTimeSeriesTimestampColumn() {
    return timeSeriesTimestampColumn;
  }

  public void setTimeSeriesTimestampColumn(String timeSeriesTimestampColumn) {
    this.timeSeriesTimestampColumn = timeSeriesTimestampColumn;
  }


  public TrainingOptions treeMethod(TreeMethodEnum treeMethod) {
    this.treeMethod = treeMethod;
    return this;
  }

  /**
   * Tree construction algorithm for boosted tree models.
   * @return treeMethod
   */
  @javax.annotation.Nullable
  public TreeMethodEnum getTreeMethod() {
    return treeMethod;
  }

  public void setTreeMethod(TreeMethodEnum treeMethod) {
    this.treeMethod = treeMethod;
  }


  public TrainingOptions trendSmoothingWindowSize(String trendSmoothingWindowSize) {
    this.trendSmoothingWindowSize = trendSmoothingWindowSize;
    return this;
  }

  /**
   * Smoothing window size for the trend component. When a positive value is specified, a center moving average smoothing is applied on the history trend. When the smoothing window is out of the boundary at the beginning or the end of the trend, the first element or the last element is padded to fill the smoothing window before the average is applied.
   * @return trendSmoothingWindowSize
   */
  @javax.annotation.Nullable
  public String getTrendSmoothingWindowSize() {
    return trendSmoothingWindowSize;
  }

  public void setTrendSmoothingWindowSize(String trendSmoothingWindowSize) {
    this.trendSmoothingWindowSize = trendSmoothingWindowSize;
  }


  public TrainingOptions userColumn(String userColumn) {
    this.userColumn = userColumn;
    return this;
  }

  /**
   * User column specified for matrix factorization models.
   * @return userColumn
   */
  @javax.annotation.Nullable
  public String getUserColumn() {
    return userColumn;
  }

  public void setUserColumn(String userColumn) {
    this.userColumn = userColumn;
  }


  public TrainingOptions vertexAiModelVersionAliases(List<String> vertexAiModelVersionAliases) {
    this.vertexAiModelVersionAliases = vertexAiModelVersionAliases;
    return this;
  }

  public TrainingOptions addVertexAiModelVersionAliasesItem(String vertexAiModelVersionAliasesItem) {
    if (this.vertexAiModelVersionAliases == null) {
      this.vertexAiModelVersionAliases = new ArrayList<>();
    }
    this.vertexAiModelVersionAliases.add(vertexAiModelVersionAliasesItem);
    return this;
  }

  /**
   * The version aliases to apply in Vertex AI model registry. Always overwrite if the version aliases exists in a existing model.
   * @return vertexAiModelVersionAliases
   */
  @javax.annotation.Nullable
  public List<String> getVertexAiModelVersionAliases() {
    return vertexAiModelVersionAliases;
  }

  public void setVertexAiModelVersionAliases(List<String> vertexAiModelVersionAliases) {
    this.vertexAiModelVersionAliases = vertexAiModelVersionAliases;
  }


  public TrainingOptions walsAlpha(Double walsAlpha) {
    this.walsAlpha = walsAlpha;
    return this;
  }

  /**
   * Hyperparameter for matrix factoration when implicit feedback type is specified.
   * @return walsAlpha
   */
  @javax.annotation.Nullable
  public Double getWalsAlpha() {
    return walsAlpha;
  }

  public void setWalsAlpha(Double walsAlpha) {
    this.walsAlpha = walsAlpha;
  }


  public TrainingOptions warmStart(Boolean warmStart) {
    this.warmStart = warmStart;
    return this;
  }

  /**
   * Whether to train a model from the last checkpoint.
   * @return warmStart
   */
  @javax.annotation.Nullable
  public Boolean getWarmStart() {
    return warmStart;
  }

  public void setWarmStart(Boolean warmStart) {
    this.warmStart = warmStart;
  }


  public TrainingOptions xgboostVersion(String xgboostVersion) {
    this.xgboostVersion = xgboostVersion;
    return this;
  }

  /**
   * User-selected XGBoost versions for training of XGBoost models.
   * @return xgboostVersion
   */
  @javax.annotation.Nullable
  public String getXgboostVersion() {
    return xgboostVersion;
  }

  public void setXgboostVersion(String xgboostVersion) {
    this.xgboostVersion = xgboostVersion;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TrainingOptions trainingOptions = (TrainingOptions) o;
    return Objects.equals(this.activationFn, trainingOptions.activationFn) &&
        Objects.equals(this.adjustStepChanges, trainingOptions.adjustStepChanges) &&
        Objects.equals(this.approxGlobalFeatureContrib, trainingOptions.approxGlobalFeatureContrib) &&
        Objects.equals(this.autoArima, trainingOptions.autoArima) &&
        Objects.equals(this.autoArimaMaxOrder, trainingOptions.autoArimaMaxOrder) &&
        Objects.equals(this.autoArimaMinOrder, trainingOptions.autoArimaMinOrder) &&
        Objects.equals(this.autoClassWeights, trainingOptions.autoClassWeights) &&
        Objects.equals(this.batchSize, trainingOptions.batchSize) &&
        Objects.equals(this.boosterType, trainingOptions.boosterType) &&
        Objects.equals(this.budgetHours, trainingOptions.budgetHours) &&
        Objects.equals(this.calculatePValues, trainingOptions.calculatePValues) &&
        Objects.equals(this.categoryEncodingMethod, trainingOptions.categoryEncodingMethod) &&
        Objects.equals(this.cleanSpikesAndDips, trainingOptions.cleanSpikesAndDips) &&
        Objects.equals(this.colorSpace, trainingOptions.colorSpace) &&
        Objects.equals(this.colsampleBylevel, trainingOptions.colsampleBylevel) &&
        Objects.equals(this.colsampleBynode, trainingOptions.colsampleBynode) &&
        Objects.equals(this.colsampleBytree, trainingOptions.colsampleBytree) &&
        Objects.equals(this.dartNormalizeType, trainingOptions.dartNormalizeType) &&
        Objects.equals(this.dataFrequency, trainingOptions.dataFrequency) &&
        Objects.equals(this.dataSplitColumn, trainingOptions.dataSplitColumn) &&
        Objects.equals(this.dataSplitEvalFraction, trainingOptions.dataSplitEvalFraction) &&
        Objects.equals(this.dataSplitMethod, trainingOptions.dataSplitMethod) &&
        Objects.equals(this.decomposeTimeSeries, trainingOptions.decomposeTimeSeries) &&
        Objects.equals(this.distanceType, trainingOptions.distanceType) &&
        Objects.equals(this.dropout, trainingOptions.dropout) &&
        Objects.equals(this.earlyStop, trainingOptions.earlyStop) &&
        Objects.equals(this.enableGlobalExplain, trainingOptions.enableGlobalExplain) &&
        Objects.equals(this.feedbackType, trainingOptions.feedbackType) &&
        Objects.equals(this.fitIntercept, trainingOptions.fitIntercept) &&
        Objects.equals(this.hiddenUnits, trainingOptions.hiddenUnits) &&
        Objects.equals(this.holidayRegion, trainingOptions.holidayRegion) &&
        Objects.equals(this.holidayRegions, trainingOptions.holidayRegions) &&
        Objects.equals(this.horizon, trainingOptions.horizon) &&
        Objects.equals(this.hparamTuningObjectives, trainingOptions.hparamTuningObjectives) &&
        Objects.equals(this.includeDrift, trainingOptions.includeDrift) &&
        Objects.equals(this.initialLearnRate, trainingOptions.initialLearnRate) &&
        Objects.equals(this.inputLabelColumns, trainingOptions.inputLabelColumns) &&
        Objects.equals(this.instanceWeightColumn, trainingOptions.instanceWeightColumn) &&
        Objects.equals(this.integratedGradientsNumSteps, trainingOptions.integratedGradientsNumSteps) &&
        Objects.equals(this.itemColumn, trainingOptions.itemColumn) &&
        Objects.equals(this.kmeansInitializationColumn, trainingOptions.kmeansInitializationColumn) &&
        Objects.equals(this.kmeansInitializationMethod, trainingOptions.kmeansInitializationMethod) &&
        Objects.equals(this.l1RegActivation, trainingOptions.l1RegActivation) &&
        Objects.equals(this.l1Regularization, trainingOptions.l1Regularization) &&
        Objects.equals(this.l2Regularization, trainingOptions.l2Regularization) &&
        Objects.equals(this.labelClassWeights, trainingOptions.labelClassWeights) &&
        Objects.equals(this.learnRate, trainingOptions.learnRate) &&
        Objects.equals(this.learnRateStrategy, trainingOptions.learnRateStrategy) &&
        Objects.equals(this.lossType, trainingOptions.lossType) &&
        Objects.equals(this.maxIterations, trainingOptions.maxIterations) &&
        Objects.equals(this.maxParallelTrials, trainingOptions.maxParallelTrials) &&
        Objects.equals(this.maxTimeSeriesLength, trainingOptions.maxTimeSeriesLength) &&
        Objects.equals(this.maxTreeDepth, trainingOptions.maxTreeDepth) &&
        Objects.equals(this.minRelativeProgress, trainingOptions.minRelativeProgress) &&
        Objects.equals(this.minSplitLoss, trainingOptions.minSplitLoss) &&
        Objects.equals(this.minTimeSeriesLength, trainingOptions.minTimeSeriesLength) &&
        Objects.equals(this.minTreeChildWeight, trainingOptions.minTreeChildWeight) &&
        Objects.equals(this.modelRegistry, trainingOptions.modelRegistry) &&
        Objects.equals(this.modelUri, trainingOptions.modelUri) &&
        Objects.equals(this.nonSeasonalOrder, trainingOptions.nonSeasonalOrder) &&
        Objects.equals(this.numClusters, trainingOptions.numClusters) &&
        Objects.equals(this.numFactors, trainingOptions.numFactors) &&
        Objects.equals(this.numParallelTree, trainingOptions.numParallelTree) &&
        Objects.equals(this.numPrincipalComponents, trainingOptions.numPrincipalComponents) &&
        Objects.equals(this.numTrials, trainingOptions.numTrials) &&
        Objects.equals(this.optimizationStrategy, trainingOptions.optimizationStrategy) &&
        Objects.equals(this.optimizer, trainingOptions.optimizer) &&
        Objects.equals(this.pcaExplainedVarianceRatio, trainingOptions.pcaExplainedVarianceRatio) &&
        Objects.equals(this.pcaSolver, trainingOptions.pcaSolver) &&
        Objects.equals(this.sampledShapleyNumPaths, trainingOptions.sampledShapleyNumPaths) &&
        Objects.equals(this.scaleFeatures, trainingOptions.scaleFeatures) &&
        Objects.equals(this.standardizeFeatures, trainingOptions.standardizeFeatures) &&
        Objects.equals(this.subsample, trainingOptions.subsample) &&
        Objects.equals(this.tfVersion, trainingOptions.tfVersion) &&
        Objects.equals(this.timeSeriesDataColumn, trainingOptions.timeSeriesDataColumn) &&
        Objects.equals(this.timeSeriesIdColumn, trainingOptions.timeSeriesIdColumn) &&
        Objects.equals(this.timeSeriesIdColumns, trainingOptions.timeSeriesIdColumns) &&
        Objects.equals(this.timeSeriesLengthFraction, trainingOptions.timeSeriesLengthFraction) &&
        Objects.equals(this.timeSeriesTimestampColumn, trainingOptions.timeSeriesTimestampColumn) &&
        Objects.equals(this.treeMethod, trainingOptions.treeMethod) &&
        Objects.equals(this.trendSmoothingWindowSize, trainingOptions.trendSmoothingWindowSize) &&
        Objects.equals(this.userColumn, trainingOptions.userColumn) &&
        Objects.equals(this.vertexAiModelVersionAliases, trainingOptions.vertexAiModelVersionAliases) &&
        Objects.equals(this.walsAlpha, trainingOptions.walsAlpha) &&
        Objects.equals(this.warmStart, trainingOptions.warmStart) &&
        Objects.equals(this.xgboostVersion, trainingOptions.xgboostVersion);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationFn, adjustStepChanges, approxGlobalFeatureContrib, autoArima, autoArimaMaxOrder, autoArimaMinOrder, autoClassWeights, batchSize, boosterType, budgetHours, calculatePValues, categoryEncodingMethod, cleanSpikesAndDips, colorSpace, colsampleBylevel, colsampleBynode, colsampleBytree, dartNormalizeType, dataFrequency, dataSplitColumn, dataSplitEvalFraction, dataSplitMethod, decomposeTimeSeries, distanceType, dropout, earlyStop, enableGlobalExplain, feedbackType, fitIntercept, hiddenUnits, holidayRegion, holidayRegions, horizon, hparamTuningObjectives, includeDrift, initialLearnRate, inputLabelColumns, instanceWeightColumn, integratedGradientsNumSteps, itemColumn, kmeansInitializationColumn, kmeansInitializationMethod, l1RegActivation, l1Regularization, l2Regularization, labelClassWeights, learnRate, learnRateStrategy, lossType, maxIterations, maxParallelTrials, maxTimeSeriesLength, maxTreeDepth, minRelativeProgress, minSplitLoss, minTimeSeriesLength, minTreeChildWeight, modelRegistry, modelUri, nonSeasonalOrder, numClusters, numFactors, numParallelTree, numPrincipalComponents, numTrials, optimizationStrategy, optimizer, pcaExplainedVarianceRatio, pcaSolver, sampledShapleyNumPaths, scaleFeatures, standardizeFeatures, subsample, tfVersion, timeSeriesDataColumn, timeSeriesIdColumn, timeSeriesIdColumns, timeSeriesLengthFraction, timeSeriesTimestampColumn, treeMethod, trendSmoothingWindowSize, userColumn, vertexAiModelVersionAliases, walsAlpha, warmStart, xgboostVersion);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TrainingOptions {\n");
    sb.append("    activationFn: ").append(toIndentedString(activationFn)).append("\n");
    sb.append("    adjustStepChanges: ").append(toIndentedString(adjustStepChanges)).append("\n");
    sb.append("    approxGlobalFeatureContrib: ").append(toIndentedString(approxGlobalFeatureContrib)).append("\n");
    sb.append("    autoArima: ").append(toIndentedString(autoArima)).append("\n");
    sb.append("    autoArimaMaxOrder: ").append(toIndentedString(autoArimaMaxOrder)).append("\n");
    sb.append("    autoArimaMinOrder: ").append(toIndentedString(autoArimaMinOrder)).append("\n");
    sb.append("    autoClassWeights: ").append(toIndentedString(autoClassWeights)).append("\n");
    sb.append("    batchSize: ").append(toIndentedString(batchSize)).append("\n");
    sb.append("    boosterType: ").append(toIndentedString(boosterType)).append("\n");
    sb.append("    budgetHours: ").append(toIndentedString(budgetHours)).append("\n");
    sb.append("    calculatePValues: ").append(toIndentedString(calculatePValues)).append("\n");
    sb.append("    categoryEncodingMethod: ").append(toIndentedString(categoryEncodingMethod)).append("\n");
    sb.append("    cleanSpikesAndDips: ").append(toIndentedString(cleanSpikesAndDips)).append("\n");
    sb.append("    colorSpace: ").append(toIndentedString(colorSpace)).append("\n");
    sb.append("    colsampleBylevel: ").append(toIndentedString(colsampleBylevel)).append("\n");
    sb.append("    colsampleBynode: ").append(toIndentedString(colsampleBynode)).append("\n");
    sb.append("    colsampleBytree: ").append(toIndentedString(colsampleBytree)).append("\n");
    sb.append("    dartNormalizeType: ").append(toIndentedString(dartNormalizeType)).append("\n");
    sb.append("    dataFrequency: ").append(toIndentedString(dataFrequency)).append("\n");
    sb.append("    dataSplitColumn: ").append(toIndentedString(dataSplitColumn)).append("\n");
    sb.append("    dataSplitEvalFraction: ").append(toIndentedString(dataSplitEvalFraction)).append("\n");
    sb.append("    dataSplitMethod: ").append(toIndentedString(dataSplitMethod)).append("\n");
    sb.append("    decomposeTimeSeries: ").append(toIndentedString(decomposeTimeSeries)).append("\n");
    sb.append("    distanceType: ").append(toIndentedString(distanceType)).append("\n");
    sb.append("    dropout: ").append(toIndentedString(dropout)).append("\n");
    sb.append("    earlyStop: ").append(toIndentedString(earlyStop)).append("\n");
    sb.append("    enableGlobalExplain: ").append(toIndentedString(enableGlobalExplain)).append("\n");
    sb.append("    feedbackType: ").append(toIndentedString(feedbackType)).append("\n");
    sb.append("    fitIntercept: ").append(toIndentedString(fitIntercept)).append("\n");
    sb.append("    hiddenUnits: ").append(toIndentedString(hiddenUnits)).append("\n");
    sb.append("    holidayRegion: ").append(toIndentedString(holidayRegion)).append("\n");
    sb.append("    holidayRegions: ").append(toIndentedString(holidayRegions)).append("\n");
    sb.append("    horizon: ").append(toIndentedString(horizon)).append("\n");
    sb.append("    hparamTuningObjectives: ").append(toIndentedString(hparamTuningObjectives)).append("\n");
    sb.append("    includeDrift: ").append(toIndentedString(includeDrift)).append("\n");
    sb.append("    initialLearnRate: ").append(toIndentedString(initialLearnRate)).append("\n");
    sb.append("    inputLabelColumns: ").append(toIndentedString(inputLabelColumns)).append("\n");
    sb.append("    instanceWeightColumn: ").append(toIndentedString(instanceWeightColumn)).append("\n");
    sb.append("    integratedGradientsNumSteps: ").append(toIndentedString(integratedGradientsNumSteps)).append("\n");
    sb.append("    itemColumn: ").append(toIndentedString(itemColumn)).append("\n");
    sb.append("    kmeansInitializationColumn: ").append(toIndentedString(kmeansInitializationColumn)).append("\n");
    sb.append("    kmeansInitializationMethod: ").append(toIndentedString(kmeansInitializationMethod)).append("\n");
    sb.append("    l1RegActivation: ").append(toIndentedString(l1RegActivation)).append("\n");
    sb.append("    l1Regularization: ").append(toIndentedString(l1Regularization)).append("\n");
    sb.append("    l2Regularization: ").append(toIndentedString(l2Regularization)).append("\n");
    sb.append("    labelClassWeights: ").append(toIndentedString(labelClassWeights)).append("\n");
    sb.append("    learnRate: ").append(toIndentedString(learnRate)).append("\n");
    sb.append("    learnRateStrategy: ").append(toIndentedString(learnRateStrategy)).append("\n");
    sb.append("    lossType: ").append(toIndentedString(lossType)).append("\n");
    sb.append("    maxIterations: ").append(toIndentedString(maxIterations)).append("\n");
    sb.append("    maxParallelTrials: ").append(toIndentedString(maxParallelTrials)).append("\n");
    sb.append("    maxTimeSeriesLength: ").append(toIndentedString(maxTimeSeriesLength)).append("\n");
    sb.append("    maxTreeDepth: ").append(toIndentedString(maxTreeDepth)).append("\n");
    sb.append("    minRelativeProgress: ").append(toIndentedString(minRelativeProgress)).append("\n");
    sb.append("    minSplitLoss: ").append(toIndentedString(minSplitLoss)).append("\n");
    sb.append("    minTimeSeriesLength: ").append(toIndentedString(minTimeSeriesLength)).append("\n");
    sb.append("    minTreeChildWeight: ").append(toIndentedString(minTreeChildWeight)).append("\n");
    sb.append("    modelRegistry: ").append(toIndentedString(modelRegistry)).append("\n");
    sb.append("    modelUri: ").append(toIndentedString(modelUri)).append("\n");
    sb.append("    nonSeasonalOrder: ").append(toIndentedString(nonSeasonalOrder)).append("\n");
    sb.append("    numClusters: ").append(toIndentedString(numClusters)).append("\n");
    sb.append("    numFactors: ").append(toIndentedString(numFactors)).append("\n");
    sb.append("    numParallelTree: ").append(toIndentedString(numParallelTree)).append("\n");
    sb.append("    numPrincipalComponents: ").append(toIndentedString(numPrincipalComponents)).append("\n");
    sb.append("    numTrials: ").append(toIndentedString(numTrials)).append("\n");
    sb.append("    optimizationStrategy: ").append(toIndentedString(optimizationStrategy)).append("\n");
    sb.append("    optimizer: ").append(toIndentedString(optimizer)).append("\n");
    sb.append("    pcaExplainedVarianceRatio: ").append(toIndentedString(pcaExplainedVarianceRatio)).append("\n");
    sb.append("    pcaSolver: ").append(toIndentedString(pcaSolver)).append("\n");
    sb.append("    sampledShapleyNumPaths: ").append(toIndentedString(sampledShapleyNumPaths)).append("\n");
    sb.append("    scaleFeatures: ").append(toIndentedString(scaleFeatures)).append("\n");
    sb.append("    standardizeFeatures: ").append(toIndentedString(standardizeFeatures)).append("\n");
    sb.append("    subsample: ").append(toIndentedString(subsample)).append("\n");
    sb.append("    tfVersion: ").append(toIndentedString(tfVersion)).append("\n");
    sb.append("    timeSeriesDataColumn: ").append(toIndentedString(timeSeriesDataColumn)).append("\n");
    sb.append("    timeSeriesIdColumn: ").append(toIndentedString(timeSeriesIdColumn)).append("\n");
    sb.append("    timeSeriesIdColumns: ").append(toIndentedString(timeSeriesIdColumns)).append("\n");
    sb.append("    timeSeriesLengthFraction: ").append(toIndentedString(timeSeriesLengthFraction)).append("\n");
    sb.append("    timeSeriesTimestampColumn: ").append(toIndentedString(timeSeriesTimestampColumn)).append("\n");
    sb.append("    treeMethod: ").append(toIndentedString(treeMethod)).append("\n");
    sb.append("    trendSmoothingWindowSize: ").append(toIndentedString(trendSmoothingWindowSize)).append("\n");
    sb.append("    userColumn: ").append(toIndentedString(userColumn)).append("\n");
    sb.append("    vertexAiModelVersionAliases: ").append(toIndentedString(vertexAiModelVersionAliases)).append("\n");
    sb.append("    walsAlpha: ").append(toIndentedString(walsAlpha)).append("\n");
    sb.append("    warmStart: ").append(toIndentedString(warmStart)).append("\n");
    sb.append("    xgboostVersion: ").append(toIndentedString(xgboostVersion)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationFn");
    openapiFields.add("adjustStepChanges");
    openapiFields.add("approxGlobalFeatureContrib");
    openapiFields.add("autoArima");
    openapiFields.add("autoArimaMaxOrder");
    openapiFields.add("autoArimaMinOrder");
    openapiFields.add("autoClassWeights");
    openapiFields.add("batchSize");
    openapiFields.add("boosterType");
    openapiFields.add("budgetHours");
    openapiFields.add("calculatePValues");
    openapiFields.add("categoryEncodingMethod");
    openapiFields.add("cleanSpikesAndDips");
    openapiFields.add("colorSpace");
    openapiFields.add("colsampleBylevel");
    openapiFields.add("colsampleBynode");
    openapiFields.add("colsampleBytree");
    openapiFields.add("dartNormalizeType");
    openapiFields.add("dataFrequency");
    openapiFields.add("dataSplitColumn");
    openapiFields.add("dataSplitEvalFraction");
    openapiFields.add("dataSplitMethod");
    openapiFields.add("decomposeTimeSeries");
    openapiFields.add("distanceType");
    openapiFields.add("dropout");
    openapiFields.add("earlyStop");
    openapiFields.add("enableGlobalExplain");
    openapiFields.add("feedbackType");
    openapiFields.add("fitIntercept");
    openapiFields.add("hiddenUnits");
    openapiFields.add("holidayRegion");
    openapiFields.add("holidayRegions");
    openapiFields.add("horizon");
    openapiFields.add("hparamTuningObjectives");
    openapiFields.add("includeDrift");
    openapiFields.add("initialLearnRate");
    openapiFields.add("inputLabelColumns");
    openapiFields.add("instanceWeightColumn");
    openapiFields.add("integratedGradientsNumSteps");
    openapiFields.add("itemColumn");
    openapiFields.add("kmeansInitializationColumn");
    openapiFields.add("kmeansInitializationMethod");
    openapiFields.add("l1RegActivation");
    openapiFields.add("l1Regularization");
    openapiFields.add("l2Regularization");
    openapiFields.add("labelClassWeights");
    openapiFields.add("learnRate");
    openapiFields.add("learnRateStrategy");
    openapiFields.add("lossType");
    openapiFields.add("maxIterations");
    openapiFields.add("maxParallelTrials");
    openapiFields.add("maxTimeSeriesLength");
    openapiFields.add("maxTreeDepth");
    openapiFields.add("minRelativeProgress");
    openapiFields.add("minSplitLoss");
    openapiFields.add("minTimeSeriesLength");
    openapiFields.add("minTreeChildWeight");
    openapiFields.add("modelRegistry");
    openapiFields.add("modelUri");
    openapiFields.add("nonSeasonalOrder");
    openapiFields.add("numClusters");
    openapiFields.add("numFactors");
    openapiFields.add("numParallelTree");
    openapiFields.add("numPrincipalComponents");
    openapiFields.add("numTrials");
    openapiFields.add("optimizationStrategy");
    openapiFields.add("optimizer");
    openapiFields.add("pcaExplainedVarianceRatio");
    openapiFields.add("pcaSolver");
    openapiFields.add("sampledShapleyNumPaths");
    openapiFields.add("scaleFeatures");
    openapiFields.add("standardizeFeatures");
    openapiFields.add("subsample");
    openapiFields.add("tfVersion");
    openapiFields.add("timeSeriesDataColumn");
    openapiFields.add("timeSeriesIdColumn");
    openapiFields.add("timeSeriesIdColumns");
    openapiFields.add("timeSeriesLengthFraction");
    openapiFields.add("timeSeriesTimestampColumn");
    openapiFields.add("treeMethod");
    openapiFields.add("trendSmoothingWindowSize");
    openapiFields.add("userColumn");
    openapiFields.add("vertexAiModelVersionAliases");
    openapiFields.add("walsAlpha");
    openapiFields.add("warmStart");
    openapiFields.add("xgboostVersion");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TrainingOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TrainingOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TrainingOptions is not found in the empty JSON string", TrainingOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TrainingOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TrainingOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("activationFn") != null && !jsonObj.get("activationFn").isJsonNull()) && !jsonObj.get("activationFn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activationFn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activationFn").toString()));
      }
      if ((jsonObj.get("autoArimaMaxOrder") != null && !jsonObj.get("autoArimaMaxOrder").isJsonNull()) && !jsonObj.get("autoArimaMaxOrder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoArimaMaxOrder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoArimaMaxOrder").toString()));
      }
      if ((jsonObj.get("autoArimaMinOrder") != null && !jsonObj.get("autoArimaMinOrder").isJsonNull()) && !jsonObj.get("autoArimaMinOrder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoArimaMinOrder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoArimaMinOrder").toString()));
      }
      if ((jsonObj.get("batchSize") != null && !jsonObj.get("batchSize").isJsonNull()) && !jsonObj.get("batchSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batchSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batchSize").toString()));
      }
      if ((jsonObj.get("boosterType") != null && !jsonObj.get("boosterType").isJsonNull()) && !jsonObj.get("boosterType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `boosterType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("boosterType").toString()));
      }
      // validate the optional field `boosterType`
      if (jsonObj.get("boosterType") != null && !jsonObj.get("boosterType").isJsonNull()) {
        BoosterTypeEnum.validateJsonElement(jsonObj.get("boosterType"));
      }
      if ((jsonObj.get("categoryEncodingMethod") != null && !jsonObj.get("categoryEncodingMethod").isJsonNull()) && !jsonObj.get("categoryEncodingMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `categoryEncodingMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("categoryEncodingMethod").toString()));
      }
      // validate the optional field `categoryEncodingMethod`
      if (jsonObj.get("categoryEncodingMethod") != null && !jsonObj.get("categoryEncodingMethod").isJsonNull()) {
        CategoryEncodingMethodEnum.validateJsonElement(jsonObj.get("categoryEncodingMethod"));
      }
      if ((jsonObj.get("colorSpace") != null && !jsonObj.get("colorSpace").isJsonNull()) && !jsonObj.get("colorSpace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `colorSpace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("colorSpace").toString()));
      }
      // validate the optional field `colorSpace`
      if (jsonObj.get("colorSpace") != null && !jsonObj.get("colorSpace").isJsonNull()) {
        ColorSpaceEnum.validateJsonElement(jsonObj.get("colorSpace"));
      }
      if ((jsonObj.get("dartNormalizeType") != null && !jsonObj.get("dartNormalizeType").isJsonNull()) && !jsonObj.get("dartNormalizeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dartNormalizeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dartNormalizeType").toString()));
      }
      // validate the optional field `dartNormalizeType`
      if (jsonObj.get("dartNormalizeType") != null && !jsonObj.get("dartNormalizeType").isJsonNull()) {
        DartNormalizeTypeEnum.validateJsonElement(jsonObj.get("dartNormalizeType"));
      }
      if ((jsonObj.get("dataFrequency") != null && !jsonObj.get("dataFrequency").isJsonNull()) && !jsonObj.get("dataFrequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataFrequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataFrequency").toString()));
      }
      // validate the optional field `dataFrequency`
      if (jsonObj.get("dataFrequency") != null && !jsonObj.get("dataFrequency").isJsonNull()) {
        DataFrequencyEnum.validateJsonElement(jsonObj.get("dataFrequency"));
      }
      if ((jsonObj.get("dataSplitColumn") != null && !jsonObj.get("dataSplitColumn").isJsonNull()) && !jsonObj.get("dataSplitColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataSplitColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataSplitColumn").toString()));
      }
      if ((jsonObj.get("dataSplitMethod") != null && !jsonObj.get("dataSplitMethod").isJsonNull()) && !jsonObj.get("dataSplitMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataSplitMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataSplitMethod").toString()));
      }
      // validate the optional field `dataSplitMethod`
      if (jsonObj.get("dataSplitMethod") != null && !jsonObj.get("dataSplitMethod").isJsonNull()) {
        DataSplitMethodEnum.validateJsonElement(jsonObj.get("dataSplitMethod"));
      }
      if ((jsonObj.get("distanceType") != null && !jsonObj.get("distanceType").isJsonNull()) && !jsonObj.get("distanceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `distanceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("distanceType").toString()));
      }
      // validate the optional field `distanceType`
      if (jsonObj.get("distanceType") != null && !jsonObj.get("distanceType").isJsonNull()) {
        DistanceTypeEnum.validateJsonElement(jsonObj.get("distanceType"));
      }
      if ((jsonObj.get("feedbackType") != null && !jsonObj.get("feedbackType").isJsonNull()) && !jsonObj.get("feedbackType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `feedbackType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("feedbackType").toString()));
      }
      // validate the optional field `feedbackType`
      if (jsonObj.get("feedbackType") != null && !jsonObj.get("feedbackType").isJsonNull()) {
        FeedbackTypeEnum.validateJsonElement(jsonObj.get("feedbackType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("hiddenUnits") != null && !jsonObj.get("hiddenUnits").isJsonNull() && !jsonObj.get("hiddenUnits").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `hiddenUnits` to be an array in the JSON string but got `%s`", jsonObj.get("hiddenUnits").toString()));
      }
      if ((jsonObj.get("holidayRegion") != null && !jsonObj.get("holidayRegion").isJsonNull()) && !jsonObj.get("holidayRegion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holidayRegion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holidayRegion").toString()));
      }
      // validate the optional field `holidayRegion`
      if (jsonObj.get("holidayRegion") != null && !jsonObj.get("holidayRegion").isJsonNull()) {
        HolidayRegionEnum.validateJsonElement(jsonObj.get("holidayRegion"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("holidayRegions") != null && !jsonObj.get("holidayRegions").isJsonNull() && !jsonObj.get("holidayRegions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `holidayRegions` to be an array in the JSON string but got `%s`", jsonObj.get("holidayRegions").toString()));
      }
      if ((jsonObj.get("horizon") != null && !jsonObj.get("horizon").isJsonNull()) && !jsonObj.get("horizon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `horizon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("horizon").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("hparamTuningObjectives") != null && !jsonObj.get("hparamTuningObjectives").isJsonNull() && !jsonObj.get("hparamTuningObjectives").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `hparamTuningObjectives` to be an array in the JSON string but got `%s`", jsonObj.get("hparamTuningObjectives").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("inputLabelColumns") != null && !jsonObj.get("inputLabelColumns").isJsonNull() && !jsonObj.get("inputLabelColumns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `inputLabelColumns` to be an array in the JSON string but got `%s`", jsonObj.get("inputLabelColumns").toString()));
      }
      if ((jsonObj.get("instanceWeightColumn") != null && !jsonObj.get("instanceWeightColumn").isJsonNull()) && !jsonObj.get("instanceWeightColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceWeightColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instanceWeightColumn").toString()));
      }
      if ((jsonObj.get("integratedGradientsNumSteps") != null && !jsonObj.get("integratedGradientsNumSteps").isJsonNull()) && !jsonObj.get("integratedGradientsNumSteps").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `integratedGradientsNumSteps` to be a primitive type in the JSON string but got `%s`", jsonObj.get("integratedGradientsNumSteps").toString()));
      }
      if ((jsonObj.get("itemColumn") != null && !jsonObj.get("itemColumn").isJsonNull()) && !jsonObj.get("itemColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("itemColumn").toString()));
      }
      if ((jsonObj.get("kmeansInitializationColumn") != null && !jsonObj.get("kmeansInitializationColumn").isJsonNull()) && !jsonObj.get("kmeansInitializationColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmeansInitializationColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmeansInitializationColumn").toString()));
      }
      if ((jsonObj.get("kmeansInitializationMethod") != null && !jsonObj.get("kmeansInitializationMethod").isJsonNull()) && !jsonObj.get("kmeansInitializationMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmeansInitializationMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmeansInitializationMethod").toString()));
      }
      // validate the optional field `kmeansInitializationMethod`
      if (jsonObj.get("kmeansInitializationMethod") != null && !jsonObj.get("kmeansInitializationMethod").isJsonNull()) {
        KmeansInitializationMethodEnum.validateJsonElement(jsonObj.get("kmeansInitializationMethod"));
      }
      if ((jsonObj.get("learnRateStrategy") != null && !jsonObj.get("learnRateStrategy").isJsonNull()) && !jsonObj.get("learnRateStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `learnRateStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("learnRateStrategy").toString()));
      }
      // validate the optional field `learnRateStrategy`
      if (jsonObj.get("learnRateStrategy") != null && !jsonObj.get("learnRateStrategy").isJsonNull()) {
        LearnRateStrategyEnum.validateJsonElement(jsonObj.get("learnRateStrategy"));
      }
      if ((jsonObj.get("lossType") != null && !jsonObj.get("lossType").isJsonNull()) && !jsonObj.get("lossType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lossType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lossType").toString()));
      }
      // validate the optional field `lossType`
      if (jsonObj.get("lossType") != null && !jsonObj.get("lossType").isJsonNull()) {
        LossTypeEnum.validateJsonElement(jsonObj.get("lossType"));
      }
      if ((jsonObj.get("maxIterations") != null && !jsonObj.get("maxIterations").isJsonNull()) && !jsonObj.get("maxIterations").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxIterations` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxIterations").toString()));
      }
      if ((jsonObj.get("maxParallelTrials") != null && !jsonObj.get("maxParallelTrials").isJsonNull()) && !jsonObj.get("maxParallelTrials").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxParallelTrials` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxParallelTrials").toString()));
      }
      if ((jsonObj.get("maxTimeSeriesLength") != null && !jsonObj.get("maxTimeSeriesLength").isJsonNull()) && !jsonObj.get("maxTimeSeriesLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxTimeSeriesLength` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxTimeSeriesLength").toString()));
      }
      if ((jsonObj.get("maxTreeDepth") != null && !jsonObj.get("maxTreeDepth").isJsonNull()) && !jsonObj.get("maxTreeDepth").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxTreeDepth` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxTreeDepth").toString()));
      }
      if ((jsonObj.get("minTimeSeriesLength") != null && !jsonObj.get("minTimeSeriesLength").isJsonNull()) && !jsonObj.get("minTimeSeriesLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minTimeSeriesLength` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minTimeSeriesLength").toString()));
      }
      if ((jsonObj.get("minTreeChildWeight") != null && !jsonObj.get("minTreeChildWeight").isJsonNull()) && !jsonObj.get("minTreeChildWeight").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minTreeChildWeight` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minTreeChildWeight").toString()));
      }
      if ((jsonObj.get("modelRegistry") != null && !jsonObj.get("modelRegistry").isJsonNull()) && !jsonObj.get("modelRegistry").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modelRegistry` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modelRegistry").toString()));
      }
      // validate the optional field `modelRegistry`
      if (jsonObj.get("modelRegistry") != null && !jsonObj.get("modelRegistry").isJsonNull()) {
        ModelRegistryEnum.validateJsonElement(jsonObj.get("modelRegistry"));
      }
      if ((jsonObj.get("modelUri") != null && !jsonObj.get("modelUri").isJsonNull()) && !jsonObj.get("modelUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modelUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modelUri").toString()));
      }
      // validate the optional field `nonSeasonalOrder`
      if (jsonObj.get("nonSeasonalOrder") != null && !jsonObj.get("nonSeasonalOrder").isJsonNull()) {
        ArimaOrder.validateJsonElement(jsonObj.get("nonSeasonalOrder"));
      }
      if ((jsonObj.get("numClusters") != null && !jsonObj.get("numClusters").isJsonNull()) && !jsonObj.get("numClusters").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numClusters` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numClusters").toString()));
      }
      if ((jsonObj.get("numFactors") != null && !jsonObj.get("numFactors").isJsonNull()) && !jsonObj.get("numFactors").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numFactors` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numFactors").toString()));
      }
      if ((jsonObj.get("numParallelTree") != null && !jsonObj.get("numParallelTree").isJsonNull()) && !jsonObj.get("numParallelTree").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numParallelTree` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numParallelTree").toString()));
      }
      if ((jsonObj.get("numPrincipalComponents") != null && !jsonObj.get("numPrincipalComponents").isJsonNull()) && !jsonObj.get("numPrincipalComponents").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numPrincipalComponents` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numPrincipalComponents").toString()));
      }
      if ((jsonObj.get("numTrials") != null && !jsonObj.get("numTrials").isJsonNull()) && !jsonObj.get("numTrials").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numTrials` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numTrials").toString()));
      }
      if ((jsonObj.get("optimizationStrategy") != null && !jsonObj.get("optimizationStrategy").isJsonNull()) && !jsonObj.get("optimizationStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizationStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizationStrategy").toString()));
      }
      // validate the optional field `optimizationStrategy`
      if (jsonObj.get("optimizationStrategy") != null && !jsonObj.get("optimizationStrategy").isJsonNull()) {
        OptimizationStrategyEnum.validateJsonElement(jsonObj.get("optimizationStrategy"));
      }
      if ((jsonObj.get("optimizer") != null && !jsonObj.get("optimizer").isJsonNull()) && !jsonObj.get("optimizer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizer").toString()));
      }
      if ((jsonObj.get("pcaSolver") != null && !jsonObj.get("pcaSolver").isJsonNull()) && !jsonObj.get("pcaSolver").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pcaSolver` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pcaSolver").toString()));
      }
      // validate the optional field `pcaSolver`
      if (jsonObj.get("pcaSolver") != null && !jsonObj.get("pcaSolver").isJsonNull()) {
        PcaSolverEnum.validateJsonElement(jsonObj.get("pcaSolver"));
      }
      if ((jsonObj.get("sampledShapleyNumPaths") != null && !jsonObj.get("sampledShapleyNumPaths").isJsonNull()) && !jsonObj.get("sampledShapleyNumPaths").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sampledShapleyNumPaths` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sampledShapleyNumPaths").toString()));
      }
      if ((jsonObj.get("tfVersion") != null && !jsonObj.get("tfVersion").isJsonNull()) && !jsonObj.get("tfVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tfVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tfVersion").toString()));
      }
      if ((jsonObj.get("timeSeriesDataColumn") != null && !jsonObj.get("timeSeriesDataColumn").isJsonNull()) && !jsonObj.get("timeSeriesDataColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesDataColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeSeriesDataColumn").toString()));
      }
      if ((jsonObj.get("timeSeriesIdColumn") != null && !jsonObj.get("timeSeriesIdColumn").isJsonNull()) && !jsonObj.get("timeSeriesIdColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesIdColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeSeriesIdColumn").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("timeSeriesIdColumns") != null && !jsonObj.get("timeSeriesIdColumns").isJsonNull() && !jsonObj.get("timeSeriesIdColumns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesIdColumns` to be an array in the JSON string but got `%s`", jsonObj.get("timeSeriesIdColumns").toString()));
      }
      if ((jsonObj.get("timeSeriesTimestampColumn") != null && !jsonObj.get("timeSeriesTimestampColumn").isJsonNull()) && !jsonObj.get("timeSeriesTimestampColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeSeriesTimestampColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeSeriesTimestampColumn").toString()));
      }
      if ((jsonObj.get("treeMethod") != null && !jsonObj.get("treeMethod").isJsonNull()) && !jsonObj.get("treeMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `treeMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("treeMethod").toString()));
      }
      // validate the optional field `treeMethod`
      if (jsonObj.get("treeMethod") != null && !jsonObj.get("treeMethod").isJsonNull()) {
        TreeMethodEnum.validateJsonElement(jsonObj.get("treeMethod"));
      }
      if ((jsonObj.get("trendSmoothingWindowSize") != null && !jsonObj.get("trendSmoothingWindowSize").isJsonNull()) && !jsonObj.get("trendSmoothingWindowSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trendSmoothingWindowSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trendSmoothingWindowSize").toString()));
      }
      if ((jsonObj.get("userColumn") != null && !jsonObj.get("userColumn").isJsonNull()) && !jsonObj.get("userColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userColumn").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("vertexAiModelVersionAliases") != null && !jsonObj.get("vertexAiModelVersionAliases").isJsonNull() && !jsonObj.get("vertexAiModelVersionAliases").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `vertexAiModelVersionAliases` to be an array in the JSON string but got `%s`", jsonObj.get("vertexAiModelVersionAliases").toString()));
      }
      if ((jsonObj.get("xgboostVersion") != null && !jsonObj.get("xgboostVersion").isJsonNull()) && !jsonObj.get("xgboostVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `xgboostVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("xgboostVersion").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TrainingOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TrainingOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TrainingOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TrainingOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<TrainingOptions>() {
           @Override
           public void write(JsonWriter out, TrainingOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TrainingOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TrainingOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TrainingOptions
   * @throws IOException if the JSON string is invalid with respect to TrainingOptions
   */
  public static TrainingOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TrainingOptions.class);
  }

  /**
   * Convert an instance of TrainingOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

