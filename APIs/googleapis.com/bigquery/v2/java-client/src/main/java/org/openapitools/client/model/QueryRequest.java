/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ConnectionProperty;
import org.openapitools.client.model.DataFormatOptions;
import org.openapitools.client.model.DatasetReference;
import org.openapitools.client.model.QueryParameter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the format of the jobs.query request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class QueryRequest {
  public static final String SERIALIZED_NAME_CONNECTION_PROPERTIES = "connectionProperties";
  @SerializedName(SERIALIZED_NAME_CONNECTION_PROPERTIES)
  private List<ConnectionProperty> connectionProperties = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTINUOUS = "continuous";
  @SerializedName(SERIALIZED_NAME_CONTINUOUS)
  private Boolean continuous;

  public static final String SERIALIZED_NAME_CREATE_SESSION = "createSession";
  @SerializedName(SERIALIZED_NAME_CREATE_SESSION)
  private Boolean createSession;

  public static final String SERIALIZED_NAME_DEFAULT_DATASET = "defaultDataset";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DATASET)
  private DatasetReference defaultDataset;

  public static final String SERIALIZED_NAME_DRY_RUN = "dryRun";
  @SerializedName(SERIALIZED_NAME_DRY_RUN)
  private Boolean dryRun;

  public static final String SERIALIZED_NAME_FORMAT_OPTIONS = "formatOptions";
  @SerializedName(SERIALIZED_NAME_FORMAT_OPTIONS)
  private DataFormatOptions formatOptions;

  /**
   * Optional. If not set, jobs are always required. If set, the query request will follow the behavior described JobCreationMode. This feature is not yet available. Jobs will always be created.
   */
  @JsonAdapter(JobCreationModeEnum.Adapter.class)
  public enum JobCreationModeEnum {
    MODE_UNSPECIFIED("JOB_CREATION_MODE_UNSPECIFIED"),
    
    REQUIRED("JOB_CREATION_REQUIRED"),
    
    OPTIONAL("JOB_CREATION_OPTIONAL");

    private String value;

    JobCreationModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static JobCreationModeEnum fromValue(String value) {
      for (JobCreationModeEnum b : JobCreationModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<JobCreationModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobCreationModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public JobCreationModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return JobCreationModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      JobCreationModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_JOB_CREATION_MODE = "jobCreationMode";
  @SerializedName(SERIALIZED_NAME_JOB_CREATION_MODE)
  private JobCreationModeEnum jobCreationMode;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "bigquery#queryRequest";

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_MAX_RESULTS = "maxResults";
  @SerializedName(SERIALIZED_NAME_MAX_RESULTS)
  private Integer maxResults;

  public static final String SERIALIZED_NAME_MAXIMUM_BYTES_BILLED = "maximumBytesBilled";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_BYTES_BILLED)
  private String maximumBytesBilled;

  public static final String SERIALIZED_NAME_PARAMETER_MODE = "parameterMode";
  @SerializedName(SERIALIZED_NAME_PARAMETER_MODE)
  private String parameterMode;

  public static final String SERIALIZED_NAME_PRESERVE_NULLS = "preserveNulls";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_PRESERVE_NULLS)
  private Boolean preserveNulls;

  public static final String SERIALIZED_NAME_QUERY = "query";
  @SerializedName(SERIALIZED_NAME_QUERY)
  private String query;

  public static final String SERIALIZED_NAME_QUERY_PARAMETERS = "queryParameters";
  @SerializedName(SERIALIZED_NAME_QUERY_PARAMETERS)
  private List<QueryParameter> queryParameters = new ArrayList<>();

  public static final String SERIALIZED_NAME_REQUEST_ID = "requestId";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_TIMEOUT_MS = "timeoutMs";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_MS)
  private Integer timeoutMs;

  public static final String SERIALIZED_NAME_USE_LEGACY_SQL = "useLegacySql";
  @SerializedName(SERIALIZED_NAME_USE_LEGACY_SQL)
  private Boolean useLegacySql = true;

  public static final String SERIALIZED_NAME_USE_QUERY_CACHE = "useQueryCache";
  @SerializedName(SERIALIZED_NAME_USE_QUERY_CACHE)
  private Boolean useQueryCache = true;

  public QueryRequest() {
  }

  public QueryRequest connectionProperties(List<ConnectionProperty> connectionProperties) {
    this.connectionProperties = connectionProperties;
    return this;
  }

  public QueryRequest addConnectionPropertiesItem(ConnectionProperty connectionPropertiesItem) {
    if (this.connectionProperties == null) {
      this.connectionProperties = new ArrayList<>();
    }
    this.connectionProperties.add(connectionPropertiesItem);
    return this;
  }

  /**
   * Optional. Connection properties which can modify the query behavior.
   * @return connectionProperties
   */
  @javax.annotation.Nullable
  public List<ConnectionProperty> getConnectionProperties() {
    return connectionProperties;
  }

  public void setConnectionProperties(List<ConnectionProperty> connectionProperties) {
    this.connectionProperties = connectionProperties;
  }


  public QueryRequest continuous(Boolean continuous) {
    this.continuous = continuous;
    return this;
  }

  /**
   * [Optional] Specifies whether the query should be executed as a continuous query. The default value is false.
   * @return continuous
   */
  @javax.annotation.Nullable
  public Boolean getContinuous() {
    return continuous;
  }

  public void setContinuous(Boolean continuous) {
    this.continuous = continuous;
  }


  public QueryRequest createSession(Boolean createSession) {
    this.createSession = createSession;
    return this;
  }

  /**
   * Optional. If true, creates a new session using a randomly generated session_id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode. The session location will be set to QueryRequest.location if it is present, otherwise it&#39;s set to the default location based on existing routing logic.
   * @return createSession
   */
  @javax.annotation.Nullable
  public Boolean getCreateSession() {
    return createSession;
  }

  public void setCreateSession(Boolean createSession) {
    this.createSession = createSession;
  }


  public QueryRequest defaultDataset(DatasetReference defaultDataset) {
    this.defaultDataset = defaultDataset;
    return this;
  }

  /**
   * Get defaultDataset
   * @return defaultDataset
   */
  @javax.annotation.Nullable
  public DatasetReference getDefaultDataset() {
    return defaultDataset;
  }

  public void setDefaultDataset(DatasetReference defaultDataset) {
    this.defaultDataset = defaultDataset;
  }


  public QueryRequest dryRun(Boolean dryRun) {
    this.dryRun = dryRun;
    return this;
  }

  /**
   * Optional. If set to true, BigQuery doesn&#39;t run the job. Instead, if the query is valid, BigQuery returns statistics about the job such as how many bytes would be processed. If the query is invalid, an error returns. The default value is false.
   * @return dryRun
   */
  @javax.annotation.Nullable
  public Boolean getDryRun() {
    return dryRun;
  }

  public void setDryRun(Boolean dryRun) {
    this.dryRun = dryRun;
  }


  public QueryRequest formatOptions(DataFormatOptions formatOptions) {
    this.formatOptions = formatOptions;
    return this;
  }

  /**
   * Get formatOptions
   * @return formatOptions
   */
  @javax.annotation.Nullable
  public DataFormatOptions getFormatOptions() {
    return formatOptions;
  }

  public void setFormatOptions(DataFormatOptions formatOptions) {
    this.formatOptions = formatOptions;
  }


  public QueryRequest jobCreationMode(JobCreationModeEnum jobCreationMode) {
    this.jobCreationMode = jobCreationMode;
    return this;
  }

  /**
   * Optional. If not set, jobs are always required. If set, the query request will follow the behavior described JobCreationMode. This feature is not yet available. Jobs will always be created.
   * @return jobCreationMode
   */
  @javax.annotation.Nullable
  public JobCreationModeEnum getJobCreationMode() {
    return jobCreationMode;
  }

  public void setJobCreationMode(JobCreationModeEnum jobCreationMode) {
    this.jobCreationMode = jobCreationMode;
  }


  public QueryRequest kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * The resource type of the request.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public QueryRequest labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public QueryRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. The labels associated with this query. Labels can be used to organize and group query jobs. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label keys must start with a letter and each label in the list must have a different key.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public QueryRequest location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The geographic location where the job should run. See details at https://cloud.google.com/bigquery/docs/locations#specifying_your_location.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public QueryRequest maxResults(Integer maxResults) {
    this.maxResults = maxResults;
    return this;
  }

  /**
   * Optional. The maximum number of rows of data to return per page of results. Setting this flag to a small value such as 1000 and then paging through results might improve reliability when the query result set is large. In addition to this limit, responses are also limited to 10 MB. By default, there is no maximum row count, and only the byte limit applies.
   * @return maxResults
   */
  @javax.annotation.Nullable
  public Integer getMaxResults() {
    return maxResults;
  }

  public void setMaxResults(Integer maxResults) {
    this.maxResults = maxResults;
  }


  public QueryRequest maximumBytesBilled(String maximumBytesBilled) {
    this.maximumBytesBilled = maximumBytesBilled;
    return this;
  }

  /**
   * Optional. Limits the bytes billed for this query. Queries with bytes billed above this limit will fail (without incurring a charge). If unspecified, the project default is used.
   * @return maximumBytesBilled
   */
  @javax.annotation.Nullable
  public String getMaximumBytesBilled() {
    return maximumBytesBilled;
  }

  public void setMaximumBytesBilled(String maximumBytesBilled) {
    this.maximumBytesBilled = maximumBytesBilled;
  }


  public QueryRequest parameterMode(String parameterMode) {
    this.parameterMode = parameterMode;
    return this;
  }

  /**
   * GoogleSQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
   * @return parameterMode
   */
  @javax.annotation.Nullable
  public String getParameterMode() {
    return parameterMode;
  }

  public void setParameterMode(String parameterMode) {
    this.parameterMode = parameterMode;
  }


  @Deprecated
  public QueryRequest preserveNulls(Boolean preserveNulls) {
    this.preserveNulls = preserveNulls;
    return this;
  }

  /**
   * This property is deprecated.
   * @return preserveNulls
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getPreserveNulls() {
    return preserveNulls;
  }

  @Deprecated
  public void setPreserveNulls(Boolean preserveNulls) {
    this.preserveNulls = preserveNulls;
  }


  public QueryRequest query(String query) {
    this.query = query;
    return this;
  }

  /**
   * Required. A query string to execute, using Google Standard SQL or legacy SQL syntax. Example: \&quot;SELECT COUNT(f1) FROM myProjectId.myDatasetId.myTableId\&quot;.
   * @return query
   */
  @javax.annotation.Nullable
  public String getQuery() {
    return query;
  }

  public void setQuery(String query) {
    this.query = query;
  }


  public QueryRequest queryParameters(List<QueryParameter> queryParameters) {
    this.queryParameters = queryParameters;
    return this;
  }

  public QueryRequest addQueryParametersItem(QueryParameter queryParametersItem) {
    if (this.queryParameters == null) {
      this.queryParameters = new ArrayList<>();
    }
    this.queryParameters.add(queryParametersItem);
    return this;
  }

  /**
   * Query parameters for GoogleSQL queries.
   * @return queryParameters
   */
  @javax.annotation.Nullable
  public List<QueryParameter> getQueryParameters() {
    return queryParameters;
  }

  public void setQueryParameters(List<QueryParameter> queryParameters) {
    this.queryParameters = queryParameters;
  }


  public QueryRequest requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

  /**
   * Optional. A unique user provided identifier to ensure idempotent behavior for queries. Note that this is different from the job_id. It has the following properties: 1. It is case-sensitive, limited to up to 36 ASCII characters. A UUID is recommended. 2. Read only queries can ignore this token since they are nullipotent by definition. 3. For the purposes of idempotency ensured by the request_id, a request is considered duplicate of another only if they have the same request_id and are actually duplicates. When determining whether a request is a duplicate of another request, all parameters in the request that may affect the result are considered. For example, query, connection_properties, query_parameters, use_legacy_sql are parameters that affect the result and are considered when determining whether a request is a duplicate, but properties like timeout_ms don&#39;t affect the result and are thus not considered. Dry run query requests are never considered duplicate of another request. 4. When a duplicate mutating query request is detected, it returns: a. the results of the mutation if it completes successfully within the timeout. b. the running operation if it is still in progress at the end of the timeout. 5. Its lifetime is limited to 15 minutes. In other words, if two requests are sent with the same request_id, but more than 15 minutes apart, idempotency is not guaranteed.
   * @return requestId
   */
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public QueryRequest timeoutMs(Integer timeoutMs) {
    this.timeoutMs = timeoutMs;
    return this;
  }

  /**
   * Optional. Optional: Specifies the maximum amount of time, in milliseconds, that the client is willing to wait for the query to complete. By default, this limit is 10 seconds (10,000 milliseconds). If the query is complete, the jobComplete field in the response is true. If the query has not yet completed, jobComplete is false. You can request a longer timeout period in the timeoutMs field. However, the call is not guaranteed to wait for the specified timeout; it typically returns after around 200 seconds (200,000 milliseconds), even if the query is not complete. If jobComplete is false, you can continue to wait for the query to complete by calling the getQueryResults method until the jobComplete field in the getQueryResults response is true.
   * @return timeoutMs
   */
  @javax.annotation.Nullable
  public Integer getTimeoutMs() {
    return timeoutMs;
  }

  public void setTimeoutMs(Integer timeoutMs) {
    this.timeoutMs = timeoutMs;
  }


  public QueryRequest useLegacySql(Boolean useLegacySql) {
    this.useLegacySql = useLegacySql;
    return this;
  }

  /**
   * Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s GoogleSQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
   * @return useLegacySql
   */
  @javax.annotation.Nullable
  public Boolean getUseLegacySql() {
    return useLegacySql;
  }

  public void setUseLegacySql(Boolean useLegacySql) {
    this.useLegacySql = useLegacySql;
  }


  public QueryRequest useQueryCache(Boolean useQueryCache) {
    this.useQueryCache = useQueryCache;
    return this;
  }

  /**
   * Optional. Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. The default value is true.
   * @return useQueryCache
   */
  @javax.annotation.Nullable
  public Boolean getUseQueryCache() {
    return useQueryCache;
  }

  public void setUseQueryCache(Boolean useQueryCache) {
    this.useQueryCache = useQueryCache;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QueryRequest queryRequest = (QueryRequest) o;
    return Objects.equals(this.connectionProperties, queryRequest.connectionProperties) &&
        Objects.equals(this.continuous, queryRequest.continuous) &&
        Objects.equals(this.createSession, queryRequest.createSession) &&
        Objects.equals(this.defaultDataset, queryRequest.defaultDataset) &&
        Objects.equals(this.dryRun, queryRequest.dryRun) &&
        Objects.equals(this.formatOptions, queryRequest.formatOptions) &&
        Objects.equals(this.jobCreationMode, queryRequest.jobCreationMode) &&
        Objects.equals(this.kind, queryRequest.kind) &&
        Objects.equals(this.labels, queryRequest.labels) &&
        Objects.equals(this.location, queryRequest.location) &&
        Objects.equals(this.maxResults, queryRequest.maxResults) &&
        Objects.equals(this.maximumBytesBilled, queryRequest.maximumBytesBilled) &&
        Objects.equals(this.parameterMode, queryRequest.parameterMode) &&
        Objects.equals(this.preserveNulls, queryRequest.preserveNulls) &&
        Objects.equals(this.query, queryRequest.query) &&
        Objects.equals(this.queryParameters, queryRequest.queryParameters) &&
        Objects.equals(this.requestId, queryRequest.requestId) &&
        Objects.equals(this.timeoutMs, queryRequest.timeoutMs) &&
        Objects.equals(this.useLegacySql, queryRequest.useLegacySql) &&
        Objects.equals(this.useQueryCache, queryRequest.useQueryCache);
  }

  @Override
  public int hashCode() {
    return Objects.hash(connectionProperties, continuous, createSession, defaultDataset, dryRun, formatOptions, jobCreationMode, kind, labels, location, maxResults, maximumBytesBilled, parameterMode, preserveNulls, query, queryParameters, requestId, timeoutMs, useLegacySql, useQueryCache);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QueryRequest {\n");
    sb.append("    connectionProperties: ").append(toIndentedString(connectionProperties)).append("\n");
    sb.append("    continuous: ").append(toIndentedString(continuous)).append("\n");
    sb.append("    createSession: ").append(toIndentedString(createSession)).append("\n");
    sb.append("    defaultDataset: ").append(toIndentedString(defaultDataset)).append("\n");
    sb.append("    dryRun: ").append(toIndentedString(dryRun)).append("\n");
    sb.append("    formatOptions: ").append(toIndentedString(formatOptions)).append("\n");
    sb.append("    jobCreationMode: ").append(toIndentedString(jobCreationMode)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    maxResults: ").append(toIndentedString(maxResults)).append("\n");
    sb.append("    maximumBytesBilled: ").append(toIndentedString(maximumBytesBilled)).append("\n");
    sb.append("    parameterMode: ").append(toIndentedString(parameterMode)).append("\n");
    sb.append("    preserveNulls: ").append(toIndentedString(preserveNulls)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    queryParameters: ").append(toIndentedString(queryParameters)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    timeoutMs: ").append(toIndentedString(timeoutMs)).append("\n");
    sb.append("    useLegacySql: ").append(toIndentedString(useLegacySql)).append("\n");
    sb.append("    useQueryCache: ").append(toIndentedString(useQueryCache)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("connectionProperties");
    openapiFields.add("continuous");
    openapiFields.add("createSession");
    openapiFields.add("defaultDataset");
    openapiFields.add("dryRun");
    openapiFields.add("formatOptions");
    openapiFields.add("jobCreationMode");
    openapiFields.add("kind");
    openapiFields.add("labels");
    openapiFields.add("location");
    openapiFields.add("maxResults");
    openapiFields.add("maximumBytesBilled");
    openapiFields.add("parameterMode");
    openapiFields.add("preserveNulls");
    openapiFields.add("query");
    openapiFields.add("queryParameters");
    openapiFields.add("requestId");
    openapiFields.add("timeoutMs");
    openapiFields.add("useLegacySql");
    openapiFields.add("useQueryCache");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to QueryRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!QueryRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in QueryRequest is not found in the empty JSON string", QueryRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!QueryRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `QueryRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("connectionProperties") != null && !jsonObj.get("connectionProperties").isJsonNull()) {
        JsonArray jsonArrayconnectionProperties = jsonObj.getAsJsonArray("connectionProperties");
        if (jsonArrayconnectionProperties != null) {
          // ensure the json data is an array
          if (!jsonObj.get("connectionProperties").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `connectionProperties` to be an array in the JSON string but got `%s`", jsonObj.get("connectionProperties").toString()));
          }

          // validate the optional field `connectionProperties` (array)
          for (int i = 0; i < jsonArrayconnectionProperties.size(); i++) {
            ConnectionProperty.validateJsonElement(jsonArrayconnectionProperties.get(i));
          };
        }
      }
      // validate the optional field `defaultDataset`
      if (jsonObj.get("defaultDataset") != null && !jsonObj.get("defaultDataset").isJsonNull()) {
        DatasetReference.validateJsonElement(jsonObj.get("defaultDataset"));
      }
      // validate the optional field `formatOptions`
      if (jsonObj.get("formatOptions") != null && !jsonObj.get("formatOptions").isJsonNull()) {
        DataFormatOptions.validateJsonElement(jsonObj.get("formatOptions"));
      }
      if ((jsonObj.get("jobCreationMode") != null && !jsonObj.get("jobCreationMode").isJsonNull()) && !jsonObj.get("jobCreationMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobCreationMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jobCreationMode").toString()));
      }
      // validate the optional field `jobCreationMode`
      if (jsonObj.get("jobCreationMode") != null && !jsonObj.get("jobCreationMode").isJsonNull()) {
        JobCreationModeEnum.validateJsonElement(jsonObj.get("jobCreationMode"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("maximumBytesBilled") != null && !jsonObj.get("maximumBytesBilled").isJsonNull()) && !jsonObj.get("maximumBytesBilled").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumBytesBilled` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumBytesBilled").toString()));
      }
      if ((jsonObj.get("parameterMode") != null && !jsonObj.get("parameterMode").isJsonNull()) && !jsonObj.get("parameterMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parameterMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parameterMode").toString()));
      }
      if ((jsonObj.get("query") != null && !jsonObj.get("query").isJsonNull()) && !jsonObj.get("query").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `query` to be a primitive type in the JSON string but got `%s`", jsonObj.get("query").toString()));
      }
      if (jsonObj.get("queryParameters") != null && !jsonObj.get("queryParameters").isJsonNull()) {
        JsonArray jsonArrayqueryParameters = jsonObj.getAsJsonArray("queryParameters");
        if (jsonArrayqueryParameters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("queryParameters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `queryParameters` to be an array in the JSON string but got `%s`", jsonObj.get("queryParameters").toString()));
          }

          // validate the optional field `queryParameters` (array)
          for (int i = 0; i < jsonArrayqueryParameters.size(); i++) {
            QueryParameter.validateJsonElement(jsonArrayqueryParameters.get(i));
          };
        }
      }
      if ((jsonObj.get("requestId") != null && !jsonObj.get("requestId").isJsonNull()) && !jsonObj.get("requestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QueryRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QueryRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QueryRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QueryRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<QueryRequest>() {
           @Override
           public void write(JsonWriter out, QueryRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public QueryRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of QueryRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of QueryRequest
   * @throws IOException if the JSON string is invalid with respect to QueryRequest
   */
  public static QueryRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QueryRequest.class);
  }

  /**
   * Convert an instance of QueryRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

