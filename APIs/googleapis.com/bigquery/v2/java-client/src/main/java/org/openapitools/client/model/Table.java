/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.BigLakeConfiguration;
import org.openapitools.client.model.CloneDefinition;
import org.openapitools.client.model.Clustering;
import org.openapitools.client.model.EncryptionConfiguration;
import org.openapitools.client.model.ExternalDataConfiguration;
import org.openapitools.client.model.MaterializedViewDefinition;
import org.openapitools.client.model.MaterializedViewStatus;
import org.openapitools.client.model.ModelDefinition;
import org.openapitools.client.model.RangePartitioning;
import org.openapitools.client.model.SnapshotDefinition;
import org.openapitools.client.model.Streamingbuffer;
import org.openapitools.client.model.TableConstraints;
import org.openapitools.client.model.TableReference;
import org.openapitools.client.model.TableReplicationInfo;
import org.openapitools.client.model.TableSchema;
import org.openapitools.client.model.TimePartitioning;
import org.openapitools.client.model.ViewDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Table
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Table {
  public static final String SERIALIZED_NAME_BIGLAKE_CONFIGURATION = "biglakeConfiguration";
  @SerializedName(SERIALIZED_NAME_BIGLAKE_CONFIGURATION)
  private BigLakeConfiguration biglakeConfiguration;

  public static final String SERIALIZED_NAME_CLONE_DEFINITION = "cloneDefinition";
  @SerializedName(SERIALIZED_NAME_CLONE_DEFINITION)
  private CloneDefinition cloneDefinition;

  public static final String SERIALIZED_NAME_CLUSTERING = "clustering";
  @SerializedName(SERIALIZED_NAME_CLUSTERING)
  private Clustering clustering;

  public static final String SERIALIZED_NAME_CREATION_TIME = "creationTime";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private String creationTime;

  public static final String SERIALIZED_NAME_DEFAULT_COLLATION = "defaultCollation";
  @SerializedName(SERIALIZED_NAME_DEFAULT_COLLATION)
  private String defaultCollation;

  /**
   * Optional. Defines the default rounding mode specification of new decimal fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or update, if a decimal field is added to this table without an explicit rounding mode specified, then the field inherits the table default rounding mode. Changing this field doesn&#39;t affect existing fields.
   */
  @JsonAdapter(DefaultRoundingModeEnum.Adapter.class)
  public enum DefaultRoundingModeEnum {
    ROUNDING_MODE_UNSPECIFIED("ROUNDING_MODE_UNSPECIFIED"),
    
    ROUND_HALF_AWAY_FROM_ZERO("ROUND_HALF_AWAY_FROM_ZERO"),
    
    ROUND_HALF_EVEN("ROUND_HALF_EVEN");

    private String value;

    DefaultRoundingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultRoundingModeEnum fromValue(String value) {
      for (DefaultRoundingModeEnum b : DefaultRoundingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultRoundingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultRoundingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultRoundingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DefaultRoundingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DefaultRoundingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_ROUNDING_MODE = "defaultRoundingMode";
  @SerializedName(SERIALIZED_NAME_DEFAULT_ROUNDING_MODE)
  private DefaultRoundingModeEnum defaultRoundingMode;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ENCRYPTION_CONFIGURATION = "encryptionConfiguration";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_CONFIGURATION)
  private EncryptionConfiguration encryptionConfiguration;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_EXPIRATION_TIME = "expirationTime";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_TIME)
  private String expirationTime;

  public static final String SERIALIZED_NAME_EXTERNAL_DATA_CONFIGURATION = "externalDataConfiguration";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_DATA_CONFIGURATION)
  private ExternalDataConfiguration externalDataConfiguration;

  public static final String SERIALIZED_NAME_FRIENDLY_NAME = "friendlyName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_NAME)
  private String friendlyName;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "bigquery#table";

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LAST_MODIFIED_TIME = "lastModifiedTime";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED_TIME)
  private String lastModifiedTime;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_MATERIALIZED_VIEW = "materializedView";
  @SerializedName(SERIALIZED_NAME_MATERIALIZED_VIEW)
  private MaterializedViewDefinition materializedView;

  public static final String SERIALIZED_NAME_MATERIALIZED_VIEW_STATUS = "materializedViewStatus";
  @SerializedName(SERIALIZED_NAME_MATERIALIZED_VIEW_STATUS)
  private MaterializedViewStatus materializedViewStatus;

  public static final String SERIALIZED_NAME_MAX_STALENESS = "maxStaleness";
  @SerializedName(SERIALIZED_NAME_MAX_STALENESS)
  private String maxStaleness;

  public static final String SERIALIZED_NAME_MODEL = "model";
  @SerializedName(SERIALIZED_NAME_MODEL)
  private ModelDefinition model;

  public static final String SERIALIZED_NAME_NUM_ACTIVE_LOGICAL_BYTES = "numActiveLogicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_ACTIVE_LOGICAL_BYTES)
  private String numActiveLogicalBytes;

  public static final String SERIALIZED_NAME_NUM_ACTIVE_PHYSICAL_BYTES = "numActivePhysicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_ACTIVE_PHYSICAL_BYTES)
  private String numActivePhysicalBytes;

  public static final String SERIALIZED_NAME_NUM_BYTES = "numBytes";
  @SerializedName(SERIALIZED_NAME_NUM_BYTES)
  private String numBytes;

  public static final String SERIALIZED_NAME_NUM_LONG_TERM_BYTES = "numLongTermBytes";
  @SerializedName(SERIALIZED_NAME_NUM_LONG_TERM_BYTES)
  private String numLongTermBytes;

  public static final String SERIALIZED_NAME_NUM_LONG_TERM_LOGICAL_BYTES = "numLongTermLogicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_LONG_TERM_LOGICAL_BYTES)
  private String numLongTermLogicalBytes;

  public static final String SERIALIZED_NAME_NUM_LONG_TERM_PHYSICAL_BYTES = "numLongTermPhysicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_LONG_TERM_PHYSICAL_BYTES)
  private String numLongTermPhysicalBytes;

  public static final String SERIALIZED_NAME_NUM_PARTITIONS = "numPartitions";
  @SerializedName(SERIALIZED_NAME_NUM_PARTITIONS)
  private String numPartitions;

  public static final String SERIALIZED_NAME_NUM_PHYSICAL_BYTES = "numPhysicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_PHYSICAL_BYTES)
  private String numPhysicalBytes;

  public static final String SERIALIZED_NAME_NUM_ROWS = "numRows";
  @SerializedName(SERIALIZED_NAME_NUM_ROWS)
  private String numRows;

  public static final String SERIALIZED_NAME_NUM_TIME_TRAVEL_PHYSICAL_BYTES = "numTimeTravelPhysicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_TIME_TRAVEL_PHYSICAL_BYTES)
  private String numTimeTravelPhysicalBytes;

  public static final String SERIALIZED_NAME_NUM_TOTAL_LOGICAL_BYTES = "numTotalLogicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_TOTAL_LOGICAL_BYTES)
  private String numTotalLogicalBytes;

  public static final String SERIALIZED_NAME_NUM_TOTAL_PHYSICAL_BYTES = "numTotalPhysicalBytes";
  @SerializedName(SERIALIZED_NAME_NUM_TOTAL_PHYSICAL_BYTES)
  private String numTotalPhysicalBytes;

  public static final String SERIALIZED_NAME_RANGE_PARTITIONING = "rangePartitioning";
  @SerializedName(SERIALIZED_NAME_RANGE_PARTITIONING)
  private RangePartitioning rangePartitioning;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private List<TableReference> replicas = new ArrayList<>();

  public static final String SERIALIZED_NAME_REQUIRE_PARTITION_FILTER = "requirePartitionFilter";
  @SerializedName(SERIALIZED_NAME_REQUIRE_PARTITION_FILTER)
  private Boolean requirePartitionFilter = false;

  public static final String SERIALIZED_NAME_RESOURCE_TAGS = "resourceTags";
  @SerializedName(SERIALIZED_NAME_RESOURCE_TAGS)
  private Map<String, String> resourceTags = new HashMap<>();

  public static final String SERIALIZED_NAME_SCHEMA = "schema";
  @SerializedName(SERIALIZED_NAME_SCHEMA)
  private TableSchema schema;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public static final String SERIALIZED_NAME_SNAPSHOT_DEFINITION = "snapshotDefinition";
  @SerializedName(SERIALIZED_NAME_SNAPSHOT_DEFINITION)
  private SnapshotDefinition snapshotDefinition;

  public static final String SERIALIZED_NAME_STREAMING_BUFFER = "streamingBuffer";
  @SerializedName(SERIALIZED_NAME_STREAMING_BUFFER)
  private Streamingbuffer streamingBuffer;

  public static final String SERIALIZED_NAME_TABLE_CONSTRAINTS = "tableConstraints";
  @SerializedName(SERIALIZED_NAME_TABLE_CONSTRAINTS)
  private TableConstraints tableConstraints;

  public static final String SERIALIZED_NAME_TABLE_REFERENCE = "tableReference";
  @SerializedName(SERIALIZED_NAME_TABLE_REFERENCE)
  private TableReference tableReference;

  public static final String SERIALIZED_NAME_TABLE_REPLICATION_INFO = "tableReplicationInfo";
  @SerializedName(SERIALIZED_NAME_TABLE_REPLICATION_INFO)
  private TableReplicationInfo tableReplicationInfo;

  public static final String SERIALIZED_NAME_TIME_PARTITIONING = "timePartitioning";
  @SerializedName(SERIALIZED_NAME_TIME_PARTITIONING)
  private TimePartitioning timePartitioning;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_VIEW = "view";
  @SerializedName(SERIALIZED_NAME_VIEW)
  private ViewDefinition view;

  public Table() {
  }

  public Table(
     String creationTime, 
     String etag, 
     String id, 
     String lastModifiedTime, 
     String location, 
     String numActiveLogicalBytes, 
     String numActivePhysicalBytes, 
     String numBytes, 
     String numLongTermBytes, 
     String numLongTermLogicalBytes, 
     String numLongTermPhysicalBytes, 
     String numPartitions, 
     String numPhysicalBytes, 
     String numRows, 
     String numTimeTravelPhysicalBytes, 
     String numTotalLogicalBytes, 
     String numTotalPhysicalBytes, 
     List<TableReference> replicas, 
     String selfLink, 
     String type
  ) {
    this();
    this.creationTime = creationTime;
    this.etag = etag;
    this.id = id;
    this.lastModifiedTime = lastModifiedTime;
    this.location = location;
    this.numActiveLogicalBytes = numActiveLogicalBytes;
    this.numActivePhysicalBytes = numActivePhysicalBytes;
    this.numBytes = numBytes;
    this.numLongTermBytes = numLongTermBytes;
    this.numLongTermLogicalBytes = numLongTermLogicalBytes;
    this.numLongTermPhysicalBytes = numLongTermPhysicalBytes;
    this.numPartitions = numPartitions;
    this.numPhysicalBytes = numPhysicalBytes;
    this.numRows = numRows;
    this.numTimeTravelPhysicalBytes = numTimeTravelPhysicalBytes;
    this.numTotalLogicalBytes = numTotalLogicalBytes;
    this.numTotalPhysicalBytes = numTotalPhysicalBytes;
    this.replicas = replicas;
    this.selfLink = selfLink;
    this.type = type;
  }

  public Table biglakeConfiguration(BigLakeConfiguration biglakeConfiguration) {
    this.biglakeConfiguration = biglakeConfiguration;
    return this;
  }

  /**
   * Get biglakeConfiguration
   * @return biglakeConfiguration
   */
  @javax.annotation.Nullable
  public BigLakeConfiguration getBiglakeConfiguration() {
    return biglakeConfiguration;
  }

  public void setBiglakeConfiguration(BigLakeConfiguration biglakeConfiguration) {
    this.biglakeConfiguration = biglakeConfiguration;
  }


  public Table cloneDefinition(CloneDefinition cloneDefinition) {
    this.cloneDefinition = cloneDefinition;
    return this;
  }

  /**
   * Get cloneDefinition
   * @return cloneDefinition
   */
  @javax.annotation.Nullable
  public CloneDefinition getCloneDefinition() {
    return cloneDefinition;
  }

  public void setCloneDefinition(CloneDefinition cloneDefinition) {
    this.cloneDefinition = cloneDefinition;
  }


  public Table clustering(Clustering clustering) {
    this.clustering = clustering;
    return this;
  }

  /**
   * Get clustering
   * @return clustering
   */
  @javax.annotation.Nullable
  public Clustering getClustering() {
    return clustering;
  }

  public void setClustering(Clustering clustering) {
    this.clustering = clustering;
  }


  /**
   * Output only. The time when this table was created, in milliseconds since the epoch.
   * @return creationTime
   */
  @javax.annotation.Nullable
  public String getCreationTime() {
    return creationTime;
  }



  public Table defaultCollation(String defaultCollation) {
    this.defaultCollation = defaultCollation;
    return this;
  }

  /**
   * Optional. Defines the default collation specification of new STRING fields in the table. During table creation or update, if a STRING field is added to this table without explicit collation specified, then the table inherits the table default collation. A change to this field affects only fields added afterwards, and does not alter the existing fields. The following values are supported: * &#39;und:ci&#39;: undetermined locale, case insensitive. * &#39;&#39;: empty string. Default to case-sensitive behavior.
   * @return defaultCollation
   */
  @javax.annotation.Nullable
  public String getDefaultCollation() {
    return defaultCollation;
  }

  public void setDefaultCollation(String defaultCollation) {
    this.defaultCollation = defaultCollation;
  }


  public Table defaultRoundingMode(DefaultRoundingModeEnum defaultRoundingMode) {
    this.defaultRoundingMode = defaultRoundingMode;
    return this;
  }

  /**
   * Optional. Defines the default rounding mode specification of new decimal fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or update, if a decimal field is added to this table without an explicit rounding mode specified, then the field inherits the table default rounding mode. Changing this field doesn&#39;t affect existing fields.
   * @return defaultRoundingMode
   */
  @javax.annotation.Nullable
  public DefaultRoundingModeEnum getDefaultRoundingMode() {
    return defaultRoundingMode;
  }

  public void setDefaultRoundingMode(DefaultRoundingModeEnum defaultRoundingMode) {
    this.defaultRoundingMode = defaultRoundingMode;
  }


  public Table description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. A user-friendly description of this table.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Table encryptionConfiguration(EncryptionConfiguration encryptionConfiguration) {
    this.encryptionConfiguration = encryptionConfiguration;
    return this;
  }

  /**
   * Get encryptionConfiguration
   * @return encryptionConfiguration
   */
  @javax.annotation.Nullable
  public EncryptionConfiguration getEncryptionConfiguration() {
    return encryptionConfiguration;
  }

  public void setEncryptionConfiguration(EncryptionConfiguration encryptionConfiguration) {
    this.encryptionConfiguration = encryptionConfiguration;
  }


  /**
   * Output only. A hash of this resource.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }



  public Table expirationTime(String expirationTime) {
    this.expirationTime = expirationTime;
    return this;
  }

  /**
   * Optional. The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
   * @return expirationTime
   */
  @javax.annotation.Nullable
  public String getExpirationTime() {
    return expirationTime;
  }

  public void setExpirationTime(String expirationTime) {
    this.expirationTime = expirationTime;
  }


  public Table externalDataConfiguration(ExternalDataConfiguration externalDataConfiguration) {
    this.externalDataConfiguration = externalDataConfiguration;
    return this;
  }

  /**
   * Get externalDataConfiguration
   * @return externalDataConfiguration
   */
  @javax.annotation.Nullable
  public ExternalDataConfiguration getExternalDataConfiguration() {
    return externalDataConfiguration;
  }

  public void setExternalDataConfiguration(ExternalDataConfiguration externalDataConfiguration) {
    this.externalDataConfiguration = externalDataConfiguration;
  }


  public Table friendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
    return this;
  }

  /**
   * Optional. A descriptive name for this table.
   * @return friendlyName
   */
  @javax.annotation.Nullable
  public String getFriendlyName() {
    return friendlyName;
  }

  public void setFriendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
  }


  /**
   * Output only. An opaque ID uniquely identifying the table.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public Table kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * The type of resource ID.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Table labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Table putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  /**
   * Output only. The time when this table was last modified, in milliseconds since the epoch.
   * @return lastModifiedTime
   */
  @javax.annotation.Nullable
  public String getLastModifiedTime() {
    return lastModifiedTime;
  }



  /**
   * Output only. The geographic location where the table resides. This value is inherited from the dataset.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }



  public Table materializedView(MaterializedViewDefinition materializedView) {
    this.materializedView = materializedView;
    return this;
  }

  /**
   * Get materializedView
   * @return materializedView
   */
  @javax.annotation.Nullable
  public MaterializedViewDefinition getMaterializedView() {
    return materializedView;
  }

  public void setMaterializedView(MaterializedViewDefinition materializedView) {
    this.materializedView = materializedView;
  }


  public Table materializedViewStatus(MaterializedViewStatus materializedViewStatus) {
    this.materializedViewStatus = materializedViewStatus;
    return this;
  }

  /**
   * Get materializedViewStatus
   * @return materializedViewStatus
   */
  @javax.annotation.Nullable
  public MaterializedViewStatus getMaterializedViewStatus() {
    return materializedViewStatus;
  }

  public void setMaterializedViewStatus(MaterializedViewStatus materializedViewStatus) {
    this.materializedViewStatus = materializedViewStatus;
  }


  public Table maxStaleness(String maxStaleness) {
    this.maxStaleness = maxStaleness;
    return this;
  }

  /**
   * Optional. The maximum staleness of data that could be returned when the table (or stale MV) is queried. Staleness encoded as a string encoding of sql IntervalValue type.
   * @return maxStaleness
   */
  @javax.annotation.Nullable
  public String getMaxStaleness() {
    return maxStaleness;
  }

  public void setMaxStaleness(String maxStaleness) {
    this.maxStaleness = maxStaleness;
  }


  public Table model(ModelDefinition model) {
    this.model = model;
    return this;
  }

  /**
   * Get model
   * @return model
   */
  @javax.annotation.Nullable
  public ModelDefinition getModel() {
    return model;
  }

  public void setModel(ModelDefinition model) {
    this.model = model;
  }


  /**
   * Output only. Number of logical bytes that are less than 90 days old.
   * @return numActiveLogicalBytes
   */
  @javax.annotation.Nullable
  public String getNumActiveLogicalBytes() {
    return numActiveLogicalBytes;
  }



  /**
   * Output only. Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
   * @return numActivePhysicalBytes
   */
  @javax.annotation.Nullable
  public String getNumActivePhysicalBytes() {
    return numActivePhysicalBytes;
  }



  /**
   * Output only. The size of this table in logical bytes, excluding any data in the streaming buffer.
   * @return numBytes
   */
  @javax.annotation.Nullable
  public String getNumBytes() {
    return numBytes;
  }



  /**
   * Output only. The number of logical bytes in the table that are considered \&quot;long-term storage\&quot;.
   * @return numLongTermBytes
   */
  @javax.annotation.Nullable
  public String getNumLongTermBytes() {
    return numLongTermBytes;
  }



  /**
   * Output only. Number of logical bytes that are more than 90 days old.
   * @return numLongTermLogicalBytes
   */
  @javax.annotation.Nullable
  public String getNumLongTermLogicalBytes() {
    return numLongTermLogicalBytes;
  }



  /**
   * Output only. Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
   * @return numLongTermPhysicalBytes
   */
  @javax.annotation.Nullable
  public String getNumLongTermPhysicalBytes() {
    return numLongTermPhysicalBytes;
  }



  /**
   * Output only. The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
   * @return numPartitions
   */
  @javax.annotation.Nullable
  public String getNumPartitions() {
    return numPartitions;
  }



  /**
   * Output only. The physical size of this table in bytes. This includes storage used for time travel.
   * @return numPhysicalBytes
   */
  @javax.annotation.Nullable
  public String getNumPhysicalBytes() {
    return numPhysicalBytes;
  }



  /**
   * Output only. The number of rows of data in this table, excluding any data in the streaming buffer.
   * @return numRows
   */
  @javax.annotation.Nullable
  public String getNumRows() {
    return numRows;
  }



  /**
   * Output only. Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
   * @return numTimeTravelPhysicalBytes
   */
  @javax.annotation.Nullable
  public String getNumTimeTravelPhysicalBytes() {
    return numTimeTravelPhysicalBytes;
  }



  /**
   * Output only. Total number of logical bytes in the table or materialized view.
   * @return numTotalLogicalBytes
   */
  @javax.annotation.Nullable
  public String getNumTotalLogicalBytes() {
    return numTotalLogicalBytes;
  }



  /**
   * Output only. The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
   * @return numTotalPhysicalBytes
   */
  @javax.annotation.Nullable
  public String getNumTotalPhysicalBytes() {
    return numTotalPhysicalBytes;
  }



  public Table rangePartitioning(RangePartitioning rangePartitioning) {
    this.rangePartitioning = rangePartitioning;
    return this;
  }

  /**
   * Get rangePartitioning
   * @return rangePartitioning
   */
  @javax.annotation.Nullable
  public RangePartitioning getRangePartitioning() {
    return rangePartitioning;
  }

  public void setRangePartitioning(RangePartitioning rangePartitioning) {
    this.rangePartitioning = rangePartitioning;
  }


  /**
   * Optional. Output only. Table references of all replicas currently active on the table.
   * @return replicas
   */
  @javax.annotation.Nullable
  public List<TableReference> getReplicas() {
    return replicas;
  }



  public Table requirePartitionFilter(Boolean requirePartitionFilter) {
    this.requirePartitionFilter = requirePartitionFilter;
    return this;
  }

  /**
   * Optional. If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
   * @return requirePartitionFilter
   */
  @javax.annotation.Nullable
  public Boolean getRequirePartitionFilter() {
    return requirePartitionFilter;
  }

  public void setRequirePartitionFilter(Boolean requirePartitionFilter) {
    this.requirePartitionFilter = requirePartitionFilter;
  }


  public Table resourceTags(Map<String, String> resourceTags) {
    this.resourceTags = resourceTags;
    return this;
  }

  public Table putResourceTagsItem(String key, String resourceTagsItem) {
    if (this.resourceTags == null) {
      this.resourceTags = new HashMap<>();
    }
    this.resourceTags.put(key, resourceTagsItem);
    return this;
  }

  /**
   * [Optional] The tags associated with this table. Tag keys are globally unique. See additional information on [tags](https://cloud.google.com/iam/docs/tags-access-control#definitions). An object containing a list of \&quot;key\&quot;: value pairs. The key is the namespaced friendly name of the tag key, e.g. \&quot;12345/environment\&quot; where 12345 is parent id. The value is the friendly short name of the tag value, e.g. \&quot;production\&quot;.
   * @return resourceTags
   */
  @javax.annotation.Nullable
  public Map<String, String> getResourceTags() {
    return resourceTags;
  }

  public void setResourceTags(Map<String, String> resourceTags) {
    this.resourceTags = resourceTags;
  }


  public Table schema(TableSchema schema) {
    this.schema = schema;
    return this;
  }

  /**
   * Get schema
   * @return schema
   */
  @javax.annotation.Nullable
  public TableSchema getSchema() {
    return schema;
  }

  public void setSchema(TableSchema schema) {
    this.schema = schema;
  }


  /**
   * Output only. A URL that can be used to access this resource again.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }



  public Table snapshotDefinition(SnapshotDefinition snapshotDefinition) {
    this.snapshotDefinition = snapshotDefinition;
    return this;
  }

  /**
   * Get snapshotDefinition
   * @return snapshotDefinition
   */
  @javax.annotation.Nullable
  public SnapshotDefinition getSnapshotDefinition() {
    return snapshotDefinition;
  }

  public void setSnapshotDefinition(SnapshotDefinition snapshotDefinition) {
    this.snapshotDefinition = snapshotDefinition;
  }


  public Table streamingBuffer(Streamingbuffer streamingBuffer) {
    this.streamingBuffer = streamingBuffer;
    return this;
  }

  /**
   * Get streamingBuffer
   * @return streamingBuffer
   */
  @javax.annotation.Nullable
  public Streamingbuffer getStreamingBuffer() {
    return streamingBuffer;
  }

  public void setStreamingBuffer(Streamingbuffer streamingBuffer) {
    this.streamingBuffer = streamingBuffer;
  }


  public Table tableConstraints(TableConstraints tableConstraints) {
    this.tableConstraints = tableConstraints;
    return this;
  }

  /**
   * Get tableConstraints
   * @return tableConstraints
   */
  @javax.annotation.Nullable
  public TableConstraints getTableConstraints() {
    return tableConstraints;
  }

  public void setTableConstraints(TableConstraints tableConstraints) {
    this.tableConstraints = tableConstraints;
  }


  public Table tableReference(TableReference tableReference) {
    this.tableReference = tableReference;
    return this;
  }

  /**
   * Get tableReference
   * @return tableReference
   */
  @javax.annotation.Nullable
  public TableReference getTableReference() {
    return tableReference;
  }

  public void setTableReference(TableReference tableReference) {
    this.tableReference = tableReference;
  }


  public Table tableReplicationInfo(TableReplicationInfo tableReplicationInfo) {
    this.tableReplicationInfo = tableReplicationInfo;
    return this;
  }

  /**
   * Get tableReplicationInfo
   * @return tableReplicationInfo
   */
  @javax.annotation.Nullable
  public TableReplicationInfo getTableReplicationInfo() {
    return tableReplicationInfo;
  }

  public void setTableReplicationInfo(TableReplicationInfo tableReplicationInfo) {
    this.tableReplicationInfo = tableReplicationInfo;
  }


  public Table timePartitioning(TimePartitioning timePartitioning) {
    this.timePartitioning = timePartitioning;
    return this;
  }

  /**
   * Get timePartitioning
   * @return timePartitioning
   */
  @javax.annotation.Nullable
  public TimePartitioning getTimePartitioning() {
    return timePartitioning;
  }

  public void setTimePartitioning(TimePartitioning timePartitioning) {
    this.timePartitioning = timePartitioning;
  }


  /**
   * Output only. Describes the table type. The following values are supported: * &#x60;TABLE&#x60;: A normal BigQuery table. * &#x60;VIEW&#x60;: A virtual table defined by a SQL query. * &#x60;EXTERNAL&#x60;: A table that references data stored in an external storage system, such as Google Cloud Storage. * &#x60;MATERIALIZED_VIEW&#x60;: A precomputed view defined by a SQL query. * &#x60;SNAPSHOT&#x60;: An immutable BigQuery table that preserves the contents of a base table at a particular time. See additional information on [table snapshots](/bigquery/docs/table-snapshots-intro). The default value is &#x60;TABLE&#x60;.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }



  public Table view(ViewDefinition view) {
    this.view = view;
    return this;
  }

  /**
   * Get view
   * @return view
   */
  @javax.annotation.Nullable
  public ViewDefinition getView() {
    return view;
  }

  public void setView(ViewDefinition view) {
    this.view = view;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Table table = (Table) o;
    return Objects.equals(this.biglakeConfiguration, table.biglakeConfiguration) &&
        Objects.equals(this.cloneDefinition, table.cloneDefinition) &&
        Objects.equals(this.clustering, table.clustering) &&
        Objects.equals(this.creationTime, table.creationTime) &&
        Objects.equals(this.defaultCollation, table.defaultCollation) &&
        Objects.equals(this.defaultRoundingMode, table.defaultRoundingMode) &&
        Objects.equals(this.description, table.description) &&
        Objects.equals(this.encryptionConfiguration, table.encryptionConfiguration) &&
        Objects.equals(this.etag, table.etag) &&
        Objects.equals(this.expirationTime, table.expirationTime) &&
        Objects.equals(this.externalDataConfiguration, table.externalDataConfiguration) &&
        Objects.equals(this.friendlyName, table.friendlyName) &&
        Objects.equals(this.id, table.id) &&
        Objects.equals(this.kind, table.kind) &&
        Objects.equals(this.labels, table.labels) &&
        Objects.equals(this.lastModifiedTime, table.lastModifiedTime) &&
        Objects.equals(this.location, table.location) &&
        Objects.equals(this.materializedView, table.materializedView) &&
        Objects.equals(this.materializedViewStatus, table.materializedViewStatus) &&
        Objects.equals(this.maxStaleness, table.maxStaleness) &&
        Objects.equals(this.model, table.model) &&
        Objects.equals(this.numActiveLogicalBytes, table.numActiveLogicalBytes) &&
        Objects.equals(this.numActivePhysicalBytes, table.numActivePhysicalBytes) &&
        Objects.equals(this.numBytes, table.numBytes) &&
        Objects.equals(this.numLongTermBytes, table.numLongTermBytes) &&
        Objects.equals(this.numLongTermLogicalBytes, table.numLongTermLogicalBytes) &&
        Objects.equals(this.numLongTermPhysicalBytes, table.numLongTermPhysicalBytes) &&
        Objects.equals(this.numPartitions, table.numPartitions) &&
        Objects.equals(this.numPhysicalBytes, table.numPhysicalBytes) &&
        Objects.equals(this.numRows, table.numRows) &&
        Objects.equals(this.numTimeTravelPhysicalBytes, table.numTimeTravelPhysicalBytes) &&
        Objects.equals(this.numTotalLogicalBytes, table.numTotalLogicalBytes) &&
        Objects.equals(this.numTotalPhysicalBytes, table.numTotalPhysicalBytes) &&
        Objects.equals(this.rangePartitioning, table.rangePartitioning) &&
        Objects.equals(this.replicas, table.replicas) &&
        Objects.equals(this.requirePartitionFilter, table.requirePartitionFilter) &&
        Objects.equals(this.resourceTags, table.resourceTags) &&
        Objects.equals(this.schema, table.schema) &&
        Objects.equals(this.selfLink, table.selfLink) &&
        Objects.equals(this.snapshotDefinition, table.snapshotDefinition) &&
        Objects.equals(this.streamingBuffer, table.streamingBuffer) &&
        Objects.equals(this.tableConstraints, table.tableConstraints) &&
        Objects.equals(this.tableReference, table.tableReference) &&
        Objects.equals(this.tableReplicationInfo, table.tableReplicationInfo) &&
        Objects.equals(this.timePartitioning, table.timePartitioning) &&
        Objects.equals(this.type, table.type) &&
        Objects.equals(this.view, table.view);
  }

  @Override
  public int hashCode() {
    return Objects.hash(biglakeConfiguration, cloneDefinition, clustering, creationTime, defaultCollation, defaultRoundingMode, description, encryptionConfiguration, etag, expirationTime, externalDataConfiguration, friendlyName, id, kind, labels, lastModifiedTime, location, materializedView, materializedViewStatus, maxStaleness, model, numActiveLogicalBytes, numActivePhysicalBytes, numBytes, numLongTermBytes, numLongTermLogicalBytes, numLongTermPhysicalBytes, numPartitions, numPhysicalBytes, numRows, numTimeTravelPhysicalBytes, numTotalLogicalBytes, numTotalPhysicalBytes, rangePartitioning, replicas, requirePartitionFilter, resourceTags, schema, selfLink, snapshotDefinition, streamingBuffer, tableConstraints, tableReference, tableReplicationInfo, timePartitioning, type, view);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Table {\n");
    sb.append("    biglakeConfiguration: ").append(toIndentedString(biglakeConfiguration)).append("\n");
    sb.append("    cloneDefinition: ").append(toIndentedString(cloneDefinition)).append("\n");
    sb.append("    clustering: ").append(toIndentedString(clustering)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    defaultCollation: ").append(toIndentedString(defaultCollation)).append("\n");
    sb.append("    defaultRoundingMode: ").append(toIndentedString(defaultRoundingMode)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    encryptionConfiguration: ").append(toIndentedString(encryptionConfiguration)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    expirationTime: ").append(toIndentedString(expirationTime)).append("\n");
    sb.append("    externalDataConfiguration: ").append(toIndentedString(externalDataConfiguration)).append("\n");
    sb.append("    friendlyName: ").append(toIndentedString(friendlyName)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lastModifiedTime: ").append(toIndentedString(lastModifiedTime)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    materializedView: ").append(toIndentedString(materializedView)).append("\n");
    sb.append("    materializedViewStatus: ").append(toIndentedString(materializedViewStatus)).append("\n");
    sb.append("    maxStaleness: ").append(toIndentedString(maxStaleness)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    numActiveLogicalBytes: ").append(toIndentedString(numActiveLogicalBytes)).append("\n");
    sb.append("    numActivePhysicalBytes: ").append(toIndentedString(numActivePhysicalBytes)).append("\n");
    sb.append("    numBytes: ").append(toIndentedString(numBytes)).append("\n");
    sb.append("    numLongTermBytes: ").append(toIndentedString(numLongTermBytes)).append("\n");
    sb.append("    numLongTermLogicalBytes: ").append(toIndentedString(numLongTermLogicalBytes)).append("\n");
    sb.append("    numLongTermPhysicalBytes: ").append(toIndentedString(numLongTermPhysicalBytes)).append("\n");
    sb.append("    numPartitions: ").append(toIndentedString(numPartitions)).append("\n");
    sb.append("    numPhysicalBytes: ").append(toIndentedString(numPhysicalBytes)).append("\n");
    sb.append("    numRows: ").append(toIndentedString(numRows)).append("\n");
    sb.append("    numTimeTravelPhysicalBytes: ").append(toIndentedString(numTimeTravelPhysicalBytes)).append("\n");
    sb.append("    numTotalLogicalBytes: ").append(toIndentedString(numTotalLogicalBytes)).append("\n");
    sb.append("    numTotalPhysicalBytes: ").append(toIndentedString(numTotalPhysicalBytes)).append("\n");
    sb.append("    rangePartitioning: ").append(toIndentedString(rangePartitioning)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    requirePartitionFilter: ").append(toIndentedString(requirePartitionFilter)).append("\n");
    sb.append("    resourceTags: ").append(toIndentedString(resourceTags)).append("\n");
    sb.append("    schema: ").append(toIndentedString(schema)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    snapshotDefinition: ").append(toIndentedString(snapshotDefinition)).append("\n");
    sb.append("    streamingBuffer: ").append(toIndentedString(streamingBuffer)).append("\n");
    sb.append("    tableConstraints: ").append(toIndentedString(tableConstraints)).append("\n");
    sb.append("    tableReference: ").append(toIndentedString(tableReference)).append("\n");
    sb.append("    tableReplicationInfo: ").append(toIndentedString(tableReplicationInfo)).append("\n");
    sb.append("    timePartitioning: ").append(toIndentedString(timePartitioning)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    view: ").append(toIndentedString(view)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("biglakeConfiguration");
    openapiFields.add("cloneDefinition");
    openapiFields.add("clustering");
    openapiFields.add("creationTime");
    openapiFields.add("defaultCollation");
    openapiFields.add("defaultRoundingMode");
    openapiFields.add("description");
    openapiFields.add("encryptionConfiguration");
    openapiFields.add("etag");
    openapiFields.add("expirationTime");
    openapiFields.add("externalDataConfiguration");
    openapiFields.add("friendlyName");
    openapiFields.add("id");
    openapiFields.add("kind");
    openapiFields.add("labels");
    openapiFields.add("lastModifiedTime");
    openapiFields.add("location");
    openapiFields.add("materializedView");
    openapiFields.add("materializedViewStatus");
    openapiFields.add("maxStaleness");
    openapiFields.add("model");
    openapiFields.add("numActiveLogicalBytes");
    openapiFields.add("numActivePhysicalBytes");
    openapiFields.add("numBytes");
    openapiFields.add("numLongTermBytes");
    openapiFields.add("numLongTermLogicalBytes");
    openapiFields.add("numLongTermPhysicalBytes");
    openapiFields.add("numPartitions");
    openapiFields.add("numPhysicalBytes");
    openapiFields.add("numRows");
    openapiFields.add("numTimeTravelPhysicalBytes");
    openapiFields.add("numTotalLogicalBytes");
    openapiFields.add("numTotalPhysicalBytes");
    openapiFields.add("rangePartitioning");
    openapiFields.add("replicas");
    openapiFields.add("requirePartitionFilter");
    openapiFields.add("resourceTags");
    openapiFields.add("schema");
    openapiFields.add("selfLink");
    openapiFields.add("snapshotDefinition");
    openapiFields.add("streamingBuffer");
    openapiFields.add("tableConstraints");
    openapiFields.add("tableReference");
    openapiFields.add("tableReplicationInfo");
    openapiFields.add("timePartitioning");
    openapiFields.add("type");
    openapiFields.add("view");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Table
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Table.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Table is not found in the empty JSON string", Table.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Table.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Table` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `biglakeConfiguration`
      if (jsonObj.get("biglakeConfiguration") != null && !jsonObj.get("biglakeConfiguration").isJsonNull()) {
        BigLakeConfiguration.validateJsonElement(jsonObj.get("biglakeConfiguration"));
      }
      // validate the optional field `cloneDefinition`
      if (jsonObj.get("cloneDefinition") != null && !jsonObj.get("cloneDefinition").isJsonNull()) {
        CloneDefinition.validateJsonElement(jsonObj.get("cloneDefinition"));
      }
      // validate the optional field `clustering`
      if (jsonObj.get("clustering") != null && !jsonObj.get("clustering").isJsonNull()) {
        Clustering.validateJsonElement(jsonObj.get("clustering"));
      }
      if ((jsonObj.get("creationTime") != null && !jsonObj.get("creationTime").isJsonNull()) && !jsonObj.get("creationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creationTime").toString()));
      }
      if ((jsonObj.get("defaultCollation") != null && !jsonObj.get("defaultCollation").isJsonNull()) && !jsonObj.get("defaultCollation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultCollation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultCollation").toString()));
      }
      if ((jsonObj.get("defaultRoundingMode") != null && !jsonObj.get("defaultRoundingMode").isJsonNull()) && !jsonObj.get("defaultRoundingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultRoundingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultRoundingMode").toString()));
      }
      // validate the optional field `defaultRoundingMode`
      if (jsonObj.get("defaultRoundingMode") != null && !jsonObj.get("defaultRoundingMode").isJsonNull()) {
        DefaultRoundingModeEnum.validateJsonElement(jsonObj.get("defaultRoundingMode"));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `encryptionConfiguration`
      if (jsonObj.get("encryptionConfiguration") != null && !jsonObj.get("encryptionConfiguration").isJsonNull()) {
        EncryptionConfiguration.validateJsonElement(jsonObj.get("encryptionConfiguration"));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("expirationTime") != null && !jsonObj.get("expirationTime").isJsonNull()) && !jsonObj.get("expirationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expirationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expirationTime").toString()));
      }
      // validate the optional field `externalDataConfiguration`
      if (jsonObj.get("externalDataConfiguration") != null && !jsonObj.get("externalDataConfiguration").isJsonNull()) {
        ExternalDataConfiguration.validateJsonElement(jsonObj.get("externalDataConfiguration"));
      }
      if ((jsonObj.get("friendlyName") != null && !jsonObj.get("friendlyName").isJsonNull()) && !jsonObj.get("friendlyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlyName").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("lastModifiedTime") != null && !jsonObj.get("lastModifiedTime").isJsonNull()) && !jsonObj.get("lastModifiedTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastModifiedTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastModifiedTime").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      // validate the optional field `materializedView`
      if (jsonObj.get("materializedView") != null && !jsonObj.get("materializedView").isJsonNull()) {
        MaterializedViewDefinition.validateJsonElement(jsonObj.get("materializedView"));
      }
      // validate the optional field `materializedViewStatus`
      if (jsonObj.get("materializedViewStatus") != null && !jsonObj.get("materializedViewStatus").isJsonNull()) {
        MaterializedViewStatus.validateJsonElement(jsonObj.get("materializedViewStatus"));
      }
      if ((jsonObj.get("maxStaleness") != null && !jsonObj.get("maxStaleness").isJsonNull()) && !jsonObj.get("maxStaleness").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxStaleness` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxStaleness").toString()));
      }
      // validate the optional field `model`
      if (jsonObj.get("model") != null && !jsonObj.get("model").isJsonNull()) {
        ModelDefinition.validateJsonElement(jsonObj.get("model"));
      }
      if ((jsonObj.get("numActiveLogicalBytes") != null && !jsonObj.get("numActiveLogicalBytes").isJsonNull()) && !jsonObj.get("numActiveLogicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numActiveLogicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numActiveLogicalBytes").toString()));
      }
      if ((jsonObj.get("numActivePhysicalBytes") != null && !jsonObj.get("numActivePhysicalBytes").isJsonNull()) && !jsonObj.get("numActivePhysicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numActivePhysicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numActivePhysicalBytes").toString()));
      }
      if ((jsonObj.get("numBytes") != null && !jsonObj.get("numBytes").isJsonNull()) && !jsonObj.get("numBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numBytes").toString()));
      }
      if ((jsonObj.get("numLongTermBytes") != null && !jsonObj.get("numLongTermBytes").isJsonNull()) && !jsonObj.get("numLongTermBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numLongTermBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numLongTermBytes").toString()));
      }
      if ((jsonObj.get("numLongTermLogicalBytes") != null && !jsonObj.get("numLongTermLogicalBytes").isJsonNull()) && !jsonObj.get("numLongTermLogicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numLongTermLogicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numLongTermLogicalBytes").toString()));
      }
      if ((jsonObj.get("numLongTermPhysicalBytes") != null && !jsonObj.get("numLongTermPhysicalBytes").isJsonNull()) && !jsonObj.get("numLongTermPhysicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numLongTermPhysicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numLongTermPhysicalBytes").toString()));
      }
      if ((jsonObj.get("numPartitions") != null && !jsonObj.get("numPartitions").isJsonNull()) && !jsonObj.get("numPartitions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numPartitions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numPartitions").toString()));
      }
      if ((jsonObj.get("numPhysicalBytes") != null && !jsonObj.get("numPhysicalBytes").isJsonNull()) && !jsonObj.get("numPhysicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numPhysicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numPhysicalBytes").toString()));
      }
      if ((jsonObj.get("numRows") != null && !jsonObj.get("numRows").isJsonNull()) && !jsonObj.get("numRows").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numRows` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numRows").toString()));
      }
      if ((jsonObj.get("numTimeTravelPhysicalBytes") != null && !jsonObj.get("numTimeTravelPhysicalBytes").isJsonNull()) && !jsonObj.get("numTimeTravelPhysicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numTimeTravelPhysicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numTimeTravelPhysicalBytes").toString()));
      }
      if ((jsonObj.get("numTotalLogicalBytes") != null && !jsonObj.get("numTotalLogicalBytes").isJsonNull()) && !jsonObj.get("numTotalLogicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numTotalLogicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numTotalLogicalBytes").toString()));
      }
      if ((jsonObj.get("numTotalPhysicalBytes") != null && !jsonObj.get("numTotalPhysicalBytes").isJsonNull()) && !jsonObj.get("numTotalPhysicalBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numTotalPhysicalBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numTotalPhysicalBytes").toString()));
      }
      // validate the optional field `rangePartitioning`
      if (jsonObj.get("rangePartitioning") != null && !jsonObj.get("rangePartitioning").isJsonNull()) {
        RangePartitioning.validateJsonElement(jsonObj.get("rangePartitioning"));
      }
      if (jsonObj.get("replicas") != null && !jsonObj.get("replicas").isJsonNull()) {
        JsonArray jsonArrayreplicas = jsonObj.getAsJsonArray("replicas");
        if (jsonArrayreplicas != null) {
          // ensure the json data is an array
          if (!jsonObj.get("replicas").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `replicas` to be an array in the JSON string but got `%s`", jsonObj.get("replicas").toString()));
          }

          // validate the optional field `replicas` (array)
          for (int i = 0; i < jsonArrayreplicas.size(); i++) {
            TableReference.validateJsonElement(jsonArrayreplicas.get(i));
          };
        }
      }
      // validate the optional field `schema`
      if (jsonObj.get("schema") != null && !jsonObj.get("schema").isJsonNull()) {
        TableSchema.validateJsonElement(jsonObj.get("schema"));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      // validate the optional field `snapshotDefinition`
      if (jsonObj.get("snapshotDefinition") != null && !jsonObj.get("snapshotDefinition").isJsonNull()) {
        SnapshotDefinition.validateJsonElement(jsonObj.get("snapshotDefinition"));
      }
      // validate the optional field `streamingBuffer`
      if (jsonObj.get("streamingBuffer") != null && !jsonObj.get("streamingBuffer").isJsonNull()) {
        Streamingbuffer.validateJsonElement(jsonObj.get("streamingBuffer"));
      }
      // validate the optional field `tableConstraints`
      if (jsonObj.get("tableConstraints") != null && !jsonObj.get("tableConstraints").isJsonNull()) {
        TableConstraints.validateJsonElement(jsonObj.get("tableConstraints"));
      }
      // validate the optional field `tableReference`
      if (jsonObj.get("tableReference") != null && !jsonObj.get("tableReference").isJsonNull()) {
        TableReference.validateJsonElement(jsonObj.get("tableReference"));
      }
      // validate the optional field `tableReplicationInfo`
      if (jsonObj.get("tableReplicationInfo") != null && !jsonObj.get("tableReplicationInfo").isJsonNull()) {
        TableReplicationInfo.validateJsonElement(jsonObj.get("tableReplicationInfo"));
      }
      // validate the optional field `timePartitioning`
      if (jsonObj.get("timePartitioning") != null && !jsonObj.get("timePartitioning").isJsonNull()) {
        TimePartitioning.validateJsonElement(jsonObj.get("timePartitioning"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `view`
      if (jsonObj.get("view") != null && !jsonObj.get("view").isJsonNull()) {
        ViewDefinition.validateJsonElement(jsonObj.get("view"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Table.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Table' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Table> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Table.class));

       return (TypeAdapter<T>) new TypeAdapter<Table>() {
           @Override
           public void write(JsonWriter out, Table value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Table read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Table given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Table
   * @throws IOException if the JSON string is invalid with respect to Table
   */
  public static Table fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Table.class);
  }

  /**
   * Convert an instance of Table to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

