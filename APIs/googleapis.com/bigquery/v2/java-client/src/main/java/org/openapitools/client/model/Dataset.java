/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DatasetAccessInner;
import org.openapitools.client.model.DatasetReference;
import org.openapitools.client.model.DatasetTagsInner;
import org.openapitools.client.model.EncryptionConfiguration;
import org.openapitools.client.model.ExternalDatasetReference;
import org.openapitools.client.model.LinkedDatasetSource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Dataset
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Dataset {
  public static final String SERIALIZED_NAME_ACCESS = "access";
  @SerializedName(SERIALIZED_NAME_ACCESS)
  private List<DatasetAccessInner> access = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATION_TIME = "creationTime";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private String creationTime;

  public static final String SERIALIZED_NAME_DATASET_REFERENCE = "datasetReference";
  @SerializedName(SERIALIZED_NAME_DATASET_REFERENCE)
  private DatasetReference datasetReference;

  public static final String SERIALIZED_NAME_DEFAULT_COLLATION = "defaultCollation";
  @SerializedName(SERIALIZED_NAME_DEFAULT_COLLATION)
  private String defaultCollation;

  public static final String SERIALIZED_NAME_DEFAULT_ENCRYPTION_CONFIGURATION = "defaultEncryptionConfiguration";
  @SerializedName(SERIALIZED_NAME_DEFAULT_ENCRYPTION_CONFIGURATION)
  private EncryptionConfiguration defaultEncryptionConfiguration;

  public static final String SERIALIZED_NAME_DEFAULT_PARTITION_EXPIRATION_MS = "defaultPartitionExpirationMs";
  @SerializedName(SERIALIZED_NAME_DEFAULT_PARTITION_EXPIRATION_MS)
  private String defaultPartitionExpirationMs;

  /**
   * Optional. Defines the default rounding mode specification of new tables created within this dataset. During table creation, if this field is specified, the table within this dataset will inherit the default rounding mode of the dataset. Setting the default rounding mode on a table overrides this option. Existing tables in the dataset are unaffected. If columns are defined during that table creation, they will immediately inherit the table&#39;s default rounding mode, unless otherwise specified.
   */
  @JsonAdapter(DefaultRoundingModeEnum.Adapter.class)
  public enum DefaultRoundingModeEnum {
    ROUNDING_MODE_UNSPECIFIED("ROUNDING_MODE_UNSPECIFIED"),
    
    ROUND_HALF_AWAY_FROM_ZERO("ROUND_HALF_AWAY_FROM_ZERO"),
    
    ROUND_HALF_EVEN("ROUND_HALF_EVEN");

    private String value;

    DefaultRoundingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultRoundingModeEnum fromValue(String value) {
      for (DefaultRoundingModeEnum b : DefaultRoundingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultRoundingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultRoundingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultRoundingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DefaultRoundingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DefaultRoundingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_ROUNDING_MODE = "defaultRoundingMode";
  @SerializedName(SERIALIZED_NAME_DEFAULT_ROUNDING_MODE)
  private DefaultRoundingModeEnum defaultRoundingMode;

  public static final String SERIALIZED_NAME_DEFAULT_TABLE_EXPIRATION_MS = "defaultTableExpirationMs";
  @SerializedName(SERIALIZED_NAME_DEFAULT_TABLE_EXPIRATION_MS)
  private String defaultTableExpirationMs;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_EXTERNAL_DATASET_REFERENCE = "externalDatasetReference";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_DATASET_REFERENCE)
  private ExternalDatasetReference externalDatasetReference;

  public static final String SERIALIZED_NAME_FRIENDLY_NAME = "friendlyName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_NAME)
  private String friendlyName;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IS_CASE_INSENSITIVE = "isCaseInsensitive";
  @SerializedName(SERIALIZED_NAME_IS_CASE_INSENSITIVE)
  private Boolean isCaseInsensitive;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "bigquery#dataset";

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LAST_MODIFIED_TIME = "lastModifiedTime";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED_TIME)
  private String lastModifiedTime;

  public static final String SERIALIZED_NAME_LINKED_DATASET_SOURCE = "linkedDatasetSource";
  @SerializedName(SERIALIZED_NAME_LINKED_DATASET_SOURCE)
  private LinkedDatasetSource linkedDatasetSource;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_MAX_TIME_TRAVEL_HOURS = "maxTimeTravelHours";
  @SerializedName(SERIALIZED_NAME_MAX_TIME_TRAVEL_HOURS)
  private String maxTimeTravelHours;

  public static final String SERIALIZED_NAME_SATISFIES_PZI = "satisfiesPzi";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZI)
  private Boolean satisfiesPzi;

  public static final String SERIALIZED_NAME_SATISFIES_PZS = "satisfiesPzs";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZS)
  private Boolean satisfiesPzs;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  /**
   * Optional. Updates storage_billing_model for the dataset.
   */
  @JsonAdapter(StorageBillingModelEnum.Adapter.class)
  public enum StorageBillingModelEnum {
    STORAGE_BILLING_MODEL_UNSPECIFIED("STORAGE_BILLING_MODEL_UNSPECIFIED"),
    
    LOGICAL("LOGICAL"),
    
    PHYSICAL("PHYSICAL");

    private String value;

    StorageBillingModelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StorageBillingModelEnum fromValue(String value) {
      for (StorageBillingModelEnum b : StorageBillingModelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StorageBillingModelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StorageBillingModelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StorageBillingModelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StorageBillingModelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StorageBillingModelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STORAGE_BILLING_MODEL = "storageBillingModel";
  @SerializedName(SERIALIZED_NAME_STORAGE_BILLING_MODEL)
  private StorageBillingModelEnum storageBillingModel;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<DatasetTagsInner> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public Dataset() {
  }

  public Dataset(
     String creationTime, 
     String etag, 
     String id, 
     String kind, 
     String lastModifiedTime, 
     Boolean satisfiesPzi, 
     Boolean satisfiesPzs, 
     String selfLink, 
     List<DatasetTagsInner> tags, 
     String type
  ) {
    this();
    this.creationTime = creationTime;
    this.etag = etag;
    this.id = id;
    this.kind = kind;
    this.lastModifiedTime = lastModifiedTime;
    this.satisfiesPzi = satisfiesPzi;
    this.satisfiesPzs = satisfiesPzs;
    this.selfLink = selfLink;
    this.tags = tags;
    this.type = type;
  }

  public Dataset access(List<DatasetAccessInner> access) {
    this.access = access;
    return this;
  }

  public Dataset addAccessItem(DatasetAccessInner accessItem) {
    if (this.access == null) {
      this.access = new ArrayList<>();
    }
    this.access.add(accessItem);
    return this;
  }

  /**
   * Optional. An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.role: OWNER; access.userByEmail: [dataset creator email]; access.role: OWNER;
   * @return access
   */
  @javax.annotation.Nullable
  public List<DatasetAccessInner> getAccess() {
    return access;
  }

  public void setAccess(List<DatasetAccessInner> access) {
    this.access = access;
  }


  /**
   * Output only. The time when this dataset was created, in milliseconds since the epoch.
   * @return creationTime
   */
  @javax.annotation.Nullable
  public String getCreationTime() {
    return creationTime;
  }



  public Dataset datasetReference(DatasetReference datasetReference) {
    this.datasetReference = datasetReference;
    return this;
  }

  /**
   * Get datasetReference
   * @return datasetReference
   */
  @javax.annotation.Nullable
  public DatasetReference getDatasetReference() {
    return datasetReference;
  }

  public void setDatasetReference(DatasetReference datasetReference) {
    this.datasetReference = datasetReference;
  }


  public Dataset defaultCollation(String defaultCollation) {
    this.defaultCollation = defaultCollation;
    return this;
  }

  /**
   * Optional. Defines the default collation specification of future tables created in the dataset. If a table is created in this dataset without table-level default collation, then the table inherits the dataset default collation, which is applied to the string fields that do not have explicit collation specified. A change to this field affects only tables created afterwards, and does not alter the existing tables. The following values are supported: * &#39;und:ci&#39;: undetermined locale, case insensitive. * &#39;&#39;: empty string. Default to case-sensitive behavior.
   * @return defaultCollation
   */
  @javax.annotation.Nullable
  public String getDefaultCollation() {
    return defaultCollation;
  }

  public void setDefaultCollation(String defaultCollation) {
    this.defaultCollation = defaultCollation;
  }


  public Dataset defaultEncryptionConfiguration(EncryptionConfiguration defaultEncryptionConfiguration) {
    this.defaultEncryptionConfiguration = defaultEncryptionConfiguration;
    return this;
  }

  /**
   * Get defaultEncryptionConfiguration
   * @return defaultEncryptionConfiguration
   */
  @javax.annotation.Nullable
  public EncryptionConfiguration getDefaultEncryptionConfiguration() {
    return defaultEncryptionConfiguration;
  }

  public void setDefaultEncryptionConfiguration(EncryptionConfiguration defaultEncryptionConfiguration) {
    this.defaultEncryptionConfiguration = defaultEncryptionConfiguration;
  }


  public Dataset defaultPartitionExpirationMs(String defaultPartitionExpirationMs) {
    this.defaultPartitionExpirationMs = defaultPartitionExpirationMs;
    return this;
  }

  /**
   * This default partition expiration, expressed in milliseconds. When new time-partitioned tables are created in a dataset where this property is set, the table will inherit this value, propagated as the &#x60;TimePartitioning.expirationMs&#x60; property on the new table. If you set &#x60;TimePartitioning.expirationMs&#x60; explicitly when creating a table, the &#x60;defaultPartitionExpirationMs&#x60; of the containing dataset is ignored. When creating a partitioned table, if &#x60;defaultPartitionExpirationMs&#x60; is set, the &#x60;defaultTableExpirationMs&#x60; value is ignored and the table will not be inherit a table expiration deadline.
   * @return defaultPartitionExpirationMs
   */
  @javax.annotation.Nullable
  public String getDefaultPartitionExpirationMs() {
    return defaultPartitionExpirationMs;
  }

  public void setDefaultPartitionExpirationMs(String defaultPartitionExpirationMs) {
    this.defaultPartitionExpirationMs = defaultPartitionExpirationMs;
  }


  public Dataset defaultRoundingMode(DefaultRoundingModeEnum defaultRoundingMode) {
    this.defaultRoundingMode = defaultRoundingMode;
    return this;
  }

  /**
   * Optional. Defines the default rounding mode specification of new tables created within this dataset. During table creation, if this field is specified, the table within this dataset will inherit the default rounding mode of the dataset. Setting the default rounding mode on a table overrides this option. Existing tables in the dataset are unaffected. If columns are defined during that table creation, they will immediately inherit the table&#39;s default rounding mode, unless otherwise specified.
   * @return defaultRoundingMode
   */
  @javax.annotation.Nullable
  public DefaultRoundingModeEnum getDefaultRoundingMode() {
    return defaultRoundingMode;
  }

  public void setDefaultRoundingMode(DefaultRoundingModeEnum defaultRoundingMode) {
    this.defaultRoundingMode = defaultRoundingMode;
  }


  public Dataset defaultTableExpirationMs(String defaultTableExpirationMs) {
    this.defaultTableExpirationMs = defaultTableExpirationMs;
    return this;
  }

  /**
   * Optional. The default lifetime of all tables in the dataset, in milliseconds. The minimum lifetime value is 3600000 milliseconds (one hour). To clear an existing default expiration with a PATCH request, set to 0. Once this property is set, all newly-created tables in the dataset will have an expirationTime property set to the creation time plus the value in this property, and changing the value will only affect new tables, not existing ones. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table&#39;s expirationTime is modified or removed before the table expires, or if you provide an explicit expirationTime when creating a table, that value takes precedence over the default expiration time indicated by this property.
   * @return defaultTableExpirationMs
   */
  @javax.annotation.Nullable
  public String getDefaultTableExpirationMs() {
    return defaultTableExpirationMs;
  }

  public void setDefaultTableExpirationMs(String defaultTableExpirationMs) {
    this.defaultTableExpirationMs = defaultTableExpirationMs;
  }


  public Dataset description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. A user-friendly description of the dataset.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  /**
   * Output only. A hash of the resource.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }



  public Dataset externalDatasetReference(ExternalDatasetReference externalDatasetReference) {
    this.externalDatasetReference = externalDatasetReference;
    return this;
  }

  /**
   * Get externalDatasetReference
   * @return externalDatasetReference
   */
  @javax.annotation.Nullable
  public ExternalDatasetReference getExternalDatasetReference() {
    return externalDatasetReference;
  }

  public void setExternalDatasetReference(ExternalDatasetReference externalDatasetReference) {
    this.externalDatasetReference = externalDatasetReference;
  }


  public Dataset friendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
    return this;
  }

  /**
   * Optional. A descriptive name for the dataset.
   * @return friendlyName
   */
  @javax.annotation.Nullable
  public String getFriendlyName() {
    return friendlyName;
  }

  public void setFriendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
  }


  /**
   * Output only. The fully-qualified unique name of the dataset in the format projectId:datasetId. The dataset name without the project name is given in the datasetId field. When creating a new dataset, leave this field blank, and instead specify the datasetId field.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public Dataset isCaseInsensitive(Boolean isCaseInsensitive) {
    this.isCaseInsensitive = isCaseInsensitive;
    return this;
  }

  /**
   * Optional. TRUE if the dataset and its table names are case-insensitive, otherwise FALSE. By default, this is FALSE, which means the dataset and its table names are case-sensitive. This field does not affect routine references.
   * @return isCaseInsensitive
   */
  @javax.annotation.Nullable
  public Boolean getIsCaseInsensitive() {
    return isCaseInsensitive;
  }

  public void setIsCaseInsensitive(Boolean isCaseInsensitive) {
    this.isCaseInsensitive = isCaseInsensitive;
  }


  /**
   * Output only. The resource type.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }



  public Dataset labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Dataset putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The labels associated with this dataset. You can use these to organize and group your datasets. You can set this property when inserting or updating a dataset. See Creating and Updating Dataset Labels for more information.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  /**
   * Output only. The date when this dataset was last modified, in milliseconds since the epoch.
   * @return lastModifiedTime
   */
  @javax.annotation.Nullable
  public String getLastModifiedTime() {
    return lastModifiedTime;
  }



  public Dataset linkedDatasetSource(LinkedDatasetSource linkedDatasetSource) {
    this.linkedDatasetSource = linkedDatasetSource;
    return this;
  }

  /**
   * Get linkedDatasetSource
   * @return linkedDatasetSource
   */
  @javax.annotation.Nullable
  public LinkedDatasetSource getLinkedDatasetSource() {
    return linkedDatasetSource;
  }

  public void setLinkedDatasetSource(LinkedDatasetSource linkedDatasetSource) {
    this.linkedDatasetSource = linkedDatasetSource;
  }


  public Dataset location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The geographic location where the dataset should reside. See https://cloud.google.com/bigquery/docs/locations for supported locations.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public Dataset maxTimeTravelHours(String maxTimeTravelHours) {
    this.maxTimeTravelHours = maxTimeTravelHours;
    return this;
  }

  /**
   * Optional. Defines the time travel window in hours. The value can be from 48 to 168 hours (2 to 7 days). The default value is 168 hours if this is not set.
   * @return maxTimeTravelHours
   */
  @javax.annotation.Nullable
  public String getMaxTimeTravelHours() {
    return maxTimeTravelHours;
  }

  public void setMaxTimeTravelHours(String maxTimeTravelHours) {
    this.maxTimeTravelHours = maxTimeTravelHours;
  }


  /**
   * Output only. Reserved for future use.
   * @return satisfiesPzi
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzi() {
    return satisfiesPzi;
  }



  /**
   * Output only. Reserved for future use.
   * @return satisfiesPzs
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzs() {
    return satisfiesPzs;
  }



  /**
   * Output only. A URL that can be used to access the resource again. You can use this URL in Get or Update requests to the resource.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }



  public Dataset storageBillingModel(StorageBillingModelEnum storageBillingModel) {
    this.storageBillingModel = storageBillingModel;
    return this;
  }

  /**
   * Optional. Updates storage_billing_model for the dataset.
   * @return storageBillingModel
   */
  @javax.annotation.Nullable
  public StorageBillingModelEnum getStorageBillingModel() {
    return storageBillingModel;
  }

  public void setStorageBillingModel(StorageBillingModelEnum storageBillingModel) {
    this.storageBillingModel = storageBillingModel;
  }


  /**
   * Output only. Tags for the Dataset.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<DatasetTagsInner> getTags() {
    return tags;
  }



  /**
   * Output only. Same as &#x60;type&#x60; in &#x60;ListFormatDataset&#x60;. The type of the dataset, one of: * DEFAULT - only accessible by owner and authorized accounts, * PUBLIC - accessible by everyone, * LINKED - linked dataset, * EXTERNAL - dataset with definition in external metadata catalog. -- *BIGLAKE_METASTORE - dataset that references a database created in BigLakeMetastore service. --
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Dataset dataset = (Dataset) o;
    return Objects.equals(this.access, dataset.access) &&
        Objects.equals(this.creationTime, dataset.creationTime) &&
        Objects.equals(this.datasetReference, dataset.datasetReference) &&
        Objects.equals(this.defaultCollation, dataset.defaultCollation) &&
        Objects.equals(this.defaultEncryptionConfiguration, dataset.defaultEncryptionConfiguration) &&
        Objects.equals(this.defaultPartitionExpirationMs, dataset.defaultPartitionExpirationMs) &&
        Objects.equals(this.defaultRoundingMode, dataset.defaultRoundingMode) &&
        Objects.equals(this.defaultTableExpirationMs, dataset.defaultTableExpirationMs) &&
        Objects.equals(this.description, dataset.description) &&
        Objects.equals(this.etag, dataset.etag) &&
        Objects.equals(this.externalDatasetReference, dataset.externalDatasetReference) &&
        Objects.equals(this.friendlyName, dataset.friendlyName) &&
        Objects.equals(this.id, dataset.id) &&
        Objects.equals(this.isCaseInsensitive, dataset.isCaseInsensitive) &&
        Objects.equals(this.kind, dataset.kind) &&
        Objects.equals(this.labels, dataset.labels) &&
        Objects.equals(this.lastModifiedTime, dataset.lastModifiedTime) &&
        Objects.equals(this.linkedDatasetSource, dataset.linkedDatasetSource) &&
        Objects.equals(this.location, dataset.location) &&
        Objects.equals(this.maxTimeTravelHours, dataset.maxTimeTravelHours) &&
        Objects.equals(this.satisfiesPzi, dataset.satisfiesPzi) &&
        Objects.equals(this.satisfiesPzs, dataset.satisfiesPzs) &&
        Objects.equals(this.selfLink, dataset.selfLink) &&
        Objects.equals(this.storageBillingModel, dataset.storageBillingModel) &&
        Objects.equals(this.tags, dataset.tags) &&
        Objects.equals(this.type, dataset.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(access, creationTime, datasetReference, defaultCollation, defaultEncryptionConfiguration, defaultPartitionExpirationMs, defaultRoundingMode, defaultTableExpirationMs, description, etag, externalDatasetReference, friendlyName, id, isCaseInsensitive, kind, labels, lastModifiedTime, linkedDatasetSource, location, maxTimeTravelHours, satisfiesPzi, satisfiesPzs, selfLink, storageBillingModel, tags, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Dataset {\n");
    sb.append("    access: ").append(toIndentedString(access)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    datasetReference: ").append(toIndentedString(datasetReference)).append("\n");
    sb.append("    defaultCollation: ").append(toIndentedString(defaultCollation)).append("\n");
    sb.append("    defaultEncryptionConfiguration: ").append(toIndentedString(defaultEncryptionConfiguration)).append("\n");
    sb.append("    defaultPartitionExpirationMs: ").append(toIndentedString(defaultPartitionExpirationMs)).append("\n");
    sb.append("    defaultRoundingMode: ").append(toIndentedString(defaultRoundingMode)).append("\n");
    sb.append("    defaultTableExpirationMs: ").append(toIndentedString(defaultTableExpirationMs)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    externalDatasetReference: ").append(toIndentedString(externalDatasetReference)).append("\n");
    sb.append("    friendlyName: ").append(toIndentedString(friendlyName)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isCaseInsensitive: ").append(toIndentedString(isCaseInsensitive)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lastModifiedTime: ").append(toIndentedString(lastModifiedTime)).append("\n");
    sb.append("    linkedDatasetSource: ").append(toIndentedString(linkedDatasetSource)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    maxTimeTravelHours: ").append(toIndentedString(maxTimeTravelHours)).append("\n");
    sb.append("    satisfiesPzi: ").append(toIndentedString(satisfiesPzi)).append("\n");
    sb.append("    satisfiesPzs: ").append(toIndentedString(satisfiesPzs)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    storageBillingModel: ").append(toIndentedString(storageBillingModel)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("access");
    openapiFields.add("creationTime");
    openapiFields.add("datasetReference");
    openapiFields.add("defaultCollation");
    openapiFields.add("defaultEncryptionConfiguration");
    openapiFields.add("defaultPartitionExpirationMs");
    openapiFields.add("defaultRoundingMode");
    openapiFields.add("defaultTableExpirationMs");
    openapiFields.add("description");
    openapiFields.add("etag");
    openapiFields.add("externalDatasetReference");
    openapiFields.add("friendlyName");
    openapiFields.add("id");
    openapiFields.add("isCaseInsensitive");
    openapiFields.add("kind");
    openapiFields.add("labels");
    openapiFields.add("lastModifiedTime");
    openapiFields.add("linkedDatasetSource");
    openapiFields.add("location");
    openapiFields.add("maxTimeTravelHours");
    openapiFields.add("satisfiesPzi");
    openapiFields.add("satisfiesPzs");
    openapiFields.add("selfLink");
    openapiFields.add("storageBillingModel");
    openapiFields.add("tags");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Dataset
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Dataset.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Dataset is not found in the empty JSON string", Dataset.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Dataset.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Dataset` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("access") != null && !jsonObj.get("access").isJsonNull()) {
        JsonArray jsonArrayaccess = jsonObj.getAsJsonArray("access");
        if (jsonArrayaccess != null) {
          // ensure the json data is an array
          if (!jsonObj.get("access").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `access` to be an array in the JSON string but got `%s`", jsonObj.get("access").toString()));
          }

          // validate the optional field `access` (array)
          for (int i = 0; i < jsonArrayaccess.size(); i++) {
            DatasetAccessInner.validateJsonElement(jsonArrayaccess.get(i));
          };
        }
      }
      if ((jsonObj.get("creationTime") != null && !jsonObj.get("creationTime").isJsonNull()) && !jsonObj.get("creationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creationTime").toString()));
      }
      // validate the optional field `datasetReference`
      if (jsonObj.get("datasetReference") != null && !jsonObj.get("datasetReference").isJsonNull()) {
        DatasetReference.validateJsonElement(jsonObj.get("datasetReference"));
      }
      if ((jsonObj.get("defaultCollation") != null && !jsonObj.get("defaultCollation").isJsonNull()) && !jsonObj.get("defaultCollation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultCollation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultCollation").toString()));
      }
      // validate the optional field `defaultEncryptionConfiguration`
      if (jsonObj.get("defaultEncryptionConfiguration") != null && !jsonObj.get("defaultEncryptionConfiguration").isJsonNull()) {
        EncryptionConfiguration.validateJsonElement(jsonObj.get("defaultEncryptionConfiguration"));
      }
      if ((jsonObj.get("defaultPartitionExpirationMs") != null && !jsonObj.get("defaultPartitionExpirationMs").isJsonNull()) && !jsonObj.get("defaultPartitionExpirationMs").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultPartitionExpirationMs` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultPartitionExpirationMs").toString()));
      }
      if ((jsonObj.get("defaultRoundingMode") != null && !jsonObj.get("defaultRoundingMode").isJsonNull()) && !jsonObj.get("defaultRoundingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultRoundingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultRoundingMode").toString()));
      }
      // validate the optional field `defaultRoundingMode`
      if (jsonObj.get("defaultRoundingMode") != null && !jsonObj.get("defaultRoundingMode").isJsonNull()) {
        DefaultRoundingModeEnum.validateJsonElement(jsonObj.get("defaultRoundingMode"));
      }
      if ((jsonObj.get("defaultTableExpirationMs") != null && !jsonObj.get("defaultTableExpirationMs").isJsonNull()) && !jsonObj.get("defaultTableExpirationMs").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultTableExpirationMs` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultTableExpirationMs").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      // validate the optional field `externalDatasetReference`
      if (jsonObj.get("externalDatasetReference") != null && !jsonObj.get("externalDatasetReference").isJsonNull()) {
        ExternalDatasetReference.validateJsonElement(jsonObj.get("externalDatasetReference"));
      }
      if ((jsonObj.get("friendlyName") != null && !jsonObj.get("friendlyName").isJsonNull()) && !jsonObj.get("friendlyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlyName").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("lastModifiedTime") != null && !jsonObj.get("lastModifiedTime").isJsonNull()) && !jsonObj.get("lastModifiedTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastModifiedTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastModifiedTime").toString()));
      }
      // validate the optional field `linkedDatasetSource`
      if (jsonObj.get("linkedDatasetSource") != null && !jsonObj.get("linkedDatasetSource").isJsonNull()) {
        LinkedDatasetSource.validateJsonElement(jsonObj.get("linkedDatasetSource"));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("maxTimeTravelHours") != null && !jsonObj.get("maxTimeTravelHours").isJsonNull()) && !jsonObj.get("maxTimeTravelHours").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxTimeTravelHours` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxTimeTravelHours").toString()));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      if ((jsonObj.get("storageBillingModel") != null && !jsonObj.get("storageBillingModel").isJsonNull()) && !jsonObj.get("storageBillingModel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageBillingModel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageBillingModel").toString()));
      }
      // validate the optional field `storageBillingModel`
      if (jsonObj.get("storageBillingModel") != null && !jsonObj.get("storageBillingModel").isJsonNull()) {
        StorageBillingModelEnum.validateJsonElement(jsonObj.get("storageBillingModel"));
      }
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull()) {
        JsonArray jsonArraytags = jsonObj.getAsJsonArray("tags");
        if (jsonArraytags != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tags").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
          }

          // validate the optional field `tags` (array)
          for (int i = 0; i < jsonArraytags.size(); i++) {
            DatasetTagsInner.validateJsonElement(jsonArraytags.get(i));
          };
        }
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Dataset.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Dataset' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Dataset> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Dataset.class));

       return (TypeAdapter<T>) new TypeAdapter<Dataset>() {
           @Override
           public void write(JsonWriter out, Dataset value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Dataset read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Dataset given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Dataset
   * @throws IOException if the JSON string is invalid with respect to Dataset
   */
  public static Dataset fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Dataset.class);
  }

  /**
   * Convert an instance of Dataset to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

