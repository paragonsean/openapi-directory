/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information related to a CSV data source.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CsvOptions {
  public static final String SERIALIZED_NAME_ALLOW_JAGGED_ROWS = "allowJaggedRows";
  @SerializedName(SERIALIZED_NAME_ALLOW_JAGGED_ROWS)
  private Boolean allowJaggedRows;

  public static final String SERIALIZED_NAME_ALLOW_QUOTED_NEWLINES = "allowQuotedNewlines";
  @SerializedName(SERIALIZED_NAME_ALLOW_QUOTED_NEWLINES)
  private Boolean allowQuotedNewlines;

  public static final String SERIALIZED_NAME_ENCODING = "encoding";
  @SerializedName(SERIALIZED_NAME_ENCODING)
  private String encoding;

  public static final String SERIALIZED_NAME_FIELD_DELIMITER = "fieldDelimiter";
  @SerializedName(SERIALIZED_NAME_FIELD_DELIMITER)
  private String fieldDelimiter;

  public static final String SERIALIZED_NAME_NULL_MARKER = "nullMarker";
  @SerializedName(SERIALIZED_NAME_NULL_MARKER)
  private String nullMarker;

  public static final String SERIALIZED_NAME_PRESERVE_ASCII_CONTROL_CHARACTERS = "preserveAsciiControlCharacters";
  @SerializedName(SERIALIZED_NAME_PRESERVE_ASCII_CONTROL_CHARACTERS)
  private Boolean preserveAsciiControlCharacters;

  public static final String SERIALIZED_NAME_QUOTE = "quote";
  @SerializedName(SERIALIZED_NAME_QUOTE)
  private String quote = "\"";

  public static final String SERIALIZED_NAME_SKIP_LEADING_ROWS = "skipLeadingRows";
  @SerializedName(SERIALIZED_NAME_SKIP_LEADING_ROWS)
  private String skipLeadingRows;

  public CsvOptions() {
  }

  public CsvOptions allowJaggedRows(Boolean allowJaggedRows) {
    this.allowJaggedRows = allowJaggedRows;
    return this;
  }

  /**
   * Optional. Indicates if BigQuery should accept rows that are missing trailing optional columns. If true, BigQuery treats missing trailing columns as null values. If false, records with missing trailing columns are treated as bad records, and if there are too many bad records, an invalid error is returned in the job result. The default value is false.
   * @return allowJaggedRows
   */
  @javax.annotation.Nullable
  public Boolean getAllowJaggedRows() {
    return allowJaggedRows;
  }

  public void setAllowJaggedRows(Boolean allowJaggedRows) {
    this.allowJaggedRows = allowJaggedRows;
  }


  public CsvOptions allowQuotedNewlines(Boolean allowQuotedNewlines) {
    this.allowQuotedNewlines = allowQuotedNewlines;
    return this;
  }

  /**
   * Optional. Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file. The default value is false.
   * @return allowQuotedNewlines
   */
  @javax.annotation.Nullable
  public Boolean getAllowQuotedNewlines() {
    return allowQuotedNewlines;
  }

  public void setAllowQuotedNewlines(Boolean allowQuotedNewlines) {
    this.allowQuotedNewlines = allowQuotedNewlines;
  }


  public CsvOptions encoding(String encoding) {
    this.encoding = encoding;
    return this;
  }

  /**
   * Optional. The character encoding of the data. The supported values are UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8. BigQuery decodes the data after the raw, binary data has been split using the values of the quote and fieldDelimiter properties.
   * @return encoding
   */
  @javax.annotation.Nullable
  public String getEncoding() {
    return encoding;
  }

  public void setEncoding(String encoding) {
    this.encoding = encoding;
  }


  public CsvOptions fieldDelimiter(String fieldDelimiter) {
    this.fieldDelimiter = fieldDelimiter;
    return this;
  }

  /**
   * Optional. The separator character for fields in a CSV file. The separator is interpreted as a single byte. For files encoded in ISO-8859-1, any single character can be used as a separator. For files encoded in UTF-8, characters represented in decimal range 1-127 (U+0001-U+007F) can be used without any modification. UTF-8 characters encoded with multiple bytes (i.e. U+0080 and above) will have only the first byte used for separating fields. The remaining bytes will be treated as a part of the field. BigQuery also supports the escape sequence \&quot;\\t\&quot; (U+0009) to specify a tab separator. The default value is comma (\&quot;,\&quot;, U+002C).
   * @return fieldDelimiter
   */
  @javax.annotation.Nullable
  public String getFieldDelimiter() {
    return fieldDelimiter;
  }

  public void setFieldDelimiter(String fieldDelimiter) {
    this.fieldDelimiter = fieldDelimiter;
  }


  public CsvOptions nullMarker(String nullMarker) {
    this.nullMarker = nullMarker;
    return this;
  }

  /**
   * [Optional] A custom string that will represent a NULL value in CSV import data.
   * @return nullMarker
   */
  @javax.annotation.Nullable
  public String getNullMarker() {
    return nullMarker;
  }

  public void setNullMarker(String nullMarker) {
    this.nullMarker = nullMarker;
  }


  public CsvOptions preserveAsciiControlCharacters(Boolean preserveAsciiControlCharacters) {
    this.preserveAsciiControlCharacters = preserveAsciiControlCharacters;
    return this;
  }

  /**
   * Optional. Indicates if the embedded ASCII control characters (the first 32 characters in the ASCII-table, from &#39;\\x00&#39; to &#39;\\x1F&#39;) are preserved.
   * @return preserveAsciiControlCharacters
   */
  @javax.annotation.Nullable
  public Boolean getPreserveAsciiControlCharacters() {
    return preserveAsciiControlCharacters;
  }

  public void setPreserveAsciiControlCharacters(Boolean preserveAsciiControlCharacters) {
    this.preserveAsciiControlCharacters = preserveAsciiControlCharacters;
  }


  public CsvOptions quote(String quote) {
    this.quote = quote;
    return this;
  }

  /**
   * Optional. The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the data in its raw, binary state. The default value is a double-quote (\&quot;). If your data does not contain quoted sections, set the property value to an empty string. If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true. To include the specific quote character within a quoted value, precede it with an additional matching quote character. For example, if you want to escape the default character &#39; \&quot; &#39;, use &#39; \&quot;\&quot; &#39;.
   * @return quote
   */
  @javax.annotation.Nullable
  public String getQuote() {
    return quote;
  }

  public void setQuote(String quote) {
    this.quote = quote;
  }


  public CsvOptions skipLeadingRows(String skipLeadingRows) {
    this.skipLeadingRows = skipLeadingRows;
    return this;
  }

  /**
   * Optional. The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped. When autodetect is on, the behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected, the row is read as data. Otherwise data is read starting from the second row. * skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row. * skipLeadingRows &#x3D; N &gt; 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected, row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
   * @return skipLeadingRows
   */
  @javax.annotation.Nullable
  public String getSkipLeadingRows() {
    return skipLeadingRows;
  }

  public void setSkipLeadingRows(String skipLeadingRows) {
    this.skipLeadingRows = skipLeadingRows;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CsvOptions csvOptions = (CsvOptions) o;
    return Objects.equals(this.allowJaggedRows, csvOptions.allowJaggedRows) &&
        Objects.equals(this.allowQuotedNewlines, csvOptions.allowQuotedNewlines) &&
        Objects.equals(this.encoding, csvOptions.encoding) &&
        Objects.equals(this.fieldDelimiter, csvOptions.fieldDelimiter) &&
        Objects.equals(this.nullMarker, csvOptions.nullMarker) &&
        Objects.equals(this.preserveAsciiControlCharacters, csvOptions.preserveAsciiControlCharacters) &&
        Objects.equals(this.quote, csvOptions.quote) &&
        Objects.equals(this.skipLeadingRows, csvOptions.skipLeadingRows);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowJaggedRows, allowQuotedNewlines, encoding, fieldDelimiter, nullMarker, preserveAsciiControlCharacters, quote, skipLeadingRows);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CsvOptions {\n");
    sb.append("    allowJaggedRows: ").append(toIndentedString(allowJaggedRows)).append("\n");
    sb.append("    allowQuotedNewlines: ").append(toIndentedString(allowQuotedNewlines)).append("\n");
    sb.append("    encoding: ").append(toIndentedString(encoding)).append("\n");
    sb.append("    fieldDelimiter: ").append(toIndentedString(fieldDelimiter)).append("\n");
    sb.append("    nullMarker: ").append(toIndentedString(nullMarker)).append("\n");
    sb.append("    preserveAsciiControlCharacters: ").append(toIndentedString(preserveAsciiControlCharacters)).append("\n");
    sb.append("    quote: ").append(toIndentedString(quote)).append("\n");
    sb.append("    skipLeadingRows: ").append(toIndentedString(skipLeadingRows)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowJaggedRows");
    openapiFields.add("allowQuotedNewlines");
    openapiFields.add("encoding");
    openapiFields.add("fieldDelimiter");
    openapiFields.add("nullMarker");
    openapiFields.add("preserveAsciiControlCharacters");
    openapiFields.add("quote");
    openapiFields.add("skipLeadingRows");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CsvOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CsvOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CsvOptions is not found in the empty JSON string", CsvOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CsvOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CsvOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("encoding") != null && !jsonObj.get("encoding").isJsonNull()) && !jsonObj.get("encoding").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encoding` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encoding").toString()));
      }
      if ((jsonObj.get("fieldDelimiter") != null && !jsonObj.get("fieldDelimiter").isJsonNull()) && !jsonObj.get("fieldDelimiter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fieldDelimiter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fieldDelimiter").toString()));
      }
      if ((jsonObj.get("nullMarker") != null && !jsonObj.get("nullMarker").isJsonNull()) && !jsonObj.get("nullMarker").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nullMarker` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nullMarker").toString()));
      }
      if ((jsonObj.get("quote") != null && !jsonObj.get("quote").isJsonNull()) && !jsonObj.get("quote").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quote` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quote").toString()));
      }
      if ((jsonObj.get("skipLeadingRows") != null && !jsonObj.get("skipLeadingRows").isJsonNull()) && !jsonObj.get("skipLeadingRows").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `skipLeadingRows` to be a primitive type in the JSON string but got `%s`", jsonObj.get("skipLeadingRows").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CsvOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CsvOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CsvOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CsvOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<CsvOptions>() {
           @Override
           public void write(JsonWriter out, CsvOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CsvOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CsvOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CsvOptions
   * @throws IOException if the JSON string is invalid with respect to CsvOptions
   */
  public static CsvOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CsvOptions.class);
  }

  /**
   * Convert an instance of CsvOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

