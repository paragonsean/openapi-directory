/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BigtableColumnFamily;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options specific to Google Cloud Bigtable data sources.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BigtableOptions {
  public static final String SERIALIZED_NAME_COLUMN_FAMILIES = "columnFamilies";
  @SerializedName(SERIALIZED_NAME_COLUMN_FAMILIES)
  private List<BigtableColumnFamily> columnFamilies = new ArrayList<>();

  public static final String SERIALIZED_NAME_IGNORE_UNSPECIFIED_COLUMN_FAMILIES = "ignoreUnspecifiedColumnFamilies";
  @SerializedName(SERIALIZED_NAME_IGNORE_UNSPECIFIED_COLUMN_FAMILIES)
  private Boolean ignoreUnspecifiedColumnFamilies;

  public static final String SERIALIZED_NAME_OUTPUT_COLUMN_FAMILIES_AS_JSON = "outputColumnFamiliesAsJson";
  @SerializedName(SERIALIZED_NAME_OUTPUT_COLUMN_FAMILIES_AS_JSON)
  private Boolean outputColumnFamiliesAsJson;

  public static final String SERIALIZED_NAME_READ_ROWKEY_AS_STRING = "readRowkeyAsString";
  @SerializedName(SERIALIZED_NAME_READ_ROWKEY_AS_STRING)
  private Boolean readRowkeyAsString;

  public BigtableOptions() {
  }

  public BigtableOptions columnFamilies(List<BigtableColumnFamily> columnFamilies) {
    this.columnFamilies = columnFamilies;
    return this;
  }

  public BigtableOptions addColumnFamiliesItem(BigtableColumnFamily columnFamiliesItem) {
    if (this.columnFamilies == null) {
      this.columnFamilies = new ArrayList<>();
    }
    this.columnFamilies.add(columnFamiliesItem);
    return this;
  }

  /**
   * Optional. List of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the &#39;type&#39; field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.
   * @return columnFamilies
   */
  @javax.annotation.Nullable
  public List<BigtableColumnFamily> getColumnFamilies() {
    return columnFamilies;
  }

  public void setColumnFamilies(List<BigtableColumnFamily> columnFamilies) {
    this.columnFamilies = columnFamilies;
  }


  public BigtableOptions ignoreUnspecifiedColumnFamilies(Boolean ignoreUnspecifiedColumnFamilies) {
    this.ignoreUnspecifiedColumnFamilies = ignoreUnspecifiedColumnFamilies;
    return this;
  }

  /**
   * Optional. If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
   * @return ignoreUnspecifiedColumnFamilies
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreUnspecifiedColumnFamilies() {
    return ignoreUnspecifiedColumnFamilies;
  }

  public void setIgnoreUnspecifiedColumnFamilies(Boolean ignoreUnspecifiedColumnFamilies) {
    this.ignoreUnspecifiedColumnFamilies = ignoreUnspecifiedColumnFamilies;
  }


  public BigtableOptions outputColumnFamiliesAsJson(Boolean outputColumnFamiliesAsJson) {
    this.outputColumnFamiliesAsJson = outputColumnFamiliesAsJson;
    return this;
  }

  /**
   * Optional. If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
   * @return outputColumnFamiliesAsJson
   */
  @javax.annotation.Nullable
  public Boolean getOutputColumnFamiliesAsJson() {
    return outputColumnFamiliesAsJson;
  }

  public void setOutputColumnFamiliesAsJson(Boolean outputColumnFamiliesAsJson) {
    this.outputColumnFamiliesAsJson = outputColumnFamiliesAsJson;
  }


  public BigtableOptions readRowkeyAsString(Boolean readRowkeyAsString) {
    this.readRowkeyAsString = readRowkeyAsString;
    return this;
  }

  /**
   * Optional. If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
   * @return readRowkeyAsString
   */
  @javax.annotation.Nullable
  public Boolean getReadRowkeyAsString() {
    return readRowkeyAsString;
  }

  public void setReadRowkeyAsString(Boolean readRowkeyAsString) {
    this.readRowkeyAsString = readRowkeyAsString;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BigtableOptions bigtableOptions = (BigtableOptions) o;
    return Objects.equals(this.columnFamilies, bigtableOptions.columnFamilies) &&
        Objects.equals(this.ignoreUnspecifiedColumnFamilies, bigtableOptions.ignoreUnspecifiedColumnFamilies) &&
        Objects.equals(this.outputColumnFamiliesAsJson, bigtableOptions.outputColumnFamiliesAsJson) &&
        Objects.equals(this.readRowkeyAsString, bigtableOptions.readRowkeyAsString);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columnFamilies, ignoreUnspecifiedColumnFamilies, outputColumnFamiliesAsJson, readRowkeyAsString);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BigtableOptions {\n");
    sb.append("    columnFamilies: ").append(toIndentedString(columnFamilies)).append("\n");
    sb.append("    ignoreUnspecifiedColumnFamilies: ").append(toIndentedString(ignoreUnspecifiedColumnFamilies)).append("\n");
    sb.append("    outputColumnFamiliesAsJson: ").append(toIndentedString(outputColumnFamiliesAsJson)).append("\n");
    sb.append("    readRowkeyAsString: ").append(toIndentedString(readRowkeyAsString)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("columnFamilies");
    openapiFields.add("ignoreUnspecifiedColumnFamilies");
    openapiFields.add("outputColumnFamiliesAsJson");
    openapiFields.add("readRowkeyAsString");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BigtableOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BigtableOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BigtableOptions is not found in the empty JSON string", BigtableOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BigtableOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BigtableOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("columnFamilies") != null && !jsonObj.get("columnFamilies").isJsonNull()) {
        JsonArray jsonArraycolumnFamilies = jsonObj.getAsJsonArray("columnFamilies");
        if (jsonArraycolumnFamilies != null) {
          // ensure the json data is an array
          if (!jsonObj.get("columnFamilies").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `columnFamilies` to be an array in the JSON string but got `%s`", jsonObj.get("columnFamilies").toString()));
          }

          // validate the optional field `columnFamilies` (array)
          for (int i = 0; i < jsonArraycolumnFamilies.size(); i++) {
            BigtableColumnFamily.validateJsonElement(jsonArraycolumnFamilies.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BigtableOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BigtableOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BigtableOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BigtableOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<BigtableOptions>() {
           @Override
           public void write(JsonWriter out, BigtableOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BigtableOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BigtableOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BigtableOptions
   * @throws IOException if the JSON string is invalid with respect to BigtableOptions
   */
  public static BigtableOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BigtableOptions.class);
  }

  /**
   * Convert an instance of BigtableOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

