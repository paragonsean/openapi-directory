/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options for a remote user-defined function.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RemoteFunctionOptions {
  public static final String SERIALIZED_NAME_CONNECTION = "connection";
  @SerializedName(SERIALIZED_NAME_CONNECTION)
  private String connection;

  public static final String SERIALIZED_NAME_ENDPOINT = "endpoint";
  @SerializedName(SERIALIZED_NAME_ENDPOINT)
  private String endpoint;

  public static final String SERIALIZED_NAME_MAX_BATCHING_ROWS = "maxBatchingRows";
  @SerializedName(SERIALIZED_NAME_MAX_BATCHING_ROWS)
  private String maxBatchingRows;

  public static final String SERIALIZED_NAME_USER_DEFINED_CONTEXT = "userDefinedContext";
  @SerializedName(SERIALIZED_NAME_USER_DEFINED_CONTEXT)
  private Map<String, String> userDefinedContext = new HashMap<>();

  public RemoteFunctionOptions() {
  }

  public RemoteFunctionOptions connection(String connection) {
    this.connection = connection;
    return this;
  }

  /**
   * Fully qualified name of the user-provided connection object which holds the authentication information to send requests to the remote service. Format: &#x60;&#x60;&#x60;\&quot;projects/{projectId}/locations/{locationId}/connections/{connectionId}\&quot;&#x60;&#x60;&#x60;
   * @return connection
   */
  @javax.annotation.Nullable
  public String getConnection() {
    return connection;
  }

  public void setConnection(String connection) {
    this.connection = connection;
  }


  public RemoteFunctionOptions endpoint(String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

  /**
   * Endpoint of the user-provided remote service, e.g. &#x60;&#x60;&#x60;https://us-east1-my_gcf_project.cloudfunctions.net/remote_add&#x60;&#x60;&#x60;
   * @return endpoint
   */
  @javax.annotation.Nullable
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(String endpoint) {
    this.endpoint = endpoint;
  }


  public RemoteFunctionOptions maxBatchingRows(String maxBatchingRows) {
    this.maxBatchingRows = maxBatchingRows;
    return this;
  }

  /**
   * Max number of rows in each batch sent to the remote service. If absent or if 0, BigQuery dynamically decides the number of rows in a batch.
   * @return maxBatchingRows
   */
  @javax.annotation.Nullable
  public String getMaxBatchingRows() {
    return maxBatchingRows;
  }

  public void setMaxBatchingRows(String maxBatchingRows) {
    this.maxBatchingRows = maxBatchingRows;
  }


  public RemoteFunctionOptions userDefinedContext(Map<String, String> userDefinedContext) {
    this.userDefinedContext = userDefinedContext;
    return this;
  }

  public RemoteFunctionOptions putUserDefinedContextItem(String key, String userDefinedContextItem) {
    if (this.userDefinedContext == null) {
      this.userDefinedContext = new HashMap<>();
    }
    this.userDefinedContext.put(key, userDefinedContextItem);
    return this;
  }

  /**
   * User-defined context as a set of key/value pairs, which will be sent as function invocation context together with batched arguments in the requests to the remote service. The total number of bytes of keys and values must be less than 8KB.
   * @return userDefinedContext
   */
  @javax.annotation.Nullable
  public Map<String, String> getUserDefinedContext() {
    return userDefinedContext;
  }

  public void setUserDefinedContext(Map<String, String> userDefinedContext) {
    this.userDefinedContext = userDefinedContext;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RemoteFunctionOptions remoteFunctionOptions = (RemoteFunctionOptions) o;
    return Objects.equals(this.connection, remoteFunctionOptions.connection) &&
        Objects.equals(this.endpoint, remoteFunctionOptions.endpoint) &&
        Objects.equals(this.maxBatchingRows, remoteFunctionOptions.maxBatchingRows) &&
        Objects.equals(this.userDefinedContext, remoteFunctionOptions.userDefinedContext);
  }

  @Override
  public int hashCode() {
    return Objects.hash(connection, endpoint, maxBatchingRows, userDefinedContext);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RemoteFunctionOptions {\n");
    sb.append("    connection: ").append(toIndentedString(connection)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    maxBatchingRows: ").append(toIndentedString(maxBatchingRows)).append("\n");
    sb.append("    userDefinedContext: ").append(toIndentedString(userDefinedContext)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("connection");
    openapiFields.add("endpoint");
    openapiFields.add("maxBatchingRows");
    openapiFields.add("userDefinedContext");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RemoteFunctionOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RemoteFunctionOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RemoteFunctionOptions is not found in the empty JSON string", RemoteFunctionOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RemoteFunctionOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RemoteFunctionOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("connection") != null && !jsonObj.get("connection").isJsonNull()) && !jsonObj.get("connection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connection").toString()));
      }
      if ((jsonObj.get("endpoint") != null && !jsonObj.get("endpoint").isJsonNull()) && !jsonObj.get("endpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endpoint").toString()));
      }
      if ((jsonObj.get("maxBatchingRows") != null && !jsonObj.get("maxBatchingRows").isJsonNull()) && !jsonObj.get("maxBatchingRows").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxBatchingRows` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxBatchingRows").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RemoteFunctionOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RemoteFunctionOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RemoteFunctionOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RemoteFunctionOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<RemoteFunctionOptions>() {
           @Override
           public void write(JsonWriter out, RemoteFunctionOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RemoteFunctionOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RemoteFunctionOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RemoteFunctionOptions
   * @throws IOException if the JSON string is invalid with respect to RemoteFunctionOptions
   */
  public static RemoteFunctionOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RemoteFunctionOptions.class);
  }

  /**
   * Convert an instance of RemoteFunctionOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

