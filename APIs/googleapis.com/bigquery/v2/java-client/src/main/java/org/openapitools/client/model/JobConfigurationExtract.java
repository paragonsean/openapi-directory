/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ModelExtractOptions;
import org.openapitools.client.model.ModelReference;
import org.openapitools.client.model.TableReference;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JobConfigurationExtract configures a job that exports data from a BigQuery table into Google Cloud Storage.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class JobConfigurationExtract {
  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  private String compression;

  public static final String SERIALIZED_NAME_DESTINATION_FORMAT = "destinationFormat";
  @SerializedName(SERIALIZED_NAME_DESTINATION_FORMAT)
  private String destinationFormat;

  public static final String SERIALIZED_NAME_DESTINATION_URI = "destinationUri";
  @SerializedName(SERIALIZED_NAME_DESTINATION_URI)
  private String destinationUri;

  public static final String SERIALIZED_NAME_DESTINATION_URIS = "destinationUris";
  @SerializedName(SERIALIZED_NAME_DESTINATION_URIS)
  private List<String> destinationUris = new ArrayList<>();

  public static final String SERIALIZED_NAME_FIELD_DELIMITER = "fieldDelimiter";
  @SerializedName(SERIALIZED_NAME_FIELD_DELIMITER)
  private String fieldDelimiter;

  public static final String SERIALIZED_NAME_MODEL_EXTRACT_OPTIONS = "modelExtractOptions";
  @SerializedName(SERIALIZED_NAME_MODEL_EXTRACT_OPTIONS)
  private ModelExtractOptions modelExtractOptions;

  public static final String SERIALIZED_NAME_PRINT_HEADER = "printHeader";
  @SerializedName(SERIALIZED_NAME_PRINT_HEADER)
  private Boolean printHeader = true;

  public static final String SERIALIZED_NAME_SOURCE_MODEL = "sourceModel";
  @SerializedName(SERIALIZED_NAME_SOURCE_MODEL)
  private ModelReference sourceModel;

  public static final String SERIALIZED_NAME_SOURCE_TABLE = "sourceTable";
  @SerializedName(SERIALIZED_NAME_SOURCE_TABLE)
  private TableReference sourceTable;

  public static final String SERIALIZED_NAME_USE_AVRO_LOGICAL_TYPES = "useAvroLogicalTypes";
  @SerializedName(SERIALIZED_NAME_USE_AVRO_LOGICAL_TYPES)
  private Boolean useAvroLogicalTypes;

  public JobConfigurationExtract() {
  }

  public JobConfigurationExtract compression(String compression) {
    this.compression = compression;
    return this;
  }

  /**
   * Optional. The compression type to use for exported files. Possible values include DEFLATE, GZIP, NONE, SNAPPY, and ZSTD. The default value is NONE. Not all compression formats are support for all file formats. DEFLATE is only supported for Avro. ZSTD is only supported for Parquet. Not applicable when extracting models.
   * @return compression
   */
  @javax.annotation.Nullable
  public String getCompression() {
    return compression;
  }

  public void setCompression(String compression) {
    this.compression = compression;
  }


  public JobConfigurationExtract destinationFormat(String destinationFormat) {
    this.destinationFormat = destinationFormat;
    return this;
  }

  /**
   * Optional. The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON, PARQUET, or AVRO for tables and ML_TF_SAVED_MODEL or ML_XGBOOST_BOOSTER for models. The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV. The default value for models is ML_TF_SAVED_MODEL.
   * @return destinationFormat
   */
  @javax.annotation.Nullable
  public String getDestinationFormat() {
    return destinationFormat;
  }

  public void setDestinationFormat(String destinationFormat) {
    this.destinationFormat = destinationFormat;
  }


  public JobConfigurationExtract destinationUri(String destinationUri) {
    this.destinationUri = destinationUri;
    return this;
  }

  /**
   * [Pick one] DEPRECATED: Use destinationUris instead, passing only one URI as necessary. The fully-qualified Google Cloud Storage URI where the extracted table should be written.
   * @return destinationUri
   */
  @javax.annotation.Nullable
  public String getDestinationUri() {
    return destinationUri;
  }

  public void setDestinationUri(String destinationUri) {
    this.destinationUri = destinationUri;
  }


  public JobConfigurationExtract destinationUris(List<String> destinationUris) {
    this.destinationUris = destinationUris;
    return this;
  }

  public JobConfigurationExtract addDestinationUrisItem(String destinationUrisItem) {
    if (this.destinationUris == null) {
      this.destinationUris = new ArrayList<>();
    }
    this.destinationUris.add(destinationUrisItem);
    return this;
  }

  /**
   * [Pick one] A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
   * @return destinationUris
   */
  @javax.annotation.Nullable
  public List<String> getDestinationUris() {
    return destinationUris;
  }

  public void setDestinationUris(List<String> destinationUris) {
    this.destinationUris = destinationUris;
  }


  public JobConfigurationExtract fieldDelimiter(String fieldDelimiter) {
    this.fieldDelimiter = fieldDelimiter;
    return this;
  }

  /**
   * Optional. When extracting data in CSV format, this defines the delimiter to use between fields in the exported data. Default is &#39;,&#39;. Not applicable when extracting models.
   * @return fieldDelimiter
   */
  @javax.annotation.Nullable
  public String getFieldDelimiter() {
    return fieldDelimiter;
  }

  public void setFieldDelimiter(String fieldDelimiter) {
    this.fieldDelimiter = fieldDelimiter;
  }


  public JobConfigurationExtract modelExtractOptions(ModelExtractOptions modelExtractOptions) {
    this.modelExtractOptions = modelExtractOptions;
    return this;
  }

  /**
   * Get modelExtractOptions
   * @return modelExtractOptions
   */
  @javax.annotation.Nullable
  public ModelExtractOptions getModelExtractOptions() {
    return modelExtractOptions;
  }

  public void setModelExtractOptions(ModelExtractOptions modelExtractOptions) {
    this.modelExtractOptions = modelExtractOptions;
  }


  public JobConfigurationExtract printHeader(Boolean printHeader) {
    this.printHeader = printHeader;
    return this;
  }

  /**
   * Optional. Whether to print out a header row in the results. Default is true. Not applicable when extracting models.
   * @return printHeader
   */
  @javax.annotation.Nullable
  public Boolean getPrintHeader() {
    return printHeader;
  }

  public void setPrintHeader(Boolean printHeader) {
    this.printHeader = printHeader;
  }


  public JobConfigurationExtract sourceModel(ModelReference sourceModel) {
    this.sourceModel = sourceModel;
    return this;
  }

  /**
   * Get sourceModel
   * @return sourceModel
   */
  @javax.annotation.Nullable
  public ModelReference getSourceModel() {
    return sourceModel;
  }

  public void setSourceModel(ModelReference sourceModel) {
    this.sourceModel = sourceModel;
  }


  public JobConfigurationExtract sourceTable(TableReference sourceTable) {
    this.sourceTable = sourceTable;
    return this;
  }

  /**
   * Get sourceTable
   * @return sourceTable
   */
  @javax.annotation.Nullable
  public TableReference getSourceTable() {
    return sourceTable;
  }

  public void setSourceTable(TableReference sourceTable) {
    this.sourceTable = sourceTable;
  }


  public JobConfigurationExtract useAvroLogicalTypes(Boolean useAvroLogicalTypes) {
    this.useAvroLogicalTypes = useAvroLogicalTypes;
    return this;
  }

  /**
   * Whether to use logical types when extracting to AVRO format. Not applicable when extracting models.
   * @return useAvroLogicalTypes
   */
  @javax.annotation.Nullable
  public Boolean getUseAvroLogicalTypes() {
    return useAvroLogicalTypes;
  }

  public void setUseAvroLogicalTypes(Boolean useAvroLogicalTypes) {
    this.useAvroLogicalTypes = useAvroLogicalTypes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobConfigurationExtract jobConfigurationExtract = (JobConfigurationExtract) o;
    return Objects.equals(this.compression, jobConfigurationExtract.compression) &&
        Objects.equals(this.destinationFormat, jobConfigurationExtract.destinationFormat) &&
        Objects.equals(this.destinationUri, jobConfigurationExtract.destinationUri) &&
        Objects.equals(this.destinationUris, jobConfigurationExtract.destinationUris) &&
        Objects.equals(this.fieldDelimiter, jobConfigurationExtract.fieldDelimiter) &&
        Objects.equals(this.modelExtractOptions, jobConfigurationExtract.modelExtractOptions) &&
        Objects.equals(this.printHeader, jobConfigurationExtract.printHeader) &&
        Objects.equals(this.sourceModel, jobConfigurationExtract.sourceModel) &&
        Objects.equals(this.sourceTable, jobConfigurationExtract.sourceTable) &&
        Objects.equals(this.useAvroLogicalTypes, jobConfigurationExtract.useAvroLogicalTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(compression, destinationFormat, destinationUri, destinationUris, fieldDelimiter, modelExtractOptions, printHeader, sourceModel, sourceTable, useAvroLogicalTypes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobConfigurationExtract {\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    destinationFormat: ").append(toIndentedString(destinationFormat)).append("\n");
    sb.append("    destinationUri: ").append(toIndentedString(destinationUri)).append("\n");
    sb.append("    destinationUris: ").append(toIndentedString(destinationUris)).append("\n");
    sb.append("    fieldDelimiter: ").append(toIndentedString(fieldDelimiter)).append("\n");
    sb.append("    modelExtractOptions: ").append(toIndentedString(modelExtractOptions)).append("\n");
    sb.append("    printHeader: ").append(toIndentedString(printHeader)).append("\n");
    sb.append("    sourceModel: ").append(toIndentedString(sourceModel)).append("\n");
    sb.append("    sourceTable: ").append(toIndentedString(sourceTable)).append("\n");
    sb.append("    useAvroLogicalTypes: ").append(toIndentedString(useAvroLogicalTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("compression");
    openapiFields.add("destinationFormat");
    openapiFields.add("destinationUri");
    openapiFields.add("destinationUris");
    openapiFields.add("fieldDelimiter");
    openapiFields.add("modelExtractOptions");
    openapiFields.add("printHeader");
    openapiFields.add("sourceModel");
    openapiFields.add("sourceTable");
    openapiFields.add("useAvroLogicalTypes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to JobConfigurationExtract
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JobConfigurationExtract.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JobConfigurationExtract is not found in the empty JSON string", JobConfigurationExtract.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JobConfigurationExtract.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JobConfigurationExtract` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) && !jsonObj.get("compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compression").toString()));
      }
      if ((jsonObj.get("destinationFormat") != null && !jsonObj.get("destinationFormat").isJsonNull()) && !jsonObj.get("destinationFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destinationFormat").toString()));
      }
      if ((jsonObj.get("destinationUri") != null && !jsonObj.get("destinationUri").isJsonNull()) && !jsonObj.get("destinationUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destinationUri").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("destinationUris") != null && !jsonObj.get("destinationUris").isJsonNull() && !jsonObj.get("destinationUris").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationUris` to be an array in the JSON string but got `%s`", jsonObj.get("destinationUris").toString()));
      }
      if ((jsonObj.get("fieldDelimiter") != null && !jsonObj.get("fieldDelimiter").isJsonNull()) && !jsonObj.get("fieldDelimiter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fieldDelimiter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fieldDelimiter").toString()));
      }
      // validate the optional field `modelExtractOptions`
      if (jsonObj.get("modelExtractOptions") != null && !jsonObj.get("modelExtractOptions").isJsonNull()) {
        ModelExtractOptions.validateJsonElement(jsonObj.get("modelExtractOptions"));
      }
      // validate the optional field `sourceModel`
      if (jsonObj.get("sourceModel") != null && !jsonObj.get("sourceModel").isJsonNull()) {
        ModelReference.validateJsonElement(jsonObj.get("sourceModel"));
      }
      // validate the optional field `sourceTable`
      if (jsonObj.get("sourceTable") != null && !jsonObj.get("sourceTable").isJsonNull()) {
        TableReference.validateJsonElement(jsonObj.get("sourceTable"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JobConfigurationExtract.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JobConfigurationExtract' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JobConfigurationExtract> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JobConfigurationExtract.class));

       return (TypeAdapter<T>) new TypeAdapter<JobConfigurationExtract>() {
           @Override
           public void write(JsonWriter out, JobConfigurationExtract value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JobConfigurationExtract read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of JobConfigurationExtract given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of JobConfigurationExtract
   * @throws IOException if the JSON string is invalid with respect to JobConfigurationExtract
   */
  public static JobConfigurationExtract fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JobConfigurationExtract.class);
  }

  /**
   * Convert an instance of JobConfigurationExtract to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

