/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options for configuring hive partitioning detect.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HivePartitioningOptions {
  public static final String SERIALIZED_NAME_FIELDS = "fields";
  @SerializedName(SERIALIZED_NAME_FIELDS)
  private List<String> fields = new ArrayList<>();

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private String mode;

  public static final String SERIALIZED_NAME_REQUIRE_PARTITION_FILTER = "requirePartitionFilter";
  @SerializedName(SERIALIZED_NAME_REQUIRE_PARTITION_FILTER)
  private Boolean requirePartitionFilter = false;

  public static final String SERIALIZED_NAME_SOURCE_URI_PREFIX = "sourceUriPrefix";
  @SerializedName(SERIALIZED_NAME_SOURCE_URI_PREFIX)
  private String sourceUriPrefix;

  public HivePartitioningOptions() {
  }

  public HivePartitioningOptions(
     List<String> fields
  ) {
    this();
    this.fields = fields;
  }

  /**
   * Output only. For permanent external tables, this field is populated with the hive partition keys in the order they were inferred. The types of the partition keys can be deduced by checking the table schema (which will include the partition keys). Not every API will populate this field in the output. For example, Tables.Get will populate it, but Tables.List will not contain this field.
   * @return fields
   */
  @javax.annotation.Nullable
  public List<String> getFields() {
    return fields;
  }



  public HivePartitioningOptions mode(String mode) {
    this.mode = mode;
    return this;
  }

  /**
   * Optional. When set, what mode of hive partitioning to use when reading data. The following modes are supported: * AUTO: automatically infer partition key name(s) and type(s). * STRINGS: automatically infer partition key name(s). All types are strings. * CUSTOM: partition key schema is encoded in the source URI prefix. Not all storage formats support hive partitioning. Requesting hive partitioning on an unsupported format will lead to an error. Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
   * @return mode
   */
  @javax.annotation.Nullable
  public String getMode() {
    return mode;
  }

  public void setMode(String mode) {
    this.mode = mode;
  }


  public HivePartitioningOptions requirePartitionFilter(Boolean requirePartitionFilter) {
    this.requirePartitionFilter = requirePartitionFilter;
    return this;
  }

  /**
   * Optional. If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified. Note that this field should only be true when creating a permanent external table or querying a temporary external table. Hive-partitioned loads with require_partition_filter explicitly set to true will fail.
   * @return requirePartitionFilter
   */
  @javax.annotation.Nullable
  public Boolean getRequirePartitionFilter() {
    return requirePartitionFilter;
  }

  public void setRequirePartitionFilter(Boolean requirePartitionFilter) {
    this.requirePartitionFilter = requirePartitionFilter;
  }


  public HivePartitioningOptions sourceUriPrefix(String sourceUriPrefix) {
    this.sourceUriPrefix = sourceUriPrefix;
    return this;
  }

  /**
   * Optional. When hive partition detection is requested, a common prefix for all source uris must be required. The prefix must end immediately before the partition key encoding begins. For example, consider files following this data layout: gs://bucket/path_to_table/dt&#x3D;2019-06-01/country&#x3D;USA/id&#x3D;7/file.avro gs://bucket/path_to_table/dt&#x3D;2019-05-31/country&#x3D;CA/id&#x3D;3/file.avro When hive partitioning is requested with either AUTO or STRINGS detection, the common prefix can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/. CUSTOM detection requires encoding the partitioning schema immediately after the common prefix. For CUSTOM, any of * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:INTEGER} * gs://bucket/path_to_table/{dt:STRING}/{country:STRING}/{id:INTEGER} * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:STRING} would all be valid source URI prefixes.
   * @return sourceUriPrefix
   */
  @javax.annotation.Nullable
  public String getSourceUriPrefix() {
    return sourceUriPrefix;
  }

  public void setSourceUriPrefix(String sourceUriPrefix) {
    this.sourceUriPrefix = sourceUriPrefix;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HivePartitioningOptions hivePartitioningOptions = (HivePartitioningOptions) o;
    return Objects.equals(this.fields, hivePartitioningOptions.fields) &&
        Objects.equals(this.mode, hivePartitioningOptions.mode) &&
        Objects.equals(this.requirePartitionFilter, hivePartitioningOptions.requirePartitionFilter) &&
        Objects.equals(this.sourceUriPrefix, hivePartitioningOptions.sourceUriPrefix);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fields, mode, requirePartitionFilter, sourceUriPrefix);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HivePartitioningOptions {\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    requirePartitionFilter: ").append(toIndentedString(requirePartitionFilter)).append("\n");
    sb.append("    sourceUriPrefix: ").append(toIndentedString(sourceUriPrefix)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("fields");
    openapiFields.add("mode");
    openapiFields.add("requirePartitionFilter");
    openapiFields.add("sourceUriPrefix");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HivePartitioningOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HivePartitioningOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HivePartitioningOptions is not found in the empty JSON string", HivePartitioningOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HivePartitioningOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HivePartitioningOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("fields") != null && !jsonObj.get("fields").isJsonNull() && !jsonObj.get("fields").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `fields` to be an array in the JSON string but got `%s`", jsonObj.get("fields").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      if ((jsonObj.get("sourceUriPrefix") != null && !jsonObj.get("sourceUriPrefix").isJsonNull()) && !jsonObj.get("sourceUriPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceUriPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceUriPrefix").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HivePartitioningOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HivePartitioningOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HivePartitioningOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HivePartitioningOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<HivePartitioningOptions>() {
           @Override
           public void write(JsonWriter out, HivePartitioningOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HivePartitioningOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HivePartitioningOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HivePartitioningOptions
   * @throws IOException if the JSON string is invalid with respect to HivePartitioningOptions
   */
  public static HivePartitioningOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HivePartitioningOptions.class);
  }

  /**
   * Convert an instance of HivePartitioningOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

