/*
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Clustering;
import org.openapitools.client.model.ConnectionProperty;
import org.openapitools.client.model.DatasetReference;
import org.openapitools.client.model.EncryptionConfiguration;
import org.openapitools.client.model.ExternalDataConfiguration;
import org.openapitools.client.model.QueryParameter;
import org.openapitools.client.model.RangePartitioning;
import org.openapitools.client.model.ScriptOptions;
import org.openapitools.client.model.SystemVariables;
import org.openapitools.client.model.TableReference;
import org.openapitools.client.model.TimePartitioning;
import org.openapitools.client.model.UserDefinedFunctionResource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JobConfigurationQuery configures a BigQuery query job.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:22.147192-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class JobConfigurationQuery {
  public static final String SERIALIZED_NAME_ALLOW_LARGE_RESULTS = "allowLargeResults";
  @SerializedName(SERIALIZED_NAME_ALLOW_LARGE_RESULTS)
  private Boolean allowLargeResults = false;

  public static final String SERIALIZED_NAME_CLUSTERING = "clustering";
  @SerializedName(SERIALIZED_NAME_CLUSTERING)
  private Clustering clustering;

  public static final String SERIALIZED_NAME_CONNECTION_PROPERTIES = "connectionProperties";
  @SerializedName(SERIALIZED_NAME_CONNECTION_PROPERTIES)
  private List<ConnectionProperty> connectionProperties = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTINUOUS = "continuous";
  @SerializedName(SERIALIZED_NAME_CONTINUOUS)
  private Boolean continuous;

  public static final String SERIALIZED_NAME_CREATE_DISPOSITION = "createDisposition";
  @SerializedName(SERIALIZED_NAME_CREATE_DISPOSITION)
  private String createDisposition;

  public static final String SERIALIZED_NAME_CREATE_SESSION = "createSession";
  @SerializedName(SERIALIZED_NAME_CREATE_SESSION)
  private Boolean createSession;

  public static final String SERIALIZED_NAME_DEFAULT_DATASET = "defaultDataset";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DATASET)
  private DatasetReference defaultDataset;

  public static final String SERIALIZED_NAME_DESTINATION_ENCRYPTION_CONFIGURATION = "destinationEncryptionConfiguration";
  @SerializedName(SERIALIZED_NAME_DESTINATION_ENCRYPTION_CONFIGURATION)
  private EncryptionConfiguration destinationEncryptionConfiguration;

  public static final String SERIALIZED_NAME_DESTINATION_TABLE = "destinationTable";
  @SerializedName(SERIALIZED_NAME_DESTINATION_TABLE)
  private TableReference destinationTable;

  public static final String SERIALIZED_NAME_FLATTEN_RESULTS = "flattenResults";
  @SerializedName(SERIALIZED_NAME_FLATTEN_RESULTS)
  private Boolean flattenResults = true;

  public static final String SERIALIZED_NAME_MAXIMUM_BILLING_TIER = "maximumBillingTier";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_BILLING_TIER)
  private Integer maximumBillingTier = 1;

  public static final String SERIALIZED_NAME_MAXIMUM_BYTES_BILLED = "maximumBytesBilled";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_BYTES_BILLED)
  private String maximumBytesBilled;

  public static final String SERIALIZED_NAME_PARAMETER_MODE = "parameterMode";
  @SerializedName(SERIALIZED_NAME_PARAMETER_MODE)
  private String parameterMode;

  public static final String SERIALIZED_NAME_PRESERVE_NULLS = "preserveNulls";
  @SerializedName(SERIALIZED_NAME_PRESERVE_NULLS)
  private Boolean preserveNulls;

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private String priority;

  public static final String SERIALIZED_NAME_QUERY = "query";
  @SerializedName(SERIALIZED_NAME_QUERY)
  private String query;

  public static final String SERIALIZED_NAME_QUERY_PARAMETERS = "queryParameters";
  @SerializedName(SERIALIZED_NAME_QUERY_PARAMETERS)
  private List<QueryParameter> queryParameters = new ArrayList<>();

  public static final String SERIALIZED_NAME_RANGE_PARTITIONING = "rangePartitioning";
  @SerializedName(SERIALIZED_NAME_RANGE_PARTITIONING)
  private RangePartitioning rangePartitioning;

  public static final String SERIALIZED_NAME_SCHEMA_UPDATE_OPTIONS = "schemaUpdateOptions";
  @SerializedName(SERIALIZED_NAME_SCHEMA_UPDATE_OPTIONS)
  private List<String> schemaUpdateOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_SCRIPT_OPTIONS = "scriptOptions";
  @SerializedName(SERIALIZED_NAME_SCRIPT_OPTIONS)
  private ScriptOptions scriptOptions;

  public static final String SERIALIZED_NAME_SYSTEM_VARIABLES = "systemVariables";
  @SerializedName(SERIALIZED_NAME_SYSTEM_VARIABLES)
  private SystemVariables systemVariables;

  public static final String SERIALIZED_NAME_TABLE_DEFINITIONS = "tableDefinitions";
  @SerializedName(SERIALIZED_NAME_TABLE_DEFINITIONS)
  private Map<String, ExternalDataConfiguration> tableDefinitions = new HashMap<>();

  public static final String SERIALIZED_NAME_TIME_PARTITIONING = "timePartitioning";
  @SerializedName(SERIALIZED_NAME_TIME_PARTITIONING)
  private TimePartitioning timePartitioning;

  public static final String SERIALIZED_NAME_USE_LEGACY_SQL = "useLegacySql";
  @SerializedName(SERIALIZED_NAME_USE_LEGACY_SQL)
  private Boolean useLegacySql = true;

  public static final String SERIALIZED_NAME_USE_QUERY_CACHE = "useQueryCache";
  @SerializedName(SERIALIZED_NAME_USE_QUERY_CACHE)
  private Boolean useQueryCache = true;

  public static final String SERIALIZED_NAME_USER_DEFINED_FUNCTION_RESOURCES = "userDefinedFunctionResources";
  @SerializedName(SERIALIZED_NAME_USER_DEFINED_FUNCTION_RESOURCES)
  private List<UserDefinedFunctionResource> userDefinedFunctionResources = new ArrayList<>();

  public static final String SERIALIZED_NAME_WRITE_DISPOSITION = "writeDisposition";
  @SerializedName(SERIALIZED_NAME_WRITE_DISPOSITION)
  private String writeDisposition;

  public JobConfigurationQuery() {
  }

  public JobConfigurationQuery allowLargeResults(Boolean allowLargeResults) {
    this.allowLargeResults = allowLargeResults;
    return this;
  }

  /**
   * Optional. If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For GoogleSQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
   * @return allowLargeResults
   */
  @javax.annotation.Nullable
  public Boolean getAllowLargeResults() {
    return allowLargeResults;
  }

  public void setAllowLargeResults(Boolean allowLargeResults) {
    this.allowLargeResults = allowLargeResults;
  }


  public JobConfigurationQuery clustering(Clustering clustering) {
    this.clustering = clustering;
    return this;
  }

  /**
   * Get clustering
   * @return clustering
   */
  @javax.annotation.Nullable
  public Clustering getClustering() {
    return clustering;
  }

  public void setClustering(Clustering clustering) {
    this.clustering = clustering;
  }


  public JobConfigurationQuery connectionProperties(List<ConnectionProperty> connectionProperties) {
    this.connectionProperties = connectionProperties;
    return this;
  }

  public JobConfigurationQuery addConnectionPropertiesItem(ConnectionProperty connectionPropertiesItem) {
    if (this.connectionProperties == null) {
      this.connectionProperties = new ArrayList<>();
    }
    this.connectionProperties.add(connectionPropertiesItem);
    return this;
  }

  /**
   * Connection properties which can modify the query behavior.
   * @return connectionProperties
   */
  @javax.annotation.Nullable
  public List<ConnectionProperty> getConnectionProperties() {
    return connectionProperties;
  }

  public void setConnectionProperties(List<ConnectionProperty> connectionProperties) {
    this.connectionProperties = connectionProperties;
  }


  public JobConfigurationQuery continuous(Boolean continuous) {
    this.continuous = continuous;
    return this;
  }

  /**
   * [Optional] Specifies whether the query should be executed as a continuous query. The default value is false.
   * @return continuous
   */
  @javax.annotation.Nullable
  public Boolean getContinuous() {
    return continuous;
  }

  public void setContinuous(Boolean continuous) {
    this.continuous = continuous;
  }


  public JobConfigurationQuery createDisposition(String createDisposition) {
    this.createDisposition = createDisposition;
    return this;
  }

  /**
   * Optional. Specifies whether the job is allowed to create new tables. The following values are supported: * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. * CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
   * @return createDisposition
   */
  @javax.annotation.Nullable
  public String getCreateDisposition() {
    return createDisposition;
  }

  public void setCreateDisposition(String createDisposition) {
    this.createDisposition = createDisposition;
  }


  public JobConfigurationQuery createSession(Boolean createSession) {
    this.createSession = createSession;
    return this;
  }

  /**
   * If this property is true, the job creates a new session using a randomly generated session_id. To continue using a created session with subsequent queries, pass the existing session identifier as a &#x60;ConnectionProperty&#x60; value. The session identifier is returned as part of the &#x60;SessionInfo&#x60; message within the query statistics. The new session&#39;s location will be set to &#x60;Job.JobReference.location&#x60; if it is present, otherwise it&#39;s set to the default location based on existing routing logic.
   * @return createSession
   */
  @javax.annotation.Nullable
  public Boolean getCreateSession() {
    return createSession;
  }

  public void setCreateSession(Boolean createSession) {
    this.createSession = createSession;
  }


  public JobConfigurationQuery defaultDataset(DatasetReference defaultDataset) {
    this.defaultDataset = defaultDataset;
    return this;
  }

  /**
   * Get defaultDataset
   * @return defaultDataset
   */
  @javax.annotation.Nullable
  public DatasetReference getDefaultDataset() {
    return defaultDataset;
  }

  public void setDefaultDataset(DatasetReference defaultDataset) {
    this.defaultDataset = defaultDataset;
  }


  public JobConfigurationQuery destinationEncryptionConfiguration(EncryptionConfiguration destinationEncryptionConfiguration) {
    this.destinationEncryptionConfiguration = destinationEncryptionConfiguration;
    return this;
  }

  /**
   * Get destinationEncryptionConfiguration
   * @return destinationEncryptionConfiguration
   */
  @javax.annotation.Nullable
  public EncryptionConfiguration getDestinationEncryptionConfiguration() {
    return destinationEncryptionConfiguration;
  }

  public void setDestinationEncryptionConfiguration(EncryptionConfiguration destinationEncryptionConfiguration) {
    this.destinationEncryptionConfiguration = destinationEncryptionConfiguration;
  }


  public JobConfigurationQuery destinationTable(TableReference destinationTable) {
    this.destinationTable = destinationTable;
    return this;
  }

  /**
   * Get destinationTable
   * @return destinationTable
   */
  @javax.annotation.Nullable
  public TableReference getDestinationTable() {
    return destinationTable;
  }

  public void setDestinationTable(TableReference destinationTable) {
    this.destinationTable = destinationTable;
  }


  public JobConfigurationQuery flattenResults(Boolean flattenResults) {
    this.flattenResults = flattenResults;
    return this;
  }

  /**
   * Optional. If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For GoogleSQL queries, this flag is ignored and results are never flattened.
   * @return flattenResults
   */
  @javax.annotation.Nullable
  public Boolean getFlattenResults() {
    return flattenResults;
  }

  public void setFlattenResults(Boolean flattenResults) {
    this.flattenResults = flattenResults;
  }


  public JobConfigurationQuery maximumBillingTier(Integer maximumBillingTier) {
    this.maximumBillingTier = maximumBillingTier;
    return this;
  }

  /**
   * Optional. [Deprecated] Maximum billing tier allowed for this query. The billing tier controls the amount of compute resources allotted to the query, and multiplies the on-demand cost of the query accordingly. A query that runs within its allotted resources will succeed and indicate its billing tier in statistics.query.billingTier, but if the query exceeds its allotted resources, it will fail with billingTierLimitExceeded. WARNING: The billed byte amount can be multiplied by an amount up to this number! Most users should not need to alter this setting, and we recommend that you avoid introducing new uses of it.
   * @return maximumBillingTier
   */
  @javax.annotation.Nullable
  public Integer getMaximumBillingTier() {
    return maximumBillingTier;
  }

  public void setMaximumBillingTier(Integer maximumBillingTier) {
    this.maximumBillingTier = maximumBillingTier;
  }


  public JobConfigurationQuery maximumBytesBilled(String maximumBytesBilled) {
    this.maximumBytesBilled = maximumBytesBilled;
    return this;
  }

  /**
   * Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
   * @return maximumBytesBilled
   */
  @javax.annotation.Nullable
  public String getMaximumBytesBilled() {
    return maximumBytesBilled;
  }

  public void setMaximumBytesBilled(String maximumBytesBilled) {
    this.maximumBytesBilled = maximumBytesBilled;
  }


  public JobConfigurationQuery parameterMode(String parameterMode) {
    this.parameterMode = parameterMode;
    return this;
  }

  /**
   * GoogleSQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
   * @return parameterMode
   */
  @javax.annotation.Nullable
  public String getParameterMode() {
    return parameterMode;
  }

  public void setParameterMode(String parameterMode) {
    this.parameterMode = parameterMode;
  }


  public JobConfigurationQuery preserveNulls(Boolean preserveNulls) {
    this.preserveNulls = preserveNulls;
    return this;
  }

  /**
   * [Deprecated] This property is deprecated.
   * @return preserveNulls
   */
  @javax.annotation.Nullable
  public Boolean getPreserveNulls() {
    return preserveNulls;
  }

  public void setPreserveNulls(Boolean preserveNulls) {
    this.preserveNulls = preserveNulls;
  }


  public JobConfigurationQuery priority(String priority) {
    this.priority = priority;
    return this;
  }

  /**
   * Optional. Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
   * @return priority
   */
  @javax.annotation.Nullable
  public String getPriority() {
    return priority;
  }

  public void setPriority(String priority) {
    this.priority = priority;
  }


  public JobConfigurationQuery query(String query) {
    this.query = query;
    return this;
  }

  /**
   * [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or GoogleSQL.
   * @return query
   */
  @javax.annotation.Nullable
  public String getQuery() {
    return query;
  }

  public void setQuery(String query) {
    this.query = query;
  }


  public JobConfigurationQuery queryParameters(List<QueryParameter> queryParameters) {
    this.queryParameters = queryParameters;
    return this;
  }

  public JobConfigurationQuery addQueryParametersItem(QueryParameter queryParametersItem) {
    if (this.queryParameters == null) {
      this.queryParameters = new ArrayList<>();
    }
    this.queryParameters.add(queryParametersItem);
    return this;
  }

  /**
   * Query parameters for GoogleSQL queries.
   * @return queryParameters
   */
  @javax.annotation.Nullable
  public List<QueryParameter> getQueryParameters() {
    return queryParameters;
  }

  public void setQueryParameters(List<QueryParameter> queryParameters) {
    this.queryParameters = queryParameters;
  }


  public JobConfigurationQuery rangePartitioning(RangePartitioning rangePartitioning) {
    this.rangePartitioning = rangePartitioning;
    return this;
  }

  /**
   * Get rangePartitioning
   * @return rangePartitioning
   */
  @javax.annotation.Nullable
  public RangePartitioning getRangePartitioning() {
    return rangePartitioning;
  }

  public void setRangePartitioning(RangePartitioning rangePartitioning) {
    this.rangePartitioning = rangePartitioning;
  }


  public JobConfigurationQuery schemaUpdateOptions(List<String> schemaUpdateOptions) {
    this.schemaUpdateOptions = schemaUpdateOptions;
    return this;
  }

  public JobConfigurationQuery addSchemaUpdateOptionsItem(String schemaUpdateOptionsItem) {
    if (this.schemaUpdateOptions == null) {
      this.schemaUpdateOptions = new ArrayList<>();
    }
    this.schemaUpdateOptions.add(schemaUpdateOptionsItem);
    return this;
  }

  /**
   * Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
   * @return schemaUpdateOptions
   */
  @javax.annotation.Nullable
  public List<String> getSchemaUpdateOptions() {
    return schemaUpdateOptions;
  }

  public void setSchemaUpdateOptions(List<String> schemaUpdateOptions) {
    this.schemaUpdateOptions = schemaUpdateOptions;
  }


  public JobConfigurationQuery scriptOptions(ScriptOptions scriptOptions) {
    this.scriptOptions = scriptOptions;
    return this;
  }

  /**
   * Get scriptOptions
   * @return scriptOptions
   */
  @javax.annotation.Nullable
  public ScriptOptions getScriptOptions() {
    return scriptOptions;
  }

  public void setScriptOptions(ScriptOptions scriptOptions) {
    this.scriptOptions = scriptOptions;
  }


  public JobConfigurationQuery systemVariables(SystemVariables systemVariables) {
    this.systemVariables = systemVariables;
    return this;
  }

  /**
   * Get systemVariables
   * @return systemVariables
   */
  @javax.annotation.Nullable
  public SystemVariables getSystemVariables() {
    return systemVariables;
  }

  public void setSystemVariables(SystemVariables systemVariables) {
    this.systemVariables = systemVariables;
  }


  public JobConfigurationQuery tableDefinitions(Map<String, ExternalDataConfiguration> tableDefinitions) {
    this.tableDefinitions = tableDefinitions;
    return this;
  }

  public JobConfigurationQuery putTableDefinitionsItem(String key, ExternalDataConfiguration tableDefinitionsItem) {
    if (this.tableDefinitions == null) {
      this.tableDefinitions = new HashMap<>();
    }
    this.tableDefinitions.put(key, tableDefinitionsItem);
    return this;
  }

  /**
   * Optional. You can specify external table definitions, which operate as ephemeral tables that can be queried. These definitions are configured using a JSON map, where the string key represents the table identifier, and the value is the corresponding external data configuration object.
   * @return tableDefinitions
   */
  @javax.annotation.Nullable
  public Map<String, ExternalDataConfiguration> getTableDefinitions() {
    return tableDefinitions;
  }

  public void setTableDefinitions(Map<String, ExternalDataConfiguration> tableDefinitions) {
    this.tableDefinitions = tableDefinitions;
  }


  public JobConfigurationQuery timePartitioning(TimePartitioning timePartitioning) {
    this.timePartitioning = timePartitioning;
    return this;
  }

  /**
   * Get timePartitioning
   * @return timePartitioning
   */
  @javax.annotation.Nullable
  public TimePartitioning getTimePartitioning() {
    return timePartitioning;
  }

  public void setTimePartitioning(TimePartitioning timePartitioning) {
    this.timePartitioning = timePartitioning;
  }


  public JobConfigurationQuery useLegacySql(Boolean useLegacySql) {
    this.useLegacySql = useLegacySql;
    return this;
  }

  /**
   * Optional. Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s GoogleSQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
   * @return useLegacySql
   */
  @javax.annotation.Nullable
  public Boolean getUseLegacySql() {
    return useLegacySql;
  }

  public void setUseLegacySql(Boolean useLegacySql) {
    this.useLegacySql = useLegacySql;
  }


  public JobConfigurationQuery useQueryCache(Boolean useQueryCache) {
    this.useQueryCache = useQueryCache;
    return this;
  }

  /**
   * Optional. Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
   * @return useQueryCache
   */
  @javax.annotation.Nullable
  public Boolean getUseQueryCache() {
    return useQueryCache;
  }

  public void setUseQueryCache(Boolean useQueryCache) {
    this.useQueryCache = useQueryCache;
  }


  public JobConfigurationQuery userDefinedFunctionResources(List<UserDefinedFunctionResource> userDefinedFunctionResources) {
    this.userDefinedFunctionResources = userDefinedFunctionResources;
    return this;
  }

  public JobConfigurationQuery addUserDefinedFunctionResourcesItem(UserDefinedFunctionResource userDefinedFunctionResourcesItem) {
    if (this.userDefinedFunctionResources == null) {
      this.userDefinedFunctionResources = new ArrayList<>();
    }
    this.userDefinedFunctionResources.add(userDefinedFunctionResourcesItem);
    return this;
  }

  /**
   * Describes user-defined function resources used in the query.
   * @return userDefinedFunctionResources
   */
  @javax.annotation.Nullable
  public List<UserDefinedFunctionResource> getUserDefinedFunctionResources() {
    return userDefinedFunctionResources;
  }

  public void setUserDefinedFunctionResources(List<UserDefinedFunctionResource> userDefinedFunctionResources) {
    this.userDefinedFunctionResources = userDefinedFunctionResources;
  }


  public JobConfigurationQuery writeDisposition(String writeDisposition) {
    this.writeDisposition = writeDisposition;
    return this;
  }

  /**
   * Optional. Specifies the action that occurs if the destination table already exists. The following values are supported: * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the data, removes the constraints, and uses the schema from the query result. * WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. * WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
   * @return writeDisposition
   */
  @javax.annotation.Nullable
  public String getWriteDisposition() {
    return writeDisposition;
  }

  public void setWriteDisposition(String writeDisposition) {
    this.writeDisposition = writeDisposition;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobConfigurationQuery jobConfigurationQuery = (JobConfigurationQuery) o;
    return Objects.equals(this.allowLargeResults, jobConfigurationQuery.allowLargeResults) &&
        Objects.equals(this.clustering, jobConfigurationQuery.clustering) &&
        Objects.equals(this.connectionProperties, jobConfigurationQuery.connectionProperties) &&
        Objects.equals(this.continuous, jobConfigurationQuery.continuous) &&
        Objects.equals(this.createDisposition, jobConfigurationQuery.createDisposition) &&
        Objects.equals(this.createSession, jobConfigurationQuery.createSession) &&
        Objects.equals(this.defaultDataset, jobConfigurationQuery.defaultDataset) &&
        Objects.equals(this.destinationEncryptionConfiguration, jobConfigurationQuery.destinationEncryptionConfiguration) &&
        Objects.equals(this.destinationTable, jobConfigurationQuery.destinationTable) &&
        Objects.equals(this.flattenResults, jobConfigurationQuery.flattenResults) &&
        Objects.equals(this.maximumBillingTier, jobConfigurationQuery.maximumBillingTier) &&
        Objects.equals(this.maximumBytesBilled, jobConfigurationQuery.maximumBytesBilled) &&
        Objects.equals(this.parameterMode, jobConfigurationQuery.parameterMode) &&
        Objects.equals(this.preserveNulls, jobConfigurationQuery.preserveNulls) &&
        Objects.equals(this.priority, jobConfigurationQuery.priority) &&
        Objects.equals(this.query, jobConfigurationQuery.query) &&
        Objects.equals(this.queryParameters, jobConfigurationQuery.queryParameters) &&
        Objects.equals(this.rangePartitioning, jobConfigurationQuery.rangePartitioning) &&
        Objects.equals(this.schemaUpdateOptions, jobConfigurationQuery.schemaUpdateOptions) &&
        Objects.equals(this.scriptOptions, jobConfigurationQuery.scriptOptions) &&
        Objects.equals(this.systemVariables, jobConfigurationQuery.systemVariables) &&
        Objects.equals(this.tableDefinitions, jobConfigurationQuery.tableDefinitions) &&
        Objects.equals(this.timePartitioning, jobConfigurationQuery.timePartitioning) &&
        Objects.equals(this.useLegacySql, jobConfigurationQuery.useLegacySql) &&
        Objects.equals(this.useQueryCache, jobConfigurationQuery.useQueryCache) &&
        Objects.equals(this.userDefinedFunctionResources, jobConfigurationQuery.userDefinedFunctionResources) &&
        Objects.equals(this.writeDisposition, jobConfigurationQuery.writeDisposition);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowLargeResults, clustering, connectionProperties, continuous, createDisposition, createSession, defaultDataset, destinationEncryptionConfiguration, destinationTable, flattenResults, maximumBillingTier, maximumBytesBilled, parameterMode, preserveNulls, priority, query, queryParameters, rangePartitioning, schemaUpdateOptions, scriptOptions, systemVariables, tableDefinitions, timePartitioning, useLegacySql, useQueryCache, userDefinedFunctionResources, writeDisposition);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobConfigurationQuery {\n");
    sb.append("    allowLargeResults: ").append(toIndentedString(allowLargeResults)).append("\n");
    sb.append("    clustering: ").append(toIndentedString(clustering)).append("\n");
    sb.append("    connectionProperties: ").append(toIndentedString(connectionProperties)).append("\n");
    sb.append("    continuous: ").append(toIndentedString(continuous)).append("\n");
    sb.append("    createDisposition: ").append(toIndentedString(createDisposition)).append("\n");
    sb.append("    createSession: ").append(toIndentedString(createSession)).append("\n");
    sb.append("    defaultDataset: ").append(toIndentedString(defaultDataset)).append("\n");
    sb.append("    destinationEncryptionConfiguration: ").append(toIndentedString(destinationEncryptionConfiguration)).append("\n");
    sb.append("    destinationTable: ").append(toIndentedString(destinationTable)).append("\n");
    sb.append("    flattenResults: ").append(toIndentedString(flattenResults)).append("\n");
    sb.append("    maximumBillingTier: ").append(toIndentedString(maximumBillingTier)).append("\n");
    sb.append("    maximumBytesBilled: ").append(toIndentedString(maximumBytesBilled)).append("\n");
    sb.append("    parameterMode: ").append(toIndentedString(parameterMode)).append("\n");
    sb.append("    preserveNulls: ").append(toIndentedString(preserveNulls)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    queryParameters: ").append(toIndentedString(queryParameters)).append("\n");
    sb.append("    rangePartitioning: ").append(toIndentedString(rangePartitioning)).append("\n");
    sb.append("    schemaUpdateOptions: ").append(toIndentedString(schemaUpdateOptions)).append("\n");
    sb.append("    scriptOptions: ").append(toIndentedString(scriptOptions)).append("\n");
    sb.append("    systemVariables: ").append(toIndentedString(systemVariables)).append("\n");
    sb.append("    tableDefinitions: ").append(toIndentedString(tableDefinitions)).append("\n");
    sb.append("    timePartitioning: ").append(toIndentedString(timePartitioning)).append("\n");
    sb.append("    useLegacySql: ").append(toIndentedString(useLegacySql)).append("\n");
    sb.append("    useQueryCache: ").append(toIndentedString(useQueryCache)).append("\n");
    sb.append("    userDefinedFunctionResources: ").append(toIndentedString(userDefinedFunctionResources)).append("\n");
    sb.append("    writeDisposition: ").append(toIndentedString(writeDisposition)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowLargeResults");
    openapiFields.add("clustering");
    openapiFields.add("connectionProperties");
    openapiFields.add("continuous");
    openapiFields.add("createDisposition");
    openapiFields.add("createSession");
    openapiFields.add("defaultDataset");
    openapiFields.add("destinationEncryptionConfiguration");
    openapiFields.add("destinationTable");
    openapiFields.add("flattenResults");
    openapiFields.add("maximumBillingTier");
    openapiFields.add("maximumBytesBilled");
    openapiFields.add("parameterMode");
    openapiFields.add("preserveNulls");
    openapiFields.add("priority");
    openapiFields.add("query");
    openapiFields.add("queryParameters");
    openapiFields.add("rangePartitioning");
    openapiFields.add("schemaUpdateOptions");
    openapiFields.add("scriptOptions");
    openapiFields.add("systemVariables");
    openapiFields.add("tableDefinitions");
    openapiFields.add("timePartitioning");
    openapiFields.add("useLegacySql");
    openapiFields.add("useQueryCache");
    openapiFields.add("userDefinedFunctionResources");
    openapiFields.add("writeDisposition");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to JobConfigurationQuery
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JobConfigurationQuery.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JobConfigurationQuery is not found in the empty JSON string", JobConfigurationQuery.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JobConfigurationQuery.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JobConfigurationQuery` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `clustering`
      if (jsonObj.get("clustering") != null && !jsonObj.get("clustering").isJsonNull()) {
        Clustering.validateJsonElement(jsonObj.get("clustering"));
      }
      if (jsonObj.get("connectionProperties") != null && !jsonObj.get("connectionProperties").isJsonNull()) {
        JsonArray jsonArrayconnectionProperties = jsonObj.getAsJsonArray("connectionProperties");
        if (jsonArrayconnectionProperties != null) {
          // ensure the json data is an array
          if (!jsonObj.get("connectionProperties").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `connectionProperties` to be an array in the JSON string but got `%s`", jsonObj.get("connectionProperties").toString()));
          }

          // validate the optional field `connectionProperties` (array)
          for (int i = 0; i < jsonArrayconnectionProperties.size(); i++) {
            ConnectionProperty.validateJsonElement(jsonArrayconnectionProperties.get(i));
          };
        }
      }
      if ((jsonObj.get("createDisposition") != null && !jsonObj.get("createDisposition").isJsonNull()) && !jsonObj.get("createDisposition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createDisposition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createDisposition").toString()));
      }
      // validate the optional field `defaultDataset`
      if (jsonObj.get("defaultDataset") != null && !jsonObj.get("defaultDataset").isJsonNull()) {
        DatasetReference.validateJsonElement(jsonObj.get("defaultDataset"));
      }
      // validate the optional field `destinationEncryptionConfiguration`
      if (jsonObj.get("destinationEncryptionConfiguration") != null && !jsonObj.get("destinationEncryptionConfiguration").isJsonNull()) {
        EncryptionConfiguration.validateJsonElement(jsonObj.get("destinationEncryptionConfiguration"));
      }
      // validate the optional field `destinationTable`
      if (jsonObj.get("destinationTable") != null && !jsonObj.get("destinationTable").isJsonNull()) {
        TableReference.validateJsonElement(jsonObj.get("destinationTable"));
      }
      if ((jsonObj.get("maximumBytesBilled") != null && !jsonObj.get("maximumBytesBilled").isJsonNull()) && !jsonObj.get("maximumBytesBilled").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumBytesBilled` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumBytesBilled").toString()));
      }
      if ((jsonObj.get("parameterMode") != null && !jsonObj.get("parameterMode").isJsonNull()) && !jsonObj.get("parameterMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parameterMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parameterMode").toString()));
      }
      if ((jsonObj.get("priority") != null && !jsonObj.get("priority").isJsonNull()) && !jsonObj.get("priority").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priority` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priority").toString()));
      }
      if ((jsonObj.get("query") != null && !jsonObj.get("query").isJsonNull()) && !jsonObj.get("query").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `query` to be a primitive type in the JSON string but got `%s`", jsonObj.get("query").toString()));
      }
      if (jsonObj.get("queryParameters") != null && !jsonObj.get("queryParameters").isJsonNull()) {
        JsonArray jsonArrayqueryParameters = jsonObj.getAsJsonArray("queryParameters");
        if (jsonArrayqueryParameters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("queryParameters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `queryParameters` to be an array in the JSON string but got `%s`", jsonObj.get("queryParameters").toString()));
          }

          // validate the optional field `queryParameters` (array)
          for (int i = 0; i < jsonArrayqueryParameters.size(); i++) {
            QueryParameter.validateJsonElement(jsonArrayqueryParameters.get(i));
          };
        }
      }
      // validate the optional field `rangePartitioning`
      if (jsonObj.get("rangePartitioning") != null && !jsonObj.get("rangePartitioning").isJsonNull()) {
        RangePartitioning.validateJsonElement(jsonObj.get("rangePartitioning"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("schemaUpdateOptions") != null && !jsonObj.get("schemaUpdateOptions").isJsonNull() && !jsonObj.get("schemaUpdateOptions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemaUpdateOptions` to be an array in the JSON string but got `%s`", jsonObj.get("schemaUpdateOptions").toString()));
      }
      // validate the optional field `scriptOptions`
      if (jsonObj.get("scriptOptions") != null && !jsonObj.get("scriptOptions").isJsonNull()) {
        ScriptOptions.validateJsonElement(jsonObj.get("scriptOptions"));
      }
      // validate the optional field `systemVariables`
      if (jsonObj.get("systemVariables") != null && !jsonObj.get("systemVariables").isJsonNull()) {
        SystemVariables.validateJsonElement(jsonObj.get("systemVariables"));
      }
      // validate the optional field `timePartitioning`
      if (jsonObj.get("timePartitioning") != null && !jsonObj.get("timePartitioning").isJsonNull()) {
        TimePartitioning.validateJsonElement(jsonObj.get("timePartitioning"));
      }
      if (jsonObj.get("userDefinedFunctionResources") != null && !jsonObj.get("userDefinedFunctionResources").isJsonNull()) {
        JsonArray jsonArrayuserDefinedFunctionResources = jsonObj.getAsJsonArray("userDefinedFunctionResources");
        if (jsonArrayuserDefinedFunctionResources != null) {
          // ensure the json data is an array
          if (!jsonObj.get("userDefinedFunctionResources").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `userDefinedFunctionResources` to be an array in the JSON string but got `%s`", jsonObj.get("userDefinedFunctionResources").toString()));
          }

          // validate the optional field `userDefinedFunctionResources` (array)
          for (int i = 0; i < jsonArrayuserDefinedFunctionResources.size(); i++) {
            UserDefinedFunctionResource.validateJsonElement(jsonArrayuserDefinedFunctionResources.get(i));
          };
        }
      }
      if ((jsonObj.get("writeDisposition") != null && !jsonObj.get("writeDisposition").isJsonNull()) && !jsonObj.get("writeDisposition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `writeDisposition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("writeDisposition").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JobConfigurationQuery.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JobConfigurationQuery' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JobConfigurationQuery> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JobConfigurationQuery.class));

       return (TypeAdapter<T>) new TypeAdapter<JobConfigurationQuery>() {
           @Override
           public void write(JsonWriter out, JobConfigurationQuery value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JobConfigurationQuery read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of JobConfigurationQuery given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of JobConfigurationQuery
   * @throws IOException if the JSON string is invalid with respect to JobConfigurationQuery
   */
  public static JobConfigurationQuery fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JobConfigurationQuery.class);
  }

  /**
   * Convert an instance of JobConfigurationQuery to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

