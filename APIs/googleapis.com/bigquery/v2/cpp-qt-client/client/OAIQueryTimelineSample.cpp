/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIQueryTimelineSample.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIQueryTimelineSample::OAIQueryTimelineSample(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIQueryTimelineSample::OAIQueryTimelineSample() {
    this->initializeModel();
}

OAIQueryTimelineSample::~OAIQueryTimelineSample() {}

void OAIQueryTimelineSample::initializeModel() {

    m_active_units_isSet = false;
    m_active_units_isValid = false;

    m_completed_units_isSet = false;
    m_completed_units_isValid = false;

    m_elapsed_ms_isSet = false;
    m_elapsed_ms_isValid = false;

    m_estimated_runnable_units_isSet = false;
    m_estimated_runnable_units_isValid = false;

    m_pending_units_isSet = false;
    m_pending_units_isValid = false;

    m_total_slot_ms_isSet = false;
    m_total_slot_ms_isValid = false;
}

void OAIQueryTimelineSample::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIQueryTimelineSample::fromJsonObject(QJsonObject json) {

    m_active_units_isValid = ::OpenAPI::fromJsonValue(m_active_units, json[QString("activeUnits")]);
    m_active_units_isSet = !json[QString("activeUnits")].isNull() && m_active_units_isValid;

    m_completed_units_isValid = ::OpenAPI::fromJsonValue(m_completed_units, json[QString("completedUnits")]);
    m_completed_units_isSet = !json[QString("completedUnits")].isNull() && m_completed_units_isValid;

    m_elapsed_ms_isValid = ::OpenAPI::fromJsonValue(m_elapsed_ms, json[QString("elapsedMs")]);
    m_elapsed_ms_isSet = !json[QString("elapsedMs")].isNull() && m_elapsed_ms_isValid;

    m_estimated_runnable_units_isValid = ::OpenAPI::fromJsonValue(m_estimated_runnable_units, json[QString("estimatedRunnableUnits")]);
    m_estimated_runnable_units_isSet = !json[QString("estimatedRunnableUnits")].isNull() && m_estimated_runnable_units_isValid;

    m_pending_units_isValid = ::OpenAPI::fromJsonValue(m_pending_units, json[QString("pendingUnits")]);
    m_pending_units_isSet = !json[QString("pendingUnits")].isNull() && m_pending_units_isValid;

    m_total_slot_ms_isValid = ::OpenAPI::fromJsonValue(m_total_slot_ms, json[QString("totalSlotMs")]);
    m_total_slot_ms_isSet = !json[QString("totalSlotMs")].isNull() && m_total_slot_ms_isValid;
}

QString OAIQueryTimelineSample::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIQueryTimelineSample::asJsonObject() const {
    QJsonObject obj;
    if (m_active_units_isSet) {
        obj.insert(QString("activeUnits"), ::OpenAPI::toJsonValue(m_active_units));
    }
    if (m_completed_units_isSet) {
        obj.insert(QString("completedUnits"), ::OpenAPI::toJsonValue(m_completed_units));
    }
    if (m_elapsed_ms_isSet) {
        obj.insert(QString("elapsedMs"), ::OpenAPI::toJsonValue(m_elapsed_ms));
    }
    if (m_estimated_runnable_units_isSet) {
        obj.insert(QString("estimatedRunnableUnits"), ::OpenAPI::toJsonValue(m_estimated_runnable_units));
    }
    if (m_pending_units_isSet) {
        obj.insert(QString("pendingUnits"), ::OpenAPI::toJsonValue(m_pending_units));
    }
    if (m_total_slot_ms_isSet) {
        obj.insert(QString("totalSlotMs"), ::OpenAPI::toJsonValue(m_total_slot_ms));
    }
    return obj;
}

QString OAIQueryTimelineSample::getActiveUnits() const {
    return m_active_units;
}
void OAIQueryTimelineSample::setActiveUnits(const QString &active_units) {
    m_active_units = active_units;
    m_active_units_isSet = true;
}

bool OAIQueryTimelineSample::is_active_units_Set() const{
    return m_active_units_isSet;
}

bool OAIQueryTimelineSample::is_active_units_Valid() const{
    return m_active_units_isValid;
}

QString OAIQueryTimelineSample::getCompletedUnits() const {
    return m_completed_units;
}
void OAIQueryTimelineSample::setCompletedUnits(const QString &completed_units) {
    m_completed_units = completed_units;
    m_completed_units_isSet = true;
}

bool OAIQueryTimelineSample::is_completed_units_Set() const{
    return m_completed_units_isSet;
}

bool OAIQueryTimelineSample::is_completed_units_Valid() const{
    return m_completed_units_isValid;
}

QString OAIQueryTimelineSample::getElapsedMs() const {
    return m_elapsed_ms;
}
void OAIQueryTimelineSample::setElapsedMs(const QString &elapsed_ms) {
    m_elapsed_ms = elapsed_ms;
    m_elapsed_ms_isSet = true;
}

bool OAIQueryTimelineSample::is_elapsed_ms_Set() const{
    return m_elapsed_ms_isSet;
}

bool OAIQueryTimelineSample::is_elapsed_ms_Valid() const{
    return m_elapsed_ms_isValid;
}

QString OAIQueryTimelineSample::getEstimatedRunnableUnits() const {
    return m_estimated_runnable_units;
}
void OAIQueryTimelineSample::setEstimatedRunnableUnits(const QString &estimated_runnable_units) {
    m_estimated_runnable_units = estimated_runnable_units;
    m_estimated_runnable_units_isSet = true;
}

bool OAIQueryTimelineSample::is_estimated_runnable_units_Set() const{
    return m_estimated_runnable_units_isSet;
}

bool OAIQueryTimelineSample::is_estimated_runnable_units_Valid() const{
    return m_estimated_runnable_units_isValid;
}

QString OAIQueryTimelineSample::getPendingUnits() const {
    return m_pending_units;
}
void OAIQueryTimelineSample::setPendingUnits(const QString &pending_units) {
    m_pending_units = pending_units;
    m_pending_units_isSet = true;
}

bool OAIQueryTimelineSample::is_pending_units_Set() const{
    return m_pending_units_isSet;
}

bool OAIQueryTimelineSample::is_pending_units_Valid() const{
    return m_pending_units_isValid;
}

QString OAIQueryTimelineSample::getTotalSlotMs() const {
    return m_total_slot_ms;
}
void OAIQueryTimelineSample::setTotalSlotMs(const QString &total_slot_ms) {
    m_total_slot_ms = total_slot_ms;
    m_total_slot_ms_isSet = true;
}

bool OAIQueryTimelineSample::is_total_slot_ms_Set() const{
    return m_total_slot_ms_isSet;
}

bool OAIQueryTimelineSample::is_total_slot_ms_Valid() const{
    return m_total_slot_ms_isValid;
}

bool OAIQueryTimelineSample::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_active_units_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_completed_units_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_elapsed_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_estimated_runnable_units_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pending_units_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_slot_ms_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIQueryTimelineSample::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
