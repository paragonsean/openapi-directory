/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITrainingOptions.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITrainingOptions::OAITrainingOptions(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITrainingOptions::OAITrainingOptions() {
    this->initializeModel();
}

OAITrainingOptions::~OAITrainingOptions() {}

void OAITrainingOptions::initializeModel() {

    m_activation_fn_isSet = false;
    m_activation_fn_isValid = false;

    m_adjust_step_changes_isSet = false;
    m_adjust_step_changes_isValid = false;

    m_approx_global_feature_contrib_isSet = false;
    m_approx_global_feature_contrib_isValid = false;

    m_auto_arima_isSet = false;
    m_auto_arima_isValid = false;

    m_auto_arima_max_order_isSet = false;
    m_auto_arima_max_order_isValid = false;

    m_auto_arima_min_order_isSet = false;
    m_auto_arima_min_order_isValid = false;

    m_auto_class_weights_isSet = false;
    m_auto_class_weights_isValid = false;

    m_batch_size_isSet = false;
    m_batch_size_isValid = false;

    m_booster_type_isSet = false;
    m_booster_type_isValid = false;

    m_budget_hours_isSet = false;
    m_budget_hours_isValid = false;

    m_calculate_p_values_isSet = false;
    m_calculate_p_values_isValid = false;

    m_category_encoding_method_isSet = false;
    m_category_encoding_method_isValid = false;

    m_clean_spikes_and_dips_isSet = false;
    m_clean_spikes_and_dips_isValid = false;

    m_color_space_isSet = false;
    m_color_space_isValid = false;

    m_colsample_bylevel_isSet = false;
    m_colsample_bylevel_isValid = false;

    m_colsample_bynode_isSet = false;
    m_colsample_bynode_isValid = false;

    m_colsample_bytree_isSet = false;
    m_colsample_bytree_isValid = false;

    m_dart_normalize_type_isSet = false;
    m_dart_normalize_type_isValid = false;

    m_data_frequency_isSet = false;
    m_data_frequency_isValid = false;

    m_data_split_column_isSet = false;
    m_data_split_column_isValid = false;

    m_data_split_eval_fraction_isSet = false;
    m_data_split_eval_fraction_isValid = false;

    m_data_split_method_isSet = false;
    m_data_split_method_isValid = false;

    m_decompose_time_series_isSet = false;
    m_decompose_time_series_isValid = false;

    m_distance_type_isSet = false;
    m_distance_type_isValid = false;

    m_dropout_isSet = false;
    m_dropout_isValid = false;

    m_early_stop_isSet = false;
    m_early_stop_isValid = false;

    m_enable_global_explain_isSet = false;
    m_enable_global_explain_isValid = false;

    m_feedback_type_isSet = false;
    m_feedback_type_isValid = false;

    m_fit_intercept_isSet = false;
    m_fit_intercept_isValid = false;

    m_hidden_units_isSet = false;
    m_hidden_units_isValid = false;

    m_holiday_region_isSet = false;
    m_holiday_region_isValid = false;

    m_holiday_regions_isSet = false;
    m_holiday_regions_isValid = false;

    m_horizon_isSet = false;
    m_horizon_isValid = false;

    m_hparam_tuning_objectives_isSet = false;
    m_hparam_tuning_objectives_isValid = false;

    m_include_drift_isSet = false;
    m_include_drift_isValid = false;

    m_initial_learn_rate_isSet = false;
    m_initial_learn_rate_isValid = false;

    m_input_label_columns_isSet = false;
    m_input_label_columns_isValid = false;

    m_instance_weight_column_isSet = false;
    m_instance_weight_column_isValid = false;

    m_integrated_gradients_num_steps_isSet = false;
    m_integrated_gradients_num_steps_isValid = false;

    m_item_column_isSet = false;
    m_item_column_isValid = false;

    m_kmeans_initialization_column_isSet = false;
    m_kmeans_initialization_column_isValid = false;

    m_kmeans_initialization_method_isSet = false;
    m_kmeans_initialization_method_isValid = false;

    m_l1_reg_activation_isSet = false;
    m_l1_reg_activation_isValid = false;

    m_l1_regularization_isSet = false;
    m_l1_regularization_isValid = false;

    m_l2_regularization_isSet = false;
    m_l2_regularization_isValid = false;

    m_label_class_weights_isSet = false;
    m_label_class_weights_isValid = false;

    m_learn_rate_isSet = false;
    m_learn_rate_isValid = false;

    m_learn_rate_strategy_isSet = false;
    m_learn_rate_strategy_isValid = false;

    m_loss_type_isSet = false;
    m_loss_type_isValid = false;

    m_max_iterations_isSet = false;
    m_max_iterations_isValid = false;

    m_max_parallel_trials_isSet = false;
    m_max_parallel_trials_isValid = false;

    m_max_time_series_length_isSet = false;
    m_max_time_series_length_isValid = false;

    m_max_tree_depth_isSet = false;
    m_max_tree_depth_isValid = false;

    m_min_relative_progress_isSet = false;
    m_min_relative_progress_isValid = false;

    m_min_split_loss_isSet = false;
    m_min_split_loss_isValid = false;

    m_min_time_series_length_isSet = false;
    m_min_time_series_length_isValid = false;

    m_min_tree_child_weight_isSet = false;
    m_min_tree_child_weight_isValid = false;

    m_model_registry_isSet = false;
    m_model_registry_isValid = false;

    m_model_uri_isSet = false;
    m_model_uri_isValid = false;

    m_non_seasonal_order_isSet = false;
    m_non_seasonal_order_isValid = false;

    m_num_clusters_isSet = false;
    m_num_clusters_isValid = false;

    m_num_factors_isSet = false;
    m_num_factors_isValid = false;

    m_num_parallel_tree_isSet = false;
    m_num_parallel_tree_isValid = false;

    m_num_principal_components_isSet = false;
    m_num_principal_components_isValid = false;

    m_num_trials_isSet = false;
    m_num_trials_isValid = false;

    m_optimization_strategy_isSet = false;
    m_optimization_strategy_isValid = false;

    m_optimizer_isSet = false;
    m_optimizer_isValid = false;

    m_pca_explained_variance_ratio_isSet = false;
    m_pca_explained_variance_ratio_isValid = false;

    m_pca_solver_isSet = false;
    m_pca_solver_isValid = false;

    m_sampled_shapley_num_paths_isSet = false;
    m_sampled_shapley_num_paths_isValid = false;

    m_scale_features_isSet = false;
    m_scale_features_isValid = false;

    m_standardize_features_isSet = false;
    m_standardize_features_isValid = false;

    m_subsample_isSet = false;
    m_subsample_isValid = false;

    m_tf_version_isSet = false;
    m_tf_version_isValid = false;

    m_time_series_data_column_isSet = false;
    m_time_series_data_column_isValid = false;

    m_time_series_id_column_isSet = false;
    m_time_series_id_column_isValid = false;

    m_time_series_id_columns_isSet = false;
    m_time_series_id_columns_isValid = false;

    m_time_series_length_fraction_isSet = false;
    m_time_series_length_fraction_isValid = false;

    m_time_series_timestamp_column_isSet = false;
    m_time_series_timestamp_column_isValid = false;

    m_tree_method_isSet = false;
    m_tree_method_isValid = false;

    m_trend_smoothing_window_size_isSet = false;
    m_trend_smoothing_window_size_isValid = false;

    m_user_column_isSet = false;
    m_user_column_isValid = false;

    m_vertex_ai_model_version_aliases_isSet = false;
    m_vertex_ai_model_version_aliases_isValid = false;

    m_wals_alpha_isSet = false;
    m_wals_alpha_isValid = false;

    m_warm_start_isSet = false;
    m_warm_start_isValid = false;

    m_xgboost_version_isSet = false;
    m_xgboost_version_isValid = false;
}

void OAITrainingOptions::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITrainingOptions::fromJsonObject(QJsonObject json) {

    m_activation_fn_isValid = ::OpenAPI::fromJsonValue(m_activation_fn, json[QString("activationFn")]);
    m_activation_fn_isSet = !json[QString("activationFn")].isNull() && m_activation_fn_isValid;

    m_adjust_step_changes_isValid = ::OpenAPI::fromJsonValue(m_adjust_step_changes, json[QString("adjustStepChanges")]);
    m_adjust_step_changes_isSet = !json[QString("adjustStepChanges")].isNull() && m_adjust_step_changes_isValid;

    m_approx_global_feature_contrib_isValid = ::OpenAPI::fromJsonValue(m_approx_global_feature_contrib, json[QString("approxGlobalFeatureContrib")]);
    m_approx_global_feature_contrib_isSet = !json[QString("approxGlobalFeatureContrib")].isNull() && m_approx_global_feature_contrib_isValid;

    m_auto_arima_isValid = ::OpenAPI::fromJsonValue(m_auto_arima, json[QString("autoArima")]);
    m_auto_arima_isSet = !json[QString("autoArima")].isNull() && m_auto_arima_isValid;

    m_auto_arima_max_order_isValid = ::OpenAPI::fromJsonValue(m_auto_arima_max_order, json[QString("autoArimaMaxOrder")]);
    m_auto_arima_max_order_isSet = !json[QString("autoArimaMaxOrder")].isNull() && m_auto_arima_max_order_isValid;

    m_auto_arima_min_order_isValid = ::OpenAPI::fromJsonValue(m_auto_arima_min_order, json[QString("autoArimaMinOrder")]);
    m_auto_arima_min_order_isSet = !json[QString("autoArimaMinOrder")].isNull() && m_auto_arima_min_order_isValid;

    m_auto_class_weights_isValid = ::OpenAPI::fromJsonValue(m_auto_class_weights, json[QString("autoClassWeights")]);
    m_auto_class_weights_isSet = !json[QString("autoClassWeights")].isNull() && m_auto_class_weights_isValid;

    m_batch_size_isValid = ::OpenAPI::fromJsonValue(m_batch_size, json[QString("batchSize")]);
    m_batch_size_isSet = !json[QString("batchSize")].isNull() && m_batch_size_isValid;

    m_booster_type_isValid = ::OpenAPI::fromJsonValue(m_booster_type, json[QString("boosterType")]);
    m_booster_type_isSet = !json[QString("boosterType")].isNull() && m_booster_type_isValid;

    m_budget_hours_isValid = ::OpenAPI::fromJsonValue(m_budget_hours, json[QString("budgetHours")]);
    m_budget_hours_isSet = !json[QString("budgetHours")].isNull() && m_budget_hours_isValid;

    m_calculate_p_values_isValid = ::OpenAPI::fromJsonValue(m_calculate_p_values, json[QString("calculatePValues")]);
    m_calculate_p_values_isSet = !json[QString("calculatePValues")].isNull() && m_calculate_p_values_isValid;

    m_category_encoding_method_isValid = ::OpenAPI::fromJsonValue(m_category_encoding_method, json[QString("categoryEncodingMethod")]);
    m_category_encoding_method_isSet = !json[QString("categoryEncodingMethod")].isNull() && m_category_encoding_method_isValid;

    m_clean_spikes_and_dips_isValid = ::OpenAPI::fromJsonValue(m_clean_spikes_and_dips, json[QString("cleanSpikesAndDips")]);
    m_clean_spikes_and_dips_isSet = !json[QString("cleanSpikesAndDips")].isNull() && m_clean_spikes_and_dips_isValid;

    m_color_space_isValid = ::OpenAPI::fromJsonValue(m_color_space, json[QString("colorSpace")]);
    m_color_space_isSet = !json[QString("colorSpace")].isNull() && m_color_space_isValid;

    m_colsample_bylevel_isValid = ::OpenAPI::fromJsonValue(m_colsample_bylevel, json[QString("colsampleBylevel")]);
    m_colsample_bylevel_isSet = !json[QString("colsampleBylevel")].isNull() && m_colsample_bylevel_isValid;

    m_colsample_bynode_isValid = ::OpenAPI::fromJsonValue(m_colsample_bynode, json[QString("colsampleBynode")]);
    m_colsample_bynode_isSet = !json[QString("colsampleBynode")].isNull() && m_colsample_bynode_isValid;

    m_colsample_bytree_isValid = ::OpenAPI::fromJsonValue(m_colsample_bytree, json[QString("colsampleBytree")]);
    m_colsample_bytree_isSet = !json[QString("colsampleBytree")].isNull() && m_colsample_bytree_isValid;

    m_dart_normalize_type_isValid = ::OpenAPI::fromJsonValue(m_dart_normalize_type, json[QString("dartNormalizeType")]);
    m_dart_normalize_type_isSet = !json[QString("dartNormalizeType")].isNull() && m_dart_normalize_type_isValid;

    m_data_frequency_isValid = ::OpenAPI::fromJsonValue(m_data_frequency, json[QString("dataFrequency")]);
    m_data_frequency_isSet = !json[QString("dataFrequency")].isNull() && m_data_frequency_isValid;

    m_data_split_column_isValid = ::OpenAPI::fromJsonValue(m_data_split_column, json[QString("dataSplitColumn")]);
    m_data_split_column_isSet = !json[QString("dataSplitColumn")].isNull() && m_data_split_column_isValid;

    m_data_split_eval_fraction_isValid = ::OpenAPI::fromJsonValue(m_data_split_eval_fraction, json[QString("dataSplitEvalFraction")]);
    m_data_split_eval_fraction_isSet = !json[QString("dataSplitEvalFraction")].isNull() && m_data_split_eval_fraction_isValid;

    m_data_split_method_isValid = ::OpenAPI::fromJsonValue(m_data_split_method, json[QString("dataSplitMethod")]);
    m_data_split_method_isSet = !json[QString("dataSplitMethod")].isNull() && m_data_split_method_isValid;

    m_decompose_time_series_isValid = ::OpenAPI::fromJsonValue(m_decompose_time_series, json[QString("decomposeTimeSeries")]);
    m_decompose_time_series_isSet = !json[QString("decomposeTimeSeries")].isNull() && m_decompose_time_series_isValid;

    m_distance_type_isValid = ::OpenAPI::fromJsonValue(m_distance_type, json[QString("distanceType")]);
    m_distance_type_isSet = !json[QString("distanceType")].isNull() && m_distance_type_isValid;

    m_dropout_isValid = ::OpenAPI::fromJsonValue(m_dropout, json[QString("dropout")]);
    m_dropout_isSet = !json[QString("dropout")].isNull() && m_dropout_isValid;

    m_early_stop_isValid = ::OpenAPI::fromJsonValue(m_early_stop, json[QString("earlyStop")]);
    m_early_stop_isSet = !json[QString("earlyStop")].isNull() && m_early_stop_isValid;

    m_enable_global_explain_isValid = ::OpenAPI::fromJsonValue(m_enable_global_explain, json[QString("enableGlobalExplain")]);
    m_enable_global_explain_isSet = !json[QString("enableGlobalExplain")].isNull() && m_enable_global_explain_isValid;

    m_feedback_type_isValid = ::OpenAPI::fromJsonValue(m_feedback_type, json[QString("feedbackType")]);
    m_feedback_type_isSet = !json[QString("feedbackType")].isNull() && m_feedback_type_isValid;

    m_fit_intercept_isValid = ::OpenAPI::fromJsonValue(m_fit_intercept, json[QString("fitIntercept")]);
    m_fit_intercept_isSet = !json[QString("fitIntercept")].isNull() && m_fit_intercept_isValid;

    m_hidden_units_isValid = ::OpenAPI::fromJsonValue(m_hidden_units, json[QString("hiddenUnits")]);
    m_hidden_units_isSet = !json[QString("hiddenUnits")].isNull() && m_hidden_units_isValid;

    m_holiday_region_isValid = ::OpenAPI::fromJsonValue(m_holiday_region, json[QString("holidayRegion")]);
    m_holiday_region_isSet = !json[QString("holidayRegion")].isNull() && m_holiday_region_isValid;

    m_holiday_regions_isValid = ::OpenAPI::fromJsonValue(m_holiday_regions, json[QString("holidayRegions")]);
    m_holiday_regions_isSet = !json[QString("holidayRegions")].isNull() && m_holiday_regions_isValid;

    m_horizon_isValid = ::OpenAPI::fromJsonValue(m_horizon, json[QString("horizon")]);
    m_horizon_isSet = !json[QString("horizon")].isNull() && m_horizon_isValid;

    m_hparam_tuning_objectives_isValid = ::OpenAPI::fromJsonValue(m_hparam_tuning_objectives, json[QString("hparamTuningObjectives")]);
    m_hparam_tuning_objectives_isSet = !json[QString("hparamTuningObjectives")].isNull() && m_hparam_tuning_objectives_isValid;

    m_include_drift_isValid = ::OpenAPI::fromJsonValue(m_include_drift, json[QString("includeDrift")]);
    m_include_drift_isSet = !json[QString("includeDrift")].isNull() && m_include_drift_isValid;

    m_initial_learn_rate_isValid = ::OpenAPI::fromJsonValue(m_initial_learn_rate, json[QString("initialLearnRate")]);
    m_initial_learn_rate_isSet = !json[QString("initialLearnRate")].isNull() && m_initial_learn_rate_isValid;

    m_input_label_columns_isValid = ::OpenAPI::fromJsonValue(m_input_label_columns, json[QString("inputLabelColumns")]);
    m_input_label_columns_isSet = !json[QString("inputLabelColumns")].isNull() && m_input_label_columns_isValid;

    m_instance_weight_column_isValid = ::OpenAPI::fromJsonValue(m_instance_weight_column, json[QString("instanceWeightColumn")]);
    m_instance_weight_column_isSet = !json[QString("instanceWeightColumn")].isNull() && m_instance_weight_column_isValid;

    m_integrated_gradients_num_steps_isValid = ::OpenAPI::fromJsonValue(m_integrated_gradients_num_steps, json[QString("integratedGradientsNumSteps")]);
    m_integrated_gradients_num_steps_isSet = !json[QString("integratedGradientsNumSteps")].isNull() && m_integrated_gradients_num_steps_isValid;

    m_item_column_isValid = ::OpenAPI::fromJsonValue(m_item_column, json[QString("itemColumn")]);
    m_item_column_isSet = !json[QString("itemColumn")].isNull() && m_item_column_isValid;

    m_kmeans_initialization_column_isValid = ::OpenAPI::fromJsonValue(m_kmeans_initialization_column, json[QString("kmeansInitializationColumn")]);
    m_kmeans_initialization_column_isSet = !json[QString("kmeansInitializationColumn")].isNull() && m_kmeans_initialization_column_isValid;

    m_kmeans_initialization_method_isValid = ::OpenAPI::fromJsonValue(m_kmeans_initialization_method, json[QString("kmeansInitializationMethod")]);
    m_kmeans_initialization_method_isSet = !json[QString("kmeansInitializationMethod")].isNull() && m_kmeans_initialization_method_isValid;

    m_l1_reg_activation_isValid = ::OpenAPI::fromJsonValue(m_l1_reg_activation, json[QString("l1RegActivation")]);
    m_l1_reg_activation_isSet = !json[QString("l1RegActivation")].isNull() && m_l1_reg_activation_isValid;

    m_l1_regularization_isValid = ::OpenAPI::fromJsonValue(m_l1_regularization, json[QString("l1Regularization")]);
    m_l1_regularization_isSet = !json[QString("l1Regularization")].isNull() && m_l1_regularization_isValid;

    m_l2_regularization_isValid = ::OpenAPI::fromJsonValue(m_l2_regularization, json[QString("l2Regularization")]);
    m_l2_regularization_isSet = !json[QString("l2Regularization")].isNull() && m_l2_regularization_isValid;

    m_label_class_weights_isValid = ::OpenAPI::fromJsonValue(m_label_class_weights, json[QString("labelClassWeights")]);
    m_label_class_weights_isSet = !json[QString("labelClassWeights")].isNull() && m_label_class_weights_isValid;

    m_learn_rate_isValid = ::OpenAPI::fromJsonValue(m_learn_rate, json[QString("learnRate")]);
    m_learn_rate_isSet = !json[QString("learnRate")].isNull() && m_learn_rate_isValid;

    m_learn_rate_strategy_isValid = ::OpenAPI::fromJsonValue(m_learn_rate_strategy, json[QString("learnRateStrategy")]);
    m_learn_rate_strategy_isSet = !json[QString("learnRateStrategy")].isNull() && m_learn_rate_strategy_isValid;

    m_loss_type_isValid = ::OpenAPI::fromJsonValue(m_loss_type, json[QString("lossType")]);
    m_loss_type_isSet = !json[QString("lossType")].isNull() && m_loss_type_isValid;

    m_max_iterations_isValid = ::OpenAPI::fromJsonValue(m_max_iterations, json[QString("maxIterations")]);
    m_max_iterations_isSet = !json[QString("maxIterations")].isNull() && m_max_iterations_isValid;

    m_max_parallel_trials_isValid = ::OpenAPI::fromJsonValue(m_max_parallel_trials, json[QString("maxParallelTrials")]);
    m_max_parallel_trials_isSet = !json[QString("maxParallelTrials")].isNull() && m_max_parallel_trials_isValid;

    m_max_time_series_length_isValid = ::OpenAPI::fromJsonValue(m_max_time_series_length, json[QString("maxTimeSeriesLength")]);
    m_max_time_series_length_isSet = !json[QString("maxTimeSeriesLength")].isNull() && m_max_time_series_length_isValid;

    m_max_tree_depth_isValid = ::OpenAPI::fromJsonValue(m_max_tree_depth, json[QString("maxTreeDepth")]);
    m_max_tree_depth_isSet = !json[QString("maxTreeDepth")].isNull() && m_max_tree_depth_isValid;

    m_min_relative_progress_isValid = ::OpenAPI::fromJsonValue(m_min_relative_progress, json[QString("minRelativeProgress")]);
    m_min_relative_progress_isSet = !json[QString("minRelativeProgress")].isNull() && m_min_relative_progress_isValid;

    m_min_split_loss_isValid = ::OpenAPI::fromJsonValue(m_min_split_loss, json[QString("minSplitLoss")]);
    m_min_split_loss_isSet = !json[QString("minSplitLoss")].isNull() && m_min_split_loss_isValid;

    m_min_time_series_length_isValid = ::OpenAPI::fromJsonValue(m_min_time_series_length, json[QString("minTimeSeriesLength")]);
    m_min_time_series_length_isSet = !json[QString("minTimeSeriesLength")].isNull() && m_min_time_series_length_isValid;

    m_min_tree_child_weight_isValid = ::OpenAPI::fromJsonValue(m_min_tree_child_weight, json[QString("minTreeChildWeight")]);
    m_min_tree_child_weight_isSet = !json[QString("minTreeChildWeight")].isNull() && m_min_tree_child_weight_isValid;

    m_model_registry_isValid = ::OpenAPI::fromJsonValue(m_model_registry, json[QString("modelRegistry")]);
    m_model_registry_isSet = !json[QString("modelRegistry")].isNull() && m_model_registry_isValid;

    m_model_uri_isValid = ::OpenAPI::fromJsonValue(m_model_uri, json[QString("modelUri")]);
    m_model_uri_isSet = !json[QString("modelUri")].isNull() && m_model_uri_isValid;

    m_non_seasonal_order_isValid = ::OpenAPI::fromJsonValue(m_non_seasonal_order, json[QString("nonSeasonalOrder")]);
    m_non_seasonal_order_isSet = !json[QString("nonSeasonalOrder")].isNull() && m_non_seasonal_order_isValid;

    m_num_clusters_isValid = ::OpenAPI::fromJsonValue(m_num_clusters, json[QString("numClusters")]);
    m_num_clusters_isSet = !json[QString("numClusters")].isNull() && m_num_clusters_isValid;

    m_num_factors_isValid = ::OpenAPI::fromJsonValue(m_num_factors, json[QString("numFactors")]);
    m_num_factors_isSet = !json[QString("numFactors")].isNull() && m_num_factors_isValid;

    m_num_parallel_tree_isValid = ::OpenAPI::fromJsonValue(m_num_parallel_tree, json[QString("numParallelTree")]);
    m_num_parallel_tree_isSet = !json[QString("numParallelTree")].isNull() && m_num_parallel_tree_isValid;

    m_num_principal_components_isValid = ::OpenAPI::fromJsonValue(m_num_principal_components, json[QString("numPrincipalComponents")]);
    m_num_principal_components_isSet = !json[QString("numPrincipalComponents")].isNull() && m_num_principal_components_isValid;

    m_num_trials_isValid = ::OpenAPI::fromJsonValue(m_num_trials, json[QString("numTrials")]);
    m_num_trials_isSet = !json[QString("numTrials")].isNull() && m_num_trials_isValid;

    m_optimization_strategy_isValid = ::OpenAPI::fromJsonValue(m_optimization_strategy, json[QString("optimizationStrategy")]);
    m_optimization_strategy_isSet = !json[QString("optimizationStrategy")].isNull() && m_optimization_strategy_isValid;

    m_optimizer_isValid = ::OpenAPI::fromJsonValue(m_optimizer, json[QString("optimizer")]);
    m_optimizer_isSet = !json[QString("optimizer")].isNull() && m_optimizer_isValid;

    m_pca_explained_variance_ratio_isValid = ::OpenAPI::fromJsonValue(m_pca_explained_variance_ratio, json[QString("pcaExplainedVarianceRatio")]);
    m_pca_explained_variance_ratio_isSet = !json[QString("pcaExplainedVarianceRatio")].isNull() && m_pca_explained_variance_ratio_isValid;

    m_pca_solver_isValid = ::OpenAPI::fromJsonValue(m_pca_solver, json[QString("pcaSolver")]);
    m_pca_solver_isSet = !json[QString("pcaSolver")].isNull() && m_pca_solver_isValid;

    m_sampled_shapley_num_paths_isValid = ::OpenAPI::fromJsonValue(m_sampled_shapley_num_paths, json[QString("sampledShapleyNumPaths")]);
    m_sampled_shapley_num_paths_isSet = !json[QString("sampledShapleyNumPaths")].isNull() && m_sampled_shapley_num_paths_isValid;

    m_scale_features_isValid = ::OpenAPI::fromJsonValue(m_scale_features, json[QString("scaleFeatures")]);
    m_scale_features_isSet = !json[QString("scaleFeatures")].isNull() && m_scale_features_isValid;

    m_standardize_features_isValid = ::OpenAPI::fromJsonValue(m_standardize_features, json[QString("standardizeFeatures")]);
    m_standardize_features_isSet = !json[QString("standardizeFeatures")].isNull() && m_standardize_features_isValid;

    m_subsample_isValid = ::OpenAPI::fromJsonValue(m_subsample, json[QString("subsample")]);
    m_subsample_isSet = !json[QString("subsample")].isNull() && m_subsample_isValid;

    m_tf_version_isValid = ::OpenAPI::fromJsonValue(m_tf_version, json[QString("tfVersion")]);
    m_tf_version_isSet = !json[QString("tfVersion")].isNull() && m_tf_version_isValid;

    m_time_series_data_column_isValid = ::OpenAPI::fromJsonValue(m_time_series_data_column, json[QString("timeSeriesDataColumn")]);
    m_time_series_data_column_isSet = !json[QString("timeSeriesDataColumn")].isNull() && m_time_series_data_column_isValid;

    m_time_series_id_column_isValid = ::OpenAPI::fromJsonValue(m_time_series_id_column, json[QString("timeSeriesIdColumn")]);
    m_time_series_id_column_isSet = !json[QString("timeSeriesIdColumn")].isNull() && m_time_series_id_column_isValid;

    m_time_series_id_columns_isValid = ::OpenAPI::fromJsonValue(m_time_series_id_columns, json[QString("timeSeriesIdColumns")]);
    m_time_series_id_columns_isSet = !json[QString("timeSeriesIdColumns")].isNull() && m_time_series_id_columns_isValid;

    m_time_series_length_fraction_isValid = ::OpenAPI::fromJsonValue(m_time_series_length_fraction, json[QString("timeSeriesLengthFraction")]);
    m_time_series_length_fraction_isSet = !json[QString("timeSeriesLengthFraction")].isNull() && m_time_series_length_fraction_isValid;

    m_time_series_timestamp_column_isValid = ::OpenAPI::fromJsonValue(m_time_series_timestamp_column, json[QString("timeSeriesTimestampColumn")]);
    m_time_series_timestamp_column_isSet = !json[QString("timeSeriesTimestampColumn")].isNull() && m_time_series_timestamp_column_isValid;

    m_tree_method_isValid = ::OpenAPI::fromJsonValue(m_tree_method, json[QString("treeMethod")]);
    m_tree_method_isSet = !json[QString("treeMethod")].isNull() && m_tree_method_isValid;

    m_trend_smoothing_window_size_isValid = ::OpenAPI::fromJsonValue(m_trend_smoothing_window_size, json[QString("trendSmoothingWindowSize")]);
    m_trend_smoothing_window_size_isSet = !json[QString("trendSmoothingWindowSize")].isNull() && m_trend_smoothing_window_size_isValid;

    m_user_column_isValid = ::OpenAPI::fromJsonValue(m_user_column, json[QString("userColumn")]);
    m_user_column_isSet = !json[QString("userColumn")].isNull() && m_user_column_isValid;

    m_vertex_ai_model_version_aliases_isValid = ::OpenAPI::fromJsonValue(m_vertex_ai_model_version_aliases, json[QString("vertexAiModelVersionAliases")]);
    m_vertex_ai_model_version_aliases_isSet = !json[QString("vertexAiModelVersionAliases")].isNull() && m_vertex_ai_model_version_aliases_isValid;

    m_wals_alpha_isValid = ::OpenAPI::fromJsonValue(m_wals_alpha, json[QString("walsAlpha")]);
    m_wals_alpha_isSet = !json[QString("walsAlpha")].isNull() && m_wals_alpha_isValid;

    m_warm_start_isValid = ::OpenAPI::fromJsonValue(m_warm_start, json[QString("warmStart")]);
    m_warm_start_isSet = !json[QString("warmStart")].isNull() && m_warm_start_isValid;

    m_xgboost_version_isValid = ::OpenAPI::fromJsonValue(m_xgboost_version, json[QString("xgboostVersion")]);
    m_xgboost_version_isSet = !json[QString("xgboostVersion")].isNull() && m_xgboost_version_isValid;
}

QString OAITrainingOptions::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITrainingOptions::asJsonObject() const {
    QJsonObject obj;
    if (m_activation_fn_isSet) {
        obj.insert(QString("activationFn"), ::OpenAPI::toJsonValue(m_activation_fn));
    }
    if (m_adjust_step_changes_isSet) {
        obj.insert(QString("adjustStepChanges"), ::OpenAPI::toJsonValue(m_adjust_step_changes));
    }
    if (m_approx_global_feature_contrib_isSet) {
        obj.insert(QString("approxGlobalFeatureContrib"), ::OpenAPI::toJsonValue(m_approx_global_feature_contrib));
    }
    if (m_auto_arima_isSet) {
        obj.insert(QString("autoArima"), ::OpenAPI::toJsonValue(m_auto_arima));
    }
    if (m_auto_arima_max_order_isSet) {
        obj.insert(QString("autoArimaMaxOrder"), ::OpenAPI::toJsonValue(m_auto_arima_max_order));
    }
    if (m_auto_arima_min_order_isSet) {
        obj.insert(QString("autoArimaMinOrder"), ::OpenAPI::toJsonValue(m_auto_arima_min_order));
    }
    if (m_auto_class_weights_isSet) {
        obj.insert(QString("autoClassWeights"), ::OpenAPI::toJsonValue(m_auto_class_weights));
    }
    if (m_batch_size_isSet) {
        obj.insert(QString("batchSize"), ::OpenAPI::toJsonValue(m_batch_size));
    }
    if (m_booster_type_isSet) {
        obj.insert(QString("boosterType"), ::OpenAPI::toJsonValue(m_booster_type));
    }
    if (m_budget_hours_isSet) {
        obj.insert(QString("budgetHours"), ::OpenAPI::toJsonValue(m_budget_hours));
    }
    if (m_calculate_p_values_isSet) {
        obj.insert(QString("calculatePValues"), ::OpenAPI::toJsonValue(m_calculate_p_values));
    }
    if (m_category_encoding_method_isSet) {
        obj.insert(QString("categoryEncodingMethod"), ::OpenAPI::toJsonValue(m_category_encoding_method));
    }
    if (m_clean_spikes_and_dips_isSet) {
        obj.insert(QString("cleanSpikesAndDips"), ::OpenAPI::toJsonValue(m_clean_spikes_and_dips));
    }
    if (m_color_space_isSet) {
        obj.insert(QString("colorSpace"), ::OpenAPI::toJsonValue(m_color_space));
    }
    if (m_colsample_bylevel_isSet) {
        obj.insert(QString("colsampleBylevel"), ::OpenAPI::toJsonValue(m_colsample_bylevel));
    }
    if (m_colsample_bynode_isSet) {
        obj.insert(QString("colsampleBynode"), ::OpenAPI::toJsonValue(m_colsample_bynode));
    }
    if (m_colsample_bytree_isSet) {
        obj.insert(QString("colsampleBytree"), ::OpenAPI::toJsonValue(m_colsample_bytree));
    }
    if (m_dart_normalize_type_isSet) {
        obj.insert(QString("dartNormalizeType"), ::OpenAPI::toJsonValue(m_dart_normalize_type));
    }
    if (m_data_frequency_isSet) {
        obj.insert(QString("dataFrequency"), ::OpenAPI::toJsonValue(m_data_frequency));
    }
    if (m_data_split_column_isSet) {
        obj.insert(QString("dataSplitColumn"), ::OpenAPI::toJsonValue(m_data_split_column));
    }
    if (m_data_split_eval_fraction_isSet) {
        obj.insert(QString("dataSplitEvalFraction"), ::OpenAPI::toJsonValue(m_data_split_eval_fraction));
    }
    if (m_data_split_method_isSet) {
        obj.insert(QString("dataSplitMethod"), ::OpenAPI::toJsonValue(m_data_split_method));
    }
    if (m_decompose_time_series_isSet) {
        obj.insert(QString("decomposeTimeSeries"), ::OpenAPI::toJsonValue(m_decompose_time_series));
    }
    if (m_distance_type_isSet) {
        obj.insert(QString("distanceType"), ::OpenAPI::toJsonValue(m_distance_type));
    }
    if (m_dropout_isSet) {
        obj.insert(QString("dropout"), ::OpenAPI::toJsonValue(m_dropout));
    }
    if (m_early_stop_isSet) {
        obj.insert(QString("earlyStop"), ::OpenAPI::toJsonValue(m_early_stop));
    }
    if (m_enable_global_explain_isSet) {
        obj.insert(QString("enableGlobalExplain"), ::OpenAPI::toJsonValue(m_enable_global_explain));
    }
    if (m_feedback_type_isSet) {
        obj.insert(QString("feedbackType"), ::OpenAPI::toJsonValue(m_feedback_type));
    }
    if (m_fit_intercept_isSet) {
        obj.insert(QString("fitIntercept"), ::OpenAPI::toJsonValue(m_fit_intercept));
    }
    if (m_hidden_units.size() > 0) {
        obj.insert(QString("hiddenUnits"), ::OpenAPI::toJsonValue(m_hidden_units));
    }
    if (m_holiday_region_isSet) {
        obj.insert(QString("holidayRegion"), ::OpenAPI::toJsonValue(m_holiday_region));
    }
    if (m_holiday_regions.size() > 0) {
        obj.insert(QString("holidayRegions"), ::OpenAPI::toJsonValue(m_holiday_regions));
    }
    if (m_horizon_isSet) {
        obj.insert(QString("horizon"), ::OpenAPI::toJsonValue(m_horizon));
    }
    if (m_hparam_tuning_objectives.size() > 0) {
        obj.insert(QString("hparamTuningObjectives"), ::OpenAPI::toJsonValue(m_hparam_tuning_objectives));
    }
    if (m_include_drift_isSet) {
        obj.insert(QString("includeDrift"), ::OpenAPI::toJsonValue(m_include_drift));
    }
    if (m_initial_learn_rate_isSet) {
        obj.insert(QString("initialLearnRate"), ::OpenAPI::toJsonValue(m_initial_learn_rate));
    }
    if (m_input_label_columns.size() > 0) {
        obj.insert(QString("inputLabelColumns"), ::OpenAPI::toJsonValue(m_input_label_columns));
    }
    if (m_instance_weight_column_isSet) {
        obj.insert(QString("instanceWeightColumn"), ::OpenAPI::toJsonValue(m_instance_weight_column));
    }
    if (m_integrated_gradients_num_steps_isSet) {
        obj.insert(QString("integratedGradientsNumSteps"), ::OpenAPI::toJsonValue(m_integrated_gradients_num_steps));
    }
    if (m_item_column_isSet) {
        obj.insert(QString("itemColumn"), ::OpenAPI::toJsonValue(m_item_column));
    }
    if (m_kmeans_initialization_column_isSet) {
        obj.insert(QString("kmeansInitializationColumn"), ::OpenAPI::toJsonValue(m_kmeans_initialization_column));
    }
    if (m_kmeans_initialization_method_isSet) {
        obj.insert(QString("kmeansInitializationMethod"), ::OpenAPI::toJsonValue(m_kmeans_initialization_method));
    }
    if (m_l1_reg_activation_isSet) {
        obj.insert(QString("l1RegActivation"), ::OpenAPI::toJsonValue(m_l1_reg_activation));
    }
    if (m_l1_regularization_isSet) {
        obj.insert(QString("l1Regularization"), ::OpenAPI::toJsonValue(m_l1_regularization));
    }
    if (m_l2_regularization_isSet) {
        obj.insert(QString("l2Regularization"), ::OpenAPI::toJsonValue(m_l2_regularization));
    }
    if (m_label_class_weights.size() > 0) {
        obj.insert(QString("labelClassWeights"), ::OpenAPI::toJsonValue(m_label_class_weights));
    }
    if (m_learn_rate_isSet) {
        obj.insert(QString("learnRate"), ::OpenAPI::toJsonValue(m_learn_rate));
    }
    if (m_learn_rate_strategy_isSet) {
        obj.insert(QString("learnRateStrategy"), ::OpenAPI::toJsonValue(m_learn_rate_strategy));
    }
    if (m_loss_type_isSet) {
        obj.insert(QString("lossType"), ::OpenAPI::toJsonValue(m_loss_type));
    }
    if (m_max_iterations_isSet) {
        obj.insert(QString("maxIterations"), ::OpenAPI::toJsonValue(m_max_iterations));
    }
    if (m_max_parallel_trials_isSet) {
        obj.insert(QString("maxParallelTrials"), ::OpenAPI::toJsonValue(m_max_parallel_trials));
    }
    if (m_max_time_series_length_isSet) {
        obj.insert(QString("maxTimeSeriesLength"), ::OpenAPI::toJsonValue(m_max_time_series_length));
    }
    if (m_max_tree_depth_isSet) {
        obj.insert(QString("maxTreeDepth"), ::OpenAPI::toJsonValue(m_max_tree_depth));
    }
    if (m_min_relative_progress_isSet) {
        obj.insert(QString("minRelativeProgress"), ::OpenAPI::toJsonValue(m_min_relative_progress));
    }
    if (m_min_split_loss_isSet) {
        obj.insert(QString("minSplitLoss"), ::OpenAPI::toJsonValue(m_min_split_loss));
    }
    if (m_min_time_series_length_isSet) {
        obj.insert(QString("minTimeSeriesLength"), ::OpenAPI::toJsonValue(m_min_time_series_length));
    }
    if (m_min_tree_child_weight_isSet) {
        obj.insert(QString("minTreeChildWeight"), ::OpenAPI::toJsonValue(m_min_tree_child_weight));
    }
    if (m_model_registry_isSet) {
        obj.insert(QString("modelRegistry"), ::OpenAPI::toJsonValue(m_model_registry));
    }
    if (m_model_uri_isSet) {
        obj.insert(QString("modelUri"), ::OpenAPI::toJsonValue(m_model_uri));
    }
    if (m_non_seasonal_order.isSet()) {
        obj.insert(QString("nonSeasonalOrder"), ::OpenAPI::toJsonValue(m_non_seasonal_order));
    }
    if (m_num_clusters_isSet) {
        obj.insert(QString("numClusters"), ::OpenAPI::toJsonValue(m_num_clusters));
    }
    if (m_num_factors_isSet) {
        obj.insert(QString("numFactors"), ::OpenAPI::toJsonValue(m_num_factors));
    }
    if (m_num_parallel_tree_isSet) {
        obj.insert(QString("numParallelTree"), ::OpenAPI::toJsonValue(m_num_parallel_tree));
    }
    if (m_num_principal_components_isSet) {
        obj.insert(QString("numPrincipalComponents"), ::OpenAPI::toJsonValue(m_num_principal_components));
    }
    if (m_num_trials_isSet) {
        obj.insert(QString("numTrials"), ::OpenAPI::toJsonValue(m_num_trials));
    }
    if (m_optimization_strategy_isSet) {
        obj.insert(QString("optimizationStrategy"), ::OpenAPI::toJsonValue(m_optimization_strategy));
    }
    if (m_optimizer_isSet) {
        obj.insert(QString("optimizer"), ::OpenAPI::toJsonValue(m_optimizer));
    }
    if (m_pca_explained_variance_ratio_isSet) {
        obj.insert(QString("pcaExplainedVarianceRatio"), ::OpenAPI::toJsonValue(m_pca_explained_variance_ratio));
    }
    if (m_pca_solver_isSet) {
        obj.insert(QString("pcaSolver"), ::OpenAPI::toJsonValue(m_pca_solver));
    }
    if (m_sampled_shapley_num_paths_isSet) {
        obj.insert(QString("sampledShapleyNumPaths"), ::OpenAPI::toJsonValue(m_sampled_shapley_num_paths));
    }
    if (m_scale_features_isSet) {
        obj.insert(QString("scaleFeatures"), ::OpenAPI::toJsonValue(m_scale_features));
    }
    if (m_standardize_features_isSet) {
        obj.insert(QString("standardizeFeatures"), ::OpenAPI::toJsonValue(m_standardize_features));
    }
    if (m_subsample_isSet) {
        obj.insert(QString("subsample"), ::OpenAPI::toJsonValue(m_subsample));
    }
    if (m_tf_version_isSet) {
        obj.insert(QString("tfVersion"), ::OpenAPI::toJsonValue(m_tf_version));
    }
    if (m_time_series_data_column_isSet) {
        obj.insert(QString("timeSeriesDataColumn"), ::OpenAPI::toJsonValue(m_time_series_data_column));
    }
    if (m_time_series_id_column_isSet) {
        obj.insert(QString("timeSeriesIdColumn"), ::OpenAPI::toJsonValue(m_time_series_id_column));
    }
    if (m_time_series_id_columns.size() > 0) {
        obj.insert(QString("timeSeriesIdColumns"), ::OpenAPI::toJsonValue(m_time_series_id_columns));
    }
    if (m_time_series_length_fraction_isSet) {
        obj.insert(QString("timeSeriesLengthFraction"), ::OpenAPI::toJsonValue(m_time_series_length_fraction));
    }
    if (m_time_series_timestamp_column_isSet) {
        obj.insert(QString("timeSeriesTimestampColumn"), ::OpenAPI::toJsonValue(m_time_series_timestamp_column));
    }
    if (m_tree_method_isSet) {
        obj.insert(QString("treeMethod"), ::OpenAPI::toJsonValue(m_tree_method));
    }
    if (m_trend_smoothing_window_size_isSet) {
        obj.insert(QString("trendSmoothingWindowSize"), ::OpenAPI::toJsonValue(m_trend_smoothing_window_size));
    }
    if (m_user_column_isSet) {
        obj.insert(QString("userColumn"), ::OpenAPI::toJsonValue(m_user_column));
    }
    if (m_vertex_ai_model_version_aliases.size() > 0) {
        obj.insert(QString("vertexAiModelVersionAliases"), ::OpenAPI::toJsonValue(m_vertex_ai_model_version_aliases));
    }
    if (m_wals_alpha_isSet) {
        obj.insert(QString("walsAlpha"), ::OpenAPI::toJsonValue(m_wals_alpha));
    }
    if (m_warm_start_isSet) {
        obj.insert(QString("warmStart"), ::OpenAPI::toJsonValue(m_warm_start));
    }
    if (m_xgboost_version_isSet) {
        obj.insert(QString("xgboostVersion"), ::OpenAPI::toJsonValue(m_xgboost_version));
    }
    return obj;
}

QString OAITrainingOptions::getActivationFn() const {
    return m_activation_fn;
}
void OAITrainingOptions::setActivationFn(const QString &activation_fn) {
    m_activation_fn = activation_fn;
    m_activation_fn_isSet = true;
}

bool OAITrainingOptions::is_activation_fn_Set() const{
    return m_activation_fn_isSet;
}

bool OAITrainingOptions::is_activation_fn_Valid() const{
    return m_activation_fn_isValid;
}

bool OAITrainingOptions::isAdjustStepChanges() const {
    return m_adjust_step_changes;
}
void OAITrainingOptions::setAdjustStepChanges(const bool &adjust_step_changes) {
    m_adjust_step_changes = adjust_step_changes;
    m_adjust_step_changes_isSet = true;
}

bool OAITrainingOptions::is_adjust_step_changes_Set() const{
    return m_adjust_step_changes_isSet;
}

bool OAITrainingOptions::is_adjust_step_changes_Valid() const{
    return m_adjust_step_changes_isValid;
}

bool OAITrainingOptions::isApproxGlobalFeatureContrib() const {
    return m_approx_global_feature_contrib;
}
void OAITrainingOptions::setApproxGlobalFeatureContrib(const bool &approx_global_feature_contrib) {
    m_approx_global_feature_contrib = approx_global_feature_contrib;
    m_approx_global_feature_contrib_isSet = true;
}

bool OAITrainingOptions::is_approx_global_feature_contrib_Set() const{
    return m_approx_global_feature_contrib_isSet;
}

bool OAITrainingOptions::is_approx_global_feature_contrib_Valid() const{
    return m_approx_global_feature_contrib_isValid;
}

bool OAITrainingOptions::isAutoArima() const {
    return m_auto_arima;
}
void OAITrainingOptions::setAutoArima(const bool &auto_arima) {
    m_auto_arima = auto_arima;
    m_auto_arima_isSet = true;
}

bool OAITrainingOptions::is_auto_arima_Set() const{
    return m_auto_arima_isSet;
}

bool OAITrainingOptions::is_auto_arima_Valid() const{
    return m_auto_arima_isValid;
}

QString OAITrainingOptions::getAutoArimaMaxOrder() const {
    return m_auto_arima_max_order;
}
void OAITrainingOptions::setAutoArimaMaxOrder(const QString &auto_arima_max_order) {
    m_auto_arima_max_order = auto_arima_max_order;
    m_auto_arima_max_order_isSet = true;
}

bool OAITrainingOptions::is_auto_arima_max_order_Set() const{
    return m_auto_arima_max_order_isSet;
}

bool OAITrainingOptions::is_auto_arima_max_order_Valid() const{
    return m_auto_arima_max_order_isValid;
}

QString OAITrainingOptions::getAutoArimaMinOrder() const {
    return m_auto_arima_min_order;
}
void OAITrainingOptions::setAutoArimaMinOrder(const QString &auto_arima_min_order) {
    m_auto_arima_min_order = auto_arima_min_order;
    m_auto_arima_min_order_isSet = true;
}

bool OAITrainingOptions::is_auto_arima_min_order_Set() const{
    return m_auto_arima_min_order_isSet;
}

bool OAITrainingOptions::is_auto_arima_min_order_Valid() const{
    return m_auto_arima_min_order_isValid;
}

bool OAITrainingOptions::isAutoClassWeights() const {
    return m_auto_class_weights;
}
void OAITrainingOptions::setAutoClassWeights(const bool &auto_class_weights) {
    m_auto_class_weights = auto_class_weights;
    m_auto_class_weights_isSet = true;
}

bool OAITrainingOptions::is_auto_class_weights_Set() const{
    return m_auto_class_weights_isSet;
}

bool OAITrainingOptions::is_auto_class_weights_Valid() const{
    return m_auto_class_weights_isValid;
}

QString OAITrainingOptions::getBatchSize() const {
    return m_batch_size;
}
void OAITrainingOptions::setBatchSize(const QString &batch_size) {
    m_batch_size = batch_size;
    m_batch_size_isSet = true;
}

bool OAITrainingOptions::is_batch_size_Set() const{
    return m_batch_size_isSet;
}

bool OAITrainingOptions::is_batch_size_Valid() const{
    return m_batch_size_isValid;
}

QString OAITrainingOptions::getBoosterType() const {
    return m_booster_type;
}
void OAITrainingOptions::setBoosterType(const QString &booster_type) {
    m_booster_type = booster_type;
    m_booster_type_isSet = true;
}

bool OAITrainingOptions::is_booster_type_Set() const{
    return m_booster_type_isSet;
}

bool OAITrainingOptions::is_booster_type_Valid() const{
    return m_booster_type_isValid;
}

double OAITrainingOptions::getBudgetHours() const {
    return m_budget_hours;
}
void OAITrainingOptions::setBudgetHours(const double &budget_hours) {
    m_budget_hours = budget_hours;
    m_budget_hours_isSet = true;
}

bool OAITrainingOptions::is_budget_hours_Set() const{
    return m_budget_hours_isSet;
}

bool OAITrainingOptions::is_budget_hours_Valid() const{
    return m_budget_hours_isValid;
}

bool OAITrainingOptions::isCalculatePValues() const {
    return m_calculate_p_values;
}
void OAITrainingOptions::setCalculatePValues(const bool &calculate_p_values) {
    m_calculate_p_values = calculate_p_values;
    m_calculate_p_values_isSet = true;
}

bool OAITrainingOptions::is_calculate_p_values_Set() const{
    return m_calculate_p_values_isSet;
}

bool OAITrainingOptions::is_calculate_p_values_Valid() const{
    return m_calculate_p_values_isValid;
}

QString OAITrainingOptions::getCategoryEncodingMethod() const {
    return m_category_encoding_method;
}
void OAITrainingOptions::setCategoryEncodingMethod(const QString &category_encoding_method) {
    m_category_encoding_method = category_encoding_method;
    m_category_encoding_method_isSet = true;
}

bool OAITrainingOptions::is_category_encoding_method_Set() const{
    return m_category_encoding_method_isSet;
}

bool OAITrainingOptions::is_category_encoding_method_Valid() const{
    return m_category_encoding_method_isValid;
}

bool OAITrainingOptions::isCleanSpikesAndDips() const {
    return m_clean_spikes_and_dips;
}
void OAITrainingOptions::setCleanSpikesAndDips(const bool &clean_spikes_and_dips) {
    m_clean_spikes_and_dips = clean_spikes_and_dips;
    m_clean_spikes_and_dips_isSet = true;
}

bool OAITrainingOptions::is_clean_spikes_and_dips_Set() const{
    return m_clean_spikes_and_dips_isSet;
}

bool OAITrainingOptions::is_clean_spikes_and_dips_Valid() const{
    return m_clean_spikes_and_dips_isValid;
}

QString OAITrainingOptions::getColorSpace() const {
    return m_color_space;
}
void OAITrainingOptions::setColorSpace(const QString &color_space) {
    m_color_space = color_space;
    m_color_space_isSet = true;
}

bool OAITrainingOptions::is_color_space_Set() const{
    return m_color_space_isSet;
}

bool OAITrainingOptions::is_color_space_Valid() const{
    return m_color_space_isValid;
}

double OAITrainingOptions::getColsampleBylevel() const {
    return m_colsample_bylevel;
}
void OAITrainingOptions::setColsampleBylevel(const double &colsample_bylevel) {
    m_colsample_bylevel = colsample_bylevel;
    m_colsample_bylevel_isSet = true;
}

bool OAITrainingOptions::is_colsample_bylevel_Set() const{
    return m_colsample_bylevel_isSet;
}

bool OAITrainingOptions::is_colsample_bylevel_Valid() const{
    return m_colsample_bylevel_isValid;
}

double OAITrainingOptions::getColsampleBynode() const {
    return m_colsample_bynode;
}
void OAITrainingOptions::setColsampleBynode(const double &colsample_bynode) {
    m_colsample_bynode = colsample_bynode;
    m_colsample_bynode_isSet = true;
}

bool OAITrainingOptions::is_colsample_bynode_Set() const{
    return m_colsample_bynode_isSet;
}

bool OAITrainingOptions::is_colsample_bynode_Valid() const{
    return m_colsample_bynode_isValid;
}

double OAITrainingOptions::getColsampleBytree() const {
    return m_colsample_bytree;
}
void OAITrainingOptions::setColsampleBytree(const double &colsample_bytree) {
    m_colsample_bytree = colsample_bytree;
    m_colsample_bytree_isSet = true;
}

bool OAITrainingOptions::is_colsample_bytree_Set() const{
    return m_colsample_bytree_isSet;
}

bool OAITrainingOptions::is_colsample_bytree_Valid() const{
    return m_colsample_bytree_isValid;
}

QString OAITrainingOptions::getDartNormalizeType() const {
    return m_dart_normalize_type;
}
void OAITrainingOptions::setDartNormalizeType(const QString &dart_normalize_type) {
    m_dart_normalize_type = dart_normalize_type;
    m_dart_normalize_type_isSet = true;
}

bool OAITrainingOptions::is_dart_normalize_type_Set() const{
    return m_dart_normalize_type_isSet;
}

bool OAITrainingOptions::is_dart_normalize_type_Valid() const{
    return m_dart_normalize_type_isValid;
}

QString OAITrainingOptions::getDataFrequency() const {
    return m_data_frequency;
}
void OAITrainingOptions::setDataFrequency(const QString &data_frequency) {
    m_data_frequency = data_frequency;
    m_data_frequency_isSet = true;
}

bool OAITrainingOptions::is_data_frequency_Set() const{
    return m_data_frequency_isSet;
}

bool OAITrainingOptions::is_data_frequency_Valid() const{
    return m_data_frequency_isValid;
}

QString OAITrainingOptions::getDataSplitColumn() const {
    return m_data_split_column;
}
void OAITrainingOptions::setDataSplitColumn(const QString &data_split_column) {
    m_data_split_column = data_split_column;
    m_data_split_column_isSet = true;
}

bool OAITrainingOptions::is_data_split_column_Set() const{
    return m_data_split_column_isSet;
}

bool OAITrainingOptions::is_data_split_column_Valid() const{
    return m_data_split_column_isValid;
}

double OAITrainingOptions::getDataSplitEvalFraction() const {
    return m_data_split_eval_fraction;
}
void OAITrainingOptions::setDataSplitEvalFraction(const double &data_split_eval_fraction) {
    m_data_split_eval_fraction = data_split_eval_fraction;
    m_data_split_eval_fraction_isSet = true;
}

bool OAITrainingOptions::is_data_split_eval_fraction_Set() const{
    return m_data_split_eval_fraction_isSet;
}

bool OAITrainingOptions::is_data_split_eval_fraction_Valid() const{
    return m_data_split_eval_fraction_isValid;
}

QString OAITrainingOptions::getDataSplitMethod() const {
    return m_data_split_method;
}
void OAITrainingOptions::setDataSplitMethod(const QString &data_split_method) {
    m_data_split_method = data_split_method;
    m_data_split_method_isSet = true;
}

bool OAITrainingOptions::is_data_split_method_Set() const{
    return m_data_split_method_isSet;
}

bool OAITrainingOptions::is_data_split_method_Valid() const{
    return m_data_split_method_isValid;
}

bool OAITrainingOptions::isDecomposeTimeSeries() const {
    return m_decompose_time_series;
}
void OAITrainingOptions::setDecomposeTimeSeries(const bool &decompose_time_series) {
    m_decompose_time_series = decompose_time_series;
    m_decompose_time_series_isSet = true;
}

bool OAITrainingOptions::is_decompose_time_series_Set() const{
    return m_decompose_time_series_isSet;
}

bool OAITrainingOptions::is_decompose_time_series_Valid() const{
    return m_decompose_time_series_isValid;
}

QString OAITrainingOptions::getDistanceType() const {
    return m_distance_type;
}
void OAITrainingOptions::setDistanceType(const QString &distance_type) {
    m_distance_type = distance_type;
    m_distance_type_isSet = true;
}

bool OAITrainingOptions::is_distance_type_Set() const{
    return m_distance_type_isSet;
}

bool OAITrainingOptions::is_distance_type_Valid() const{
    return m_distance_type_isValid;
}

double OAITrainingOptions::getDropout() const {
    return m_dropout;
}
void OAITrainingOptions::setDropout(const double &dropout) {
    m_dropout = dropout;
    m_dropout_isSet = true;
}

bool OAITrainingOptions::is_dropout_Set() const{
    return m_dropout_isSet;
}

bool OAITrainingOptions::is_dropout_Valid() const{
    return m_dropout_isValid;
}

bool OAITrainingOptions::isEarlyStop() const {
    return m_early_stop;
}
void OAITrainingOptions::setEarlyStop(const bool &early_stop) {
    m_early_stop = early_stop;
    m_early_stop_isSet = true;
}

bool OAITrainingOptions::is_early_stop_Set() const{
    return m_early_stop_isSet;
}

bool OAITrainingOptions::is_early_stop_Valid() const{
    return m_early_stop_isValid;
}

bool OAITrainingOptions::isEnableGlobalExplain() const {
    return m_enable_global_explain;
}
void OAITrainingOptions::setEnableGlobalExplain(const bool &enable_global_explain) {
    m_enable_global_explain = enable_global_explain;
    m_enable_global_explain_isSet = true;
}

bool OAITrainingOptions::is_enable_global_explain_Set() const{
    return m_enable_global_explain_isSet;
}

bool OAITrainingOptions::is_enable_global_explain_Valid() const{
    return m_enable_global_explain_isValid;
}

QString OAITrainingOptions::getFeedbackType() const {
    return m_feedback_type;
}
void OAITrainingOptions::setFeedbackType(const QString &feedback_type) {
    m_feedback_type = feedback_type;
    m_feedback_type_isSet = true;
}

bool OAITrainingOptions::is_feedback_type_Set() const{
    return m_feedback_type_isSet;
}

bool OAITrainingOptions::is_feedback_type_Valid() const{
    return m_feedback_type_isValid;
}

bool OAITrainingOptions::isFitIntercept() const {
    return m_fit_intercept;
}
void OAITrainingOptions::setFitIntercept(const bool &fit_intercept) {
    m_fit_intercept = fit_intercept;
    m_fit_intercept_isSet = true;
}

bool OAITrainingOptions::is_fit_intercept_Set() const{
    return m_fit_intercept_isSet;
}

bool OAITrainingOptions::is_fit_intercept_Valid() const{
    return m_fit_intercept_isValid;
}

QList<QString> OAITrainingOptions::getHiddenUnits() const {
    return m_hidden_units;
}
void OAITrainingOptions::setHiddenUnits(const QList<QString> &hidden_units) {
    m_hidden_units = hidden_units;
    m_hidden_units_isSet = true;
}

bool OAITrainingOptions::is_hidden_units_Set() const{
    return m_hidden_units_isSet;
}

bool OAITrainingOptions::is_hidden_units_Valid() const{
    return m_hidden_units_isValid;
}

QString OAITrainingOptions::getHolidayRegion() const {
    return m_holiday_region;
}
void OAITrainingOptions::setHolidayRegion(const QString &holiday_region) {
    m_holiday_region = holiday_region;
    m_holiday_region_isSet = true;
}

bool OAITrainingOptions::is_holiday_region_Set() const{
    return m_holiday_region_isSet;
}

bool OAITrainingOptions::is_holiday_region_Valid() const{
    return m_holiday_region_isValid;
}

QList<QString> OAITrainingOptions::getHolidayRegions() const {
    return m_holiday_regions;
}
void OAITrainingOptions::setHolidayRegions(const QList<QString> &holiday_regions) {
    m_holiday_regions = holiday_regions;
    m_holiday_regions_isSet = true;
}

bool OAITrainingOptions::is_holiday_regions_Set() const{
    return m_holiday_regions_isSet;
}

bool OAITrainingOptions::is_holiday_regions_Valid() const{
    return m_holiday_regions_isValid;
}

QString OAITrainingOptions::getHorizon() const {
    return m_horizon;
}
void OAITrainingOptions::setHorizon(const QString &horizon) {
    m_horizon = horizon;
    m_horizon_isSet = true;
}

bool OAITrainingOptions::is_horizon_Set() const{
    return m_horizon_isSet;
}

bool OAITrainingOptions::is_horizon_Valid() const{
    return m_horizon_isValid;
}

QList<QString> OAITrainingOptions::getHparamTuningObjectives() const {
    return m_hparam_tuning_objectives;
}
void OAITrainingOptions::setHparamTuningObjectives(const QList<QString> &hparam_tuning_objectives) {
    m_hparam_tuning_objectives = hparam_tuning_objectives;
    m_hparam_tuning_objectives_isSet = true;
}

bool OAITrainingOptions::is_hparam_tuning_objectives_Set() const{
    return m_hparam_tuning_objectives_isSet;
}

bool OAITrainingOptions::is_hparam_tuning_objectives_Valid() const{
    return m_hparam_tuning_objectives_isValid;
}

bool OAITrainingOptions::isIncludeDrift() const {
    return m_include_drift;
}
void OAITrainingOptions::setIncludeDrift(const bool &include_drift) {
    m_include_drift = include_drift;
    m_include_drift_isSet = true;
}

bool OAITrainingOptions::is_include_drift_Set() const{
    return m_include_drift_isSet;
}

bool OAITrainingOptions::is_include_drift_Valid() const{
    return m_include_drift_isValid;
}

double OAITrainingOptions::getInitialLearnRate() const {
    return m_initial_learn_rate;
}
void OAITrainingOptions::setInitialLearnRate(const double &initial_learn_rate) {
    m_initial_learn_rate = initial_learn_rate;
    m_initial_learn_rate_isSet = true;
}

bool OAITrainingOptions::is_initial_learn_rate_Set() const{
    return m_initial_learn_rate_isSet;
}

bool OAITrainingOptions::is_initial_learn_rate_Valid() const{
    return m_initial_learn_rate_isValid;
}

QList<QString> OAITrainingOptions::getInputLabelColumns() const {
    return m_input_label_columns;
}
void OAITrainingOptions::setInputLabelColumns(const QList<QString> &input_label_columns) {
    m_input_label_columns = input_label_columns;
    m_input_label_columns_isSet = true;
}

bool OAITrainingOptions::is_input_label_columns_Set() const{
    return m_input_label_columns_isSet;
}

bool OAITrainingOptions::is_input_label_columns_Valid() const{
    return m_input_label_columns_isValid;
}

QString OAITrainingOptions::getInstanceWeightColumn() const {
    return m_instance_weight_column;
}
void OAITrainingOptions::setInstanceWeightColumn(const QString &instance_weight_column) {
    m_instance_weight_column = instance_weight_column;
    m_instance_weight_column_isSet = true;
}

bool OAITrainingOptions::is_instance_weight_column_Set() const{
    return m_instance_weight_column_isSet;
}

bool OAITrainingOptions::is_instance_weight_column_Valid() const{
    return m_instance_weight_column_isValid;
}

QString OAITrainingOptions::getIntegratedGradientsNumSteps() const {
    return m_integrated_gradients_num_steps;
}
void OAITrainingOptions::setIntegratedGradientsNumSteps(const QString &integrated_gradients_num_steps) {
    m_integrated_gradients_num_steps = integrated_gradients_num_steps;
    m_integrated_gradients_num_steps_isSet = true;
}

bool OAITrainingOptions::is_integrated_gradients_num_steps_Set() const{
    return m_integrated_gradients_num_steps_isSet;
}

bool OAITrainingOptions::is_integrated_gradients_num_steps_Valid() const{
    return m_integrated_gradients_num_steps_isValid;
}

QString OAITrainingOptions::getItemColumn() const {
    return m_item_column;
}
void OAITrainingOptions::setItemColumn(const QString &item_column) {
    m_item_column = item_column;
    m_item_column_isSet = true;
}

bool OAITrainingOptions::is_item_column_Set() const{
    return m_item_column_isSet;
}

bool OAITrainingOptions::is_item_column_Valid() const{
    return m_item_column_isValid;
}

QString OAITrainingOptions::getKmeansInitializationColumn() const {
    return m_kmeans_initialization_column;
}
void OAITrainingOptions::setKmeansInitializationColumn(const QString &kmeans_initialization_column) {
    m_kmeans_initialization_column = kmeans_initialization_column;
    m_kmeans_initialization_column_isSet = true;
}

bool OAITrainingOptions::is_kmeans_initialization_column_Set() const{
    return m_kmeans_initialization_column_isSet;
}

bool OAITrainingOptions::is_kmeans_initialization_column_Valid() const{
    return m_kmeans_initialization_column_isValid;
}

QString OAITrainingOptions::getKmeansInitializationMethod() const {
    return m_kmeans_initialization_method;
}
void OAITrainingOptions::setKmeansInitializationMethod(const QString &kmeans_initialization_method) {
    m_kmeans_initialization_method = kmeans_initialization_method;
    m_kmeans_initialization_method_isSet = true;
}

bool OAITrainingOptions::is_kmeans_initialization_method_Set() const{
    return m_kmeans_initialization_method_isSet;
}

bool OAITrainingOptions::is_kmeans_initialization_method_Valid() const{
    return m_kmeans_initialization_method_isValid;
}

double OAITrainingOptions::getL1RegActivation() const {
    return m_l1_reg_activation;
}
void OAITrainingOptions::setL1RegActivation(const double &l1_reg_activation) {
    m_l1_reg_activation = l1_reg_activation;
    m_l1_reg_activation_isSet = true;
}

bool OAITrainingOptions::is_l1_reg_activation_Set() const{
    return m_l1_reg_activation_isSet;
}

bool OAITrainingOptions::is_l1_reg_activation_Valid() const{
    return m_l1_reg_activation_isValid;
}

double OAITrainingOptions::getL1Regularization() const {
    return m_l1_regularization;
}
void OAITrainingOptions::setL1Regularization(const double &l1_regularization) {
    m_l1_regularization = l1_regularization;
    m_l1_regularization_isSet = true;
}

bool OAITrainingOptions::is_l1_regularization_Set() const{
    return m_l1_regularization_isSet;
}

bool OAITrainingOptions::is_l1_regularization_Valid() const{
    return m_l1_regularization_isValid;
}

double OAITrainingOptions::getL2Regularization() const {
    return m_l2_regularization;
}
void OAITrainingOptions::setL2Regularization(const double &l2_regularization) {
    m_l2_regularization = l2_regularization;
    m_l2_regularization_isSet = true;
}

bool OAITrainingOptions::is_l2_regularization_Set() const{
    return m_l2_regularization_isSet;
}

bool OAITrainingOptions::is_l2_regularization_Valid() const{
    return m_l2_regularization_isValid;
}

QMap<QString, double> OAITrainingOptions::getLabelClassWeights() const {
    return m_label_class_weights;
}
void OAITrainingOptions::setLabelClassWeights(const QMap<QString, double> &label_class_weights) {
    m_label_class_weights = label_class_weights;
    m_label_class_weights_isSet = true;
}

bool OAITrainingOptions::is_label_class_weights_Set() const{
    return m_label_class_weights_isSet;
}

bool OAITrainingOptions::is_label_class_weights_Valid() const{
    return m_label_class_weights_isValid;
}

double OAITrainingOptions::getLearnRate() const {
    return m_learn_rate;
}
void OAITrainingOptions::setLearnRate(const double &learn_rate) {
    m_learn_rate = learn_rate;
    m_learn_rate_isSet = true;
}

bool OAITrainingOptions::is_learn_rate_Set() const{
    return m_learn_rate_isSet;
}

bool OAITrainingOptions::is_learn_rate_Valid() const{
    return m_learn_rate_isValid;
}

QString OAITrainingOptions::getLearnRateStrategy() const {
    return m_learn_rate_strategy;
}
void OAITrainingOptions::setLearnRateStrategy(const QString &learn_rate_strategy) {
    m_learn_rate_strategy = learn_rate_strategy;
    m_learn_rate_strategy_isSet = true;
}

bool OAITrainingOptions::is_learn_rate_strategy_Set() const{
    return m_learn_rate_strategy_isSet;
}

bool OAITrainingOptions::is_learn_rate_strategy_Valid() const{
    return m_learn_rate_strategy_isValid;
}

QString OAITrainingOptions::getLossType() const {
    return m_loss_type;
}
void OAITrainingOptions::setLossType(const QString &loss_type) {
    m_loss_type = loss_type;
    m_loss_type_isSet = true;
}

bool OAITrainingOptions::is_loss_type_Set() const{
    return m_loss_type_isSet;
}

bool OAITrainingOptions::is_loss_type_Valid() const{
    return m_loss_type_isValid;
}

QString OAITrainingOptions::getMaxIterations() const {
    return m_max_iterations;
}
void OAITrainingOptions::setMaxIterations(const QString &max_iterations) {
    m_max_iterations = max_iterations;
    m_max_iterations_isSet = true;
}

bool OAITrainingOptions::is_max_iterations_Set() const{
    return m_max_iterations_isSet;
}

bool OAITrainingOptions::is_max_iterations_Valid() const{
    return m_max_iterations_isValid;
}

QString OAITrainingOptions::getMaxParallelTrials() const {
    return m_max_parallel_trials;
}
void OAITrainingOptions::setMaxParallelTrials(const QString &max_parallel_trials) {
    m_max_parallel_trials = max_parallel_trials;
    m_max_parallel_trials_isSet = true;
}

bool OAITrainingOptions::is_max_parallel_trials_Set() const{
    return m_max_parallel_trials_isSet;
}

bool OAITrainingOptions::is_max_parallel_trials_Valid() const{
    return m_max_parallel_trials_isValid;
}

QString OAITrainingOptions::getMaxTimeSeriesLength() const {
    return m_max_time_series_length;
}
void OAITrainingOptions::setMaxTimeSeriesLength(const QString &max_time_series_length) {
    m_max_time_series_length = max_time_series_length;
    m_max_time_series_length_isSet = true;
}

bool OAITrainingOptions::is_max_time_series_length_Set() const{
    return m_max_time_series_length_isSet;
}

bool OAITrainingOptions::is_max_time_series_length_Valid() const{
    return m_max_time_series_length_isValid;
}

QString OAITrainingOptions::getMaxTreeDepth() const {
    return m_max_tree_depth;
}
void OAITrainingOptions::setMaxTreeDepth(const QString &max_tree_depth) {
    m_max_tree_depth = max_tree_depth;
    m_max_tree_depth_isSet = true;
}

bool OAITrainingOptions::is_max_tree_depth_Set() const{
    return m_max_tree_depth_isSet;
}

bool OAITrainingOptions::is_max_tree_depth_Valid() const{
    return m_max_tree_depth_isValid;
}

double OAITrainingOptions::getMinRelativeProgress() const {
    return m_min_relative_progress;
}
void OAITrainingOptions::setMinRelativeProgress(const double &min_relative_progress) {
    m_min_relative_progress = min_relative_progress;
    m_min_relative_progress_isSet = true;
}

bool OAITrainingOptions::is_min_relative_progress_Set() const{
    return m_min_relative_progress_isSet;
}

bool OAITrainingOptions::is_min_relative_progress_Valid() const{
    return m_min_relative_progress_isValid;
}

double OAITrainingOptions::getMinSplitLoss() const {
    return m_min_split_loss;
}
void OAITrainingOptions::setMinSplitLoss(const double &min_split_loss) {
    m_min_split_loss = min_split_loss;
    m_min_split_loss_isSet = true;
}

bool OAITrainingOptions::is_min_split_loss_Set() const{
    return m_min_split_loss_isSet;
}

bool OAITrainingOptions::is_min_split_loss_Valid() const{
    return m_min_split_loss_isValid;
}

QString OAITrainingOptions::getMinTimeSeriesLength() const {
    return m_min_time_series_length;
}
void OAITrainingOptions::setMinTimeSeriesLength(const QString &min_time_series_length) {
    m_min_time_series_length = min_time_series_length;
    m_min_time_series_length_isSet = true;
}

bool OAITrainingOptions::is_min_time_series_length_Set() const{
    return m_min_time_series_length_isSet;
}

bool OAITrainingOptions::is_min_time_series_length_Valid() const{
    return m_min_time_series_length_isValid;
}

QString OAITrainingOptions::getMinTreeChildWeight() const {
    return m_min_tree_child_weight;
}
void OAITrainingOptions::setMinTreeChildWeight(const QString &min_tree_child_weight) {
    m_min_tree_child_weight = min_tree_child_weight;
    m_min_tree_child_weight_isSet = true;
}

bool OAITrainingOptions::is_min_tree_child_weight_Set() const{
    return m_min_tree_child_weight_isSet;
}

bool OAITrainingOptions::is_min_tree_child_weight_Valid() const{
    return m_min_tree_child_weight_isValid;
}

QString OAITrainingOptions::getModelRegistry() const {
    return m_model_registry;
}
void OAITrainingOptions::setModelRegistry(const QString &model_registry) {
    m_model_registry = model_registry;
    m_model_registry_isSet = true;
}

bool OAITrainingOptions::is_model_registry_Set() const{
    return m_model_registry_isSet;
}

bool OAITrainingOptions::is_model_registry_Valid() const{
    return m_model_registry_isValid;
}

QString OAITrainingOptions::getModelUri() const {
    return m_model_uri;
}
void OAITrainingOptions::setModelUri(const QString &model_uri) {
    m_model_uri = model_uri;
    m_model_uri_isSet = true;
}

bool OAITrainingOptions::is_model_uri_Set() const{
    return m_model_uri_isSet;
}

bool OAITrainingOptions::is_model_uri_Valid() const{
    return m_model_uri_isValid;
}

OAIArimaOrder OAITrainingOptions::getNonSeasonalOrder() const {
    return m_non_seasonal_order;
}
void OAITrainingOptions::setNonSeasonalOrder(const OAIArimaOrder &non_seasonal_order) {
    m_non_seasonal_order = non_seasonal_order;
    m_non_seasonal_order_isSet = true;
}

bool OAITrainingOptions::is_non_seasonal_order_Set() const{
    return m_non_seasonal_order_isSet;
}

bool OAITrainingOptions::is_non_seasonal_order_Valid() const{
    return m_non_seasonal_order_isValid;
}

QString OAITrainingOptions::getNumClusters() const {
    return m_num_clusters;
}
void OAITrainingOptions::setNumClusters(const QString &num_clusters) {
    m_num_clusters = num_clusters;
    m_num_clusters_isSet = true;
}

bool OAITrainingOptions::is_num_clusters_Set() const{
    return m_num_clusters_isSet;
}

bool OAITrainingOptions::is_num_clusters_Valid() const{
    return m_num_clusters_isValid;
}

QString OAITrainingOptions::getNumFactors() const {
    return m_num_factors;
}
void OAITrainingOptions::setNumFactors(const QString &num_factors) {
    m_num_factors = num_factors;
    m_num_factors_isSet = true;
}

bool OAITrainingOptions::is_num_factors_Set() const{
    return m_num_factors_isSet;
}

bool OAITrainingOptions::is_num_factors_Valid() const{
    return m_num_factors_isValid;
}

QString OAITrainingOptions::getNumParallelTree() const {
    return m_num_parallel_tree;
}
void OAITrainingOptions::setNumParallelTree(const QString &num_parallel_tree) {
    m_num_parallel_tree = num_parallel_tree;
    m_num_parallel_tree_isSet = true;
}

bool OAITrainingOptions::is_num_parallel_tree_Set() const{
    return m_num_parallel_tree_isSet;
}

bool OAITrainingOptions::is_num_parallel_tree_Valid() const{
    return m_num_parallel_tree_isValid;
}

QString OAITrainingOptions::getNumPrincipalComponents() const {
    return m_num_principal_components;
}
void OAITrainingOptions::setNumPrincipalComponents(const QString &num_principal_components) {
    m_num_principal_components = num_principal_components;
    m_num_principal_components_isSet = true;
}

bool OAITrainingOptions::is_num_principal_components_Set() const{
    return m_num_principal_components_isSet;
}

bool OAITrainingOptions::is_num_principal_components_Valid() const{
    return m_num_principal_components_isValid;
}

QString OAITrainingOptions::getNumTrials() const {
    return m_num_trials;
}
void OAITrainingOptions::setNumTrials(const QString &num_trials) {
    m_num_trials = num_trials;
    m_num_trials_isSet = true;
}

bool OAITrainingOptions::is_num_trials_Set() const{
    return m_num_trials_isSet;
}

bool OAITrainingOptions::is_num_trials_Valid() const{
    return m_num_trials_isValid;
}

QString OAITrainingOptions::getOptimizationStrategy() const {
    return m_optimization_strategy;
}
void OAITrainingOptions::setOptimizationStrategy(const QString &optimization_strategy) {
    m_optimization_strategy = optimization_strategy;
    m_optimization_strategy_isSet = true;
}

bool OAITrainingOptions::is_optimization_strategy_Set() const{
    return m_optimization_strategy_isSet;
}

bool OAITrainingOptions::is_optimization_strategy_Valid() const{
    return m_optimization_strategy_isValid;
}

QString OAITrainingOptions::getOptimizer() const {
    return m_optimizer;
}
void OAITrainingOptions::setOptimizer(const QString &optimizer) {
    m_optimizer = optimizer;
    m_optimizer_isSet = true;
}

bool OAITrainingOptions::is_optimizer_Set() const{
    return m_optimizer_isSet;
}

bool OAITrainingOptions::is_optimizer_Valid() const{
    return m_optimizer_isValid;
}

double OAITrainingOptions::getPcaExplainedVarianceRatio() const {
    return m_pca_explained_variance_ratio;
}
void OAITrainingOptions::setPcaExplainedVarianceRatio(const double &pca_explained_variance_ratio) {
    m_pca_explained_variance_ratio = pca_explained_variance_ratio;
    m_pca_explained_variance_ratio_isSet = true;
}

bool OAITrainingOptions::is_pca_explained_variance_ratio_Set() const{
    return m_pca_explained_variance_ratio_isSet;
}

bool OAITrainingOptions::is_pca_explained_variance_ratio_Valid() const{
    return m_pca_explained_variance_ratio_isValid;
}

QString OAITrainingOptions::getPcaSolver() const {
    return m_pca_solver;
}
void OAITrainingOptions::setPcaSolver(const QString &pca_solver) {
    m_pca_solver = pca_solver;
    m_pca_solver_isSet = true;
}

bool OAITrainingOptions::is_pca_solver_Set() const{
    return m_pca_solver_isSet;
}

bool OAITrainingOptions::is_pca_solver_Valid() const{
    return m_pca_solver_isValid;
}

QString OAITrainingOptions::getSampledShapleyNumPaths() const {
    return m_sampled_shapley_num_paths;
}
void OAITrainingOptions::setSampledShapleyNumPaths(const QString &sampled_shapley_num_paths) {
    m_sampled_shapley_num_paths = sampled_shapley_num_paths;
    m_sampled_shapley_num_paths_isSet = true;
}

bool OAITrainingOptions::is_sampled_shapley_num_paths_Set() const{
    return m_sampled_shapley_num_paths_isSet;
}

bool OAITrainingOptions::is_sampled_shapley_num_paths_Valid() const{
    return m_sampled_shapley_num_paths_isValid;
}

bool OAITrainingOptions::isScaleFeatures() const {
    return m_scale_features;
}
void OAITrainingOptions::setScaleFeatures(const bool &scale_features) {
    m_scale_features = scale_features;
    m_scale_features_isSet = true;
}

bool OAITrainingOptions::is_scale_features_Set() const{
    return m_scale_features_isSet;
}

bool OAITrainingOptions::is_scale_features_Valid() const{
    return m_scale_features_isValid;
}

bool OAITrainingOptions::isStandardizeFeatures() const {
    return m_standardize_features;
}
void OAITrainingOptions::setStandardizeFeatures(const bool &standardize_features) {
    m_standardize_features = standardize_features;
    m_standardize_features_isSet = true;
}

bool OAITrainingOptions::is_standardize_features_Set() const{
    return m_standardize_features_isSet;
}

bool OAITrainingOptions::is_standardize_features_Valid() const{
    return m_standardize_features_isValid;
}

double OAITrainingOptions::getSubsample() const {
    return m_subsample;
}
void OAITrainingOptions::setSubsample(const double &subsample) {
    m_subsample = subsample;
    m_subsample_isSet = true;
}

bool OAITrainingOptions::is_subsample_Set() const{
    return m_subsample_isSet;
}

bool OAITrainingOptions::is_subsample_Valid() const{
    return m_subsample_isValid;
}

QString OAITrainingOptions::getTfVersion() const {
    return m_tf_version;
}
void OAITrainingOptions::setTfVersion(const QString &tf_version) {
    m_tf_version = tf_version;
    m_tf_version_isSet = true;
}

bool OAITrainingOptions::is_tf_version_Set() const{
    return m_tf_version_isSet;
}

bool OAITrainingOptions::is_tf_version_Valid() const{
    return m_tf_version_isValid;
}

QString OAITrainingOptions::getTimeSeriesDataColumn() const {
    return m_time_series_data_column;
}
void OAITrainingOptions::setTimeSeriesDataColumn(const QString &time_series_data_column) {
    m_time_series_data_column = time_series_data_column;
    m_time_series_data_column_isSet = true;
}

bool OAITrainingOptions::is_time_series_data_column_Set() const{
    return m_time_series_data_column_isSet;
}

bool OAITrainingOptions::is_time_series_data_column_Valid() const{
    return m_time_series_data_column_isValid;
}

QString OAITrainingOptions::getTimeSeriesIdColumn() const {
    return m_time_series_id_column;
}
void OAITrainingOptions::setTimeSeriesIdColumn(const QString &time_series_id_column) {
    m_time_series_id_column = time_series_id_column;
    m_time_series_id_column_isSet = true;
}

bool OAITrainingOptions::is_time_series_id_column_Set() const{
    return m_time_series_id_column_isSet;
}

bool OAITrainingOptions::is_time_series_id_column_Valid() const{
    return m_time_series_id_column_isValid;
}

QList<QString> OAITrainingOptions::getTimeSeriesIdColumns() const {
    return m_time_series_id_columns;
}
void OAITrainingOptions::setTimeSeriesIdColumns(const QList<QString> &time_series_id_columns) {
    m_time_series_id_columns = time_series_id_columns;
    m_time_series_id_columns_isSet = true;
}

bool OAITrainingOptions::is_time_series_id_columns_Set() const{
    return m_time_series_id_columns_isSet;
}

bool OAITrainingOptions::is_time_series_id_columns_Valid() const{
    return m_time_series_id_columns_isValid;
}

double OAITrainingOptions::getTimeSeriesLengthFraction() const {
    return m_time_series_length_fraction;
}
void OAITrainingOptions::setTimeSeriesLengthFraction(const double &time_series_length_fraction) {
    m_time_series_length_fraction = time_series_length_fraction;
    m_time_series_length_fraction_isSet = true;
}

bool OAITrainingOptions::is_time_series_length_fraction_Set() const{
    return m_time_series_length_fraction_isSet;
}

bool OAITrainingOptions::is_time_series_length_fraction_Valid() const{
    return m_time_series_length_fraction_isValid;
}

QString OAITrainingOptions::getTimeSeriesTimestampColumn() const {
    return m_time_series_timestamp_column;
}
void OAITrainingOptions::setTimeSeriesTimestampColumn(const QString &time_series_timestamp_column) {
    m_time_series_timestamp_column = time_series_timestamp_column;
    m_time_series_timestamp_column_isSet = true;
}

bool OAITrainingOptions::is_time_series_timestamp_column_Set() const{
    return m_time_series_timestamp_column_isSet;
}

bool OAITrainingOptions::is_time_series_timestamp_column_Valid() const{
    return m_time_series_timestamp_column_isValid;
}

QString OAITrainingOptions::getTreeMethod() const {
    return m_tree_method;
}
void OAITrainingOptions::setTreeMethod(const QString &tree_method) {
    m_tree_method = tree_method;
    m_tree_method_isSet = true;
}

bool OAITrainingOptions::is_tree_method_Set() const{
    return m_tree_method_isSet;
}

bool OAITrainingOptions::is_tree_method_Valid() const{
    return m_tree_method_isValid;
}

QString OAITrainingOptions::getTrendSmoothingWindowSize() const {
    return m_trend_smoothing_window_size;
}
void OAITrainingOptions::setTrendSmoothingWindowSize(const QString &trend_smoothing_window_size) {
    m_trend_smoothing_window_size = trend_smoothing_window_size;
    m_trend_smoothing_window_size_isSet = true;
}

bool OAITrainingOptions::is_trend_smoothing_window_size_Set() const{
    return m_trend_smoothing_window_size_isSet;
}

bool OAITrainingOptions::is_trend_smoothing_window_size_Valid() const{
    return m_trend_smoothing_window_size_isValid;
}

QString OAITrainingOptions::getUserColumn() const {
    return m_user_column;
}
void OAITrainingOptions::setUserColumn(const QString &user_column) {
    m_user_column = user_column;
    m_user_column_isSet = true;
}

bool OAITrainingOptions::is_user_column_Set() const{
    return m_user_column_isSet;
}

bool OAITrainingOptions::is_user_column_Valid() const{
    return m_user_column_isValid;
}

QList<QString> OAITrainingOptions::getVertexAiModelVersionAliases() const {
    return m_vertex_ai_model_version_aliases;
}
void OAITrainingOptions::setVertexAiModelVersionAliases(const QList<QString> &vertex_ai_model_version_aliases) {
    m_vertex_ai_model_version_aliases = vertex_ai_model_version_aliases;
    m_vertex_ai_model_version_aliases_isSet = true;
}

bool OAITrainingOptions::is_vertex_ai_model_version_aliases_Set() const{
    return m_vertex_ai_model_version_aliases_isSet;
}

bool OAITrainingOptions::is_vertex_ai_model_version_aliases_Valid() const{
    return m_vertex_ai_model_version_aliases_isValid;
}

double OAITrainingOptions::getWalsAlpha() const {
    return m_wals_alpha;
}
void OAITrainingOptions::setWalsAlpha(const double &wals_alpha) {
    m_wals_alpha = wals_alpha;
    m_wals_alpha_isSet = true;
}

bool OAITrainingOptions::is_wals_alpha_Set() const{
    return m_wals_alpha_isSet;
}

bool OAITrainingOptions::is_wals_alpha_Valid() const{
    return m_wals_alpha_isValid;
}

bool OAITrainingOptions::isWarmStart() const {
    return m_warm_start;
}
void OAITrainingOptions::setWarmStart(const bool &warm_start) {
    m_warm_start = warm_start;
    m_warm_start_isSet = true;
}

bool OAITrainingOptions::is_warm_start_Set() const{
    return m_warm_start_isSet;
}

bool OAITrainingOptions::is_warm_start_Valid() const{
    return m_warm_start_isValid;
}

QString OAITrainingOptions::getXgboostVersion() const {
    return m_xgboost_version;
}
void OAITrainingOptions::setXgboostVersion(const QString &xgboost_version) {
    m_xgboost_version = xgboost_version;
    m_xgboost_version_isSet = true;
}

bool OAITrainingOptions::is_xgboost_version_Set() const{
    return m_xgboost_version_isSet;
}

bool OAITrainingOptions::is_xgboost_version_Valid() const{
    return m_xgboost_version_isValid;
}

bool OAITrainingOptions::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_activation_fn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_adjust_step_changes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_approx_global_feature_contrib_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_arima_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_arima_max_order_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_arima_min_order_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_class_weights_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_batch_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_booster_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_budget_hours_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_calculate_p_values_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_category_encoding_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_clean_spikes_and_dips_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bylevel_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bynode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bytree_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dart_normalize_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_frequency_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_split_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_split_eval_fraction_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_split_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_decompose_time_series_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_distance_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dropout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_early_stop_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_global_explain_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_feedback_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fit_intercept_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hidden_units.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_holiday_region_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_holiday_regions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_horizon_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hparam_tuning_objectives.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_drift_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_initial_learn_rate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_input_label_columns.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_weight_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_integrated_gradients_num_steps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_item_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kmeans_initialization_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kmeans_initialization_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_l1_reg_activation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_l1_regularization_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_l2_regularization_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_label_class_weights.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_learn_rate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_learn_rate_strategy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_loss_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_iterations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_parallel_trials_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_time_series_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_tree_depth_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_relative_progress_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_split_loss_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_time_series_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_tree_child_weight_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_model_registry_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_model_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_non_seasonal_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_clusters_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_factors_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_parallel_tree_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_principal_components_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_trials_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_optimization_strategy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_optimizer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pca_explained_variance_ratio_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pca_solver_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sampled_shapley_num_paths_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scale_features_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_standardize_features_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subsample_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tf_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_series_data_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_series_id_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_series_id_columns.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_series_length_fraction_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_series_timestamp_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tree_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_trend_smoothing_window_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vertex_ai_model_version_aliases.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wals_alpha_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_warm_start_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_xgboost_version_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITrainingOptions::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
