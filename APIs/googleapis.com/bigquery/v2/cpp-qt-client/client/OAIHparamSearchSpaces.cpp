/**
 * BigQuery API
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIHparamSearchSpaces.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIHparamSearchSpaces::OAIHparamSearchSpaces(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIHparamSearchSpaces::OAIHparamSearchSpaces() {
    this->initializeModel();
}

OAIHparamSearchSpaces::~OAIHparamSearchSpaces() {}

void OAIHparamSearchSpaces::initializeModel() {

    m_activation_fn_isSet = false;
    m_activation_fn_isValid = false;

    m_batch_size_isSet = false;
    m_batch_size_isValid = false;

    m_booster_type_isSet = false;
    m_booster_type_isValid = false;

    m_colsample_bylevel_isSet = false;
    m_colsample_bylevel_isValid = false;

    m_colsample_bynode_isSet = false;
    m_colsample_bynode_isValid = false;

    m_colsample_bytree_isSet = false;
    m_colsample_bytree_isValid = false;

    m_dart_normalize_type_isSet = false;
    m_dart_normalize_type_isValid = false;

    m_dropout_isSet = false;
    m_dropout_isValid = false;

    m_hidden_units_isSet = false;
    m_hidden_units_isValid = false;

    m_l1_reg_isSet = false;
    m_l1_reg_isValid = false;

    m_l2_reg_isSet = false;
    m_l2_reg_isValid = false;

    m_learn_rate_isSet = false;
    m_learn_rate_isValid = false;

    m_max_tree_depth_isSet = false;
    m_max_tree_depth_isValid = false;

    m_min_split_loss_isSet = false;
    m_min_split_loss_isValid = false;

    m_min_tree_child_weight_isSet = false;
    m_min_tree_child_weight_isValid = false;

    m_num_clusters_isSet = false;
    m_num_clusters_isValid = false;

    m_num_factors_isSet = false;
    m_num_factors_isValid = false;

    m_num_parallel_tree_isSet = false;
    m_num_parallel_tree_isValid = false;

    m_optimizer_isSet = false;
    m_optimizer_isValid = false;

    m_subsample_isSet = false;
    m_subsample_isValid = false;

    m_tree_method_isSet = false;
    m_tree_method_isValid = false;

    m_wals_alpha_isSet = false;
    m_wals_alpha_isValid = false;
}

void OAIHparamSearchSpaces::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIHparamSearchSpaces::fromJsonObject(QJsonObject json) {

    m_activation_fn_isValid = ::OpenAPI::fromJsonValue(m_activation_fn, json[QString("activationFn")]);
    m_activation_fn_isSet = !json[QString("activationFn")].isNull() && m_activation_fn_isValid;

    m_batch_size_isValid = ::OpenAPI::fromJsonValue(m_batch_size, json[QString("batchSize")]);
    m_batch_size_isSet = !json[QString("batchSize")].isNull() && m_batch_size_isValid;

    m_booster_type_isValid = ::OpenAPI::fromJsonValue(m_booster_type, json[QString("boosterType")]);
    m_booster_type_isSet = !json[QString("boosterType")].isNull() && m_booster_type_isValid;

    m_colsample_bylevel_isValid = ::OpenAPI::fromJsonValue(m_colsample_bylevel, json[QString("colsampleBylevel")]);
    m_colsample_bylevel_isSet = !json[QString("colsampleBylevel")].isNull() && m_colsample_bylevel_isValid;

    m_colsample_bynode_isValid = ::OpenAPI::fromJsonValue(m_colsample_bynode, json[QString("colsampleBynode")]);
    m_colsample_bynode_isSet = !json[QString("colsampleBynode")].isNull() && m_colsample_bynode_isValid;

    m_colsample_bytree_isValid = ::OpenAPI::fromJsonValue(m_colsample_bytree, json[QString("colsampleBytree")]);
    m_colsample_bytree_isSet = !json[QString("colsampleBytree")].isNull() && m_colsample_bytree_isValid;

    m_dart_normalize_type_isValid = ::OpenAPI::fromJsonValue(m_dart_normalize_type, json[QString("dartNormalizeType")]);
    m_dart_normalize_type_isSet = !json[QString("dartNormalizeType")].isNull() && m_dart_normalize_type_isValid;

    m_dropout_isValid = ::OpenAPI::fromJsonValue(m_dropout, json[QString("dropout")]);
    m_dropout_isSet = !json[QString("dropout")].isNull() && m_dropout_isValid;

    m_hidden_units_isValid = ::OpenAPI::fromJsonValue(m_hidden_units, json[QString("hiddenUnits")]);
    m_hidden_units_isSet = !json[QString("hiddenUnits")].isNull() && m_hidden_units_isValid;

    m_l1_reg_isValid = ::OpenAPI::fromJsonValue(m_l1_reg, json[QString("l1Reg")]);
    m_l1_reg_isSet = !json[QString("l1Reg")].isNull() && m_l1_reg_isValid;

    m_l2_reg_isValid = ::OpenAPI::fromJsonValue(m_l2_reg, json[QString("l2Reg")]);
    m_l2_reg_isSet = !json[QString("l2Reg")].isNull() && m_l2_reg_isValid;

    m_learn_rate_isValid = ::OpenAPI::fromJsonValue(m_learn_rate, json[QString("learnRate")]);
    m_learn_rate_isSet = !json[QString("learnRate")].isNull() && m_learn_rate_isValid;

    m_max_tree_depth_isValid = ::OpenAPI::fromJsonValue(m_max_tree_depth, json[QString("maxTreeDepth")]);
    m_max_tree_depth_isSet = !json[QString("maxTreeDepth")].isNull() && m_max_tree_depth_isValid;

    m_min_split_loss_isValid = ::OpenAPI::fromJsonValue(m_min_split_loss, json[QString("minSplitLoss")]);
    m_min_split_loss_isSet = !json[QString("minSplitLoss")].isNull() && m_min_split_loss_isValid;

    m_min_tree_child_weight_isValid = ::OpenAPI::fromJsonValue(m_min_tree_child_weight, json[QString("minTreeChildWeight")]);
    m_min_tree_child_weight_isSet = !json[QString("minTreeChildWeight")].isNull() && m_min_tree_child_weight_isValid;

    m_num_clusters_isValid = ::OpenAPI::fromJsonValue(m_num_clusters, json[QString("numClusters")]);
    m_num_clusters_isSet = !json[QString("numClusters")].isNull() && m_num_clusters_isValid;

    m_num_factors_isValid = ::OpenAPI::fromJsonValue(m_num_factors, json[QString("numFactors")]);
    m_num_factors_isSet = !json[QString("numFactors")].isNull() && m_num_factors_isValid;

    m_num_parallel_tree_isValid = ::OpenAPI::fromJsonValue(m_num_parallel_tree, json[QString("numParallelTree")]);
    m_num_parallel_tree_isSet = !json[QString("numParallelTree")].isNull() && m_num_parallel_tree_isValid;

    m_optimizer_isValid = ::OpenAPI::fromJsonValue(m_optimizer, json[QString("optimizer")]);
    m_optimizer_isSet = !json[QString("optimizer")].isNull() && m_optimizer_isValid;

    m_subsample_isValid = ::OpenAPI::fromJsonValue(m_subsample, json[QString("subsample")]);
    m_subsample_isSet = !json[QString("subsample")].isNull() && m_subsample_isValid;

    m_tree_method_isValid = ::OpenAPI::fromJsonValue(m_tree_method, json[QString("treeMethod")]);
    m_tree_method_isSet = !json[QString("treeMethod")].isNull() && m_tree_method_isValid;

    m_wals_alpha_isValid = ::OpenAPI::fromJsonValue(m_wals_alpha, json[QString("walsAlpha")]);
    m_wals_alpha_isSet = !json[QString("walsAlpha")].isNull() && m_wals_alpha_isValid;
}

QString OAIHparamSearchSpaces::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIHparamSearchSpaces::asJsonObject() const {
    QJsonObject obj;
    if (m_activation_fn.isSet()) {
        obj.insert(QString("activationFn"), ::OpenAPI::toJsonValue(m_activation_fn));
    }
    if (m_batch_size.isSet()) {
        obj.insert(QString("batchSize"), ::OpenAPI::toJsonValue(m_batch_size));
    }
    if (m_booster_type.isSet()) {
        obj.insert(QString("boosterType"), ::OpenAPI::toJsonValue(m_booster_type));
    }
    if (m_colsample_bylevel.isSet()) {
        obj.insert(QString("colsampleBylevel"), ::OpenAPI::toJsonValue(m_colsample_bylevel));
    }
    if (m_colsample_bynode.isSet()) {
        obj.insert(QString("colsampleBynode"), ::OpenAPI::toJsonValue(m_colsample_bynode));
    }
    if (m_colsample_bytree.isSet()) {
        obj.insert(QString("colsampleBytree"), ::OpenAPI::toJsonValue(m_colsample_bytree));
    }
    if (m_dart_normalize_type.isSet()) {
        obj.insert(QString("dartNormalizeType"), ::OpenAPI::toJsonValue(m_dart_normalize_type));
    }
    if (m_dropout.isSet()) {
        obj.insert(QString("dropout"), ::OpenAPI::toJsonValue(m_dropout));
    }
    if (m_hidden_units.isSet()) {
        obj.insert(QString("hiddenUnits"), ::OpenAPI::toJsonValue(m_hidden_units));
    }
    if (m_l1_reg.isSet()) {
        obj.insert(QString("l1Reg"), ::OpenAPI::toJsonValue(m_l1_reg));
    }
    if (m_l2_reg.isSet()) {
        obj.insert(QString("l2Reg"), ::OpenAPI::toJsonValue(m_l2_reg));
    }
    if (m_learn_rate.isSet()) {
        obj.insert(QString("learnRate"), ::OpenAPI::toJsonValue(m_learn_rate));
    }
    if (m_max_tree_depth.isSet()) {
        obj.insert(QString("maxTreeDepth"), ::OpenAPI::toJsonValue(m_max_tree_depth));
    }
    if (m_min_split_loss.isSet()) {
        obj.insert(QString("minSplitLoss"), ::OpenAPI::toJsonValue(m_min_split_loss));
    }
    if (m_min_tree_child_weight.isSet()) {
        obj.insert(QString("minTreeChildWeight"), ::OpenAPI::toJsonValue(m_min_tree_child_weight));
    }
    if (m_num_clusters.isSet()) {
        obj.insert(QString("numClusters"), ::OpenAPI::toJsonValue(m_num_clusters));
    }
    if (m_num_factors.isSet()) {
        obj.insert(QString("numFactors"), ::OpenAPI::toJsonValue(m_num_factors));
    }
    if (m_num_parallel_tree.isSet()) {
        obj.insert(QString("numParallelTree"), ::OpenAPI::toJsonValue(m_num_parallel_tree));
    }
    if (m_optimizer.isSet()) {
        obj.insert(QString("optimizer"), ::OpenAPI::toJsonValue(m_optimizer));
    }
    if (m_subsample.isSet()) {
        obj.insert(QString("subsample"), ::OpenAPI::toJsonValue(m_subsample));
    }
    if (m_tree_method.isSet()) {
        obj.insert(QString("treeMethod"), ::OpenAPI::toJsonValue(m_tree_method));
    }
    if (m_wals_alpha.isSet()) {
        obj.insert(QString("walsAlpha"), ::OpenAPI::toJsonValue(m_wals_alpha));
    }
    return obj;
}

OAIStringHparamSearchSpace OAIHparamSearchSpaces::getActivationFn() const {
    return m_activation_fn;
}
void OAIHparamSearchSpaces::setActivationFn(const OAIStringHparamSearchSpace &activation_fn) {
    m_activation_fn = activation_fn;
    m_activation_fn_isSet = true;
}

bool OAIHparamSearchSpaces::is_activation_fn_Set() const{
    return m_activation_fn_isSet;
}

bool OAIHparamSearchSpaces::is_activation_fn_Valid() const{
    return m_activation_fn_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getBatchSize() const {
    return m_batch_size;
}
void OAIHparamSearchSpaces::setBatchSize(const OAIIntHparamSearchSpace &batch_size) {
    m_batch_size = batch_size;
    m_batch_size_isSet = true;
}

bool OAIHparamSearchSpaces::is_batch_size_Set() const{
    return m_batch_size_isSet;
}

bool OAIHparamSearchSpaces::is_batch_size_Valid() const{
    return m_batch_size_isValid;
}

OAIStringHparamSearchSpace OAIHparamSearchSpaces::getBoosterType() const {
    return m_booster_type;
}
void OAIHparamSearchSpaces::setBoosterType(const OAIStringHparamSearchSpace &booster_type) {
    m_booster_type = booster_type;
    m_booster_type_isSet = true;
}

bool OAIHparamSearchSpaces::is_booster_type_Set() const{
    return m_booster_type_isSet;
}

bool OAIHparamSearchSpaces::is_booster_type_Valid() const{
    return m_booster_type_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getColsampleBylevel() const {
    return m_colsample_bylevel;
}
void OAIHparamSearchSpaces::setColsampleBylevel(const OAIDoubleHparamSearchSpace &colsample_bylevel) {
    m_colsample_bylevel = colsample_bylevel;
    m_colsample_bylevel_isSet = true;
}

bool OAIHparamSearchSpaces::is_colsample_bylevel_Set() const{
    return m_colsample_bylevel_isSet;
}

bool OAIHparamSearchSpaces::is_colsample_bylevel_Valid() const{
    return m_colsample_bylevel_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getColsampleBynode() const {
    return m_colsample_bynode;
}
void OAIHparamSearchSpaces::setColsampleBynode(const OAIDoubleHparamSearchSpace &colsample_bynode) {
    m_colsample_bynode = colsample_bynode;
    m_colsample_bynode_isSet = true;
}

bool OAIHparamSearchSpaces::is_colsample_bynode_Set() const{
    return m_colsample_bynode_isSet;
}

bool OAIHparamSearchSpaces::is_colsample_bynode_Valid() const{
    return m_colsample_bynode_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getColsampleBytree() const {
    return m_colsample_bytree;
}
void OAIHparamSearchSpaces::setColsampleBytree(const OAIDoubleHparamSearchSpace &colsample_bytree) {
    m_colsample_bytree = colsample_bytree;
    m_colsample_bytree_isSet = true;
}

bool OAIHparamSearchSpaces::is_colsample_bytree_Set() const{
    return m_colsample_bytree_isSet;
}

bool OAIHparamSearchSpaces::is_colsample_bytree_Valid() const{
    return m_colsample_bytree_isValid;
}

OAIStringHparamSearchSpace OAIHparamSearchSpaces::getDartNormalizeType() const {
    return m_dart_normalize_type;
}
void OAIHparamSearchSpaces::setDartNormalizeType(const OAIStringHparamSearchSpace &dart_normalize_type) {
    m_dart_normalize_type = dart_normalize_type;
    m_dart_normalize_type_isSet = true;
}

bool OAIHparamSearchSpaces::is_dart_normalize_type_Set() const{
    return m_dart_normalize_type_isSet;
}

bool OAIHparamSearchSpaces::is_dart_normalize_type_Valid() const{
    return m_dart_normalize_type_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getDropout() const {
    return m_dropout;
}
void OAIHparamSearchSpaces::setDropout(const OAIDoubleHparamSearchSpace &dropout) {
    m_dropout = dropout;
    m_dropout_isSet = true;
}

bool OAIHparamSearchSpaces::is_dropout_Set() const{
    return m_dropout_isSet;
}

bool OAIHparamSearchSpaces::is_dropout_Valid() const{
    return m_dropout_isValid;
}

OAIIntArrayHparamSearchSpace OAIHparamSearchSpaces::getHiddenUnits() const {
    return m_hidden_units;
}
void OAIHparamSearchSpaces::setHiddenUnits(const OAIIntArrayHparamSearchSpace &hidden_units) {
    m_hidden_units = hidden_units;
    m_hidden_units_isSet = true;
}

bool OAIHparamSearchSpaces::is_hidden_units_Set() const{
    return m_hidden_units_isSet;
}

bool OAIHparamSearchSpaces::is_hidden_units_Valid() const{
    return m_hidden_units_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getL1Reg() const {
    return m_l1_reg;
}
void OAIHparamSearchSpaces::setL1Reg(const OAIDoubleHparamSearchSpace &l1_reg) {
    m_l1_reg = l1_reg;
    m_l1_reg_isSet = true;
}

bool OAIHparamSearchSpaces::is_l1_reg_Set() const{
    return m_l1_reg_isSet;
}

bool OAIHparamSearchSpaces::is_l1_reg_Valid() const{
    return m_l1_reg_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getL2Reg() const {
    return m_l2_reg;
}
void OAIHparamSearchSpaces::setL2Reg(const OAIDoubleHparamSearchSpace &l2_reg) {
    m_l2_reg = l2_reg;
    m_l2_reg_isSet = true;
}

bool OAIHparamSearchSpaces::is_l2_reg_Set() const{
    return m_l2_reg_isSet;
}

bool OAIHparamSearchSpaces::is_l2_reg_Valid() const{
    return m_l2_reg_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getLearnRate() const {
    return m_learn_rate;
}
void OAIHparamSearchSpaces::setLearnRate(const OAIDoubleHparamSearchSpace &learn_rate) {
    m_learn_rate = learn_rate;
    m_learn_rate_isSet = true;
}

bool OAIHparamSearchSpaces::is_learn_rate_Set() const{
    return m_learn_rate_isSet;
}

bool OAIHparamSearchSpaces::is_learn_rate_Valid() const{
    return m_learn_rate_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getMaxTreeDepth() const {
    return m_max_tree_depth;
}
void OAIHparamSearchSpaces::setMaxTreeDepth(const OAIIntHparamSearchSpace &max_tree_depth) {
    m_max_tree_depth = max_tree_depth;
    m_max_tree_depth_isSet = true;
}

bool OAIHparamSearchSpaces::is_max_tree_depth_Set() const{
    return m_max_tree_depth_isSet;
}

bool OAIHparamSearchSpaces::is_max_tree_depth_Valid() const{
    return m_max_tree_depth_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getMinSplitLoss() const {
    return m_min_split_loss;
}
void OAIHparamSearchSpaces::setMinSplitLoss(const OAIDoubleHparamSearchSpace &min_split_loss) {
    m_min_split_loss = min_split_loss;
    m_min_split_loss_isSet = true;
}

bool OAIHparamSearchSpaces::is_min_split_loss_Set() const{
    return m_min_split_loss_isSet;
}

bool OAIHparamSearchSpaces::is_min_split_loss_Valid() const{
    return m_min_split_loss_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getMinTreeChildWeight() const {
    return m_min_tree_child_weight;
}
void OAIHparamSearchSpaces::setMinTreeChildWeight(const OAIIntHparamSearchSpace &min_tree_child_weight) {
    m_min_tree_child_weight = min_tree_child_weight;
    m_min_tree_child_weight_isSet = true;
}

bool OAIHparamSearchSpaces::is_min_tree_child_weight_Set() const{
    return m_min_tree_child_weight_isSet;
}

bool OAIHparamSearchSpaces::is_min_tree_child_weight_Valid() const{
    return m_min_tree_child_weight_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getNumClusters() const {
    return m_num_clusters;
}
void OAIHparamSearchSpaces::setNumClusters(const OAIIntHparamSearchSpace &num_clusters) {
    m_num_clusters = num_clusters;
    m_num_clusters_isSet = true;
}

bool OAIHparamSearchSpaces::is_num_clusters_Set() const{
    return m_num_clusters_isSet;
}

bool OAIHparamSearchSpaces::is_num_clusters_Valid() const{
    return m_num_clusters_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getNumFactors() const {
    return m_num_factors;
}
void OAIHparamSearchSpaces::setNumFactors(const OAIIntHparamSearchSpace &num_factors) {
    m_num_factors = num_factors;
    m_num_factors_isSet = true;
}

bool OAIHparamSearchSpaces::is_num_factors_Set() const{
    return m_num_factors_isSet;
}

bool OAIHparamSearchSpaces::is_num_factors_Valid() const{
    return m_num_factors_isValid;
}

OAIIntHparamSearchSpace OAIHparamSearchSpaces::getNumParallelTree() const {
    return m_num_parallel_tree;
}
void OAIHparamSearchSpaces::setNumParallelTree(const OAIIntHparamSearchSpace &num_parallel_tree) {
    m_num_parallel_tree = num_parallel_tree;
    m_num_parallel_tree_isSet = true;
}

bool OAIHparamSearchSpaces::is_num_parallel_tree_Set() const{
    return m_num_parallel_tree_isSet;
}

bool OAIHparamSearchSpaces::is_num_parallel_tree_Valid() const{
    return m_num_parallel_tree_isValid;
}

OAIStringHparamSearchSpace OAIHparamSearchSpaces::getOptimizer() const {
    return m_optimizer;
}
void OAIHparamSearchSpaces::setOptimizer(const OAIStringHparamSearchSpace &optimizer) {
    m_optimizer = optimizer;
    m_optimizer_isSet = true;
}

bool OAIHparamSearchSpaces::is_optimizer_Set() const{
    return m_optimizer_isSet;
}

bool OAIHparamSearchSpaces::is_optimizer_Valid() const{
    return m_optimizer_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getSubsample() const {
    return m_subsample;
}
void OAIHparamSearchSpaces::setSubsample(const OAIDoubleHparamSearchSpace &subsample) {
    m_subsample = subsample;
    m_subsample_isSet = true;
}

bool OAIHparamSearchSpaces::is_subsample_Set() const{
    return m_subsample_isSet;
}

bool OAIHparamSearchSpaces::is_subsample_Valid() const{
    return m_subsample_isValid;
}

OAIStringHparamSearchSpace OAIHparamSearchSpaces::getTreeMethod() const {
    return m_tree_method;
}
void OAIHparamSearchSpaces::setTreeMethod(const OAIStringHparamSearchSpace &tree_method) {
    m_tree_method = tree_method;
    m_tree_method_isSet = true;
}

bool OAIHparamSearchSpaces::is_tree_method_Set() const{
    return m_tree_method_isSet;
}

bool OAIHparamSearchSpaces::is_tree_method_Valid() const{
    return m_tree_method_isValid;
}

OAIDoubleHparamSearchSpace OAIHparamSearchSpaces::getWalsAlpha() const {
    return m_wals_alpha;
}
void OAIHparamSearchSpaces::setWalsAlpha(const OAIDoubleHparamSearchSpace &wals_alpha) {
    m_wals_alpha = wals_alpha;
    m_wals_alpha_isSet = true;
}

bool OAIHparamSearchSpaces::is_wals_alpha_Set() const{
    return m_wals_alpha_isSet;
}

bool OAIHparamSearchSpaces::is_wals_alpha_Valid() const{
    return m_wals_alpha_isValid;
}

bool OAIHparamSearchSpaces::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_activation_fn.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_batch_size.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_booster_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bylevel.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bynode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_colsample_bytree.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dart_normalize_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dropout.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hidden_units.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_l1_reg.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_l2_reg.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_learn_rate.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_tree_depth.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_split_loss.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_tree_child_weight.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_clusters.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_factors.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_parallel_tree.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_optimizer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subsample.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tree_method.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_wals_alpha.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIHparamSearchSpaces::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
