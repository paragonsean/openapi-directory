/*
 * Cloud Composer API
 * Manages Apache Airflow environments on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.CloudDataLineageIntegration;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies the selection and configuration of software inside the environment.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:41.703333-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SoftwareConfig {
  public static final String SERIALIZED_NAME_AIRFLOW_CONFIG_OVERRIDES = "airflowConfigOverrides";
  @SerializedName(SERIALIZED_NAME_AIRFLOW_CONFIG_OVERRIDES)
  private Map<String, String> airflowConfigOverrides = new HashMap<>();

  public static final String SERIALIZED_NAME_CLOUD_DATA_LINEAGE_INTEGRATION = "cloudDataLineageIntegration";
  @SerializedName(SERIALIZED_NAME_CLOUD_DATA_LINEAGE_INTEGRATION)
  private CloudDataLineageIntegration cloudDataLineageIntegration;

  public static final String SERIALIZED_NAME_ENV_VARIABLES = "envVariables";
  @SerializedName(SERIALIZED_NAME_ENV_VARIABLES)
  private Map<String, String> envVariables = new HashMap<>();

  public static final String SERIALIZED_NAME_IMAGE_VERSION = "imageVersion";
  @SerializedName(SERIALIZED_NAME_IMAGE_VERSION)
  private String imageVersion;

  public static final String SERIALIZED_NAME_PYPI_PACKAGES = "pypiPackages";
  @SerializedName(SERIALIZED_NAME_PYPI_PACKAGES)
  private Map<String, String> pypiPackages = new HashMap<>();

  public static final String SERIALIZED_NAME_PYTHON_VERSION = "pythonVersion";
  @SerializedName(SERIALIZED_NAME_PYTHON_VERSION)
  private String pythonVersion;

  public static final String SERIALIZED_NAME_SCHEDULER_COUNT = "schedulerCount";
  @SerializedName(SERIALIZED_NAME_SCHEDULER_COUNT)
  private Integer schedulerCount;

  /**
   * Optional. Whether or not the web server uses custom plugins. If unspecified, the field defaults to &#x60;PLUGINS_ENABLED&#x60;. This field is supported for Cloud Composer environments in versions composer-3.*.*-airflow-*.*.* and newer.
   */
  @JsonAdapter(WebServerPluginsModeEnum.Adapter.class)
  public enum WebServerPluginsModeEnum {
    WEB_SERVER_PLUGINS_MODE_UNSPECIFIED("WEB_SERVER_PLUGINS_MODE_UNSPECIFIED"),
    
    PLUGINS_DISABLED("PLUGINS_DISABLED"),
    
    PLUGINS_ENABLED("PLUGINS_ENABLED");

    private String value;

    WebServerPluginsModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WebServerPluginsModeEnum fromValue(String value) {
      for (WebServerPluginsModeEnum b : WebServerPluginsModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<WebServerPluginsModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WebServerPluginsModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WebServerPluginsModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return WebServerPluginsModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      WebServerPluginsModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_WEB_SERVER_PLUGINS_MODE = "webServerPluginsMode";
  @SerializedName(SERIALIZED_NAME_WEB_SERVER_PLUGINS_MODE)
  private WebServerPluginsModeEnum webServerPluginsMode;

  public SoftwareConfig() {
  }

  public SoftwareConfig airflowConfigOverrides(Map<String, String> airflowConfigOverrides) {
    this.airflowConfigOverrides = airflowConfigOverrides;
    return this;
  }

  public SoftwareConfig putAirflowConfigOverridesItem(String key, String airflowConfigOverridesItem) {
    if (this.airflowConfigOverrides == null) {
      this.airflowConfigOverrides = new HashMap<>();
    }
    this.airflowConfigOverrides.put(key, airflowConfigOverridesItem);
    return this;
  }

  /**
   * Optional. Apache Airflow configuration properties to override. Property keys contain the section and property names, separated by a hyphen, for example \&quot;core-dags_are_paused_at_creation\&quot;. Section names must not contain hyphens (\&quot;-\&quot;), opening square brackets (\&quot;[\&quot;), or closing square brackets (\&quot;]\&quot;). The property name must not be empty and must not contain an equals sign (\&quot;&#x3D;\&quot;) or semicolon (\&quot;;\&quot;). Section and property names must not contain a period (\&quot;.\&quot;). Apache Airflow configuration property names must be written in [snake_case](https://en.wikipedia.org/wiki/Snake_case). Property values can contain any character, and can be written in any lower/upper case format. Certain Apache Airflow configuration property values are [blocked](/composer/docs/concepts/airflow-configurations), and cannot be overridden.
   * @return airflowConfigOverrides
   */
  @javax.annotation.Nullable
  public Map<String, String> getAirflowConfigOverrides() {
    return airflowConfigOverrides;
  }

  public void setAirflowConfigOverrides(Map<String, String> airflowConfigOverrides) {
    this.airflowConfigOverrides = airflowConfigOverrides;
  }


  public SoftwareConfig cloudDataLineageIntegration(CloudDataLineageIntegration cloudDataLineageIntegration) {
    this.cloudDataLineageIntegration = cloudDataLineageIntegration;
    return this;
  }

  /**
   * Get cloudDataLineageIntegration
   * @return cloudDataLineageIntegration
   */
  @javax.annotation.Nullable
  public CloudDataLineageIntegration getCloudDataLineageIntegration() {
    return cloudDataLineageIntegration;
  }

  public void setCloudDataLineageIntegration(CloudDataLineageIntegration cloudDataLineageIntegration) {
    this.cloudDataLineageIntegration = cloudDataLineageIntegration;
  }


  public SoftwareConfig envVariables(Map<String, String> envVariables) {
    this.envVariables = envVariables;
    return this;
  }

  public SoftwareConfig putEnvVariablesItem(String key, String envVariablesItem) {
    if (this.envVariables == null) {
      this.envVariables = new HashMap<>();
    }
    this.envVariables.put(key, envVariablesItem);
    return this;
  }

  /**
   * Optional. Additional environment variables to provide to the Apache Airflow scheduler, worker, and webserver processes. Environment variable names must match the regular expression &#x60;a-zA-Z_*&#x60;. They cannot specify Apache Airflow software configuration overrides (they cannot match the regular expression &#x60;AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+&#x60;), and they cannot match any of the following reserved names: * &#x60;AIRFLOW_HOME&#x60; * &#x60;C_FORCE_ROOT&#x60; * &#x60;CONTAINER_NAME&#x60; * &#x60;DAGS_FOLDER&#x60; * &#x60;GCP_PROJECT&#x60; * &#x60;GCS_BUCKET&#x60; * &#x60;GKE_CLUSTER_NAME&#x60; * &#x60;SQL_DATABASE&#x60; * &#x60;SQL_INSTANCE&#x60; * &#x60;SQL_PASSWORD&#x60; * &#x60;SQL_PROJECT&#x60; * &#x60;SQL_REGION&#x60; * &#x60;SQL_USER&#x60;
   * @return envVariables
   */
  @javax.annotation.Nullable
  public Map<String, String> getEnvVariables() {
    return envVariables;
  }

  public void setEnvVariables(Map<String, String> envVariables) {
    this.envVariables = envVariables;
  }


  public SoftwareConfig imageVersion(String imageVersion) {
    this.imageVersion = imageVersion;
    return this;
  }

  /**
   * The version of the software running in the environment. This encapsulates both the version of Cloud Composer functionality and the version of Apache Airflow. It must match the regular expression &#x60;composer-([0-9]+(\\.[0-9]+\\.[0-9]+(-preview\\.[0-9]+)?)?|latest)-airflow-([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)&#x60;. When used as input, the server also checks if the provided version is supported and denies the request for an unsupported version. The Cloud Composer portion of the image version is a full [semantic version](https://semver.org), or an alias in the form of major version number or &#x60;latest&#x60;. When an alias is provided, the server replaces it with the current Cloud Composer version that satisfies the alias. The Apache Airflow portion of the image version is a full semantic version that points to one of the supported Apache Airflow versions, or an alias in the form of only major or major.minor versions specified. When an alias is provided, the server replaces it with the latest Apache Airflow version that satisfies the alias and is supported in the given Cloud Composer version. In all cases, the resolved image version is stored in the same field. See also [version list](/composer/docs/concepts/versioning/composer-versions) and [versioning overview](/composer/docs/concepts/versioning/composer-versioning-overview).
   * @return imageVersion
   */
  @javax.annotation.Nullable
  public String getImageVersion() {
    return imageVersion;
  }

  public void setImageVersion(String imageVersion) {
    this.imageVersion = imageVersion;
  }


  public SoftwareConfig pypiPackages(Map<String, String> pypiPackages) {
    this.pypiPackages = pypiPackages;
    return this;
  }

  public SoftwareConfig putPypiPackagesItem(String key, String pypiPackagesItem) {
    if (this.pypiPackages == null) {
      this.pypiPackages = new HashMap<>();
    }
    this.pypiPackages.put(key, pypiPackagesItem);
    return this;
  }

  /**
   * Optional. Custom Python Package Index (PyPI) packages to be installed in the environment. Keys refer to the lowercase package name such as \&quot;numpy\&quot; and values are the lowercase extras and version specifier such as \&quot;&#x3D;&#x3D;1.12.0\&quot;, \&quot;[devel,gcp_api]\&quot;, or \&quot;[devel]&gt;&#x3D;1.8.2, &lt;1.9.2\&quot;. To specify a package without pinning it to a version specifier, use the empty string as the value.
   * @return pypiPackages
   */
  @javax.annotation.Nullable
  public Map<String, String> getPypiPackages() {
    return pypiPackages;
  }

  public void setPypiPackages(Map<String, String> pypiPackages) {
    this.pypiPackages = pypiPackages;
  }


  public SoftwareConfig pythonVersion(String pythonVersion) {
    this.pythonVersion = pythonVersion;
    return this;
  }

  /**
   * Optional. The major version of Python used to run the Apache Airflow scheduler, worker, and webserver processes. Can be set to &#39;2&#39; or &#39;3&#39;. If not specified, the default is &#39;3&#39;. Cannot be updated. This field is only supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*. Environments in newer versions always use Python major version 3.
   * @return pythonVersion
   */
  @javax.annotation.Nullable
  public String getPythonVersion() {
    return pythonVersion;
  }

  public void setPythonVersion(String pythonVersion) {
    this.pythonVersion = pythonVersion;
  }


  public SoftwareConfig schedulerCount(Integer schedulerCount) {
    this.schedulerCount = schedulerCount;
    return this;
  }

  /**
   * Optional. The number of schedulers for Airflow. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-2.*.*.
   * @return schedulerCount
   */
  @javax.annotation.Nullable
  public Integer getSchedulerCount() {
    return schedulerCount;
  }

  public void setSchedulerCount(Integer schedulerCount) {
    this.schedulerCount = schedulerCount;
  }


  public SoftwareConfig webServerPluginsMode(WebServerPluginsModeEnum webServerPluginsMode) {
    this.webServerPluginsMode = webServerPluginsMode;
    return this;
  }

  /**
   * Optional. Whether or not the web server uses custom plugins. If unspecified, the field defaults to &#x60;PLUGINS_ENABLED&#x60;. This field is supported for Cloud Composer environments in versions composer-3.*.*-airflow-*.*.* and newer.
   * @return webServerPluginsMode
   */
  @javax.annotation.Nullable
  public WebServerPluginsModeEnum getWebServerPluginsMode() {
    return webServerPluginsMode;
  }

  public void setWebServerPluginsMode(WebServerPluginsModeEnum webServerPluginsMode) {
    this.webServerPluginsMode = webServerPluginsMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SoftwareConfig softwareConfig = (SoftwareConfig) o;
    return Objects.equals(this.airflowConfigOverrides, softwareConfig.airflowConfigOverrides) &&
        Objects.equals(this.cloudDataLineageIntegration, softwareConfig.cloudDataLineageIntegration) &&
        Objects.equals(this.envVariables, softwareConfig.envVariables) &&
        Objects.equals(this.imageVersion, softwareConfig.imageVersion) &&
        Objects.equals(this.pypiPackages, softwareConfig.pypiPackages) &&
        Objects.equals(this.pythonVersion, softwareConfig.pythonVersion) &&
        Objects.equals(this.schedulerCount, softwareConfig.schedulerCount) &&
        Objects.equals(this.webServerPluginsMode, softwareConfig.webServerPluginsMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(airflowConfigOverrides, cloudDataLineageIntegration, envVariables, imageVersion, pypiPackages, pythonVersion, schedulerCount, webServerPluginsMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SoftwareConfig {\n");
    sb.append("    airflowConfigOverrides: ").append(toIndentedString(airflowConfigOverrides)).append("\n");
    sb.append("    cloudDataLineageIntegration: ").append(toIndentedString(cloudDataLineageIntegration)).append("\n");
    sb.append("    envVariables: ").append(toIndentedString(envVariables)).append("\n");
    sb.append("    imageVersion: ").append(toIndentedString(imageVersion)).append("\n");
    sb.append("    pypiPackages: ").append(toIndentedString(pypiPackages)).append("\n");
    sb.append("    pythonVersion: ").append(toIndentedString(pythonVersion)).append("\n");
    sb.append("    schedulerCount: ").append(toIndentedString(schedulerCount)).append("\n");
    sb.append("    webServerPluginsMode: ").append(toIndentedString(webServerPluginsMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("airflowConfigOverrides");
    openapiFields.add("cloudDataLineageIntegration");
    openapiFields.add("envVariables");
    openapiFields.add("imageVersion");
    openapiFields.add("pypiPackages");
    openapiFields.add("pythonVersion");
    openapiFields.add("schedulerCount");
    openapiFields.add("webServerPluginsMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SoftwareConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SoftwareConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SoftwareConfig is not found in the empty JSON string", SoftwareConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SoftwareConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SoftwareConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `cloudDataLineageIntegration`
      if (jsonObj.get("cloudDataLineageIntegration") != null && !jsonObj.get("cloudDataLineageIntegration").isJsonNull()) {
        CloudDataLineageIntegration.validateJsonElement(jsonObj.get("cloudDataLineageIntegration"));
      }
      if ((jsonObj.get("imageVersion") != null && !jsonObj.get("imageVersion").isJsonNull()) && !jsonObj.get("imageVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageVersion").toString()));
      }
      if ((jsonObj.get("pythonVersion") != null && !jsonObj.get("pythonVersion").isJsonNull()) && !jsonObj.get("pythonVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pythonVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pythonVersion").toString()));
      }
      if ((jsonObj.get("webServerPluginsMode") != null && !jsonObj.get("webServerPluginsMode").isJsonNull()) && !jsonObj.get("webServerPluginsMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webServerPluginsMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webServerPluginsMode").toString()));
      }
      // validate the optional field `webServerPluginsMode`
      if (jsonObj.get("webServerPluginsMode") != null && !jsonObj.get("webServerPluginsMode").isJsonNull()) {
        WebServerPluginsModeEnum.validateJsonElement(jsonObj.get("webServerPluginsMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SoftwareConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SoftwareConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SoftwareConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SoftwareConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<SoftwareConfig>() {
           @Override
           public void write(JsonWriter out, SoftwareConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SoftwareConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SoftwareConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SoftwareConfig
   * @throws IOException if the JSON string is invalid with respect to SoftwareConfig
   */
  public static SoftwareConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SoftwareConfig.class);
  }

  /**
   * Convert an instance of SoftwareConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

