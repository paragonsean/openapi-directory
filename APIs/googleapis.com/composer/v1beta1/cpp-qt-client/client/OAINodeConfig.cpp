/**
 * Cloud Composer API
 * Manages Apache Airflow environments on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINodeConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINodeConfig::OAINodeConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINodeConfig::OAINodeConfig() {
    this->initializeModel();
}

OAINodeConfig::~OAINodeConfig() {}

void OAINodeConfig::initializeModel() {

    m_composer_internal_ipv4_cidr_block_isSet = false;
    m_composer_internal_ipv4_cidr_block_isValid = false;

    m_composer_network_attachment_isSet = false;
    m_composer_network_attachment_isValid = false;

    m_disk_size_gb_isSet = false;
    m_disk_size_gb_isValid = false;

    m_enable_ip_masq_agent_isSet = false;
    m_enable_ip_masq_agent_isValid = false;

    m_ip_allocation_policy_isSet = false;
    m_ip_allocation_policy_isValid = false;

    m_location_isSet = false;
    m_location_isValid = false;

    m_machine_type_isSet = false;
    m_machine_type_isValid = false;

    m_max_pods_per_node_isSet = false;
    m_max_pods_per_node_isValid = false;

    m_network_isSet = false;
    m_network_isValid = false;

    m_oauth_scopes_isSet = false;
    m_oauth_scopes_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_subnetwork_isSet = false;
    m_subnetwork_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAINodeConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINodeConfig::fromJsonObject(QJsonObject json) {

    m_composer_internal_ipv4_cidr_block_isValid = ::OpenAPI::fromJsonValue(m_composer_internal_ipv4_cidr_block, json[QString("composerInternalIpv4CidrBlock")]);
    m_composer_internal_ipv4_cidr_block_isSet = !json[QString("composerInternalIpv4CidrBlock")].isNull() && m_composer_internal_ipv4_cidr_block_isValid;

    m_composer_network_attachment_isValid = ::OpenAPI::fromJsonValue(m_composer_network_attachment, json[QString("composerNetworkAttachment")]);
    m_composer_network_attachment_isSet = !json[QString("composerNetworkAttachment")].isNull() && m_composer_network_attachment_isValid;

    m_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_disk_size_gb, json[QString("diskSizeGb")]);
    m_disk_size_gb_isSet = !json[QString("diskSizeGb")].isNull() && m_disk_size_gb_isValid;

    m_enable_ip_masq_agent_isValid = ::OpenAPI::fromJsonValue(m_enable_ip_masq_agent, json[QString("enableIpMasqAgent")]);
    m_enable_ip_masq_agent_isSet = !json[QString("enableIpMasqAgent")].isNull() && m_enable_ip_masq_agent_isValid;

    m_ip_allocation_policy_isValid = ::OpenAPI::fromJsonValue(m_ip_allocation_policy, json[QString("ipAllocationPolicy")]);
    m_ip_allocation_policy_isSet = !json[QString("ipAllocationPolicy")].isNull() && m_ip_allocation_policy_isValid;

    m_location_isValid = ::OpenAPI::fromJsonValue(m_location, json[QString("location")]);
    m_location_isSet = !json[QString("location")].isNull() && m_location_isValid;

    m_machine_type_isValid = ::OpenAPI::fromJsonValue(m_machine_type, json[QString("machineType")]);
    m_machine_type_isSet = !json[QString("machineType")].isNull() && m_machine_type_isValid;

    m_max_pods_per_node_isValid = ::OpenAPI::fromJsonValue(m_max_pods_per_node, json[QString("maxPodsPerNode")]);
    m_max_pods_per_node_isSet = !json[QString("maxPodsPerNode")].isNull() && m_max_pods_per_node_isValid;

    m_network_isValid = ::OpenAPI::fromJsonValue(m_network, json[QString("network")]);
    m_network_isSet = !json[QString("network")].isNull() && m_network_isValid;

    m_oauth_scopes_isValid = ::OpenAPI::fromJsonValue(m_oauth_scopes, json[QString("oauthScopes")]);
    m_oauth_scopes_isSet = !json[QString("oauthScopes")].isNull() && m_oauth_scopes_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_subnetwork_isValid = ::OpenAPI::fromJsonValue(m_subnetwork, json[QString("subnetwork")]);
    m_subnetwork_isSet = !json[QString("subnetwork")].isNull() && m_subnetwork_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;
}

QString OAINodeConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINodeConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_composer_internal_ipv4_cidr_block_isSet) {
        obj.insert(QString("composerInternalIpv4CidrBlock"), ::OpenAPI::toJsonValue(m_composer_internal_ipv4_cidr_block));
    }
    if (m_composer_network_attachment_isSet) {
        obj.insert(QString("composerNetworkAttachment"), ::OpenAPI::toJsonValue(m_composer_network_attachment));
    }
    if (m_disk_size_gb_isSet) {
        obj.insert(QString("diskSizeGb"), ::OpenAPI::toJsonValue(m_disk_size_gb));
    }
    if (m_enable_ip_masq_agent_isSet) {
        obj.insert(QString("enableIpMasqAgent"), ::OpenAPI::toJsonValue(m_enable_ip_masq_agent));
    }
    if (m_ip_allocation_policy.isSet()) {
        obj.insert(QString("ipAllocationPolicy"), ::OpenAPI::toJsonValue(m_ip_allocation_policy));
    }
    if (m_location_isSet) {
        obj.insert(QString("location"), ::OpenAPI::toJsonValue(m_location));
    }
    if (m_machine_type_isSet) {
        obj.insert(QString("machineType"), ::OpenAPI::toJsonValue(m_machine_type));
    }
    if (m_max_pods_per_node_isSet) {
        obj.insert(QString("maxPodsPerNode"), ::OpenAPI::toJsonValue(m_max_pods_per_node));
    }
    if (m_network_isSet) {
        obj.insert(QString("network"), ::OpenAPI::toJsonValue(m_network));
    }
    if (m_oauth_scopes.size() > 0) {
        obj.insert(QString("oauthScopes"), ::OpenAPI::toJsonValue(m_oauth_scopes));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_subnetwork_isSet) {
        obj.insert(QString("subnetwork"), ::OpenAPI::toJsonValue(m_subnetwork));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

QString OAINodeConfig::getComposerInternalIpv4CidrBlock() const {
    return m_composer_internal_ipv4_cidr_block;
}
void OAINodeConfig::setComposerInternalIpv4CidrBlock(const QString &composer_internal_ipv4_cidr_block) {
    m_composer_internal_ipv4_cidr_block = composer_internal_ipv4_cidr_block;
    m_composer_internal_ipv4_cidr_block_isSet = true;
}

bool OAINodeConfig::is_composer_internal_ipv4_cidr_block_Set() const{
    return m_composer_internal_ipv4_cidr_block_isSet;
}

bool OAINodeConfig::is_composer_internal_ipv4_cidr_block_Valid() const{
    return m_composer_internal_ipv4_cidr_block_isValid;
}

QString OAINodeConfig::getComposerNetworkAttachment() const {
    return m_composer_network_attachment;
}
void OAINodeConfig::setComposerNetworkAttachment(const QString &composer_network_attachment) {
    m_composer_network_attachment = composer_network_attachment;
    m_composer_network_attachment_isSet = true;
}

bool OAINodeConfig::is_composer_network_attachment_Set() const{
    return m_composer_network_attachment_isSet;
}

bool OAINodeConfig::is_composer_network_attachment_Valid() const{
    return m_composer_network_attachment_isValid;
}

qint32 OAINodeConfig::getDiskSizeGb() const {
    return m_disk_size_gb;
}
void OAINodeConfig::setDiskSizeGb(const qint32 &disk_size_gb) {
    m_disk_size_gb = disk_size_gb;
    m_disk_size_gb_isSet = true;
}

bool OAINodeConfig::is_disk_size_gb_Set() const{
    return m_disk_size_gb_isSet;
}

bool OAINodeConfig::is_disk_size_gb_Valid() const{
    return m_disk_size_gb_isValid;
}

bool OAINodeConfig::isEnableIpMasqAgent() const {
    return m_enable_ip_masq_agent;
}
void OAINodeConfig::setEnableIpMasqAgent(const bool &enable_ip_masq_agent) {
    m_enable_ip_masq_agent = enable_ip_masq_agent;
    m_enable_ip_masq_agent_isSet = true;
}

bool OAINodeConfig::is_enable_ip_masq_agent_Set() const{
    return m_enable_ip_masq_agent_isSet;
}

bool OAINodeConfig::is_enable_ip_masq_agent_Valid() const{
    return m_enable_ip_masq_agent_isValid;
}

OAIIPAllocationPolicy OAINodeConfig::getIpAllocationPolicy() const {
    return m_ip_allocation_policy;
}
void OAINodeConfig::setIpAllocationPolicy(const OAIIPAllocationPolicy &ip_allocation_policy) {
    m_ip_allocation_policy = ip_allocation_policy;
    m_ip_allocation_policy_isSet = true;
}

bool OAINodeConfig::is_ip_allocation_policy_Set() const{
    return m_ip_allocation_policy_isSet;
}

bool OAINodeConfig::is_ip_allocation_policy_Valid() const{
    return m_ip_allocation_policy_isValid;
}

QString OAINodeConfig::getLocation() const {
    return m_location;
}
void OAINodeConfig::setLocation(const QString &location) {
    m_location = location;
    m_location_isSet = true;
}

bool OAINodeConfig::is_location_Set() const{
    return m_location_isSet;
}

bool OAINodeConfig::is_location_Valid() const{
    return m_location_isValid;
}

QString OAINodeConfig::getMachineType() const {
    return m_machine_type;
}
void OAINodeConfig::setMachineType(const QString &machine_type) {
    m_machine_type = machine_type;
    m_machine_type_isSet = true;
}

bool OAINodeConfig::is_machine_type_Set() const{
    return m_machine_type_isSet;
}

bool OAINodeConfig::is_machine_type_Valid() const{
    return m_machine_type_isValid;
}

qint32 OAINodeConfig::getMaxPodsPerNode() const {
    return m_max_pods_per_node;
}
void OAINodeConfig::setMaxPodsPerNode(const qint32 &max_pods_per_node) {
    m_max_pods_per_node = max_pods_per_node;
    m_max_pods_per_node_isSet = true;
}

bool OAINodeConfig::is_max_pods_per_node_Set() const{
    return m_max_pods_per_node_isSet;
}

bool OAINodeConfig::is_max_pods_per_node_Valid() const{
    return m_max_pods_per_node_isValid;
}

QString OAINodeConfig::getNetwork() const {
    return m_network;
}
void OAINodeConfig::setNetwork(const QString &network) {
    m_network = network;
    m_network_isSet = true;
}

bool OAINodeConfig::is_network_Set() const{
    return m_network_isSet;
}

bool OAINodeConfig::is_network_Valid() const{
    return m_network_isValid;
}

QList<QString> OAINodeConfig::getOauthScopes() const {
    return m_oauth_scopes;
}
void OAINodeConfig::setOauthScopes(const QList<QString> &oauth_scopes) {
    m_oauth_scopes = oauth_scopes;
    m_oauth_scopes_isSet = true;
}

bool OAINodeConfig::is_oauth_scopes_Set() const{
    return m_oauth_scopes_isSet;
}

bool OAINodeConfig::is_oauth_scopes_Valid() const{
    return m_oauth_scopes_isValid;
}

QString OAINodeConfig::getServiceAccount() const {
    return m_service_account;
}
void OAINodeConfig::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAINodeConfig::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAINodeConfig::is_service_account_Valid() const{
    return m_service_account_isValid;
}

QString OAINodeConfig::getSubnetwork() const {
    return m_subnetwork;
}
void OAINodeConfig::setSubnetwork(const QString &subnetwork) {
    m_subnetwork = subnetwork;
    m_subnetwork_isSet = true;
}

bool OAINodeConfig::is_subnetwork_Set() const{
    return m_subnetwork_isSet;
}

bool OAINodeConfig::is_subnetwork_Valid() const{
    return m_subnetwork_isValid;
}

QList<QString> OAINodeConfig::getTags() const {
    return m_tags;
}
void OAINodeConfig::setTags(const QList<QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAINodeConfig::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAINodeConfig::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAINodeConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_composer_internal_ipv4_cidr_block_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_composer_network_attachment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_ip_masq_agent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_allocation_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_location_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_machine_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_pods_per_node_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_oauth_scopes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subnetwork_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINodeConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
