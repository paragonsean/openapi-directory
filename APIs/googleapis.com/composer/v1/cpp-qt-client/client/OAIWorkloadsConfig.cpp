/**
 * Cloud Composer API
 * Manages Apache Airflow environments on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIWorkloadsConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIWorkloadsConfig::OAIWorkloadsConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIWorkloadsConfig::OAIWorkloadsConfig() {
    this->initializeModel();
}

OAIWorkloadsConfig::~OAIWorkloadsConfig() {}

void OAIWorkloadsConfig::initializeModel() {

    m_dag_processor_isSet = false;
    m_dag_processor_isValid = false;

    m_scheduler_isSet = false;
    m_scheduler_isValid = false;

    m_triggerer_isSet = false;
    m_triggerer_isValid = false;

    m_web_server_isSet = false;
    m_web_server_isValid = false;

    m_worker_isSet = false;
    m_worker_isValid = false;
}

void OAIWorkloadsConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIWorkloadsConfig::fromJsonObject(QJsonObject json) {

    m_dag_processor_isValid = ::OpenAPI::fromJsonValue(m_dag_processor, json[QString("dagProcessor")]);
    m_dag_processor_isSet = !json[QString("dagProcessor")].isNull() && m_dag_processor_isValid;

    m_scheduler_isValid = ::OpenAPI::fromJsonValue(m_scheduler, json[QString("scheduler")]);
    m_scheduler_isSet = !json[QString("scheduler")].isNull() && m_scheduler_isValid;

    m_triggerer_isValid = ::OpenAPI::fromJsonValue(m_triggerer, json[QString("triggerer")]);
    m_triggerer_isSet = !json[QString("triggerer")].isNull() && m_triggerer_isValid;

    m_web_server_isValid = ::OpenAPI::fromJsonValue(m_web_server, json[QString("webServer")]);
    m_web_server_isSet = !json[QString("webServer")].isNull() && m_web_server_isValid;

    m_worker_isValid = ::OpenAPI::fromJsonValue(m_worker, json[QString("worker")]);
    m_worker_isSet = !json[QString("worker")].isNull() && m_worker_isValid;
}

QString OAIWorkloadsConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIWorkloadsConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_dag_processor.isSet()) {
        obj.insert(QString("dagProcessor"), ::OpenAPI::toJsonValue(m_dag_processor));
    }
    if (m_scheduler.isSet()) {
        obj.insert(QString("scheduler"), ::OpenAPI::toJsonValue(m_scheduler));
    }
    if (m_triggerer.isSet()) {
        obj.insert(QString("triggerer"), ::OpenAPI::toJsonValue(m_triggerer));
    }
    if (m_web_server.isSet()) {
        obj.insert(QString("webServer"), ::OpenAPI::toJsonValue(m_web_server));
    }
    if (m_worker.isSet()) {
        obj.insert(QString("worker"), ::OpenAPI::toJsonValue(m_worker));
    }
    return obj;
}

OAIDagProcessorResource OAIWorkloadsConfig::getDagProcessor() const {
    return m_dag_processor;
}
void OAIWorkloadsConfig::setDagProcessor(const OAIDagProcessorResource &dag_processor) {
    m_dag_processor = dag_processor;
    m_dag_processor_isSet = true;
}

bool OAIWorkloadsConfig::is_dag_processor_Set() const{
    return m_dag_processor_isSet;
}

bool OAIWorkloadsConfig::is_dag_processor_Valid() const{
    return m_dag_processor_isValid;
}

OAISchedulerResource OAIWorkloadsConfig::getScheduler() const {
    return m_scheduler;
}
void OAIWorkloadsConfig::setScheduler(const OAISchedulerResource &scheduler) {
    m_scheduler = scheduler;
    m_scheduler_isSet = true;
}

bool OAIWorkloadsConfig::is_scheduler_Set() const{
    return m_scheduler_isSet;
}

bool OAIWorkloadsConfig::is_scheduler_Valid() const{
    return m_scheduler_isValid;
}

OAITriggererResource OAIWorkloadsConfig::getTriggerer() const {
    return m_triggerer;
}
void OAIWorkloadsConfig::setTriggerer(const OAITriggererResource &triggerer) {
    m_triggerer = triggerer;
    m_triggerer_isSet = true;
}

bool OAIWorkloadsConfig::is_triggerer_Set() const{
    return m_triggerer_isSet;
}

bool OAIWorkloadsConfig::is_triggerer_Valid() const{
    return m_triggerer_isValid;
}

OAIWebServerResource OAIWorkloadsConfig::getWebServer() const {
    return m_web_server;
}
void OAIWorkloadsConfig::setWebServer(const OAIWebServerResource &web_server) {
    m_web_server = web_server;
    m_web_server_isSet = true;
}

bool OAIWorkloadsConfig::is_web_server_Set() const{
    return m_web_server_isSet;
}

bool OAIWorkloadsConfig::is_web_server_Valid() const{
    return m_web_server_isValid;
}

OAIWorkerResource OAIWorkloadsConfig::getWorker() const {
    return m_worker;
}
void OAIWorkloadsConfig::setWorker(const OAIWorkerResource &worker) {
    m_worker = worker;
    m_worker_isSet = true;
}

bool OAIWorkloadsConfig::is_worker_Set() const{
    return m_worker_isSet;
}

bool OAIWorkloadsConfig::is_worker_Valid() const{
    return m_worker_isValid;
}

bool OAIWorkloadsConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_dag_processor.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduler.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_triggerer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_web_server.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_worker.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIWorkloadsConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
