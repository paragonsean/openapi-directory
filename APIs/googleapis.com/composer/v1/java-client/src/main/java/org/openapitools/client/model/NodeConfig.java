/*
 * Cloud Composer API
 * Manages Apache Airflow environments on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IPAllocationPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The configuration information for the Kubernetes Engine nodes running the Apache Airflow software.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:43.595125-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NodeConfig {
  public static final String SERIALIZED_NAME_COMPOSER_INTERNAL_IPV4_CIDR_BLOCK = "composerInternalIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_COMPOSER_INTERNAL_IPV4_CIDR_BLOCK)
  private String composerInternalIpv4CidrBlock;

  public static final String SERIALIZED_NAME_COMPOSER_NETWORK_ATTACHMENT = "composerNetworkAttachment";
  @SerializedName(SERIALIZED_NAME_COMPOSER_NETWORK_ATTACHMENT)
  private String composerNetworkAttachment;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_ENABLE_IP_MASQ_AGENT = "enableIpMasqAgent";
  @SerializedName(SERIALIZED_NAME_ENABLE_IP_MASQ_AGENT)
  private Boolean enableIpMasqAgent;

  public static final String SERIALIZED_NAME_IP_ALLOCATION_POLICY = "ipAllocationPolicy";
  @SerializedName(SERIALIZED_NAME_IP_ALLOCATION_POLICY)
  private IPAllocationPolicy ipAllocationPolicy;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_OAUTH_SCOPES = "oauthScopes";
  @SerializedName(SERIALIZED_NAME_OAUTH_SCOPES)
  private List<String> oauthScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public NodeConfig() {
  }

  public NodeConfig composerInternalIpv4CidrBlock(String composerInternalIpv4CidrBlock) {
    this.composerInternalIpv4CidrBlock = composerInternalIpv4CidrBlock;
    return this;
  }

  /**
   * Optional. The IP range in CIDR notation to use internally by Cloud Composer. IP addresses are not reserved - and the same range can be used by multiple Cloud Composer environments. In case of overlap, IPs from this range will not be accessible in the user&#39;s VPC network. Cannot be updated. If not specified, the default value of &#39;100.64.128.0/20&#39; is used. This field is supported for Cloud Composer environments in versions composer-3.*.*-airflow-*.*.* and newer.
   * @return composerInternalIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getComposerInternalIpv4CidrBlock() {
    return composerInternalIpv4CidrBlock;
  }

  public void setComposerInternalIpv4CidrBlock(String composerInternalIpv4CidrBlock) {
    this.composerInternalIpv4CidrBlock = composerInternalIpv4CidrBlock;
  }


  public NodeConfig composerNetworkAttachment(String composerNetworkAttachment) {
    this.composerNetworkAttachment = composerNetworkAttachment;
    return this;
  }

  /**
   * Optional. Network Attachment that Cloud Composer environment is connected to, which provides connectivity with a user&#39;s VPC network. Takes precedence over network and subnetwork settings. If not provided, but network and subnetwork are defined during environment, it will be provisioned. If not provided and network and subnetwork are also empty, then connectivity to user&#39;s VPC network is disabled. Network attachment must be provided in format projects/{project}/regions/{region}/networkAttachments/{networkAttachment}. This field is supported for Cloud Composer environments in versions composer-3.*.*-airflow-*.*.* and newer.
   * @return composerNetworkAttachment
   */
  @javax.annotation.Nullable
  public String getComposerNetworkAttachment() {
    return composerNetworkAttachment;
  }

  public void setComposerNetworkAttachment(String composerNetworkAttachment) {
    this.composerNetworkAttachment = composerNetworkAttachment;
  }


  public NodeConfig diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Optional. The disk size in GB used for node VMs. Minimum size is 30GB. If unspecified, defaults to 100GB. Cannot be updated. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public NodeConfig enableIpMasqAgent(Boolean enableIpMasqAgent) {
    this.enableIpMasqAgent = enableIpMasqAgent;
    return this;
  }

  /**
   * Optional. Deploys &#39;ip-masq-agent&#39; daemon set in the GKE cluster and defines nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for all destination addresses, except between pods traffic. See: https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent
   * @return enableIpMasqAgent
   */
  @javax.annotation.Nullable
  public Boolean getEnableIpMasqAgent() {
    return enableIpMasqAgent;
  }

  public void setEnableIpMasqAgent(Boolean enableIpMasqAgent) {
    this.enableIpMasqAgent = enableIpMasqAgent;
  }


  public NodeConfig ipAllocationPolicy(IPAllocationPolicy ipAllocationPolicy) {
    this.ipAllocationPolicy = ipAllocationPolicy;
    return this;
  }

  /**
   * Get ipAllocationPolicy
   * @return ipAllocationPolicy
   */
  @javax.annotation.Nullable
  public IPAllocationPolicy getIpAllocationPolicy() {
    return ipAllocationPolicy;
  }

  public void setIpAllocationPolicy(IPAllocationPolicy ipAllocationPolicy) {
    this.ipAllocationPolicy = ipAllocationPolicy;
  }


  public NodeConfig location(String location) {
    this.location = location;
    return this;
  }

  /**
   * Optional. The Compute Engine [zone](/compute/docs/regions-zones) in which to deploy the VMs used to run the Apache Airflow software, specified as a [relative resource name](/apis/design/resource_names#relative_resource_name). For example: \&quot;projects/{projectId}/zones/{zoneId}\&quot;. This &#x60;location&#x60; must belong to the enclosing environment&#39;s project and location. If both this field and &#x60;nodeConfig.machineType&#x60; are specified, &#x60;nodeConfig.machineType&#x60; must belong to this &#x60;location&#x60;; if both are unspecified, the service will pick a zone in the Compute Engine region corresponding to the Cloud Composer location, and propagate that choice to both fields. If only one field (&#x60;location&#x60; or &#x60;nodeConfig.machineType&#x60;) is specified, the location information from the specified field will be propagated to the unspecified field. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public NodeConfig machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Optional. The Compute Engine [machine type](/compute/docs/machine-types) used for cluster instances, specified as a [relative resource name](/apis/design/resource_names#relative_resource_name). For example: \&quot;projects/{projectId}/zones/{zoneId}/machineTypes/{machineTypeId}\&quot;. The &#x60;machineType&#x60; must belong to the enclosing environment&#39;s project and location. If both this field and &#x60;nodeConfig.location&#x60; are specified, this &#x60;machineType&#x60; must belong to the &#x60;nodeConfig.location&#x60;; if both are unspecified, the service will pick a zone in the Compute Engine region corresponding to the Cloud Composer location, and propagate that choice to both fields. If exactly one of this field and &#x60;nodeConfig.location&#x60; is specified, the location information from the specified field will be propagated to the unspecified field. The &#x60;machineTypeId&#x60; must not be a [shared-core machine type](/compute/docs/machine-types#sharedcore). If this field is unspecified, the &#x60;machineTypeId&#x60; defaults to \&quot;n1-standard-1\&quot;. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public NodeConfig network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Optional. The Compute Engine network to be used for machine communications, specified as a [relative resource name](/apis/design/resource_names#relative_resource_name). For example: \&quot;projects/{projectId}/global/networks/{networkId}\&quot;. If unspecified, the \&quot;default\&quot; network ID in the environment&#39;s project is used. If a [Custom Subnet Network](/vpc/docs/vpc#vpc_networks_and_subnets) is provided, &#x60;nodeConfig.subnetwork&#x60; must also be provided. For [Shared VPC](/vpc/docs/shared-vpc) subnetwork requirements, see &#x60;nodeConfig.subnetwork&#x60;.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public NodeConfig oauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
    return this;
  }

  public NodeConfig addOauthScopesItem(String oauthScopesItem) {
    if (this.oauthScopes == null) {
      this.oauthScopes = new ArrayList<>();
    }
    this.oauthScopes.add(oauthScopesItem);
    return this;
  }

  /**
   * Optional. The set of Google API scopes to be made available on all node VMs. If &#x60;oauth_scopes&#x60; is empty, defaults to [\&quot;https://www.googleapis.com/auth/cloud-platform\&quot;]. Cannot be updated. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
   * @return oauthScopes
   */
  @javax.annotation.Nullable
  public List<String> getOauthScopes() {
    return oauthScopes;
  }

  public void setOauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
  }


  public NodeConfig serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * Optional. The Google Cloud Platform Service Account to be used by the node VMs. If a service account is not specified, the \&quot;default\&quot; Compute Engine service account is used. Cannot be updated.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public NodeConfig subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Optional. The Compute Engine subnetwork to be used for machine communications, specified as a [relative resource name](/apis/design/resource_names#relative_resource_name). For example: \&quot;projects/{projectId}/regions/{regionId}/subnetworks/{subnetworkId}\&quot; If a subnetwork is provided, &#x60;nodeConfig.network&#x60; must also be provided, and the subnetwork must belong to the enclosing environment&#39;s project and location.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  public NodeConfig tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public NodeConfig addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Optional. The list of instance tags applied to all node VMs. Tags are used to identify valid sources or targets for network firewalls. Each tag within the list must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Cannot be updated.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodeConfig nodeConfig = (NodeConfig) o;
    return Objects.equals(this.composerInternalIpv4CidrBlock, nodeConfig.composerInternalIpv4CidrBlock) &&
        Objects.equals(this.composerNetworkAttachment, nodeConfig.composerNetworkAttachment) &&
        Objects.equals(this.diskSizeGb, nodeConfig.diskSizeGb) &&
        Objects.equals(this.enableIpMasqAgent, nodeConfig.enableIpMasqAgent) &&
        Objects.equals(this.ipAllocationPolicy, nodeConfig.ipAllocationPolicy) &&
        Objects.equals(this.location, nodeConfig.location) &&
        Objects.equals(this.machineType, nodeConfig.machineType) &&
        Objects.equals(this.network, nodeConfig.network) &&
        Objects.equals(this.oauthScopes, nodeConfig.oauthScopes) &&
        Objects.equals(this.serviceAccount, nodeConfig.serviceAccount) &&
        Objects.equals(this.subnetwork, nodeConfig.subnetwork) &&
        Objects.equals(this.tags, nodeConfig.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(composerInternalIpv4CidrBlock, composerNetworkAttachment, diskSizeGb, enableIpMasqAgent, ipAllocationPolicy, location, machineType, network, oauthScopes, serviceAccount, subnetwork, tags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodeConfig {\n");
    sb.append("    composerInternalIpv4CidrBlock: ").append(toIndentedString(composerInternalIpv4CidrBlock)).append("\n");
    sb.append("    composerNetworkAttachment: ").append(toIndentedString(composerNetworkAttachment)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    enableIpMasqAgent: ").append(toIndentedString(enableIpMasqAgent)).append("\n");
    sb.append("    ipAllocationPolicy: ").append(toIndentedString(ipAllocationPolicy)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    oauthScopes: ").append(toIndentedString(oauthScopes)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("composerInternalIpv4CidrBlock");
    openapiFields.add("composerNetworkAttachment");
    openapiFields.add("diskSizeGb");
    openapiFields.add("enableIpMasqAgent");
    openapiFields.add("ipAllocationPolicy");
    openapiFields.add("location");
    openapiFields.add("machineType");
    openapiFields.add("network");
    openapiFields.add("oauthScopes");
    openapiFields.add("serviceAccount");
    openapiFields.add("subnetwork");
    openapiFields.add("tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NodeConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodeConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodeConfig is not found in the empty JSON string", NodeConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodeConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodeConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("composerInternalIpv4CidrBlock") != null && !jsonObj.get("composerInternalIpv4CidrBlock").isJsonNull()) && !jsonObj.get("composerInternalIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `composerInternalIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("composerInternalIpv4CidrBlock").toString()));
      }
      if ((jsonObj.get("composerNetworkAttachment") != null && !jsonObj.get("composerNetworkAttachment").isJsonNull()) && !jsonObj.get("composerNetworkAttachment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `composerNetworkAttachment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("composerNetworkAttachment").toString()));
      }
      // validate the optional field `ipAllocationPolicy`
      if (jsonObj.get("ipAllocationPolicy") != null && !jsonObj.get("ipAllocationPolicy").isJsonNull()) {
        IPAllocationPolicy.validateJsonElement(jsonObj.get("ipAllocationPolicy"));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("oauthScopes") != null && !jsonObj.get("oauthScopes").isJsonNull() && !jsonObj.get("oauthScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthScopes` to be an array in the JSON string but got `%s`", jsonObj.get("oauthScopes").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodeConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodeConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodeConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodeConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<NodeConfig>() {
           @Override
           public void write(JsonWriter out, NodeConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodeConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NodeConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NodeConfig
   * @throws IOException if the JSON string is invalid with respect to NodeConfig
   */
  public static NodeConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodeConfig.class);
  }

  /**
   * Convert an instance of NodeConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

