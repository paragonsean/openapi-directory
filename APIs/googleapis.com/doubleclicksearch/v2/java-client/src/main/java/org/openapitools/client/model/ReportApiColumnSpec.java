/*
 * Search Ads 360 API
 * The Search Ads 360 API allows developers to automate uploading conversions and downloading reports from Search Ads 360.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A request object used to create a DoubleClick Search report.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:25.520985-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReportApiColumnSpec {
  public static final String SERIALIZED_NAME_COLUMN_NAME = "columnName";
  @SerializedName(SERIALIZED_NAME_COLUMN_NAME)
  private String columnName;

  public static final String SERIALIZED_NAME_CUSTOM_DIMENSION_NAME = "customDimensionName";
  @SerializedName(SERIALIZED_NAME_CUSTOM_DIMENSION_NAME)
  private String customDimensionName;

  public static final String SERIALIZED_NAME_CUSTOM_METRIC_NAME = "customMetricName";
  @SerializedName(SERIALIZED_NAME_CUSTOM_METRIC_NAME)
  private String customMetricName;

  public static final String SERIALIZED_NAME_END_DATE = "endDate";
  @SerializedName(SERIALIZED_NAME_END_DATE)
  private String endDate;

  public static final String SERIALIZED_NAME_GROUP_BY_COLUMN = "groupByColumn";
  @SerializedName(SERIALIZED_NAME_GROUP_BY_COLUMN)
  private Boolean groupByColumn;

  public static final String SERIALIZED_NAME_HEADER_TEXT = "headerText";
  @SerializedName(SERIALIZED_NAME_HEADER_TEXT)
  private String headerText;

  public static final String SERIALIZED_NAME_PLATFORM_SOURCE = "platformSource";
  @SerializedName(SERIALIZED_NAME_PLATFORM_SOURCE)
  private String platformSource;

  public static final String SERIALIZED_NAME_PRODUCT_REPORT_PERSPECTIVE = "productReportPerspective";
  @SerializedName(SERIALIZED_NAME_PRODUCT_REPORT_PERSPECTIVE)
  private String productReportPerspective;

  public static final String SERIALIZED_NAME_SAVED_COLUMN_NAME = "savedColumnName";
  @SerializedName(SERIALIZED_NAME_SAVED_COLUMN_NAME)
  private String savedColumnName;

  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private String startDate;

  public ReportApiColumnSpec() {
  }

  public ReportApiColumnSpec columnName(String columnName) {
    this.columnName = columnName;
    return this;
  }

  /**
   * Name of a DoubleClick Search column to include in the report.
   * @return columnName
   */
  @javax.annotation.Nullable
  public String getColumnName() {
    return columnName;
  }

  public void setColumnName(String columnName) {
    this.columnName = columnName;
  }


  public ReportApiColumnSpec customDimensionName(String customDimensionName) {
    this.customDimensionName = customDimensionName;
    return this;
  }

  /**
   * Segments a report by a custom dimension. The report must be scoped to an advertiser or lower, and the custom dimension must already be set up in DoubleClick Search. The custom dimension name, which appears in DoubleClick Search, is case sensitive.\\ If used in a conversion report, returns the value of the specified custom dimension for the given conversion, if set. This column does not segment the conversion report.
   * @return customDimensionName
   */
  @javax.annotation.Nullable
  public String getCustomDimensionName() {
    return customDimensionName;
  }

  public void setCustomDimensionName(String customDimensionName) {
    this.customDimensionName = customDimensionName;
  }


  public ReportApiColumnSpec customMetricName(String customMetricName) {
    this.customMetricName = customMetricName;
    return this;
  }

  /**
   * Name of a custom metric to include in the report. The report must be scoped to an advertiser or lower, and the custom metric must already be set up in DoubleClick Search. The custom metric name, which appears in DoubleClick Search, is case sensitive.
   * @return customMetricName
   */
  @javax.annotation.Nullable
  public String getCustomMetricName() {
    return customMetricName;
  }

  public void setCustomMetricName(String customMetricName) {
    this.customMetricName = customMetricName;
  }


  public ReportApiColumnSpec endDate(String endDate) {
    this.endDate = endDate;
    return this;
  }

  /**
   * Inclusive day in YYYY-MM-DD format. When provided, this overrides the overall time range of the report for this column only. Must be provided together with &#x60;startDate&#x60;.
   * @return endDate
   */
  @javax.annotation.Nullable
  public String getEndDate() {
    return endDate;
  }

  public void setEndDate(String endDate) {
    this.endDate = endDate;
  }


  public ReportApiColumnSpec groupByColumn(Boolean groupByColumn) {
    this.groupByColumn = groupByColumn;
    return this;
  }

  /**
   * Synchronous report only. Set to &#x60;true&#x60; to group by this column. Defaults to &#x60;false&#x60;.
   * @return groupByColumn
   */
  @javax.annotation.Nullable
  public Boolean getGroupByColumn() {
    return groupByColumn;
  }

  public void setGroupByColumn(Boolean groupByColumn) {
    this.groupByColumn = groupByColumn;
  }


  public ReportApiColumnSpec headerText(String headerText) {
    this.headerText = headerText;
    return this;
  }

  /**
   * Text used to identify this column in the report output; defaults to &#x60;columnName&#x60; or &#x60;savedColumnName&#x60; when not specified. This can be used to prevent collisions between DoubleClick Search columns and saved columns with the same name.
   * @return headerText
   */
  @javax.annotation.Nullable
  public String getHeaderText() {
    return headerText;
  }

  public void setHeaderText(String headerText) {
    this.headerText = headerText;
  }


  public ReportApiColumnSpec platformSource(String platformSource) {
    this.platformSource = platformSource;
    return this;
  }

  /**
   * The platform that is used to provide data for the custom dimension. Acceptable values are \&quot;floodlight\&quot;.
   * @return platformSource
   */
  @javax.annotation.Nullable
  public String getPlatformSource() {
    return platformSource;
  }

  public void setPlatformSource(String platformSource) {
    this.platformSource = platformSource;
  }


  public ReportApiColumnSpec productReportPerspective(String productReportPerspective) {
    this.productReportPerspective = productReportPerspective;
    return this;
  }

  /**
   * Returns metrics only for a specific type of product activity. Accepted values are: - \&quot;&#x60;sold&#x60;\&quot;: returns metrics only for products that were sold - \&quot;&#x60;advertised&#x60;\&quot;: returns metrics only for products that were advertised in a Shopping campaign, and that might or might not have been sold 
   * @return productReportPerspective
   */
  @javax.annotation.Nullable
  public String getProductReportPerspective() {
    return productReportPerspective;
  }

  public void setProductReportPerspective(String productReportPerspective) {
    this.productReportPerspective = productReportPerspective;
  }


  public ReportApiColumnSpec savedColumnName(String savedColumnName) {
    this.savedColumnName = savedColumnName;
    return this;
  }

  /**
   * Name of a saved column to include in the report. The report must be scoped at advertiser or lower, and this saved column must already be created in the DoubleClick Search UI.
   * @return savedColumnName
   */
  @javax.annotation.Nullable
  public String getSavedColumnName() {
    return savedColumnName;
  }

  public void setSavedColumnName(String savedColumnName) {
    this.savedColumnName = savedColumnName;
  }


  public ReportApiColumnSpec startDate(String startDate) {
    this.startDate = startDate;
    return this;
  }

  /**
   * Inclusive date in YYYY-MM-DD format. When provided, this overrides the overall time range of the report for this column only. Must be provided together with &#x60;endDate&#x60;.
   * @return startDate
   */
  @javax.annotation.Nullable
  public String getStartDate() {
    return startDate;
  }

  public void setStartDate(String startDate) {
    this.startDate = startDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReportApiColumnSpec reportApiColumnSpec = (ReportApiColumnSpec) o;
    return Objects.equals(this.columnName, reportApiColumnSpec.columnName) &&
        Objects.equals(this.customDimensionName, reportApiColumnSpec.customDimensionName) &&
        Objects.equals(this.customMetricName, reportApiColumnSpec.customMetricName) &&
        Objects.equals(this.endDate, reportApiColumnSpec.endDate) &&
        Objects.equals(this.groupByColumn, reportApiColumnSpec.groupByColumn) &&
        Objects.equals(this.headerText, reportApiColumnSpec.headerText) &&
        Objects.equals(this.platformSource, reportApiColumnSpec.platformSource) &&
        Objects.equals(this.productReportPerspective, reportApiColumnSpec.productReportPerspective) &&
        Objects.equals(this.savedColumnName, reportApiColumnSpec.savedColumnName) &&
        Objects.equals(this.startDate, reportApiColumnSpec.startDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columnName, customDimensionName, customMetricName, endDate, groupByColumn, headerText, platformSource, productReportPerspective, savedColumnName, startDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReportApiColumnSpec {\n");
    sb.append("    columnName: ").append(toIndentedString(columnName)).append("\n");
    sb.append("    customDimensionName: ").append(toIndentedString(customDimensionName)).append("\n");
    sb.append("    customMetricName: ").append(toIndentedString(customMetricName)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    groupByColumn: ").append(toIndentedString(groupByColumn)).append("\n");
    sb.append("    headerText: ").append(toIndentedString(headerText)).append("\n");
    sb.append("    platformSource: ").append(toIndentedString(platformSource)).append("\n");
    sb.append("    productReportPerspective: ").append(toIndentedString(productReportPerspective)).append("\n");
    sb.append("    savedColumnName: ").append(toIndentedString(savedColumnName)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("columnName");
    openapiFields.add("customDimensionName");
    openapiFields.add("customMetricName");
    openapiFields.add("endDate");
    openapiFields.add("groupByColumn");
    openapiFields.add("headerText");
    openapiFields.add("platformSource");
    openapiFields.add("productReportPerspective");
    openapiFields.add("savedColumnName");
    openapiFields.add("startDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReportApiColumnSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReportApiColumnSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReportApiColumnSpec is not found in the empty JSON string", ReportApiColumnSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReportApiColumnSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReportApiColumnSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("columnName") != null && !jsonObj.get("columnName").isJsonNull()) && !jsonObj.get("columnName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `columnName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("columnName").toString()));
      }
      if ((jsonObj.get("customDimensionName") != null && !jsonObj.get("customDimensionName").isJsonNull()) && !jsonObj.get("customDimensionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customDimensionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customDimensionName").toString()));
      }
      if ((jsonObj.get("customMetricName") != null && !jsonObj.get("customMetricName").isJsonNull()) && !jsonObj.get("customMetricName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customMetricName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customMetricName").toString()));
      }
      if ((jsonObj.get("endDate") != null && !jsonObj.get("endDate").isJsonNull()) && !jsonObj.get("endDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endDate").toString()));
      }
      if ((jsonObj.get("headerText") != null && !jsonObj.get("headerText").isJsonNull()) && !jsonObj.get("headerText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `headerText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("headerText").toString()));
      }
      if ((jsonObj.get("platformSource") != null && !jsonObj.get("platformSource").isJsonNull()) && !jsonObj.get("platformSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `platformSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("platformSource").toString()));
      }
      if ((jsonObj.get("productReportPerspective") != null && !jsonObj.get("productReportPerspective").isJsonNull()) && !jsonObj.get("productReportPerspective").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productReportPerspective` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productReportPerspective").toString()));
      }
      if ((jsonObj.get("savedColumnName") != null && !jsonObj.get("savedColumnName").isJsonNull()) && !jsonObj.get("savedColumnName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `savedColumnName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("savedColumnName").toString()));
      }
      if ((jsonObj.get("startDate") != null && !jsonObj.get("startDate").isJsonNull()) && !jsonObj.get("startDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReportApiColumnSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReportApiColumnSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReportApiColumnSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReportApiColumnSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<ReportApiColumnSpec>() {
           @Override
           public void write(JsonWriter out, ReportApiColumnSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReportApiColumnSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReportApiColumnSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReportApiColumnSpec
   * @throws IOException if the JSON string is invalid with respect to ReportApiColumnSpec
   */
  public static ReportApiColumnSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReportApiColumnSpec.class);
  }

  /**
   * Convert an instance of ReportApiColumnSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

