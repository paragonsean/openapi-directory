/**
 * Cloud SQL Admin API
 * API for Cloud SQL database instance management
 *
 * The version of the OpenAPI document: v1beta4
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIImportContext_bakImportOptions.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIImportContext_bakImportOptions::OAIImportContext_bakImportOptions(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIImportContext_bakImportOptions::OAIImportContext_bakImportOptions() {
    this->initializeModel();
}

OAIImportContext_bakImportOptions::~OAIImportContext_bakImportOptions() {}

void OAIImportContext_bakImportOptions::initializeModel() {

    m_bak_type_isSet = false;
    m_bak_type_isValid = false;

    m_encryption_options_isSet = false;
    m_encryption_options_isValid = false;

    m_no_recovery_isSet = false;
    m_no_recovery_isValid = false;

    m_recovery_only_isSet = false;
    m_recovery_only_isValid = false;

    m_stop_at_isSet = false;
    m_stop_at_isValid = false;

    m_stop_at_mark_isSet = false;
    m_stop_at_mark_isValid = false;

    m_striped_isSet = false;
    m_striped_isValid = false;
}

void OAIImportContext_bakImportOptions::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIImportContext_bakImportOptions::fromJsonObject(QJsonObject json) {

    m_bak_type_isValid = ::OpenAPI::fromJsonValue(m_bak_type, json[QString("bakType")]);
    m_bak_type_isSet = !json[QString("bakType")].isNull() && m_bak_type_isValid;

    m_encryption_options_isValid = ::OpenAPI::fromJsonValue(m_encryption_options, json[QString("encryptionOptions")]);
    m_encryption_options_isSet = !json[QString("encryptionOptions")].isNull() && m_encryption_options_isValid;

    m_no_recovery_isValid = ::OpenAPI::fromJsonValue(m_no_recovery, json[QString("noRecovery")]);
    m_no_recovery_isSet = !json[QString("noRecovery")].isNull() && m_no_recovery_isValid;

    m_recovery_only_isValid = ::OpenAPI::fromJsonValue(m_recovery_only, json[QString("recoveryOnly")]);
    m_recovery_only_isSet = !json[QString("recoveryOnly")].isNull() && m_recovery_only_isValid;

    m_stop_at_isValid = ::OpenAPI::fromJsonValue(m_stop_at, json[QString("stopAt")]);
    m_stop_at_isSet = !json[QString("stopAt")].isNull() && m_stop_at_isValid;

    m_stop_at_mark_isValid = ::OpenAPI::fromJsonValue(m_stop_at_mark, json[QString("stopAtMark")]);
    m_stop_at_mark_isSet = !json[QString("stopAtMark")].isNull() && m_stop_at_mark_isValid;

    m_striped_isValid = ::OpenAPI::fromJsonValue(m_striped, json[QString("striped")]);
    m_striped_isSet = !json[QString("striped")].isNull() && m_striped_isValid;
}

QString OAIImportContext_bakImportOptions::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIImportContext_bakImportOptions::asJsonObject() const {
    QJsonObject obj;
    if (m_bak_type_isSet) {
        obj.insert(QString("bakType"), ::OpenAPI::toJsonValue(m_bak_type));
    }
    if (m_encryption_options.isSet()) {
        obj.insert(QString("encryptionOptions"), ::OpenAPI::toJsonValue(m_encryption_options));
    }
    if (m_no_recovery_isSet) {
        obj.insert(QString("noRecovery"), ::OpenAPI::toJsonValue(m_no_recovery));
    }
    if (m_recovery_only_isSet) {
        obj.insert(QString("recoveryOnly"), ::OpenAPI::toJsonValue(m_recovery_only));
    }
    if (m_stop_at_isSet) {
        obj.insert(QString("stopAt"), ::OpenAPI::toJsonValue(m_stop_at));
    }
    if (m_stop_at_mark_isSet) {
        obj.insert(QString("stopAtMark"), ::OpenAPI::toJsonValue(m_stop_at_mark));
    }
    if (m_striped_isSet) {
        obj.insert(QString("striped"), ::OpenAPI::toJsonValue(m_striped));
    }
    return obj;
}

QString OAIImportContext_bakImportOptions::getBakType() const {
    return m_bak_type;
}
void OAIImportContext_bakImportOptions::setBakType(const QString &bak_type) {
    m_bak_type = bak_type;
    m_bak_type_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_bak_type_Set() const{
    return m_bak_type_isSet;
}

bool OAIImportContext_bakImportOptions::is_bak_type_Valid() const{
    return m_bak_type_isValid;
}

OAIImportContext_bakImportOptions_encryptionOptions OAIImportContext_bakImportOptions::getEncryptionOptions() const {
    return m_encryption_options;
}
void OAIImportContext_bakImportOptions::setEncryptionOptions(const OAIImportContext_bakImportOptions_encryptionOptions &encryption_options) {
    m_encryption_options = encryption_options;
    m_encryption_options_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_encryption_options_Set() const{
    return m_encryption_options_isSet;
}

bool OAIImportContext_bakImportOptions::is_encryption_options_Valid() const{
    return m_encryption_options_isValid;
}

bool OAIImportContext_bakImportOptions::isNoRecovery() const {
    return m_no_recovery;
}
void OAIImportContext_bakImportOptions::setNoRecovery(const bool &no_recovery) {
    m_no_recovery = no_recovery;
    m_no_recovery_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_no_recovery_Set() const{
    return m_no_recovery_isSet;
}

bool OAIImportContext_bakImportOptions::is_no_recovery_Valid() const{
    return m_no_recovery_isValid;
}

bool OAIImportContext_bakImportOptions::isRecoveryOnly() const {
    return m_recovery_only;
}
void OAIImportContext_bakImportOptions::setRecoveryOnly(const bool &recovery_only) {
    m_recovery_only = recovery_only;
    m_recovery_only_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_recovery_only_Set() const{
    return m_recovery_only_isSet;
}

bool OAIImportContext_bakImportOptions::is_recovery_only_Valid() const{
    return m_recovery_only_isValid;
}

QString OAIImportContext_bakImportOptions::getStopAt() const {
    return m_stop_at;
}
void OAIImportContext_bakImportOptions::setStopAt(const QString &stop_at) {
    m_stop_at = stop_at;
    m_stop_at_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_stop_at_Set() const{
    return m_stop_at_isSet;
}

bool OAIImportContext_bakImportOptions::is_stop_at_Valid() const{
    return m_stop_at_isValid;
}

QString OAIImportContext_bakImportOptions::getStopAtMark() const {
    return m_stop_at_mark;
}
void OAIImportContext_bakImportOptions::setStopAtMark(const QString &stop_at_mark) {
    m_stop_at_mark = stop_at_mark;
    m_stop_at_mark_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_stop_at_mark_Set() const{
    return m_stop_at_mark_isSet;
}

bool OAIImportContext_bakImportOptions::is_stop_at_mark_Valid() const{
    return m_stop_at_mark_isValid;
}

bool OAIImportContext_bakImportOptions::isStriped() const {
    return m_striped;
}
void OAIImportContext_bakImportOptions::setStriped(const bool &striped) {
    m_striped = striped;
    m_striped_isSet = true;
}

bool OAIImportContext_bakImportOptions::is_striped_Set() const{
    return m_striped_isSet;
}

bool OAIImportContext_bakImportOptions::is_striped_Valid() const{
    return m_striped_isValid;
}

bool OAIImportContext_bakImportOptions::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bak_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_options.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_no_recovery_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recovery_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stop_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stop_at_mark_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_striped_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIImportContext_bakImportOptions::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
