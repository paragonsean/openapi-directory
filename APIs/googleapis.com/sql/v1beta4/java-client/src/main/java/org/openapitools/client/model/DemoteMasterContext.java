/*
 * Cloud SQL Admin API
 * API for Cloud SQL database instance management
 *
 * The version of the OpenAPI document: v1beta4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DemoteMasterConfiguration;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Database instance demote primary instance context.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:44.282326-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DemoteMasterContext {
  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MASTER_INSTANCE_NAME = "masterInstanceName";
  @SerializedName(SERIALIZED_NAME_MASTER_INSTANCE_NAME)
  private String masterInstanceName;

  public static final String SERIALIZED_NAME_REPLICA_CONFIGURATION = "replicaConfiguration";
  @SerializedName(SERIALIZED_NAME_REPLICA_CONFIGURATION)
  private DemoteMasterConfiguration replicaConfiguration;

  public static final String SERIALIZED_NAME_SKIP_REPLICATION_SETUP = "skipReplicationSetup";
  @SerializedName(SERIALIZED_NAME_SKIP_REPLICATION_SETUP)
  private Boolean skipReplicationSetup;

  public static final String SERIALIZED_NAME_VERIFY_GTID_CONSISTENCY = "verifyGtidConsistency";
  @SerializedName(SERIALIZED_NAME_VERIFY_GTID_CONSISTENCY)
  private Boolean verifyGtidConsistency;

  public DemoteMasterContext() {
  }

  public DemoteMasterContext kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * This is always &#x60;sql#demoteMasterContext&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public DemoteMasterContext masterInstanceName(String masterInstanceName) {
    this.masterInstanceName = masterInstanceName;
    return this;
  }

  /**
   * The name of the instance which will act as on-premises primary instance in the replication setup.
   * @return masterInstanceName
   */
  @javax.annotation.Nullable
  public String getMasterInstanceName() {
    return masterInstanceName;
  }

  public void setMasterInstanceName(String masterInstanceName) {
    this.masterInstanceName = masterInstanceName;
  }


  public DemoteMasterContext replicaConfiguration(DemoteMasterConfiguration replicaConfiguration) {
    this.replicaConfiguration = replicaConfiguration;
    return this;
  }

  /**
   * Get replicaConfiguration
   * @return replicaConfiguration
   */
  @javax.annotation.Nullable
  public DemoteMasterConfiguration getReplicaConfiguration() {
    return replicaConfiguration;
  }

  public void setReplicaConfiguration(DemoteMasterConfiguration replicaConfiguration) {
    this.replicaConfiguration = replicaConfiguration;
  }


  public DemoteMasterContext skipReplicationSetup(Boolean skipReplicationSetup) {
    this.skipReplicationSetup = skipReplicationSetup;
    return this;
  }

  /**
   * Flag to skip replication setup on the instance.
   * @return skipReplicationSetup
   */
  @javax.annotation.Nullable
  public Boolean getSkipReplicationSetup() {
    return skipReplicationSetup;
  }

  public void setSkipReplicationSetup(Boolean skipReplicationSetup) {
    this.skipReplicationSetup = skipReplicationSetup;
  }


  public DemoteMasterContext verifyGtidConsistency(Boolean verifyGtidConsistency) {
    this.verifyGtidConsistency = verifyGtidConsistency;
    return this;
  }

  /**
   * Verify the GTID consistency for demote operation. Default value: &#x60;True&#x60;. Setting this flag to &#x60;false&#x60; enables you to bypass the GTID consistency check between on-premises primary instance and Cloud SQL instance during the demotion operation but also exposes you to the risk of future replication failures. Change the value only if you know the reason for the GTID divergence and are confident that doing so will not cause any replication issues.
   * @return verifyGtidConsistency
   */
  @javax.annotation.Nullable
  public Boolean getVerifyGtidConsistency() {
    return verifyGtidConsistency;
  }

  public void setVerifyGtidConsistency(Boolean verifyGtidConsistency) {
    this.verifyGtidConsistency = verifyGtidConsistency;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DemoteMasterContext demoteMasterContext = (DemoteMasterContext) o;
    return Objects.equals(this.kind, demoteMasterContext.kind) &&
        Objects.equals(this.masterInstanceName, demoteMasterContext.masterInstanceName) &&
        Objects.equals(this.replicaConfiguration, demoteMasterContext.replicaConfiguration) &&
        Objects.equals(this.skipReplicationSetup, demoteMasterContext.skipReplicationSetup) &&
        Objects.equals(this.verifyGtidConsistency, demoteMasterContext.verifyGtidConsistency);
  }

  @Override
  public int hashCode() {
    return Objects.hash(kind, masterInstanceName, replicaConfiguration, skipReplicationSetup, verifyGtidConsistency);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DemoteMasterContext {\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    masterInstanceName: ").append(toIndentedString(masterInstanceName)).append("\n");
    sb.append("    replicaConfiguration: ").append(toIndentedString(replicaConfiguration)).append("\n");
    sb.append("    skipReplicationSetup: ").append(toIndentedString(skipReplicationSetup)).append("\n");
    sb.append("    verifyGtidConsistency: ").append(toIndentedString(verifyGtidConsistency)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("kind");
    openapiFields.add("masterInstanceName");
    openapiFields.add("replicaConfiguration");
    openapiFields.add("skipReplicationSetup");
    openapiFields.add("verifyGtidConsistency");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DemoteMasterContext
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DemoteMasterContext.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DemoteMasterContext is not found in the empty JSON string", DemoteMasterContext.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DemoteMasterContext.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DemoteMasterContext` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("masterInstanceName") != null && !jsonObj.get("masterInstanceName").isJsonNull()) && !jsonObj.get("masterInstanceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `masterInstanceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("masterInstanceName").toString()));
      }
      // validate the optional field `replicaConfiguration`
      if (jsonObj.get("replicaConfiguration") != null && !jsonObj.get("replicaConfiguration").isJsonNull()) {
        DemoteMasterConfiguration.validateJsonElement(jsonObj.get("replicaConfiguration"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DemoteMasterContext.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DemoteMasterContext' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DemoteMasterContext> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DemoteMasterContext.class));

       return (TypeAdapter<T>) new TypeAdapter<DemoteMasterContext>() {
           @Override
           public void write(JsonWriter out, DemoteMasterContext value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DemoteMasterContext read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DemoteMasterContext given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DemoteMasterContext
   * @throws IOException if the JSON string is invalid with respect to DemoteMasterContext
   */
  public static DemoteMasterContext fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DemoteMasterContext.class);
  }

  /**
   * Convert an instance of DemoteMasterContext to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

