/*
 * Cloud SQL Admin API
 * API for Cloud SQL database instance management
 *
 * The version of the OpenAPI document: v1beta4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.AdvancedMachineFeatures;
import org.openapitools.client.model.BackupConfiguration;
import org.openapitools.client.model.DataCacheConfig;
import org.openapitools.client.model.DatabaseFlags;
import org.openapitools.client.model.DenyMaintenancePeriod;
import org.openapitools.client.model.InsightsConfig;
import org.openapitools.client.model.IpConfiguration;
import org.openapitools.client.model.LocationPreference;
import org.openapitools.client.model.MaintenanceWindow;
import org.openapitools.client.model.PasswordValidationPolicy;
import org.openapitools.client.model.SqlActiveDirectoryConfig;
import org.openapitools.client.model.SqlServerAuditConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Database instance settings.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:44.282326-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Settings {
  /**
   * The activation policy specifies when the instance is activated; it is applicable only when the instance state is RUNNABLE. Valid values: * &#x60;ALWAYS&#x60;: The instance is on, and remains so even in the absence of connection requests. * &#x60;NEVER&#x60;: The instance is off; it is not activated, even if a connection request arrives.
   */
  @JsonAdapter(ActivationPolicyEnum.Adapter.class)
  public enum ActivationPolicyEnum {
    SQL_ACTIVATION_POLICY_UNSPECIFIED("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
    
    ALWAYS("ALWAYS"),
    
    NEVER("NEVER"),
    
    ON_DEMAND("ON_DEMAND");

    private String value;

    ActivationPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ActivationPolicyEnum fromValue(String value) {
      for (ActivationPolicyEnum b : ActivationPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ActivationPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActivationPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActivationPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ActivationPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ActivationPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACTIVATION_POLICY = "activationPolicy";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_POLICY)
  private ActivationPolicyEnum activationPolicy;

  public static final String SERIALIZED_NAME_ACTIVE_DIRECTORY_CONFIG = "activeDirectoryConfig";
  @SerializedName(SERIALIZED_NAME_ACTIVE_DIRECTORY_CONFIG)
  private SqlActiveDirectoryConfig activeDirectoryConfig;

  public static final String SERIALIZED_NAME_ADVANCED_MACHINE_FEATURES = "advancedMachineFeatures";
  @SerializedName(SERIALIZED_NAME_ADVANCED_MACHINE_FEATURES)
  private AdvancedMachineFeatures advancedMachineFeatures;

  public static final String SERIALIZED_NAME_AUTHORIZED_GAE_APPLICATIONS = "authorizedGaeApplications";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_AUTHORIZED_GAE_APPLICATIONS)
  private List<String> authorizedGaeApplications = new ArrayList<>();

  /**
   * Availability type. Potential values: * &#x60;ZONAL&#x60;: The instance serves data from only one zone. Outages in that zone affect data accessibility. * &#x60;REGIONAL&#x60;: The instance can serve data from more than one zone in a region (it is highly available)./ For more information, see [Overview of the High Availability Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
   */
  @JsonAdapter(AvailabilityTypeEnum.Adapter.class)
  public enum AvailabilityTypeEnum {
    SQL_AVAILABILITY_TYPE_UNSPECIFIED("SQL_AVAILABILITY_TYPE_UNSPECIFIED"),
    
    ZONAL("ZONAL"),
    
    REGIONAL("REGIONAL");

    private String value;

    AvailabilityTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AvailabilityTypeEnum fromValue(String value) {
      for (AvailabilityTypeEnum b : AvailabilityTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AvailabilityTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AvailabilityTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AvailabilityTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AvailabilityTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AvailabilityTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AVAILABILITY_TYPE = "availabilityType";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_TYPE)
  private AvailabilityTypeEnum availabilityType;

  public static final String SERIALIZED_NAME_BACKUP_CONFIGURATION = "backupConfiguration";
  @SerializedName(SERIALIZED_NAME_BACKUP_CONFIGURATION)
  private BackupConfiguration backupConfiguration;

  public static final String SERIALIZED_NAME_COLLATION = "collation";
  @SerializedName(SERIALIZED_NAME_COLLATION)
  private String collation;

  /**
   * Specifies if connections must use Cloud SQL connectors. Option values include the following: &#x60;NOT_REQUIRED&#x60; (Cloud SQL instances can be connected without Cloud SQL Connectors) and &#x60;REQUIRED&#x60; (Only allow connections that use Cloud SQL Connectors) Note that using REQUIRED disables all existing authorized networks. If this field is not specified when creating a new instance, NOT_REQUIRED is used. If this field is not specified when patching or updating an existing instance, it is left unchanged in the instance.
   */
  @JsonAdapter(ConnectorEnforcementEnum.Adapter.class)
  public enum ConnectorEnforcementEnum {
    CONNECTOR_ENFORCEMENT_UNSPECIFIED("CONNECTOR_ENFORCEMENT_UNSPECIFIED"),
    
    NOT_REQUIRED("NOT_REQUIRED"),
    
    REQUIRED("REQUIRED");

    private String value;

    ConnectorEnforcementEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConnectorEnforcementEnum fromValue(String value) {
      for (ConnectorEnforcementEnum b : ConnectorEnforcementEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConnectorEnforcementEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConnectorEnforcementEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConnectorEnforcementEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConnectorEnforcementEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ConnectorEnforcementEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONNECTOR_ENFORCEMENT = "connectorEnforcement";
  @SerializedName(SERIALIZED_NAME_CONNECTOR_ENFORCEMENT)
  private ConnectorEnforcementEnum connectorEnforcement;

  public static final String SERIALIZED_NAME_CRASH_SAFE_REPLICATION_ENABLED = "crashSafeReplicationEnabled";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CRASH_SAFE_REPLICATION_ENABLED)
  private Boolean crashSafeReplicationEnabled;

  public static final String SERIALIZED_NAME_DATA_CACHE_CONFIG = "dataCacheConfig";
  @SerializedName(SERIALIZED_NAME_DATA_CACHE_CONFIG)
  private DataCacheConfig dataCacheConfig;

  public static final String SERIALIZED_NAME_DATA_DISK_SIZE_GB = "dataDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_SIZE_GB)
  private String dataDiskSizeGb;

  /**
   * The type of data disk: &#x60;PD_SSD&#x60; (default) or &#x60;PD_HDD&#x60;. Not used for First Generation instances.
   */
  @JsonAdapter(DataDiskTypeEnum.Adapter.class)
  public enum DataDiskTypeEnum {
    SQL_DATA_DISK_TYPE_UNSPECIFIED("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
    
    PD_SSD("PD_SSD"),
    
    PD_HDD("PD_HDD"),
    
    OBSOLETE_LOCAL_SSD("OBSOLETE_LOCAL_SSD");

    private String value;

    DataDiskTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataDiskTypeEnum fromValue(String value) {
      for (DataDiskTypeEnum b : DataDiskTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataDiskTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataDiskTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataDiskTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataDiskTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataDiskTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_DISK_TYPE = "dataDiskType";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_TYPE)
  private DataDiskTypeEnum dataDiskType;

  public static final String SERIALIZED_NAME_DATABASE_FLAGS = "databaseFlags";
  @SerializedName(SERIALIZED_NAME_DATABASE_FLAGS)
  private List<DatabaseFlags> databaseFlags = new ArrayList<>();

  public static final String SERIALIZED_NAME_DATABASE_REPLICATION_ENABLED = "databaseReplicationEnabled";
  @SerializedName(SERIALIZED_NAME_DATABASE_REPLICATION_ENABLED)
  private Boolean databaseReplicationEnabled;

  public static final String SERIALIZED_NAME_DELETION_PROTECTION_ENABLED = "deletionProtectionEnabled";
  @SerializedName(SERIALIZED_NAME_DELETION_PROTECTION_ENABLED)
  private Boolean deletionProtectionEnabled;

  public static final String SERIALIZED_NAME_DENY_MAINTENANCE_PERIODS = "denyMaintenancePeriods";
  @SerializedName(SERIALIZED_NAME_DENY_MAINTENANCE_PERIODS)
  private List<DenyMaintenancePeriod> denyMaintenancePeriods = new ArrayList<>();

  /**
   * Optional. The edition of the instance.
   */
  @JsonAdapter(EditionEnum.Adapter.class)
  public enum EditionEnum {
    EDITION_UNSPECIFIED("EDITION_UNSPECIFIED"),
    
    ENTERPRISE("ENTERPRISE"),
    
    ENTERPRISE_PLUS("ENTERPRISE_PLUS");

    private String value;

    EditionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EditionEnum fromValue(String value) {
      for (EditionEnum b : EditionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EditionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EditionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EditionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EditionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EditionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EDITION = "edition";
  @SerializedName(SERIALIZED_NAME_EDITION)
  private EditionEnum edition;

  public static final String SERIALIZED_NAME_INSIGHTS_CONFIG = "insightsConfig";
  @SerializedName(SERIALIZED_NAME_INSIGHTS_CONFIG)
  private InsightsConfig insightsConfig;

  public static final String SERIALIZED_NAME_IP_CONFIGURATION = "ipConfiguration";
  @SerializedName(SERIALIZED_NAME_IP_CONFIGURATION)
  private IpConfiguration ipConfiguration;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_LOCATION_PREFERENCE = "locationPreference";
  @SerializedName(SERIALIZED_NAME_LOCATION_PREFERENCE)
  private LocationPreference locationPreference;

  public static final String SERIALIZED_NAME_MAINTENANCE_WINDOW = "maintenanceWindow";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_WINDOW)
  private MaintenanceWindow maintenanceWindow;

  public static final String SERIALIZED_NAME_PASSWORD_VALIDATION_POLICY = "passwordValidationPolicy";
  @SerializedName(SERIALIZED_NAME_PASSWORD_VALIDATION_POLICY)
  private PasswordValidationPolicy passwordValidationPolicy;

  /**
   * The pricing plan for this instance. This can be either &#x60;PER_USE&#x60; or &#x60;PACKAGE&#x60;. Only &#x60;PER_USE&#x60; is supported for Second Generation instances.
   */
  @JsonAdapter(PricingPlanEnum.Adapter.class)
  public enum PricingPlanEnum {
    SQL_PRICING_PLAN_UNSPECIFIED("SQL_PRICING_PLAN_UNSPECIFIED"),
    
    PACKAGE("PACKAGE"),
    
    PER_USE("PER_USE");

    private String value;

    PricingPlanEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PricingPlanEnum fromValue(String value) {
      for (PricingPlanEnum b : PricingPlanEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PricingPlanEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PricingPlanEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PricingPlanEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PricingPlanEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PricingPlanEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRICING_PLAN = "pricingPlan";
  @SerializedName(SERIALIZED_NAME_PRICING_PLAN)
  private PricingPlanEnum pricingPlan;

  /**
   * The type of replication this instance uses. This can be either &#x60;ASYNCHRONOUS&#x60; or &#x60;SYNCHRONOUS&#x60;. (Deprecated) This property was only applicable to First Generation instances.
   */
  @JsonAdapter(ReplicationTypeEnum.Adapter.class)
  public enum ReplicationTypeEnum {
    SQL_REPLICATION_TYPE_UNSPECIFIED("SQL_REPLICATION_TYPE_UNSPECIFIED"),
    
    SYNCHRONOUS("SYNCHRONOUS"),
    
    ASYNCHRONOUS("ASYNCHRONOUS");

    private String value;

    ReplicationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReplicationTypeEnum fromValue(String value) {
      for (ReplicationTypeEnum b : ReplicationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ReplicationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReplicationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReplicationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReplicationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReplicationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REPLICATION_TYPE = "replicationType";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_REPLICATION_TYPE)
  private ReplicationTypeEnum replicationType;

  public static final String SERIALIZED_NAME_SETTINGS_VERSION = "settingsVersion";
  @SerializedName(SERIALIZED_NAME_SETTINGS_VERSION)
  private String settingsVersion;

  public static final String SERIALIZED_NAME_SQL_SERVER_AUDIT_CONFIG = "sqlServerAuditConfig";
  @SerializedName(SERIALIZED_NAME_SQL_SERVER_AUDIT_CONFIG)
  private SqlServerAuditConfig sqlServerAuditConfig;

  public static final String SERIALIZED_NAME_STORAGE_AUTO_RESIZE = "storageAutoResize";
  @SerializedName(SERIALIZED_NAME_STORAGE_AUTO_RESIZE)
  private Boolean storageAutoResize;

  public static final String SERIALIZED_NAME_STORAGE_AUTO_RESIZE_LIMIT = "storageAutoResizeLimit";
  @SerializedName(SERIALIZED_NAME_STORAGE_AUTO_RESIZE_LIMIT)
  private String storageAutoResizeLimit;

  public static final String SERIALIZED_NAME_TIER = "tier";
  @SerializedName(SERIALIZED_NAME_TIER)
  private String tier;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public static final String SERIALIZED_NAME_USER_LABELS = "userLabels";
  @SerializedName(SERIALIZED_NAME_USER_LABELS)
  private Map<String, String> userLabels = new HashMap<>();

  public Settings() {
  }

  public Settings activationPolicy(ActivationPolicyEnum activationPolicy) {
    this.activationPolicy = activationPolicy;
    return this;
  }

  /**
   * The activation policy specifies when the instance is activated; it is applicable only when the instance state is RUNNABLE. Valid values: * &#x60;ALWAYS&#x60;: The instance is on, and remains so even in the absence of connection requests. * &#x60;NEVER&#x60;: The instance is off; it is not activated, even if a connection request arrives.
   * @return activationPolicy
   */
  @javax.annotation.Nullable
  public ActivationPolicyEnum getActivationPolicy() {
    return activationPolicy;
  }

  public void setActivationPolicy(ActivationPolicyEnum activationPolicy) {
    this.activationPolicy = activationPolicy;
  }


  public Settings activeDirectoryConfig(SqlActiveDirectoryConfig activeDirectoryConfig) {
    this.activeDirectoryConfig = activeDirectoryConfig;
    return this;
  }

  /**
   * Get activeDirectoryConfig
   * @return activeDirectoryConfig
   */
  @javax.annotation.Nullable
  public SqlActiveDirectoryConfig getActiveDirectoryConfig() {
    return activeDirectoryConfig;
  }

  public void setActiveDirectoryConfig(SqlActiveDirectoryConfig activeDirectoryConfig) {
    this.activeDirectoryConfig = activeDirectoryConfig;
  }


  public Settings advancedMachineFeatures(AdvancedMachineFeatures advancedMachineFeatures) {
    this.advancedMachineFeatures = advancedMachineFeatures;
    return this;
  }

  /**
   * Get advancedMachineFeatures
   * @return advancedMachineFeatures
   */
  @javax.annotation.Nullable
  public AdvancedMachineFeatures getAdvancedMachineFeatures() {
    return advancedMachineFeatures;
  }

  public void setAdvancedMachineFeatures(AdvancedMachineFeatures advancedMachineFeatures) {
    this.advancedMachineFeatures = advancedMachineFeatures;
  }


  @Deprecated
  public Settings authorizedGaeApplications(List<String> authorizedGaeApplications) {
    this.authorizedGaeApplications = authorizedGaeApplications;
    return this;
  }

  public Settings addAuthorizedGaeApplicationsItem(String authorizedGaeApplicationsItem) {
    if (this.authorizedGaeApplications == null) {
      this.authorizedGaeApplications = new ArrayList<>();
    }
    this.authorizedGaeApplications.add(authorizedGaeApplicationsItem);
    return this;
  }

  /**
   * The App Engine app IDs that can access this instance. (Deprecated) Applied to First Generation instances only.
   * @return authorizedGaeApplications
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<String> getAuthorizedGaeApplications() {
    return authorizedGaeApplications;
  }

  @Deprecated
  public void setAuthorizedGaeApplications(List<String> authorizedGaeApplications) {
    this.authorizedGaeApplications = authorizedGaeApplications;
  }


  public Settings availabilityType(AvailabilityTypeEnum availabilityType) {
    this.availabilityType = availabilityType;
    return this;
  }

  /**
   * Availability type. Potential values: * &#x60;ZONAL&#x60;: The instance serves data from only one zone. Outages in that zone affect data accessibility. * &#x60;REGIONAL&#x60;: The instance can serve data from more than one zone in a region (it is highly available)./ For more information, see [Overview of the High Availability Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
   * @return availabilityType
   */
  @javax.annotation.Nullable
  public AvailabilityTypeEnum getAvailabilityType() {
    return availabilityType;
  }

  public void setAvailabilityType(AvailabilityTypeEnum availabilityType) {
    this.availabilityType = availabilityType;
  }


  public Settings backupConfiguration(BackupConfiguration backupConfiguration) {
    this.backupConfiguration = backupConfiguration;
    return this;
  }

  /**
   * Get backupConfiguration
   * @return backupConfiguration
   */
  @javax.annotation.Nullable
  public BackupConfiguration getBackupConfiguration() {
    return backupConfiguration;
  }

  public void setBackupConfiguration(BackupConfiguration backupConfiguration) {
    this.backupConfiguration = backupConfiguration;
  }


  public Settings collation(String collation) {
    this.collation = collation;
    return this;
  }

  /**
   * The name of server Instance collation.
   * @return collation
   */
  @javax.annotation.Nullable
  public String getCollation() {
    return collation;
  }

  public void setCollation(String collation) {
    this.collation = collation;
  }


  public Settings connectorEnforcement(ConnectorEnforcementEnum connectorEnforcement) {
    this.connectorEnforcement = connectorEnforcement;
    return this;
  }

  /**
   * Specifies if connections must use Cloud SQL connectors. Option values include the following: &#x60;NOT_REQUIRED&#x60; (Cloud SQL instances can be connected without Cloud SQL Connectors) and &#x60;REQUIRED&#x60; (Only allow connections that use Cloud SQL Connectors) Note that using REQUIRED disables all existing authorized networks. If this field is not specified when creating a new instance, NOT_REQUIRED is used. If this field is not specified when patching or updating an existing instance, it is left unchanged in the instance.
   * @return connectorEnforcement
   */
  @javax.annotation.Nullable
  public ConnectorEnforcementEnum getConnectorEnforcement() {
    return connectorEnforcement;
  }

  public void setConnectorEnforcement(ConnectorEnforcementEnum connectorEnforcement) {
    this.connectorEnforcement = connectorEnforcement;
  }


  @Deprecated
  public Settings crashSafeReplicationEnabled(Boolean crashSafeReplicationEnabled) {
    this.crashSafeReplicationEnabled = crashSafeReplicationEnabled;
    return this;
  }

  /**
   * Configuration specific to read replica instances. Indicates whether database flags for crash-safe replication are enabled. This property was only applicable to First Generation instances.
   * @return crashSafeReplicationEnabled
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getCrashSafeReplicationEnabled() {
    return crashSafeReplicationEnabled;
  }

  @Deprecated
  public void setCrashSafeReplicationEnabled(Boolean crashSafeReplicationEnabled) {
    this.crashSafeReplicationEnabled = crashSafeReplicationEnabled;
  }


  public Settings dataCacheConfig(DataCacheConfig dataCacheConfig) {
    this.dataCacheConfig = dataCacheConfig;
    return this;
  }

  /**
   * Get dataCacheConfig
   * @return dataCacheConfig
   */
  @javax.annotation.Nullable
  public DataCacheConfig getDataCacheConfig() {
    return dataCacheConfig;
  }

  public void setDataCacheConfig(DataCacheConfig dataCacheConfig) {
    this.dataCacheConfig = dataCacheConfig;
  }


  public Settings dataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
    return this;
  }

  /**
   * The size of data disk, in GB. The data disk size minimum is 10GB.
   * @return dataDiskSizeGb
   */
  @javax.annotation.Nullable
  public String getDataDiskSizeGb() {
    return dataDiskSizeGb;
  }

  public void setDataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
  }


  public Settings dataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
    return this;
  }

  /**
   * The type of data disk: &#x60;PD_SSD&#x60; (default) or &#x60;PD_HDD&#x60;. Not used for First Generation instances.
   * @return dataDiskType
   */
  @javax.annotation.Nullable
  public DataDiskTypeEnum getDataDiskType() {
    return dataDiskType;
  }

  public void setDataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
  }


  public Settings databaseFlags(List<DatabaseFlags> databaseFlags) {
    this.databaseFlags = databaseFlags;
    return this;
  }

  public Settings addDatabaseFlagsItem(DatabaseFlags databaseFlagsItem) {
    if (this.databaseFlags == null) {
      this.databaseFlags = new ArrayList<>();
    }
    this.databaseFlags.add(databaseFlagsItem);
    return this;
  }

  /**
   * The database flags passed to the instance at startup.
   * @return databaseFlags
   */
  @javax.annotation.Nullable
  public List<DatabaseFlags> getDatabaseFlags() {
    return databaseFlags;
  }

  public void setDatabaseFlags(List<DatabaseFlags> databaseFlags) {
    this.databaseFlags = databaseFlags;
  }


  public Settings databaseReplicationEnabled(Boolean databaseReplicationEnabled) {
    this.databaseReplicationEnabled = databaseReplicationEnabled;
    return this;
  }

  /**
   * Configuration specific to read replica instances. Indicates whether replication is enabled or not. WARNING: Changing this restarts the instance.
   * @return databaseReplicationEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDatabaseReplicationEnabled() {
    return databaseReplicationEnabled;
  }

  public void setDatabaseReplicationEnabled(Boolean databaseReplicationEnabled) {
    this.databaseReplicationEnabled = databaseReplicationEnabled;
  }


  public Settings deletionProtectionEnabled(Boolean deletionProtectionEnabled) {
    this.deletionProtectionEnabled = deletionProtectionEnabled;
    return this;
  }

  /**
   * Configuration to protect against accidental instance deletion.
   * @return deletionProtectionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDeletionProtectionEnabled() {
    return deletionProtectionEnabled;
  }

  public void setDeletionProtectionEnabled(Boolean deletionProtectionEnabled) {
    this.deletionProtectionEnabled = deletionProtectionEnabled;
  }


  public Settings denyMaintenancePeriods(List<DenyMaintenancePeriod> denyMaintenancePeriods) {
    this.denyMaintenancePeriods = denyMaintenancePeriods;
    return this;
  }

  public Settings addDenyMaintenancePeriodsItem(DenyMaintenancePeriod denyMaintenancePeriodsItem) {
    if (this.denyMaintenancePeriods == null) {
      this.denyMaintenancePeriods = new ArrayList<>();
    }
    this.denyMaintenancePeriods.add(denyMaintenancePeriodsItem);
    return this;
  }

  /**
   * Deny maintenance periods
   * @return denyMaintenancePeriods
   */
  @javax.annotation.Nullable
  public List<DenyMaintenancePeriod> getDenyMaintenancePeriods() {
    return denyMaintenancePeriods;
  }

  public void setDenyMaintenancePeriods(List<DenyMaintenancePeriod> denyMaintenancePeriods) {
    this.denyMaintenancePeriods = denyMaintenancePeriods;
  }


  public Settings edition(EditionEnum edition) {
    this.edition = edition;
    return this;
  }

  /**
   * Optional. The edition of the instance.
   * @return edition
   */
  @javax.annotation.Nullable
  public EditionEnum getEdition() {
    return edition;
  }

  public void setEdition(EditionEnum edition) {
    this.edition = edition;
  }


  public Settings insightsConfig(InsightsConfig insightsConfig) {
    this.insightsConfig = insightsConfig;
    return this;
  }

  /**
   * Get insightsConfig
   * @return insightsConfig
   */
  @javax.annotation.Nullable
  public InsightsConfig getInsightsConfig() {
    return insightsConfig;
  }

  public void setInsightsConfig(InsightsConfig insightsConfig) {
    this.insightsConfig = insightsConfig;
  }


  public Settings ipConfiguration(IpConfiguration ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
    return this;
  }

  /**
   * Get ipConfiguration
   * @return ipConfiguration
   */
  @javax.annotation.Nullable
  public IpConfiguration getIpConfiguration() {
    return ipConfiguration;
  }

  public void setIpConfiguration(IpConfiguration ipConfiguration) {
    this.ipConfiguration = ipConfiguration;
  }


  public Settings kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * This is always &#x60;sql#settings&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Settings locationPreference(LocationPreference locationPreference) {
    this.locationPreference = locationPreference;
    return this;
  }

  /**
   * Get locationPreference
   * @return locationPreference
   */
  @javax.annotation.Nullable
  public LocationPreference getLocationPreference() {
    return locationPreference;
  }

  public void setLocationPreference(LocationPreference locationPreference) {
    this.locationPreference = locationPreference;
  }


  public Settings maintenanceWindow(MaintenanceWindow maintenanceWindow) {
    this.maintenanceWindow = maintenanceWindow;
    return this;
  }

  /**
   * Get maintenanceWindow
   * @return maintenanceWindow
   */
  @javax.annotation.Nullable
  public MaintenanceWindow getMaintenanceWindow() {
    return maintenanceWindow;
  }

  public void setMaintenanceWindow(MaintenanceWindow maintenanceWindow) {
    this.maintenanceWindow = maintenanceWindow;
  }


  public Settings passwordValidationPolicy(PasswordValidationPolicy passwordValidationPolicy) {
    this.passwordValidationPolicy = passwordValidationPolicy;
    return this;
  }

  /**
   * Get passwordValidationPolicy
   * @return passwordValidationPolicy
   */
  @javax.annotation.Nullable
  public PasswordValidationPolicy getPasswordValidationPolicy() {
    return passwordValidationPolicy;
  }

  public void setPasswordValidationPolicy(PasswordValidationPolicy passwordValidationPolicy) {
    this.passwordValidationPolicy = passwordValidationPolicy;
  }


  public Settings pricingPlan(PricingPlanEnum pricingPlan) {
    this.pricingPlan = pricingPlan;
    return this;
  }

  /**
   * The pricing plan for this instance. This can be either &#x60;PER_USE&#x60; or &#x60;PACKAGE&#x60;. Only &#x60;PER_USE&#x60; is supported for Second Generation instances.
   * @return pricingPlan
   */
  @javax.annotation.Nullable
  public PricingPlanEnum getPricingPlan() {
    return pricingPlan;
  }

  public void setPricingPlan(PricingPlanEnum pricingPlan) {
    this.pricingPlan = pricingPlan;
  }


  @Deprecated
  public Settings replicationType(ReplicationTypeEnum replicationType) {
    this.replicationType = replicationType;
    return this;
  }

  /**
   * The type of replication this instance uses. This can be either &#x60;ASYNCHRONOUS&#x60; or &#x60;SYNCHRONOUS&#x60;. (Deprecated) This property was only applicable to First Generation instances.
   * @return replicationType
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public ReplicationTypeEnum getReplicationType() {
    return replicationType;
  }

  @Deprecated
  public void setReplicationType(ReplicationTypeEnum replicationType) {
    this.replicationType = replicationType;
  }


  public Settings settingsVersion(String settingsVersion) {
    this.settingsVersion = settingsVersion;
    return this;
  }

  /**
   * The version of instance settings. This is a required field for update method to make sure concurrent updates are handled properly. During update, use the most recent settingsVersion value for this instance and do not try to update this value.
   * @return settingsVersion
   */
  @javax.annotation.Nullable
  public String getSettingsVersion() {
    return settingsVersion;
  }

  public void setSettingsVersion(String settingsVersion) {
    this.settingsVersion = settingsVersion;
  }


  public Settings sqlServerAuditConfig(SqlServerAuditConfig sqlServerAuditConfig) {
    this.sqlServerAuditConfig = sqlServerAuditConfig;
    return this;
  }

  /**
   * Get sqlServerAuditConfig
   * @return sqlServerAuditConfig
   */
  @javax.annotation.Nullable
  public SqlServerAuditConfig getSqlServerAuditConfig() {
    return sqlServerAuditConfig;
  }

  public void setSqlServerAuditConfig(SqlServerAuditConfig sqlServerAuditConfig) {
    this.sqlServerAuditConfig = sqlServerAuditConfig;
  }


  public Settings storageAutoResize(Boolean storageAutoResize) {
    this.storageAutoResize = storageAutoResize;
    return this;
  }

  /**
   * Configuration to increase storage size automatically. The default value is true.
   * @return storageAutoResize
   */
  @javax.annotation.Nullable
  public Boolean getStorageAutoResize() {
    return storageAutoResize;
  }

  public void setStorageAutoResize(Boolean storageAutoResize) {
    this.storageAutoResize = storageAutoResize;
  }


  public Settings storageAutoResizeLimit(String storageAutoResizeLimit) {
    this.storageAutoResizeLimit = storageAutoResizeLimit;
    return this;
  }

  /**
   * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
   * @return storageAutoResizeLimit
   */
  @javax.annotation.Nullable
  public String getStorageAutoResizeLimit() {
    return storageAutoResizeLimit;
  }

  public void setStorageAutoResizeLimit(String storageAutoResizeLimit) {
    this.storageAutoResizeLimit = storageAutoResizeLimit;
  }


  public Settings tier(String tier) {
    this.tier = tier;
    return this;
  }

  /**
   * The tier (or machine type) for this instance, for example &#x60;db-custom-1-3840&#x60;. WARNING: Changing this restarts the instance.
   * @return tier
   */
  @javax.annotation.Nullable
  public String getTier() {
    return tier;
  }

  public void setTier(String tier) {
    this.tier = tier;
  }


  public Settings timeZone(String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * Server timezone, relevant only for Cloud SQL for SQL Server.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }


  public Settings userLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
    return this;
  }

  public Settings putUserLabelsItem(String key, String userLabelsItem) {
    if (this.userLabels == null) {
      this.userLabels = new HashMap<>();
    }
    this.userLabels.put(key, userLabelsItem);
    return this;
  }

  /**
   * User-provided labels, represented as a dictionary where each label is a single key value pair.
   * @return userLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getUserLabels() {
    return userLabels;
  }

  public void setUserLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Settings settings = (Settings) o;
    return Objects.equals(this.activationPolicy, settings.activationPolicy) &&
        Objects.equals(this.activeDirectoryConfig, settings.activeDirectoryConfig) &&
        Objects.equals(this.advancedMachineFeatures, settings.advancedMachineFeatures) &&
        Objects.equals(this.authorizedGaeApplications, settings.authorizedGaeApplications) &&
        Objects.equals(this.availabilityType, settings.availabilityType) &&
        Objects.equals(this.backupConfiguration, settings.backupConfiguration) &&
        Objects.equals(this.collation, settings.collation) &&
        Objects.equals(this.connectorEnforcement, settings.connectorEnforcement) &&
        Objects.equals(this.crashSafeReplicationEnabled, settings.crashSafeReplicationEnabled) &&
        Objects.equals(this.dataCacheConfig, settings.dataCacheConfig) &&
        Objects.equals(this.dataDiskSizeGb, settings.dataDiskSizeGb) &&
        Objects.equals(this.dataDiskType, settings.dataDiskType) &&
        Objects.equals(this.databaseFlags, settings.databaseFlags) &&
        Objects.equals(this.databaseReplicationEnabled, settings.databaseReplicationEnabled) &&
        Objects.equals(this.deletionProtectionEnabled, settings.deletionProtectionEnabled) &&
        Objects.equals(this.denyMaintenancePeriods, settings.denyMaintenancePeriods) &&
        Objects.equals(this.edition, settings.edition) &&
        Objects.equals(this.insightsConfig, settings.insightsConfig) &&
        Objects.equals(this.ipConfiguration, settings.ipConfiguration) &&
        Objects.equals(this.kind, settings.kind) &&
        Objects.equals(this.locationPreference, settings.locationPreference) &&
        Objects.equals(this.maintenanceWindow, settings.maintenanceWindow) &&
        Objects.equals(this.passwordValidationPolicy, settings.passwordValidationPolicy) &&
        Objects.equals(this.pricingPlan, settings.pricingPlan) &&
        Objects.equals(this.replicationType, settings.replicationType) &&
        Objects.equals(this.settingsVersion, settings.settingsVersion) &&
        Objects.equals(this.sqlServerAuditConfig, settings.sqlServerAuditConfig) &&
        Objects.equals(this.storageAutoResize, settings.storageAutoResize) &&
        Objects.equals(this.storageAutoResizeLimit, settings.storageAutoResizeLimit) &&
        Objects.equals(this.tier, settings.tier) &&
        Objects.equals(this.timeZone, settings.timeZone) &&
        Objects.equals(this.userLabels, settings.userLabels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationPolicy, activeDirectoryConfig, advancedMachineFeatures, authorizedGaeApplications, availabilityType, backupConfiguration, collation, connectorEnforcement, crashSafeReplicationEnabled, dataCacheConfig, dataDiskSizeGb, dataDiskType, databaseFlags, databaseReplicationEnabled, deletionProtectionEnabled, denyMaintenancePeriods, edition, insightsConfig, ipConfiguration, kind, locationPreference, maintenanceWindow, passwordValidationPolicy, pricingPlan, replicationType, settingsVersion, sqlServerAuditConfig, storageAutoResize, storageAutoResizeLimit, tier, timeZone, userLabels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Settings {\n");
    sb.append("    activationPolicy: ").append(toIndentedString(activationPolicy)).append("\n");
    sb.append("    activeDirectoryConfig: ").append(toIndentedString(activeDirectoryConfig)).append("\n");
    sb.append("    advancedMachineFeatures: ").append(toIndentedString(advancedMachineFeatures)).append("\n");
    sb.append("    authorizedGaeApplications: ").append(toIndentedString(authorizedGaeApplications)).append("\n");
    sb.append("    availabilityType: ").append(toIndentedString(availabilityType)).append("\n");
    sb.append("    backupConfiguration: ").append(toIndentedString(backupConfiguration)).append("\n");
    sb.append("    collation: ").append(toIndentedString(collation)).append("\n");
    sb.append("    connectorEnforcement: ").append(toIndentedString(connectorEnforcement)).append("\n");
    sb.append("    crashSafeReplicationEnabled: ").append(toIndentedString(crashSafeReplicationEnabled)).append("\n");
    sb.append("    dataCacheConfig: ").append(toIndentedString(dataCacheConfig)).append("\n");
    sb.append("    dataDiskSizeGb: ").append(toIndentedString(dataDiskSizeGb)).append("\n");
    sb.append("    dataDiskType: ").append(toIndentedString(dataDiskType)).append("\n");
    sb.append("    databaseFlags: ").append(toIndentedString(databaseFlags)).append("\n");
    sb.append("    databaseReplicationEnabled: ").append(toIndentedString(databaseReplicationEnabled)).append("\n");
    sb.append("    deletionProtectionEnabled: ").append(toIndentedString(deletionProtectionEnabled)).append("\n");
    sb.append("    denyMaintenancePeriods: ").append(toIndentedString(denyMaintenancePeriods)).append("\n");
    sb.append("    edition: ").append(toIndentedString(edition)).append("\n");
    sb.append("    insightsConfig: ").append(toIndentedString(insightsConfig)).append("\n");
    sb.append("    ipConfiguration: ").append(toIndentedString(ipConfiguration)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    locationPreference: ").append(toIndentedString(locationPreference)).append("\n");
    sb.append("    maintenanceWindow: ").append(toIndentedString(maintenanceWindow)).append("\n");
    sb.append("    passwordValidationPolicy: ").append(toIndentedString(passwordValidationPolicy)).append("\n");
    sb.append("    pricingPlan: ").append(toIndentedString(pricingPlan)).append("\n");
    sb.append("    replicationType: ").append(toIndentedString(replicationType)).append("\n");
    sb.append("    settingsVersion: ").append(toIndentedString(settingsVersion)).append("\n");
    sb.append("    sqlServerAuditConfig: ").append(toIndentedString(sqlServerAuditConfig)).append("\n");
    sb.append("    storageAutoResize: ").append(toIndentedString(storageAutoResize)).append("\n");
    sb.append("    storageAutoResizeLimit: ").append(toIndentedString(storageAutoResizeLimit)).append("\n");
    sb.append("    tier: ").append(toIndentedString(tier)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("    userLabels: ").append(toIndentedString(userLabels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationPolicy");
    openapiFields.add("activeDirectoryConfig");
    openapiFields.add("advancedMachineFeatures");
    openapiFields.add("authorizedGaeApplications");
    openapiFields.add("availabilityType");
    openapiFields.add("backupConfiguration");
    openapiFields.add("collation");
    openapiFields.add("connectorEnforcement");
    openapiFields.add("crashSafeReplicationEnabled");
    openapiFields.add("dataCacheConfig");
    openapiFields.add("dataDiskSizeGb");
    openapiFields.add("dataDiskType");
    openapiFields.add("databaseFlags");
    openapiFields.add("databaseReplicationEnabled");
    openapiFields.add("deletionProtectionEnabled");
    openapiFields.add("denyMaintenancePeriods");
    openapiFields.add("edition");
    openapiFields.add("insightsConfig");
    openapiFields.add("ipConfiguration");
    openapiFields.add("kind");
    openapiFields.add("locationPreference");
    openapiFields.add("maintenanceWindow");
    openapiFields.add("passwordValidationPolicy");
    openapiFields.add("pricingPlan");
    openapiFields.add("replicationType");
    openapiFields.add("settingsVersion");
    openapiFields.add("sqlServerAuditConfig");
    openapiFields.add("storageAutoResize");
    openapiFields.add("storageAutoResizeLimit");
    openapiFields.add("tier");
    openapiFields.add("timeZone");
    openapiFields.add("userLabels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Settings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Settings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Settings is not found in the empty JSON string", Settings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Settings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Settings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("activationPolicy") != null && !jsonObj.get("activationPolicy").isJsonNull()) && !jsonObj.get("activationPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activationPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activationPolicy").toString()));
      }
      // validate the optional field `activationPolicy`
      if (jsonObj.get("activationPolicy") != null && !jsonObj.get("activationPolicy").isJsonNull()) {
        ActivationPolicyEnum.validateJsonElement(jsonObj.get("activationPolicy"));
      }
      // validate the optional field `activeDirectoryConfig`
      if (jsonObj.get("activeDirectoryConfig") != null && !jsonObj.get("activeDirectoryConfig").isJsonNull()) {
        SqlActiveDirectoryConfig.validateJsonElement(jsonObj.get("activeDirectoryConfig"));
      }
      // validate the optional field `advancedMachineFeatures`
      if (jsonObj.get("advancedMachineFeatures") != null && !jsonObj.get("advancedMachineFeatures").isJsonNull()) {
        AdvancedMachineFeatures.validateJsonElement(jsonObj.get("advancedMachineFeatures"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("authorizedGaeApplications") != null && !jsonObj.get("authorizedGaeApplications").isJsonNull() && !jsonObj.get("authorizedGaeApplications").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizedGaeApplications` to be an array in the JSON string but got `%s`", jsonObj.get("authorizedGaeApplications").toString()));
      }
      if ((jsonObj.get("availabilityType") != null && !jsonObj.get("availabilityType").isJsonNull()) && !jsonObj.get("availabilityType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availabilityType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availabilityType").toString()));
      }
      // validate the optional field `availabilityType`
      if (jsonObj.get("availabilityType") != null && !jsonObj.get("availabilityType").isJsonNull()) {
        AvailabilityTypeEnum.validateJsonElement(jsonObj.get("availabilityType"));
      }
      // validate the optional field `backupConfiguration`
      if (jsonObj.get("backupConfiguration") != null && !jsonObj.get("backupConfiguration").isJsonNull()) {
        BackupConfiguration.validateJsonElement(jsonObj.get("backupConfiguration"));
      }
      if ((jsonObj.get("collation") != null && !jsonObj.get("collation").isJsonNull()) && !jsonObj.get("collation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `collation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("collation").toString()));
      }
      if ((jsonObj.get("connectorEnforcement") != null && !jsonObj.get("connectorEnforcement").isJsonNull()) && !jsonObj.get("connectorEnforcement").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectorEnforcement` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectorEnforcement").toString()));
      }
      // validate the optional field `connectorEnforcement`
      if (jsonObj.get("connectorEnforcement") != null && !jsonObj.get("connectorEnforcement").isJsonNull()) {
        ConnectorEnforcementEnum.validateJsonElement(jsonObj.get("connectorEnforcement"));
      }
      // validate the optional field `dataCacheConfig`
      if (jsonObj.get("dataCacheConfig") != null && !jsonObj.get("dataCacheConfig").isJsonNull()) {
        DataCacheConfig.validateJsonElement(jsonObj.get("dataCacheConfig"));
      }
      if ((jsonObj.get("dataDiskSizeGb") != null && !jsonObj.get("dataDiskSizeGb").isJsonNull()) && !jsonObj.get("dataDiskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskSizeGb").toString()));
      }
      if ((jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) && !jsonObj.get("dataDiskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskType").toString()));
      }
      // validate the optional field `dataDiskType`
      if (jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) {
        DataDiskTypeEnum.validateJsonElement(jsonObj.get("dataDiskType"));
      }
      if (jsonObj.get("databaseFlags") != null && !jsonObj.get("databaseFlags").isJsonNull()) {
        JsonArray jsonArraydatabaseFlags = jsonObj.getAsJsonArray("databaseFlags");
        if (jsonArraydatabaseFlags != null) {
          // ensure the json data is an array
          if (!jsonObj.get("databaseFlags").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `databaseFlags` to be an array in the JSON string but got `%s`", jsonObj.get("databaseFlags").toString()));
          }

          // validate the optional field `databaseFlags` (array)
          for (int i = 0; i < jsonArraydatabaseFlags.size(); i++) {
            DatabaseFlags.validateJsonElement(jsonArraydatabaseFlags.get(i));
          };
        }
      }
      if (jsonObj.get("denyMaintenancePeriods") != null && !jsonObj.get("denyMaintenancePeriods").isJsonNull()) {
        JsonArray jsonArraydenyMaintenancePeriods = jsonObj.getAsJsonArray("denyMaintenancePeriods");
        if (jsonArraydenyMaintenancePeriods != null) {
          // ensure the json data is an array
          if (!jsonObj.get("denyMaintenancePeriods").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `denyMaintenancePeriods` to be an array in the JSON string but got `%s`", jsonObj.get("denyMaintenancePeriods").toString()));
          }

          // validate the optional field `denyMaintenancePeriods` (array)
          for (int i = 0; i < jsonArraydenyMaintenancePeriods.size(); i++) {
            DenyMaintenancePeriod.validateJsonElement(jsonArraydenyMaintenancePeriods.get(i));
          };
        }
      }
      if ((jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) && !jsonObj.get("edition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edition").toString()));
      }
      // validate the optional field `edition`
      if (jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) {
        EditionEnum.validateJsonElement(jsonObj.get("edition"));
      }
      // validate the optional field `insightsConfig`
      if (jsonObj.get("insightsConfig") != null && !jsonObj.get("insightsConfig").isJsonNull()) {
        InsightsConfig.validateJsonElement(jsonObj.get("insightsConfig"));
      }
      // validate the optional field `ipConfiguration`
      if (jsonObj.get("ipConfiguration") != null && !jsonObj.get("ipConfiguration").isJsonNull()) {
        IpConfiguration.validateJsonElement(jsonObj.get("ipConfiguration"));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // validate the optional field `locationPreference`
      if (jsonObj.get("locationPreference") != null && !jsonObj.get("locationPreference").isJsonNull()) {
        LocationPreference.validateJsonElement(jsonObj.get("locationPreference"));
      }
      // validate the optional field `maintenanceWindow`
      if (jsonObj.get("maintenanceWindow") != null && !jsonObj.get("maintenanceWindow").isJsonNull()) {
        MaintenanceWindow.validateJsonElement(jsonObj.get("maintenanceWindow"));
      }
      // validate the optional field `passwordValidationPolicy`
      if (jsonObj.get("passwordValidationPolicy") != null && !jsonObj.get("passwordValidationPolicy").isJsonNull()) {
        PasswordValidationPolicy.validateJsonElement(jsonObj.get("passwordValidationPolicy"));
      }
      if ((jsonObj.get("pricingPlan") != null && !jsonObj.get("pricingPlan").isJsonNull()) && !jsonObj.get("pricingPlan").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pricingPlan` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pricingPlan").toString()));
      }
      // validate the optional field `pricingPlan`
      if (jsonObj.get("pricingPlan") != null && !jsonObj.get("pricingPlan").isJsonNull()) {
        PricingPlanEnum.validateJsonElement(jsonObj.get("pricingPlan"));
      }
      if ((jsonObj.get("replicationType") != null && !jsonObj.get("replicationType").isJsonNull()) && !jsonObj.get("replicationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replicationType").toString()));
      }
      // validate the optional field `replicationType`
      if (jsonObj.get("replicationType") != null && !jsonObj.get("replicationType").isJsonNull()) {
        ReplicationTypeEnum.validateJsonElement(jsonObj.get("replicationType"));
      }
      if ((jsonObj.get("settingsVersion") != null && !jsonObj.get("settingsVersion").isJsonNull()) && !jsonObj.get("settingsVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `settingsVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("settingsVersion").toString()));
      }
      // validate the optional field `sqlServerAuditConfig`
      if (jsonObj.get("sqlServerAuditConfig") != null && !jsonObj.get("sqlServerAuditConfig").isJsonNull()) {
        SqlServerAuditConfig.validateJsonElement(jsonObj.get("sqlServerAuditConfig"));
      }
      if ((jsonObj.get("storageAutoResizeLimit") != null && !jsonObj.get("storageAutoResizeLimit").isJsonNull()) && !jsonObj.get("storageAutoResizeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageAutoResizeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageAutoResizeLimit").toString()));
      }
      if ((jsonObj.get("tier") != null && !jsonObj.get("tier").isJsonNull()) && !jsonObj.get("tier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tier").toString()));
      }
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Settings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Settings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Settings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Settings.class));

       return (TypeAdapter<T>) new TypeAdapter<Settings>() {
           @Override
           public void write(JsonWriter out, Settings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Settings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Settings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Settings
   * @throws IOException if the JSON string is invalid with respect to Settings
   */
  public static Settings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Settings.class);
  }

  /**
   * Convert an instance of Settings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

