/*
 * Cloud SQL Admin API
 * API for Cloud SQL database instance management
 *
 * The version of the OpenAPI document: v1beta4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DatabaseInstanceFailoverReplica;
import org.openapitools.client.model.DiskEncryptionConfiguration;
import org.openapitools.client.model.DiskEncryptionStatus;
import org.openapitools.client.model.IpMapping;
import org.openapitools.client.model.OnPremisesConfiguration;
import org.openapitools.client.model.ReplicaConfiguration;
import org.openapitools.client.model.Settings;
import org.openapitools.client.model.SqlOutOfDiskReport;
import org.openapitools.client.model.SqlScheduledMaintenance;
import org.openapitools.client.model.SslCert;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Cloud SQL instance resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:44.282326-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DatabaseInstance {
  public static final String SERIALIZED_NAME_AVAILABLE_MAINTENANCE_VERSIONS = "availableMaintenanceVersions";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_MAINTENANCE_VERSIONS)
  private List<String> availableMaintenanceVersions = new ArrayList<>();

  /**
   * The backend type. &#x60;SECOND_GEN&#x60;: Cloud SQL database instance. &#x60;EXTERNAL&#x60;: A database server that is not managed by Google. This property is read-only; use the &#x60;tier&#x60; property in the &#x60;settings&#x60; object to determine the database type.
   */
  @JsonAdapter(BackendTypeEnum.Adapter.class)
  public enum BackendTypeEnum {
    SQL_BACKEND_TYPE_UNSPECIFIED("SQL_BACKEND_TYPE_UNSPECIFIED"),
    
    FIRST_GEN("FIRST_GEN"),
    
    SECOND_GEN("SECOND_GEN"),
    
    EXTERNAL("EXTERNAL");

    private String value;

    BackendTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BackendTypeEnum fromValue(String value) {
      for (BackendTypeEnum b : BackendTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BackendTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BackendTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BackendTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BackendTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BackendTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BACKEND_TYPE = "backendType";
  @SerializedName(SERIALIZED_NAME_BACKEND_TYPE)
  private BackendTypeEnum backendType;

  public static final String SERIALIZED_NAME_CONNECTION_NAME = "connectionName";
  @SerializedName(SERIALIZED_NAME_CONNECTION_NAME)
  private String connectionName;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CURRENT_DISK_SIZE = "currentDiskSize";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CURRENT_DISK_SIZE)
  private String currentDiskSize;

  public static final String SERIALIZED_NAME_DATABASE_INSTALLED_VERSION = "databaseInstalledVersion";
  @SerializedName(SERIALIZED_NAME_DATABASE_INSTALLED_VERSION)
  private String databaseInstalledVersion;

  /**
   * The database engine type and version. The &#x60;databaseVersion&#x60; field cannot be changed after instance creation.
   */
  @JsonAdapter(DatabaseVersionEnum.Adapter.class)
  public enum DatabaseVersionEnum {
    SQL_DATABASE_VERSION_UNSPECIFIED("SQL_DATABASE_VERSION_UNSPECIFIED"),
    
    MYSQL_5_1("MYSQL_5_1"),
    
    MYSQL_5_5("MYSQL_5_5"),
    
    MYSQL_5_6("MYSQL_5_6"),
    
    MYSQL_5_7("MYSQL_5_7"),
    
    SQLSERVER_2017_STANDARD("SQLSERVER_2017_STANDARD"),
    
    SQLSERVER_2017_ENTERPRISE("SQLSERVER_2017_ENTERPRISE"),
    
    SQLSERVER_2017_EXPRESS("SQLSERVER_2017_EXPRESS"),
    
    SQLSERVER_2017_WEB("SQLSERVER_2017_WEB"),
    
    POSTGRES_9_6("POSTGRES_9_6"),
    
    POSTGRES_10("POSTGRES_10"),
    
    POSTGRES_11("POSTGRES_11"),
    
    POSTGRES_12("POSTGRES_12"),
    
    POSTGRES_13("POSTGRES_13"),
    
    POSTGRES_14("POSTGRES_14"),
    
    POSTGRES_15("POSTGRES_15"),
    
    MYSQL_8_0("MYSQL_8_0"),
    
    MYSQL_8_0_18("MYSQL_8_0_18"),
    
    MYSQL_8_0_26("MYSQL_8_0_26"),
    
    MYSQL_8_0_27("MYSQL_8_0_27"),
    
    MYSQL_8_0_28("MYSQL_8_0_28"),
    
    MYSQL_8_0_29("MYSQL_8_0_29"),
    
    MYSQL_8_0_30("MYSQL_8_0_30"),
    
    MYSQL_8_0_31("MYSQL_8_0_31"),
    
    MYSQL_8_0_32("MYSQL_8_0_32"),
    
    MYSQL_8_0_33("MYSQL_8_0_33"),
    
    MYSQL_8_0_34("MYSQL_8_0_34"),
    
    MYSQL_8_0_35("MYSQL_8_0_35"),
    
    MYSQL_8_0_36("MYSQL_8_0_36"),
    
    SQLSERVER_2019_STANDARD("SQLSERVER_2019_STANDARD"),
    
    SQLSERVER_2019_ENTERPRISE("SQLSERVER_2019_ENTERPRISE"),
    
    SQLSERVER_2019_EXPRESS("SQLSERVER_2019_EXPRESS"),
    
    SQLSERVER_2019_WEB("SQLSERVER_2019_WEB"),
    
    SQLSERVER_2022_STANDARD("SQLSERVER_2022_STANDARD"),
    
    SQLSERVER_2022_ENTERPRISE("SQLSERVER_2022_ENTERPRISE"),
    
    SQLSERVER_2022_EXPRESS("SQLSERVER_2022_EXPRESS"),
    
    SQLSERVER_2022_WEB("SQLSERVER_2022_WEB");

    private String value;

    DatabaseVersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DatabaseVersionEnum fromValue(String value) {
      for (DatabaseVersionEnum b : DatabaseVersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DatabaseVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DatabaseVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DatabaseVersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DatabaseVersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DatabaseVersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATABASE_VERSION = "databaseVersion";
  @SerializedName(SERIALIZED_NAME_DATABASE_VERSION)
  private DatabaseVersionEnum databaseVersion;

  public static final String SERIALIZED_NAME_DISK_ENCRYPTION_CONFIGURATION = "diskEncryptionConfiguration";
  @SerializedName(SERIALIZED_NAME_DISK_ENCRYPTION_CONFIGURATION)
  private DiskEncryptionConfiguration diskEncryptionConfiguration;

  public static final String SERIALIZED_NAME_DISK_ENCRYPTION_STATUS = "diskEncryptionStatus";
  @SerializedName(SERIALIZED_NAME_DISK_ENCRYPTION_STATUS)
  private DiskEncryptionStatus diskEncryptionStatus;

  public static final String SERIALIZED_NAME_DNS_NAME = "dnsName";
  @SerializedName(SERIALIZED_NAME_DNS_NAME)
  private String dnsName;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_FAILOVER_REPLICA = "failoverReplica";
  @SerializedName(SERIALIZED_NAME_FAILOVER_REPLICA)
  private DatabaseInstanceFailoverReplica failoverReplica;

  public static final String SERIALIZED_NAME_GCE_ZONE = "gceZone";
  @SerializedName(SERIALIZED_NAME_GCE_ZONE)
  private String gceZone;

  /**
   * The instance type.
   */
  @JsonAdapter(InstanceTypeEnum.Adapter.class)
  public enum InstanceTypeEnum {
    SQL_INSTANCE_TYPE_UNSPECIFIED("SQL_INSTANCE_TYPE_UNSPECIFIED"),
    
    CLOUD_SQL_INSTANCE("CLOUD_SQL_INSTANCE"),
    
    ON_PREMISES_INSTANCE("ON_PREMISES_INSTANCE"),
    
    READ_REPLICA_INSTANCE("READ_REPLICA_INSTANCE");

    private String value;

    InstanceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InstanceTypeEnum fromValue(String value) {
      for (InstanceTypeEnum b : InstanceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InstanceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InstanceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InstanceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InstanceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InstanceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INSTANCE_TYPE = "instanceType";
  @SerializedName(SERIALIZED_NAME_INSTANCE_TYPE)
  private InstanceTypeEnum instanceType;

  public static final String SERIALIZED_NAME_IP_ADDRESSES = "ipAddresses";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESSES)
  private List<IpMapping> ipAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_IPV6_ADDRESS = "ipv6Address";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_IPV6_ADDRESS)
  private String ipv6Address;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MAINTENANCE_VERSION = "maintenanceVersion";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_VERSION)
  private String maintenanceVersion;

  public static final String SERIALIZED_NAME_MASTER_INSTANCE_NAME = "masterInstanceName";
  @SerializedName(SERIALIZED_NAME_MASTER_INSTANCE_NAME)
  private String masterInstanceName;

  public static final String SERIALIZED_NAME_MAX_DISK_SIZE = "maxDiskSize";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_MAX_DISK_SIZE)
  private String maxDiskSize;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_ON_PREMISES_CONFIGURATION = "onPremisesConfiguration";
  @SerializedName(SERIALIZED_NAME_ON_PREMISES_CONFIGURATION)
  private OnPremisesConfiguration onPremisesConfiguration;

  public static final String SERIALIZED_NAME_OUT_OF_DISK_REPORT = "outOfDiskReport";
  @SerializedName(SERIALIZED_NAME_OUT_OF_DISK_REPORT)
  private SqlOutOfDiskReport outOfDiskReport;

  public static final String SERIALIZED_NAME_PRIMARY_DNS_NAME = "primaryDnsName";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_PRIMARY_DNS_NAME)
  private String primaryDnsName;

  public static final String SERIALIZED_NAME_PROJECT = "project";
  @SerializedName(SERIALIZED_NAME_PROJECT)
  private String project;

  public static final String SERIALIZED_NAME_PSC_SERVICE_ATTACHMENT_LINK = "pscServiceAttachmentLink";
  @SerializedName(SERIALIZED_NAME_PSC_SERVICE_ATTACHMENT_LINK)
  private String pscServiceAttachmentLink;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  private String region;

  public static final String SERIALIZED_NAME_REPLICA_CONFIGURATION = "replicaConfiguration";
  @SerializedName(SERIALIZED_NAME_REPLICA_CONFIGURATION)
  private ReplicaConfiguration replicaConfiguration;

  public static final String SERIALIZED_NAME_REPLICA_NAMES = "replicaNames";
  @SerializedName(SERIALIZED_NAME_REPLICA_NAMES)
  private List<String> replicaNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_ROOT_PASSWORD = "rootPassword";
  @SerializedName(SERIALIZED_NAME_ROOT_PASSWORD)
  private String rootPassword;

  public static final String SERIALIZED_NAME_SATISFIES_PZS = "satisfiesPzs";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZS)
  private Boolean satisfiesPzs;

  public static final String SERIALIZED_NAME_SCHEDULED_MAINTENANCE = "scheduledMaintenance";
  @SerializedName(SERIALIZED_NAME_SCHEDULED_MAINTENANCE)
  private SqlScheduledMaintenance scheduledMaintenance;

  public static final String SERIALIZED_NAME_SECONDARY_GCE_ZONE = "secondaryGceZone";
  @SerializedName(SERIALIZED_NAME_SECONDARY_GCE_ZONE)
  private String secondaryGceZone;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public static final String SERIALIZED_NAME_SERVER_CA_CERT = "serverCaCert";
  @SerializedName(SERIALIZED_NAME_SERVER_CA_CERT)
  private SslCert serverCaCert;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL_ADDRESS = "serviceAccountEmailAddress";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_EMAIL_ADDRESS)
  private String serviceAccountEmailAddress;

  public static final String SERIALIZED_NAME_SETTINGS = "settings";
  @SerializedName(SERIALIZED_NAME_SETTINGS)
  private Settings settings;

  /**
   * The SQL network architecture for the instance.
   */
  @JsonAdapter(SqlNetworkArchitectureEnum.Adapter.class)
  public enum SqlNetworkArchitectureEnum {
    SQL_NETWORK_ARCHITECTURE_UNSPECIFIED("SQL_NETWORK_ARCHITECTURE_UNSPECIFIED"),
    
    NEW_NETWORK_ARCHITECTURE("NEW_NETWORK_ARCHITECTURE"),
    
    OLD_NETWORK_ARCHITECTURE("OLD_NETWORK_ARCHITECTURE");

    private String value;

    SqlNetworkArchitectureEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SqlNetworkArchitectureEnum fromValue(String value) {
      for (SqlNetworkArchitectureEnum b : SqlNetworkArchitectureEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SqlNetworkArchitectureEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SqlNetworkArchitectureEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SqlNetworkArchitectureEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SqlNetworkArchitectureEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SqlNetworkArchitectureEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SQL_NETWORK_ARCHITECTURE = "sqlNetworkArchitecture";
  @SerializedName(SERIALIZED_NAME_SQL_NETWORK_ARCHITECTURE)
  private SqlNetworkArchitectureEnum sqlNetworkArchitecture;

  /**
   * The current serving state of the Cloud SQL instance.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    SQL_INSTANCE_STATE_UNSPECIFIED("SQL_INSTANCE_STATE_UNSPECIFIED"),
    
    RUNNABLE("RUNNABLE"),
    
    SUSPENDED("SUSPENDED"),
    
    PENDING_DELETE("PENDING_DELETE"),
    
    PENDING_CREATE("PENDING_CREATE"),
    
    MAINTENANCE("MAINTENANCE"),
    
    FAILED("FAILED"),
    
    ONLINE_MAINTENANCE("ONLINE_MAINTENANCE");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  /**
   * Gets or Sets suspensionReason
   */
  @JsonAdapter(SuspensionReasonEnum.Adapter.class)
  public enum SuspensionReasonEnum {
    SQL_SUSPENSION_REASON_UNSPECIFIED("SQL_SUSPENSION_REASON_UNSPECIFIED"),
    
    BILLING_ISSUE("BILLING_ISSUE"),
    
    LEGAL_ISSUE("LEGAL_ISSUE"),
    
    OPERATIONAL_ISSUE("OPERATIONAL_ISSUE"),
    
    KMS_KEY_ISSUE("KMS_KEY_ISSUE");

    private String value;

    SuspensionReasonEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SuspensionReasonEnum fromValue(String value) {
      for (SuspensionReasonEnum b : SuspensionReasonEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SuspensionReasonEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SuspensionReasonEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SuspensionReasonEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SuspensionReasonEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SuspensionReasonEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUSPENSION_REASON = "suspensionReason";
  @SerializedName(SERIALIZED_NAME_SUSPENSION_REASON)
  private List<SuspensionReasonEnum> suspensionReason = new ArrayList<>();

  public static final String SERIALIZED_NAME_WRITE_ENDPOINT = "writeEndpoint";
  @SerializedName(SERIALIZED_NAME_WRITE_ENDPOINT)
  private String writeEndpoint;

  public DatabaseInstance() {
  }

  public DatabaseInstance(
     List<String> availableMaintenanceVersions, 
     String createTime, 
     String databaseInstalledVersion, 
     String dnsName, 
     String primaryDnsName, 
     String pscServiceAttachmentLink, 
     String writeEndpoint
  ) {
    this();
    this.availableMaintenanceVersions = availableMaintenanceVersions;
    this.createTime = createTime;
    this.databaseInstalledVersion = databaseInstalledVersion;
    this.dnsName = dnsName;
    this.primaryDnsName = primaryDnsName;
    this.pscServiceAttachmentLink = pscServiceAttachmentLink;
    this.writeEndpoint = writeEndpoint;
  }

  /**
   * Output only. List all maintenance versions applicable on the instance
   * @return availableMaintenanceVersions
   */
  @javax.annotation.Nullable
  public List<String> getAvailableMaintenanceVersions() {
    return availableMaintenanceVersions;
  }



  public DatabaseInstance backendType(BackendTypeEnum backendType) {
    this.backendType = backendType;
    return this;
  }

  /**
   * The backend type. &#x60;SECOND_GEN&#x60;: Cloud SQL database instance. &#x60;EXTERNAL&#x60;: A database server that is not managed by Google. This property is read-only; use the &#x60;tier&#x60; property in the &#x60;settings&#x60; object to determine the database type.
   * @return backendType
   */
  @javax.annotation.Nullable
  public BackendTypeEnum getBackendType() {
    return backendType;
  }

  public void setBackendType(BackendTypeEnum backendType) {
    this.backendType = backendType;
  }


  public DatabaseInstance connectionName(String connectionName) {
    this.connectionName = connectionName;
    return this;
  }

  /**
   * Connection name of the Cloud SQL instance used in connection strings.
   * @return connectionName
   */
  @javax.annotation.Nullable
  public String getConnectionName() {
    return connectionName;
  }

  public void setConnectionName(String connectionName) {
    this.connectionName = connectionName;
  }


  /**
   * Output only. The time when the instance was created in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example &#x60;2012-11-15T16:19:00.094Z&#x60;.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  @Deprecated
  public DatabaseInstance currentDiskSize(String currentDiskSize) {
    this.currentDiskSize = currentDiskSize;
    return this;
  }

  /**
   * The current disk usage of the instance in bytes. This property has been deprecated. Use the \&quot;cloudsql.googleapis.com/database/disk/bytes_used\&quot; metric in Cloud Monitoring API instead. Please see [this announcement](https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ) for details.
   * @return currentDiskSize
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getCurrentDiskSize() {
    return currentDiskSize;
  }

  @Deprecated
  public void setCurrentDiskSize(String currentDiskSize) {
    this.currentDiskSize = currentDiskSize;
  }


  /**
   * Output only. Stores the current database version running on the instance including minor version such as &#x60;MYSQL_8_0_18&#x60;.
   * @return databaseInstalledVersion
   */
  @javax.annotation.Nullable
  public String getDatabaseInstalledVersion() {
    return databaseInstalledVersion;
  }



  public DatabaseInstance databaseVersion(DatabaseVersionEnum databaseVersion) {
    this.databaseVersion = databaseVersion;
    return this;
  }

  /**
   * The database engine type and version. The &#x60;databaseVersion&#x60; field cannot be changed after instance creation.
   * @return databaseVersion
   */
  @javax.annotation.Nullable
  public DatabaseVersionEnum getDatabaseVersion() {
    return databaseVersion;
  }

  public void setDatabaseVersion(DatabaseVersionEnum databaseVersion) {
    this.databaseVersion = databaseVersion;
  }


  public DatabaseInstance diskEncryptionConfiguration(DiskEncryptionConfiguration diskEncryptionConfiguration) {
    this.diskEncryptionConfiguration = diskEncryptionConfiguration;
    return this;
  }

  /**
   * Get diskEncryptionConfiguration
   * @return diskEncryptionConfiguration
   */
  @javax.annotation.Nullable
  public DiskEncryptionConfiguration getDiskEncryptionConfiguration() {
    return diskEncryptionConfiguration;
  }

  public void setDiskEncryptionConfiguration(DiskEncryptionConfiguration diskEncryptionConfiguration) {
    this.diskEncryptionConfiguration = diskEncryptionConfiguration;
  }


  public DatabaseInstance diskEncryptionStatus(DiskEncryptionStatus diskEncryptionStatus) {
    this.diskEncryptionStatus = diskEncryptionStatus;
    return this;
  }

  /**
   * Get diskEncryptionStatus
   * @return diskEncryptionStatus
   */
  @javax.annotation.Nullable
  public DiskEncryptionStatus getDiskEncryptionStatus() {
    return diskEncryptionStatus;
  }

  public void setDiskEncryptionStatus(DiskEncryptionStatus diskEncryptionStatus) {
    this.diskEncryptionStatus = diskEncryptionStatus;
  }


  /**
   * Output only. The dns name of the instance.
   * @return dnsName
   */
  @javax.annotation.Nullable
  public String getDnsName() {
    return dnsName;
  }



  public DatabaseInstance etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * This field is deprecated and will be removed from a future version of the API. Use the &#x60;settings.settingsVersion&#x60; field instead.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public DatabaseInstance failoverReplica(DatabaseInstanceFailoverReplica failoverReplica) {
    this.failoverReplica = failoverReplica;
    return this;
  }

  /**
   * Get failoverReplica
   * @return failoverReplica
   */
  @javax.annotation.Nullable
  public DatabaseInstanceFailoverReplica getFailoverReplica() {
    return failoverReplica;
  }

  public void setFailoverReplica(DatabaseInstanceFailoverReplica failoverReplica) {
    this.failoverReplica = failoverReplica;
  }


  public DatabaseInstance gceZone(String gceZone) {
    this.gceZone = gceZone;
    return this;
  }

  /**
   * The Compute Engine zone that the instance is currently serving from. This value could be different from the zone that was specified when the instance was created if the instance has failed over to its secondary zone. WARNING: Changing this might restart the instance.
   * @return gceZone
   */
  @javax.annotation.Nullable
  public String getGceZone() {
    return gceZone;
  }

  public void setGceZone(String gceZone) {
    this.gceZone = gceZone;
  }


  public DatabaseInstance instanceType(InstanceTypeEnum instanceType) {
    this.instanceType = instanceType;
    return this;
  }

  /**
   * The instance type.
   * @return instanceType
   */
  @javax.annotation.Nullable
  public InstanceTypeEnum getInstanceType() {
    return instanceType;
  }

  public void setInstanceType(InstanceTypeEnum instanceType) {
    this.instanceType = instanceType;
  }


  public DatabaseInstance ipAddresses(List<IpMapping> ipAddresses) {
    this.ipAddresses = ipAddresses;
    return this;
  }

  public DatabaseInstance addIpAddressesItem(IpMapping ipAddressesItem) {
    if (this.ipAddresses == null) {
      this.ipAddresses = new ArrayList<>();
    }
    this.ipAddresses.add(ipAddressesItem);
    return this;
  }

  /**
   * The assigned IP addresses for the instance.
   * @return ipAddresses
   */
  @javax.annotation.Nullable
  public List<IpMapping> getIpAddresses() {
    return ipAddresses;
  }

  public void setIpAddresses(List<IpMapping> ipAddresses) {
    this.ipAddresses = ipAddresses;
  }


  @Deprecated
  public DatabaseInstance ipv6Address(String ipv6Address) {
    this.ipv6Address = ipv6Address;
    return this;
  }

  /**
   * The IPv6 address assigned to the instance. (Deprecated) This property was applicable only to First Generation instances.
   * @return ipv6Address
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getIpv6Address() {
    return ipv6Address;
  }

  @Deprecated
  public void setIpv6Address(String ipv6Address) {
    this.ipv6Address = ipv6Address;
  }


  public DatabaseInstance kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * This is always &#x60;sql#instance&#x60;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public DatabaseInstance maintenanceVersion(String maintenanceVersion) {
    this.maintenanceVersion = maintenanceVersion;
    return this;
  }

  /**
   * The current software version on the instance.
   * @return maintenanceVersion
   */
  @javax.annotation.Nullable
  public String getMaintenanceVersion() {
    return maintenanceVersion;
  }

  public void setMaintenanceVersion(String maintenanceVersion) {
    this.maintenanceVersion = maintenanceVersion;
  }


  public DatabaseInstance masterInstanceName(String masterInstanceName) {
    this.masterInstanceName = masterInstanceName;
    return this;
  }

  /**
   * The name of the instance which will act as primary in the replication setup.
   * @return masterInstanceName
   */
  @javax.annotation.Nullable
  public String getMasterInstanceName() {
    return masterInstanceName;
  }

  public void setMasterInstanceName(String masterInstanceName) {
    this.masterInstanceName = masterInstanceName;
  }


  @Deprecated
  public DatabaseInstance maxDiskSize(String maxDiskSize) {
    this.maxDiskSize = maxDiskSize;
    return this;
  }

  /**
   * The maximum disk size of the instance in bytes.
   * @return maxDiskSize
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getMaxDiskSize() {
    return maxDiskSize;
  }

  @Deprecated
  public void setMaxDiskSize(String maxDiskSize) {
    this.maxDiskSize = maxDiskSize;
  }


  public DatabaseInstance name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the Cloud SQL instance. This does not include the project ID.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public DatabaseInstance onPremisesConfiguration(OnPremisesConfiguration onPremisesConfiguration) {
    this.onPremisesConfiguration = onPremisesConfiguration;
    return this;
  }

  /**
   * Get onPremisesConfiguration
   * @return onPremisesConfiguration
   */
  @javax.annotation.Nullable
  public OnPremisesConfiguration getOnPremisesConfiguration() {
    return onPremisesConfiguration;
  }

  public void setOnPremisesConfiguration(OnPremisesConfiguration onPremisesConfiguration) {
    this.onPremisesConfiguration = onPremisesConfiguration;
  }


  public DatabaseInstance outOfDiskReport(SqlOutOfDiskReport outOfDiskReport) {
    this.outOfDiskReport = outOfDiskReport;
    return this;
  }

  /**
   * Get outOfDiskReport
   * @return outOfDiskReport
   */
  @javax.annotation.Nullable
  public SqlOutOfDiskReport getOutOfDiskReport() {
    return outOfDiskReport;
  }

  public void setOutOfDiskReport(SqlOutOfDiskReport outOfDiskReport) {
    this.outOfDiskReport = outOfDiskReport;
  }


  /**
   * Output only. DEPRECATED: please use write_endpoint instead.
   * @return primaryDnsName
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getPrimaryDnsName() {
    return primaryDnsName;
  }



  public DatabaseInstance project(String project) {
    this.project = project;
    return this;
  }

  /**
   * The project ID of the project containing the Cloud SQL instance. The Google apps domain is prefixed if applicable.
   * @return project
   */
  @javax.annotation.Nullable
  public String getProject() {
    return project;
  }

  public void setProject(String project) {
    this.project = project;
  }


  /**
   * Output only. The link to service attachment of PSC instance.
   * @return pscServiceAttachmentLink
   */
  @javax.annotation.Nullable
  public String getPscServiceAttachmentLink() {
    return pscServiceAttachmentLink;
  }



  public DatabaseInstance region(String region) {
    this.region = region;
    return this;
  }

  /**
   * The geographical region of the Cloud SQL instance. It can be one of the [regions](https://cloud.google.com/sql/docs/mysql/locations#location-r) where Cloud SQL operates: For example, &#x60;asia-east1&#x60;, &#x60;europe-west1&#x60;, and &#x60;us-central1&#x60;. The default value is &#x60;us-central1&#x60;.
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(String region) {
    this.region = region;
  }


  public DatabaseInstance replicaConfiguration(ReplicaConfiguration replicaConfiguration) {
    this.replicaConfiguration = replicaConfiguration;
    return this;
  }

  /**
   * Get replicaConfiguration
   * @return replicaConfiguration
   */
  @javax.annotation.Nullable
  public ReplicaConfiguration getReplicaConfiguration() {
    return replicaConfiguration;
  }

  public void setReplicaConfiguration(ReplicaConfiguration replicaConfiguration) {
    this.replicaConfiguration = replicaConfiguration;
  }


  public DatabaseInstance replicaNames(List<String> replicaNames) {
    this.replicaNames = replicaNames;
    return this;
  }

  public DatabaseInstance addReplicaNamesItem(String replicaNamesItem) {
    if (this.replicaNames == null) {
      this.replicaNames = new ArrayList<>();
    }
    this.replicaNames.add(replicaNamesItem);
    return this;
  }

  /**
   * The replicas of the instance.
   * @return replicaNames
   */
  @javax.annotation.Nullable
  public List<String> getReplicaNames() {
    return replicaNames;
  }

  public void setReplicaNames(List<String> replicaNames) {
    this.replicaNames = replicaNames;
  }


  public DatabaseInstance rootPassword(String rootPassword) {
    this.rootPassword = rootPassword;
    return this;
  }

  /**
   * Initial root password. Use only on creation. You must set root passwords before you can connect to PostgreSQL instances.
   * @return rootPassword
   */
  @javax.annotation.Nullable
  public String getRootPassword() {
    return rootPassword;
  }

  public void setRootPassword(String rootPassword) {
    this.rootPassword = rootPassword;
  }


  public DatabaseInstance satisfiesPzs(Boolean satisfiesPzs) {
    this.satisfiesPzs = satisfiesPzs;
    return this;
  }

  /**
   * The status indicating if instance satisfiesPzs. Reserved for future use.
   * @return satisfiesPzs
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzs() {
    return satisfiesPzs;
  }

  public void setSatisfiesPzs(Boolean satisfiesPzs) {
    this.satisfiesPzs = satisfiesPzs;
  }


  public DatabaseInstance scheduledMaintenance(SqlScheduledMaintenance scheduledMaintenance) {
    this.scheduledMaintenance = scheduledMaintenance;
    return this;
  }

  /**
   * Get scheduledMaintenance
   * @return scheduledMaintenance
   */
  @javax.annotation.Nullable
  public SqlScheduledMaintenance getScheduledMaintenance() {
    return scheduledMaintenance;
  }

  public void setScheduledMaintenance(SqlScheduledMaintenance scheduledMaintenance) {
    this.scheduledMaintenance = scheduledMaintenance;
  }


  public DatabaseInstance secondaryGceZone(String secondaryGceZone) {
    this.secondaryGceZone = secondaryGceZone;
    return this;
  }

  /**
   * The Compute Engine zone that the failover instance is currently serving from for a regional instance. This value could be different from the zone that was specified when the instance was created if the instance has failed over to its secondary/failover zone.
   * @return secondaryGceZone
   */
  @javax.annotation.Nullable
  public String getSecondaryGceZone() {
    return secondaryGceZone;
  }

  public void setSecondaryGceZone(String secondaryGceZone) {
    this.secondaryGceZone = secondaryGceZone;
  }


  public DatabaseInstance selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * The URI of this resource.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }


  public DatabaseInstance serverCaCert(SslCert serverCaCert) {
    this.serverCaCert = serverCaCert;
    return this;
  }

  /**
   * Get serverCaCert
   * @return serverCaCert
   */
  @javax.annotation.Nullable
  public SslCert getServerCaCert() {
    return serverCaCert;
  }

  public void setServerCaCert(SslCert serverCaCert) {
    this.serverCaCert = serverCaCert;
  }


  public DatabaseInstance serviceAccountEmailAddress(String serviceAccountEmailAddress) {
    this.serviceAccountEmailAddress = serviceAccountEmailAddress;
    return this;
  }

  /**
   * The service account email address assigned to the instance. \\This property is read-only.
   * @return serviceAccountEmailAddress
   */
  @javax.annotation.Nullable
  public String getServiceAccountEmailAddress() {
    return serviceAccountEmailAddress;
  }

  public void setServiceAccountEmailAddress(String serviceAccountEmailAddress) {
    this.serviceAccountEmailAddress = serviceAccountEmailAddress;
  }


  public DatabaseInstance settings(Settings settings) {
    this.settings = settings;
    return this;
  }

  /**
   * Get settings
   * @return settings
   */
  @javax.annotation.Nullable
  public Settings getSettings() {
    return settings;
  }

  public void setSettings(Settings settings) {
    this.settings = settings;
  }


  public DatabaseInstance sqlNetworkArchitecture(SqlNetworkArchitectureEnum sqlNetworkArchitecture) {
    this.sqlNetworkArchitecture = sqlNetworkArchitecture;
    return this;
  }

  /**
   * The SQL network architecture for the instance.
   * @return sqlNetworkArchitecture
   */
  @javax.annotation.Nullable
  public SqlNetworkArchitectureEnum getSqlNetworkArchitecture() {
    return sqlNetworkArchitecture;
  }

  public void setSqlNetworkArchitecture(SqlNetworkArchitectureEnum sqlNetworkArchitecture) {
    this.sqlNetworkArchitecture = sqlNetworkArchitecture;
  }


  public DatabaseInstance state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * The current serving state of the Cloud SQL instance.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public DatabaseInstance suspensionReason(List<SuspensionReasonEnum> suspensionReason) {
    this.suspensionReason = suspensionReason;
    return this;
  }

  public DatabaseInstance addSuspensionReasonItem(SuspensionReasonEnum suspensionReasonItem) {
    if (this.suspensionReason == null) {
      this.suspensionReason = new ArrayList<>();
    }
    this.suspensionReason.add(suspensionReasonItem);
    return this;
  }

  /**
   * If the instance state is SUSPENDED, the reason for the suspension.
   * @return suspensionReason
   */
  @javax.annotation.Nullable
  public List<SuspensionReasonEnum> getSuspensionReason() {
    return suspensionReason;
  }

  public void setSuspensionReason(List<SuspensionReasonEnum> suspensionReason) {
    this.suspensionReason = suspensionReason;
  }


  /**
   * Output only. The dns name of the primary instance in a replication group.
   * @return writeEndpoint
   */
  @javax.annotation.Nullable
  public String getWriteEndpoint() {
    return writeEndpoint;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DatabaseInstance databaseInstance = (DatabaseInstance) o;
    return Objects.equals(this.availableMaintenanceVersions, databaseInstance.availableMaintenanceVersions) &&
        Objects.equals(this.backendType, databaseInstance.backendType) &&
        Objects.equals(this.connectionName, databaseInstance.connectionName) &&
        Objects.equals(this.createTime, databaseInstance.createTime) &&
        Objects.equals(this.currentDiskSize, databaseInstance.currentDiskSize) &&
        Objects.equals(this.databaseInstalledVersion, databaseInstance.databaseInstalledVersion) &&
        Objects.equals(this.databaseVersion, databaseInstance.databaseVersion) &&
        Objects.equals(this.diskEncryptionConfiguration, databaseInstance.diskEncryptionConfiguration) &&
        Objects.equals(this.diskEncryptionStatus, databaseInstance.diskEncryptionStatus) &&
        Objects.equals(this.dnsName, databaseInstance.dnsName) &&
        Objects.equals(this.etag, databaseInstance.etag) &&
        Objects.equals(this.failoverReplica, databaseInstance.failoverReplica) &&
        Objects.equals(this.gceZone, databaseInstance.gceZone) &&
        Objects.equals(this.instanceType, databaseInstance.instanceType) &&
        Objects.equals(this.ipAddresses, databaseInstance.ipAddresses) &&
        Objects.equals(this.ipv6Address, databaseInstance.ipv6Address) &&
        Objects.equals(this.kind, databaseInstance.kind) &&
        Objects.equals(this.maintenanceVersion, databaseInstance.maintenanceVersion) &&
        Objects.equals(this.masterInstanceName, databaseInstance.masterInstanceName) &&
        Objects.equals(this.maxDiskSize, databaseInstance.maxDiskSize) &&
        Objects.equals(this.name, databaseInstance.name) &&
        Objects.equals(this.onPremisesConfiguration, databaseInstance.onPremisesConfiguration) &&
        Objects.equals(this.outOfDiskReport, databaseInstance.outOfDiskReport) &&
        Objects.equals(this.primaryDnsName, databaseInstance.primaryDnsName) &&
        Objects.equals(this.project, databaseInstance.project) &&
        Objects.equals(this.pscServiceAttachmentLink, databaseInstance.pscServiceAttachmentLink) &&
        Objects.equals(this.region, databaseInstance.region) &&
        Objects.equals(this.replicaConfiguration, databaseInstance.replicaConfiguration) &&
        Objects.equals(this.replicaNames, databaseInstance.replicaNames) &&
        Objects.equals(this.rootPassword, databaseInstance.rootPassword) &&
        Objects.equals(this.satisfiesPzs, databaseInstance.satisfiesPzs) &&
        Objects.equals(this.scheduledMaintenance, databaseInstance.scheduledMaintenance) &&
        Objects.equals(this.secondaryGceZone, databaseInstance.secondaryGceZone) &&
        Objects.equals(this.selfLink, databaseInstance.selfLink) &&
        Objects.equals(this.serverCaCert, databaseInstance.serverCaCert) &&
        Objects.equals(this.serviceAccountEmailAddress, databaseInstance.serviceAccountEmailAddress) &&
        Objects.equals(this.settings, databaseInstance.settings) &&
        Objects.equals(this.sqlNetworkArchitecture, databaseInstance.sqlNetworkArchitecture) &&
        Objects.equals(this.state, databaseInstance.state) &&
        Objects.equals(this.suspensionReason, databaseInstance.suspensionReason) &&
        Objects.equals(this.writeEndpoint, databaseInstance.writeEndpoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableMaintenanceVersions, backendType, connectionName, createTime, currentDiskSize, databaseInstalledVersion, databaseVersion, diskEncryptionConfiguration, diskEncryptionStatus, dnsName, etag, failoverReplica, gceZone, instanceType, ipAddresses, ipv6Address, kind, maintenanceVersion, masterInstanceName, maxDiskSize, name, onPremisesConfiguration, outOfDiskReport, primaryDnsName, project, pscServiceAttachmentLink, region, replicaConfiguration, replicaNames, rootPassword, satisfiesPzs, scheduledMaintenance, secondaryGceZone, selfLink, serverCaCert, serviceAccountEmailAddress, settings, sqlNetworkArchitecture, state, suspensionReason, writeEndpoint);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DatabaseInstance {\n");
    sb.append("    availableMaintenanceVersions: ").append(toIndentedString(availableMaintenanceVersions)).append("\n");
    sb.append("    backendType: ").append(toIndentedString(backendType)).append("\n");
    sb.append("    connectionName: ").append(toIndentedString(connectionName)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    currentDiskSize: ").append(toIndentedString(currentDiskSize)).append("\n");
    sb.append("    databaseInstalledVersion: ").append(toIndentedString(databaseInstalledVersion)).append("\n");
    sb.append("    databaseVersion: ").append(toIndentedString(databaseVersion)).append("\n");
    sb.append("    diskEncryptionConfiguration: ").append(toIndentedString(diskEncryptionConfiguration)).append("\n");
    sb.append("    diskEncryptionStatus: ").append(toIndentedString(diskEncryptionStatus)).append("\n");
    sb.append("    dnsName: ").append(toIndentedString(dnsName)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    failoverReplica: ").append(toIndentedString(failoverReplica)).append("\n");
    sb.append("    gceZone: ").append(toIndentedString(gceZone)).append("\n");
    sb.append("    instanceType: ").append(toIndentedString(instanceType)).append("\n");
    sb.append("    ipAddresses: ").append(toIndentedString(ipAddresses)).append("\n");
    sb.append("    ipv6Address: ").append(toIndentedString(ipv6Address)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    maintenanceVersion: ").append(toIndentedString(maintenanceVersion)).append("\n");
    sb.append("    masterInstanceName: ").append(toIndentedString(masterInstanceName)).append("\n");
    sb.append("    maxDiskSize: ").append(toIndentedString(maxDiskSize)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    onPremisesConfiguration: ").append(toIndentedString(onPremisesConfiguration)).append("\n");
    sb.append("    outOfDiskReport: ").append(toIndentedString(outOfDiskReport)).append("\n");
    sb.append("    primaryDnsName: ").append(toIndentedString(primaryDnsName)).append("\n");
    sb.append("    project: ").append(toIndentedString(project)).append("\n");
    sb.append("    pscServiceAttachmentLink: ").append(toIndentedString(pscServiceAttachmentLink)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    replicaConfiguration: ").append(toIndentedString(replicaConfiguration)).append("\n");
    sb.append("    replicaNames: ").append(toIndentedString(replicaNames)).append("\n");
    sb.append("    rootPassword: ").append(toIndentedString(rootPassword)).append("\n");
    sb.append("    satisfiesPzs: ").append(toIndentedString(satisfiesPzs)).append("\n");
    sb.append("    scheduledMaintenance: ").append(toIndentedString(scheduledMaintenance)).append("\n");
    sb.append("    secondaryGceZone: ").append(toIndentedString(secondaryGceZone)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    serverCaCert: ").append(toIndentedString(serverCaCert)).append("\n");
    sb.append("    serviceAccountEmailAddress: ").append(toIndentedString(serviceAccountEmailAddress)).append("\n");
    sb.append("    settings: ").append(toIndentedString(settings)).append("\n");
    sb.append("    sqlNetworkArchitecture: ").append(toIndentedString(sqlNetworkArchitecture)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    suspensionReason: ").append(toIndentedString(suspensionReason)).append("\n");
    sb.append("    writeEndpoint: ").append(toIndentedString(writeEndpoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("availableMaintenanceVersions");
    openapiFields.add("backendType");
    openapiFields.add("connectionName");
    openapiFields.add("createTime");
    openapiFields.add("currentDiskSize");
    openapiFields.add("databaseInstalledVersion");
    openapiFields.add("databaseVersion");
    openapiFields.add("diskEncryptionConfiguration");
    openapiFields.add("diskEncryptionStatus");
    openapiFields.add("dnsName");
    openapiFields.add("etag");
    openapiFields.add("failoverReplica");
    openapiFields.add("gceZone");
    openapiFields.add("instanceType");
    openapiFields.add("ipAddresses");
    openapiFields.add("ipv6Address");
    openapiFields.add("kind");
    openapiFields.add("maintenanceVersion");
    openapiFields.add("masterInstanceName");
    openapiFields.add("maxDiskSize");
    openapiFields.add("name");
    openapiFields.add("onPremisesConfiguration");
    openapiFields.add("outOfDiskReport");
    openapiFields.add("primaryDnsName");
    openapiFields.add("project");
    openapiFields.add("pscServiceAttachmentLink");
    openapiFields.add("region");
    openapiFields.add("replicaConfiguration");
    openapiFields.add("replicaNames");
    openapiFields.add("rootPassword");
    openapiFields.add("satisfiesPzs");
    openapiFields.add("scheduledMaintenance");
    openapiFields.add("secondaryGceZone");
    openapiFields.add("selfLink");
    openapiFields.add("serverCaCert");
    openapiFields.add("serviceAccountEmailAddress");
    openapiFields.add("settings");
    openapiFields.add("sqlNetworkArchitecture");
    openapiFields.add("state");
    openapiFields.add("suspensionReason");
    openapiFields.add("writeEndpoint");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DatabaseInstance
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DatabaseInstance.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DatabaseInstance is not found in the empty JSON string", DatabaseInstance.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DatabaseInstance.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DatabaseInstance` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("availableMaintenanceVersions") != null && !jsonObj.get("availableMaintenanceVersions").isJsonNull() && !jsonObj.get("availableMaintenanceVersions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableMaintenanceVersions` to be an array in the JSON string but got `%s`", jsonObj.get("availableMaintenanceVersions").toString()));
      }
      if ((jsonObj.get("backendType") != null && !jsonObj.get("backendType").isJsonNull()) && !jsonObj.get("backendType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backendType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backendType").toString()));
      }
      // validate the optional field `backendType`
      if (jsonObj.get("backendType") != null && !jsonObj.get("backendType").isJsonNull()) {
        BackendTypeEnum.validateJsonElement(jsonObj.get("backendType"));
      }
      if ((jsonObj.get("connectionName") != null && !jsonObj.get("connectionName").isJsonNull()) && !jsonObj.get("connectionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectionName").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("currentDiskSize") != null && !jsonObj.get("currentDiskSize").isJsonNull()) && !jsonObj.get("currentDiskSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currentDiskSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currentDiskSize").toString()));
      }
      if ((jsonObj.get("databaseInstalledVersion") != null && !jsonObj.get("databaseInstalledVersion").isJsonNull()) && !jsonObj.get("databaseInstalledVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseInstalledVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseInstalledVersion").toString()));
      }
      if ((jsonObj.get("databaseVersion") != null && !jsonObj.get("databaseVersion").isJsonNull()) && !jsonObj.get("databaseVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseVersion").toString()));
      }
      // validate the optional field `databaseVersion`
      if (jsonObj.get("databaseVersion") != null && !jsonObj.get("databaseVersion").isJsonNull()) {
        DatabaseVersionEnum.validateJsonElement(jsonObj.get("databaseVersion"));
      }
      // validate the optional field `diskEncryptionConfiguration`
      if (jsonObj.get("diskEncryptionConfiguration") != null && !jsonObj.get("diskEncryptionConfiguration").isJsonNull()) {
        DiskEncryptionConfiguration.validateJsonElement(jsonObj.get("diskEncryptionConfiguration"));
      }
      // validate the optional field `diskEncryptionStatus`
      if (jsonObj.get("diskEncryptionStatus") != null && !jsonObj.get("diskEncryptionStatus").isJsonNull()) {
        DiskEncryptionStatus.validateJsonElement(jsonObj.get("diskEncryptionStatus"));
      }
      if ((jsonObj.get("dnsName") != null && !jsonObj.get("dnsName").isJsonNull()) && !jsonObj.get("dnsName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dnsName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dnsName").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      // validate the optional field `failoverReplica`
      if (jsonObj.get("failoverReplica") != null && !jsonObj.get("failoverReplica").isJsonNull()) {
        DatabaseInstanceFailoverReplica.validateJsonElement(jsonObj.get("failoverReplica"));
      }
      if ((jsonObj.get("gceZone") != null && !jsonObj.get("gceZone").isJsonNull()) && !jsonObj.get("gceZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gceZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gceZone").toString()));
      }
      if ((jsonObj.get("instanceType") != null && !jsonObj.get("instanceType").isJsonNull()) && !jsonObj.get("instanceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instanceType").toString()));
      }
      // validate the optional field `instanceType`
      if (jsonObj.get("instanceType") != null && !jsonObj.get("instanceType").isJsonNull()) {
        InstanceTypeEnum.validateJsonElement(jsonObj.get("instanceType"));
      }
      if (jsonObj.get("ipAddresses") != null && !jsonObj.get("ipAddresses").isJsonNull()) {
        JsonArray jsonArrayipAddresses = jsonObj.getAsJsonArray("ipAddresses");
        if (jsonArrayipAddresses != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ipAddresses").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ipAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("ipAddresses").toString()));
          }

          // validate the optional field `ipAddresses` (array)
          for (int i = 0; i < jsonArrayipAddresses.size(); i++) {
            IpMapping.validateJsonElement(jsonArrayipAddresses.get(i));
          };
        }
      }
      if ((jsonObj.get("ipv6Address") != null && !jsonObj.get("ipv6Address").isJsonNull()) && !jsonObj.get("ipv6Address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipv6Address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipv6Address").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("maintenanceVersion") != null && !jsonObj.get("maintenanceVersion").isJsonNull()) && !jsonObj.get("maintenanceVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maintenanceVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maintenanceVersion").toString()));
      }
      if ((jsonObj.get("masterInstanceName") != null && !jsonObj.get("masterInstanceName").isJsonNull()) && !jsonObj.get("masterInstanceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `masterInstanceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("masterInstanceName").toString()));
      }
      if ((jsonObj.get("maxDiskSize") != null && !jsonObj.get("maxDiskSize").isJsonNull()) && !jsonObj.get("maxDiskSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxDiskSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxDiskSize").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `onPremisesConfiguration`
      if (jsonObj.get("onPremisesConfiguration") != null && !jsonObj.get("onPremisesConfiguration").isJsonNull()) {
        OnPremisesConfiguration.validateJsonElement(jsonObj.get("onPremisesConfiguration"));
      }
      // validate the optional field `outOfDiskReport`
      if (jsonObj.get("outOfDiskReport") != null && !jsonObj.get("outOfDiskReport").isJsonNull()) {
        SqlOutOfDiskReport.validateJsonElement(jsonObj.get("outOfDiskReport"));
      }
      if ((jsonObj.get("primaryDnsName") != null && !jsonObj.get("primaryDnsName").isJsonNull()) && !jsonObj.get("primaryDnsName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `primaryDnsName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("primaryDnsName").toString()));
      }
      if ((jsonObj.get("project") != null && !jsonObj.get("project").isJsonNull()) && !jsonObj.get("project").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `project` to be a primitive type in the JSON string but got `%s`", jsonObj.get("project").toString()));
      }
      if ((jsonObj.get("pscServiceAttachmentLink") != null && !jsonObj.get("pscServiceAttachmentLink").isJsonNull()) && !jsonObj.get("pscServiceAttachmentLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pscServiceAttachmentLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pscServiceAttachmentLink").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
      // validate the optional field `replicaConfiguration`
      if (jsonObj.get("replicaConfiguration") != null && !jsonObj.get("replicaConfiguration").isJsonNull()) {
        ReplicaConfiguration.validateJsonElement(jsonObj.get("replicaConfiguration"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("replicaNames") != null && !jsonObj.get("replicaNames").isJsonNull() && !jsonObj.get("replicaNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `replicaNames` to be an array in the JSON string but got `%s`", jsonObj.get("replicaNames").toString()));
      }
      if ((jsonObj.get("rootPassword") != null && !jsonObj.get("rootPassword").isJsonNull()) && !jsonObj.get("rootPassword").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rootPassword` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rootPassword").toString()));
      }
      // validate the optional field `scheduledMaintenance`
      if (jsonObj.get("scheduledMaintenance") != null && !jsonObj.get("scheduledMaintenance").isJsonNull()) {
        SqlScheduledMaintenance.validateJsonElement(jsonObj.get("scheduledMaintenance"));
      }
      if ((jsonObj.get("secondaryGceZone") != null && !jsonObj.get("secondaryGceZone").isJsonNull()) && !jsonObj.get("secondaryGceZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondaryGceZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondaryGceZone").toString()));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      // validate the optional field `serverCaCert`
      if (jsonObj.get("serverCaCert") != null && !jsonObj.get("serverCaCert").isJsonNull()) {
        SslCert.validateJsonElement(jsonObj.get("serverCaCert"));
      }
      if ((jsonObj.get("serviceAccountEmailAddress") != null && !jsonObj.get("serviceAccountEmailAddress").isJsonNull()) && !jsonObj.get("serviceAccountEmailAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountEmailAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountEmailAddress").toString()));
      }
      // validate the optional field `settings`
      if (jsonObj.get("settings") != null && !jsonObj.get("settings").isJsonNull()) {
        Settings.validateJsonElement(jsonObj.get("settings"));
      }
      if ((jsonObj.get("sqlNetworkArchitecture") != null && !jsonObj.get("sqlNetworkArchitecture").isJsonNull()) && !jsonObj.get("sqlNetworkArchitecture").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sqlNetworkArchitecture` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sqlNetworkArchitecture").toString()));
      }
      // validate the optional field `sqlNetworkArchitecture`
      if (jsonObj.get("sqlNetworkArchitecture") != null && !jsonObj.get("sqlNetworkArchitecture").isJsonNull()) {
        SqlNetworkArchitectureEnum.validateJsonElement(jsonObj.get("sqlNetworkArchitecture"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("suspensionReason") != null && !jsonObj.get("suspensionReason").isJsonNull() && !jsonObj.get("suspensionReason").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `suspensionReason` to be an array in the JSON string but got `%s`", jsonObj.get("suspensionReason").toString()));
      }
      if ((jsonObj.get("writeEndpoint") != null && !jsonObj.get("writeEndpoint").isJsonNull()) && !jsonObj.get("writeEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `writeEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("writeEndpoint").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DatabaseInstance.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DatabaseInstance' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DatabaseInstance> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DatabaseInstance.class));

       return (TypeAdapter<T>) new TypeAdapter<DatabaseInstance>() {
           @Override
           public void write(JsonWriter out, DatabaseInstance value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DatabaseInstance read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DatabaseInstance given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DatabaseInstance
   * @throws IOException if the JSON string is invalid with respect to DatabaseInstance
   */
  public static DatabaseInstance fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DatabaseInstance.class);
  }

  /**
   * Convert an instance of DatabaseInstance to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

