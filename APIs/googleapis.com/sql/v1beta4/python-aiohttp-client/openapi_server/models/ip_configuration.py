# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.acl_entry import AclEntry
from openapi_server.models.psc_config import PscConfig
from openapi_server import util


class IpConfiguration(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, allocated_ip_range: str=None, authorized_networks: List[AclEntry]=None, enable_private_path_for_google_cloud_services: bool=None, ipv4_enabled: bool=None, private_network: str=None, psc_config: PscConfig=None, require_ssl: bool=None, ssl_mode: str=None):
        """IpConfiguration - a model defined in OpenAPI

        :param allocated_ip_range: The allocated_ip_range of this IpConfiguration.
        :param authorized_networks: The authorized_networks of this IpConfiguration.
        :param enable_private_path_for_google_cloud_services: The enable_private_path_for_google_cloud_services of this IpConfiguration.
        :param ipv4_enabled: The ipv4_enabled of this IpConfiguration.
        :param private_network: The private_network of this IpConfiguration.
        :param psc_config: The psc_config of this IpConfiguration.
        :param require_ssl: The require_ssl of this IpConfiguration.
        :param ssl_mode: The ssl_mode of this IpConfiguration.
        """
        self.openapi_types = {
            'allocated_ip_range': str,
            'authorized_networks': List[AclEntry],
            'enable_private_path_for_google_cloud_services': bool,
            'ipv4_enabled': bool,
            'private_network': str,
            'psc_config': PscConfig,
            'require_ssl': bool,
            'ssl_mode': str
        }

        self.attribute_map = {
            'allocated_ip_range': 'allocatedIpRange',
            'authorized_networks': 'authorizedNetworks',
            'enable_private_path_for_google_cloud_services': 'enablePrivatePathForGoogleCloudServices',
            'ipv4_enabled': 'ipv4Enabled',
            'private_network': 'privateNetwork',
            'psc_config': 'pscConfig',
            'require_ssl': 'requireSsl',
            'ssl_mode': 'sslMode'
        }

        self._allocated_ip_range = allocated_ip_range
        self._authorized_networks = authorized_networks
        self._enable_private_path_for_google_cloud_services = enable_private_path_for_google_cloud_services
        self._ipv4_enabled = ipv4_enabled
        self._private_network = private_network
        self._psc_config = psc_config
        self._require_ssl = require_ssl
        self._ssl_mode = ssl_mode

    @classmethod
    def from_dict(cls, dikt: dict) -> 'IpConfiguration':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The IpConfiguration of this IpConfiguration.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def allocated_ip_range(self):
        """Gets the allocated_ip_range of this IpConfiguration.

        The name of the allocated ip range for the private ip Cloud SQL instance. For example: \"google-managed-services-default\". If set, the instance ip will be created in the allocated range. The range name must comply with [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?.`

        :return: The allocated_ip_range of this IpConfiguration.
        :rtype: str
        """
        return self._allocated_ip_range

    @allocated_ip_range.setter
    def allocated_ip_range(self, allocated_ip_range):
        """Sets the allocated_ip_range of this IpConfiguration.

        The name of the allocated ip range for the private ip Cloud SQL instance. For example: \"google-managed-services-default\". If set, the instance ip will be created in the allocated range. The range name must comply with [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?.`

        :param allocated_ip_range: The allocated_ip_range of this IpConfiguration.
        :type allocated_ip_range: str
        """

        self._allocated_ip_range = allocated_ip_range

    @property
    def authorized_networks(self):
        """Gets the authorized_networks of this IpConfiguration.

        The list of external networks that are allowed to connect to the instance using the IP. In 'CIDR' notation, also known as 'slash' notation (for example: `157.197.200.0/24`).

        :return: The authorized_networks of this IpConfiguration.
        :rtype: List[AclEntry]
        """
        return self._authorized_networks

    @authorized_networks.setter
    def authorized_networks(self, authorized_networks):
        """Sets the authorized_networks of this IpConfiguration.

        The list of external networks that are allowed to connect to the instance using the IP. In 'CIDR' notation, also known as 'slash' notation (for example: `157.197.200.0/24`).

        :param authorized_networks: The authorized_networks of this IpConfiguration.
        :type authorized_networks: List[AclEntry]
        """

        self._authorized_networks = authorized_networks

    @property
    def enable_private_path_for_google_cloud_services(self):
        """Gets the enable_private_path_for_google_cloud_services of this IpConfiguration.

        Controls connectivity to private IP instances from Google services, such as BigQuery.

        :return: The enable_private_path_for_google_cloud_services of this IpConfiguration.
        :rtype: bool
        """
        return self._enable_private_path_for_google_cloud_services

    @enable_private_path_for_google_cloud_services.setter
    def enable_private_path_for_google_cloud_services(self, enable_private_path_for_google_cloud_services):
        """Sets the enable_private_path_for_google_cloud_services of this IpConfiguration.

        Controls connectivity to private IP instances from Google services, such as BigQuery.

        :param enable_private_path_for_google_cloud_services: The enable_private_path_for_google_cloud_services of this IpConfiguration.
        :type enable_private_path_for_google_cloud_services: bool
        """

        self._enable_private_path_for_google_cloud_services = enable_private_path_for_google_cloud_services

    @property
    def ipv4_enabled(self):
        """Gets the ipv4_enabled of this IpConfiguration.

        Whether the instance is assigned a public IP address or not.

        :return: The ipv4_enabled of this IpConfiguration.
        :rtype: bool
        """
        return self._ipv4_enabled

    @ipv4_enabled.setter
    def ipv4_enabled(self, ipv4_enabled):
        """Sets the ipv4_enabled of this IpConfiguration.

        Whether the instance is assigned a public IP address or not.

        :param ipv4_enabled: The ipv4_enabled of this IpConfiguration.
        :type ipv4_enabled: bool
        """

        self._ipv4_enabled = ipv4_enabled

    @property
    def private_network(self):
        """Gets the private_network of this IpConfiguration.

        The resource link for the VPC network from which the Cloud SQL instance is accessible for private IP. For example, `/projects/myProject/global/networks/default`. This setting can be updated, but it cannot be removed after it is set.

        :return: The private_network of this IpConfiguration.
        :rtype: str
        """
        return self._private_network

    @private_network.setter
    def private_network(self, private_network):
        """Sets the private_network of this IpConfiguration.

        The resource link for the VPC network from which the Cloud SQL instance is accessible for private IP. For example, `/projects/myProject/global/networks/default`. This setting can be updated, but it cannot be removed after it is set.

        :param private_network: The private_network of this IpConfiguration.
        :type private_network: str
        """

        self._private_network = private_network

    @property
    def psc_config(self):
        """Gets the psc_config of this IpConfiguration.


        :return: The psc_config of this IpConfiguration.
        :rtype: PscConfig
        """
        return self._psc_config

    @psc_config.setter
    def psc_config(self, psc_config):
        """Sets the psc_config of this IpConfiguration.


        :param psc_config: The psc_config of this IpConfiguration.
        :type psc_config: PscConfig
        """

        self._psc_config = psc_config

    @property
    def require_ssl(self):
        """Gets the require_ssl of this IpConfiguration.

        Use `ssl_mode` instead for MySQL and PostgreSQL. SQL Server uses this flag. Whether SSL/TLS connections over IP are enforced. If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections. For SSL/TLS connections, the client certificate won't be verified. If set to true, then only allow connections encrypted with SSL/TLS and with valid client certificates. If you want to enforce SSL/TLS without enforcing the requirement for valid client certificates, then use the `ssl_mode` flag instead of the legacy `require_ssl` flag.

        :return: The require_ssl of this IpConfiguration.
        :rtype: bool
        """
        return self._require_ssl

    @require_ssl.setter
    def require_ssl(self, require_ssl):
        """Sets the require_ssl of this IpConfiguration.

        Use `ssl_mode` instead for MySQL and PostgreSQL. SQL Server uses this flag. Whether SSL/TLS connections over IP are enforced. If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections. For SSL/TLS connections, the client certificate won't be verified. If set to true, then only allow connections encrypted with SSL/TLS and with valid client certificates. If you want to enforce SSL/TLS without enforcing the requirement for valid client certificates, then use the `ssl_mode` flag instead of the legacy `require_ssl` flag.

        :param require_ssl: The require_ssl of this IpConfiguration.
        :type require_ssl: bool
        """

        self._require_ssl = require_ssl

    @property
    def ssl_mode(self):
        """Gets the ssl_mode of this IpConfiguration.

        Specify how SSL/TLS is enforced in database connections. MySQL and PostgreSQL use the `ssl_mode` flag. If you must use the `require_ssl` flag for backward compatibility, then only the following value pairs are valid: * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false` * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false` * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true` The value of `ssl_mode` gets priority over the value of `require_ssl`. For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`, the `ssl_mode=ENCRYPTED_ONLY` means only accept SSL connections, while the `require_ssl=false` means accept both non-SSL and SSL connections. MySQL and PostgreSQL databases respect `ssl_mode` in this case and accept only SSL connections. SQL Server uses the `require_ssl` flag. You can set the value for this flag to `true` or `false`.

        :return: The ssl_mode of this IpConfiguration.
        :rtype: str
        """
        return self._ssl_mode

    @ssl_mode.setter
    def ssl_mode(self, ssl_mode):
        """Sets the ssl_mode of this IpConfiguration.

        Specify how SSL/TLS is enforced in database connections. MySQL and PostgreSQL use the `ssl_mode` flag. If you must use the `require_ssl` flag for backward compatibility, then only the following value pairs are valid: * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false` * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false` * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true` The value of `ssl_mode` gets priority over the value of `require_ssl`. For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`, the `ssl_mode=ENCRYPTED_ONLY` means only accept SSL connections, while the `require_ssl=false` means accept both non-SSL and SSL connections. MySQL and PostgreSQL databases respect `ssl_mode` in this case and accept only SSL connections. SQL Server uses the `require_ssl` flag. You can set the value for this flag to `true` or `false`.

        :param ssl_mode: The ssl_mode of this IpConfiguration.
        :type ssl_mode: str
        """
        allowed_values = ["SSL_MODE_UNSPECIFIED", "ALLOW_UNENCRYPTED_AND_ENCRYPTED", "ENCRYPTED_ONLY", "TRUSTED_CLIENT_CERTIFICATE_REQUIRED"]  # noqa: E501
        if ssl_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `ssl_mode` ({0}), must be one of {1}"
                .format(ssl_mode, allowed_values)
            )

        self._ssl_mode = ssl_mode
