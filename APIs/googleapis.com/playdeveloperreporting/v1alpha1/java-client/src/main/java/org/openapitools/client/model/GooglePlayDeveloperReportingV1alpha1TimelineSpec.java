/*
 * Google Play Developer Reporting API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GoogleTypeDateTime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specification of the time-related aggregation parameters of a timeline. Timelines have an aggregation period (&#x60;DAILY&#x60;, &#x60;HOURLY&#x60;, etc) which defines how events are aggregated in metrics. The points in a timeline are defined by the starting DateTime of the aggregation period. The duration is implicit in the AggregationPeriod. Hourly aggregation periods, when supported by a metric set, are always specified in UTC to avoid ambiguities around daylight saving time transitions, where an hour is skipped when adopting DST, and repeated when abandoning DST. For example, the timestamp &#39;2021-11-07 01:00:00 America/Los_Angeles&#39; is ambiguous since it can correspond to &#39;2021-11-07 08:00:00 UTC&#39; or &#39;2021-11-07 09:00:00 UTC&#39;. Daily aggregation periods require specifying a timezone which will determine the precise instants of the start and the end of the day. Not all metric sets support all timezones, so make sure to check which timezones are supported by the metric set you want to query.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:51:15.855761-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GooglePlayDeveloperReportingV1alpha1TimelineSpec {
  /**
   * Type of the aggregation period of the datapoints in the timeline. Intervals are identified by the date and time at the start of the interval.
   */
  @JsonAdapter(AggregationPeriodEnum.Adapter.class)
  public enum AggregationPeriodEnum {
    AGGREGATION_PERIOD_UNSPECIFIED("AGGREGATION_PERIOD_UNSPECIFIED"),
    
    HOURLY("HOURLY"),
    
    DAILY("DAILY"),
    
    FULL_RANGE("FULL_RANGE");

    private String value;

    AggregationPeriodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AggregationPeriodEnum fromValue(String value) {
      for (AggregationPeriodEnum b : AggregationPeriodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AggregationPeriodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AggregationPeriodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AggregationPeriodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AggregationPeriodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AggregationPeriodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AGGREGATION_PERIOD = "aggregationPeriod";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_PERIOD)
  private AggregationPeriodEnum aggregationPeriod;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private GoogleTypeDateTime endTime;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private GoogleTypeDateTime startTime;

  public GooglePlayDeveloperReportingV1alpha1TimelineSpec() {
  }

  public GooglePlayDeveloperReportingV1alpha1TimelineSpec aggregationPeriod(AggregationPeriodEnum aggregationPeriod) {
    this.aggregationPeriod = aggregationPeriod;
    return this;
  }

  /**
   * Type of the aggregation period of the datapoints in the timeline. Intervals are identified by the date and time at the start of the interval.
   * @return aggregationPeriod
   */
  @javax.annotation.Nullable
  public AggregationPeriodEnum getAggregationPeriod() {
    return aggregationPeriod;
  }

  public void setAggregationPeriod(AggregationPeriodEnum aggregationPeriod) {
    this.aggregationPeriod = aggregationPeriod;
  }


  public GooglePlayDeveloperReportingV1alpha1TimelineSpec endTime(GoogleTypeDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Get endTime
   * @return endTime
   */
  @javax.annotation.Nullable
  public GoogleTypeDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(GoogleTypeDateTime endTime) {
    this.endTime = endTime;
  }


  public GooglePlayDeveloperReportingV1alpha1TimelineSpec startTime(GoogleTypeDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Get startTime
   * @return startTime
   */
  @javax.annotation.Nullable
  public GoogleTypeDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(GoogleTypeDateTime startTime) {
    this.startTime = startTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GooglePlayDeveloperReportingV1alpha1TimelineSpec googlePlayDeveloperReportingV1alpha1TimelineSpec = (GooglePlayDeveloperReportingV1alpha1TimelineSpec) o;
    return Objects.equals(this.aggregationPeriod, googlePlayDeveloperReportingV1alpha1TimelineSpec.aggregationPeriod) &&
        Objects.equals(this.endTime, googlePlayDeveloperReportingV1alpha1TimelineSpec.endTime) &&
        Objects.equals(this.startTime, googlePlayDeveloperReportingV1alpha1TimelineSpec.startTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aggregationPeriod, endTime, startTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GooglePlayDeveloperReportingV1alpha1TimelineSpec {\n");
    sb.append("    aggregationPeriod: ").append(toIndentedString(aggregationPeriod)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("aggregationPeriod");
    openapiFields.add("endTime");
    openapiFields.add("startTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GooglePlayDeveloperReportingV1alpha1TimelineSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GooglePlayDeveloperReportingV1alpha1TimelineSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GooglePlayDeveloperReportingV1alpha1TimelineSpec is not found in the empty JSON string", GooglePlayDeveloperReportingV1alpha1TimelineSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GooglePlayDeveloperReportingV1alpha1TimelineSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GooglePlayDeveloperReportingV1alpha1TimelineSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("aggregationPeriod") != null && !jsonObj.get("aggregationPeriod").isJsonNull()) && !jsonObj.get("aggregationPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aggregationPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aggregationPeriod").toString()));
      }
      // validate the optional field `aggregationPeriod`
      if (jsonObj.get("aggregationPeriod") != null && !jsonObj.get("aggregationPeriod").isJsonNull()) {
        AggregationPeriodEnum.validateJsonElement(jsonObj.get("aggregationPeriod"));
      }
      // validate the optional field `endTime`
      if (jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) {
        GoogleTypeDateTime.validateJsonElement(jsonObj.get("endTime"));
      }
      // validate the optional field `startTime`
      if (jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) {
        GoogleTypeDateTime.validateJsonElement(jsonObj.get("startTime"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GooglePlayDeveloperReportingV1alpha1TimelineSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GooglePlayDeveloperReportingV1alpha1TimelineSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GooglePlayDeveloperReportingV1alpha1TimelineSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GooglePlayDeveloperReportingV1alpha1TimelineSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<GooglePlayDeveloperReportingV1alpha1TimelineSpec>() {
           @Override
           public void write(JsonWriter out, GooglePlayDeveloperReportingV1alpha1TimelineSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GooglePlayDeveloperReportingV1alpha1TimelineSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GooglePlayDeveloperReportingV1alpha1TimelineSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GooglePlayDeveloperReportingV1alpha1TimelineSpec
   * @throws IOException if the JSON string is invalid with respect to GooglePlayDeveloperReportingV1alpha1TimelineSpec
   */
  public static GooglePlayDeveloperReportingV1alpha1TimelineSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GooglePlayDeveloperReportingV1alpha1TimelineSpec.class);
  }

  /**
   * Convert an instance of GooglePlayDeveloperReportingV1alpha1TimelineSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

