/*
 * Google Play Developer Reporting API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#39;s BigDecimal or Python&#39;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:51:15.855761-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleTypeDecimal {
  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private String value;

  public GoogleTypeDecimal() {
  }

  public GoogleTypeDecimal value(String value) {
    this.value = value;
    return this;
  }

  /**
   * The decimal value, as a string. The string representation consists of an optional sign, &#x60;+&#x60; (&#x60;U+002B&#x60;) or &#x60;-&#x60; (&#x60;U+002D&#x60;), followed by a sequence of zero or more decimal digits (\&quot;the integer\&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as &#x60;0&#x60;. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character &#x60;e&#x60; (&#x60;U+0065&#x60;) or &#x60;E&#x60; (&#x60;U+0045&#x60;) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided &#x60;+&#x60; sign (&#x60;+2.5&#x60; -&gt; &#x60;2.5&#x60;). - Replacing a zero-length integer value with &#x60;0&#x60; (&#x60;.5&#x60; -&gt; &#x60;0.5&#x60;). - Coercing the exponent character to upper-case, with explicit sign (&#x60;2.5e8&#x60; -&gt; &#x60;2.5E+8&#x60;). - Removing an explicitly-provided zero exponent (&#x60;2.5E0&#x60; -&gt; &#x60;2.5&#x60;). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: &#x60;2.5E-1&#x60; &lt;-&gt; &#x60;0.25&#x60;). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the &#x60;.&#x60; character is supported to divide the integer and the fraction; &#x60;,&#x60; **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString &#x3D; &#39;&#39; | [Sign] Significand [Exponent]; Sign &#x3D; &#39;+&#39; | &#39;-&#39;; Significand &#x3D; Digits &#39;.&#39; | [Digits] &#39;.&#39; Digits; Exponent &#x3D; (&#39;e&#39; | &#39;E&#39;) [Sign] Digits; Digits &#x3D; { &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with &#x60;400 Bad Request&#x60; (&#x60;INVALID_ARGUMENT&#x60; in gRPC) if precision would be lost. Services **should** error with &#x60;400 Bad Request&#x60; (&#x60;INVALID_ARGUMENT&#x60; in gRPC) if the service receives a value outside of the supported range.
   * @return value
   */
  @javax.annotation.Nullable
  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleTypeDecimal googleTypeDecimal = (GoogleTypeDecimal) o;
    return Objects.equals(this.value, googleTypeDecimal.value);
  }

  @Override
  public int hashCode() {
    return Objects.hash(value);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleTypeDecimal {\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleTypeDecimal
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleTypeDecimal.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleTypeDecimal is not found in the empty JSON string", GoogleTypeDecimal.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleTypeDecimal.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleTypeDecimal` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) && !jsonObj.get("value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("value").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleTypeDecimal.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleTypeDecimal' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleTypeDecimal> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleTypeDecimal.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleTypeDecimal>() {
           @Override
           public void write(JsonWriter out, GoogleTypeDecimal value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleTypeDecimal read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleTypeDecimal given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleTypeDecimal
   * @throws IOException if the JSON string is invalid with respect to GoogleTypeDecimal
   */
  public static GoogleTypeDecimal fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleTypeDecimal.class);
  }

  /**
   * Convert an instance of GoogleTypeDecimal to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

