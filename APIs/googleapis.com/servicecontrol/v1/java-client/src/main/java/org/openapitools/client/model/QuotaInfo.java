/*
 * Service Control API
 * Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.MetricValueSet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains the quota information for a quota check response.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:21.369626-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class QuotaInfo {
  public static final String SERIALIZED_NAME_LIMIT_EXCEEDED = "limitExceeded";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_LIMIT_EXCEEDED)
  private List<String> limitExceeded = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUOTA_CONSUMED = "quotaConsumed";
  @SerializedName(SERIALIZED_NAME_QUOTA_CONSUMED)
  private Map<String, Integer> quotaConsumed = new HashMap<>();

  public static final String SERIALIZED_NAME_QUOTA_METRICS = "quotaMetrics";
  @SerializedName(SERIALIZED_NAME_QUOTA_METRICS)
  private List<MetricValueSet> quotaMetrics = new ArrayList<>();

  public QuotaInfo() {
  }

  @Deprecated
  public QuotaInfo limitExceeded(List<String> limitExceeded) {
    this.limitExceeded = limitExceeded;
    return this;
  }

  public QuotaInfo addLimitExceededItem(String limitExceededItem) {
    if (this.limitExceeded == null) {
      this.limitExceeded = new ArrayList<>();
    }
    this.limitExceeded.add(limitExceededItem);
    return this;
  }

  /**
   * Quota Metrics that have exceeded quota limits. For QuotaGroup-based quota, this is QuotaGroup.name For QuotaLimit-based quota, this is QuotaLimit.name See: google.api.Quota Deprecated: Use quota_metrics to get per quota group limit exceeded status.
   * @return limitExceeded
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<String> getLimitExceeded() {
    return limitExceeded;
  }

  @Deprecated
  public void setLimitExceeded(List<String> limitExceeded) {
    this.limitExceeded = limitExceeded;
  }


  public QuotaInfo quotaConsumed(Map<String, Integer> quotaConsumed) {
    this.quotaConsumed = quotaConsumed;
    return this;
  }

  public QuotaInfo putQuotaConsumedItem(String key, Integer quotaConsumedItem) {
    if (this.quotaConsumed == null) {
      this.quotaConsumed = new HashMap<>();
    }
    this.quotaConsumed.put(key, quotaConsumedItem);
    return this;
  }

  /**
   * Map of quota group name to the actual number of tokens consumed. If the quota check was not successful, then this will not be populated due to no quota consumption. We are not merging this field with &#39;quota_metrics&#39; field because of the complexity of scaling in Chemist client code base. For simplicity, we will keep this field for Castor (that scales quota usage) and &#39;quota_metrics&#39; for SuperQuota (that doesn&#39;t scale quota usage). 
   * @return quotaConsumed
   */
  @javax.annotation.Nullable
  public Map<String, Integer> getQuotaConsumed() {
    return quotaConsumed;
  }

  public void setQuotaConsumed(Map<String, Integer> quotaConsumed) {
    this.quotaConsumed = quotaConsumed;
  }


  public QuotaInfo quotaMetrics(List<MetricValueSet> quotaMetrics) {
    this.quotaMetrics = quotaMetrics;
    return this;
  }

  public QuotaInfo addQuotaMetricsItem(MetricValueSet quotaMetricsItem) {
    if (this.quotaMetrics == null) {
      this.quotaMetrics = new ArrayList<>();
    }
    this.quotaMetrics.add(quotaMetricsItem);
    return this;
  }

  /**
   * Quota metrics to indicate the usage. Depending on the check request, one or more of the following metrics will be included: 1. For rate quota, per quota group or per quota metric incremental usage will be specified using the following delta metric: \&quot;serviceruntime.googleapis.com/api/consumer/quota_used_count\&quot; 2. For allocation quota, per quota metric total usage will be specified using the following gauge metric: \&quot;serviceruntime.googleapis.com/allocation/consumer/quota_used_count\&quot; 3. For both rate quota and allocation quota, the quota limit reached condition will be specified using the following boolean metric: \&quot;serviceruntime.googleapis.com/quota/exceeded\&quot;
   * @return quotaMetrics
   */
  @javax.annotation.Nullable
  public List<MetricValueSet> getQuotaMetrics() {
    return quotaMetrics;
  }

  public void setQuotaMetrics(List<MetricValueSet> quotaMetrics) {
    this.quotaMetrics = quotaMetrics;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QuotaInfo quotaInfo = (QuotaInfo) o;
    return Objects.equals(this.limitExceeded, quotaInfo.limitExceeded) &&
        Objects.equals(this.quotaConsumed, quotaInfo.quotaConsumed) &&
        Objects.equals(this.quotaMetrics, quotaInfo.quotaMetrics);
  }

  @Override
  public int hashCode() {
    return Objects.hash(limitExceeded, quotaConsumed, quotaMetrics);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QuotaInfo {\n");
    sb.append("    limitExceeded: ").append(toIndentedString(limitExceeded)).append("\n");
    sb.append("    quotaConsumed: ").append(toIndentedString(quotaConsumed)).append("\n");
    sb.append("    quotaMetrics: ").append(toIndentedString(quotaMetrics)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("limitExceeded");
    openapiFields.add("quotaConsumed");
    openapiFields.add("quotaMetrics");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to QuotaInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!QuotaInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in QuotaInfo is not found in the empty JSON string", QuotaInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!QuotaInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `QuotaInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("limitExceeded") != null && !jsonObj.get("limitExceeded").isJsonNull() && !jsonObj.get("limitExceeded").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `limitExceeded` to be an array in the JSON string but got `%s`", jsonObj.get("limitExceeded").toString()));
      }
      if (jsonObj.get("quotaMetrics") != null && !jsonObj.get("quotaMetrics").isJsonNull()) {
        JsonArray jsonArrayquotaMetrics = jsonObj.getAsJsonArray("quotaMetrics");
        if (jsonArrayquotaMetrics != null) {
          // ensure the json data is an array
          if (!jsonObj.get("quotaMetrics").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `quotaMetrics` to be an array in the JSON string but got `%s`", jsonObj.get("quotaMetrics").toString()));
          }

          // validate the optional field `quotaMetrics` (array)
          for (int i = 0; i < jsonArrayquotaMetrics.size(); i++) {
            MetricValueSet.validateJsonElement(jsonArrayquotaMetrics.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QuotaInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QuotaInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QuotaInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QuotaInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<QuotaInfo>() {
           @Override
           public void write(JsonWriter out, QuotaInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public QuotaInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of QuotaInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of QuotaInfo
   * @throws IOException if the JSON string is invalid with respect to QuotaInfo
   */
  public static QuotaInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QuotaInfo.class);
  }

  /**
   * Convert an instance of QuotaInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

