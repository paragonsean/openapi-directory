/*
 * Service Control API
 * Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.LogEntry;
import org.openapitools.client.model.MetricValueSet;
import org.openapitools.client.model.QuotaProperties;
import org.openapitools.client.model.ResourceInfo;
import org.openapitools.client.model.TraceSpan;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents information regarding an operation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:21.369626-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Operation {
  public static final String SERIALIZED_NAME_CONSUMER_ID = "consumerId";
  @SerializedName(SERIALIZED_NAME_CONSUMER_ID)
  private String consumerId;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private String endTime;

  /**
   * DO NOT USE. This is an experimental field.
   */
  @JsonAdapter(ImportanceEnum.Adapter.class)
  public enum ImportanceEnum {
    LOW("LOW"),
    
    HIGH("HIGH"),
    
    DEBUG("DEBUG"),
    
    PROMOTED("PROMOTED");

    private String value;

    ImportanceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ImportanceEnum fromValue(String value) {
      for (ImportanceEnum b : ImportanceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ImportanceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ImportanceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ImportanceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ImportanceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ImportanceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IMPORTANCE = "importance";
  @SerializedName(SERIALIZED_NAME_IMPORTANCE)
  private ImportanceEnum importance;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LOG_ENTRIES = "logEntries";
  @SerializedName(SERIALIZED_NAME_LOG_ENTRIES)
  private List<LogEntry> logEntries = new ArrayList<>();

  public static final String SERIALIZED_NAME_METRIC_VALUE_SETS = "metricValueSets";
  @SerializedName(SERIALIZED_NAME_METRIC_VALUE_SETS)
  private List<MetricValueSet> metricValueSets = new ArrayList<>();

  public static final String SERIALIZED_NAME_OPERATION_ID = "operationId";
  @SerializedName(SERIALIZED_NAME_OPERATION_ID)
  private String operationId;

  public static final String SERIALIZED_NAME_OPERATION_NAME = "operationName";
  @SerializedName(SERIALIZED_NAME_OPERATION_NAME)
  private String operationName;

  public static final String SERIALIZED_NAME_QUOTA_PROPERTIES = "quotaProperties";
  @SerializedName(SERIALIZED_NAME_QUOTA_PROPERTIES)
  private QuotaProperties quotaProperties;

  public static final String SERIALIZED_NAME_RESOURCES = "resources";
  @SerializedName(SERIALIZED_NAME_RESOURCES)
  private List<ResourceInfo> resources = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  public static final String SERIALIZED_NAME_TRACE_SPANS = "traceSpans";
  @SerializedName(SERIALIZED_NAME_TRACE_SPANS)
  private List<TraceSpan> traceSpans = new ArrayList<>();

  public static final String SERIALIZED_NAME_USER_LABELS = "userLabels";
  @SerializedName(SERIALIZED_NAME_USER_LABELS)
  private Map<String, String> userLabels = new HashMap<>();

  public Operation() {
  }

  public Operation consumerId(String consumerId) {
    this.consumerId = consumerId;
    return this;
  }

  /**
   * Identity of the consumer who is using the service. This field should be filled in for the operations initiated by a consumer, but not for service-initiated operations that are not related to a specific consumer. - This can be in one of the following formats: - project:PROJECT_ID, - project&#x60;_&#x60;number:PROJECT_NUMBER, - projects/PROJECT_ID or PROJECT_NUMBER, - folders/FOLDER_NUMBER, - organizations/ORGANIZATION_NUMBER, - api&#x60;_&#x60;key:API_KEY.
   * @return consumerId
   */
  @javax.annotation.Nullable
  public String getConsumerId() {
    return consumerId;
  }

  public void setConsumerId(String consumerId) {
    this.consumerId = consumerId;
  }


  public Operation endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * End time of the operation. Required when the operation is used in ServiceController.Report, but optional when the operation is used in ServiceController.Check.
   * @return endTime
   */
  @javax.annotation.Nullable
  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }


  public Operation importance(ImportanceEnum importance) {
    this.importance = importance;
    return this;
  }

  /**
   * DO NOT USE. This is an experimental field.
   * @return importance
   */
  @javax.annotation.Nullable
  public ImportanceEnum getImportance() {
    return importance;
  }

  public void setImportance(ImportanceEnum importance) {
    this.importance = importance;
  }


  public Operation labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Operation putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels describing the operation. Only the following labels are allowed: - Labels describing monitored resources as defined in the service configuration. - Default labels of metric values. When specified, labels defined in the metric value override these default. - The following labels defined by Google Cloud Platform: - &#x60;cloud.googleapis.com/location&#x60; describing the location where the operation happened, - &#x60;servicecontrol.googleapis.com/user_agent&#x60; describing the user agent of the API request, - &#x60;servicecontrol.googleapis.com/service_agent&#x60; describing the service used to handle the API request (e.g. ESP), - &#x60;servicecontrol.googleapis.com/platform&#x60; describing the platform where the API is served, such as App Engine, Compute Engine, or Kubernetes Engine.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Operation logEntries(List<LogEntry> logEntries) {
    this.logEntries = logEntries;
    return this;
  }

  public Operation addLogEntriesItem(LogEntry logEntriesItem) {
    if (this.logEntries == null) {
      this.logEntries = new ArrayList<>();
    }
    this.logEntries.add(logEntriesItem);
    return this;
  }

  /**
   * Represents information to be logged.
   * @return logEntries
   */
  @javax.annotation.Nullable
  public List<LogEntry> getLogEntries() {
    return logEntries;
  }

  public void setLogEntries(List<LogEntry> logEntries) {
    this.logEntries = logEntries;
  }


  public Operation metricValueSets(List<MetricValueSet> metricValueSets) {
    this.metricValueSets = metricValueSets;
    return this;
  }

  public Operation addMetricValueSetsItem(MetricValueSet metricValueSetsItem) {
    if (this.metricValueSets == null) {
      this.metricValueSets = new ArrayList<>();
    }
    this.metricValueSets.add(metricValueSetsItem);
    return this;
  }

  /**
   * Represents information about this operation. Each MetricValueSet corresponds to a metric defined in the service configuration. The data type used in the MetricValueSet must agree with the data type specified in the metric definition. Within a single operation, it is not allowed to have more than one MetricValue instances that have the same metric names and identical label value combinations. If a request has such duplicated MetricValue instances, the entire request is rejected with an invalid argument error.
   * @return metricValueSets
   */
  @javax.annotation.Nullable
  public List<MetricValueSet> getMetricValueSets() {
    return metricValueSets;
  }

  public void setMetricValueSets(List<MetricValueSet> metricValueSets) {
    this.metricValueSets = metricValueSets;
  }


  public Operation operationId(String operationId) {
    this.operationId = operationId;
    return this;
  }

  /**
   * Identity of the operation. This must be unique within the scope of the service that generated the operation. If the service calls Check() and Report() on the same operation, the two calls should carry the same id. UUID version 4 is recommended, though not required. In scenarios where an operation is computed from existing information and an idempotent id is desirable for deduplication purpose, UUID version 5 is recommended. See RFC 4122 for details.
   * @return operationId
   */
  @javax.annotation.Nullable
  public String getOperationId() {
    return operationId;
  }

  public void setOperationId(String operationId) {
    this.operationId = operationId;
  }


  public Operation operationName(String operationName) {
    this.operationName = operationName;
    return this;
  }

  /**
   * Fully qualified name of the operation. Reserved for future use.
   * @return operationName
   */
  @javax.annotation.Nullable
  public String getOperationName() {
    return operationName;
  }

  public void setOperationName(String operationName) {
    this.operationName = operationName;
  }


  public Operation quotaProperties(QuotaProperties quotaProperties) {
    this.quotaProperties = quotaProperties;
    return this;
  }

  /**
   * Get quotaProperties
   * @return quotaProperties
   */
  @javax.annotation.Nullable
  public QuotaProperties getQuotaProperties() {
    return quotaProperties;
  }

  public void setQuotaProperties(QuotaProperties quotaProperties) {
    this.quotaProperties = quotaProperties;
  }


  public Operation resources(List<ResourceInfo> resources) {
    this.resources = resources;
    return this;
  }

  public Operation addResourcesItem(ResourceInfo resourcesItem) {
    if (this.resources == null) {
      this.resources = new ArrayList<>();
    }
    this.resources.add(resourcesItem);
    return this;
  }

  /**
   * The resources that are involved in the operation. The maximum supported number of entries in this field is 100.
   * @return resources
   */
  @javax.annotation.Nullable
  public List<ResourceInfo> getResources() {
    return resources;
  }

  public void setResources(List<ResourceInfo> resources) {
    this.resources = resources;
  }


  public Operation startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Required. Start time of the operation.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }


  public Operation traceSpans(List<TraceSpan> traceSpans) {
    this.traceSpans = traceSpans;
    return this;
  }

  public Operation addTraceSpansItem(TraceSpan traceSpansItem) {
    if (this.traceSpans == null) {
      this.traceSpans = new ArrayList<>();
    }
    this.traceSpans.add(traceSpansItem);
    return this;
  }

  /**
   * Unimplemented. A list of Cloud Trace spans. The span names shall contain the id of the destination project which can be either the produce or the consumer project.
   * @return traceSpans
   */
  @javax.annotation.Nullable
  public List<TraceSpan> getTraceSpans() {
    return traceSpans;
  }

  public void setTraceSpans(List<TraceSpan> traceSpans) {
    this.traceSpans = traceSpans;
  }


  public Operation userLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
    return this;
  }

  public Operation putUserLabelsItem(String key, String userLabelsItem) {
    if (this.userLabels == null) {
      this.userLabels = new HashMap<>();
    }
    this.userLabels.put(key, userLabelsItem);
    return this;
  }

  /**
   * Private Preview. This feature is only available for approved services. User defined labels for the resource that this operation is associated with.
   * @return userLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getUserLabels() {
    return userLabels;
  }

  public void setUserLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Operation operation = (Operation) o;
    return Objects.equals(this.consumerId, operation.consumerId) &&
        Objects.equals(this.endTime, operation.endTime) &&
        Objects.equals(this.importance, operation.importance) &&
        Objects.equals(this.labels, operation.labels) &&
        Objects.equals(this.logEntries, operation.logEntries) &&
        Objects.equals(this.metricValueSets, operation.metricValueSets) &&
        Objects.equals(this.operationId, operation.operationId) &&
        Objects.equals(this.operationName, operation.operationName) &&
        Objects.equals(this.quotaProperties, operation.quotaProperties) &&
        Objects.equals(this.resources, operation.resources) &&
        Objects.equals(this.startTime, operation.startTime) &&
        Objects.equals(this.traceSpans, operation.traceSpans) &&
        Objects.equals(this.userLabels, operation.userLabels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(consumerId, endTime, importance, labels, logEntries, metricValueSets, operationId, operationName, quotaProperties, resources, startTime, traceSpans, userLabels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Operation {\n");
    sb.append("    consumerId: ").append(toIndentedString(consumerId)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    importance: ").append(toIndentedString(importance)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    logEntries: ").append(toIndentedString(logEntries)).append("\n");
    sb.append("    metricValueSets: ").append(toIndentedString(metricValueSets)).append("\n");
    sb.append("    operationId: ").append(toIndentedString(operationId)).append("\n");
    sb.append("    operationName: ").append(toIndentedString(operationName)).append("\n");
    sb.append("    quotaProperties: ").append(toIndentedString(quotaProperties)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    traceSpans: ").append(toIndentedString(traceSpans)).append("\n");
    sb.append("    userLabels: ").append(toIndentedString(userLabels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("consumerId");
    openapiFields.add("endTime");
    openapiFields.add("importance");
    openapiFields.add("labels");
    openapiFields.add("logEntries");
    openapiFields.add("metricValueSets");
    openapiFields.add("operationId");
    openapiFields.add("operationName");
    openapiFields.add("quotaProperties");
    openapiFields.add("resources");
    openapiFields.add("startTime");
    openapiFields.add("traceSpans");
    openapiFields.add("userLabels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Operation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Operation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Operation is not found in the empty JSON string", Operation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Operation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Operation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("consumerId") != null && !jsonObj.get("consumerId").isJsonNull()) && !jsonObj.get("consumerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `consumerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("consumerId").toString()));
      }
      if ((jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) && !jsonObj.get("endTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endTime").toString()));
      }
      if ((jsonObj.get("importance") != null && !jsonObj.get("importance").isJsonNull()) && !jsonObj.get("importance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `importance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("importance").toString()));
      }
      // validate the optional field `importance`
      if (jsonObj.get("importance") != null && !jsonObj.get("importance").isJsonNull()) {
        ImportanceEnum.validateJsonElement(jsonObj.get("importance"));
      }
      if (jsonObj.get("logEntries") != null && !jsonObj.get("logEntries").isJsonNull()) {
        JsonArray jsonArraylogEntries = jsonObj.getAsJsonArray("logEntries");
        if (jsonArraylogEntries != null) {
          // ensure the json data is an array
          if (!jsonObj.get("logEntries").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `logEntries` to be an array in the JSON string but got `%s`", jsonObj.get("logEntries").toString()));
          }

          // validate the optional field `logEntries` (array)
          for (int i = 0; i < jsonArraylogEntries.size(); i++) {
            LogEntry.validateJsonElement(jsonArraylogEntries.get(i));
          };
        }
      }
      if (jsonObj.get("metricValueSets") != null && !jsonObj.get("metricValueSets").isJsonNull()) {
        JsonArray jsonArraymetricValueSets = jsonObj.getAsJsonArray("metricValueSets");
        if (jsonArraymetricValueSets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metricValueSets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metricValueSets` to be an array in the JSON string but got `%s`", jsonObj.get("metricValueSets").toString()));
          }

          // validate the optional field `metricValueSets` (array)
          for (int i = 0; i < jsonArraymetricValueSets.size(); i++) {
            MetricValueSet.validateJsonElement(jsonArraymetricValueSets.get(i));
          };
        }
      }
      if ((jsonObj.get("operationId") != null && !jsonObj.get("operationId").isJsonNull()) && !jsonObj.get("operationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `operationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("operationId").toString()));
      }
      if ((jsonObj.get("operationName") != null && !jsonObj.get("operationName").isJsonNull()) && !jsonObj.get("operationName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `operationName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("operationName").toString()));
      }
      // validate the optional field `quotaProperties`
      if (jsonObj.get("quotaProperties") != null && !jsonObj.get("quotaProperties").isJsonNull()) {
        QuotaProperties.validateJsonElement(jsonObj.get("quotaProperties"));
      }
      if (jsonObj.get("resources") != null && !jsonObj.get("resources").isJsonNull()) {
        JsonArray jsonArrayresources = jsonObj.getAsJsonArray("resources");
        if (jsonArrayresources != null) {
          // ensure the json data is an array
          if (!jsonObj.get("resources").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `resources` to be an array in the JSON string but got `%s`", jsonObj.get("resources").toString()));
          }

          // validate the optional field `resources` (array)
          for (int i = 0; i < jsonArrayresources.size(); i++) {
            ResourceInfo.validateJsonElement(jsonArrayresources.get(i));
          };
        }
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if (jsonObj.get("traceSpans") != null && !jsonObj.get("traceSpans").isJsonNull()) {
        JsonArray jsonArraytraceSpans = jsonObj.getAsJsonArray("traceSpans");
        if (jsonArraytraceSpans != null) {
          // ensure the json data is an array
          if (!jsonObj.get("traceSpans").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `traceSpans` to be an array in the JSON string but got `%s`", jsonObj.get("traceSpans").toString()));
          }

          // validate the optional field `traceSpans` (array)
          for (int i = 0; i < jsonArraytraceSpans.size(); i++) {
            TraceSpan.validateJsonElement(jsonArraytraceSpans.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Operation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Operation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Operation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Operation.class));

       return (TypeAdapter<T>) new TypeAdapter<Operation>() {
           @Override
           public void write(JsonWriter out, Operation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Operation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Operation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Operation
   * @throws IOException if the JSON string is invalid with respect to Operation
   */
  public static Operation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Operation.class);
  }

  /**
   * Convert an instance of Operation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

