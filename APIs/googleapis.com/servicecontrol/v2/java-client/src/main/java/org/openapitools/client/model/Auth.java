/*
 * Service Control API
 * Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This message defines request authentication attributes. Terminology is based on the JSON Web Token (JWT) standard, but the terms also correlate to concepts in other standards.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:15.323338-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Auth {
  public static final String SERIALIZED_NAME_ACCESS_LEVELS = "accessLevels";
  @SerializedName(SERIALIZED_NAME_ACCESS_LEVELS)
  private List<String> accessLevels = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUDIENCES = "audiences";
  @SerializedName(SERIALIZED_NAME_AUDIENCES)
  private List<String> audiences = new ArrayList<>();

  public static final String SERIALIZED_NAME_CLAIMS = "claims";
  @SerializedName(SERIALIZED_NAME_CLAIMS)
  private Map<String, Object> claims = new HashMap<>();

  public static final String SERIALIZED_NAME_PRESENTER = "presenter";
  @SerializedName(SERIALIZED_NAME_PRESENTER)
  private String presenter;

  public static final String SERIALIZED_NAME_PRINCIPAL = "principal";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL)
  private String principal;

  public Auth() {
  }

  public Auth accessLevels(List<String> accessLevels) {
    this.accessLevels = accessLevels;
    return this;
  }

  public Auth addAccessLevelsItem(String accessLevelsItem) {
    if (this.accessLevels == null) {
      this.accessLevels = new ArrayList<>();
    }
    this.accessLevels.add(accessLevelsItem);
    return this;
  }

  /**
   * A list of access level resource names that allow resources to be accessed by authenticated requester. It is part of Secure GCP processing for the incoming request. An access level string has the format: \&quot;//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}\&quot; Example: \&quot;//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL\&quot;
   * @return accessLevels
   */
  @javax.annotation.Nullable
  public List<String> getAccessLevels() {
    return accessLevels;
  }

  public void setAccessLevels(List<String> accessLevels) {
    this.accessLevels = accessLevels;
  }


  public Auth audiences(List<String> audiences) {
    this.audiences = audiences;
    return this;
  }

  public Auth addAudiencesItem(String audiencesItem) {
    if (this.audiences == null) {
      this.audiences = new ArrayList<>();
    }
    this.audiences.add(audiencesItem);
    return this;
  }

  /**
   * The intended audience(s) for this authentication information. Reflects the audience (&#x60;aud&#x60;) claim within a JWT. The audience value(s) depends on the &#x60;issuer&#x60;, but typically include one or more of the following pieces of information: * The services intended to receive the credential. For example, [\&quot;https://pubsub.googleapis.com/\&quot;, \&quot;https://storage.googleapis.com/\&quot;]. * A set of service-based scopes. For example, [\&quot;https://www.googleapis.com/auth/cloud-platform\&quot;]. * The client id of an app, such as the Firebase project id for JWTs from Firebase Auth. Consult the documentation for the credential issuer to determine the information provided.
   * @return audiences
   */
  @javax.annotation.Nullable
  public List<String> getAudiences() {
    return audiences;
  }

  public void setAudiences(List<String> audiences) {
    this.audiences = audiences;
  }


  public Auth claims(Map<String, Object> claims) {
    this.claims = claims;
    return this;
  }

  public Auth putClaimsItem(String key, Object claimsItem) {
    if (this.claims == null) {
      this.claims = new HashMap<>();
    }
    this.claims.put(key, claimsItem);
    return this;
  }

  /**
   * Structured claims presented with the credential. JWTs include &#x60;{key: value}&#x60; pairs for standard and private claims. The following is a subset of the standard required and optional claims that would typically be presented for a Google-based JWT: {&#39;iss&#39;: &#39;accounts.google.com&#39;, &#39;sub&#39;: &#39;113289723416554971153&#39;, &#39;aud&#39;: [&#39;123456789012&#39;, &#39;pubsub.googleapis.com&#39;], &#39;azp&#39;: &#39;123456789012.apps.googleusercontent.com&#39;, &#39;email&#39;: &#39;jsmith@example.com&#39;, &#39;iat&#39;: 1353601026, &#39;exp&#39;: 1353604926} SAML assertions are similarly specified, but with an identity provider dependent structure.
   * @return claims
   */
  @javax.annotation.Nullable
  public Map<String, Object> getClaims() {
    return claims;
  }

  public void setClaims(Map<String, Object> claims) {
    this.claims = claims;
  }


  public Auth presenter(String presenter) {
    this.presenter = presenter;
    return this;
  }

  /**
   * The authorized presenter of the credential. Reflects the optional Authorized Presenter (&#x60;azp&#x60;) claim within a JWT or the OAuth client id. For example, a Google Cloud Platform client id looks as follows: \&quot;123456789012.apps.googleusercontent.com\&quot;.
   * @return presenter
   */
  @javax.annotation.Nullable
  public String getPresenter() {
    return presenter;
  }

  public void setPresenter(String presenter) {
    this.presenter = presenter;
  }


  public Auth principal(String principal) {
    this.principal = principal;
    return this;
  }

  /**
   * The authenticated principal. Reflects the issuer (&#x60;iss&#x60;) and subject (&#x60;sub&#x60;) claims within a JWT. The issuer and subject should be &#x60;/&#x60; delimited, with &#x60;/&#x60; percent-encoded within the subject fragment. For Google accounts, the principal format is: \&quot;https://accounts.google.com/{id}\&quot;
   * @return principal
   */
  @javax.annotation.Nullable
  public String getPrincipal() {
    return principal;
  }

  public void setPrincipal(String principal) {
    this.principal = principal;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Auth auth = (Auth) o;
    return Objects.equals(this.accessLevels, auth.accessLevels) &&
        Objects.equals(this.audiences, auth.audiences) &&
        Objects.equals(this.claims, auth.claims) &&
        Objects.equals(this.presenter, auth.presenter) &&
        Objects.equals(this.principal, auth.principal);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessLevels, audiences, claims, presenter, principal);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Auth {\n");
    sb.append("    accessLevels: ").append(toIndentedString(accessLevels)).append("\n");
    sb.append("    audiences: ").append(toIndentedString(audiences)).append("\n");
    sb.append("    claims: ").append(toIndentedString(claims)).append("\n");
    sb.append("    presenter: ").append(toIndentedString(presenter)).append("\n");
    sb.append("    principal: ").append(toIndentedString(principal)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessLevels");
    openapiFields.add("audiences");
    openapiFields.add("claims");
    openapiFields.add("presenter");
    openapiFields.add("principal");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Auth
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Auth.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Auth is not found in the empty JSON string", Auth.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Auth.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Auth` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("accessLevels") != null && !jsonObj.get("accessLevels").isJsonNull() && !jsonObj.get("accessLevels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessLevels` to be an array in the JSON string but got `%s`", jsonObj.get("accessLevels").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("audiences") != null && !jsonObj.get("audiences").isJsonNull() && !jsonObj.get("audiences").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `audiences` to be an array in the JSON string but got `%s`", jsonObj.get("audiences").toString()));
      }
      if ((jsonObj.get("presenter") != null && !jsonObj.get("presenter").isJsonNull()) && !jsonObj.get("presenter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `presenter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("presenter").toString()));
      }
      if ((jsonObj.get("principal") != null && !jsonObj.get("principal").isJsonNull()) && !jsonObj.get("principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("principal").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Auth.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Auth' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Auth> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Auth.class));

       return (TypeAdapter<T>) new TypeAdapter<Auth>() {
           @Override
           public void write(JsonWriter out, Auth value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Auth read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Auth given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Auth
   * @throws IOException if the JSON string is invalid with respect to Auth
   */
  public static Auth fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Auth.class);
  }

  /**
   * Convert an instance of Auth to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

