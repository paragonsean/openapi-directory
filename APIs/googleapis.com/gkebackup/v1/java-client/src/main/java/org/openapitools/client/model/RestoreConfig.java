/*
 * Backup for GKE API
 * Backup for GKE is a managed Kubernetes workload backup and restore service for GKE clusters.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ClusterResourceRestoreScope;
import org.openapitools.client.model.NamespacedNames;
import org.openapitools.client.model.Namespaces;
import org.openapitools.client.model.SubstitutionRule;
import org.openapitools.client.model.TransformationRule;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration of a restore. Next id: 14
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:31.365638-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RestoreConfig {
  public static final String SERIALIZED_NAME_ALL_NAMESPACES = "allNamespaces";
  @SerializedName(SERIALIZED_NAME_ALL_NAMESPACES)
  private Boolean allNamespaces;

  /**
   * Optional. Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
   */
  @JsonAdapter(ClusterResourceConflictPolicyEnum.Adapter.class)
  public enum ClusterResourceConflictPolicyEnum {
    CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED("CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED"),
    
    USE_EXISTING_VERSION("USE_EXISTING_VERSION"),
    
    USE_BACKUP_VERSION("USE_BACKUP_VERSION");

    private String value;

    ClusterResourceConflictPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClusterResourceConflictPolicyEnum fromValue(String value) {
      for (ClusterResourceConflictPolicyEnum b : ClusterResourceConflictPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ClusterResourceConflictPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClusterResourceConflictPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClusterResourceConflictPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ClusterResourceConflictPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ClusterResourceConflictPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CLUSTER_RESOURCE_CONFLICT_POLICY = "clusterResourceConflictPolicy";
  @SerializedName(SERIALIZED_NAME_CLUSTER_RESOURCE_CONFLICT_POLICY)
  private ClusterResourceConflictPolicyEnum clusterResourceConflictPolicy;

  public static final String SERIALIZED_NAME_CLUSTER_RESOURCE_RESTORE_SCOPE = "clusterResourceRestoreScope";
  @SerializedName(SERIALIZED_NAME_CLUSTER_RESOURCE_RESTORE_SCOPE)
  private ClusterResourceRestoreScope clusterResourceRestoreScope;

  public static final String SERIALIZED_NAME_EXCLUDED_NAMESPACES = "excludedNamespaces";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_NAMESPACES)
  private Namespaces excludedNamespaces;

  /**
   * Optional. Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
   */
  @JsonAdapter(NamespacedResourceRestoreModeEnum.Adapter.class)
  public enum NamespacedResourceRestoreModeEnum {
    NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED("NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED"),
    
    DELETE_AND_RESTORE("DELETE_AND_RESTORE"),
    
    FAIL_ON_CONFLICT("FAIL_ON_CONFLICT");

    private String value;

    NamespacedResourceRestoreModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NamespacedResourceRestoreModeEnum fromValue(String value) {
      for (NamespacedResourceRestoreModeEnum b : NamespacedResourceRestoreModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<NamespacedResourceRestoreModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NamespacedResourceRestoreModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NamespacedResourceRestoreModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NamespacedResourceRestoreModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      NamespacedResourceRestoreModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_NAMESPACED_RESOURCE_RESTORE_MODE = "namespacedResourceRestoreMode";
  @SerializedName(SERIALIZED_NAME_NAMESPACED_RESOURCE_RESTORE_MODE)
  private NamespacedResourceRestoreModeEnum namespacedResourceRestoreMode;

  public static final String SERIALIZED_NAME_NO_NAMESPACES = "noNamespaces";
  @SerializedName(SERIALIZED_NAME_NO_NAMESPACES)
  private Boolean noNamespaces;

  public static final String SERIALIZED_NAME_SELECTED_APPLICATIONS = "selectedApplications";
  @SerializedName(SERIALIZED_NAME_SELECTED_APPLICATIONS)
  private NamespacedNames selectedApplications;

  public static final String SERIALIZED_NAME_SELECTED_NAMESPACES = "selectedNamespaces";
  @SerializedName(SERIALIZED_NAME_SELECTED_NAMESPACES)
  private Namespaces selectedNamespaces;

  public static final String SERIALIZED_NAME_SUBSTITUTION_RULES = "substitutionRules";
  @SerializedName(SERIALIZED_NAME_SUBSTITUTION_RULES)
  private List<SubstitutionRule> substitutionRules = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSFORMATION_RULES = "transformationRules";
  @SerializedName(SERIALIZED_NAME_TRANSFORMATION_RULES)
  private List<TransformationRule> transformationRules = new ArrayList<>();

  /**
   * Optional. Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
   */
  @JsonAdapter(VolumeDataRestorePolicyEnum.Adapter.class)
  public enum VolumeDataRestorePolicyEnum {
    VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED("VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED"),
    
    RESTORE_VOLUME_DATA_FROM_BACKUP("RESTORE_VOLUME_DATA_FROM_BACKUP"),
    
    REUSE_VOLUME_HANDLE_FROM_BACKUP("REUSE_VOLUME_HANDLE_FROM_BACKUP"),
    
    NO_VOLUME_DATA_RESTORATION("NO_VOLUME_DATA_RESTORATION");

    private String value;

    VolumeDataRestorePolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VolumeDataRestorePolicyEnum fromValue(String value) {
      for (VolumeDataRestorePolicyEnum b : VolumeDataRestorePolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VolumeDataRestorePolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VolumeDataRestorePolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VolumeDataRestorePolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VolumeDataRestorePolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VolumeDataRestorePolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VOLUME_DATA_RESTORE_POLICY = "volumeDataRestorePolicy";
  @SerializedName(SERIALIZED_NAME_VOLUME_DATA_RESTORE_POLICY)
  private VolumeDataRestorePolicyEnum volumeDataRestorePolicy;

  public RestoreConfig() {
  }

  public RestoreConfig allNamespaces(Boolean allNamespaces) {
    this.allNamespaces = allNamespaces;
    return this;
  }

  /**
   * Restore all namespaced resources in the Backup if set to \&quot;True\&quot;. Specifying this field to \&quot;False\&quot; is an error.
   * @return allNamespaces
   */
  @javax.annotation.Nullable
  public Boolean getAllNamespaces() {
    return allNamespaces;
  }

  public void setAllNamespaces(Boolean allNamespaces) {
    this.allNamespaces = allNamespaces;
  }


  public RestoreConfig clusterResourceConflictPolicy(ClusterResourceConflictPolicyEnum clusterResourceConflictPolicy) {
    this.clusterResourceConflictPolicy = clusterResourceConflictPolicy;
    return this;
  }

  /**
   * Optional. Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
   * @return clusterResourceConflictPolicy
   */
  @javax.annotation.Nullable
  public ClusterResourceConflictPolicyEnum getClusterResourceConflictPolicy() {
    return clusterResourceConflictPolicy;
  }

  public void setClusterResourceConflictPolicy(ClusterResourceConflictPolicyEnum clusterResourceConflictPolicy) {
    this.clusterResourceConflictPolicy = clusterResourceConflictPolicy;
  }


  public RestoreConfig clusterResourceRestoreScope(ClusterResourceRestoreScope clusterResourceRestoreScope) {
    this.clusterResourceRestoreScope = clusterResourceRestoreScope;
    return this;
  }

  /**
   * Get clusterResourceRestoreScope
   * @return clusterResourceRestoreScope
   */
  @javax.annotation.Nullable
  public ClusterResourceRestoreScope getClusterResourceRestoreScope() {
    return clusterResourceRestoreScope;
  }

  public void setClusterResourceRestoreScope(ClusterResourceRestoreScope clusterResourceRestoreScope) {
    this.clusterResourceRestoreScope = clusterResourceRestoreScope;
  }


  public RestoreConfig excludedNamespaces(Namespaces excludedNamespaces) {
    this.excludedNamespaces = excludedNamespaces;
    return this;
  }

  /**
   * Get excludedNamespaces
   * @return excludedNamespaces
   */
  @javax.annotation.Nullable
  public Namespaces getExcludedNamespaces() {
    return excludedNamespaces;
  }

  public void setExcludedNamespaces(Namespaces excludedNamespaces) {
    this.excludedNamespaces = excludedNamespaces;
  }


  public RestoreConfig namespacedResourceRestoreMode(NamespacedResourceRestoreModeEnum namespacedResourceRestoreMode) {
    this.namespacedResourceRestoreMode = namespacedResourceRestoreMode;
    return this;
  }

  /**
   * Optional. Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
   * @return namespacedResourceRestoreMode
   */
  @javax.annotation.Nullable
  public NamespacedResourceRestoreModeEnum getNamespacedResourceRestoreMode() {
    return namespacedResourceRestoreMode;
  }

  public void setNamespacedResourceRestoreMode(NamespacedResourceRestoreModeEnum namespacedResourceRestoreMode) {
    this.namespacedResourceRestoreMode = namespacedResourceRestoreMode;
  }


  public RestoreConfig noNamespaces(Boolean noNamespaces) {
    this.noNamespaces = noNamespaces;
    return this;
  }

  /**
   * Do not restore any namespaced resources if set to \&quot;True\&quot;. Specifying this field to \&quot;False\&quot; is not allowed.
   * @return noNamespaces
   */
  @javax.annotation.Nullable
  public Boolean getNoNamespaces() {
    return noNamespaces;
  }

  public void setNoNamespaces(Boolean noNamespaces) {
    this.noNamespaces = noNamespaces;
  }


  public RestoreConfig selectedApplications(NamespacedNames selectedApplications) {
    this.selectedApplications = selectedApplications;
    return this;
  }

  /**
   * Get selectedApplications
   * @return selectedApplications
   */
  @javax.annotation.Nullable
  public NamespacedNames getSelectedApplications() {
    return selectedApplications;
  }

  public void setSelectedApplications(NamespacedNames selectedApplications) {
    this.selectedApplications = selectedApplications;
  }


  public RestoreConfig selectedNamespaces(Namespaces selectedNamespaces) {
    this.selectedNamespaces = selectedNamespaces;
    return this;
  }

  /**
   * Get selectedNamespaces
   * @return selectedNamespaces
   */
  @javax.annotation.Nullable
  public Namespaces getSelectedNamespaces() {
    return selectedNamespaces;
  }

  public void setSelectedNamespaces(Namespaces selectedNamespaces) {
    this.selectedNamespaces = selectedNamespaces;
  }


  public RestoreConfig substitutionRules(List<SubstitutionRule> substitutionRules) {
    this.substitutionRules = substitutionRules;
    return this;
  }

  public RestoreConfig addSubstitutionRulesItem(SubstitutionRule substitutionRulesItem) {
    if (this.substitutionRules == null) {
      this.substitutionRules = new ArrayList<>();
    }
    this.substitutionRules.add(substitutionRulesItem);
    return this;
  }

  /**
   * Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no substitution will occur.
   * @return substitutionRules
   */
  @javax.annotation.Nullable
  public List<SubstitutionRule> getSubstitutionRules() {
    return substitutionRules;
  }

  public void setSubstitutionRules(List<SubstitutionRule> substitutionRules) {
    this.substitutionRules = substitutionRules;
  }


  public RestoreConfig transformationRules(List<TransformationRule> transformationRules) {
    this.transformationRules = transformationRules;
    return this;
  }

  public RestoreConfig addTransformationRulesItem(TransformationRule transformationRulesItem) {
    if (this.transformationRules == null) {
      this.transformationRules = new ArrayList<>();
    }
    this.transformationRules.add(transformationRulesItem);
    return this;
  }

  /**
   * Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no transformation will occur.
   * @return transformationRules
   */
  @javax.annotation.Nullable
  public List<TransformationRule> getTransformationRules() {
    return transformationRules;
  }

  public void setTransformationRules(List<TransformationRule> transformationRules) {
    this.transformationRules = transformationRules;
  }


  public RestoreConfig volumeDataRestorePolicy(VolumeDataRestorePolicyEnum volumeDataRestorePolicy) {
    this.volumeDataRestorePolicy = volumeDataRestorePolicy;
    return this;
  }

  /**
   * Optional. Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
   * @return volumeDataRestorePolicy
   */
  @javax.annotation.Nullable
  public VolumeDataRestorePolicyEnum getVolumeDataRestorePolicy() {
    return volumeDataRestorePolicy;
  }

  public void setVolumeDataRestorePolicy(VolumeDataRestorePolicyEnum volumeDataRestorePolicy) {
    this.volumeDataRestorePolicy = volumeDataRestorePolicy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RestoreConfig restoreConfig = (RestoreConfig) o;
    return Objects.equals(this.allNamespaces, restoreConfig.allNamespaces) &&
        Objects.equals(this.clusterResourceConflictPolicy, restoreConfig.clusterResourceConflictPolicy) &&
        Objects.equals(this.clusterResourceRestoreScope, restoreConfig.clusterResourceRestoreScope) &&
        Objects.equals(this.excludedNamespaces, restoreConfig.excludedNamespaces) &&
        Objects.equals(this.namespacedResourceRestoreMode, restoreConfig.namespacedResourceRestoreMode) &&
        Objects.equals(this.noNamespaces, restoreConfig.noNamespaces) &&
        Objects.equals(this.selectedApplications, restoreConfig.selectedApplications) &&
        Objects.equals(this.selectedNamespaces, restoreConfig.selectedNamespaces) &&
        Objects.equals(this.substitutionRules, restoreConfig.substitutionRules) &&
        Objects.equals(this.transformationRules, restoreConfig.transformationRules) &&
        Objects.equals(this.volumeDataRestorePolicy, restoreConfig.volumeDataRestorePolicy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allNamespaces, clusterResourceConflictPolicy, clusterResourceRestoreScope, excludedNamespaces, namespacedResourceRestoreMode, noNamespaces, selectedApplications, selectedNamespaces, substitutionRules, transformationRules, volumeDataRestorePolicy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RestoreConfig {\n");
    sb.append("    allNamespaces: ").append(toIndentedString(allNamespaces)).append("\n");
    sb.append("    clusterResourceConflictPolicy: ").append(toIndentedString(clusterResourceConflictPolicy)).append("\n");
    sb.append("    clusterResourceRestoreScope: ").append(toIndentedString(clusterResourceRestoreScope)).append("\n");
    sb.append("    excludedNamespaces: ").append(toIndentedString(excludedNamespaces)).append("\n");
    sb.append("    namespacedResourceRestoreMode: ").append(toIndentedString(namespacedResourceRestoreMode)).append("\n");
    sb.append("    noNamespaces: ").append(toIndentedString(noNamespaces)).append("\n");
    sb.append("    selectedApplications: ").append(toIndentedString(selectedApplications)).append("\n");
    sb.append("    selectedNamespaces: ").append(toIndentedString(selectedNamespaces)).append("\n");
    sb.append("    substitutionRules: ").append(toIndentedString(substitutionRules)).append("\n");
    sb.append("    transformationRules: ").append(toIndentedString(transformationRules)).append("\n");
    sb.append("    volumeDataRestorePolicy: ").append(toIndentedString(volumeDataRestorePolicy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allNamespaces");
    openapiFields.add("clusterResourceConflictPolicy");
    openapiFields.add("clusterResourceRestoreScope");
    openapiFields.add("excludedNamespaces");
    openapiFields.add("namespacedResourceRestoreMode");
    openapiFields.add("noNamespaces");
    openapiFields.add("selectedApplications");
    openapiFields.add("selectedNamespaces");
    openapiFields.add("substitutionRules");
    openapiFields.add("transformationRules");
    openapiFields.add("volumeDataRestorePolicy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RestoreConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RestoreConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RestoreConfig is not found in the empty JSON string", RestoreConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RestoreConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RestoreConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("clusterResourceConflictPolicy") != null && !jsonObj.get("clusterResourceConflictPolicy").isJsonNull()) && !jsonObj.get("clusterResourceConflictPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterResourceConflictPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterResourceConflictPolicy").toString()));
      }
      // validate the optional field `clusterResourceConflictPolicy`
      if (jsonObj.get("clusterResourceConflictPolicy") != null && !jsonObj.get("clusterResourceConflictPolicy").isJsonNull()) {
        ClusterResourceConflictPolicyEnum.validateJsonElement(jsonObj.get("clusterResourceConflictPolicy"));
      }
      // validate the optional field `clusterResourceRestoreScope`
      if (jsonObj.get("clusterResourceRestoreScope") != null && !jsonObj.get("clusterResourceRestoreScope").isJsonNull()) {
        ClusterResourceRestoreScope.validateJsonElement(jsonObj.get("clusterResourceRestoreScope"));
      }
      // validate the optional field `excludedNamespaces`
      if (jsonObj.get("excludedNamespaces") != null && !jsonObj.get("excludedNamespaces").isJsonNull()) {
        Namespaces.validateJsonElement(jsonObj.get("excludedNamespaces"));
      }
      if ((jsonObj.get("namespacedResourceRestoreMode") != null && !jsonObj.get("namespacedResourceRestoreMode").isJsonNull()) && !jsonObj.get("namespacedResourceRestoreMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespacedResourceRestoreMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespacedResourceRestoreMode").toString()));
      }
      // validate the optional field `namespacedResourceRestoreMode`
      if (jsonObj.get("namespacedResourceRestoreMode") != null && !jsonObj.get("namespacedResourceRestoreMode").isJsonNull()) {
        NamespacedResourceRestoreModeEnum.validateJsonElement(jsonObj.get("namespacedResourceRestoreMode"));
      }
      // validate the optional field `selectedApplications`
      if (jsonObj.get("selectedApplications") != null && !jsonObj.get("selectedApplications").isJsonNull()) {
        NamespacedNames.validateJsonElement(jsonObj.get("selectedApplications"));
      }
      // validate the optional field `selectedNamespaces`
      if (jsonObj.get("selectedNamespaces") != null && !jsonObj.get("selectedNamespaces").isJsonNull()) {
        Namespaces.validateJsonElement(jsonObj.get("selectedNamespaces"));
      }
      if (jsonObj.get("substitutionRules") != null && !jsonObj.get("substitutionRules").isJsonNull()) {
        JsonArray jsonArraysubstitutionRules = jsonObj.getAsJsonArray("substitutionRules");
        if (jsonArraysubstitutionRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("substitutionRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `substitutionRules` to be an array in the JSON string but got `%s`", jsonObj.get("substitutionRules").toString()));
          }

          // validate the optional field `substitutionRules` (array)
          for (int i = 0; i < jsonArraysubstitutionRules.size(); i++) {
            SubstitutionRule.validateJsonElement(jsonArraysubstitutionRules.get(i));
          };
        }
      }
      if (jsonObj.get("transformationRules") != null && !jsonObj.get("transformationRules").isJsonNull()) {
        JsonArray jsonArraytransformationRules = jsonObj.getAsJsonArray("transformationRules");
        if (jsonArraytransformationRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transformationRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transformationRules` to be an array in the JSON string but got `%s`", jsonObj.get("transformationRules").toString()));
          }

          // validate the optional field `transformationRules` (array)
          for (int i = 0; i < jsonArraytransformationRules.size(); i++) {
            TransformationRule.validateJsonElement(jsonArraytransformationRules.get(i));
          };
        }
      }
      if ((jsonObj.get("volumeDataRestorePolicy") != null && !jsonObj.get("volumeDataRestorePolicy").isJsonNull()) && !jsonObj.get("volumeDataRestorePolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `volumeDataRestorePolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("volumeDataRestorePolicy").toString()));
      }
      // validate the optional field `volumeDataRestorePolicy`
      if (jsonObj.get("volumeDataRestorePolicy") != null && !jsonObj.get("volumeDataRestorePolicy").isJsonNull()) {
        VolumeDataRestorePolicyEnum.validateJsonElement(jsonObj.get("volumeDataRestorePolicy"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RestoreConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RestoreConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RestoreConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RestoreConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<RestoreConfig>() {
           @Override
           public void write(JsonWriter out, RestoreConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RestoreConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RestoreConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RestoreConfig
   * @throws IOException if the JSON string is invalid with respect to RestoreConfig
   */
  public static RestoreConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RestoreConfig.class);
  }

  /**
   * Convert an instance of RestoreConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

