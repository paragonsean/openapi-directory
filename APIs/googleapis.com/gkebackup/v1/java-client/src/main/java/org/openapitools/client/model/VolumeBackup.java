/*
 * Backup for GKE API
 * Backup for GKE is a managed Kubernetes workload backup and restore service for GKE clusters.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.NamespacedName;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the backup of a specific persistent volume as a component of a Backup - both the record of the operation and a pointer to the underlying storage-specific artifacts. Next id: 14
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:31.365638-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VolumeBackup {
  public static final String SERIALIZED_NAME_COMPLETE_TIME = "completeTime";
  @SerializedName(SERIALIZED_NAME_COMPLETE_TIME)
  private String completeTime;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DISK_SIZE_BYTES = "diskSizeBytes";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_BYTES)
  private String diskSizeBytes;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  /**
   * Output only. The format used for the volume backup.
   */
  @JsonAdapter(FormatEnum.Adapter.class)
  public enum FormatEnum {
    VOLUME_BACKUP_FORMAT_UNSPECIFIED("VOLUME_BACKUP_FORMAT_UNSPECIFIED"),
    
    GCE_PERSISTENT_DISK("GCE_PERSISTENT_DISK");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FormatEnum fromValue(String value) {
      for (FormatEnum b : FormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private FormatEnum format;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SOURCE_PVC = "sourcePvc";
  @SerializedName(SERIALIZED_NAME_SOURCE_PVC)
  private NamespacedName sourcePvc;

  /**
   * Output only. The current state of this VolumeBackup.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    CREATING("CREATING"),
    
    SNAPSHOTTING("SNAPSHOTTING"),
    
    UPLOADING("UPLOADING"),
    
    SUCCEEDED("SUCCEEDED"),
    
    FAILED("FAILED"),
    
    DELETING("DELETING");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_STATE_MESSAGE = "stateMessage";
  @SerializedName(SERIALIZED_NAME_STATE_MESSAGE)
  private String stateMessage;

  public static final String SERIALIZED_NAME_STORAGE_BYTES = "storageBytes";
  @SerializedName(SERIALIZED_NAME_STORAGE_BYTES)
  private String storageBytes;

  public static final String SERIALIZED_NAME_UID = "uid";
  @SerializedName(SERIALIZED_NAME_UID)
  private String uid;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_VOLUME_BACKUP_HANDLE = "volumeBackupHandle";
  @SerializedName(SERIALIZED_NAME_VOLUME_BACKUP_HANDLE)
  private String volumeBackupHandle;

  public VolumeBackup() {
  }

  public VolumeBackup(
     String completeTime, 
     String createTime, 
     String diskSizeBytes, 
     String etag, 
     FormatEnum format, 
     String name, 
     StateEnum state, 
     String stateMessage, 
     String storageBytes, 
     String uid, 
     String updateTime, 
     String volumeBackupHandle
  ) {
    this();
    this.completeTime = completeTime;
    this.createTime = createTime;
    this.diskSizeBytes = diskSizeBytes;
    this.etag = etag;
    this.format = format;
    this.name = name;
    this.state = state;
    this.stateMessage = stateMessage;
    this.storageBytes = storageBytes;
    this.uid = uid;
    this.updateTime = updateTime;
    this.volumeBackupHandle = volumeBackupHandle;
  }

  /**
   * Output only. The timestamp when the associated underlying volume backup operation completed.
   * @return completeTime
   */
  @javax.annotation.Nullable
  public String getCompleteTime() {
    return completeTime;
  }



  /**
   * Output only. The timestamp when this VolumeBackup resource was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. The minimum size of the disk to which this VolumeBackup can be restored.
   * @return diskSizeBytes
   */
  @javax.annotation.Nullable
  public String getDiskSizeBytes() {
    return diskSizeBytes;
  }



  /**
   * Output only. &#x60;etag&#x60; is used for optimistic concurrency control as a way to help prevent simultaneous updates of a volume backup from overwriting each other. It is strongly suggested that systems make use of the &#x60;etag&#x60; in the read-modify-write cycle to perform volume backup updates in order to avoid race conditions.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }



  /**
   * Output only. The format used for the volume backup.
   * @return format
   */
  @javax.annotation.Nullable
  public FormatEnum getFormat() {
    return format;
  }



  /**
   * Output only. The full name of the VolumeBackup resource. Format: &#x60;projects/_*_/locations/_*_/backupPlans/_*_/backups/_*_/volumeBackups/_*&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public VolumeBackup sourcePvc(NamespacedName sourcePvc) {
    this.sourcePvc = sourcePvc;
    return this;
  }

  /**
   * Get sourcePvc
   * @return sourcePvc
   */
  @javax.annotation.Nullable
  public NamespacedName getSourcePvc() {
    return sourcePvc;
  }

  public void setSourcePvc(NamespacedName sourcePvc) {
    this.sourcePvc = sourcePvc;
  }


  /**
   * Output only. The current state of this VolumeBackup.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  /**
   * Output only. A human readable message explaining why the VolumeBackup is in its current state.
   * @return stateMessage
   */
  @javax.annotation.Nullable
  public String getStateMessage() {
    return stateMessage;
  }



  /**
   * Output only. The aggregate size of the underlying artifacts associated with this VolumeBackup in the backup storage. This may change over time when multiple backups of the same volume share the same backup storage location. In particular, this is likely to increase in size when the immediately preceding backup of the same volume is deleted.
   * @return storageBytes
   */
  @javax.annotation.Nullable
  public String getStorageBytes() {
    return storageBytes;
  }



  /**
   * Output only. Server generated global unique identifier of [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
   * @return uid
   */
  @javax.annotation.Nullable
  public String getUid() {
    return uid;
  }



  /**
   * Output only. The timestamp when this VolumeBackup resource was last updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  /**
   * Output only. A storage system-specific opaque handle to the underlying volume backup.
   * @return volumeBackupHandle
   */
  @javax.annotation.Nullable
  public String getVolumeBackupHandle() {
    return volumeBackupHandle;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VolumeBackup volumeBackup = (VolumeBackup) o;
    return Objects.equals(this.completeTime, volumeBackup.completeTime) &&
        Objects.equals(this.createTime, volumeBackup.createTime) &&
        Objects.equals(this.diskSizeBytes, volumeBackup.diskSizeBytes) &&
        Objects.equals(this.etag, volumeBackup.etag) &&
        Objects.equals(this.format, volumeBackup.format) &&
        Objects.equals(this.name, volumeBackup.name) &&
        Objects.equals(this.sourcePvc, volumeBackup.sourcePvc) &&
        Objects.equals(this.state, volumeBackup.state) &&
        Objects.equals(this.stateMessage, volumeBackup.stateMessage) &&
        Objects.equals(this.storageBytes, volumeBackup.storageBytes) &&
        Objects.equals(this.uid, volumeBackup.uid) &&
        Objects.equals(this.updateTime, volumeBackup.updateTime) &&
        Objects.equals(this.volumeBackupHandle, volumeBackup.volumeBackupHandle);
  }

  @Override
  public int hashCode() {
    return Objects.hash(completeTime, createTime, diskSizeBytes, etag, format, name, sourcePvc, state, stateMessage, storageBytes, uid, updateTime, volumeBackupHandle);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VolumeBackup {\n");
    sb.append("    completeTime: ").append(toIndentedString(completeTime)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    diskSizeBytes: ").append(toIndentedString(diskSizeBytes)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    sourcePvc: ").append(toIndentedString(sourcePvc)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stateMessage: ").append(toIndentedString(stateMessage)).append("\n");
    sb.append("    storageBytes: ").append(toIndentedString(storageBytes)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    volumeBackupHandle: ").append(toIndentedString(volumeBackupHandle)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("completeTime");
    openapiFields.add("createTime");
    openapiFields.add("diskSizeBytes");
    openapiFields.add("etag");
    openapiFields.add("format");
    openapiFields.add("name");
    openapiFields.add("sourcePvc");
    openapiFields.add("state");
    openapiFields.add("stateMessage");
    openapiFields.add("storageBytes");
    openapiFields.add("uid");
    openapiFields.add("updateTime");
    openapiFields.add("volumeBackupHandle");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VolumeBackup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VolumeBackup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VolumeBackup is not found in the empty JSON string", VolumeBackup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VolumeBackup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VolumeBackup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("completeTime") != null && !jsonObj.get("completeTime").isJsonNull()) && !jsonObj.get("completeTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completeTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completeTime").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("diskSizeBytes") != null && !jsonObj.get("diskSizeBytes").isJsonNull()) && !jsonObj.get("diskSizeBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskSizeBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskSizeBytes").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      // validate the optional field `format`
      if (jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) {
        FormatEnum.validateJsonElement(jsonObj.get("format"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `sourcePvc`
      if (jsonObj.get("sourcePvc") != null && !jsonObj.get("sourcePvc").isJsonNull()) {
        NamespacedName.validateJsonElement(jsonObj.get("sourcePvc"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("stateMessage") != null && !jsonObj.get("stateMessage").isJsonNull()) && !jsonObj.get("stateMessage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stateMessage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stateMessage").toString()));
      }
      if ((jsonObj.get("storageBytes") != null && !jsonObj.get("storageBytes").isJsonNull()) && !jsonObj.get("storageBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageBytes").toString()));
      }
      if ((jsonObj.get("uid") != null && !jsonObj.get("uid").isJsonNull()) && !jsonObj.get("uid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      if ((jsonObj.get("volumeBackupHandle") != null && !jsonObj.get("volumeBackupHandle").isJsonNull()) && !jsonObj.get("volumeBackupHandle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `volumeBackupHandle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("volumeBackupHandle").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VolumeBackup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VolumeBackup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VolumeBackup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VolumeBackup.class));

       return (TypeAdapter<T>) new TypeAdapter<VolumeBackup>() {
           @Override
           public void write(JsonWriter out, VolumeBackup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VolumeBackup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VolumeBackup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VolumeBackup
   * @throws IOException if the JSON string is invalid with respect to VolumeBackup
   */
  public static VolumeBackup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VolumeBackup.class);
  }

  /**
   * Convert an instance of VolumeBackup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

