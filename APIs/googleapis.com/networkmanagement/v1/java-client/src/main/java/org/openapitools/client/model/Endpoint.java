/*
 * Network Management API
 * The Network Management API provides a collection of network performance monitoring and diagnostic capabilities.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AppEngineVersionEndpoint;
import org.openapitools.client.model.CloudFunctionEndpoint;
import org.openapitools.client.model.CloudRunRevisionEndpoint;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Source or destination of the Connectivity Test.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:04.582710-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Endpoint {
  public static final String SERIALIZED_NAME_APP_ENGINE_VERSION = "appEngineVersion";
  @SerializedName(SERIALIZED_NAME_APP_ENGINE_VERSION)
  private AppEngineVersionEndpoint appEngineVersion;

  public static final String SERIALIZED_NAME_CLOUD_FUNCTION = "cloudFunction";
  @SerializedName(SERIALIZED_NAME_CLOUD_FUNCTION)
  private CloudFunctionEndpoint cloudFunction;

  public static final String SERIALIZED_NAME_CLOUD_RUN_REVISION = "cloudRunRevision";
  @SerializedName(SERIALIZED_NAME_CLOUD_RUN_REVISION)
  private CloudRunRevisionEndpoint cloudRunRevision;

  public static final String SERIALIZED_NAME_CLOUD_SQL_INSTANCE = "cloudSqlInstance";
  @SerializedName(SERIALIZED_NAME_CLOUD_SQL_INSTANCE)
  private String cloudSqlInstance;

  public static final String SERIALIZED_NAME_FORWARDING_RULE = "forwardingRule";
  @SerializedName(SERIALIZED_NAME_FORWARDING_RULE)
  private String forwardingRule;

  /**
   * Output only. Specifies the type of the target of the forwarding rule.
   */
  @JsonAdapter(ForwardingRuleTargetEnum.Adapter.class)
  public enum ForwardingRuleTargetEnum {
    FORWARDING_RULE_TARGET_UNSPECIFIED("FORWARDING_RULE_TARGET_UNSPECIFIED"),
    
    INSTANCE("INSTANCE"),
    
    LOAD_BALANCER("LOAD_BALANCER"),
    
    VPN_GATEWAY("VPN_GATEWAY"),
    
    PSC("PSC");

    private String value;

    ForwardingRuleTargetEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ForwardingRuleTargetEnum fromValue(String value) {
      for (ForwardingRuleTargetEnum b : ForwardingRuleTargetEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ForwardingRuleTargetEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ForwardingRuleTargetEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ForwardingRuleTargetEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ForwardingRuleTargetEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ForwardingRuleTargetEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FORWARDING_RULE_TARGET = "forwardingRuleTarget";
  @SerializedName(SERIALIZED_NAME_FORWARDING_RULE_TARGET)
  private ForwardingRuleTargetEnum forwardingRuleTarget;

  public static final String SERIALIZED_NAME_GKE_MASTER_CLUSTER = "gkeMasterCluster";
  @SerializedName(SERIALIZED_NAME_GKE_MASTER_CLUSTER)
  private String gkeMasterCluster;

  public static final String SERIALIZED_NAME_INSTANCE = "instance";
  @SerializedName(SERIALIZED_NAME_INSTANCE)
  private String instance;

  public static final String SERIALIZED_NAME_IP_ADDRESS = "ipAddress";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS)
  private String ipAddress;

  public static final String SERIALIZED_NAME_LOAD_BALANCER_ID = "loadBalancerId";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCER_ID)
  private String loadBalancerId;

  /**
   * Output only. Type of the load balancer the forwarding rule points to.
   */
  @JsonAdapter(LoadBalancerTypeEnum.Adapter.class)
  public enum LoadBalancerTypeEnum {
    LOAD_BALANCER_TYPE_UNSPECIFIED("LOAD_BALANCER_TYPE_UNSPECIFIED"),
    
    HTTPS_ADVANCED_LOAD_BALANCER("HTTPS_ADVANCED_LOAD_BALANCER"),
    
    HTTPS_LOAD_BALANCER("HTTPS_LOAD_BALANCER"),
    
    REGIONAL_HTTPS_LOAD_BALANCER("REGIONAL_HTTPS_LOAD_BALANCER"),
    
    INTERNAL_HTTPS_LOAD_BALANCER("INTERNAL_HTTPS_LOAD_BALANCER"),
    
    SSL_PROXY_LOAD_BALANCER("SSL_PROXY_LOAD_BALANCER"),
    
    TCP_PROXY_LOAD_BALANCER("TCP_PROXY_LOAD_BALANCER"),
    
    INTERNAL_TCP_PROXY_LOAD_BALANCER("INTERNAL_TCP_PROXY_LOAD_BALANCER"),
    
    NETWORK_LOAD_BALANCER("NETWORK_LOAD_BALANCER"),
    
    LEGACY_NETWORK_LOAD_BALANCER("LEGACY_NETWORK_LOAD_BALANCER"),
    
    TCP_UDP_INTERNAL_LOAD_BALANCER("TCP_UDP_INTERNAL_LOAD_BALANCER");

    private String value;

    LoadBalancerTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LoadBalancerTypeEnum fromValue(String value) {
      for (LoadBalancerTypeEnum b : LoadBalancerTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LoadBalancerTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LoadBalancerTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LoadBalancerTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LoadBalancerTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LoadBalancerTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOAD_BALANCER_TYPE = "loadBalancerType";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCER_TYPE)
  private LoadBalancerTypeEnum loadBalancerType;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  /**
   * Type of the network where the endpoint is located. Applicable only to source endpoint, as destination network type can be inferred from the source.
   */
  @JsonAdapter(NetworkTypeEnum.Adapter.class)
  public enum NetworkTypeEnum {
    NETWORK_TYPE_UNSPECIFIED("NETWORK_TYPE_UNSPECIFIED"),
    
    GCP_NETWORK("GCP_NETWORK"),
    
    NON_GCP_NETWORK("NON_GCP_NETWORK");

    private String value;

    NetworkTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NetworkTypeEnum fromValue(String value) {
      for (NetworkTypeEnum b : NetworkTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<NetworkTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NetworkTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NetworkTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NetworkTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      NetworkTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_NETWORK_TYPE = "networkType";
  @SerializedName(SERIALIZED_NAME_NETWORK_TYPE)
  private NetworkTypeEnum networkType;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Integer port;

  public static final String SERIALIZED_NAME_PROJECT_ID = "projectId";
  @SerializedName(SERIALIZED_NAME_PROJECT_ID)
  private String projectId;

  public Endpoint() {
  }

  public Endpoint(
     ForwardingRuleTargetEnum forwardingRuleTarget, 
     String loadBalancerId, 
     LoadBalancerTypeEnum loadBalancerType
  ) {
    this();
    this.forwardingRuleTarget = forwardingRuleTarget;
    this.loadBalancerId = loadBalancerId;
    this.loadBalancerType = loadBalancerType;
  }

  public Endpoint appEngineVersion(AppEngineVersionEndpoint appEngineVersion) {
    this.appEngineVersion = appEngineVersion;
    return this;
  }

  /**
   * Get appEngineVersion
   * @return appEngineVersion
   */
  @javax.annotation.Nullable
  public AppEngineVersionEndpoint getAppEngineVersion() {
    return appEngineVersion;
  }

  public void setAppEngineVersion(AppEngineVersionEndpoint appEngineVersion) {
    this.appEngineVersion = appEngineVersion;
  }


  public Endpoint cloudFunction(CloudFunctionEndpoint cloudFunction) {
    this.cloudFunction = cloudFunction;
    return this;
  }

  /**
   * Get cloudFunction
   * @return cloudFunction
   */
  @javax.annotation.Nullable
  public CloudFunctionEndpoint getCloudFunction() {
    return cloudFunction;
  }

  public void setCloudFunction(CloudFunctionEndpoint cloudFunction) {
    this.cloudFunction = cloudFunction;
  }


  public Endpoint cloudRunRevision(CloudRunRevisionEndpoint cloudRunRevision) {
    this.cloudRunRevision = cloudRunRevision;
    return this;
  }

  /**
   * Get cloudRunRevision
   * @return cloudRunRevision
   */
  @javax.annotation.Nullable
  public CloudRunRevisionEndpoint getCloudRunRevision() {
    return cloudRunRevision;
  }

  public void setCloudRunRevision(CloudRunRevisionEndpoint cloudRunRevision) {
    this.cloudRunRevision = cloudRunRevision;
  }


  public Endpoint cloudSqlInstance(String cloudSqlInstance) {
    this.cloudSqlInstance = cloudSqlInstance;
    return this;
  }

  /**
   * A [Cloud SQL](https://cloud.google.com/sql) instance URI.
   * @return cloudSqlInstance
   */
  @javax.annotation.Nullable
  public String getCloudSqlInstance() {
    return cloudSqlInstance;
  }

  public void setCloudSqlInstance(String cloudSqlInstance) {
    this.cloudSqlInstance = cloudSqlInstance;
  }


  public Endpoint forwardingRule(String forwardingRule) {
    this.forwardingRule = forwardingRule;
    return this;
  }

  /**
   * A forwarding rule and its corresponding IP address represent the frontend configuration of a Google Cloud load balancer. Forwarding rules are also used for protocol forwarding, Private Service Connect and other network services to provide forwarding information in the control plane. Format: projects/{project}/global/forwardingRules/{id} or projects/{project}/regions/{region}/forwardingRules/{id}
   * @return forwardingRule
   */
  @javax.annotation.Nullable
  public String getForwardingRule() {
    return forwardingRule;
  }

  public void setForwardingRule(String forwardingRule) {
    this.forwardingRule = forwardingRule;
  }


  /**
   * Output only. Specifies the type of the target of the forwarding rule.
   * @return forwardingRuleTarget
   */
  @javax.annotation.Nullable
  public ForwardingRuleTargetEnum getForwardingRuleTarget() {
    return forwardingRuleTarget;
  }



  public Endpoint gkeMasterCluster(String gkeMasterCluster) {
    this.gkeMasterCluster = gkeMasterCluster;
    return this;
  }

  /**
   * A cluster URI for [Google Kubernetes Engine master](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
   * @return gkeMasterCluster
   */
  @javax.annotation.Nullable
  public String getGkeMasterCluster() {
    return gkeMasterCluster;
  }

  public void setGkeMasterCluster(String gkeMasterCluster) {
    this.gkeMasterCluster = gkeMasterCluster;
  }


  public Endpoint instance(String instance) {
    this.instance = instance;
    return this;
  }

  /**
   * A Compute Engine instance URI.
   * @return instance
   */
  @javax.annotation.Nullable
  public String getInstance() {
    return instance;
  }

  public void setInstance(String instance) {
    this.instance = instance;
  }


  public Endpoint ipAddress(String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

  /**
   * The IP address of the endpoint, which can be an external or internal IP.
   * @return ipAddress
   */
  @javax.annotation.Nullable
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }


  /**
   * Output only. ID of the load balancer the forwarding rule points to. Empty for forwarding rules not related to load balancers.
   * @return loadBalancerId
   */
  @javax.annotation.Nullable
  public String getLoadBalancerId() {
    return loadBalancerId;
  }



  /**
   * Output only. Type of the load balancer the forwarding rule points to.
   * @return loadBalancerType
   */
  @javax.annotation.Nullable
  public LoadBalancerTypeEnum getLoadBalancerType() {
    return loadBalancerType;
  }



  public Endpoint network(String network) {
    this.network = network;
    return this;
  }

  /**
   * A Compute Engine network URI.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public Endpoint networkType(NetworkTypeEnum networkType) {
    this.networkType = networkType;
    return this;
  }

  /**
   * Type of the network where the endpoint is located. Applicable only to source endpoint, as destination network type can be inferred from the source.
   * @return networkType
   */
  @javax.annotation.Nullable
  public NetworkTypeEnum getNetworkType() {
    return networkType;
  }

  public void setNetworkType(NetworkTypeEnum networkType) {
    this.networkType = networkType;
  }


  public Endpoint port(Integer port) {
    this.port = port;
    return this;
  }

  /**
   * The IP protocol port of the endpoint. Only applicable when protocol is TCP or UDP.
   * @return port
   */
  @javax.annotation.Nullable
  public Integer getPort() {
    return port;
  }

  public void setPort(Integer port) {
    this.port = port;
  }


  public Endpoint projectId(String projectId) {
    this.projectId = projectId;
    return this;
  }

  /**
   * Project ID where the endpoint is located. The Project ID can be derived from the URI if you provide a VM instance or network URI. The following are two cases where you must provide the project ID: 1. Only the IP address is specified, and the IP address is within a Google Cloud project. 2. When you are using Shared VPC and the IP address that you provide is from the service project. In this case, the network that the IP address resides in is defined in the host project.
   * @return projectId
   */
  @javax.annotation.Nullable
  public String getProjectId() {
    return projectId;
  }

  public void setProjectId(String projectId) {
    this.projectId = projectId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Endpoint endpoint = (Endpoint) o;
    return Objects.equals(this.appEngineVersion, endpoint.appEngineVersion) &&
        Objects.equals(this.cloudFunction, endpoint.cloudFunction) &&
        Objects.equals(this.cloudRunRevision, endpoint.cloudRunRevision) &&
        Objects.equals(this.cloudSqlInstance, endpoint.cloudSqlInstance) &&
        Objects.equals(this.forwardingRule, endpoint.forwardingRule) &&
        Objects.equals(this.forwardingRuleTarget, endpoint.forwardingRuleTarget) &&
        Objects.equals(this.gkeMasterCluster, endpoint.gkeMasterCluster) &&
        Objects.equals(this.instance, endpoint.instance) &&
        Objects.equals(this.ipAddress, endpoint.ipAddress) &&
        Objects.equals(this.loadBalancerId, endpoint.loadBalancerId) &&
        Objects.equals(this.loadBalancerType, endpoint.loadBalancerType) &&
        Objects.equals(this.network, endpoint.network) &&
        Objects.equals(this.networkType, endpoint.networkType) &&
        Objects.equals(this.port, endpoint.port) &&
        Objects.equals(this.projectId, endpoint.projectId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appEngineVersion, cloudFunction, cloudRunRevision, cloudSqlInstance, forwardingRule, forwardingRuleTarget, gkeMasterCluster, instance, ipAddress, loadBalancerId, loadBalancerType, network, networkType, port, projectId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Endpoint {\n");
    sb.append("    appEngineVersion: ").append(toIndentedString(appEngineVersion)).append("\n");
    sb.append("    cloudFunction: ").append(toIndentedString(cloudFunction)).append("\n");
    sb.append("    cloudRunRevision: ").append(toIndentedString(cloudRunRevision)).append("\n");
    sb.append("    cloudSqlInstance: ").append(toIndentedString(cloudSqlInstance)).append("\n");
    sb.append("    forwardingRule: ").append(toIndentedString(forwardingRule)).append("\n");
    sb.append("    forwardingRuleTarget: ").append(toIndentedString(forwardingRuleTarget)).append("\n");
    sb.append("    gkeMasterCluster: ").append(toIndentedString(gkeMasterCluster)).append("\n");
    sb.append("    instance: ").append(toIndentedString(instance)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    loadBalancerId: ").append(toIndentedString(loadBalancerId)).append("\n");
    sb.append("    loadBalancerType: ").append(toIndentedString(loadBalancerType)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    networkType: ").append(toIndentedString(networkType)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    projectId: ").append(toIndentedString(projectId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("appEngineVersion");
    openapiFields.add("cloudFunction");
    openapiFields.add("cloudRunRevision");
    openapiFields.add("cloudSqlInstance");
    openapiFields.add("forwardingRule");
    openapiFields.add("forwardingRuleTarget");
    openapiFields.add("gkeMasterCluster");
    openapiFields.add("instance");
    openapiFields.add("ipAddress");
    openapiFields.add("loadBalancerId");
    openapiFields.add("loadBalancerType");
    openapiFields.add("network");
    openapiFields.add("networkType");
    openapiFields.add("port");
    openapiFields.add("projectId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Endpoint
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Endpoint.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Endpoint is not found in the empty JSON string", Endpoint.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Endpoint.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Endpoint` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `appEngineVersion`
      if (jsonObj.get("appEngineVersion") != null && !jsonObj.get("appEngineVersion").isJsonNull()) {
        AppEngineVersionEndpoint.validateJsonElement(jsonObj.get("appEngineVersion"));
      }
      // validate the optional field `cloudFunction`
      if (jsonObj.get("cloudFunction") != null && !jsonObj.get("cloudFunction").isJsonNull()) {
        CloudFunctionEndpoint.validateJsonElement(jsonObj.get("cloudFunction"));
      }
      // validate the optional field `cloudRunRevision`
      if (jsonObj.get("cloudRunRevision") != null && !jsonObj.get("cloudRunRevision").isJsonNull()) {
        CloudRunRevisionEndpoint.validateJsonElement(jsonObj.get("cloudRunRevision"));
      }
      if ((jsonObj.get("cloudSqlInstance") != null && !jsonObj.get("cloudSqlInstance").isJsonNull()) && !jsonObj.get("cloudSqlInstance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cloudSqlInstance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cloudSqlInstance").toString()));
      }
      if ((jsonObj.get("forwardingRule") != null && !jsonObj.get("forwardingRule").isJsonNull()) && !jsonObj.get("forwardingRule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forwardingRule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forwardingRule").toString()));
      }
      if ((jsonObj.get("forwardingRuleTarget") != null && !jsonObj.get("forwardingRuleTarget").isJsonNull()) && !jsonObj.get("forwardingRuleTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forwardingRuleTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forwardingRuleTarget").toString()));
      }
      // validate the optional field `forwardingRuleTarget`
      if (jsonObj.get("forwardingRuleTarget") != null && !jsonObj.get("forwardingRuleTarget").isJsonNull()) {
        ForwardingRuleTargetEnum.validateJsonElement(jsonObj.get("forwardingRuleTarget"));
      }
      if ((jsonObj.get("gkeMasterCluster") != null && !jsonObj.get("gkeMasterCluster").isJsonNull()) && !jsonObj.get("gkeMasterCluster").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gkeMasterCluster` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gkeMasterCluster").toString()));
      }
      if ((jsonObj.get("instance") != null && !jsonObj.get("instance").isJsonNull()) && !jsonObj.get("instance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instance").toString()));
      }
      if ((jsonObj.get("ipAddress") != null && !jsonObj.get("ipAddress").isJsonNull()) && !jsonObj.get("ipAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipAddress").toString()));
      }
      if ((jsonObj.get("loadBalancerId") != null && !jsonObj.get("loadBalancerId").isJsonNull()) && !jsonObj.get("loadBalancerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loadBalancerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loadBalancerId").toString()));
      }
      if ((jsonObj.get("loadBalancerType") != null && !jsonObj.get("loadBalancerType").isJsonNull()) && !jsonObj.get("loadBalancerType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loadBalancerType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loadBalancerType").toString()));
      }
      // validate the optional field `loadBalancerType`
      if (jsonObj.get("loadBalancerType") != null && !jsonObj.get("loadBalancerType").isJsonNull()) {
        LoadBalancerTypeEnum.validateJsonElement(jsonObj.get("loadBalancerType"));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("networkType") != null && !jsonObj.get("networkType").isJsonNull()) && !jsonObj.get("networkType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkType").toString()));
      }
      // validate the optional field `networkType`
      if (jsonObj.get("networkType") != null && !jsonObj.get("networkType").isJsonNull()) {
        NetworkTypeEnum.validateJsonElement(jsonObj.get("networkType"));
      }
      if ((jsonObj.get("projectId") != null && !jsonObj.get("projectId").isJsonNull()) && !jsonObj.get("projectId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projectId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projectId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Endpoint.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Endpoint' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Endpoint> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Endpoint.class));

       return (TypeAdapter<T>) new TypeAdapter<Endpoint>() {
           @Override
           public void write(JsonWriter out, Endpoint value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Endpoint read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Endpoint given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Endpoint
   * @throws IOException if the JSON string is invalid with respect to Endpoint
   */
  public static Endpoint fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Endpoint.class);
  }

  /**
   * Convert an instance of Endpoint to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

