/**
 * Network Management API
 * The Network Management API provides a collection of network performance monitoring and diagnostic capabilities.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRouteInfo.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRouteInfo::OAIRouteInfo(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRouteInfo::OAIRouteInfo() {
    this->initializeModel();
}

OAIRouteInfo::~OAIRouteInfo() {}

void OAIRouteInfo::initializeModel() {

    m_dest_ip_range_isSet = false;
    m_dest_ip_range_isValid = false;

    m_dest_port_ranges_isSet = false;
    m_dest_port_ranges_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_instance_tags_isSet = false;
    m_instance_tags_isValid = false;

    m_ncc_hub_uri_isSet = false;
    m_ncc_hub_uri_isValid = false;

    m_ncc_spoke_uri_isSet = false;
    m_ncc_spoke_uri_isValid = false;

    m_network_uri_isSet = false;
    m_network_uri_isValid = false;

    m_next_hop_isSet = false;
    m_next_hop_isValid = false;

    m_next_hop_type_isSet = false;
    m_next_hop_type_isValid = false;

    m_priority_isSet = false;
    m_priority_isValid = false;

    m_protocols_isSet = false;
    m_protocols_isValid = false;

    m_route_scope_isSet = false;
    m_route_scope_isValid = false;

    m_route_type_isSet = false;
    m_route_type_isValid = false;

    m_src_ip_range_isSet = false;
    m_src_ip_range_isValid = false;

    m_src_port_ranges_isSet = false;
    m_src_port_ranges_isValid = false;

    m_uri_isSet = false;
    m_uri_isValid = false;
}

void OAIRouteInfo::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRouteInfo::fromJsonObject(QJsonObject json) {

    m_dest_ip_range_isValid = ::OpenAPI::fromJsonValue(m_dest_ip_range, json[QString("destIpRange")]);
    m_dest_ip_range_isSet = !json[QString("destIpRange")].isNull() && m_dest_ip_range_isValid;

    m_dest_port_ranges_isValid = ::OpenAPI::fromJsonValue(m_dest_port_ranges, json[QString("destPortRanges")]);
    m_dest_port_ranges_isSet = !json[QString("destPortRanges")].isNull() && m_dest_port_ranges_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_instance_tags_isValid = ::OpenAPI::fromJsonValue(m_instance_tags, json[QString("instanceTags")]);
    m_instance_tags_isSet = !json[QString("instanceTags")].isNull() && m_instance_tags_isValid;

    m_ncc_hub_uri_isValid = ::OpenAPI::fromJsonValue(m_ncc_hub_uri, json[QString("nccHubUri")]);
    m_ncc_hub_uri_isSet = !json[QString("nccHubUri")].isNull() && m_ncc_hub_uri_isValid;

    m_ncc_spoke_uri_isValid = ::OpenAPI::fromJsonValue(m_ncc_spoke_uri, json[QString("nccSpokeUri")]);
    m_ncc_spoke_uri_isSet = !json[QString("nccSpokeUri")].isNull() && m_ncc_spoke_uri_isValid;

    m_network_uri_isValid = ::OpenAPI::fromJsonValue(m_network_uri, json[QString("networkUri")]);
    m_network_uri_isSet = !json[QString("networkUri")].isNull() && m_network_uri_isValid;

    m_next_hop_isValid = ::OpenAPI::fromJsonValue(m_next_hop, json[QString("nextHop")]);
    m_next_hop_isSet = !json[QString("nextHop")].isNull() && m_next_hop_isValid;

    m_next_hop_type_isValid = ::OpenAPI::fromJsonValue(m_next_hop_type, json[QString("nextHopType")]);
    m_next_hop_type_isSet = !json[QString("nextHopType")].isNull() && m_next_hop_type_isValid;

    m_priority_isValid = ::OpenAPI::fromJsonValue(m_priority, json[QString("priority")]);
    m_priority_isSet = !json[QString("priority")].isNull() && m_priority_isValid;

    m_protocols_isValid = ::OpenAPI::fromJsonValue(m_protocols, json[QString("protocols")]);
    m_protocols_isSet = !json[QString("protocols")].isNull() && m_protocols_isValid;

    m_route_scope_isValid = ::OpenAPI::fromJsonValue(m_route_scope, json[QString("routeScope")]);
    m_route_scope_isSet = !json[QString("routeScope")].isNull() && m_route_scope_isValid;

    m_route_type_isValid = ::OpenAPI::fromJsonValue(m_route_type, json[QString("routeType")]);
    m_route_type_isSet = !json[QString("routeType")].isNull() && m_route_type_isValid;

    m_src_ip_range_isValid = ::OpenAPI::fromJsonValue(m_src_ip_range, json[QString("srcIpRange")]);
    m_src_ip_range_isSet = !json[QString("srcIpRange")].isNull() && m_src_ip_range_isValid;

    m_src_port_ranges_isValid = ::OpenAPI::fromJsonValue(m_src_port_ranges, json[QString("srcPortRanges")]);
    m_src_port_ranges_isSet = !json[QString("srcPortRanges")].isNull() && m_src_port_ranges_isValid;

    m_uri_isValid = ::OpenAPI::fromJsonValue(m_uri, json[QString("uri")]);
    m_uri_isSet = !json[QString("uri")].isNull() && m_uri_isValid;
}

QString OAIRouteInfo::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRouteInfo::asJsonObject() const {
    QJsonObject obj;
    if (m_dest_ip_range_isSet) {
        obj.insert(QString("destIpRange"), ::OpenAPI::toJsonValue(m_dest_ip_range));
    }
    if (m_dest_port_ranges.size() > 0) {
        obj.insert(QString("destPortRanges"), ::OpenAPI::toJsonValue(m_dest_port_ranges));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_instance_tags.size() > 0) {
        obj.insert(QString("instanceTags"), ::OpenAPI::toJsonValue(m_instance_tags));
    }
    if (m_ncc_hub_uri_isSet) {
        obj.insert(QString("nccHubUri"), ::OpenAPI::toJsonValue(m_ncc_hub_uri));
    }
    if (m_ncc_spoke_uri_isSet) {
        obj.insert(QString("nccSpokeUri"), ::OpenAPI::toJsonValue(m_ncc_spoke_uri));
    }
    if (m_network_uri_isSet) {
        obj.insert(QString("networkUri"), ::OpenAPI::toJsonValue(m_network_uri));
    }
    if (m_next_hop_isSet) {
        obj.insert(QString("nextHop"), ::OpenAPI::toJsonValue(m_next_hop));
    }
    if (m_next_hop_type_isSet) {
        obj.insert(QString("nextHopType"), ::OpenAPI::toJsonValue(m_next_hop_type));
    }
    if (m_priority_isSet) {
        obj.insert(QString("priority"), ::OpenAPI::toJsonValue(m_priority));
    }
    if (m_protocols.size() > 0) {
        obj.insert(QString("protocols"), ::OpenAPI::toJsonValue(m_protocols));
    }
    if (m_route_scope_isSet) {
        obj.insert(QString("routeScope"), ::OpenAPI::toJsonValue(m_route_scope));
    }
    if (m_route_type_isSet) {
        obj.insert(QString("routeType"), ::OpenAPI::toJsonValue(m_route_type));
    }
    if (m_src_ip_range_isSet) {
        obj.insert(QString("srcIpRange"), ::OpenAPI::toJsonValue(m_src_ip_range));
    }
    if (m_src_port_ranges.size() > 0) {
        obj.insert(QString("srcPortRanges"), ::OpenAPI::toJsonValue(m_src_port_ranges));
    }
    if (m_uri_isSet) {
        obj.insert(QString("uri"), ::OpenAPI::toJsonValue(m_uri));
    }
    return obj;
}

QString OAIRouteInfo::getDestIpRange() const {
    return m_dest_ip_range;
}
void OAIRouteInfo::setDestIpRange(const QString &dest_ip_range) {
    m_dest_ip_range = dest_ip_range;
    m_dest_ip_range_isSet = true;
}

bool OAIRouteInfo::is_dest_ip_range_Set() const{
    return m_dest_ip_range_isSet;
}

bool OAIRouteInfo::is_dest_ip_range_Valid() const{
    return m_dest_ip_range_isValid;
}

QList<QString> OAIRouteInfo::getDestPortRanges() const {
    return m_dest_port_ranges;
}
void OAIRouteInfo::setDestPortRanges(const QList<QString> &dest_port_ranges) {
    m_dest_port_ranges = dest_port_ranges;
    m_dest_port_ranges_isSet = true;
}

bool OAIRouteInfo::is_dest_port_ranges_Set() const{
    return m_dest_port_ranges_isSet;
}

bool OAIRouteInfo::is_dest_port_ranges_Valid() const{
    return m_dest_port_ranges_isValid;
}

QString OAIRouteInfo::getDisplayName() const {
    return m_display_name;
}
void OAIRouteInfo::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIRouteInfo::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIRouteInfo::is_display_name_Valid() const{
    return m_display_name_isValid;
}

QList<QString> OAIRouteInfo::getInstanceTags() const {
    return m_instance_tags;
}
void OAIRouteInfo::setInstanceTags(const QList<QString> &instance_tags) {
    m_instance_tags = instance_tags;
    m_instance_tags_isSet = true;
}

bool OAIRouteInfo::is_instance_tags_Set() const{
    return m_instance_tags_isSet;
}

bool OAIRouteInfo::is_instance_tags_Valid() const{
    return m_instance_tags_isValid;
}

QString OAIRouteInfo::getNccHubUri() const {
    return m_ncc_hub_uri;
}
void OAIRouteInfo::setNccHubUri(const QString &ncc_hub_uri) {
    m_ncc_hub_uri = ncc_hub_uri;
    m_ncc_hub_uri_isSet = true;
}

bool OAIRouteInfo::is_ncc_hub_uri_Set() const{
    return m_ncc_hub_uri_isSet;
}

bool OAIRouteInfo::is_ncc_hub_uri_Valid() const{
    return m_ncc_hub_uri_isValid;
}

QString OAIRouteInfo::getNccSpokeUri() const {
    return m_ncc_spoke_uri;
}
void OAIRouteInfo::setNccSpokeUri(const QString &ncc_spoke_uri) {
    m_ncc_spoke_uri = ncc_spoke_uri;
    m_ncc_spoke_uri_isSet = true;
}

bool OAIRouteInfo::is_ncc_spoke_uri_Set() const{
    return m_ncc_spoke_uri_isSet;
}

bool OAIRouteInfo::is_ncc_spoke_uri_Valid() const{
    return m_ncc_spoke_uri_isValid;
}

QString OAIRouteInfo::getNetworkUri() const {
    return m_network_uri;
}
void OAIRouteInfo::setNetworkUri(const QString &network_uri) {
    m_network_uri = network_uri;
    m_network_uri_isSet = true;
}

bool OAIRouteInfo::is_network_uri_Set() const{
    return m_network_uri_isSet;
}

bool OAIRouteInfo::is_network_uri_Valid() const{
    return m_network_uri_isValid;
}

QString OAIRouteInfo::getNextHop() const {
    return m_next_hop;
}
void OAIRouteInfo::setNextHop(const QString &next_hop) {
    m_next_hop = next_hop;
    m_next_hop_isSet = true;
}

bool OAIRouteInfo::is_next_hop_Set() const{
    return m_next_hop_isSet;
}

bool OAIRouteInfo::is_next_hop_Valid() const{
    return m_next_hop_isValid;
}

QString OAIRouteInfo::getNextHopType() const {
    return m_next_hop_type;
}
void OAIRouteInfo::setNextHopType(const QString &next_hop_type) {
    m_next_hop_type = next_hop_type;
    m_next_hop_type_isSet = true;
}

bool OAIRouteInfo::is_next_hop_type_Set() const{
    return m_next_hop_type_isSet;
}

bool OAIRouteInfo::is_next_hop_type_Valid() const{
    return m_next_hop_type_isValid;
}

qint32 OAIRouteInfo::getPriority() const {
    return m_priority;
}
void OAIRouteInfo::setPriority(const qint32 &priority) {
    m_priority = priority;
    m_priority_isSet = true;
}

bool OAIRouteInfo::is_priority_Set() const{
    return m_priority_isSet;
}

bool OAIRouteInfo::is_priority_Valid() const{
    return m_priority_isValid;
}

QList<QString> OAIRouteInfo::getProtocols() const {
    return m_protocols;
}
void OAIRouteInfo::setProtocols(const QList<QString> &protocols) {
    m_protocols = protocols;
    m_protocols_isSet = true;
}

bool OAIRouteInfo::is_protocols_Set() const{
    return m_protocols_isSet;
}

bool OAIRouteInfo::is_protocols_Valid() const{
    return m_protocols_isValid;
}

QString OAIRouteInfo::getRouteScope() const {
    return m_route_scope;
}
void OAIRouteInfo::setRouteScope(const QString &route_scope) {
    m_route_scope = route_scope;
    m_route_scope_isSet = true;
}

bool OAIRouteInfo::is_route_scope_Set() const{
    return m_route_scope_isSet;
}

bool OAIRouteInfo::is_route_scope_Valid() const{
    return m_route_scope_isValid;
}

QString OAIRouteInfo::getRouteType() const {
    return m_route_type;
}
void OAIRouteInfo::setRouteType(const QString &route_type) {
    m_route_type = route_type;
    m_route_type_isSet = true;
}

bool OAIRouteInfo::is_route_type_Set() const{
    return m_route_type_isSet;
}

bool OAIRouteInfo::is_route_type_Valid() const{
    return m_route_type_isValid;
}

QString OAIRouteInfo::getSrcIpRange() const {
    return m_src_ip_range;
}
void OAIRouteInfo::setSrcIpRange(const QString &src_ip_range) {
    m_src_ip_range = src_ip_range;
    m_src_ip_range_isSet = true;
}

bool OAIRouteInfo::is_src_ip_range_Set() const{
    return m_src_ip_range_isSet;
}

bool OAIRouteInfo::is_src_ip_range_Valid() const{
    return m_src_ip_range_isValid;
}

QList<QString> OAIRouteInfo::getSrcPortRanges() const {
    return m_src_port_ranges;
}
void OAIRouteInfo::setSrcPortRanges(const QList<QString> &src_port_ranges) {
    m_src_port_ranges = src_port_ranges;
    m_src_port_ranges_isSet = true;
}

bool OAIRouteInfo::is_src_port_ranges_Set() const{
    return m_src_port_ranges_isSet;
}

bool OAIRouteInfo::is_src_port_ranges_Valid() const{
    return m_src_port_ranges_isValid;
}

QString OAIRouteInfo::getUri() const {
    return m_uri;
}
void OAIRouteInfo::setUri(const QString &uri) {
    m_uri = uri;
    m_uri_isSet = true;
}

bool OAIRouteInfo::is_uri_Set() const{
    return m_uri_isSet;
}

bool OAIRouteInfo::is_uri_Valid() const{
    return m_uri_isValid;
}

bool OAIRouteInfo::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_dest_ip_range_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dest_port_ranges.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_ncc_hub_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ncc_spoke_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_hop_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_hop_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_priority_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocols.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_route_scope_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_route_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_ip_range_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_port_ranges.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_uri_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRouteInfo::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
