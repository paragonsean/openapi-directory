/*
 * Calendar API
 * Manipulates events and other calendar data.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ConferenceData;
import org.openapitools.client.model.EventAttachment;
import org.openapitools.client.model.EventAttendee;
import org.openapitools.client.model.EventCreator;
import org.openapitools.client.model.EventDateTime;
import org.openapitools.client.model.EventExtendedProperties;
import org.openapitools.client.model.EventFocusTimeProperties;
import org.openapitools.client.model.EventGadget;
import org.openapitools.client.model.EventOrganizer;
import org.openapitools.client.model.EventOutOfOfficeProperties;
import org.openapitools.client.model.EventReminders;
import org.openapitools.client.model.EventSource;
import org.openapitools.client.model.EventWorkingLocationProperties;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Event
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:09.684550-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Event {
  public static final String SERIALIZED_NAME_ANYONE_CAN_ADD_SELF = "anyoneCanAddSelf";
  @SerializedName(SERIALIZED_NAME_ANYONE_CAN_ADD_SELF)
  private Boolean anyoneCanAddSelf = false;

  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private List<EventAttachment> attachments = new ArrayList<>();

  public static final String SERIALIZED_NAME_ATTENDEES = "attendees";
  @SerializedName(SERIALIZED_NAME_ATTENDEES)
  private List<EventAttendee> attendees = new ArrayList<>();

  public static final String SERIALIZED_NAME_ATTENDEES_OMITTED = "attendeesOmitted";
  @SerializedName(SERIALIZED_NAME_ATTENDEES_OMITTED)
  private Boolean attendeesOmitted = false;

  public static final String SERIALIZED_NAME_COLOR_ID = "colorId";
  @SerializedName(SERIALIZED_NAME_COLOR_ID)
  private String colorId;

  public static final String SERIALIZED_NAME_CONFERENCE_DATA = "conferenceData";
  @SerializedName(SERIALIZED_NAME_CONFERENCE_DATA)
  private ConferenceData conferenceData;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_CREATOR = "creator";
  @SerializedName(SERIALIZED_NAME_CREATOR)
  private EventCreator creator;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_END = "end";
  @SerializedName(SERIALIZED_NAME_END)
  private EventDateTime end;

  public static final String SERIALIZED_NAME_END_TIME_UNSPECIFIED = "endTimeUnspecified";
  @SerializedName(SERIALIZED_NAME_END_TIME_UNSPECIFIED)
  private Boolean endTimeUnspecified = false;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_EVENT_TYPE = "eventType";
  @SerializedName(SERIALIZED_NAME_EVENT_TYPE)
  private String eventType = "default";

  public static final String SERIALIZED_NAME_EXTENDED_PROPERTIES = "extendedProperties";
  @SerializedName(SERIALIZED_NAME_EXTENDED_PROPERTIES)
  private EventExtendedProperties extendedProperties;

  public static final String SERIALIZED_NAME_FOCUS_TIME_PROPERTIES = "focusTimeProperties";
  @SerializedName(SERIALIZED_NAME_FOCUS_TIME_PROPERTIES)
  private EventFocusTimeProperties focusTimeProperties;

  public static final String SERIALIZED_NAME_GADGET = "gadget";
  @SerializedName(SERIALIZED_NAME_GADGET)
  private EventGadget gadget;

  public static final String SERIALIZED_NAME_GUESTS_CAN_INVITE_OTHERS = "guestsCanInviteOthers";
  @SerializedName(SERIALIZED_NAME_GUESTS_CAN_INVITE_OTHERS)
  private Boolean guestsCanInviteOthers = true;

  public static final String SERIALIZED_NAME_GUESTS_CAN_MODIFY = "guestsCanModify";
  @SerializedName(SERIALIZED_NAME_GUESTS_CAN_MODIFY)
  private Boolean guestsCanModify = false;

  public static final String SERIALIZED_NAME_GUESTS_CAN_SEE_OTHER_GUESTS = "guestsCanSeeOtherGuests";
  @SerializedName(SERIALIZED_NAME_GUESTS_CAN_SEE_OTHER_GUESTS)
  private Boolean guestsCanSeeOtherGuests = true;

  public static final String SERIALIZED_NAME_HANGOUT_LINK = "hangoutLink";
  @SerializedName(SERIALIZED_NAME_HANGOUT_LINK)
  private String hangoutLink;

  public static final String SERIALIZED_NAME_HTML_LINK = "htmlLink";
  @SerializedName(SERIALIZED_NAME_HTML_LINK)
  private String htmlLink;

  public static final String SERIALIZED_NAME_I_CAL_U_I_D = "iCalUID";
  @SerializedName(SERIALIZED_NAME_I_CAL_U_I_D)
  private String iCalUID;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "calendar#event";

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_LOCKED = "locked";
  @SerializedName(SERIALIZED_NAME_LOCKED)
  private Boolean locked = false;

  public static final String SERIALIZED_NAME_ORGANIZER = "organizer";
  @SerializedName(SERIALIZED_NAME_ORGANIZER)
  private EventOrganizer organizer;

  public static final String SERIALIZED_NAME_ORIGINAL_START_TIME = "originalStartTime";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_START_TIME)
  private EventDateTime originalStartTime;

  public static final String SERIALIZED_NAME_OUT_OF_OFFICE_PROPERTIES = "outOfOfficeProperties";
  @SerializedName(SERIALIZED_NAME_OUT_OF_OFFICE_PROPERTIES)
  private EventOutOfOfficeProperties outOfOfficeProperties;

  public static final String SERIALIZED_NAME_PRIVATE_COPY = "privateCopy";
  @SerializedName(SERIALIZED_NAME_PRIVATE_COPY)
  private Boolean privateCopy = false;

  public static final String SERIALIZED_NAME_RECURRENCE = "recurrence";
  @SerializedName(SERIALIZED_NAME_RECURRENCE)
  private List<String> recurrence = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECURRING_EVENT_ID = "recurringEventId";
  @SerializedName(SERIALIZED_NAME_RECURRING_EVENT_ID)
  private String recurringEventId;

  public static final String SERIALIZED_NAME_REMINDERS = "reminders";
  @SerializedName(SERIALIZED_NAME_REMINDERS)
  private EventReminders reminders;

  public static final String SERIALIZED_NAME_SEQUENCE = "sequence";
  @SerializedName(SERIALIZED_NAME_SEQUENCE)
  private Integer sequence;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private EventSource source;

  public static final String SERIALIZED_NAME_START = "start";
  @SerializedName(SERIALIZED_NAME_START)
  private EventDateTime start;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private String summary;

  public static final String SERIALIZED_NAME_TRANSPARENCY = "transparency";
  @SerializedName(SERIALIZED_NAME_TRANSPARENCY)
  private String transparency = "opaque";

  public static final String SERIALIZED_NAME_UPDATED = "updated";
  @SerializedName(SERIALIZED_NAME_UPDATED)
  private OffsetDateTime updated;

  public static final String SERIALIZED_NAME_VISIBILITY = "visibility";
  @SerializedName(SERIALIZED_NAME_VISIBILITY)
  private String visibility = "default";

  public static final String SERIALIZED_NAME_WORKING_LOCATION_PROPERTIES = "workingLocationProperties";
  @SerializedName(SERIALIZED_NAME_WORKING_LOCATION_PROPERTIES)
  private EventWorkingLocationProperties workingLocationProperties;

  public Event() {
  }

  public Event anyoneCanAddSelf(Boolean anyoneCanAddSelf) {
    this.anyoneCanAddSelf = anyoneCanAddSelf;
    return this;
  }

  /**
   * Whether anyone can invite themselves to the event (deprecated). Optional. The default is False.
   * @return anyoneCanAddSelf
   */
  @javax.annotation.Nullable
  public Boolean getAnyoneCanAddSelf() {
    return anyoneCanAddSelf;
  }

  public void setAnyoneCanAddSelf(Boolean anyoneCanAddSelf) {
    this.anyoneCanAddSelf = anyoneCanAddSelf;
  }


  public Event attachments(List<EventAttachment> attachments) {
    this.attachments = attachments;
    return this;
  }

  public Event addAttachmentsItem(EventAttachment attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * File attachments for the event. In order to modify attachments the supportsAttachments request parameter should be set to true. There can be at most 25 attachments per event,
   * @return attachments
   */
  @javax.annotation.Nullable
  public List<EventAttachment> getAttachments() {
    return attachments;
  }

  public void setAttachments(List<EventAttachment> attachments) {
    this.attachments = attachments;
  }


  public Event attendees(List<EventAttendee> attendees) {
    this.attendees = attendees;
    return this;
  }

  public Event addAttendeesItem(EventAttendee attendeesItem) {
    if (this.attendees == null) {
      this.attendees = new ArrayList<>();
    }
    this.attendees.add(attendeesItem);
    return this;
  }

  /**
   * The attendees of the event. See the Events with attendees guide for more information on scheduling events with other calendar users. Service accounts need to use domain-wide delegation of authority to populate the attendee list.
   * @return attendees
   */
  @javax.annotation.Nullable
  public List<EventAttendee> getAttendees() {
    return attendees;
  }

  public void setAttendees(List<EventAttendee> attendees) {
    this.attendees = attendees;
  }


  public Event attendeesOmitted(Boolean attendeesOmitted) {
    this.attendeesOmitted = attendeesOmitted;
    return this;
  }

  /**
   * Whether attendees may have been omitted from the event&#39;s representation. When retrieving an event, this may be due to a restriction specified by the maxAttendee query parameter. When updating an event, this can be used to only update the participant&#39;s response. Optional. The default is False.
   * @return attendeesOmitted
   */
  @javax.annotation.Nullable
  public Boolean getAttendeesOmitted() {
    return attendeesOmitted;
  }

  public void setAttendeesOmitted(Boolean attendeesOmitted) {
    this.attendeesOmitted = attendeesOmitted;
  }


  public Event colorId(String colorId) {
    this.colorId = colorId;
    return this;
  }

  /**
   * The color of the event. This is an ID referring to an entry in the event section of the colors definition (see the  colors endpoint). Optional.
   * @return colorId
   */
  @javax.annotation.Nullable
  public String getColorId() {
    return colorId;
  }

  public void setColorId(String colorId) {
    this.colorId = colorId;
  }


  public Event conferenceData(ConferenceData conferenceData) {
    this.conferenceData = conferenceData;
    return this;
  }

  /**
   * Get conferenceData
   * @return conferenceData
   */
  @javax.annotation.Nullable
  public ConferenceData getConferenceData() {
    return conferenceData;
  }

  public void setConferenceData(ConferenceData conferenceData) {
    this.conferenceData = conferenceData;
  }


  public Event created(OffsetDateTime created) {
    this.created = created;
    return this;
  }

  /**
   * Creation time of the event (as a RFC3339 timestamp). Read-only.
   * @return created
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreated() {
    return created;
  }

  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public Event creator(EventCreator creator) {
    this.creator = creator;
    return this;
  }

  /**
   * Get creator
   * @return creator
   */
  @javax.annotation.Nullable
  public EventCreator getCreator() {
    return creator;
  }

  public void setCreator(EventCreator creator) {
    this.creator = creator;
  }


  public Event description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of the event. Can contain HTML. Optional.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Event end(EventDateTime end) {
    this.end = end;
    return this;
  }

  /**
   * Get end
   * @return end
   */
  @javax.annotation.Nullable
  public EventDateTime getEnd() {
    return end;
  }

  public void setEnd(EventDateTime end) {
    this.end = end;
  }


  public Event endTimeUnspecified(Boolean endTimeUnspecified) {
    this.endTimeUnspecified = endTimeUnspecified;
    return this;
  }

  /**
   * Whether the end time is actually unspecified. An end time is still provided for compatibility reasons, even if this attribute is set to True. The default is False.
   * @return endTimeUnspecified
   */
  @javax.annotation.Nullable
  public Boolean getEndTimeUnspecified() {
    return endTimeUnspecified;
  }

  public void setEndTimeUnspecified(Boolean endTimeUnspecified) {
    this.endTimeUnspecified = endTimeUnspecified;
  }


  public Event etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * ETag of the resource.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public Event eventType(String eventType) {
    this.eventType = eventType;
    return this;
  }

  /**
   * Specific type of the event. This cannot be modified after the event is created. Possible values are:   - \&quot;default\&quot; - A regular event or not further specified.  - \&quot;outOfOffice\&quot; - An out-of-office event.  - \&quot;focusTime\&quot; - A focus-time event.  - \&quot;workingLocation\&quot; - A working location event.  Currently, only \&quot;default \&quot; and \&quot;workingLocation\&quot; events can be created using the API. Extended support for other event types will be made available in later releases.
   * @return eventType
   */
  @javax.annotation.Nullable
  public String getEventType() {
    return eventType;
  }

  public void setEventType(String eventType) {
    this.eventType = eventType;
  }


  public Event extendedProperties(EventExtendedProperties extendedProperties) {
    this.extendedProperties = extendedProperties;
    return this;
  }

  /**
   * Get extendedProperties
   * @return extendedProperties
   */
  @javax.annotation.Nullable
  public EventExtendedProperties getExtendedProperties() {
    return extendedProperties;
  }

  public void setExtendedProperties(EventExtendedProperties extendedProperties) {
    this.extendedProperties = extendedProperties;
  }


  public Event focusTimeProperties(EventFocusTimeProperties focusTimeProperties) {
    this.focusTimeProperties = focusTimeProperties;
    return this;
  }

  /**
   * Get focusTimeProperties
   * @return focusTimeProperties
   */
  @javax.annotation.Nullable
  public EventFocusTimeProperties getFocusTimeProperties() {
    return focusTimeProperties;
  }

  public void setFocusTimeProperties(EventFocusTimeProperties focusTimeProperties) {
    this.focusTimeProperties = focusTimeProperties;
  }


  public Event gadget(EventGadget gadget) {
    this.gadget = gadget;
    return this;
  }

  /**
   * Get gadget
   * @return gadget
   */
  @javax.annotation.Nullable
  public EventGadget getGadget() {
    return gadget;
  }

  public void setGadget(EventGadget gadget) {
    this.gadget = gadget;
  }


  public Event guestsCanInviteOthers(Boolean guestsCanInviteOthers) {
    this.guestsCanInviteOthers = guestsCanInviteOthers;
    return this;
  }

  /**
   * Whether attendees other than the organizer can invite others to the event. Optional. The default is True.
   * @return guestsCanInviteOthers
   */
  @javax.annotation.Nullable
  public Boolean getGuestsCanInviteOthers() {
    return guestsCanInviteOthers;
  }

  public void setGuestsCanInviteOthers(Boolean guestsCanInviteOthers) {
    this.guestsCanInviteOthers = guestsCanInviteOthers;
  }


  public Event guestsCanModify(Boolean guestsCanModify) {
    this.guestsCanModify = guestsCanModify;
    return this;
  }

  /**
   * Whether attendees other than the organizer can modify the event. Optional. The default is False.
   * @return guestsCanModify
   */
  @javax.annotation.Nullable
  public Boolean getGuestsCanModify() {
    return guestsCanModify;
  }

  public void setGuestsCanModify(Boolean guestsCanModify) {
    this.guestsCanModify = guestsCanModify;
  }


  public Event guestsCanSeeOtherGuests(Boolean guestsCanSeeOtherGuests) {
    this.guestsCanSeeOtherGuests = guestsCanSeeOtherGuests;
    return this;
  }

  /**
   * Whether attendees other than the organizer can see who the event&#39;s attendees are. Optional. The default is True.
   * @return guestsCanSeeOtherGuests
   */
  @javax.annotation.Nullable
  public Boolean getGuestsCanSeeOtherGuests() {
    return guestsCanSeeOtherGuests;
  }

  public void setGuestsCanSeeOtherGuests(Boolean guestsCanSeeOtherGuests) {
    this.guestsCanSeeOtherGuests = guestsCanSeeOtherGuests;
  }


  public Event hangoutLink(String hangoutLink) {
    this.hangoutLink = hangoutLink;
    return this;
  }

  /**
   * An absolute link to the Google Hangout associated with this event. Read-only.
   * @return hangoutLink
   */
  @javax.annotation.Nullable
  public String getHangoutLink() {
    return hangoutLink;
  }

  public void setHangoutLink(String hangoutLink) {
    this.hangoutLink = hangoutLink;
  }


  public Event htmlLink(String htmlLink) {
    this.htmlLink = htmlLink;
    return this;
  }

  /**
   * An absolute link to this event in the Google Calendar Web UI. Read-only.
   * @return htmlLink
   */
  @javax.annotation.Nullable
  public String getHtmlLink() {
    return htmlLink;
  }

  public void setHtmlLink(String htmlLink) {
    this.htmlLink = htmlLink;
  }


  public Event iCalUID(String iCalUID) {
    this.iCalUID = iCalUID;
    return this;
  }

  /**
   * Event unique identifier as defined in RFC5545. It is used to uniquely identify events accross calendaring systems and must be supplied when importing events via the import method. Note that the iCalUID and the id are not identical and only one of them should be supplied at event creation time. One difference in their semantics is that in recurring events, all occurrences of one event have different ids while they all share the same iCalUIDs. To retrieve an event using its iCalUID, call the events.list method using the iCalUID parameter. To retrieve an event using its id, call the events.get method.
   * @return iCalUID
   */
  @javax.annotation.Nullable
  public String getiCalUID() {
    return iCalUID;
  }

  public void setiCalUID(String iCalUID) {
    this.iCalUID = iCalUID;
  }


  public Event id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Opaque identifier of the event. When creating new single or recurring events, you can specify their IDs. Provided IDs must follow these rules:   - characters allowed in the ID are those used in base32hex encoding, i.e. lowercase letters a-v and digits 0-9, see section 3.1.2 in RFC2938  - the length of the ID must be between 5 and 1024 characters  - the ID must be unique per calendar  Due to the globally distributed nature of the system, we cannot guarantee that ID collisions will be detected at event creation time. To minimize the risk of collisions we recommend using an established UUID algorithm such as one described in RFC4122. If you do not specify an ID, it will be automatically generated by the server. Note that the icalUID and the id are not identical and only one of them should be supplied at event creation time. One difference in their semantics is that in recurring events, all occurrences of one event have different ids while they all share the same icalUIDs.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Event kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Type of the resource (\&quot;calendar#event\&quot;).
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Event location(String location) {
    this.location = location;
    return this;
  }

  /**
   * Geographic location of the event as free-form text. Optional.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public Event locked(Boolean locked) {
    this.locked = locked;
    return this;
  }

  /**
   * Whether this is a locked event copy where no changes can be made to the main event fields \&quot;summary\&quot;, \&quot;description\&quot;, \&quot;location\&quot;, \&quot;start\&quot;, \&quot;end\&quot; or \&quot;recurrence\&quot;. The default is False. Read-Only.
   * @return locked
   */
  @javax.annotation.Nullable
  public Boolean getLocked() {
    return locked;
  }

  public void setLocked(Boolean locked) {
    this.locked = locked;
  }


  public Event organizer(EventOrganizer organizer) {
    this.organizer = organizer;
    return this;
  }

  /**
   * Get organizer
   * @return organizer
   */
  @javax.annotation.Nullable
  public EventOrganizer getOrganizer() {
    return organizer;
  }

  public void setOrganizer(EventOrganizer organizer) {
    this.organizer = organizer;
  }


  public Event originalStartTime(EventDateTime originalStartTime) {
    this.originalStartTime = originalStartTime;
    return this;
  }

  /**
   * Get originalStartTime
   * @return originalStartTime
   */
  @javax.annotation.Nullable
  public EventDateTime getOriginalStartTime() {
    return originalStartTime;
  }

  public void setOriginalStartTime(EventDateTime originalStartTime) {
    this.originalStartTime = originalStartTime;
  }


  public Event outOfOfficeProperties(EventOutOfOfficeProperties outOfOfficeProperties) {
    this.outOfOfficeProperties = outOfOfficeProperties;
    return this;
  }

  /**
   * Get outOfOfficeProperties
   * @return outOfOfficeProperties
   */
  @javax.annotation.Nullable
  public EventOutOfOfficeProperties getOutOfOfficeProperties() {
    return outOfOfficeProperties;
  }

  public void setOutOfOfficeProperties(EventOutOfOfficeProperties outOfOfficeProperties) {
    this.outOfOfficeProperties = outOfOfficeProperties;
  }


  public Event privateCopy(Boolean privateCopy) {
    this.privateCopy = privateCopy;
    return this;
  }

  /**
   * If set to True, Event propagation is disabled. Note that it is not the same thing as Private event properties. Optional. Immutable. The default is False.
   * @return privateCopy
   */
  @javax.annotation.Nullable
  public Boolean getPrivateCopy() {
    return privateCopy;
  }

  public void setPrivateCopy(Boolean privateCopy) {
    this.privateCopy = privateCopy;
  }


  public Event recurrence(List<String> recurrence) {
    this.recurrence = recurrence;
    return this;
  }

  public Event addRecurrenceItem(String recurrenceItem) {
    if (this.recurrence == null) {
      this.recurrence = new ArrayList<>();
    }
    this.recurrence.add(recurrenceItem);
    return this;
  }

  /**
   * List of RRULE, EXRULE, RDATE and EXDATE lines for a recurring event, as specified in RFC5545. Note that DTSTART and DTEND lines are not allowed in this field; event start and end times are specified in the start and end fields. This field is omitted for single events or instances of recurring events.
   * @return recurrence
   */
  @javax.annotation.Nullable
  public List<String> getRecurrence() {
    return recurrence;
  }

  public void setRecurrence(List<String> recurrence) {
    this.recurrence = recurrence;
  }


  public Event recurringEventId(String recurringEventId) {
    this.recurringEventId = recurringEventId;
    return this;
  }

  /**
   * For an instance of a recurring event, this is the id of the recurring event to which this instance belongs. Immutable.
   * @return recurringEventId
   */
  @javax.annotation.Nullable
  public String getRecurringEventId() {
    return recurringEventId;
  }

  public void setRecurringEventId(String recurringEventId) {
    this.recurringEventId = recurringEventId;
  }


  public Event reminders(EventReminders reminders) {
    this.reminders = reminders;
    return this;
  }

  /**
   * Get reminders
   * @return reminders
   */
  @javax.annotation.Nullable
  public EventReminders getReminders() {
    return reminders;
  }

  public void setReminders(EventReminders reminders) {
    this.reminders = reminders;
  }


  public Event sequence(Integer sequence) {
    this.sequence = sequence;
    return this;
  }

  /**
   * Sequence number as per iCalendar.
   * @return sequence
   */
  @javax.annotation.Nullable
  public Integer getSequence() {
    return sequence;
  }

  public void setSequence(Integer sequence) {
    this.sequence = sequence;
  }


  public Event source(EventSource source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nullable
  public EventSource getSource() {
    return source;
  }

  public void setSource(EventSource source) {
    this.source = source;
  }


  public Event start(EventDateTime start) {
    this.start = start;
    return this;
  }

  /**
   * Get start
   * @return start
   */
  @javax.annotation.Nullable
  public EventDateTime getStart() {
    return start;
  }

  public void setStart(EventDateTime start) {
    this.start = start;
  }


  public Event status(String status) {
    this.status = status;
    return this;
  }

  /**
   * Status of the event. Optional. Possible values are:   - \&quot;confirmed\&quot; - The event is confirmed. This is the default status.  - \&quot;tentative\&quot; - The event is tentatively confirmed.  - \&quot;cancelled\&quot; - The event is cancelled (deleted). The list method returns cancelled events only on incremental sync (when syncToken or updatedMin are specified) or if the showDeleted flag is set to true. The get method always returns them. A cancelled status represents two different states depending on the event type:   - Cancelled exceptions of an uncancelled recurring event indicate that this instance should no longer be presented to the user. Clients should store these events for the lifetime of the parent recurring event. Cancelled exceptions are only guaranteed to have values for the id, recurringEventId and originalStartTime fields populated. The other fields might be empty.   - All other cancelled events represent deleted events. Clients should remove their locally synced copies. Such cancelled events will eventually disappear, so do not rely on them being available indefinitely. Deleted events are only guaranteed to have the id field populated.   On the organizer&#39;s calendar, cancelled events continue to expose event details (summary, location, etc.) so that they can be restored (undeleted). Similarly, the events to which the user was invited and that they manually removed continue to provide details. However, incremental sync requests with showDeleted set to false will not return these details. If an event changes its organizer (for example via the move operation) and the original organizer is not on the attendee list, it will leave behind a cancelled event where only the id field is guaranteed to be populated.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public Event summary(String summary) {
    this.summary = summary;
    return this;
  }

  /**
   * Title of the event.
   * @return summary
   */
  @javax.annotation.Nullable
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }


  public Event transparency(String transparency) {
    this.transparency = transparency;
    return this;
  }

  /**
   * Whether the event blocks time on the calendar. Optional. Possible values are:   - \&quot;opaque\&quot; - Default value. The event does block time on the calendar. This is equivalent to setting Show me as to Busy in the Calendar UI.  - \&quot;transparent\&quot; - The event does not block time on the calendar. This is equivalent to setting Show me as to Available in the Calendar UI.
   * @return transparency
   */
  @javax.annotation.Nullable
  public String getTransparency() {
    return transparency;
  }

  public void setTransparency(String transparency) {
    this.transparency = transparency;
  }


  public Event updated(OffsetDateTime updated) {
    this.updated = updated;
    return this;
  }

  /**
   * Last modification time of the event (as a RFC3339 timestamp). Read-only.
   * @return updated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdated() {
    return updated;
  }

  public void setUpdated(OffsetDateTime updated) {
    this.updated = updated;
  }


  public Event visibility(String visibility) {
    this.visibility = visibility;
    return this;
  }

  /**
   * Visibility of the event. Optional. Possible values are:   - \&quot;default\&quot; - Uses the default visibility for events on the calendar. This is the default value.  - \&quot;public\&quot; - The event is public and event details are visible to all readers of the calendar.  - \&quot;private\&quot; - The event is private and only event attendees may view event details.  - \&quot;confidential\&quot; - The event is private. This value is provided for compatibility reasons.
   * @return visibility
   */
  @javax.annotation.Nullable
  public String getVisibility() {
    return visibility;
  }

  public void setVisibility(String visibility) {
    this.visibility = visibility;
  }


  public Event workingLocationProperties(EventWorkingLocationProperties workingLocationProperties) {
    this.workingLocationProperties = workingLocationProperties;
    return this;
  }

  /**
   * Get workingLocationProperties
   * @return workingLocationProperties
   */
  @javax.annotation.Nullable
  public EventWorkingLocationProperties getWorkingLocationProperties() {
    return workingLocationProperties;
  }

  public void setWorkingLocationProperties(EventWorkingLocationProperties workingLocationProperties) {
    this.workingLocationProperties = workingLocationProperties;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Event event = (Event) o;
    return Objects.equals(this.anyoneCanAddSelf, event.anyoneCanAddSelf) &&
        Objects.equals(this.attachments, event.attachments) &&
        Objects.equals(this.attendees, event.attendees) &&
        Objects.equals(this.attendeesOmitted, event.attendeesOmitted) &&
        Objects.equals(this.colorId, event.colorId) &&
        Objects.equals(this.conferenceData, event.conferenceData) &&
        Objects.equals(this.created, event.created) &&
        Objects.equals(this.creator, event.creator) &&
        Objects.equals(this.description, event.description) &&
        Objects.equals(this.end, event.end) &&
        Objects.equals(this.endTimeUnspecified, event.endTimeUnspecified) &&
        Objects.equals(this.etag, event.etag) &&
        Objects.equals(this.eventType, event.eventType) &&
        Objects.equals(this.extendedProperties, event.extendedProperties) &&
        Objects.equals(this.focusTimeProperties, event.focusTimeProperties) &&
        Objects.equals(this.gadget, event.gadget) &&
        Objects.equals(this.guestsCanInviteOthers, event.guestsCanInviteOthers) &&
        Objects.equals(this.guestsCanModify, event.guestsCanModify) &&
        Objects.equals(this.guestsCanSeeOtherGuests, event.guestsCanSeeOtherGuests) &&
        Objects.equals(this.hangoutLink, event.hangoutLink) &&
        Objects.equals(this.htmlLink, event.htmlLink) &&
        Objects.equals(this.iCalUID, event.iCalUID) &&
        Objects.equals(this.id, event.id) &&
        Objects.equals(this.kind, event.kind) &&
        Objects.equals(this.location, event.location) &&
        Objects.equals(this.locked, event.locked) &&
        Objects.equals(this.organizer, event.organizer) &&
        Objects.equals(this.originalStartTime, event.originalStartTime) &&
        Objects.equals(this.outOfOfficeProperties, event.outOfOfficeProperties) &&
        Objects.equals(this.privateCopy, event.privateCopy) &&
        Objects.equals(this.recurrence, event.recurrence) &&
        Objects.equals(this.recurringEventId, event.recurringEventId) &&
        Objects.equals(this.reminders, event.reminders) &&
        Objects.equals(this.sequence, event.sequence) &&
        Objects.equals(this.source, event.source) &&
        Objects.equals(this.start, event.start) &&
        Objects.equals(this.status, event.status) &&
        Objects.equals(this.summary, event.summary) &&
        Objects.equals(this.transparency, event.transparency) &&
        Objects.equals(this.updated, event.updated) &&
        Objects.equals(this.visibility, event.visibility) &&
        Objects.equals(this.workingLocationProperties, event.workingLocationProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(anyoneCanAddSelf, attachments, attendees, attendeesOmitted, colorId, conferenceData, created, creator, description, end, endTimeUnspecified, etag, eventType, extendedProperties, focusTimeProperties, gadget, guestsCanInviteOthers, guestsCanModify, guestsCanSeeOtherGuests, hangoutLink, htmlLink, iCalUID, id, kind, location, locked, organizer, originalStartTime, outOfOfficeProperties, privateCopy, recurrence, recurringEventId, reminders, sequence, source, start, status, summary, transparency, updated, visibility, workingLocationProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Event {\n");
    sb.append("    anyoneCanAddSelf: ").append(toIndentedString(anyoneCanAddSelf)).append("\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    attendees: ").append(toIndentedString(attendees)).append("\n");
    sb.append("    attendeesOmitted: ").append(toIndentedString(attendeesOmitted)).append("\n");
    sb.append("    colorId: ").append(toIndentedString(colorId)).append("\n");
    sb.append("    conferenceData: ").append(toIndentedString(conferenceData)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    creator: ").append(toIndentedString(creator)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    endTimeUnspecified: ").append(toIndentedString(endTimeUnspecified)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    eventType: ").append(toIndentedString(eventType)).append("\n");
    sb.append("    extendedProperties: ").append(toIndentedString(extendedProperties)).append("\n");
    sb.append("    focusTimeProperties: ").append(toIndentedString(focusTimeProperties)).append("\n");
    sb.append("    gadget: ").append(toIndentedString(gadget)).append("\n");
    sb.append("    guestsCanInviteOthers: ").append(toIndentedString(guestsCanInviteOthers)).append("\n");
    sb.append("    guestsCanModify: ").append(toIndentedString(guestsCanModify)).append("\n");
    sb.append("    guestsCanSeeOtherGuests: ").append(toIndentedString(guestsCanSeeOtherGuests)).append("\n");
    sb.append("    hangoutLink: ").append(toIndentedString(hangoutLink)).append("\n");
    sb.append("    htmlLink: ").append(toIndentedString(htmlLink)).append("\n");
    sb.append("    iCalUID: ").append(toIndentedString(iCalUID)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    locked: ").append(toIndentedString(locked)).append("\n");
    sb.append("    organizer: ").append(toIndentedString(organizer)).append("\n");
    sb.append("    originalStartTime: ").append(toIndentedString(originalStartTime)).append("\n");
    sb.append("    outOfOfficeProperties: ").append(toIndentedString(outOfOfficeProperties)).append("\n");
    sb.append("    privateCopy: ").append(toIndentedString(privateCopy)).append("\n");
    sb.append("    recurrence: ").append(toIndentedString(recurrence)).append("\n");
    sb.append("    recurringEventId: ").append(toIndentedString(recurringEventId)).append("\n");
    sb.append("    reminders: ").append(toIndentedString(reminders)).append("\n");
    sb.append("    sequence: ").append(toIndentedString(sequence)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    transparency: ").append(toIndentedString(transparency)).append("\n");
    sb.append("    updated: ").append(toIndentedString(updated)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("    workingLocationProperties: ").append(toIndentedString(workingLocationProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("anyoneCanAddSelf");
    openapiFields.add("attachments");
    openapiFields.add("attendees");
    openapiFields.add("attendeesOmitted");
    openapiFields.add("colorId");
    openapiFields.add("conferenceData");
    openapiFields.add("created");
    openapiFields.add("creator");
    openapiFields.add("description");
    openapiFields.add("end");
    openapiFields.add("endTimeUnspecified");
    openapiFields.add("etag");
    openapiFields.add("eventType");
    openapiFields.add("extendedProperties");
    openapiFields.add("focusTimeProperties");
    openapiFields.add("gadget");
    openapiFields.add("guestsCanInviteOthers");
    openapiFields.add("guestsCanModify");
    openapiFields.add("guestsCanSeeOtherGuests");
    openapiFields.add("hangoutLink");
    openapiFields.add("htmlLink");
    openapiFields.add("iCalUID");
    openapiFields.add("id");
    openapiFields.add("kind");
    openapiFields.add("location");
    openapiFields.add("locked");
    openapiFields.add("organizer");
    openapiFields.add("originalStartTime");
    openapiFields.add("outOfOfficeProperties");
    openapiFields.add("privateCopy");
    openapiFields.add("recurrence");
    openapiFields.add("recurringEventId");
    openapiFields.add("reminders");
    openapiFields.add("sequence");
    openapiFields.add("source");
    openapiFields.add("start");
    openapiFields.add("status");
    openapiFields.add("summary");
    openapiFields.add("transparency");
    openapiFields.add("updated");
    openapiFields.add("visibility");
    openapiFields.add("workingLocationProperties");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Event
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Event.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Event is not found in the empty JSON string", Event.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Event.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Event` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        JsonArray jsonArrayattachments = jsonObj.getAsJsonArray("attachments");
        if (jsonArrayattachments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
          }

          // validate the optional field `attachments` (array)
          for (int i = 0; i < jsonArrayattachments.size(); i++) {
            EventAttachment.validateJsonElement(jsonArrayattachments.get(i));
          };
        }
      }
      if (jsonObj.get("attendees") != null && !jsonObj.get("attendees").isJsonNull()) {
        JsonArray jsonArrayattendees = jsonObj.getAsJsonArray("attendees");
        if (jsonArrayattendees != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attendees").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attendees` to be an array in the JSON string but got `%s`", jsonObj.get("attendees").toString()));
          }

          // validate the optional field `attendees` (array)
          for (int i = 0; i < jsonArrayattendees.size(); i++) {
            EventAttendee.validateJsonElement(jsonArrayattendees.get(i));
          };
        }
      }
      if ((jsonObj.get("colorId") != null && !jsonObj.get("colorId").isJsonNull()) && !jsonObj.get("colorId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `colorId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("colorId").toString()));
      }
      // validate the optional field `conferenceData`
      if (jsonObj.get("conferenceData") != null && !jsonObj.get("conferenceData").isJsonNull()) {
        ConferenceData.validateJsonElement(jsonObj.get("conferenceData"));
      }
      // validate the optional field `creator`
      if (jsonObj.get("creator") != null && !jsonObj.get("creator").isJsonNull()) {
        EventCreator.validateJsonElement(jsonObj.get("creator"));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `end`
      if (jsonObj.get("end") != null && !jsonObj.get("end").isJsonNull()) {
        EventDateTime.validateJsonElement(jsonObj.get("end"));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("eventType") != null && !jsonObj.get("eventType").isJsonNull()) && !jsonObj.get("eventType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eventType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eventType").toString()));
      }
      // validate the optional field `extendedProperties`
      if (jsonObj.get("extendedProperties") != null && !jsonObj.get("extendedProperties").isJsonNull()) {
        EventExtendedProperties.validateJsonElement(jsonObj.get("extendedProperties"));
      }
      // validate the optional field `focusTimeProperties`
      if (jsonObj.get("focusTimeProperties") != null && !jsonObj.get("focusTimeProperties").isJsonNull()) {
        EventFocusTimeProperties.validateJsonElement(jsonObj.get("focusTimeProperties"));
      }
      // validate the optional field `gadget`
      if (jsonObj.get("gadget") != null && !jsonObj.get("gadget").isJsonNull()) {
        EventGadget.validateJsonElement(jsonObj.get("gadget"));
      }
      if ((jsonObj.get("hangoutLink") != null && !jsonObj.get("hangoutLink").isJsonNull()) && !jsonObj.get("hangoutLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hangoutLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hangoutLink").toString()));
      }
      if ((jsonObj.get("htmlLink") != null && !jsonObj.get("htmlLink").isJsonNull()) && !jsonObj.get("htmlLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `htmlLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("htmlLink").toString()));
      }
      if ((jsonObj.get("iCalUID") != null && !jsonObj.get("iCalUID").isJsonNull()) && !jsonObj.get("iCalUID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iCalUID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iCalUID").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      // validate the optional field `organizer`
      if (jsonObj.get("organizer") != null && !jsonObj.get("organizer").isJsonNull()) {
        EventOrganizer.validateJsonElement(jsonObj.get("organizer"));
      }
      // validate the optional field `originalStartTime`
      if (jsonObj.get("originalStartTime") != null && !jsonObj.get("originalStartTime").isJsonNull()) {
        EventDateTime.validateJsonElement(jsonObj.get("originalStartTime"));
      }
      // validate the optional field `outOfOfficeProperties`
      if (jsonObj.get("outOfOfficeProperties") != null && !jsonObj.get("outOfOfficeProperties").isJsonNull()) {
        EventOutOfOfficeProperties.validateJsonElement(jsonObj.get("outOfOfficeProperties"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("recurrence") != null && !jsonObj.get("recurrence").isJsonNull() && !jsonObj.get("recurrence").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `recurrence` to be an array in the JSON string but got `%s`", jsonObj.get("recurrence").toString()));
      }
      if ((jsonObj.get("recurringEventId") != null && !jsonObj.get("recurringEventId").isJsonNull()) && !jsonObj.get("recurringEventId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recurringEventId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recurringEventId").toString()));
      }
      // validate the optional field `reminders`
      if (jsonObj.get("reminders") != null && !jsonObj.get("reminders").isJsonNull()) {
        EventReminders.validateJsonElement(jsonObj.get("reminders"));
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        EventSource.validateJsonElement(jsonObj.get("source"));
      }
      // validate the optional field `start`
      if (jsonObj.get("start") != null && !jsonObj.get("start").isJsonNull()) {
        EventDateTime.validateJsonElement(jsonObj.get("start"));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if ((jsonObj.get("summary") != null && !jsonObj.get("summary").isJsonNull()) && !jsonObj.get("summary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summary").toString()));
      }
      if ((jsonObj.get("transparency") != null && !jsonObj.get("transparency").isJsonNull()) && !jsonObj.get("transparency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transparency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transparency").toString()));
      }
      if ((jsonObj.get("visibility") != null && !jsonObj.get("visibility").isJsonNull()) && !jsonObj.get("visibility").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `visibility` to be a primitive type in the JSON string but got `%s`", jsonObj.get("visibility").toString()));
      }
      // validate the optional field `workingLocationProperties`
      if (jsonObj.get("workingLocationProperties") != null && !jsonObj.get("workingLocationProperties").isJsonNull()) {
        EventWorkingLocationProperties.validateJsonElement(jsonObj.get("workingLocationProperties"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Event.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Event' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Event> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Event.class));

       return (TypeAdapter<T>) new TypeAdapter<Event>() {
           @Override
           public void write(JsonWriter out, Event value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Event read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Event given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Event
   * @throws IOException if the JSON string is invalid with respect to Event
   */
  public static Event fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Event.class);
  }

  /**
   * Convert an instance of Event to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

