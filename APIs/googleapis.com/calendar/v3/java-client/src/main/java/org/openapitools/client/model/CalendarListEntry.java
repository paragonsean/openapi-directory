/*
 * Calendar API
 * Manipulates events and other calendar data.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CalendarListEntryNotificationSettings;
import org.openapitools.client.model.ConferenceProperties;
import org.openapitools.client.model.EventReminder;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CalendarListEntry
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:09.684550-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CalendarListEntry {
  public static final String SERIALIZED_NAME_ACCESS_ROLE = "accessRole";
  @SerializedName(SERIALIZED_NAME_ACCESS_ROLE)
  private String accessRole;

  public static final String SERIALIZED_NAME_BACKGROUND_COLOR = "backgroundColor";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_COLOR)
  private String backgroundColor;

  public static final String SERIALIZED_NAME_COLOR_ID = "colorId";
  @SerializedName(SERIALIZED_NAME_COLOR_ID)
  private String colorId;

  public static final String SERIALIZED_NAME_CONFERENCE_PROPERTIES = "conferenceProperties";
  @SerializedName(SERIALIZED_NAME_CONFERENCE_PROPERTIES)
  private ConferenceProperties conferenceProperties;

  public static final String SERIALIZED_NAME_DEFAULT_REMINDERS = "defaultReminders";
  @SerializedName(SERIALIZED_NAME_DEFAULT_REMINDERS)
  private List<EventReminder> defaultReminders = new ArrayList<>();

  public static final String SERIALIZED_NAME_DELETED = "deleted";
  @SerializedName(SERIALIZED_NAME_DELETED)
  private Boolean deleted = false;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_FOREGROUND_COLOR = "foregroundColor";
  @SerializedName(SERIALIZED_NAME_FOREGROUND_COLOR)
  private String foregroundColor;

  public static final String SERIALIZED_NAME_HIDDEN = "hidden";
  @SerializedName(SERIALIZED_NAME_HIDDEN)
  private Boolean hidden = false;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "calendar#calendarListEntry";

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_NOTIFICATION_SETTINGS = "notificationSettings";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_SETTINGS)
  private CalendarListEntryNotificationSettings notificationSettings;

  public static final String SERIALIZED_NAME_PRIMARY = "primary";
  @SerializedName(SERIALIZED_NAME_PRIMARY)
  private Boolean primary = false;

  public static final String SERIALIZED_NAME_SELECTED = "selected";
  @SerializedName(SERIALIZED_NAME_SELECTED)
  private Boolean selected = false;

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private String summary;

  public static final String SERIALIZED_NAME_SUMMARY_OVERRIDE = "summaryOverride";
  @SerializedName(SERIALIZED_NAME_SUMMARY_OVERRIDE)
  private String summaryOverride;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public CalendarListEntry() {
  }

  public CalendarListEntry accessRole(String accessRole) {
    this.accessRole = accessRole;
    return this;
  }

  /**
   * The effective access role that the authenticated user has on the calendar. Read-only. Possible values are:   - \&quot;freeBusyReader\&quot; - Provides read access to free/busy information.  - \&quot;reader\&quot; - Provides read access to the calendar. Private events will appear to users with reader access, but event details will be hidden.  - \&quot;writer\&quot; - Provides read and write access to the calendar. Private events will appear to users with writer access, and event details will be visible.  - \&quot;owner\&quot; - Provides ownership of the calendar. This role has all of the permissions of the writer role with the additional ability to see and manipulate ACLs.
   * @return accessRole
   */
  @javax.annotation.Nullable
  public String getAccessRole() {
    return accessRole;
  }

  public void setAccessRole(String accessRole) {
    this.accessRole = accessRole;
  }


  public CalendarListEntry backgroundColor(String backgroundColor) {
    this.backgroundColor = backgroundColor;
    return this;
  }

  /**
   * The main color of the calendar in the hexadecimal format \&quot;#0088aa\&quot;. This property supersedes the index-based colorId property. To set or change this property, you need to specify colorRgbFormat&#x3D;true in the parameters of the insert, update and patch methods. Optional.
   * @return backgroundColor
   */
  @javax.annotation.Nullable
  public String getBackgroundColor() {
    return backgroundColor;
  }

  public void setBackgroundColor(String backgroundColor) {
    this.backgroundColor = backgroundColor;
  }


  public CalendarListEntry colorId(String colorId) {
    this.colorId = colorId;
    return this;
  }

  /**
   * The color of the calendar. This is an ID referring to an entry in the calendar section of the colors definition (see the colors endpoint). This property is superseded by the backgroundColor and foregroundColor properties and can be ignored when using these properties. Optional.
   * @return colorId
   */
  @javax.annotation.Nullable
  public String getColorId() {
    return colorId;
  }

  public void setColorId(String colorId) {
    this.colorId = colorId;
  }


  public CalendarListEntry conferenceProperties(ConferenceProperties conferenceProperties) {
    this.conferenceProperties = conferenceProperties;
    return this;
  }

  /**
   * Get conferenceProperties
   * @return conferenceProperties
   */
  @javax.annotation.Nullable
  public ConferenceProperties getConferenceProperties() {
    return conferenceProperties;
  }

  public void setConferenceProperties(ConferenceProperties conferenceProperties) {
    this.conferenceProperties = conferenceProperties;
  }


  public CalendarListEntry defaultReminders(List<EventReminder> defaultReminders) {
    this.defaultReminders = defaultReminders;
    return this;
  }

  public CalendarListEntry addDefaultRemindersItem(EventReminder defaultRemindersItem) {
    if (this.defaultReminders == null) {
      this.defaultReminders = new ArrayList<>();
    }
    this.defaultReminders.add(defaultRemindersItem);
    return this;
  }

  /**
   * The default reminders that the authenticated user has for this calendar.
   * @return defaultReminders
   */
  @javax.annotation.Nullable
  public List<EventReminder> getDefaultReminders() {
    return defaultReminders;
  }

  public void setDefaultReminders(List<EventReminder> defaultReminders) {
    this.defaultReminders = defaultReminders;
  }


  public CalendarListEntry deleted(Boolean deleted) {
    this.deleted = deleted;
    return this;
  }

  /**
   * Whether this calendar list entry has been deleted from the calendar list. Read-only. Optional. The default is False.
   * @return deleted
   */
  @javax.annotation.Nullable
  public Boolean getDeleted() {
    return deleted;
  }

  public void setDeleted(Boolean deleted) {
    this.deleted = deleted;
  }


  public CalendarListEntry description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of the calendar. Optional. Read-only.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public CalendarListEntry etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * ETag of the resource.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public CalendarListEntry foregroundColor(String foregroundColor) {
    this.foregroundColor = foregroundColor;
    return this;
  }

  /**
   * The foreground color of the calendar in the hexadecimal format \&quot;#ffffff\&quot;. This property supersedes the index-based colorId property. To set or change this property, you need to specify colorRgbFormat&#x3D;true in the parameters of the insert, update and patch methods. Optional.
   * @return foregroundColor
   */
  @javax.annotation.Nullable
  public String getForegroundColor() {
    return foregroundColor;
  }

  public void setForegroundColor(String foregroundColor) {
    this.foregroundColor = foregroundColor;
  }


  public CalendarListEntry hidden(Boolean hidden) {
    this.hidden = hidden;
    return this;
  }

  /**
   * Whether the calendar has been hidden from the list. Optional. The attribute is only returned when the calendar is hidden, in which case the value is true.
   * @return hidden
   */
  @javax.annotation.Nullable
  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }


  public CalendarListEntry id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Identifier of the calendar.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public CalendarListEntry kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Type of the resource (\&quot;calendar#calendarListEntry\&quot;).
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public CalendarListEntry location(String location) {
    this.location = location;
    return this;
  }

  /**
   * Geographic location of the calendar as free-form text. Optional. Read-only.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public CalendarListEntry notificationSettings(CalendarListEntryNotificationSettings notificationSettings) {
    this.notificationSettings = notificationSettings;
    return this;
  }

  /**
   * Get notificationSettings
   * @return notificationSettings
   */
  @javax.annotation.Nullable
  public CalendarListEntryNotificationSettings getNotificationSettings() {
    return notificationSettings;
  }

  public void setNotificationSettings(CalendarListEntryNotificationSettings notificationSettings) {
    this.notificationSettings = notificationSettings;
  }


  public CalendarListEntry primary(Boolean primary) {
    this.primary = primary;
    return this;
  }

  /**
   * Whether the calendar is the primary calendar of the authenticated user. Read-only. Optional. The default is False.
   * @return primary
   */
  @javax.annotation.Nullable
  public Boolean getPrimary() {
    return primary;
  }

  public void setPrimary(Boolean primary) {
    this.primary = primary;
  }


  public CalendarListEntry selected(Boolean selected) {
    this.selected = selected;
    return this;
  }

  /**
   * Whether the calendar content shows up in the calendar UI. Optional. The default is False.
   * @return selected
   */
  @javax.annotation.Nullable
  public Boolean getSelected() {
    return selected;
  }

  public void setSelected(Boolean selected) {
    this.selected = selected;
  }


  public CalendarListEntry summary(String summary) {
    this.summary = summary;
    return this;
  }

  /**
   * Title of the calendar. Read-only.
   * @return summary
   */
  @javax.annotation.Nullable
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }


  public CalendarListEntry summaryOverride(String summaryOverride) {
    this.summaryOverride = summaryOverride;
    return this;
  }

  /**
   * The summary that the authenticated user has set for this calendar. Optional.
   * @return summaryOverride
   */
  @javax.annotation.Nullable
  public String getSummaryOverride() {
    return summaryOverride;
  }

  public void setSummaryOverride(String summaryOverride) {
    this.summaryOverride = summaryOverride;
  }


  public CalendarListEntry timeZone(String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * The time zone of the calendar. Optional. Read-only.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CalendarListEntry calendarListEntry = (CalendarListEntry) o;
    return Objects.equals(this.accessRole, calendarListEntry.accessRole) &&
        Objects.equals(this.backgroundColor, calendarListEntry.backgroundColor) &&
        Objects.equals(this.colorId, calendarListEntry.colorId) &&
        Objects.equals(this.conferenceProperties, calendarListEntry.conferenceProperties) &&
        Objects.equals(this.defaultReminders, calendarListEntry.defaultReminders) &&
        Objects.equals(this.deleted, calendarListEntry.deleted) &&
        Objects.equals(this.description, calendarListEntry.description) &&
        Objects.equals(this.etag, calendarListEntry.etag) &&
        Objects.equals(this.foregroundColor, calendarListEntry.foregroundColor) &&
        Objects.equals(this.hidden, calendarListEntry.hidden) &&
        Objects.equals(this.id, calendarListEntry.id) &&
        Objects.equals(this.kind, calendarListEntry.kind) &&
        Objects.equals(this.location, calendarListEntry.location) &&
        Objects.equals(this.notificationSettings, calendarListEntry.notificationSettings) &&
        Objects.equals(this.primary, calendarListEntry.primary) &&
        Objects.equals(this.selected, calendarListEntry.selected) &&
        Objects.equals(this.summary, calendarListEntry.summary) &&
        Objects.equals(this.summaryOverride, calendarListEntry.summaryOverride) &&
        Objects.equals(this.timeZone, calendarListEntry.timeZone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessRole, backgroundColor, colorId, conferenceProperties, defaultReminders, deleted, description, etag, foregroundColor, hidden, id, kind, location, notificationSettings, primary, selected, summary, summaryOverride, timeZone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CalendarListEntry {\n");
    sb.append("    accessRole: ").append(toIndentedString(accessRole)).append("\n");
    sb.append("    backgroundColor: ").append(toIndentedString(backgroundColor)).append("\n");
    sb.append("    colorId: ").append(toIndentedString(colorId)).append("\n");
    sb.append("    conferenceProperties: ").append(toIndentedString(conferenceProperties)).append("\n");
    sb.append("    defaultReminders: ").append(toIndentedString(defaultReminders)).append("\n");
    sb.append("    deleted: ").append(toIndentedString(deleted)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    foregroundColor: ").append(toIndentedString(foregroundColor)).append("\n");
    sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    notificationSettings: ").append(toIndentedString(notificationSettings)).append("\n");
    sb.append("    primary: ").append(toIndentedString(primary)).append("\n");
    sb.append("    selected: ").append(toIndentedString(selected)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    summaryOverride: ").append(toIndentedString(summaryOverride)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessRole");
    openapiFields.add("backgroundColor");
    openapiFields.add("colorId");
    openapiFields.add("conferenceProperties");
    openapiFields.add("defaultReminders");
    openapiFields.add("deleted");
    openapiFields.add("description");
    openapiFields.add("etag");
    openapiFields.add("foregroundColor");
    openapiFields.add("hidden");
    openapiFields.add("id");
    openapiFields.add("kind");
    openapiFields.add("location");
    openapiFields.add("notificationSettings");
    openapiFields.add("primary");
    openapiFields.add("selected");
    openapiFields.add("summary");
    openapiFields.add("summaryOverride");
    openapiFields.add("timeZone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CalendarListEntry
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CalendarListEntry.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CalendarListEntry is not found in the empty JSON string", CalendarListEntry.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CalendarListEntry.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CalendarListEntry` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accessRole") != null && !jsonObj.get("accessRole").isJsonNull()) && !jsonObj.get("accessRole").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessRole` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accessRole").toString()));
      }
      if ((jsonObj.get("backgroundColor") != null && !jsonObj.get("backgroundColor").isJsonNull()) && !jsonObj.get("backgroundColor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backgroundColor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backgroundColor").toString()));
      }
      if ((jsonObj.get("colorId") != null && !jsonObj.get("colorId").isJsonNull()) && !jsonObj.get("colorId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `colorId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("colorId").toString()));
      }
      // validate the optional field `conferenceProperties`
      if (jsonObj.get("conferenceProperties") != null && !jsonObj.get("conferenceProperties").isJsonNull()) {
        ConferenceProperties.validateJsonElement(jsonObj.get("conferenceProperties"));
      }
      if (jsonObj.get("defaultReminders") != null && !jsonObj.get("defaultReminders").isJsonNull()) {
        JsonArray jsonArraydefaultReminders = jsonObj.getAsJsonArray("defaultReminders");
        if (jsonArraydefaultReminders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("defaultReminders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `defaultReminders` to be an array in the JSON string but got `%s`", jsonObj.get("defaultReminders").toString()));
          }

          // validate the optional field `defaultReminders` (array)
          for (int i = 0; i < jsonArraydefaultReminders.size(); i++) {
            EventReminder.validateJsonElement(jsonArraydefaultReminders.get(i));
          };
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("foregroundColor") != null && !jsonObj.get("foregroundColor").isJsonNull()) && !jsonObj.get("foregroundColor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `foregroundColor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("foregroundColor").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      // validate the optional field `notificationSettings`
      if (jsonObj.get("notificationSettings") != null && !jsonObj.get("notificationSettings").isJsonNull()) {
        CalendarListEntryNotificationSettings.validateJsonElement(jsonObj.get("notificationSettings"));
      }
      if ((jsonObj.get("summary") != null && !jsonObj.get("summary").isJsonNull()) && !jsonObj.get("summary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summary").toString()));
      }
      if ((jsonObj.get("summaryOverride") != null && !jsonObj.get("summaryOverride").isJsonNull()) && !jsonObj.get("summaryOverride").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summaryOverride` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summaryOverride").toString()));
      }
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CalendarListEntry.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CalendarListEntry' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CalendarListEntry> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CalendarListEntry.class));

       return (TypeAdapter<T>) new TypeAdapter<CalendarListEntry>() {
           @Override
           public void write(JsonWriter out, CalendarListEntry value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CalendarListEntry read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CalendarListEntry given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CalendarListEntry
   * @throws IOException if the JSON string is invalid with respect to CalendarListEntry
   */
  public static CalendarListEntry fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CalendarListEntry.class);
  }

  /**
   * Convert an instance of CalendarListEntry to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

