/**
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAutoprovisioningNodePoolDefaults.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAutoprovisioningNodePoolDefaults::OAIAutoprovisioningNodePoolDefaults(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAutoprovisioningNodePoolDefaults::OAIAutoprovisioningNodePoolDefaults() {
    this->initializeModel();
}

OAIAutoprovisioningNodePoolDefaults::~OAIAutoprovisioningNodePoolDefaults() {}

void OAIAutoprovisioningNodePoolDefaults::initializeModel() {

    m_boot_disk_kms_key_isSet = false;
    m_boot_disk_kms_key_isValid = false;

    m_disk_size_gb_isSet = false;
    m_disk_size_gb_isValid = false;

    m_disk_type_isSet = false;
    m_disk_type_isValid = false;

    m_image_type_isSet = false;
    m_image_type_isValid = false;

    m_insecure_kubelet_readonly_port_enabled_isSet = false;
    m_insecure_kubelet_readonly_port_enabled_isValid = false;

    m_management_isSet = false;
    m_management_isValid = false;

    m_min_cpu_platform_isSet = false;
    m_min_cpu_platform_isValid = false;

    m_oauth_scopes_isSet = false;
    m_oauth_scopes_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_shielded_instance_config_isSet = false;
    m_shielded_instance_config_isValid = false;

    m_upgrade_settings_isSet = false;
    m_upgrade_settings_isValid = false;
}

void OAIAutoprovisioningNodePoolDefaults::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAutoprovisioningNodePoolDefaults::fromJsonObject(QJsonObject json) {

    m_boot_disk_kms_key_isValid = ::OpenAPI::fromJsonValue(m_boot_disk_kms_key, json[QString("bootDiskKmsKey")]);
    m_boot_disk_kms_key_isSet = !json[QString("bootDiskKmsKey")].isNull() && m_boot_disk_kms_key_isValid;

    m_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_disk_size_gb, json[QString("diskSizeGb")]);
    m_disk_size_gb_isSet = !json[QString("diskSizeGb")].isNull() && m_disk_size_gb_isValid;

    m_disk_type_isValid = ::OpenAPI::fromJsonValue(m_disk_type, json[QString("diskType")]);
    m_disk_type_isSet = !json[QString("diskType")].isNull() && m_disk_type_isValid;

    m_image_type_isValid = ::OpenAPI::fromJsonValue(m_image_type, json[QString("imageType")]);
    m_image_type_isSet = !json[QString("imageType")].isNull() && m_image_type_isValid;

    m_insecure_kubelet_readonly_port_enabled_isValid = ::OpenAPI::fromJsonValue(m_insecure_kubelet_readonly_port_enabled, json[QString("insecureKubeletReadonlyPortEnabled")]);
    m_insecure_kubelet_readonly_port_enabled_isSet = !json[QString("insecureKubeletReadonlyPortEnabled")].isNull() && m_insecure_kubelet_readonly_port_enabled_isValid;

    m_management_isValid = ::OpenAPI::fromJsonValue(m_management, json[QString("management")]);
    m_management_isSet = !json[QString("management")].isNull() && m_management_isValid;

    m_min_cpu_platform_isValid = ::OpenAPI::fromJsonValue(m_min_cpu_platform, json[QString("minCpuPlatform")]);
    m_min_cpu_platform_isSet = !json[QString("minCpuPlatform")].isNull() && m_min_cpu_platform_isValid;

    m_oauth_scopes_isValid = ::OpenAPI::fromJsonValue(m_oauth_scopes, json[QString("oauthScopes")]);
    m_oauth_scopes_isSet = !json[QString("oauthScopes")].isNull() && m_oauth_scopes_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_shielded_instance_config_isValid = ::OpenAPI::fromJsonValue(m_shielded_instance_config, json[QString("shieldedInstanceConfig")]);
    m_shielded_instance_config_isSet = !json[QString("shieldedInstanceConfig")].isNull() && m_shielded_instance_config_isValid;

    m_upgrade_settings_isValid = ::OpenAPI::fromJsonValue(m_upgrade_settings, json[QString("upgradeSettings")]);
    m_upgrade_settings_isSet = !json[QString("upgradeSettings")].isNull() && m_upgrade_settings_isValid;
}

QString OAIAutoprovisioningNodePoolDefaults::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAutoprovisioningNodePoolDefaults::asJsonObject() const {
    QJsonObject obj;
    if (m_boot_disk_kms_key_isSet) {
        obj.insert(QString("bootDiskKmsKey"), ::OpenAPI::toJsonValue(m_boot_disk_kms_key));
    }
    if (m_disk_size_gb_isSet) {
        obj.insert(QString("diskSizeGb"), ::OpenAPI::toJsonValue(m_disk_size_gb));
    }
    if (m_disk_type_isSet) {
        obj.insert(QString("diskType"), ::OpenAPI::toJsonValue(m_disk_type));
    }
    if (m_image_type_isSet) {
        obj.insert(QString("imageType"), ::OpenAPI::toJsonValue(m_image_type));
    }
    if (m_insecure_kubelet_readonly_port_enabled_isSet) {
        obj.insert(QString("insecureKubeletReadonlyPortEnabled"), ::OpenAPI::toJsonValue(m_insecure_kubelet_readonly_port_enabled));
    }
    if (m_management.isSet()) {
        obj.insert(QString("management"), ::OpenAPI::toJsonValue(m_management));
    }
    if (m_min_cpu_platform_isSet) {
        obj.insert(QString("minCpuPlatform"), ::OpenAPI::toJsonValue(m_min_cpu_platform));
    }
    if (m_oauth_scopes.size() > 0) {
        obj.insert(QString("oauthScopes"), ::OpenAPI::toJsonValue(m_oauth_scopes));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_shielded_instance_config.isSet()) {
        obj.insert(QString("shieldedInstanceConfig"), ::OpenAPI::toJsonValue(m_shielded_instance_config));
    }
    if (m_upgrade_settings.isSet()) {
        obj.insert(QString("upgradeSettings"), ::OpenAPI::toJsonValue(m_upgrade_settings));
    }
    return obj;
}

QString OAIAutoprovisioningNodePoolDefaults::getBootDiskKmsKey() const {
    return m_boot_disk_kms_key;
}
void OAIAutoprovisioningNodePoolDefaults::setBootDiskKmsKey(const QString &boot_disk_kms_key) {
    m_boot_disk_kms_key = boot_disk_kms_key;
    m_boot_disk_kms_key_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_boot_disk_kms_key_Set() const{
    return m_boot_disk_kms_key_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_boot_disk_kms_key_Valid() const{
    return m_boot_disk_kms_key_isValid;
}

qint32 OAIAutoprovisioningNodePoolDefaults::getDiskSizeGb() const {
    return m_disk_size_gb;
}
void OAIAutoprovisioningNodePoolDefaults::setDiskSizeGb(const qint32 &disk_size_gb) {
    m_disk_size_gb = disk_size_gb;
    m_disk_size_gb_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_disk_size_gb_Set() const{
    return m_disk_size_gb_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_disk_size_gb_Valid() const{
    return m_disk_size_gb_isValid;
}

QString OAIAutoprovisioningNodePoolDefaults::getDiskType() const {
    return m_disk_type;
}
void OAIAutoprovisioningNodePoolDefaults::setDiskType(const QString &disk_type) {
    m_disk_type = disk_type;
    m_disk_type_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_disk_type_Set() const{
    return m_disk_type_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_disk_type_Valid() const{
    return m_disk_type_isValid;
}

QString OAIAutoprovisioningNodePoolDefaults::getImageType() const {
    return m_image_type;
}
void OAIAutoprovisioningNodePoolDefaults::setImageType(const QString &image_type) {
    m_image_type = image_type;
    m_image_type_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_image_type_Set() const{
    return m_image_type_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_image_type_Valid() const{
    return m_image_type_isValid;
}

bool OAIAutoprovisioningNodePoolDefaults::isInsecureKubeletReadonlyPortEnabled() const {
    return m_insecure_kubelet_readonly_port_enabled;
}
void OAIAutoprovisioningNodePoolDefaults::setInsecureKubeletReadonlyPortEnabled(const bool &insecure_kubelet_readonly_port_enabled) {
    m_insecure_kubelet_readonly_port_enabled = insecure_kubelet_readonly_port_enabled;
    m_insecure_kubelet_readonly_port_enabled_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_insecure_kubelet_readonly_port_enabled_Set() const{
    return m_insecure_kubelet_readonly_port_enabled_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_insecure_kubelet_readonly_port_enabled_Valid() const{
    return m_insecure_kubelet_readonly_port_enabled_isValid;
}

OAINodeManagement OAIAutoprovisioningNodePoolDefaults::getManagement() const {
    return m_management;
}
void OAIAutoprovisioningNodePoolDefaults::setManagement(const OAINodeManagement &management) {
    m_management = management;
    m_management_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_management_Set() const{
    return m_management_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_management_Valid() const{
    return m_management_isValid;
}

QString OAIAutoprovisioningNodePoolDefaults::getMinCpuPlatform() const {
    return m_min_cpu_platform;
}
void OAIAutoprovisioningNodePoolDefaults::setMinCpuPlatform(const QString &min_cpu_platform) {
    m_min_cpu_platform = min_cpu_platform;
    m_min_cpu_platform_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_min_cpu_platform_Set() const{
    return m_min_cpu_platform_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_min_cpu_platform_Valid() const{
    return m_min_cpu_platform_isValid;
}

QList<QString> OAIAutoprovisioningNodePoolDefaults::getOauthScopes() const {
    return m_oauth_scopes;
}
void OAIAutoprovisioningNodePoolDefaults::setOauthScopes(const QList<QString> &oauth_scopes) {
    m_oauth_scopes = oauth_scopes;
    m_oauth_scopes_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_oauth_scopes_Set() const{
    return m_oauth_scopes_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_oauth_scopes_Valid() const{
    return m_oauth_scopes_isValid;
}

QString OAIAutoprovisioningNodePoolDefaults::getServiceAccount() const {
    return m_service_account;
}
void OAIAutoprovisioningNodePoolDefaults::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_service_account_Valid() const{
    return m_service_account_isValid;
}

OAIShieldedInstanceConfig OAIAutoprovisioningNodePoolDefaults::getShieldedInstanceConfig() const {
    return m_shielded_instance_config;
}
void OAIAutoprovisioningNodePoolDefaults::setShieldedInstanceConfig(const OAIShieldedInstanceConfig &shielded_instance_config) {
    m_shielded_instance_config = shielded_instance_config;
    m_shielded_instance_config_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_shielded_instance_config_Set() const{
    return m_shielded_instance_config_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_shielded_instance_config_Valid() const{
    return m_shielded_instance_config_isValid;
}

OAIUpgradeSettings OAIAutoprovisioningNodePoolDefaults::getUpgradeSettings() const {
    return m_upgrade_settings;
}
void OAIAutoprovisioningNodePoolDefaults::setUpgradeSettings(const OAIUpgradeSettings &upgrade_settings) {
    m_upgrade_settings = upgrade_settings;
    m_upgrade_settings_isSet = true;
}

bool OAIAutoprovisioningNodePoolDefaults::is_upgrade_settings_Set() const{
    return m_upgrade_settings_isSet;
}

bool OAIAutoprovisioningNodePoolDefaults::is_upgrade_settings_Valid() const{
    return m_upgrade_settings_isValid;
}

bool OAIAutoprovisioningNodePoolDefaults::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_boot_disk_kms_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_insecure_kubelet_readonly_port_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_management.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_cpu_platform_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_oauth_scopes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_shielded_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_upgrade_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAutoprovisioningNodePoolDefaults::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
