/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.AcceleratorConfig;
import org.openapitools.client.model.AdvancedMachineFeatures;
import org.openapitools.client.model.ConfidentialNodes;
import org.openapitools.client.model.EphemeralStorageConfig;
import org.openapitools.client.model.EphemeralStorageLocalSsdConfig;
import org.openapitools.client.model.FastSocket;
import org.openapitools.client.model.GcfsConfig;
import org.openapitools.client.model.HostMaintenancePolicy;
import org.openapitools.client.model.LinuxNodeConfig;
import org.openapitools.client.model.LocalNvmeSsdBlockConfig;
import org.openapitools.client.model.NodeKubeletConfig;
import org.openapitools.client.model.NodePoolLoggingConfig;
import org.openapitools.client.model.NodeTaint;
import org.openapitools.client.model.ReservationAffinity;
import org.openapitools.client.model.ResourceManagerTags;
import org.openapitools.client.model.SandboxConfig;
import org.openapitools.client.model.SecondaryBootDisk;
import org.openapitools.client.model.ShieldedInstanceConfig;
import org.openapitools.client.model.SoleTenantConfig;
import org.openapitools.client.model.VirtualNIC;
import org.openapitools.client.model.WindowsNodeConfig;
import org.openapitools.client.model.WorkloadMetadataConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters that describe the nodes in a cluster. GKE Autopilot clusters do not recognize parameters in &#x60;NodeConfig&#x60;. Use AutoprovisioningNodePoolDefaults instead.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:27.538902-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NodeConfig {
  public static final String SERIALIZED_NAME_ACCELERATORS = "accelerators";
  @SerializedName(SERIALIZED_NAME_ACCELERATORS)
  private List<AcceleratorConfig> accelerators = new ArrayList<>();

  public static final String SERIALIZED_NAME_ADVANCED_MACHINE_FEATURES = "advancedMachineFeatures";
  @SerializedName(SERIALIZED_NAME_ADVANCED_MACHINE_FEATURES)
  private AdvancedMachineFeatures advancedMachineFeatures;

  public static final String SERIALIZED_NAME_BOOT_DISK_KMS_KEY = "bootDiskKmsKey";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_KMS_KEY)
  private String bootDiskKmsKey;

  public static final String SERIALIZED_NAME_CONFIDENTIAL_NODES = "confidentialNodes";
  @SerializedName(SERIALIZED_NAME_CONFIDENTIAL_NODES)
  private ConfidentialNodes confidentialNodes;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_DISK_TYPE = "diskType";
  @SerializedName(SERIALIZED_NAME_DISK_TYPE)
  private String diskType;

  public static final String SERIALIZED_NAME_ENABLE_CONFIDENTIAL_STORAGE = "enableConfidentialStorage";
  @SerializedName(SERIALIZED_NAME_ENABLE_CONFIDENTIAL_STORAGE)
  private Boolean enableConfidentialStorage;

  public static final String SERIALIZED_NAME_EPHEMERAL_STORAGE_CONFIG = "ephemeralStorageConfig";
  @SerializedName(SERIALIZED_NAME_EPHEMERAL_STORAGE_CONFIG)
  private EphemeralStorageConfig ephemeralStorageConfig;

  public static final String SERIALIZED_NAME_EPHEMERAL_STORAGE_LOCAL_SSD_CONFIG = "ephemeralStorageLocalSsdConfig";
  @SerializedName(SERIALIZED_NAME_EPHEMERAL_STORAGE_LOCAL_SSD_CONFIG)
  private EphemeralStorageLocalSsdConfig ephemeralStorageLocalSsdConfig;

  public static final String SERIALIZED_NAME_FAST_SOCKET = "fastSocket";
  @SerializedName(SERIALIZED_NAME_FAST_SOCKET)
  private FastSocket fastSocket;

  public static final String SERIALIZED_NAME_GCFS_CONFIG = "gcfsConfig";
  @SerializedName(SERIALIZED_NAME_GCFS_CONFIG)
  private GcfsConfig gcfsConfig;

  public static final String SERIALIZED_NAME_GVNIC = "gvnic";
  @SerializedName(SERIALIZED_NAME_GVNIC)
  private VirtualNIC gvnic;

  public static final String SERIALIZED_NAME_HOST_MAINTENANCE_POLICY = "hostMaintenancePolicy";
  @SerializedName(SERIALIZED_NAME_HOST_MAINTENANCE_POLICY)
  private HostMaintenancePolicy hostMaintenancePolicy;

  public static final String SERIALIZED_NAME_IMAGE_TYPE = "imageType";
  @SerializedName(SERIALIZED_NAME_IMAGE_TYPE)
  private String imageType;

  public static final String SERIALIZED_NAME_KUBELET_CONFIG = "kubeletConfig";
  @SerializedName(SERIALIZED_NAME_KUBELET_CONFIG)
  private NodeKubeletConfig kubeletConfig;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LINUX_NODE_CONFIG = "linuxNodeConfig";
  @SerializedName(SERIALIZED_NAME_LINUX_NODE_CONFIG)
  private LinuxNodeConfig linuxNodeConfig;

  public static final String SERIALIZED_NAME_LOCAL_NVME_SSD_BLOCK_CONFIG = "localNvmeSsdBlockConfig";
  @SerializedName(SERIALIZED_NAME_LOCAL_NVME_SSD_BLOCK_CONFIG)
  private LocalNvmeSsdBlockConfig localNvmeSsdBlockConfig;

  public static final String SERIALIZED_NAME_LOCAL_SSD_COUNT = "localSsdCount";
  @SerializedName(SERIALIZED_NAME_LOCAL_SSD_COUNT)
  private Integer localSsdCount;

  public static final String SERIALIZED_NAME_LOGGING_CONFIG = "loggingConfig";
  @SerializedName(SERIALIZED_NAME_LOGGING_CONFIG)
  private NodePoolLoggingConfig loggingConfig;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_MIN_CPU_PLATFORM = "minCpuPlatform";
  @SerializedName(SERIALIZED_NAME_MIN_CPU_PLATFORM)
  private String minCpuPlatform;

  public static final String SERIALIZED_NAME_NODE_GROUP = "nodeGroup";
  @SerializedName(SERIALIZED_NAME_NODE_GROUP)
  private String nodeGroup;

  public static final String SERIALIZED_NAME_OAUTH_SCOPES = "oauthScopes";
  @SerializedName(SERIALIZED_NAME_OAUTH_SCOPES)
  private List<String> oauthScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PREEMPTIBLE = "preemptible";
  @SerializedName(SERIALIZED_NAME_PREEMPTIBLE)
  private Boolean preemptible;

  public static final String SERIALIZED_NAME_RESERVATION_AFFINITY = "reservationAffinity";
  @SerializedName(SERIALIZED_NAME_RESERVATION_AFFINITY)
  private ReservationAffinity reservationAffinity;

  public static final String SERIALIZED_NAME_RESOURCE_LABELS = "resourceLabels";
  @SerializedName(SERIALIZED_NAME_RESOURCE_LABELS)
  private Map<String, String> resourceLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_RESOURCE_MANAGER_TAGS = "resourceManagerTags";
  @SerializedName(SERIALIZED_NAME_RESOURCE_MANAGER_TAGS)
  private ResourceManagerTags resourceManagerTags;

  public static final String SERIALIZED_NAME_SANDBOX_CONFIG = "sandboxConfig";
  @SerializedName(SERIALIZED_NAME_SANDBOX_CONFIG)
  private SandboxConfig sandboxConfig;

  public static final String SERIALIZED_NAME_SECONDARY_BOOT_DISKS = "secondaryBootDisks";
  @SerializedName(SERIALIZED_NAME_SECONDARY_BOOT_DISKS)
  private List<SecondaryBootDisk> secondaryBootDisks = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG = "shieldedInstanceConfig";
  @SerializedName(SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG)
  private ShieldedInstanceConfig shieldedInstanceConfig;

  public static final String SERIALIZED_NAME_SOLE_TENANT_CONFIG = "soleTenantConfig";
  @SerializedName(SERIALIZED_NAME_SOLE_TENANT_CONFIG)
  private SoleTenantConfig soleTenantConfig;

  public static final String SERIALIZED_NAME_SPOT = "spot";
  @SerializedName(SERIALIZED_NAME_SPOT)
  private Boolean spot;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_TAINTS = "taints";
  @SerializedName(SERIALIZED_NAME_TAINTS)
  private List<NodeTaint> taints = new ArrayList<>();

  public static final String SERIALIZED_NAME_WINDOWS_NODE_CONFIG = "windowsNodeConfig";
  @SerializedName(SERIALIZED_NAME_WINDOWS_NODE_CONFIG)
  private WindowsNodeConfig windowsNodeConfig;

  public static final String SERIALIZED_NAME_WORKLOAD_METADATA_CONFIG = "workloadMetadataConfig";
  @SerializedName(SERIALIZED_NAME_WORKLOAD_METADATA_CONFIG)
  private WorkloadMetadataConfig workloadMetadataConfig;

  public NodeConfig() {
  }

  public NodeConfig accelerators(List<AcceleratorConfig> accelerators) {
    this.accelerators = accelerators;
    return this;
  }

  public NodeConfig addAcceleratorsItem(AcceleratorConfig acceleratorsItem) {
    if (this.accelerators == null) {
      this.accelerators = new ArrayList<>();
    }
    this.accelerators.add(acceleratorsItem);
    return this;
  }

  /**
   * A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
   * @return accelerators
   */
  @javax.annotation.Nullable
  public List<AcceleratorConfig> getAccelerators() {
    return accelerators;
  }

  public void setAccelerators(List<AcceleratorConfig> accelerators) {
    this.accelerators = accelerators;
  }


  public NodeConfig advancedMachineFeatures(AdvancedMachineFeatures advancedMachineFeatures) {
    this.advancedMachineFeatures = advancedMachineFeatures;
    return this;
  }

  /**
   * Get advancedMachineFeatures
   * @return advancedMachineFeatures
   */
  @javax.annotation.Nullable
  public AdvancedMachineFeatures getAdvancedMachineFeatures() {
    return advancedMachineFeatures;
  }

  public void setAdvancedMachineFeatures(AdvancedMachineFeatures advancedMachineFeatures) {
    this.advancedMachineFeatures = advancedMachineFeatures;
  }


  public NodeConfig bootDiskKmsKey(String bootDiskKmsKey) {
    this.bootDiskKmsKey = bootDiskKmsKey;
    return this;
  }

  /**
   *  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   * @return bootDiskKmsKey
   */
  @javax.annotation.Nullable
  public String getBootDiskKmsKey() {
    return bootDiskKmsKey;
  }

  public void setBootDiskKmsKey(String bootDiskKmsKey) {
    this.bootDiskKmsKey = bootDiskKmsKey;
  }


  public NodeConfig confidentialNodes(ConfidentialNodes confidentialNodes) {
    this.confidentialNodes = confidentialNodes;
    return this;
  }

  /**
   * Get confidentialNodes
   * @return confidentialNodes
   */
  @javax.annotation.Nullable
  public ConfidentialNodes getConfidentialNodes() {
    return confidentialNodes;
  }

  public void setConfidentialNodes(ConfidentialNodes confidentialNodes) {
    this.confidentialNodes = confidentialNodes;
  }


  public NodeConfig diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public NodeConfig diskType(String diskType) {
    this.diskType = diskType;
    return this;
  }

  /**
   * Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
   * @return diskType
   */
  @javax.annotation.Nullable
  public String getDiskType() {
    return diskType;
  }

  public void setDiskType(String diskType) {
    this.diskType = diskType;
  }


  public NodeConfig enableConfidentialStorage(Boolean enableConfidentialStorage) {
    this.enableConfidentialStorage = enableConfidentialStorage;
    return this;
  }

  /**
   * Optional. Reserved for future use.
   * @return enableConfidentialStorage
   */
  @javax.annotation.Nullable
  public Boolean getEnableConfidentialStorage() {
    return enableConfidentialStorage;
  }

  public void setEnableConfidentialStorage(Boolean enableConfidentialStorage) {
    this.enableConfidentialStorage = enableConfidentialStorage;
  }


  public NodeConfig ephemeralStorageConfig(EphemeralStorageConfig ephemeralStorageConfig) {
    this.ephemeralStorageConfig = ephemeralStorageConfig;
    return this;
  }

  /**
   * Get ephemeralStorageConfig
   * @return ephemeralStorageConfig
   */
  @javax.annotation.Nullable
  public EphemeralStorageConfig getEphemeralStorageConfig() {
    return ephemeralStorageConfig;
  }

  public void setEphemeralStorageConfig(EphemeralStorageConfig ephemeralStorageConfig) {
    this.ephemeralStorageConfig = ephemeralStorageConfig;
  }


  public NodeConfig ephemeralStorageLocalSsdConfig(EphemeralStorageLocalSsdConfig ephemeralStorageLocalSsdConfig) {
    this.ephemeralStorageLocalSsdConfig = ephemeralStorageLocalSsdConfig;
    return this;
  }

  /**
   * Get ephemeralStorageLocalSsdConfig
   * @return ephemeralStorageLocalSsdConfig
   */
  @javax.annotation.Nullable
  public EphemeralStorageLocalSsdConfig getEphemeralStorageLocalSsdConfig() {
    return ephemeralStorageLocalSsdConfig;
  }

  public void setEphemeralStorageLocalSsdConfig(EphemeralStorageLocalSsdConfig ephemeralStorageLocalSsdConfig) {
    this.ephemeralStorageLocalSsdConfig = ephemeralStorageLocalSsdConfig;
  }


  public NodeConfig fastSocket(FastSocket fastSocket) {
    this.fastSocket = fastSocket;
    return this;
  }

  /**
   * Get fastSocket
   * @return fastSocket
   */
  @javax.annotation.Nullable
  public FastSocket getFastSocket() {
    return fastSocket;
  }

  public void setFastSocket(FastSocket fastSocket) {
    this.fastSocket = fastSocket;
  }


  public NodeConfig gcfsConfig(GcfsConfig gcfsConfig) {
    this.gcfsConfig = gcfsConfig;
    return this;
  }

  /**
   * Get gcfsConfig
   * @return gcfsConfig
   */
  @javax.annotation.Nullable
  public GcfsConfig getGcfsConfig() {
    return gcfsConfig;
  }

  public void setGcfsConfig(GcfsConfig gcfsConfig) {
    this.gcfsConfig = gcfsConfig;
  }


  public NodeConfig gvnic(VirtualNIC gvnic) {
    this.gvnic = gvnic;
    return this;
  }

  /**
   * Get gvnic
   * @return gvnic
   */
  @javax.annotation.Nullable
  public VirtualNIC getGvnic() {
    return gvnic;
  }

  public void setGvnic(VirtualNIC gvnic) {
    this.gvnic = gvnic;
  }


  public NodeConfig hostMaintenancePolicy(HostMaintenancePolicy hostMaintenancePolicy) {
    this.hostMaintenancePolicy = hostMaintenancePolicy;
    return this;
  }

  /**
   * Get hostMaintenancePolicy
   * @return hostMaintenancePolicy
   */
  @javax.annotation.Nullable
  public HostMaintenancePolicy getHostMaintenancePolicy() {
    return hostMaintenancePolicy;
  }

  public void setHostMaintenancePolicy(HostMaintenancePolicy hostMaintenancePolicy) {
    this.hostMaintenancePolicy = hostMaintenancePolicy;
  }


  public NodeConfig imageType(String imageType) {
    this.imageType = imageType;
    return this;
  }

  /**
   * The image type to use for this node. Note that for a given image type, the latest version of it will be used. Please see https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for available image types.
   * @return imageType
   */
  @javax.annotation.Nullable
  public String getImageType() {
    return imageType;
  }

  public void setImageType(String imageType) {
    this.imageType = imageType;
  }


  public NodeConfig kubeletConfig(NodeKubeletConfig kubeletConfig) {
    this.kubeletConfig = kubeletConfig;
    return this;
  }

  /**
   * Get kubeletConfig
   * @return kubeletConfig
   */
  @javax.annotation.Nullable
  public NodeKubeletConfig getKubeletConfig() {
    return kubeletConfig;
  }

  public void setKubeletConfig(NodeKubeletConfig kubeletConfig) {
    this.kubeletConfig = kubeletConfig;
  }


  public NodeConfig labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public NodeConfig putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public NodeConfig linuxNodeConfig(LinuxNodeConfig linuxNodeConfig) {
    this.linuxNodeConfig = linuxNodeConfig;
    return this;
  }

  /**
   * Get linuxNodeConfig
   * @return linuxNodeConfig
   */
  @javax.annotation.Nullable
  public LinuxNodeConfig getLinuxNodeConfig() {
    return linuxNodeConfig;
  }

  public void setLinuxNodeConfig(LinuxNodeConfig linuxNodeConfig) {
    this.linuxNodeConfig = linuxNodeConfig;
  }


  public NodeConfig localNvmeSsdBlockConfig(LocalNvmeSsdBlockConfig localNvmeSsdBlockConfig) {
    this.localNvmeSsdBlockConfig = localNvmeSsdBlockConfig;
    return this;
  }

  /**
   * Get localNvmeSsdBlockConfig
   * @return localNvmeSsdBlockConfig
   */
  @javax.annotation.Nullable
  public LocalNvmeSsdBlockConfig getLocalNvmeSsdBlockConfig() {
    return localNvmeSsdBlockConfig;
  }

  public void setLocalNvmeSsdBlockConfig(LocalNvmeSsdBlockConfig localNvmeSsdBlockConfig) {
    this.localNvmeSsdBlockConfig = localNvmeSsdBlockConfig;
  }


  public NodeConfig localSsdCount(Integer localSsdCount) {
    this.localSsdCount = localSsdCount;
    return this;
  }

  /**
   * The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
   * @return localSsdCount
   */
  @javax.annotation.Nullable
  public Integer getLocalSsdCount() {
    return localSsdCount;
  }

  public void setLocalSsdCount(Integer localSsdCount) {
    this.localSsdCount = localSsdCount;
  }


  public NodeConfig loggingConfig(NodePoolLoggingConfig loggingConfig) {
    this.loggingConfig = loggingConfig;
    return this;
  }

  /**
   * Get loggingConfig
   * @return loggingConfig
   */
  @javax.annotation.Nullable
  public NodePoolLoggingConfig getLoggingConfig() {
    return loggingConfig;
  }

  public void setLoggingConfig(NodePoolLoggingConfig loggingConfig) {
    this.loggingConfig = loggingConfig;
  }


  public NodeConfig machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types). If unspecified, the default machine type is &#x60;e2-medium&#x60;.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public NodeConfig metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public NodeConfig putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp &#x60;[a-zA-Z0-9-_]+&#x60; and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - \&quot;cluster-location\&quot; - \&quot;cluster-name\&quot; - \&quot;cluster-uid\&quot; - \&quot;configure-sh\&quot; - \&quot;containerd-configure-sh\&quot; - \&quot;enable-oslogin\&quot; - \&quot;gci-ensure-gke-docker\&quot; - \&quot;gci-metrics-enabled\&quot; - \&quot;gci-update-strategy\&quot; - \&quot;instance-template\&quot; - \&quot;kube-env\&quot; - \&quot;startup-script\&quot; - \&quot;user-data\&quot; - \&quot;disable-address-manager\&quot; - \&quot;windows-startup-script-ps1\&quot; - \&quot;common-psm1\&quot; - \&quot;k8s-node-setup-psm1\&quot; - \&quot;install-ssh-psm1\&quot; - \&quot;user-profile-psm1\&quot; Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value&#39;s size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public NodeConfig minCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
    return this;
  }

  /**
   * Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as &#x60;minCpuPlatform: \&quot;Intel Haswell\&quot;&#x60; or &#x60;minCpuPlatform: \&quot;Intel Sandy Bridge\&quot;&#x60;. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
   * @return minCpuPlatform
   */
  @javax.annotation.Nullable
  public String getMinCpuPlatform() {
    return minCpuPlatform;
  }

  public void setMinCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
  }


  public NodeConfig nodeGroup(String nodeGroup) {
    this.nodeGroup = nodeGroup;
    return this;
  }

  /**
   * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
   * @return nodeGroup
   */
  @javax.annotation.Nullable
  public String getNodeGroup() {
    return nodeGroup;
  }

  public void setNodeGroup(String nodeGroup) {
    this.nodeGroup = nodeGroup;
  }


  public NodeConfig oauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
    return this;
  }

  public NodeConfig addOauthScopesItem(String oauthScopesItem) {
    if (this.oauthScopes == null) {
      this.oauthScopes = new ArrayList<>();
    }
    this.oauthScopes.add(oauthScopesItem);
    return this;
  }

  /**
   * The set of Google API scopes to be made available on all of the node VMs under the \&quot;default\&quot; service account. The following scopes are recommended, but not required, and by default are not included: * &#x60;https://www.googleapis.com/auth/compute&#x60; is required for mounting persistent storage on your nodes. * &#x60;https://www.googleapis.com/auth/devstorage.read_only&#x60; is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
   * @return oauthScopes
   */
  @javax.annotation.Nullable
  public List<String> getOauthScopes() {
    return oauthScopes;
  }

  public void setOauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
  }


  public NodeConfig preemptible(Boolean preemptible) {
    this.preemptible = preemptible;
    return this;
  }

  /**
   * Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more information about preemptible VM instances.
   * @return preemptible
   */
  @javax.annotation.Nullable
  public Boolean getPreemptible() {
    return preemptible;
  }

  public void setPreemptible(Boolean preemptible) {
    this.preemptible = preemptible;
  }


  public NodeConfig reservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
    return this;
  }

  /**
   * Get reservationAffinity
   * @return reservationAffinity
   */
  @javax.annotation.Nullable
  public ReservationAffinity getReservationAffinity() {
    return reservationAffinity;
  }

  public void setReservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
  }


  public NodeConfig resourceLabels(Map<String, String> resourceLabels) {
    this.resourceLabels = resourceLabels;
    return this;
  }

  public NodeConfig putResourceLabelsItem(String key, String resourceLabelsItem) {
    if (this.resourceLabels == null) {
      this.resourceLabels = new HashMap<>();
    }
    this.resourceLabels.put(key, resourceLabelsItem);
    return this;
  }

  /**
   * The resource labels for the node pool to use to annotate any related Google Compute Engine resources.
   * @return resourceLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getResourceLabels() {
    return resourceLabels;
  }

  public void setResourceLabels(Map<String, String> resourceLabels) {
    this.resourceLabels = resourceLabels;
  }


  public NodeConfig resourceManagerTags(ResourceManagerTags resourceManagerTags) {
    this.resourceManagerTags = resourceManagerTags;
    return this;
  }

  /**
   * Get resourceManagerTags
   * @return resourceManagerTags
   */
  @javax.annotation.Nullable
  public ResourceManagerTags getResourceManagerTags() {
    return resourceManagerTags;
  }

  public void setResourceManagerTags(ResourceManagerTags resourceManagerTags) {
    this.resourceManagerTags = resourceManagerTags;
  }


  public NodeConfig sandboxConfig(SandboxConfig sandboxConfig) {
    this.sandboxConfig = sandboxConfig;
    return this;
  }

  /**
   * Get sandboxConfig
   * @return sandboxConfig
   */
  @javax.annotation.Nullable
  public SandboxConfig getSandboxConfig() {
    return sandboxConfig;
  }

  public void setSandboxConfig(SandboxConfig sandboxConfig) {
    this.sandboxConfig = sandboxConfig;
  }


  public NodeConfig secondaryBootDisks(List<SecondaryBootDisk> secondaryBootDisks) {
    this.secondaryBootDisks = secondaryBootDisks;
    return this;
  }

  public NodeConfig addSecondaryBootDisksItem(SecondaryBootDisk secondaryBootDisksItem) {
    if (this.secondaryBootDisks == null) {
      this.secondaryBootDisks = new ArrayList<>();
    }
    this.secondaryBootDisks.add(secondaryBootDisksItem);
    return this;
  }

  /**
   * List of secondary boot disks attached to the nodes.
   * @return secondaryBootDisks
   */
  @javax.annotation.Nullable
  public List<SecondaryBootDisk> getSecondaryBootDisks() {
    return secondaryBootDisks;
  }

  public void setSecondaryBootDisks(List<SecondaryBootDisk> secondaryBootDisks) {
    this.secondaryBootDisks = secondaryBootDisks;
  }


  public NodeConfig serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the \&quot;default\&quot; service account is used.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public NodeConfig shieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
    return this;
  }

  /**
   * Get shieldedInstanceConfig
   * @return shieldedInstanceConfig
   */
  @javax.annotation.Nullable
  public ShieldedInstanceConfig getShieldedInstanceConfig() {
    return shieldedInstanceConfig;
  }

  public void setShieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
  }


  public NodeConfig soleTenantConfig(SoleTenantConfig soleTenantConfig) {
    this.soleTenantConfig = soleTenantConfig;
    return this;
  }

  /**
   * Get soleTenantConfig
   * @return soleTenantConfig
   */
  @javax.annotation.Nullable
  public SoleTenantConfig getSoleTenantConfig() {
    return soleTenantConfig;
  }

  public void setSoleTenantConfig(SoleTenantConfig soleTenantConfig) {
    this.soleTenantConfig = soleTenantConfig;
  }


  public NodeConfig spot(Boolean spot) {
    this.spot = spot;
    return this;
  }

  /**
   * Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
   * @return spot
   */
  @javax.annotation.Nullable
  public Boolean getSpot() {
    return spot;
  }

  public void setSpot(Boolean spot) {
    this.spot = spot;
  }


  public NodeConfig tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public NodeConfig addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }


  public NodeConfig taints(List<NodeTaint> taints) {
    this.taints = taints;
    return this;
  }

  public NodeConfig addTaintsItem(NodeTaint taintsItem) {
    if (this.taints == null) {
      this.taints = new ArrayList<>();
    }
    this.taints.add(taintsItem);
    return this;
  }

  /**
   * List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
   * @return taints
   */
  @javax.annotation.Nullable
  public List<NodeTaint> getTaints() {
    return taints;
  }

  public void setTaints(List<NodeTaint> taints) {
    this.taints = taints;
  }


  public NodeConfig windowsNodeConfig(WindowsNodeConfig windowsNodeConfig) {
    this.windowsNodeConfig = windowsNodeConfig;
    return this;
  }

  /**
   * Get windowsNodeConfig
   * @return windowsNodeConfig
   */
  @javax.annotation.Nullable
  public WindowsNodeConfig getWindowsNodeConfig() {
    return windowsNodeConfig;
  }

  public void setWindowsNodeConfig(WindowsNodeConfig windowsNodeConfig) {
    this.windowsNodeConfig = windowsNodeConfig;
  }


  public NodeConfig workloadMetadataConfig(WorkloadMetadataConfig workloadMetadataConfig) {
    this.workloadMetadataConfig = workloadMetadataConfig;
    return this;
  }

  /**
   * Get workloadMetadataConfig
   * @return workloadMetadataConfig
   */
  @javax.annotation.Nullable
  public WorkloadMetadataConfig getWorkloadMetadataConfig() {
    return workloadMetadataConfig;
  }

  public void setWorkloadMetadataConfig(WorkloadMetadataConfig workloadMetadataConfig) {
    this.workloadMetadataConfig = workloadMetadataConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodeConfig nodeConfig = (NodeConfig) o;
    return Objects.equals(this.accelerators, nodeConfig.accelerators) &&
        Objects.equals(this.advancedMachineFeatures, nodeConfig.advancedMachineFeatures) &&
        Objects.equals(this.bootDiskKmsKey, nodeConfig.bootDiskKmsKey) &&
        Objects.equals(this.confidentialNodes, nodeConfig.confidentialNodes) &&
        Objects.equals(this.diskSizeGb, nodeConfig.diskSizeGb) &&
        Objects.equals(this.diskType, nodeConfig.diskType) &&
        Objects.equals(this.enableConfidentialStorage, nodeConfig.enableConfidentialStorage) &&
        Objects.equals(this.ephemeralStorageConfig, nodeConfig.ephemeralStorageConfig) &&
        Objects.equals(this.ephemeralStorageLocalSsdConfig, nodeConfig.ephemeralStorageLocalSsdConfig) &&
        Objects.equals(this.fastSocket, nodeConfig.fastSocket) &&
        Objects.equals(this.gcfsConfig, nodeConfig.gcfsConfig) &&
        Objects.equals(this.gvnic, nodeConfig.gvnic) &&
        Objects.equals(this.hostMaintenancePolicy, nodeConfig.hostMaintenancePolicy) &&
        Objects.equals(this.imageType, nodeConfig.imageType) &&
        Objects.equals(this.kubeletConfig, nodeConfig.kubeletConfig) &&
        Objects.equals(this.labels, nodeConfig.labels) &&
        Objects.equals(this.linuxNodeConfig, nodeConfig.linuxNodeConfig) &&
        Objects.equals(this.localNvmeSsdBlockConfig, nodeConfig.localNvmeSsdBlockConfig) &&
        Objects.equals(this.localSsdCount, nodeConfig.localSsdCount) &&
        Objects.equals(this.loggingConfig, nodeConfig.loggingConfig) &&
        Objects.equals(this.machineType, nodeConfig.machineType) &&
        Objects.equals(this.metadata, nodeConfig.metadata) &&
        Objects.equals(this.minCpuPlatform, nodeConfig.minCpuPlatform) &&
        Objects.equals(this.nodeGroup, nodeConfig.nodeGroup) &&
        Objects.equals(this.oauthScopes, nodeConfig.oauthScopes) &&
        Objects.equals(this.preemptible, nodeConfig.preemptible) &&
        Objects.equals(this.reservationAffinity, nodeConfig.reservationAffinity) &&
        Objects.equals(this.resourceLabels, nodeConfig.resourceLabels) &&
        Objects.equals(this.resourceManagerTags, nodeConfig.resourceManagerTags) &&
        Objects.equals(this.sandboxConfig, nodeConfig.sandboxConfig) &&
        Objects.equals(this.secondaryBootDisks, nodeConfig.secondaryBootDisks) &&
        Objects.equals(this.serviceAccount, nodeConfig.serviceAccount) &&
        Objects.equals(this.shieldedInstanceConfig, nodeConfig.shieldedInstanceConfig) &&
        Objects.equals(this.soleTenantConfig, nodeConfig.soleTenantConfig) &&
        Objects.equals(this.spot, nodeConfig.spot) &&
        Objects.equals(this.tags, nodeConfig.tags) &&
        Objects.equals(this.taints, nodeConfig.taints) &&
        Objects.equals(this.windowsNodeConfig, nodeConfig.windowsNodeConfig) &&
        Objects.equals(this.workloadMetadataConfig, nodeConfig.workloadMetadataConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accelerators, advancedMachineFeatures, bootDiskKmsKey, confidentialNodes, diskSizeGb, diskType, enableConfidentialStorage, ephemeralStorageConfig, ephemeralStorageLocalSsdConfig, fastSocket, gcfsConfig, gvnic, hostMaintenancePolicy, imageType, kubeletConfig, labels, linuxNodeConfig, localNvmeSsdBlockConfig, localSsdCount, loggingConfig, machineType, metadata, minCpuPlatform, nodeGroup, oauthScopes, preemptible, reservationAffinity, resourceLabels, resourceManagerTags, sandboxConfig, secondaryBootDisks, serviceAccount, shieldedInstanceConfig, soleTenantConfig, spot, tags, taints, windowsNodeConfig, workloadMetadataConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodeConfig {\n");
    sb.append("    accelerators: ").append(toIndentedString(accelerators)).append("\n");
    sb.append("    advancedMachineFeatures: ").append(toIndentedString(advancedMachineFeatures)).append("\n");
    sb.append("    bootDiskKmsKey: ").append(toIndentedString(bootDiskKmsKey)).append("\n");
    sb.append("    confidentialNodes: ").append(toIndentedString(confidentialNodes)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    diskType: ").append(toIndentedString(diskType)).append("\n");
    sb.append("    enableConfidentialStorage: ").append(toIndentedString(enableConfidentialStorage)).append("\n");
    sb.append("    ephemeralStorageConfig: ").append(toIndentedString(ephemeralStorageConfig)).append("\n");
    sb.append("    ephemeralStorageLocalSsdConfig: ").append(toIndentedString(ephemeralStorageLocalSsdConfig)).append("\n");
    sb.append("    fastSocket: ").append(toIndentedString(fastSocket)).append("\n");
    sb.append("    gcfsConfig: ").append(toIndentedString(gcfsConfig)).append("\n");
    sb.append("    gvnic: ").append(toIndentedString(gvnic)).append("\n");
    sb.append("    hostMaintenancePolicy: ").append(toIndentedString(hostMaintenancePolicy)).append("\n");
    sb.append("    imageType: ").append(toIndentedString(imageType)).append("\n");
    sb.append("    kubeletConfig: ").append(toIndentedString(kubeletConfig)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    linuxNodeConfig: ").append(toIndentedString(linuxNodeConfig)).append("\n");
    sb.append("    localNvmeSsdBlockConfig: ").append(toIndentedString(localNvmeSsdBlockConfig)).append("\n");
    sb.append("    localSsdCount: ").append(toIndentedString(localSsdCount)).append("\n");
    sb.append("    loggingConfig: ").append(toIndentedString(loggingConfig)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    minCpuPlatform: ").append(toIndentedString(minCpuPlatform)).append("\n");
    sb.append("    nodeGroup: ").append(toIndentedString(nodeGroup)).append("\n");
    sb.append("    oauthScopes: ").append(toIndentedString(oauthScopes)).append("\n");
    sb.append("    preemptible: ").append(toIndentedString(preemptible)).append("\n");
    sb.append("    reservationAffinity: ").append(toIndentedString(reservationAffinity)).append("\n");
    sb.append("    resourceLabels: ").append(toIndentedString(resourceLabels)).append("\n");
    sb.append("    resourceManagerTags: ").append(toIndentedString(resourceManagerTags)).append("\n");
    sb.append("    sandboxConfig: ").append(toIndentedString(sandboxConfig)).append("\n");
    sb.append("    secondaryBootDisks: ").append(toIndentedString(secondaryBootDisks)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    shieldedInstanceConfig: ").append(toIndentedString(shieldedInstanceConfig)).append("\n");
    sb.append("    soleTenantConfig: ").append(toIndentedString(soleTenantConfig)).append("\n");
    sb.append("    spot: ").append(toIndentedString(spot)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    taints: ").append(toIndentedString(taints)).append("\n");
    sb.append("    windowsNodeConfig: ").append(toIndentedString(windowsNodeConfig)).append("\n");
    sb.append("    workloadMetadataConfig: ").append(toIndentedString(workloadMetadataConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accelerators");
    openapiFields.add("advancedMachineFeatures");
    openapiFields.add("bootDiskKmsKey");
    openapiFields.add("confidentialNodes");
    openapiFields.add("diskSizeGb");
    openapiFields.add("diskType");
    openapiFields.add("enableConfidentialStorage");
    openapiFields.add("ephemeralStorageConfig");
    openapiFields.add("ephemeralStorageLocalSsdConfig");
    openapiFields.add("fastSocket");
    openapiFields.add("gcfsConfig");
    openapiFields.add("gvnic");
    openapiFields.add("hostMaintenancePolicy");
    openapiFields.add("imageType");
    openapiFields.add("kubeletConfig");
    openapiFields.add("labels");
    openapiFields.add("linuxNodeConfig");
    openapiFields.add("localNvmeSsdBlockConfig");
    openapiFields.add("localSsdCount");
    openapiFields.add("loggingConfig");
    openapiFields.add("machineType");
    openapiFields.add("metadata");
    openapiFields.add("minCpuPlatform");
    openapiFields.add("nodeGroup");
    openapiFields.add("oauthScopes");
    openapiFields.add("preemptible");
    openapiFields.add("reservationAffinity");
    openapiFields.add("resourceLabels");
    openapiFields.add("resourceManagerTags");
    openapiFields.add("sandboxConfig");
    openapiFields.add("secondaryBootDisks");
    openapiFields.add("serviceAccount");
    openapiFields.add("shieldedInstanceConfig");
    openapiFields.add("soleTenantConfig");
    openapiFields.add("spot");
    openapiFields.add("tags");
    openapiFields.add("taints");
    openapiFields.add("windowsNodeConfig");
    openapiFields.add("workloadMetadataConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NodeConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodeConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodeConfig is not found in the empty JSON string", NodeConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodeConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodeConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("accelerators") != null && !jsonObj.get("accelerators").isJsonNull()) {
        JsonArray jsonArrayaccelerators = jsonObj.getAsJsonArray("accelerators");
        if (jsonArrayaccelerators != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accelerators").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accelerators` to be an array in the JSON string but got `%s`", jsonObj.get("accelerators").toString()));
          }

          // validate the optional field `accelerators` (array)
          for (int i = 0; i < jsonArrayaccelerators.size(); i++) {
            AcceleratorConfig.validateJsonElement(jsonArrayaccelerators.get(i));
          };
        }
      }
      // validate the optional field `advancedMachineFeatures`
      if (jsonObj.get("advancedMachineFeatures") != null && !jsonObj.get("advancedMachineFeatures").isJsonNull()) {
        AdvancedMachineFeatures.validateJsonElement(jsonObj.get("advancedMachineFeatures"));
      }
      if ((jsonObj.get("bootDiskKmsKey") != null && !jsonObj.get("bootDiskKmsKey").isJsonNull()) && !jsonObj.get("bootDiskKmsKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskKmsKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskKmsKey").toString()));
      }
      // validate the optional field `confidentialNodes`
      if (jsonObj.get("confidentialNodes") != null && !jsonObj.get("confidentialNodes").isJsonNull()) {
        ConfidentialNodes.validateJsonElement(jsonObj.get("confidentialNodes"));
      }
      if ((jsonObj.get("diskType") != null && !jsonObj.get("diskType").isJsonNull()) && !jsonObj.get("diskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskType").toString()));
      }
      // validate the optional field `ephemeralStorageConfig`
      if (jsonObj.get("ephemeralStorageConfig") != null && !jsonObj.get("ephemeralStorageConfig").isJsonNull()) {
        EphemeralStorageConfig.validateJsonElement(jsonObj.get("ephemeralStorageConfig"));
      }
      // validate the optional field `ephemeralStorageLocalSsdConfig`
      if (jsonObj.get("ephemeralStorageLocalSsdConfig") != null && !jsonObj.get("ephemeralStorageLocalSsdConfig").isJsonNull()) {
        EphemeralStorageLocalSsdConfig.validateJsonElement(jsonObj.get("ephemeralStorageLocalSsdConfig"));
      }
      // validate the optional field `fastSocket`
      if (jsonObj.get("fastSocket") != null && !jsonObj.get("fastSocket").isJsonNull()) {
        FastSocket.validateJsonElement(jsonObj.get("fastSocket"));
      }
      // validate the optional field `gcfsConfig`
      if (jsonObj.get("gcfsConfig") != null && !jsonObj.get("gcfsConfig").isJsonNull()) {
        GcfsConfig.validateJsonElement(jsonObj.get("gcfsConfig"));
      }
      // validate the optional field `gvnic`
      if (jsonObj.get("gvnic") != null && !jsonObj.get("gvnic").isJsonNull()) {
        VirtualNIC.validateJsonElement(jsonObj.get("gvnic"));
      }
      // validate the optional field `hostMaintenancePolicy`
      if (jsonObj.get("hostMaintenancePolicy") != null && !jsonObj.get("hostMaintenancePolicy").isJsonNull()) {
        HostMaintenancePolicy.validateJsonElement(jsonObj.get("hostMaintenancePolicy"));
      }
      if ((jsonObj.get("imageType") != null && !jsonObj.get("imageType").isJsonNull()) && !jsonObj.get("imageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageType").toString()));
      }
      // validate the optional field `kubeletConfig`
      if (jsonObj.get("kubeletConfig") != null && !jsonObj.get("kubeletConfig").isJsonNull()) {
        NodeKubeletConfig.validateJsonElement(jsonObj.get("kubeletConfig"));
      }
      // validate the optional field `linuxNodeConfig`
      if (jsonObj.get("linuxNodeConfig") != null && !jsonObj.get("linuxNodeConfig").isJsonNull()) {
        LinuxNodeConfig.validateJsonElement(jsonObj.get("linuxNodeConfig"));
      }
      // validate the optional field `localNvmeSsdBlockConfig`
      if (jsonObj.get("localNvmeSsdBlockConfig") != null && !jsonObj.get("localNvmeSsdBlockConfig").isJsonNull()) {
        LocalNvmeSsdBlockConfig.validateJsonElement(jsonObj.get("localNvmeSsdBlockConfig"));
      }
      // validate the optional field `loggingConfig`
      if (jsonObj.get("loggingConfig") != null && !jsonObj.get("loggingConfig").isJsonNull()) {
        NodePoolLoggingConfig.validateJsonElement(jsonObj.get("loggingConfig"));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("minCpuPlatform") != null && !jsonObj.get("minCpuPlatform").isJsonNull()) && !jsonObj.get("minCpuPlatform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minCpuPlatform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minCpuPlatform").toString()));
      }
      if ((jsonObj.get("nodeGroup") != null && !jsonObj.get("nodeGroup").isJsonNull()) && !jsonObj.get("nodeGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeGroup").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("oauthScopes") != null && !jsonObj.get("oauthScopes").isJsonNull() && !jsonObj.get("oauthScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthScopes` to be an array in the JSON string but got `%s`", jsonObj.get("oauthScopes").toString()));
      }
      // validate the optional field `reservationAffinity`
      if (jsonObj.get("reservationAffinity") != null && !jsonObj.get("reservationAffinity").isJsonNull()) {
        ReservationAffinity.validateJsonElement(jsonObj.get("reservationAffinity"));
      }
      // validate the optional field `resourceManagerTags`
      if (jsonObj.get("resourceManagerTags") != null && !jsonObj.get("resourceManagerTags").isJsonNull()) {
        ResourceManagerTags.validateJsonElement(jsonObj.get("resourceManagerTags"));
      }
      // validate the optional field `sandboxConfig`
      if (jsonObj.get("sandboxConfig") != null && !jsonObj.get("sandboxConfig").isJsonNull()) {
        SandboxConfig.validateJsonElement(jsonObj.get("sandboxConfig"));
      }
      if (jsonObj.get("secondaryBootDisks") != null && !jsonObj.get("secondaryBootDisks").isJsonNull()) {
        JsonArray jsonArraysecondaryBootDisks = jsonObj.getAsJsonArray("secondaryBootDisks");
        if (jsonArraysecondaryBootDisks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secondaryBootDisks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secondaryBootDisks` to be an array in the JSON string but got `%s`", jsonObj.get("secondaryBootDisks").toString()));
          }

          // validate the optional field `secondaryBootDisks` (array)
          for (int i = 0; i < jsonArraysecondaryBootDisks.size(); i++) {
            SecondaryBootDisk.validateJsonElement(jsonArraysecondaryBootDisks.get(i));
          };
        }
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // validate the optional field `shieldedInstanceConfig`
      if (jsonObj.get("shieldedInstanceConfig") != null && !jsonObj.get("shieldedInstanceConfig").isJsonNull()) {
        ShieldedInstanceConfig.validateJsonElement(jsonObj.get("shieldedInstanceConfig"));
      }
      // validate the optional field `soleTenantConfig`
      if (jsonObj.get("soleTenantConfig") != null && !jsonObj.get("soleTenantConfig").isJsonNull()) {
        SoleTenantConfig.validateJsonElement(jsonObj.get("soleTenantConfig"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if (jsonObj.get("taints") != null && !jsonObj.get("taints").isJsonNull()) {
        JsonArray jsonArraytaints = jsonObj.getAsJsonArray("taints");
        if (jsonArraytaints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("taints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `taints` to be an array in the JSON string but got `%s`", jsonObj.get("taints").toString()));
          }

          // validate the optional field `taints` (array)
          for (int i = 0; i < jsonArraytaints.size(); i++) {
            NodeTaint.validateJsonElement(jsonArraytaints.get(i));
          };
        }
      }
      // validate the optional field `windowsNodeConfig`
      if (jsonObj.get("windowsNodeConfig") != null && !jsonObj.get("windowsNodeConfig").isJsonNull()) {
        WindowsNodeConfig.validateJsonElement(jsonObj.get("windowsNodeConfig"));
      }
      // validate the optional field `workloadMetadataConfig`
      if (jsonObj.get("workloadMetadataConfig") != null && !jsonObj.get("workloadMetadataConfig").isJsonNull()) {
        WorkloadMetadataConfig.validateJsonElement(jsonObj.get("workloadMetadataConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodeConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodeConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodeConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodeConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<NodeConfig>() {
           @Override
           public void write(JsonWriter out, NodeConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodeConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NodeConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NodeConfig
   * @throws IOException if the JSON string is invalid with respect to NodeConfig
   */
  public static NodeConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodeConfig.class);
  }

  /**
   * Convert an instance of NodeConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

