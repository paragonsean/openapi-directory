/**
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINodeConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINodeConfig::OAINodeConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINodeConfig::OAINodeConfig() {
    this->initializeModel();
}

OAINodeConfig::~OAINodeConfig() {}

void OAINodeConfig::initializeModel() {

    m_accelerators_isSet = false;
    m_accelerators_isValid = false;

    m_advanced_machine_features_isSet = false;
    m_advanced_machine_features_isValid = false;

    m_boot_disk_kms_key_isSet = false;
    m_boot_disk_kms_key_isValid = false;

    m_confidential_nodes_isSet = false;
    m_confidential_nodes_isValid = false;

    m_disk_size_gb_isSet = false;
    m_disk_size_gb_isValid = false;

    m_disk_type_isSet = false;
    m_disk_type_isValid = false;

    m_enable_confidential_storage_isSet = false;
    m_enable_confidential_storage_isValid = false;

    m_ephemeral_storage_local_ssd_config_isSet = false;
    m_ephemeral_storage_local_ssd_config_isValid = false;

    m_fast_socket_isSet = false;
    m_fast_socket_isValid = false;

    m_gcfs_config_isSet = false;
    m_gcfs_config_isValid = false;

    m_gvnic_isSet = false;
    m_gvnic_isValid = false;

    m_image_type_isSet = false;
    m_image_type_isValid = false;

    m_kubelet_config_isSet = false;
    m_kubelet_config_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_linux_node_config_isSet = false;
    m_linux_node_config_isValid = false;

    m_local_nvme_ssd_block_config_isSet = false;
    m_local_nvme_ssd_block_config_isValid = false;

    m_local_ssd_count_isSet = false;
    m_local_ssd_count_isValid = false;

    m_logging_config_isSet = false;
    m_logging_config_isValid = false;

    m_machine_type_isSet = false;
    m_machine_type_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_min_cpu_platform_isSet = false;
    m_min_cpu_platform_isValid = false;

    m_node_group_isSet = false;
    m_node_group_isValid = false;

    m_oauth_scopes_isSet = false;
    m_oauth_scopes_isValid = false;

    m_preemptible_isSet = false;
    m_preemptible_isValid = false;

    m_reservation_affinity_isSet = false;
    m_reservation_affinity_isValid = false;

    m_resource_labels_isSet = false;
    m_resource_labels_isValid = false;

    m_resource_manager_tags_isSet = false;
    m_resource_manager_tags_isValid = false;

    m_sandbox_config_isSet = false;
    m_sandbox_config_isValid = false;

    m_secondary_boot_disks_isSet = false;
    m_secondary_boot_disks_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_shielded_instance_config_isSet = false;
    m_shielded_instance_config_isValid = false;

    m_sole_tenant_config_isSet = false;
    m_sole_tenant_config_isValid = false;

    m_spot_isSet = false;
    m_spot_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;

    m_taints_isSet = false;
    m_taints_isValid = false;

    m_windows_node_config_isSet = false;
    m_windows_node_config_isValid = false;

    m_workload_metadata_config_isSet = false;
    m_workload_metadata_config_isValid = false;
}

void OAINodeConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINodeConfig::fromJsonObject(QJsonObject json) {

    m_accelerators_isValid = ::OpenAPI::fromJsonValue(m_accelerators, json[QString("accelerators")]);
    m_accelerators_isSet = !json[QString("accelerators")].isNull() && m_accelerators_isValid;

    m_advanced_machine_features_isValid = ::OpenAPI::fromJsonValue(m_advanced_machine_features, json[QString("advancedMachineFeatures")]);
    m_advanced_machine_features_isSet = !json[QString("advancedMachineFeatures")].isNull() && m_advanced_machine_features_isValid;

    m_boot_disk_kms_key_isValid = ::OpenAPI::fromJsonValue(m_boot_disk_kms_key, json[QString("bootDiskKmsKey")]);
    m_boot_disk_kms_key_isSet = !json[QString("bootDiskKmsKey")].isNull() && m_boot_disk_kms_key_isValid;

    m_confidential_nodes_isValid = ::OpenAPI::fromJsonValue(m_confidential_nodes, json[QString("confidentialNodes")]);
    m_confidential_nodes_isSet = !json[QString("confidentialNodes")].isNull() && m_confidential_nodes_isValid;

    m_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_disk_size_gb, json[QString("diskSizeGb")]);
    m_disk_size_gb_isSet = !json[QString("diskSizeGb")].isNull() && m_disk_size_gb_isValid;

    m_disk_type_isValid = ::OpenAPI::fromJsonValue(m_disk_type, json[QString("diskType")]);
    m_disk_type_isSet = !json[QString("diskType")].isNull() && m_disk_type_isValid;

    m_enable_confidential_storage_isValid = ::OpenAPI::fromJsonValue(m_enable_confidential_storage, json[QString("enableConfidentialStorage")]);
    m_enable_confidential_storage_isSet = !json[QString("enableConfidentialStorage")].isNull() && m_enable_confidential_storage_isValid;

    m_ephemeral_storage_local_ssd_config_isValid = ::OpenAPI::fromJsonValue(m_ephemeral_storage_local_ssd_config, json[QString("ephemeralStorageLocalSsdConfig")]);
    m_ephemeral_storage_local_ssd_config_isSet = !json[QString("ephemeralStorageLocalSsdConfig")].isNull() && m_ephemeral_storage_local_ssd_config_isValid;

    m_fast_socket_isValid = ::OpenAPI::fromJsonValue(m_fast_socket, json[QString("fastSocket")]);
    m_fast_socket_isSet = !json[QString("fastSocket")].isNull() && m_fast_socket_isValid;

    m_gcfs_config_isValid = ::OpenAPI::fromJsonValue(m_gcfs_config, json[QString("gcfsConfig")]);
    m_gcfs_config_isSet = !json[QString("gcfsConfig")].isNull() && m_gcfs_config_isValid;

    m_gvnic_isValid = ::OpenAPI::fromJsonValue(m_gvnic, json[QString("gvnic")]);
    m_gvnic_isSet = !json[QString("gvnic")].isNull() && m_gvnic_isValid;

    m_image_type_isValid = ::OpenAPI::fromJsonValue(m_image_type, json[QString("imageType")]);
    m_image_type_isSet = !json[QString("imageType")].isNull() && m_image_type_isValid;

    m_kubelet_config_isValid = ::OpenAPI::fromJsonValue(m_kubelet_config, json[QString("kubeletConfig")]);
    m_kubelet_config_isSet = !json[QString("kubeletConfig")].isNull() && m_kubelet_config_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_linux_node_config_isValid = ::OpenAPI::fromJsonValue(m_linux_node_config, json[QString("linuxNodeConfig")]);
    m_linux_node_config_isSet = !json[QString("linuxNodeConfig")].isNull() && m_linux_node_config_isValid;

    m_local_nvme_ssd_block_config_isValid = ::OpenAPI::fromJsonValue(m_local_nvme_ssd_block_config, json[QString("localNvmeSsdBlockConfig")]);
    m_local_nvme_ssd_block_config_isSet = !json[QString("localNvmeSsdBlockConfig")].isNull() && m_local_nvme_ssd_block_config_isValid;

    m_local_ssd_count_isValid = ::OpenAPI::fromJsonValue(m_local_ssd_count, json[QString("localSsdCount")]);
    m_local_ssd_count_isSet = !json[QString("localSsdCount")].isNull() && m_local_ssd_count_isValid;

    m_logging_config_isValid = ::OpenAPI::fromJsonValue(m_logging_config, json[QString("loggingConfig")]);
    m_logging_config_isSet = !json[QString("loggingConfig")].isNull() && m_logging_config_isValid;

    m_machine_type_isValid = ::OpenAPI::fromJsonValue(m_machine_type, json[QString("machineType")]);
    m_machine_type_isSet = !json[QString("machineType")].isNull() && m_machine_type_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_min_cpu_platform_isValid = ::OpenAPI::fromJsonValue(m_min_cpu_platform, json[QString("minCpuPlatform")]);
    m_min_cpu_platform_isSet = !json[QString("minCpuPlatform")].isNull() && m_min_cpu_platform_isValid;

    m_node_group_isValid = ::OpenAPI::fromJsonValue(m_node_group, json[QString("nodeGroup")]);
    m_node_group_isSet = !json[QString("nodeGroup")].isNull() && m_node_group_isValid;

    m_oauth_scopes_isValid = ::OpenAPI::fromJsonValue(m_oauth_scopes, json[QString("oauthScopes")]);
    m_oauth_scopes_isSet = !json[QString("oauthScopes")].isNull() && m_oauth_scopes_isValid;

    m_preemptible_isValid = ::OpenAPI::fromJsonValue(m_preemptible, json[QString("preemptible")]);
    m_preemptible_isSet = !json[QString("preemptible")].isNull() && m_preemptible_isValid;

    m_reservation_affinity_isValid = ::OpenAPI::fromJsonValue(m_reservation_affinity, json[QString("reservationAffinity")]);
    m_reservation_affinity_isSet = !json[QString("reservationAffinity")].isNull() && m_reservation_affinity_isValid;

    m_resource_labels_isValid = ::OpenAPI::fromJsonValue(m_resource_labels, json[QString("resourceLabels")]);
    m_resource_labels_isSet = !json[QString("resourceLabels")].isNull() && m_resource_labels_isValid;

    m_resource_manager_tags_isValid = ::OpenAPI::fromJsonValue(m_resource_manager_tags, json[QString("resourceManagerTags")]);
    m_resource_manager_tags_isSet = !json[QString("resourceManagerTags")].isNull() && m_resource_manager_tags_isValid;

    m_sandbox_config_isValid = ::OpenAPI::fromJsonValue(m_sandbox_config, json[QString("sandboxConfig")]);
    m_sandbox_config_isSet = !json[QString("sandboxConfig")].isNull() && m_sandbox_config_isValid;

    m_secondary_boot_disks_isValid = ::OpenAPI::fromJsonValue(m_secondary_boot_disks, json[QString("secondaryBootDisks")]);
    m_secondary_boot_disks_isSet = !json[QString("secondaryBootDisks")].isNull() && m_secondary_boot_disks_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_shielded_instance_config_isValid = ::OpenAPI::fromJsonValue(m_shielded_instance_config, json[QString("shieldedInstanceConfig")]);
    m_shielded_instance_config_isSet = !json[QString("shieldedInstanceConfig")].isNull() && m_shielded_instance_config_isValid;

    m_sole_tenant_config_isValid = ::OpenAPI::fromJsonValue(m_sole_tenant_config, json[QString("soleTenantConfig")]);
    m_sole_tenant_config_isSet = !json[QString("soleTenantConfig")].isNull() && m_sole_tenant_config_isValid;

    m_spot_isValid = ::OpenAPI::fromJsonValue(m_spot, json[QString("spot")]);
    m_spot_isSet = !json[QString("spot")].isNull() && m_spot_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;

    m_taints_isValid = ::OpenAPI::fromJsonValue(m_taints, json[QString("taints")]);
    m_taints_isSet = !json[QString("taints")].isNull() && m_taints_isValid;

    m_windows_node_config_isValid = ::OpenAPI::fromJsonValue(m_windows_node_config, json[QString("windowsNodeConfig")]);
    m_windows_node_config_isSet = !json[QString("windowsNodeConfig")].isNull() && m_windows_node_config_isValid;

    m_workload_metadata_config_isValid = ::OpenAPI::fromJsonValue(m_workload_metadata_config, json[QString("workloadMetadataConfig")]);
    m_workload_metadata_config_isSet = !json[QString("workloadMetadataConfig")].isNull() && m_workload_metadata_config_isValid;
}

QString OAINodeConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINodeConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_accelerators.size() > 0) {
        obj.insert(QString("accelerators"), ::OpenAPI::toJsonValue(m_accelerators));
    }
    if (m_advanced_machine_features.isSet()) {
        obj.insert(QString("advancedMachineFeatures"), ::OpenAPI::toJsonValue(m_advanced_machine_features));
    }
    if (m_boot_disk_kms_key_isSet) {
        obj.insert(QString("bootDiskKmsKey"), ::OpenAPI::toJsonValue(m_boot_disk_kms_key));
    }
    if (m_confidential_nodes.isSet()) {
        obj.insert(QString("confidentialNodes"), ::OpenAPI::toJsonValue(m_confidential_nodes));
    }
    if (m_disk_size_gb_isSet) {
        obj.insert(QString("diskSizeGb"), ::OpenAPI::toJsonValue(m_disk_size_gb));
    }
    if (m_disk_type_isSet) {
        obj.insert(QString("diskType"), ::OpenAPI::toJsonValue(m_disk_type));
    }
    if (m_enable_confidential_storage_isSet) {
        obj.insert(QString("enableConfidentialStorage"), ::OpenAPI::toJsonValue(m_enable_confidential_storage));
    }
    if (m_ephemeral_storage_local_ssd_config.isSet()) {
        obj.insert(QString("ephemeralStorageLocalSsdConfig"), ::OpenAPI::toJsonValue(m_ephemeral_storage_local_ssd_config));
    }
    if (m_fast_socket.isSet()) {
        obj.insert(QString("fastSocket"), ::OpenAPI::toJsonValue(m_fast_socket));
    }
    if (m_gcfs_config.isSet()) {
        obj.insert(QString("gcfsConfig"), ::OpenAPI::toJsonValue(m_gcfs_config));
    }
    if (m_gvnic.isSet()) {
        obj.insert(QString("gvnic"), ::OpenAPI::toJsonValue(m_gvnic));
    }
    if (m_image_type_isSet) {
        obj.insert(QString("imageType"), ::OpenAPI::toJsonValue(m_image_type));
    }
    if (m_kubelet_config.isSet()) {
        obj.insert(QString("kubeletConfig"), ::OpenAPI::toJsonValue(m_kubelet_config));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_linux_node_config.isSet()) {
        obj.insert(QString("linuxNodeConfig"), ::OpenAPI::toJsonValue(m_linux_node_config));
    }
    if (m_local_nvme_ssd_block_config.isSet()) {
        obj.insert(QString("localNvmeSsdBlockConfig"), ::OpenAPI::toJsonValue(m_local_nvme_ssd_block_config));
    }
    if (m_local_ssd_count_isSet) {
        obj.insert(QString("localSsdCount"), ::OpenAPI::toJsonValue(m_local_ssd_count));
    }
    if (m_logging_config.isSet()) {
        obj.insert(QString("loggingConfig"), ::OpenAPI::toJsonValue(m_logging_config));
    }
    if (m_machine_type_isSet) {
        obj.insert(QString("machineType"), ::OpenAPI::toJsonValue(m_machine_type));
    }
    if (m_metadata.size() > 0) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_min_cpu_platform_isSet) {
        obj.insert(QString("minCpuPlatform"), ::OpenAPI::toJsonValue(m_min_cpu_platform));
    }
    if (m_node_group_isSet) {
        obj.insert(QString("nodeGroup"), ::OpenAPI::toJsonValue(m_node_group));
    }
    if (m_oauth_scopes.size() > 0) {
        obj.insert(QString("oauthScopes"), ::OpenAPI::toJsonValue(m_oauth_scopes));
    }
    if (m_preemptible_isSet) {
        obj.insert(QString("preemptible"), ::OpenAPI::toJsonValue(m_preemptible));
    }
    if (m_reservation_affinity.isSet()) {
        obj.insert(QString("reservationAffinity"), ::OpenAPI::toJsonValue(m_reservation_affinity));
    }
    if (m_resource_labels.size() > 0) {
        obj.insert(QString("resourceLabels"), ::OpenAPI::toJsonValue(m_resource_labels));
    }
    if (m_resource_manager_tags.isSet()) {
        obj.insert(QString("resourceManagerTags"), ::OpenAPI::toJsonValue(m_resource_manager_tags));
    }
    if (m_sandbox_config.isSet()) {
        obj.insert(QString("sandboxConfig"), ::OpenAPI::toJsonValue(m_sandbox_config));
    }
    if (m_secondary_boot_disks.size() > 0) {
        obj.insert(QString("secondaryBootDisks"), ::OpenAPI::toJsonValue(m_secondary_boot_disks));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_shielded_instance_config.isSet()) {
        obj.insert(QString("shieldedInstanceConfig"), ::OpenAPI::toJsonValue(m_shielded_instance_config));
    }
    if (m_sole_tenant_config.isSet()) {
        obj.insert(QString("soleTenantConfig"), ::OpenAPI::toJsonValue(m_sole_tenant_config));
    }
    if (m_spot_isSet) {
        obj.insert(QString("spot"), ::OpenAPI::toJsonValue(m_spot));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    if (m_taints.size() > 0) {
        obj.insert(QString("taints"), ::OpenAPI::toJsonValue(m_taints));
    }
    if (m_windows_node_config.isSet()) {
        obj.insert(QString("windowsNodeConfig"), ::OpenAPI::toJsonValue(m_windows_node_config));
    }
    if (m_workload_metadata_config.isSet()) {
        obj.insert(QString("workloadMetadataConfig"), ::OpenAPI::toJsonValue(m_workload_metadata_config));
    }
    return obj;
}

QList<OAIAcceleratorConfig> OAINodeConfig::getAccelerators() const {
    return m_accelerators;
}
void OAINodeConfig::setAccelerators(const QList<OAIAcceleratorConfig> &accelerators) {
    m_accelerators = accelerators;
    m_accelerators_isSet = true;
}

bool OAINodeConfig::is_accelerators_Set() const{
    return m_accelerators_isSet;
}

bool OAINodeConfig::is_accelerators_Valid() const{
    return m_accelerators_isValid;
}

OAIAdvancedMachineFeatures OAINodeConfig::getAdvancedMachineFeatures() const {
    return m_advanced_machine_features;
}
void OAINodeConfig::setAdvancedMachineFeatures(const OAIAdvancedMachineFeatures &advanced_machine_features) {
    m_advanced_machine_features = advanced_machine_features;
    m_advanced_machine_features_isSet = true;
}

bool OAINodeConfig::is_advanced_machine_features_Set() const{
    return m_advanced_machine_features_isSet;
}

bool OAINodeConfig::is_advanced_machine_features_Valid() const{
    return m_advanced_machine_features_isValid;
}

QString OAINodeConfig::getBootDiskKmsKey() const {
    return m_boot_disk_kms_key;
}
void OAINodeConfig::setBootDiskKmsKey(const QString &boot_disk_kms_key) {
    m_boot_disk_kms_key = boot_disk_kms_key;
    m_boot_disk_kms_key_isSet = true;
}

bool OAINodeConfig::is_boot_disk_kms_key_Set() const{
    return m_boot_disk_kms_key_isSet;
}

bool OAINodeConfig::is_boot_disk_kms_key_Valid() const{
    return m_boot_disk_kms_key_isValid;
}

OAIConfidentialNodes OAINodeConfig::getConfidentialNodes() const {
    return m_confidential_nodes;
}
void OAINodeConfig::setConfidentialNodes(const OAIConfidentialNodes &confidential_nodes) {
    m_confidential_nodes = confidential_nodes;
    m_confidential_nodes_isSet = true;
}

bool OAINodeConfig::is_confidential_nodes_Set() const{
    return m_confidential_nodes_isSet;
}

bool OAINodeConfig::is_confidential_nodes_Valid() const{
    return m_confidential_nodes_isValid;
}

qint32 OAINodeConfig::getDiskSizeGb() const {
    return m_disk_size_gb;
}
void OAINodeConfig::setDiskSizeGb(const qint32 &disk_size_gb) {
    m_disk_size_gb = disk_size_gb;
    m_disk_size_gb_isSet = true;
}

bool OAINodeConfig::is_disk_size_gb_Set() const{
    return m_disk_size_gb_isSet;
}

bool OAINodeConfig::is_disk_size_gb_Valid() const{
    return m_disk_size_gb_isValid;
}

QString OAINodeConfig::getDiskType() const {
    return m_disk_type;
}
void OAINodeConfig::setDiskType(const QString &disk_type) {
    m_disk_type = disk_type;
    m_disk_type_isSet = true;
}

bool OAINodeConfig::is_disk_type_Set() const{
    return m_disk_type_isSet;
}

bool OAINodeConfig::is_disk_type_Valid() const{
    return m_disk_type_isValid;
}

bool OAINodeConfig::isEnableConfidentialStorage() const {
    return m_enable_confidential_storage;
}
void OAINodeConfig::setEnableConfidentialStorage(const bool &enable_confidential_storage) {
    m_enable_confidential_storage = enable_confidential_storage;
    m_enable_confidential_storage_isSet = true;
}

bool OAINodeConfig::is_enable_confidential_storage_Set() const{
    return m_enable_confidential_storage_isSet;
}

bool OAINodeConfig::is_enable_confidential_storage_Valid() const{
    return m_enable_confidential_storage_isValid;
}

OAIEphemeralStorageLocalSsdConfig OAINodeConfig::getEphemeralStorageLocalSsdConfig() const {
    return m_ephemeral_storage_local_ssd_config;
}
void OAINodeConfig::setEphemeralStorageLocalSsdConfig(const OAIEphemeralStorageLocalSsdConfig &ephemeral_storage_local_ssd_config) {
    m_ephemeral_storage_local_ssd_config = ephemeral_storage_local_ssd_config;
    m_ephemeral_storage_local_ssd_config_isSet = true;
}

bool OAINodeConfig::is_ephemeral_storage_local_ssd_config_Set() const{
    return m_ephemeral_storage_local_ssd_config_isSet;
}

bool OAINodeConfig::is_ephemeral_storage_local_ssd_config_Valid() const{
    return m_ephemeral_storage_local_ssd_config_isValid;
}

OAIFastSocket OAINodeConfig::getFastSocket() const {
    return m_fast_socket;
}
void OAINodeConfig::setFastSocket(const OAIFastSocket &fast_socket) {
    m_fast_socket = fast_socket;
    m_fast_socket_isSet = true;
}

bool OAINodeConfig::is_fast_socket_Set() const{
    return m_fast_socket_isSet;
}

bool OAINodeConfig::is_fast_socket_Valid() const{
    return m_fast_socket_isValid;
}

OAIGcfsConfig OAINodeConfig::getGcfsConfig() const {
    return m_gcfs_config;
}
void OAINodeConfig::setGcfsConfig(const OAIGcfsConfig &gcfs_config) {
    m_gcfs_config = gcfs_config;
    m_gcfs_config_isSet = true;
}

bool OAINodeConfig::is_gcfs_config_Set() const{
    return m_gcfs_config_isSet;
}

bool OAINodeConfig::is_gcfs_config_Valid() const{
    return m_gcfs_config_isValid;
}

OAIVirtualNIC OAINodeConfig::getGvnic() const {
    return m_gvnic;
}
void OAINodeConfig::setGvnic(const OAIVirtualNIC &gvnic) {
    m_gvnic = gvnic;
    m_gvnic_isSet = true;
}

bool OAINodeConfig::is_gvnic_Set() const{
    return m_gvnic_isSet;
}

bool OAINodeConfig::is_gvnic_Valid() const{
    return m_gvnic_isValid;
}

QString OAINodeConfig::getImageType() const {
    return m_image_type;
}
void OAINodeConfig::setImageType(const QString &image_type) {
    m_image_type = image_type;
    m_image_type_isSet = true;
}

bool OAINodeConfig::is_image_type_Set() const{
    return m_image_type_isSet;
}

bool OAINodeConfig::is_image_type_Valid() const{
    return m_image_type_isValid;
}

OAINodeKubeletConfig OAINodeConfig::getKubeletConfig() const {
    return m_kubelet_config;
}
void OAINodeConfig::setKubeletConfig(const OAINodeKubeletConfig &kubelet_config) {
    m_kubelet_config = kubelet_config;
    m_kubelet_config_isSet = true;
}

bool OAINodeConfig::is_kubelet_config_Set() const{
    return m_kubelet_config_isSet;
}

bool OAINodeConfig::is_kubelet_config_Valid() const{
    return m_kubelet_config_isValid;
}

QMap<QString, QString> OAINodeConfig::getLabels() const {
    return m_labels;
}
void OAINodeConfig::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAINodeConfig::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAINodeConfig::is_labels_Valid() const{
    return m_labels_isValid;
}

OAILinuxNodeConfig OAINodeConfig::getLinuxNodeConfig() const {
    return m_linux_node_config;
}
void OAINodeConfig::setLinuxNodeConfig(const OAILinuxNodeConfig &linux_node_config) {
    m_linux_node_config = linux_node_config;
    m_linux_node_config_isSet = true;
}

bool OAINodeConfig::is_linux_node_config_Set() const{
    return m_linux_node_config_isSet;
}

bool OAINodeConfig::is_linux_node_config_Valid() const{
    return m_linux_node_config_isValid;
}

OAILocalNvmeSsdBlockConfig OAINodeConfig::getLocalNvmeSsdBlockConfig() const {
    return m_local_nvme_ssd_block_config;
}
void OAINodeConfig::setLocalNvmeSsdBlockConfig(const OAILocalNvmeSsdBlockConfig &local_nvme_ssd_block_config) {
    m_local_nvme_ssd_block_config = local_nvme_ssd_block_config;
    m_local_nvme_ssd_block_config_isSet = true;
}

bool OAINodeConfig::is_local_nvme_ssd_block_config_Set() const{
    return m_local_nvme_ssd_block_config_isSet;
}

bool OAINodeConfig::is_local_nvme_ssd_block_config_Valid() const{
    return m_local_nvme_ssd_block_config_isValid;
}

qint32 OAINodeConfig::getLocalSsdCount() const {
    return m_local_ssd_count;
}
void OAINodeConfig::setLocalSsdCount(const qint32 &local_ssd_count) {
    m_local_ssd_count = local_ssd_count;
    m_local_ssd_count_isSet = true;
}

bool OAINodeConfig::is_local_ssd_count_Set() const{
    return m_local_ssd_count_isSet;
}

bool OAINodeConfig::is_local_ssd_count_Valid() const{
    return m_local_ssd_count_isValid;
}

OAINodePoolLoggingConfig OAINodeConfig::getLoggingConfig() const {
    return m_logging_config;
}
void OAINodeConfig::setLoggingConfig(const OAINodePoolLoggingConfig &logging_config) {
    m_logging_config = logging_config;
    m_logging_config_isSet = true;
}

bool OAINodeConfig::is_logging_config_Set() const{
    return m_logging_config_isSet;
}

bool OAINodeConfig::is_logging_config_Valid() const{
    return m_logging_config_isValid;
}

QString OAINodeConfig::getMachineType() const {
    return m_machine_type;
}
void OAINodeConfig::setMachineType(const QString &machine_type) {
    m_machine_type = machine_type;
    m_machine_type_isSet = true;
}

bool OAINodeConfig::is_machine_type_Set() const{
    return m_machine_type_isSet;
}

bool OAINodeConfig::is_machine_type_Valid() const{
    return m_machine_type_isValid;
}

QMap<QString, QString> OAINodeConfig::getMetadata() const {
    return m_metadata;
}
void OAINodeConfig::setMetadata(const QMap<QString, QString> &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAINodeConfig::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAINodeConfig::is_metadata_Valid() const{
    return m_metadata_isValid;
}

QString OAINodeConfig::getMinCpuPlatform() const {
    return m_min_cpu_platform;
}
void OAINodeConfig::setMinCpuPlatform(const QString &min_cpu_platform) {
    m_min_cpu_platform = min_cpu_platform;
    m_min_cpu_platform_isSet = true;
}

bool OAINodeConfig::is_min_cpu_platform_Set() const{
    return m_min_cpu_platform_isSet;
}

bool OAINodeConfig::is_min_cpu_platform_Valid() const{
    return m_min_cpu_platform_isValid;
}

QString OAINodeConfig::getNodeGroup() const {
    return m_node_group;
}
void OAINodeConfig::setNodeGroup(const QString &node_group) {
    m_node_group = node_group;
    m_node_group_isSet = true;
}

bool OAINodeConfig::is_node_group_Set() const{
    return m_node_group_isSet;
}

bool OAINodeConfig::is_node_group_Valid() const{
    return m_node_group_isValid;
}

QList<QString> OAINodeConfig::getOauthScopes() const {
    return m_oauth_scopes;
}
void OAINodeConfig::setOauthScopes(const QList<QString> &oauth_scopes) {
    m_oauth_scopes = oauth_scopes;
    m_oauth_scopes_isSet = true;
}

bool OAINodeConfig::is_oauth_scopes_Set() const{
    return m_oauth_scopes_isSet;
}

bool OAINodeConfig::is_oauth_scopes_Valid() const{
    return m_oauth_scopes_isValid;
}

bool OAINodeConfig::isPreemptible() const {
    return m_preemptible;
}
void OAINodeConfig::setPreemptible(const bool &preemptible) {
    m_preemptible = preemptible;
    m_preemptible_isSet = true;
}

bool OAINodeConfig::is_preemptible_Set() const{
    return m_preemptible_isSet;
}

bool OAINodeConfig::is_preemptible_Valid() const{
    return m_preemptible_isValid;
}

OAIReservationAffinity OAINodeConfig::getReservationAffinity() const {
    return m_reservation_affinity;
}
void OAINodeConfig::setReservationAffinity(const OAIReservationAffinity &reservation_affinity) {
    m_reservation_affinity = reservation_affinity;
    m_reservation_affinity_isSet = true;
}

bool OAINodeConfig::is_reservation_affinity_Set() const{
    return m_reservation_affinity_isSet;
}

bool OAINodeConfig::is_reservation_affinity_Valid() const{
    return m_reservation_affinity_isValid;
}

QMap<QString, QString> OAINodeConfig::getResourceLabels() const {
    return m_resource_labels;
}
void OAINodeConfig::setResourceLabels(const QMap<QString, QString> &resource_labels) {
    m_resource_labels = resource_labels;
    m_resource_labels_isSet = true;
}

bool OAINodeConfig::is_resource_labels_Set() const{
    return m_resource_labels_isSet;
}

bool OAINodeConfig::is_resource_labels_Valid() const{
    return m_resource_labels_isValid;
}

OAIResourceManagerTags OAINodeConfig::getResourceManagerTags() const {
    return m_resource_manager_tags;
}
void OAINodeConfig::setResourceManagerTags(const OAIResourceManagerTags &resource_manager_tags) {
    m_resource_manager_tags = resource_manager_tags;
    m_resource_manager_tags_isSet = true;
}

bool OAINodeConfig::is_resource_manager_tags_Set() const{
    return m_resource_manager_tags_isSet;
}

bool OAINodeConfig::is_resource_manager_tags_Valid() const{
    return m_resource_manager_tags_isValid;
}

OAISandboxConfig OAINodeConfig::getSandboxConfig() const {
    return m_sandbox_config;
}
void OAINodeConfig::setSandboxConfig(const OAISandboxConfig &sandbox_config) {
    m_sandbox_config = sandbox_config;
    m_sandbox_config_isSet = true;
}

bool OAINodeConfig::is_sandbox_config_Set() const{
    return m_sandbox_config_isSet;
}

bool OAINodeConfig::is_sandbox_config_Valid() const{
    return m_sandbox_config_isValid;
}

QList<OAISecondaryBootDisk> OAINodeConfig::getSecondaryBootDisks() const {
    return m_secondary_boot_disks;
}
void OAINodeConfig::setSecondaryBootDisks(const QList<OAISecondaryBootDisk> &secondary_boot_disks) {
    m_secondary_boot_disks = secondary_boot_disks;
    m_secondary_boot_disks_isSet = true;
}

bool OAINodeConfig::is_secondary_boot_disks_Set() const{
    return m_secondary_boot_disks_isSet;
}

bool OAINodeConfig::is_secondary_boot_disks_Valid() const{
    return m_secondary_boot_disks_isValid;
}

QString OAINodeConfig::getServiceAccount() const {
    return m_service_account;
}
void OAINodeConfig::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAINodeConfig::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAINodeConfig::is_service_account_Valid() const{
    return m_service_account_isValid;
}

OAIShieldedInstanceConfig OAINodeConfig::getShieldedInstanceConfig() const {
    return m_shielded_instance_config;
}
void OAINodeConfig::setShieldedInstanceConfig(const OAIShieldedInstanceConfig &shielded_instance_config) {
    m_shielded_instance_config = shielded_instance_config;
    m_shielded_instance_config_isSet = true;
}

bool OAINodeConfig::is_shielded_instance_config_Set() const{
    return m_shielded_instance_config_isSet;
}

bool OAINodeConfig::is_shielded_instance_config_Valid() const{
    return m_shielded_instance_config_isValid;
}

OAISoleTenantConfig OAINodeConfig::getSoleTenantConfig() const {
    return m_sole_tenant_config;
}
void OAINodeConfig::setSoleTenantConfig(const OAISoleTenantConfig &sole_tenant_config) {
    m_sole_tenant_config = sole_tenant_config;
    m_sole_tenant_config_isSet = true;
}

bool OAINodeConfig::is_sole_tenant_config_Set() const{
    return m_sole_tenant_config_isSet;
}

bool OAINodeConfig::is_sole_tenant_config_Valid() const{
    return m_sole_tenant_config_isValid;
}

bool OAINodeConfig::isSpot() const {
    return m_spot;
}
void OAINodeConfig::setSpot(const bool &spot) {
    m_spot = spot;
    m_spot_isSet = true;
}

bool OAINodeConfig::is_spot_Set() const{
    return m_spot_isSet;
}

bool OAINodeConfig::is_spot_Valid() const{
    return m_spot_isValid;
}

QList<QString> OAINodeConfig::getTags() const {
    return m_tags;
}
void OAINodeConfig::setTags(const QList<QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAINodeConfig::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAINodeConfig::is_tags_Valid() const{
    return m_tags_isValid;
}

QList<OAINodeTaint> OAINodeConfig::getTaints() const {
    return m_taints;
}
void OAINodeConfig::setTaints(const QList<OAINodeTaint> &taints) {
    m_taints = taints;
    m_taints_isSet = true;
}

bool OAINodeConfig::is_taints_Set() const{
    return m_taints_isSet;
}

bool OAINodeConfig::is_taints_Valid() const{
    return m_taints_isValid;
}

OAIWindowsNodeConfig OAINodeConfig::getWindowsNodeConfig() const {
    return m_windows_node_config;
}
void OAINodeConfig::setWindowsNodeConfig(const OAIWindowsNodeConfig &windows_node_config) {
    m_windows_node_config = windows_node_config;
    m_windows_node_config_isSet = true;
}

bool OAINodeConfig::is_windows_node_config_Set() const{
    return m_windows_node_config_isSet;
}

bool OAINodeConfig::is_windows_node_config_Valid() const{
    return m_windows_node_config_isValid;
}

OAIWorkloadMetadataConfig OAINodeConfig::getWorkloadMetadataConfig() const {
    return m_workload_metadata_config;
}
void OAINodeConfig::setWorkloadMetadataConfig(const OAIWorkloadMetadataConfig &workload_metadata_config) {
    m_workload_metadata_config = workload_metadata_config;
    m_workload_metadata_config_isSet = true;
}

bool OAINodeConfig::is_workload_metadata_config_Set() const{
    return m_workload_metadata_config_isSet;
}

bool OAINodeConfig::is_workload_metadata_config_Valid() const{
    return m_workload_metadata_config_isValid;
}

bool OAINodeConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accelerators.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_advanced_machine_features.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_boot_disk_kms_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_confidential_nodes.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_confidential_storage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ephemeral_storage_local_ssd_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_fast_socket.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_gcfs_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_gvnic.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kubelet_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_linux_node_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_local_nvme_ssd_block_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_local_ssd_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logging_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_machine_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_cpu_platform_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_group_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_oauth_scopes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_preemptible_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reservation_affinity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_manager_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_sandbox_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_secondary_boot_disks.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_shielded_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_sole_tenant_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_spot_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_taints.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_windows_node_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_workload_metadata_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINodeConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
