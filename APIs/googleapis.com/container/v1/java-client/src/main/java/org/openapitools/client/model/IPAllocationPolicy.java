/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AdditionalPodRangesConfig;
import org.openapitools.client.model.PodCIDROverprovisionConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration for controlling how IPs are allocated in the cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class IPAllocationPolicy {
  public static final String SERIALIZED_NAME_ADDITIONAL_POD_RANGES_CONFIG = "additionalPodRangesConfig";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_POD_RANGES_CONFIG)
  private AdditionalPodRangesConfig additionalPodRangesConfig;

  public static final String SERIALIZED_NAME_CLUSTER_IPV4_CIDR = "clusterIpv4Cidr";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CLUSTER_IPV4_CIDR)
  private String clusterIpv4Cidr;

  public static final String SERIALIZED_NAME_CLUSTER_IPV4_CIDR_BLOCK = "clusterIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_CLUSTER_IPV4_CIDR_BLOCK)
  private String clusterIpv4CidrBlock;

  public static final String SERIALIZED_NAME_CLUSTER_SECONDARY_RANGE_NAME = "clusterSecondaryRangeName";
  @SerializedName(SERIALIZED_NAME_CLUSTER_SECONDARY_RANGE_NAME)
  private String clusterSecondaryRangeName;

  public static final String SERIALIZED_NAME_CREATE_SUBNETWORK = "createSubnetwork";
  @SerializedName(SERIALIZED_NAME_CREATE_SUBNETWORK)
  private Boolean createSubnetwork;

  public static final String SERIALIZED_NAME_DEFAULT_POD_IPV4_RANGE_UTILIZATION = "defaultPodIpv4RangeUtilization";
  @SerializedName(SERIALIZED_NAME_DEFAULT_POD_IPV4_RANGE_UTILIZATION)
  private Double defaultPodIpv4RangeUtilization;

  /**
   * The ipv6 access type (internal or external) when create_subnetwork is true
   */
  @JsonAdapter(Ipv6AccessTypeEnum.Adapter.class)
  public enum Ipv6AccessTypeEnum {
    IPV6_ACCESS_TYPE_UNSPECIFIED("IPV6_ACCESS_TYPE_UNSPECIFIED"),
    
    INTERNAL("INTERNAL"),
    
    EXTERNAL("EXTERNAL");

    private String value;

    Ipv6AccessTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static Ipv6AccessTypeEnum fromValue(String value) {
      for (Ipv6AccessTypeEnum b : Ipv6AccessTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<Ipv6AccessTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final Ipv6AccessTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public Ipv6AccessTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return Ipv6AccessTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      Ipv6AccessTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IPV6_ACCESS_TYPE = "ipv6AccessType";
  @SerializedName(SERIALIZED_NAME_IPV6_ACCESS_TYPE)
  private Ipv6AccessTypeEnum ipv6AccessType;

  public static final String SERIALIZED_NAME_NODE_IPV4_CIDR = "nodeIpv4Cidr";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_NODE_IPV4_CIDR)
  private String nodeIpv4Cidr;

  public static final String SERIALIZED_NAME_NODE_IPV4_CIDR_BLOCK = "nodeIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_NODE_IPV4_CIDR_BLOCK)
  private String nodeIpv4CidrBlock;

  public static final String SERIALIZED_NAME_POD_CIDR_OVERPROVISION_CONFIG = "podCidrOverprovisionConfig";
  @SerializedName(SERIALIZED_NAME_POD_CIDR_OVERPROVISION_CONFIG)
  private PodCIDROverprovisionConfig podCidrOverprovisionConfig;

  public static final String SERIALIZED_NAME_SERVICES_IPV4_CIDR = "servicesIpv4Cidr";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_SERVICES_IPV4_CIDR)
  private String servicesIpv4Cidr;

  public static final String SERIALIZED_NAME_SERVICES_IPV4_CIDR_BLOCK = "servicesIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_SERVICES_IPV4_CIDR_BLOCK)
  private String servicesIpv4CidrBlock;

  public static final String SERIALIZED_NAME_SERVICES_IPV6_CIDR_BLOCK = "servicesIpv6CidrBlock";
  @SerializedName(SERIALIZED_NAME_SERVICES_IPV6_CIDR_BLOCK)
  private String servicesIpv6CidrBlock;

  public static final String SERIALIZED_NAME_SERVICES_SECONDARY_RANGE_NAME = "servicesSecondaryRangeName";
  @SerializedName(SERIALIZED_NAME_SERVICES_SECONDARY_RANGE_NAME)
  private String servicesSecondaryRangeName;

  /**
   * The IP stack type of the cluster
   */
  @JsonAdapter(StackTypeEnum.Adapter.class)
  public enum StackTypeEnum {
    STACK_TYPE_UNSPECIFIED("STACK_TYPE_UNSPECIFIED"),
    
    IPV4("IPV4"),
    
    IPV4_IPV6("IPV4_IPV6");

    private String value;

    StackTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StackTypeEnum fromValue(String value) {
      for (StackTypeEnum b : StackTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StackTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StackTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StackTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StackTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StackTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STACK_TYPE = "stackType";
  @SerializedName(SERIALIZED_NAME_STACK_TYPE)
  private StackTypeEnum stackType;

  public static final String SERIALIZED_NAME_SUBNET_IPV6_CIDR_BLOCK = "subnetIpv6CidrBlock";
  @SerializedName(SERIALIZED_NAME_SUBNET_IPV6_CIDR_BLOCK)
  private String subnetIpv6CidrBlock;

  public static final String SERIALIZED_NAME_SUBNETWORK_NAME = "subnetworkName";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK_NAME)
  private String subnetworkName;

  public static final String SERIALIZED_NAME_TPU_IPV4_CIDR_BLOCK = "tpuIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_TPU_IPV4_CIDR_BLOCK)
  private String tpuIpv4CidrBlock;

  public static final String SERIALIZED_NAME_USE_IP_ALIASES = "useIpAliases";
  @SerializedName(SERIALIZED_NAME_USE_IP_ALIASES)
  private Boolean useIpAliases;

  public static final String SERIALIZED_NAME_USE_ROUTES = "useRoutes";
  @SerializedName(SERIALIZED_NAME_USE_ROUTES)
  private Boolean useRoutes;

  public IPAllocationPolicy() {
  }

  public IPAllocationPolicy(
     Double defaultPodIpv4RangeUtilization, 
     String servicesIpv6CidrBlock, 
     String subnetIpv6CidrBlock
  ) {
    this();
    this.defaultPodIpv4RangeUtilization = defaultPodIpv4RangeUtilization;
    this.servicesIpv6CidrBlock = servicesIpv6CidrBlock;
    this.subnetIpv6CidrBlock = subnetIpv6CidrBlock;
  }

  public IPAllocationPolicy additionalPodRangesConfig(AdditionalPodRangesConfig additionalPodRangesConfig) {
    this.additionalPodRangesConfig = additionalPodRangesConfig;
    return this;
  }

  /**
   * Get additionalPodRangesConfig
   * @return additionalPodRangesConfig
   */
  @javax.annotation.Nullable
  public AdditionalPodRangesConfig getAdditionalPodRangesConfig() {
    return additionalPodRangesConfig;
  }

  public void setAdditionalPodRangesConfig(AdditionalPodRangesConfig additionalPodRangesConfig) {
    this.additionalPodRangesConfig = additionalPodRangesConfig;
  }


  @Deprecated
  public IPAllocationPolicy clusterIpv4Cidr(String clusterIpv4Cidr) {
    this.clusterIpv4Cidr = clusterIpv4Cidr;
    return this;
  }

  /**
   * This field is deprecated, use cluster_ipv4_cidr_block.
   * @return clusterIpv4Cidr
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getClusterIpv4Cidr() {
    return clusterIpv4Cidr;
  }

  @Deprecated
  public void setClusterIpv4Cidr(String clusterIpv4Cidr) {
    this.clusterIpv4Cidr = clusterIpv4Cidr;
  }


  public IPAllocationPolicy clusterIpv4CidrBlock(String clusterIpv4CidrBlock) {
    this.clusterIpv4CidrBlock = clusterIpv4CidrBlock;
    return this;
  }

  /**
   * The IP address range for the cluster pod IPs. If this field is set, then &#x60;cluster.cluster_ipv4_cidr&#x60; must be left blank. This field is only applicable when &#x60;use_ip_aliases&#x60; is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. &#x60;/14&#x60;) to have a range chosen with a specific netmask. Set to a [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. &#x60;10.96.0.0/14&#x60;) from the RFC-1918 private networks (e.g. &#x60;10.0.0.0/8&#x60;, &#x60;172.16.0.0/12&#x60;, &#x60;192.168.0.0/16&#x60;) to pick a specific range to use.
   * @return clusterIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getClusterIpv4CidrBlock() {
    return clusterIpv4CidrBlock;
  }

  public void setClusterIpv4CidrBlock(String clusterIpv4CidrBlock) {
    this.clusterIpv4CidrBlock = clusterIpv4CidrBlock;
  }


  public IPAllocationPolicy clusterSecondaryRangeName(String clusterSecondaryRangeName) {
    this.clusterSecondaryRangeName = clusterSecondaryRangeName;
    return this;
  }

  /**
   * The name of the secondary range to be used for the cluster CIDR block. The secondary range will be used for pod IP addresses. This must be an existing secondary range associated with the cluster subnetwork. This field is only applicable with use_ip_aliases is true and create_subnetwork is false.
   * @return clusterSecondaryRangeName
   */
  @javax.annotation.Nullable
  public String getClusterSecondaryRangeName() {
    return clusterSecondaryRangeName;
  }

  public void setClusterSecondaryRangeName(String clusterSecondaryRangeName) {
    this.clusterSecondaryRangeName = clusterSecondaryRangeName;
  }


  public IPAllocationPolicy createSubnetwork(Boolean createSubnetwork) {
    this.createSubnetwork = createSubnetwork;
    return this;
  }

  /**
   * Whether a new subnetwork will be created automatically for the cluster. This field is only applicable when &#x60;use_ip_aliases&#x60; is true.
   * @return createSubnetwork
   */
  @javax.annotation.Nullable
  public Boolean getCreateSubnetwork() {
    return createSubnetwork;
  }

  public void setCreateSubnetwork(Boolean createSubnetwork) {
    this.createSubnetwork = createSubnetwork;
  }


  /**
   * Output only. [Output only] The utilization of the cluster default IPv4 range for the pod. The ratio is Usage/[Total number of IPs in the secondary range], Usage&#x3D;numNodes*numZones*podIPsPerNode.
   * @return defaultPodIpv4RangeUtilization
   */
  @javax.annotation.Nullable
  public Double getDefaultPodIpv4RangeUtilization() {
    return defaultPodIpv4RangeUtilization;
  }



  public IPAllocationPolicy ipv6AccessType(Ipv6AccessTypeEnum ipv6AccessType) {
    this.ipv6AccessType = ipv6AccessType;
    return this;
  }

  /**
   * The ipv6 access type (internal or external) when create_subnetwork is true
   * @return ipv6AccessType
   */
  @javax.annotation.Nullable
  public Ipv6AccessTypeEnum getIpv6AccessType() {
    return ipv6AccessType;
  }

  public void setIpv6AccessType(Ipv6AccessTypeEnum ipv6AccessType) {
    this.ipv6AccessType = ipv6AccessType;
  }


  @Deprecated
  public IPAllocationPolicy nodeIpv4Cidr(String nodeIpv4Cidr) {
    this.nodeIpv4Cidr = nodeIpv4Cidr;
    return this;
  }

  /**
   * This field is deprecated, use node_ipv4_cidr_block.
   * @return nodeIpv4Cidr
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getNodeIpv4Cidr() {
    return nodeIpv4Cidr;
  }

  @Deprecated
  public void setNodeIpv4Cidr(String nodeIpv4Cidr) {
    this.nodeIpv4Cidr = nodeIpv4Cidr;
  }


  public IPAllocationPolicy nodeIpv4CidrBlock(String nodeIpv4CidrBlock) {
    this.nodeIpv4CidrBlock = nodeIpv4CidrBlock;
    return this;
  }

  /**
   * The IP address range of the instance IPs in this cluster. This is applicable only if &#x60;create_subnetwork&#x60; is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. &#x60;/14&#x60;) to have a range chosen with a specific netmask. Set to a [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. &#x60;10.96.0.0/14&#x60;) from the RFC-1918 private networks (e.g. &#x60;10.0.0.0/8&#x60;, &#x60;172.16.0.0/12&#x60;, &#x60;192.168.0.0/16&#x60;) to pick a specific range to use.
   * @return nodeIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getNodeIpv4CidrBlock() {
    return nodeIpv4CidrBlock;
  }

  public void setNodeIpv4CidrBlock(String nodeIpv4CidrBlock) {
    this.nodeIpv4CidrBlock = nodeIpv4CidrBlock;
  }


  public IPAllocationPolicy podCidrOverprovisionConfig(PodCIDROverprovisionConfig podCidrOverprovisionConfig) {
    this.podCidrOverprovisionConfig = podCidrOverprovisionConfig;
    return this;
  }

  /**
   * Get podCidrOverprovisionConfig
   * @return podCidrOverprovisionConfig
   */
  @javax.annotation.Nullable
  public PodCIDROverprovisionConfig getPodCidrOverprovisionConfig() {
    return podCidrOverprovisionConfig;
  }

  public void setPodCidrOverprovisionConfig(PodCIDROverprovisionConfig podCidrOverprovisionConfig) {
    this.podCidrOverprovisionConfig = podCidrOverprovisionConfig;
  }


  @Deprecated
  public IPAllocationPolicy servicesIpv4Cidr(String servicesIpv4Cidr) {
    this.servicesIpv4Cidr = servicesIpv4Cidr;
    return this;
  }

  /**
   * This field is deprecated, use services_ipv4_cidr_block.
   * @return servicesIpv4Cidr
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getServicesIpv4Cidr() {
    return servicesIpv4Cidr;
  }

  @Deprecated
  public void setServicesIpv4Cidr(String servicesIpv4Cidr) {
    this.servicesIpv4Cidr = servicesIpv4Cidr;
  }


  public IPAllocationPolicy servicesIpv4CidrBlock(String servicesIpv4CidrBlock) {
    this.servicesIpv4CidrBlock = servicesIpv4CidrBlock;
    return this;
  }

  /**
   * The IP address range of the services IPs in this cluster. If blank, a range will be automatically chosen with the default size. This field is only applicable when &#x60;use_ip_aliases&#x60; is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. &#x60;/14&#x60;) to have a range chosen with a specific netmask. Set to a [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. &#x60;10.96.0.0/14&#x60;) from the RFC-1918 private networks (e.g. &#x60;10.0.0.0/8&#x60;, &#x60;172.16.0.0/12&#x60;, &#x60;192.168.0.0/16&#x60;) to pick a specific range to use.
   * @return servicesIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getServicesIpv4CidrBlock() {
    return servicesIpv4CidrBlock;
  }

  public void setServicesIpv4CidrBlock(String servicesIpv4CidrBlock) {
    this.servicesIpv4CidrBlock = servicesIpv4CidrBlock;
  }


  /**
   * Output only. [Output only] The services IPv6 CIDR block for the cluster.
   * @return servicesIpv6CidrBlock
   */
  @javax.annotation.Nullable
  public String getServicesIpv6CidrBlock() {
    return servicesIpv6CidrBlock;
  }



  public IPAllocationPolicy servicesSecondaryRangeName(String servicesSecondaryRangeName) {
    this.servicesSecondaryRangeName = servicesSecondaryRangeName;
    return this;
  }

  /**
   * The name of the secondary range to be used as for the services CIDR block. The secondary range will be used for service ClusterIPs. This must be an existing secondary range associated with the cluster subnetwork. This field is only applicable with use_ip_aliases is true and create_subnetwork is false.
   * @return servicesSecondaryRangeName
   */
  @javax.annotation.Nullable
  public String getServicesSecondaryRangeName() {
    return servicesSecondaryRangeName;
  }

  public void setServicesSecondaryRangeName(String servicesSecondaryRangeName) {
    this.servicesSecondaryRangeName = servicesSecondaryRangeName;
  }


  public IPAllocationPolicy stackType(StackTypeEnum stackType) {
    this.stackType = stackType;
    return this;
  }

  /**
   * The IP stack type of the cluster
   * @return stackType
   */
  @javax.annotation.Nullable
  public StackTypeEnum getStackType() {
    return stackType;
  }

  public void setStackType(StackTypeEnum stackType) {
    this.stackType = stackType;
  }


  /**
   * Output only. [Output only] The subnet&#39;s IPv6 CIDR block used by nodes and pods.
   * @return subnetIpv6CidrBlock
   */
  @javax.annotation.Nullable
  public String getSubnetIpv6CidrBlock() {
    return subnetIpv6CidrBlock;
  }



  public IPAllocationPolicy subnetworkName(String subnetworkName) {
    this.subnetworkName = subnetworkName;
    return this;
  }

  /**
   * A custom subnetwork name to be used if &#x60;create_subnetwork&#x60; is true. If this field is empty, then an automatic name will be chosen for the new subnetwork.
   * @return subnetworkName
   */
  @javax.annotation.Nullable
  public String getSubnetworkName() {
    return subnetworkName;
  }

  public void setSubnetworkName(String subnetworkName) {
    this.subnetworkName = subnetworkName;
  }


  public IPAllocationPolicy tpuIpv4CidrBlock(String tpuIpv4CidrBlock) {
    this.tpuIpv4CidrBlock = tpuIpv4CidrBlock;
    return this;
  }

  /**
   * The IP address range of the Cloud TPUs in this cluster. If unspecified, a range will be automatically chosen with the default size. This field is only applicable when &#x60;use_ip_aliases&#x60; is true. If unspecified, the range will use the default size. Set to /netmask (e.g. &#x60;/14&#x60;) to have a range chosen with a specific netmask. Set to a [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. &#x60;10.96.0.0/14&#x60;) from the RFC-1918 private networks (e.g. &#x60;10.0.0.0/8&#x60;, &#x60;172.16.0.0/12&#x60;, &#x60;192.168.0.0/16&#x60;) to pick a specific range to use.
   * @return tpuIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getTpuIpv4CidrBlock() {
    return tpuIpv4CidrBlock;
  }

  public void setTpuIpv4CidrBlock(String tpuIpv4CidrBlock) {
    this.tpuIpv4CidrBlock = tpuIpv4CidrBlock;
  }


  public IPAllocationPolicy useIpAliases(Boolean useIpAliases) {
    this.useIpAliases = useIpAliases;
    return this;
  }

  /**
   * Whether alias IPs will be used for pod IPs in the cluster. This is used in conjunction with use_routes. It cannot be true if use_routes is true. If both use_ip_aliases and use_routes are false, then the server picks the default IP allocation mode
   * @return useIpAliases
   */
  @javax.annotation.Nullable
  public Boolean getUseIpAliases() {
    return useIpAliases;
  }

  public void setUseIpAliases(Boolean useIpAliases) {
    this.useIpAliases = useIpAliases;
  }


  public IPAllocationPolicy useRoutes(Boolean useRoutes) {
    this.useRoutes = useRoutes;
    return this;
  }

  /**
   * Whether routes will be used for pod IPs in the cluster. This is used in conjunction with use_ip_aliases. It cannot be true if use_ip_aliases is true. If both use_ip_aliases and use_routes are false, then the server picks the default IP allocation mode
   * @return useRoutes
   */
  @javax.annotation.Nullable
  public Boolean getUseRoutes() {
    return useRoutes;
  }

  public void setUseRoutes(Boolean useRoutes) {
    this.useRoutes = useRoutes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IPAllocationPolicy ipAllocationPolicy = (IPAllocationPolicy) o;
    return Objects.equals(this.additionalPodRangesConfig, ipAllocationPolicy.additionalPodRangesConfig) &&
        Objects.equals(this.clusterIpv4Cidr, ipAllocationPolicy.clusterIpv4Cidr) &&
        Objects.equals(this.clusterIpv4CidrBlock, ipAllocationPolicy.clusterIpv4CidrBlock) &&
        Objects.equals(this.clusterSecondaryRangeName, ipAllocationPolicy.clusterSecondaryRangeName) &&
        Objects.equals(this.createSubnetwork, ipAllocationPolicy.createSubnetwork) &&
        Objects.equals(this.defaultPodIpv4RangeUtilization, ipAllocationPolicy.defaultPodIpv4RangeUtilization) &&
        Objects.equals(this.ipv6AccessType, ipAllocationPolicy.ipv6AccessType) &&
        Objects.equals(this.nodeIpv4Cidr, ipAllocationPolicy.nodeIpv4Cidr) &&
        Objects.equals(this.nodeIpv4CidrBlock, ipAllocationPolicy.nodeIpv4CidrBlock) &&
        Objects.equals(this.podCidrOverprovisionConfig, ipAllocationPolicy.podCidrOverprovisionConfig) &&
        Objects.equals(this.servicesIpv4Cidr, ipAllocationPolicy.servicesIpv4Cidr) &&
        Objects.equals(this.servicesIpv4CidrBlock, ipAllocationPolicy.servicesIpv4CidrBlock) &&
        Objects.equals(this.servicesIpv6CidrBlock, ipAllocationPolicy.servicesIpv6CidrBlock) &&
        Objects.equals(this.servicesSecondaryRangeName, ipAllocationPolicy.servicesSecondaryRangeName) &&
        Objects.equals(this.stackType, ipAllocationPolicy.stackType) &&
        Objects.equals(this.subnetIpv6CidrBlock, ipAllocationPolicy.subnetIpv6CidrBlock) &&
        Objects.equals(this.subnetworkName, ipAllocationPolicy.subnetworkName) &&
        Objects.equals(this.tpuIpv4CidrBlock, ipAllocationPolicy.tpuIpv4CidrBlock) &&
        Objects.equals(this.useIpAliases, ipAllocationPolicy.useIpAliases) &&
        Objects.equals(this.useRoutes, ipAllocationPolicy.useRoutes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalPodRangesConfig, clusterIpv4Cidr, clusterIpv4CidrBlock, clusterSecondaryRangeName, createSubnetwork, defaultPodIpv4RangeUtilization, ipv6AccessType, nodeIpv4Cidr, nodeIpv4CidrBlock, podCidrOverprovisionConfig, servicesIpv4Cidr, servicesIpv4CidrBlock, servicesIpv6CidrBlock, servicesSecondaryRangeName, stackType, subnetIpv6CidrBlock, subnetworkName, tpuIpv4CidrBlock, useIpAliases, useRoutes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IPAllocationPolicy {\n");
    sb.append("    additionalPodRangesConfig: ").append(toIndentedString(additionalPodRangesConfig)).append("\n");
    sb.append("    clusterIpv4Cidr: ").append(toIndentedString(clusterIpv4Cidr)).append("\n");
    sb.append("    clusterIpv4CidrBlock: ").append(toIndentedString(clusterIpv4CidrBlock)).append("\n");
    sb.append("    clusterSecondaryRangeName: ").append(toIndentedString(clusterSecondaryRangeName)).append("\n");
    sb.append("    createSubnetwork: ").append(toIndentedString(createSubnetwork)).append("\n");
    sb.append("    defaultPodIpv4RangeUtilization: ").append(toIndentedString(defaultPodIpv4RangeUtilization)).append("\n");
    sb.append("    ipv6AccessType: ").append(toIndentedString(ipv6AccessType)).append("\n");
    sb.append("    nodeIpv4Cidr: ").append(toIndentedString(nodeIpv4Cidr)).append("\n");
    sb.append("    nodeIpv4CidrBlock: ").append(toIndentedString(nodeIpv4CidrBlock)).append("\n");
    sb.append("    podCidrOverprovisionConfig: ").append(toIndentedString(podCidrOverprovisionConfig)).append("\n");
    sb.append("    servicesIpv4Cidr: ").append(toIndentedString(servicesIpv4Cidr)).append("\n");
    sb.append("    servicesIpv4CidrBlock: ").append(toIndentedString(servicesIpv4CidrBlock)).append("\n");
    sb.append("    servicesIpv6CidrBlock: ").append(toIndentedString(servicesIpv6CidrBlock)).append("\n");
    sb.append("    servicesSecondaryRangeName: ").append(toIndentedString(servicesSecondaryRangeName)).append("\n");
    sb.append("    stackType: ").append(toIndentedString(stackType)).append("\n");
    sb.append("    subnetIpv6CidrBlock: ").append(toIndentedString(subnetIpv6CidrBlock)).append("\n");
    sb.append("    subnetworkName: ").append(toIndentedString(subnetworkName)).append("\n");
    sb.append("    tpuIpv4CidrBlock: ").append(toIndentedString(tpuIpv4CidrBlock)).append("\n");
    sb.append("    useIpAliases: ").append(toIndentedString(useIpAliases)).append("\n");
    sb.append("    useRoutes: ").append(toIndentedString(useRoutes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("additionalPodRangesConfig");
    openapiFields.add("clusterIpv4Cidr");
    openapiFields.add("clusterIpv4CidrBlock");
    openapiFields.add("clusterSecondaryRangeName");
    openapiFields.add("createSubnetwork");
    openapiFields.add("defaultPodIpv4RangeUtilization");
    openapiFields.add("ipv6AccessType");
    openapiFields.add("nodeIpv4Cidr");
    openapiFields.add("nodeIpv4CidrBlock");
    openapiFields.add("podCidrOverprovisionConfig");
    openapiFields.add("servicesIpv4Cidr");
    openapiFields.add("servicesIpv4CidrBlock");
    openapiFields.add("servicesIpv6CidrBlock");
    openapiFields.add("servicesSecondaryRangeName");
    openapiFields.add("stackType");
    openapiFields.add("subnetIpv6CidrBlock");
    openapiFields.add("subnetworkName");
    openapiFields.add("tpuIpv4CidrBlock");
    openapiFields.add("useIpAliases");
    openapiFields.add("useRoutes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IPAllocationPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IPAllocationPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IPAllocationPolicy is not found in the empty JSON string", IPAllocationPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IPAllocationPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IPAllocationPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `additionalPodRangesConfig`
      if (jsonObj.get("additionalPodRangesConfig") != null && !jsonObj.get("additionalPodRangesConfig").isJsonNull()) {
        AdditionalPodRangesConfig.validateJsonElement(jsonObj.get("additionalPodRangesConfig"));
      }
      if ((jsonObj.get("clusterIpv4Cidr") != null && !jsonObj.get("clusterIpv4Cidr").isJsonNull()) && !jsonObj.get("clusterIpv4Cidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterIpv4Cidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterIpv4Cidr").toString()));
      }
      if ((jsonObj.get("clusterIpv4CidrBlock") != null && !jsonObj.get("clusterIpv4CidrBlock").isJsonNull()) && !jsonObj.get("clusterIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterIpv4CidrBlock").toString()));
      }
      if ((jsonObj.get("clusterSecondaryRangeName") != null && !jsonObj.get("clusterSecondaryRangeName").isJsonNull()) && !jsonObj.get("clusterSecondaryRangeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterSecondaryRangeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterSecondaryRangeName").toString()));
      }
      if ((jsonObj.get("ipv6AccessType") != null && !jsonObj.get("ipv6AccessType").isJsonNull()) && !jsonObj.get("ipv6AccessType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipv6AccessType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipv6AccessType").toString()));
      }
      // validate the optional field `ipv6AccessType`
      if (jsonObj.get("ipv6AccessType") != null && !jsonObj.get("ipv6AccessType").isJsonNull()) {
        Ipv6AccessTypeEnum.validateJsonElement(jsonObj.get("ipv6AccessType"));
      }
      if ((jsonObj.get("nodeIpv4Cidr") != null && !jsonObj.get("nodeIpv4Cidr").isJsonNull()) && !jsonObj.get("nodeIpv4Cidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeIpv4Cidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeIpv4Cidr").toString()));
      }
      if ((jsonObj.get("nodeIpv4CidrBlock") != null && !jsonObj.get("nodeIpv4CidrBlock").isJsonNull()) && !jsonObj.get("nodeIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeIpv4CidrBlock").toString()));
      }
      // validate the optional field `podCidrOverprovisionConfig`
      if (jsonObj.get("podCidrOverprovisionConfig") != null && !jsonObj.get("podCidrOverprovisionConfig").isJsonNull()) {
        PodCIDROverprovisionConfig.validateJsonElement(jsonObj.get("podCidrOverprovisionConfig"));
      }
      if ((jsonObj.get("servicesIpv4Cidr") != null && !jsonObj.get("servicesIpv4Cidr").isJsonNull()) && !jsonObj.get("servicesIpv4Cidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `servicesIpv4Cidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("servicesIpv4Cidr").toString()));
      }
      if ((jsonObj.get("servicesIpv4CidrBlock") != null && !jsonObj.get("servicesIpv4CidrBlock").isJsonNull()) && !jsonObj.get("servicesIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `servicesIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("servicesIpv4CidrBlock").toString()));
      }
      if ((jsonObj.get("servicesIpv6CidrBlock") != null && !jsonObj.get("servicesIpv6CidrBlock").isJsonNull()) && !jsonObj.get("servicesIpv6CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `servicesIpv6CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("servicesIpv6CidrBlock").toString()));
      }
      if ((jsonObj.get("servicesSecondaryRangeName") != null && !jsonObj.get("servicesSecondaryRangeName").isJsonNull()) && !jsonObj.get("servicesSecondaryRangeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `servicesSecondaryRangeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("servicesSecondaryRangeName").toString()));
      }
      if ((jsonObj.get("stackType") != null && !jsonObj.get("stackType").isJsonNull()) && !jsonObj.get("stackType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stackType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stackType").toString()));
      }
      // validate the optional field `stackType`
      if (jsonObj.get("stackType") != null && !jsonObj.get("stackType").isJsonNull()) {
        StackTypeEnum.validateJsonElement(jsonObj.get("stackType"));
      }
      if ((jsonObj.get("subnetIpv6CidrBlock") != null && !jsonObj.get("subnetIpv6CidrBlock").isJsonNull()) && !jsonObj.get("subnetIpv6CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetIpv6CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetIpv6CidrBlock").toString()));
      }
      if ((jsonObj.get("subnetworkName") != null && !jsonObj.get("subnetworkName").isJsonNull()) && !jsonObj.get("subnetworkName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetworkName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetworkName").toString()));
      }
      if ((jsonObj.get("tpuIpv4CidrBlock") != null && !jsonObj.get("tpuIpv4CidrBlock").isJsonNull()) && !jsonObj.get("tpuIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tpuIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tpuIpv4CidrBlock").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IPAllocationPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IPAllocationPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IPAllocationPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IPAllocationPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<IPAllocationPolicy>() {
           @Override
           public void write(JsonWriter out, IPAllocationPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IPAllocationPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IPAllocationPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IPAllocationPolicy
   * @throws IOException if the JSON string is invalid with respect to IPAllocationPolicy
   */
  public static IPAllocationPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IPAllocationPolicy.class);
  }

  /**
   * Convert an instance of IPAllocationPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

