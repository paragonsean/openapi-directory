/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ClusterNetworkPerformanceConfig;
import org.openapitools.client.model.DNSConfig;
import org.openapitools.client.model.DefaultSnatStatus;
import org.openapitools.client.model.GatewayAPIConfig;
import org.openapitools.client.model.ServiceExternalIPsConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NetworkConfig reports the relative names of network &amp; subnetwork.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NetworkConfig {
  /**
   * The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
   */
  @JsonAdapter(DatapathProviderEnum.Adapter.class)
  public enum DatapathProviderEnum {
    DATAPATH_PROVIDER_UNSPECIFIED("DATAPATH_PROVIDER_UNSPECIFIED"),
    
    LEGACY_DATAPATH("LEGACY_DATAPATH"),
    
    ADVANCED_DATAPATH("ADVANCED_DATAPATH");

    private String value;

    DatapathProviderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DatapathProviderEnum fromValue(String value) {
      for (DatapathProviderEnum b : DatapathProviderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DatapathProviderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DatapathProviderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DatapathProviderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DatapathProviderEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DatapathProviderEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATAPATH_PROVIDER = "datapathProvider";
  @SerializedName(SERIALIZED_NAME_DATAPATH_PROVIDER)
  private DatapathProviderEnum datapathProvider;

  public static final String SERIALIZED_NAME_DEFAULT_SNAT_STATUS = "defaultSnatStatus";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SNAT_STATUS)
  private DefaultSnatStatus defaultSnatStatus;

  public static final String SERIALIZED_NAME_DNS_CONFIG = "dnsConfig";
  @SerializedName(SERIALIZED_NAME_DNS_CONFIG)
  private DNSConfig dnsConfig;

  public static final String SERIALIZED_NAME_ENABLE_FQDN_NETWORK_POLICY = "enableFqdnNetworkPolicy";
  @SerializedName(SERIALIZED_NAME_ENABLE_FQDN_NETWORK_POLICY)
  private Boolean enableFqdnNetworkPolicy;

  public static final String SERIALIZED_NAME_ENABLE_INTRA_NODE_VISIBILITY = "enableIntraNodeVisibility";
  @SerializedName(SERIALIZED_NAME_ENABLE_INTRA_NODE_VISIBILITY)
  private Boolean enableIntraNodeVisibility;

  public static final String SERIALIZED_NAME_ENABLE_L4ILB_SUBSETTING = "enableL4ilbSubsetting";
  @SerializedName(SERIALIZED_NAME_ENABLE_L4ILB_SUBSETTING)
  private Boolean enableL4ilbSubsetting;

  public static final String SERIALIZED_NAME_ENABLE_MULTI_NETWORKING = "enableMultiNetworking";
  @SerializedName(SERIALIZED_NAME_ENABLE_MULTI_NETWORKING)
  private Boolean enableMultiNetworking;

  public static final String SERIALIZED_NAME_GATEWAY_API_CONFIG = "gatewayApiConfig";
  @SerializedName(SERIALIZED_NAME_GATEWAY_API_CONFIG)
  private GatewayAPIConfig gatewayApiConfig;

  /**
   * Specify the details of in-transit encryption.
   */
  @JsonAdapter(InTransitEncryptionConfigEnum.Adapter.class)
  public enum InTransitEncryptionConfigEnum {
    CONFIG_UNSPECIFIED("IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED"),
    
    DISABLED("IN_TRANSIT_ENCRYPTION_DISABLED"),
    
    INTER_NODE_TRANSPARENT("IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT");

    private String value;

    InTransitEncryptionConfigEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InTransitEncryptionConfigEnum fromValue(String value) {
      for (InTransitEncryptionConfigEnum b : InTransitEncryptionConfigEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InTransitEncryptionConfigEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InTransitEncryptionConfigEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InTransitEncryptionConfigEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InTransitEncryptionConfigEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InTransitEncryptionConfigEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IN_TRANSIT_ENCRYPTION_CONFIG = "inTransitEncryptionConfig";
  @SerializedName(SERIALIZED_NAME_IN_TRANSIT_ENCRYPTION_CONFIG)
  private InTransitEncryptionConfigEnum inTransitEncryptionConfig;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_NETWORK_PERFORMANCE_CONFIG = "networkPerformanceConfig";
  @SerializedName(SERIALIZED_NAME_NETWORK_PERFORMANCE_CONFIG)
  private ClusterNetworkPerformanceConfig networkPerformanceConfig;

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4)
   */
  @JsonAdapter(PrivateIpv6GoogleAccessEnum.Adapter.class)
  public enum PrivateIpv6GoogleAccessEnum {
    UNSPECIFIED("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED"),
    
    DISABLED("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED"),
    
    TO_GOOGLE("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE"),
    
    BIDIRECTIONAL("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

    private String value;

    PrivateIpv6GoogleAccessEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PrivateIpv6GoogleAccessEnum fromValue(String value) {
      for (PrivateIpv6GoogleAccessEnum b : PrivateIpv6GoogleAccessEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PrivateIpv6GoogleAccessEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PrivateIpv6GoogleAccessEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PrivateIpv6GoogleAccessEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PrivateIpv6GoogleAccessEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PrivateIpv6GoogleAccessEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS = "privateIpv6GoogleAccess";
  @SerializedName(SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS)
  private PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess;

  public static final String SERIALIZED_NAME_SERVICE_EXTERNAL_IPS_CONFIG = "serviceExternalIpsConfig";
  @SerializedName(SERIALIZED_NAME_SERVICE_EXTERNAL_IPS_CONFIG)
  private ServiceExternalIPsConfig serviceExternalIpsConfig;

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public NetworkConfig() {
  }

  public NetworkConfig datapathProvider(DatapathProviderEnum datapathProvider) {
    this.datapathProvider = datapathProvider;
    return this;
  }

  /**
   * The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
   * @return datapathProvider
   */
  @javax.annotation.Nullable
  public DatapathProviderEnum getDatapathProvider() {
    return datapathProvider;
  }

  public void setDatapathProvider(DatapathProviderEnum datapathProvider) {
    this.datapathProvider = datapathProvider;
  }


  public NetworkConfig defaultSnatStatus(DefaultSnatStatus defaultSnatStatus) {
    this.defaultSnatStatus = defaultSnatStatus;
    return this;
  }

  /**
   * Get defaultSnatStatus
   * @return defaultSnatStatus
   */
  @javax.annotation.Nullable
  public DefaultSnatStatus getDefaultSnatStatus() {
    return defaultSnatStatus;
  }

  public void setDefaultSnatStatus(DefaultSnatStatus defaultSnatStatus) {
    this.defaultSnatStatus = defaultSnatStatus;
  }


  public NetworkConfig dnsConfig(DNSConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
    return this;
  }

  /**
   * Get dnsConfig
   * @return dnsConfig
   */
  @javax.annotation.Nullable
  public DNSConfig getDnsConfig() {
    return dnsConfig;
  }

  public void setDnsConfig(DNSConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
  }


  public NetworkConfig enableFqdnNetworkPolicy(Boolean enableFqdnNetworkPolicy) {
    this.enableFqdnNetworkPolicy = enableFqdnNetworkPolicy;
    return this;
  }

  /**
   * Whether FQDN Network Policy is enabled on this cluster.
   * @return enableFqdnNetworkPolicy
   */
  @javax.annotation.Nullable
  public Boolean getEnableFqdnNetworkPolicy() {
    return enableFqdnNetworkPolicy;
  }

  public void setEnableFqdnNetworkPolicy(Boolean enableFqdnNetworkPolicy) {
    this.enableFqdnNetworkPolicy = enableFqdnNetworkPolicy;
  }


  public NetworkConfig enableIntraNodeVisibility(Boolean enableIntraNodeVisibility) {
    this.enableIntraNodeVisibility = enableIntraNodeVisibility;
    return this;
  }

  /**
   * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
   * @return enableIntraNodeVisibility
   */
  @javax.annotation.Nullable
  public Boolean getEnableIntraNodeVisibility() {
    return enableIntraNodeVisibility;
  }

  public void setEnableIntraNodeVisibility(Boolean enableIntraNodeVisibility) {
    this.enableIntraNodeVisibility = enableIntraNodeVisibility;
  }


  public NetworkConfig enableL4ilbSubsetting(Boolean enableL4ilbSubsetting) {
    this.enableL4ilbSubsetting = enableL4ilbSubsetting;
    return this;
  }

  /**
   * Whether L4ILB Subsetting is enabled for this cluster.
   * @return enableL4ilbSubsetting
   */
  @javax.annotation.Nullable
  public Boolean getEnableL4ilbSubsetting() {
    return enableL4ilbSubsetting;
  }

  public void setEnableL4ilbSubsetting(Boolean enableL4ilbSubsetting) {
    this.enableL4ilbSubsetting = enableL4ilbSubsetting;
  }


  public NetworkConfig enableMultiNetworking(Boolean enableMultiNetworking) {
    this.enableMultiNetworking = enableMultiNetworking;
    return this;
  }

  /**
   * Whether multi-networking is enabled for this cluster.
   * @return enableMultiNetworking
   */
  @javax.annotation.Nullable
  public Boolean getEnableMultiNetworking() {
    return enableMultiNetworking;
  }

  public void setEnableMultiNetworking(Boolean enableMultiNetworking) {
    this.enableMultiNetworking = enableMultiNetworking;
  }


  public NetworkConfig gatewayApiConfig(GatewayAPIConfig gatewayApiConfig) {
    this.gatewayApiConfig = gatewayApiConfig;
    return this;
  }

  /**
   * Get gatewayApiConfig
   * @return gatewayApiConfig
   */
  @javax.annotation.Nullable
  public GatewayAPIConfig getGatewayApiConfig() {
    return gatewayApiConfig;
  }

  public void setGatewayApiConfig(GatewayAPIConfig gatewayApiConfig) {
    this.gatewayApiConfig = gatewayApiConfig;
  }


  public NetworkConfig inTransitEncryptionConfig(InTransitEncryptionConfigEnum inTransitEncryptionConfig) {
    this.inTransitEncryptionConfig = inTransitEncryptionConfig;
    return this;
  }

  /**
   * Specify the details of in-transit encryption.
   * @return inTransitEncryptionConfig
   */
  @javax.annotation.Nullable
  public InTransitEncryptionConfigEnum getInTransitEncryptionConfig() {
    return inTransitEncryptionConfig;
  }

  public void setInTransitEncryptionConfig(InTransitEncryptionConfigEnum inTransitEncryptionConfig) {
    this.inTransitEncryptionConfig = inTransitEncryptionConfig;
  }


  public NetworkConfig network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Output only. The relative name of the Google Compute Engine network(https://cloud.google.com/compute/docs/networks-and-firewalls#networks) to which the cluster is connected. Example: projects/my-project/global/networks/my-network
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public NetworkConfig networkPerformanceConfig(ClusterNetworkPerformanceConfig networkPerformanceConfig) {
    this.networkPerformanceConfig = networkPerformanceConfig;
    return this;
  }

  /**
   * Get networkPerformanceConfig
   * @return networkPerformanceConfig
   */
  @javax.annotation.Nullable
  public ClusterNetworkPerformanceConfig getNetworkPerformanceConfig() {
    return networkPerformanceConfig;
  }

  public void setNetworkPerformanceConfig(ClusterNetworkPerformanceConfig networkPerformanceConfig) {
    this.networkPerformanceConfig = networkPerformanceConfig;
  }


  public NetworkConfig privateIpv6GoogleAccess(PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
    return this;
  }

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4)
   * @return privateIpv6GoogleAccess
   */
  @javax.annotation.Nullable
  public PrivateIpv6GoogleAccessEnum getPrivateIpv6GoogleAccess() {
    return privateIpv6GoogleAccess;
  }

  public void setPrivateIpv6GoogleAccess(PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
  }


  public NetworkConfig serviceExternalIpsConfig(ServiceExternalIPsConfig serviceExternalIpsConfig) {
    this.serviceExternalIpsConfig = serviceExternalIpsConfig;
    return this;
  }

  /**
   * Get serviceExternalIpsConfig
   * @return serviceExternalIpsConfig
   */
  @javax.annotation.Nullable
  public ServiceExternalIPsConfig getServiceExternalIpsConfig() {
    return serviceExternalIpsConfig;
  }

  public void setServiceExternalIpsConfig(ServiceExternalIPsConfig serviceExternalIpsConfig) {
    this.serviceExternalIpsConfig = serviceExternalIpsConfig;
  }


  public NetworkConfig subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Output only. The relative name of the Google Compute Engine [subnetwork](https://cloud.google.com/compute/docs/vpc) to which the cluster is connected. Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NetworkConfig networkConfig = (NetworkConfig) o;
    return Objects.equals(this.datapathProvider, networkConfig.datapathProvider) &&
        Objects.equals(this.defaultSnatStatus, networkConfig.defaultSnatStatus) &&
        Objects.equals(this.dnsConfig, networkConfig.dnsConfig) &&
        Objects.equals(this.enableFqdnNetworkPolicy, networkConfig.enableFqdnNetworkPolicy) &&
        Objects.equals(this.enableIntraNodeVisibility, networkConfig.enableIntraNodeVisibility) &&
        Objects.equals(this.enableL4ilbSubsetting, networkConfig.enableL4ilbSubsetting) &&
        Objects.equals(this.enableMultiNetworking, networkConfig.enableMultiNetworking) &&
        Objects.equals(this.gatewayApiConfig, networkConfig.gatewayApiConfig) &&
        Objects.equals(this.inTransitEncryptionConfig, networkConfig.inTransitEncryptionConfig) &&
        Objects.equals(this.network, networkConfig.network) &&
        Objects.equals(this.networkPerformanceConfig, networkConfig.networkPerformanceConfig) &&
        Objects.equals(this.privateIpv6GoogleAccess, networkConfig.privateIpv6GoogleAccess) &&
        Objects.equals(this.serviceExternalIpsConfig, networkConfig.serviceExternalIpsConfig) &&
        Objects.equals(this.subnetwork, networkConfig.subnetwork);
  }

  @Override
  public int hashCode() {
    return Objects.hash(datapathProvider, defaultSnatStatus, dnsConfig, enableFqdnNetworkPolicy, enableIntraNodeVisibility, enableL4ilbSubsetting, enableMultiNetworking, gatewayApiConfig, inTransitEncryptionConfig, network, networkPerformanceConfig, privateIpv6GoogleAccess, serviceExternalIpsConfig, subnetwork);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NetworkConfig {\n");
    sb.append("    datapathProvider: ").append(toIndentedString(datapathProvider)).append("\n");
    sb.append("    defaultSnatStatus: ").append(toIndentedString(defaultSnatStatus)).append("\n");
    sb.append("    dnsConfig: ").append(toIndentedString(dnsConfig)).append("\n");
    sb.append("    enableFqdnNetworkPolicy: ").append(toIndentedString(enableFqdnNetworkPolicy)).append("\n");
    sb.append("    enableIntraNodeVisibility: ").append(toIndentedString(enableIntraNodeVisibility)).append("\n");
    sb.append("    enableL4ilbSubsetting: ").append(toIndentedString(enableL4ilbSubsetting)).append("\n");
    sb.append("    enableMultiNetworking: ").append(toIndentedString(enableMultiNetworking)).append("\n");
    sb.append("    gatewayApiConfig: ").append(toIndentedString(gatewayApiConfig)).append("\n");
    sb.append("    inTransitEncryptionConfig: ").append(toIndentedString(inTransitEncryptionConfig)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    networkPerformanceConfig: ").append(toIndentedString(networkPerformanceConfig)).append("\n");
    sb.append("    privateIpv6GoogleAccess: ").append(toIndentedString(privateIpv6GoogleAccess)).append("\n");
    sb.append("    serviceExternalIpsConfig: ").append(toIndentedString(serviceExternalIpsConfig)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("datapathProvider");
    openapiFields.add("defaultSnatStatus");
    openapiFields.add("dnsConfig");
    openapiFields.add("enableFqdnNetworkPolicy");
    openapiFields.add("enableIntraNodeVisibility");
    openapiFields.add("enableL4ilbSubsetting");
    openapiFields.add("enableMultiNetworking");
    openapiFields.add("gatewayApiConfig");
    openapiFields.add("inTransitEncryptionConfig");
    openapiFields.add("network");
    openapiFields.add("networkPerformanceConfig");
    openapiFields.add("privateIpv6GoogleAccess");
    openapiFields.add("serviceExternalIpsConfig");
    openapiFields.add("subnetwork");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NetworkConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NetworkConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NetworkConfig is not found in the empty JSON string", NetworkConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NetworkConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NetworkConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("datapathProvider") != null && !jsonObj.get("datapathProvider").isJsonNull()) && !jsonObj.get("datapathProvider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `datapathProvider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("datapathProvider").toString()));
      }
      // validate the optional field `datapathProvider`
      if (jsonObj.get("datapathProvider") != null && !jsonObj.get("datapathProvider").isJsonNull()) {
        DatapathProviderEnum.validateJsonElement(jsonObj.get("datapathProvider"));
      }
      // validate the optional field `defaultSnatStatus`
      if (jsonObj.get("defaultSnatStatus") != null && !jsonObj.get("defaultSnatStatus").isJsonNull()) {
        DefaultSnatStatus.validateJsonElement(jsonObj.get("defaultSnatStatus"));
      }
      // validate the optional field `dnsConfig`
      if (jsonObj.get("dnsConfig") != null && !jsonObj.get("dnsConfig").isJsonNull()) {
        DNSConfig.validateJsonElement(jsonObj.get("dnsConfig"));
      }
      // validate the optional field `gatewayApiConfig`
      if (jsonObj.get("gatewayApiConfig") != null && !jsonObj.get("gatewayApiConfig").isJsonNull()) {
        GatewayAPIConfig.validateJsonElement(jsonObj.get("gatewayApiConfig"));
      }
      if ((jsonObj.get("inTransitEncryptionConfig") != null && !jsonObj.get("inTransitEncryptionConfig").isJsonNull()) && !jsonObj.get("inTransitEncryptionConfig").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inTransitEncryptionConfig` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inTransitEncryptionConfig").toString()));
      }
      // validate the optional field `inTransitEncryptionConfig`
      if (jsonObj.get("inTransitEncryptionConfig") != null && !jsonObj.get("inTransitEncryptionConfig").isJsonNull()) {
        InTransitEncryptionConfigEnum.validateJsonElement(jsonObj.get("inTransitEncryptionConfig"));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      // validate the optional field `networkPerformanceConfig`
      if (jsonObj.get("networkPerformanceConfig") != null && !jsonObj.get("networkPerformanceConfig").isJsonNull()) {
        ClusterNetworkPerformanceConfig.validateJsonElement(jsonObj.get("networkPerformanceConfig"));
      }
      if ((jsonObj.get("privateIpv6GoogleAccess") != null && !jsonObj.get("privateIpv6GoogleAccess").isJsonNull()) && !jsonObj.get("privateIpv6GoogleAccess").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `privateIpv6GoogleAccess` to be a primitive type in the JSON string but got `%s`", jsonObj.get("privateIpv6GoogleAccess").toString()));
      }
      // validate the optional field `privateIpv6GoogleAccess`
      if (jsonObj.get("privateIpv6GoogleAccess") != null && !jsonObj.get("privateIpv6GoogleAccess").isJsonNull()) {
        PrivateIpv6GoogleAccessEnum.validateJsonElement(jsonObj.get("privateIpv6GoogleAccess"));
      }
      // validate the optional field `serviceExternalIpsConfig`
      if (jsonObj.get("serviceExternalIpsConfig") != null && !jsonObj.get("serviceExternalIpsConfig").isJsonNull()) {
        ServiceExternalIPsConfig.validateJsonElement(jsonObj.get("serviceExternalIpsConfig"));
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NetworkConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NetworkConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NetworkConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NetworkConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<NetworkConfig>() {
           @Override
           public void write(JsonWriter out, NetworkConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NetworkConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NetworkConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NetworkConfig
   * @throws IOException if the JSON string is invalid with respect to NetworkConfig
   */
  public static NetworkConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NetworkConfig.class);
  }

  /**
   * Convert an instance of NetworkConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

