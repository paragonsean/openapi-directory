/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SecurityBulletinEvent is a notification sent to customers when a security bulletin has been posted that they are vulnerable to.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SecurityBulletinEvent {
  public static final String SERIALIZED_NAME_AFFECTED_SUPPORTED_MINORS = "affectedSupportedMinors";
  @SerializedName(SERIALIZED_NAME_AFFECTED_SUPPORTED_MINORS)
  private List<String> affectedSupportedMinors = new ArrayList<>();

  public static final String SERIALIZED_NAME_BRIEF_DESCRIPTION = "briefDescription";
  @SerializedName(SERIALIZED_NAME_BRIEF_DESCRIPTION)
  private String briefDescription;

  public static final String SERIALIZED_NAME_BULLETIN_ID = "bulletinId";
  @SerializedName(SERIALIZED_NAME_BULLETIN_ID)
  private String bulletinId;

  public static final String SERIALIZED_NAME_BULLETIN_URI = "bulletinUri";
  @SerializedName(SERIALIZED_NAME_BULLETIN_URI)
  private String bulletinUri;

  public static final String SERIALIZED_NAME_CVE_IDS = "cveIds";
  @SerializedName(SERIALIZED_NAME_CVE_IDS)
  private List<String> cveIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_MANUAL_STEPS_REQUIRED = "manualStepsRequired";
  @SerializedName(SERIALIZED_NAME_MANUAL_STEPS_REQUIRED)
  private Boolean manualStepsRequired;

  public static final String SERIALIZED_NAME_PATCHED_VERSIONS = "patchedVersions";
  @SerializedName(SERIALIZED_NAME_PATCHED_VERSIONS)
  private List<String> patchedVersions = new ArrayList<>();

  public static final String SERIALIZED_NAME_RESOURCE_TYPE_AFFECTED = "resourceTypeAffected";
  @SerializedName(SERIALIZED_NAME_RESOURCE_TYPE_AFFECTED)
  private String resourceTypeAffected;

  public static final String SERIALIZED_NAME_SEVERITY = "severity";
  @SerializedName(SERIALIZED_NAME_SEVERITY)
  private String severity;

  public static final String SERIALIZED_NAME_SUGGESTED_UPGRADE_TARGET = "suggestedUpgradeTarget";
  @SerializedName(SERIALIZED_NAME_SUGGESTED_UPGRADE_TARGET)
  private String suggestedUpgradeTarget;

  public SecurityBulletinEvent() {
  }

  public SecurityBulletinEvent affectedSupportedMinors(List<String> affectedSupportedMinors) {
    this.affectedSupportedMinors = affectedSupportedMinors;
    return this;
  }

  public SecurityBulletinEvent addAffectedSupportedMinorsItem(String affectedSupportedMinorsItem) {
    if (this.affectedSupportedMinors == null) {
      this.affectedSupportedMinors = new ArrayList<>();
    }
    this.affectedSupportedMinors.add(affectedSupportedMinorsItem);
    return this;
  }

  /**
   * The GKE minor versions affected by this vulnerability.
   * @return affectedSupportedMinors
   */
  @javax.annotation.Nullable
  public List<String> getAffectedSupportedMinors() {
    return affectedSupportedMinors;
  }

  public void setAffectedSupportedMinors(List<String> affectedSupportedMinors) {
    this.affectedSupportedMinors = affectedSupportedMinors;
  }


  public SecurityBulletinEvent briefDescription(String briefDescription) {
    this.briefDescription = briefDescription;
    return this;
  }

  /**
   * A brief description of the bulletin. See the bulletin pointed to by the bulletin_uri field for an expanded description.
   * @return briefDescription
   */
  @javax.annotation.Nullable
  public String getBriefDescription() {
    return briefDescription;
  }

  public void setBriefDescription(String briefDescription) {
    this.briefDescription = briefDescription;
  }


  public SecurityBulletinEvent bulletinId(String bulletinId) {
    this.bulletinId = bulletinId;
    return this;
  }

  /**
   * The ID of the bulletin corresponding to the vulnerability.
   * @return bulletinId
   */
  @javax.annotation.Nullable
  public String getBulletinId() {
    return bulletinId;
  }

  public void setBulletinId(String bulletinId) {
    this.bulletinId = bulletinId;
  }


  public SecurityBulletinEvent bulletinUri(String bulletinUri) {
    this.bulletinUri = bulletinUri;
    return this;
  }

  /**
   * The URI link to the bulletin on the website for more information.
   * @return bulletinUri
   */
  @javax.annotation.Nullable
  public String getBulletinUri() {
    return bulletinUri;
  }

  public void setBulletinUri(String bulletinUri) {
    this.bulletinUri = bulletinUri;
  }


  public SecurityBulletinEvent cveIds(List<String> cveIds) {
    this.cveIds = cveIds;
    return this;
  }

  public SecurityBulletinEvent addCveIdsItem(String cveIdsItem) {
    if (this.cveIds == null) {
      this.cveIds = new ArrayList<>();
    }
    this.cveIds.add(cveIdsItem);
    return this;
  }

  /**
   * The CVEs associated with this bulletin.
   * @return cveIds
   */
  @javax.annotation.Nullable
  public List<String> getCveIds() {
    return cveIds;
  }

  public void setCveIds(List<String> cveIds) {
    this.cveIds = cveIds;
  }


  public SecurityBulletinEvent manualStepsRequired(Boolean manualStepsRequired) {
    this.manualStepsRequired = manualStepsRequired;
    return this;
  }

  /**
   * If this field is specified, it means there are manual steps that the user must take to make their clusters safe.
   * @return manualStepsRequired
   */
  @javax.annotation.Nullable
  public Boolean getManualStepsRequired() {
    return manualStepsRequired;
  }

  public void setManualStepsRequired(Boolean manualStepsRequired) {
    this.manualStepsRequired = manualStepsRequired;
  }


  public SecurityBulletinEvent patchedVersions(List<String> patchedVersions) {
    this.patchedVersions = patchedVersions;
    return this;
  }

  public SecurityBulletinEvent addPatchedVersionsItem(String patchedVersionsItem) {
    if (this.patchedVersions == null) {
      this.patchedVersions = new ArrayList<>();
    }
    this.patchedVersions.add(patchedVersionsItem);
    return this;
  }

  /**
   * The GKE versions where this vulnerability is patched.
   * @return patchedVersions
   */
  @javax.annotation.Nullable
  public List<String> getPatchedVersions() {
    return patchedVersions;
  }

  public void setPatchedVersions(List<String> patchedVersions) {
    this.patchedVersions = patchedVersions;
  }


  public SecurityBulletinEvent resourceTypeAffected(String resourceTypeAffected) {
    this.resourceTypeAffected = resourceTypeAffected;
    return this;
  }

  /**
   * The resource type (node/control plane) that has the vulnerability. Multiple notifications (1 notification per resource type) will be sent for a vulnerability that affects &gt; 1 resource type.
   * @return resourceTypeAffected
   */
  @javax.annotation.Nullable
  public String getResourceTypeAffected() {
    return resourceTypeAffected;
  }

  public void setResourceTypeAffected(String resourceTypeAffected) {
    this.resourceTypeAffected = resourceTypeAffected;
  }


  public SecurityBulletinEvent severity(String severity) {
    this.severity = severity;
    return this;
  }

  /**
   * The severity of this bulletin as it relates to GKE.
   * @return severity
   */
  @javax.annotation.Nullable
  public String getSeverity() {
    return severity;
  }

  public void setSeverity(String severity) {
    this.severity = severity;
  }


  public SecurityBulletinEvent suggestedUpgradeTarget(String suggestedUpgradeTarget) {
    this.suggestedUpgradeTarget = suggestedUpgradeTarget;
    return this;
  }

  /**
   * This represents a version selected from the patched_versions field that the cluster receiving this notification should most likely want to upgrade to based on its current version. Note that if this notification is being received by a given cluster, it means that this version is currently available as an upgrade target in that cluster&#39;s location.
   * @return suggestedUpgradeTarget
   */
  @javax.annotation.Nullable
  public String getSuggestedUpgradeTarget() {
    return suggestedUpgradeTarget;
  }

  public void setSuggestedUpgradeTarget(String suggestedUpgradeTarget) {
    this.suggestedUpgradeTarget = suggestedUpgradeTarget;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SecurityBulletinEvent securityBulletinEvent = (SecurityBulletinEvent) o;
    return Objects.equals(this.affectedSupportedMinors, securityBulletinEvent.affectedSupportedMinors) &&
        Objects.equals(this.briefDescription, securityBulletinEvent.briefDescription) &&
        Objects.equals(this.bulletinId, securityBulletinEvent.bulletinId) &&
        Objects.equals(this.bulletinUri, securityBulletinEvent.bulletinUri) &&
        Objects.equals(this.cveIds, securityBulletinEvent.cveIds) &&
        Objects.equals(this.manualStepsRequired, securityBulletinEvent.manualStepsRequired) &&
        Objects.equals(this.patchedVersions, securityBulletinEvent.patchedVersions) &&
        Objects.equals(this.resourceTypeAffected, securityBulletinEvent.resourceTypeAffected) &&
        Objects.equals(this.severity, securityBulletinEvent.severity) &&
        Objects.equals(this.suggestedUpgradeTarget, securityBulletinEvent.suggestedUpgradeTarget);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affectedSupportedMinors, briefDescription, bulletinId, bulletinUri, cveIds, manualStepsRequired, patchedVersions, resourceTypeAffected, severity, suggestedUpgradeTarget);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SecurityBulletinEvent {\n");
    sb.append("    affectedSupportedMinors: ").append(toIndentedString(affectedSupportedMinors)).append("\n");
    sb.append("    briefDescription: ").append(toIndentedString(briefDescription)).append("\n");
    sb.append("    bulletinId: ").append(toIndentedString(bulletinId)).append("\n");
    sb.append("    bulletinUri: ").append(toIndentedString(bulletinUri)).append("\n");
    sb.append("    cveIds: ").append(toIndentedString(cveIds)).append("\n");
    sb.append("    manualStepsRequired: ").append(toIndentedString(manualStepsRequired)).append("\n");
    sb.append("    patchedVersions: ").append(toIndentedString(patchedVersions)).append("\n");
    sb.append("    resourceTypeAffected: ").append(toIndentedString(resourceTypeAffected)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    suggestedUpgradeTarget: ").append(toIndentedString(suggestedUpgradeTarget)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("affectedSupportedMinors");
    openapiFields.add("briefDescription");
    openapiFields.add("bulletinId");
    openapiFields.add("bulletinUri");
    openapiFields.add("cveIds");
    openapiFields.add("manualStepsRequired");
    openapiFields.add("patchedVersions");
    openapiFields.add("resourceTypeAffected");
    openapiFields.add("severity");
    openapiFields.add("suggestedUpgradeTarget");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SecurityBulletinEvent
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SecurityBulletinEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SecurityBulletinEvent is not found in the empty JSON string", SecurityBulletinEvent.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SecurityBulletinEvent.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SecurityBulletinEvent` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("affectedSupportedMinors") != null && !jsonObj.get("affectedSupportedMinors").isJsonNull() && !jsonObj.get("affectedSupportedMinors").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `affectedSupportedMinors` to be an array in the JSON string but got `%s`", jsonObj.get("affectedSupportedMinors").toString()));
      }
      if ((jsonObj.get("briefDescription") != null && !jsonObj.get("briefDescription").isJsonNull()) && !jsonObj.get("briefDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `briefDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("briefDescription").toString()));
      }
      if ((jsonObj.get("bulletinId") != null && !jsonObj.get("bulletinId").isJsonNull()) && !jsonObj.get("bulletinId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bulletinId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bulletinId").toString()));
      }
      if ((jsonObj.get("bulletinUri") != null && !jsonObj.get("bulletinUri").isJsonNull()) && !jsonObj.get("bulletinUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bulletinUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bulletinUri").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("cveIds") != null && !jsonObj.get("cveIds").isJsonNull() && !jsonObj.get("cveIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cveIds` to be an array in the JSON string but got `%s`", jsonObj.get("cveIds").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("patchedVersions") != null && !jsonObj.get("patchedVersions").isJsonNull() && !jsonObj.get("patchedVersions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `patchedVersions` to be an array in the JSON string but got `%s`", jsonObj.get("patchedVersions").toString()));
      }
      if ((jsonObj.get("resourceTypeAffected") != null && !jsonObj.get("resourceTypeAffected").isJsonNull()) && !jsonObj.get("resourceTypeAffected").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resourceTypeAffected` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resourceTypeAffected").toString()));
      }
      if ((jsonObj.get("severity") != null && !jsonObj.get("severity").isJsonNull()) && !jsonObj.get("severity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `severity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("severity").toString()));
      }
      if ((jsonObj.get("suggestedUpgradeTarget") != null && !jsonObj.get("suggestedUpgradeTarget").isJsonNull()) && !jsonObj.get("suggestedUpgradeTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suggestedUpgradeTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suggestedUpgradeTarget").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SecurityBulletinEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SecurityBulletinEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SecurityBulletinEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SecurityBulletinEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<SecurityBulletinEvent>() {
           @Override
           public void write(JsonWriter out, SecurityBulletinEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SecurityBulletinEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SecurityBulletinEvent given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SecurityBulletinEvent
   * @throws IOException if the JSON string is invalid with respect to SecurityBulletinEvent
   */
  public static SecurityBulletinEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SecurityBulletinEvent.class);
  }

  /**
   * Convert an instance of SecurityBulletinEvent to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

