/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BestEffortProvisioning;
import org.openapitools.client.model.MaxPodsConstraint;
import org.openapitools.client.model.NodeConfig;
import org.openapitools.client.model.NodeManagement;
import org.openapitools.client.model.NodeNetworkConfig;
import org.openapitools.client.model.NodePoolAutoscaling;
import org.openapitools.client.model.PlacementPolicy;
import org.openapitools.client.model.QueuedProvisioning;
import org.openapitools.client.model.StatusCondition;
import org.openapitools.client.model.UpdateInfo;
import org.openapitools.client.model.UpgradeSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NodePool contains the name and configuration for a cluster&#39;s node pool. Node pools are a set of nodes (i.e. VM&#39;s), with a common configuration and specification, under the control of the cluster master. They may have a set of Kubernetes labels applied to them, which may be used to reference them during pod scheduling. They may also be resized up or down, to accommodate the workload.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NodePool {
  public static final String SERIALIZED_NAME_AUTOSCALING = "autoscaling";
  @SerializedName(SERIALIZED_NAME_AUTOSCALING)
  private NodePoolAutoscaling autoscaling;

  public static final String SERIALIZED_NAME_BEST_EFFORT_PROVISIONING = "bestEffortProvisioning";
  @SerializedName(SERIALIZED_NAME_BEST_EFFORT_PROVISIONING)
  private BestEffortProvisioning bestEffortProvisioning;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<StatusCondition> conditions = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONFIG = "config";
  @SerializedName(SERIALIZED_NAME_CONFIG)
  private NodeConfig config;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_INITIAL_NODE_COUNT = "initialNodeCount";
  @SerializedName(SERIALIZED_NAME_INITIAL_NODE_COUNT)
  private Integer initialNodeCount;

  public static final String SERIALIZED_NAME_INSTANCE_GROUP_URLS = "instanceGroupUrls";
  @SerializedName(SERIALIZED_NAME_INSTANCE_GROUP_URLS)
  private List<String> instanceGroupUrls = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCATIONS = "locations";
  @SerializedName(SERIALIZED_NAME_LOCATIONS)
  private List<String> locations = new ArrayList<>();

  public static final String SERIALIZED_NAME_MANAGEMENT = "management";
  @SerializedName(SERIALIZED_NAME_MANAGEMENT)
  private NodeManagement management;

  public static final String SERIALIZED_NAME_MAX_PODS_CONSTRAINT = "maxPodsConstraint";
  @SerializedName(SERIALIZED_NAME_MAX_PODS_CONSTRAINT)
  private MaxPodsConstraint maxPodsConstraint;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NETWORK_CONFIG = "networkConfig";
  @SerializedName(SERIALIZED_NAME_NETWORK_CONFIG)
  private NodeNetworkConfig networkConfig;

  public static final String SERIALIZED_NAME_PLACEMENT_POLICY = "placementPolicy";
  @SerializedName(SERIALIZED_NAME_PLACEMENT_POLICY)
  private PlacementPolicy placementPolicy;

  public static final String SERIALIZED_NAME_POD_IPV4_CIDR_SIZE = "podIpv4CidrSize";
  @SerializedName(SERIALIZED_NAME_POD_IPV4_CIDR_SIZE)
  private Integer podIpv4CidrSize;

  public static final String SERIALIZED_NAME_QUEUED_PROVISIONING = "queuedProvisioning";
  @SerializedName(SERIALIZED_NAME_QUEUED_PROVISIONING)
  private QueuedProvisioning queuedProvisioning;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  /**
   * [Output only] The status of the nodes in this pool instance.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    STATUS_UNSPECIFIED("STATUS_UNSPECIFIED"),
    
    PROVISIONING("PROVISIONING"),
    
    RUNNING("RUNNING"),
    
    RUNNING_WITH_ERROR("RUNNING_WITH_ERROR"),
    
    RECONCILING("RECONCILING"),
    
    STOPPING("STOPPING"),
    
    ERROR("ERROR");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_STATUS_MESSAGE = "statusMessage";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_STATUS_MESSAGE)
  private String statusMessage;

  public static final String SERIALIZED_NAME_UPDATE_INFO = "updateInfo";
  @SerializedName(SERIALIZED_NAME_UPDATE_INFO)
  private UpdateInfo updateInfo;

  public static final String SERIALIZED_NAME_UPGRADE_SETTINGS = "upgradeSettings";
  @SerializedName(SERIALIZED_NAME_UPGRADE_SETTINGS)
  private UpgradeSettings upgradeSettings;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public NodePool() {
  }

  public NodePool autoscaling(NodePoolAutoscaling autoscaling) {
    this.autoscaling = autoscaling;
    return this;
  }

  /**
   * Get autoscaling
   * @return autoscaling
   */
  @javax.annotation.Nullable
  public NodePoolAutoscaling getAutoscaling() {
    return autoscaling;
  }

  public void setAutoscaling(NodePoolAutoscaling autoscaling) {
    this.autoscaling = autoscaling;
  }


  public NodePool bestEffortProvisioning(BestEffortProvisioning bestEffortProvisioning) {
    this.bestEffortProvisioning = bestEffortProvisioning;
    return this;
  }

  /**
   * Get bestEffortProvisioning
   * @return bestEffortProvisioning
   */
  @javax.annotation.Nullable
  public BestEffortProvisioning getBestEffortProvisioning() {
    return bestEffortProvisioning;
  }

  public void setBestEffortProvisioning(BestEffortProvisioning bestEffortProvisioning) {
    this.bestEffortProvisioning = bestEffortProvisioning;
  }


  public NodePool conditions(List<StatusCondition> conditions) {
    this.conditions = conditions;
    return this;
  }

  public NodePool addConditionsItem(StatusCondition conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

  /**
   * Which conditions caused the current node pool state.
   * @return conditions
   */
  @javax.annotation.Nullable
  public List<StatusCondition> getConditions() {
    return conditions;
  }

  public void setConditions(List<StatusCondition> conditions) {
    this.conditions = conditions;
  }


  public NodePool config(NodeConfig config) {
    this.config = config;
    return this;
  }

  /**
   * Get config
   * @return config
   */
  @javax.annotation.Nullable
  public NodeConfig getConfig() {
    return config;
  }

  public void setConfig(NodeConfig config) {
    this.config = config;
  }


  public NodePool etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * This checksum is computed by the server based on the value of node pool fields, and may be sent on update requests to ensure the client has an up-to-date value before proceeding.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public NodePool initialNodeCount(Integer initialNodeCount) {
    this.initialNodeCount = initialNodeCount;
    return this;
  }

  /**
   * The initial node count for the pool. You must ensure that your Compute Engine [resource quota](https://cloud.google.com/compute/quotas) is sufficient for this number of instances. You must also have available firewall and routes quota.
   * @return initialNodeCount
   */
  @javax.annotation.Nullable
  public Integer getInitialNodeCount() {
    return initialNodeCount;
  }

  public void setInitialNodeCount(Integer initialNodeCount) {
    this.initialNodeCount = initialNodeCount;
  }


  public NodePool instanceGroupUrls(List<String> instanceGroupUrls) {
    this.instanceGroupUrls = instanceGroupUrls;
    return this;
  }

  public NodePool addInstanceGroupUrlsItem(String instanceGroupUrlsItem) {
    if (this.instanceGroupUrls == null) {
      this.instanceGroupUrls = new ArrayList<>();
    }
    this.instanceGroupUrls.add(instanceGroupUrlsItem);
    return this;
  }

  /**
   * [Output only] The resource URLs of the [managed instance groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances) associated with this node pool. During the node pool blue-green upgrade operation, the URLs contain both blue and green resources.
   * @return instanceGroupUrls
   */
  @javax.annotation.Nullable
  public List<String> getInstanceGroupUrls() {
    return instanceGroupUrls;
  }

  public void setInstanceGroupUrls(List<String> instanceGroupUrls) {
    this.instanceGroupUrls = instanceGroupUrls;
  }


  public NodePool locations(List<String> locations) {
    this.locations = locations;
    return this;
  }

  public NodePool addLocationsItem(String locationsItem) {
    if (this.locations == null) {
      this.locations = new ArrayList<>();
    }
    this.locations.add(locationsItem);
    return this;
  }

  /**
   * The list of Google Compute Engine [zones](https://cloud.google.com/compute/docs/zones#available) in which the NodePool&#39;s nodes should be located. If this value is unspecified during node pool creation, the [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations) value will be used, instead. Warning: changing node pool locations will result in nodes being added and/or removed.
   * @return locations
   */
  @javax.annotation.Nullable
  public List<String> getLocations() {
    return locations;
  }

  public void setLocations(List<String> locations) {
    this.locations = locations;
  }


  public NodePool management(NodeManagement management) {
    this.management = management;
    return this;
  }

  /**
   * Get management
   * @return management
   */
  @javax.annotation.Nullable
  public NodeManagement getManagement() {
    return management;
  }

  public void setManagement(NodeManagement management) {
    this.management = management;
  }


  public NodePool maxPodsConstraint(MaxPodsConstraint maxPodsConstraint) {
    this.maxPodsConstraint = maxPodsConstraint;
    return this;
  }

  /**
   * Get maxPodsConstraint
   * @return maxPodsConstraint
   */
  @javax.annotation.Nullable
  public MaxPodsConstraint getMaxPodsConstraint() {
    return maxPodsConstraint;
  }

  public void setMaxPodsConstraint(MaxPodsConstraint maxPodsConstraint) {
    this.maxPodsConstraint = maxPodsConstraint;
  }


  public NodePool name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the node pool.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NodePool networkConfig(NodeNetworkConfig networkConfig) {
    this.networkConfig = networkConfig;
    return this;
  }

  /**
   * Get networkConfig
   * @return networkConfig
   */
  @javax.annotation.Nullable
  public NodeNetworkConfig getNetworkConfig() {
    return networkConfig;
  }

  public void setNetworkConfig(NodeNetworkConfig networkConfig) {
    this.networkConfig = networkConfig;
  }


  public NodePool placementPolicy(PlacementPolicy placementPolicy) {
    this.placementPolicy = placementPolicy;
    return this;
  }

  /**
   * Get placementPolicy
   * @return placementPolicy
   */
  @javax.annotation.Nullable
  public PlacementPolicy getPlacementPolicy() {
    return placementPolicy;
  }

  public void setPlacementPolicy(PlacementPolicy placementPolicy) {
    this.placementPolicy = placementPolicy;
  }


  public NodePool podIpv4CidrSize(Integer podIpv4CidrSize) {
    this.podIpv4CidrSize = podIpv4CidrSize;
    return this;
  }

  /**
   * [Output only] The pod CIDR block size per node in this node pool.
   * @return podIpv4CidrSize
   */
  @javax.annotation.Nullable
  public Integer getPodIpv4CidrSize() {
    return podIpv4CidrSize;
  }

  public void setPodIpv4CidrSize(Integer podIpv4CidrSize) {
    this.podIpv4CidrSize = podIpv4CidrSize;
  }


  public NodePool queuedProvisioning(QueuedProvisioning queuedProvisioning) {
    this.queuedProvisioning = queuedProvisioning;
    return this;
  }

  /**
   * Get queuedProvisioning
   * @return queuedProvisioning
   */
  @javax.annotation.Nullable
  public QueuedProvisioning getQueuedProvisioning() {
    return queuedProvisioning;
  }

  public void setQueuedProvisioning(QueuedProvisioning queuedProvisioning) {
    this.queuedProvisioning = queuedProvisioning;
  }


  public NodePool selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * [Output only] Server-defined URL for the resource.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }


  public NodePool status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * [Output only] The status of the nodes in this pool instance.
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  @Deprecated
  public NodePool statusMessage(String statusMessage) {
    this.statusMessage = statusMessage;
    return this;
  }

  /**
   * [Output only] Deprecated. Use conditions instead. Additional information about the current status of this node pool instance, if available.
   * @return statusMessage
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getStatusMessage() {
    return statusMessage;
  }

  @Deprecated
  public void setStatusMessage(String statusMessage) {
    this.statusMessage = statusMessage;
  }


  public NodePool updateInfo(UpdateInfo updateInfo) {
    this.updateInfo = updateInfo;
    return this;
  }

  /**
   * Get updateInfo
   * @return updateInfo
   */
  @javax.annotation.Nullable
  public UpdateInfo getUpdateInfo() {
    return updateInfo;
  }

  public void setUpdateInfo(UpdateInfo updateInfo) {
    this.updateInfo = updateInfo;
  }


  public NodePool upgradeSettings(UpgradeSettings upgradeSettings) {
    this.upgradeSettings = upgradeSettings;
    return this;
  }

  /**
   * Get upgradeSettings
   * @return upgradeSettings
   */
  @javax.annotation.Nullable
  public UpgradeSettings getUpgradeSettings() {
    return upgradeSettings;
  }

  public void setUpgradeSettings(UpgradeSettings upgradeSettings) {
    this.upgradeSettings = upgradeSettings;
  }


  public NodePool version(String version) {
    this.version = version;
    return this;
  }

  /**
   * The version of Kubernetes running on this NodePool&#39;s nodes. If unspecified, it defaults as described [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodePool nodePool = (NodePool) o;
    return Objects.equals(this.autoscaling, nodePool.autoscaling) &&
        Objects.equals(this.bestEffortProvisioning, nodePool.bestEffortProvisioning) &&
        Objects.equals(this.conditions, nodePool.conditions) &&
        Objects.equals(this.config, nodePool.config) &&
        Objects.equals(this.etag, nodePool.etag) &&
        Objects.equals(this.initialNodeCount, nodePool.initialNodeCount) &&
        Objects.equals(this.instanceGroupUrls, nodePool.instanceGroupUrls) &&
        Objects.equals(this.locations, nodePool.locations) &&
        Objects.equals(this.management, nodePool.management) &&
        Objects.equals(this.maxPodsConstraint, nodePool.maxPodsConstraint) &&
        Objects.equals(this.name, nodePool.name) &&
        Objects.equals(this.networkConfig, nodePool.networkConfig) &&
        Objects.equals(this.placementPolicy, nodePool.placementPolicy) &&
        Objects.equals(this.podIpv4CidrSize, nodePool.podIpv4CidrSize) &&
        Objects.equals(this.queuedProvisioning, nodePool.queuedProvisioning) &&
        Objects.equals(this.selfLink, nodePool.selfLink) &&
        Objects.equals(this.status, nodePool.status) &&
        Objects.equals(this.statusMessage, nodePool.statusMessage) &&
        Objects.equals(this.updateInfo, nodePool.updateInfo) &&
        Objects.equals(this.upgradeSettings, nodePool.upgradeSettings) &&
        Objects.equals(this.version, nodePool.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoscaling, bestEffortProvisioning, conditions, config, etag, initialNodeCount, instanceGroupUrls, locations, management, maxPodsConstraint, name, networkConfig, placementPolicy, podIpv4CidrSize, queuedProvisioning, selfLink, status, statusMessage, updateInfo, upgradeSettings, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodePool {\n");
    sb.append("    autoscaling: ").append(toIndentedString(autoscaling)).append("\n");
    sb.append("    bestEffortProvisioning: ").append(toIndentedString(bestEffortProvisioning)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    initialNodeCount: ").append(toIndentedString(initialNodeCount)).append("\n");
    sb.append("    instanceGroupUrls: ").append(toIndentedString(instanceGroupUrls)).append("\n");
    sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
    sb.append("    management: ").append(toIndentedString(management)).append("\n");
    sb.append("    maxPodsConstraint: ").append(toIndentedString(maxPodsConstraint)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    networkConfig: ").append(toIndentedString(networkConfig)).append("\n");
    sb.append("    placementPolicy: ").append(toIndentedString(placementPolicy)).append("\n");
    sb.append("    podIpv4CidrSize: ").append(toIndentedString(podIpv4CidrSize)).append("\n");
    sb.append("    queuedProvisioning: ").append(toIndentedString(queuedProvisioning)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusMessage: ").append(toIndentedString(statusMessage)).append("\n");
    sb.append("    updateInfo: ").append(toIndentedString(updateInfo)).append("\n");
    sb.append("    upgradeSettings: ").append(toIndentedString(upgradeSettings)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoscaling");
    openapiFields.add("bestEffortProvisioning");
    openapiFields.add("conditions");
    openapiFields.add("config");
    openapiFields.add("etag");
    openapiFields.add("initialNodeCount");
    openapiFields.add("instanceGroupUrls");
    openapiFields.add("locations");
    openapiFields.add("management");
    openapiFields.add("maxPodsConstraint");
    openapiFields.add("name");
    openapiFields.add("networkConfig");
    openapiFields.add("placementPolicy");
    openapiFields.add("podIpv4CidrSize");
    openapiFields.add("queuedProvisioning");
    openapiFields.add("selfLink");
    openapiFields.add("status");
    openapiFields.add("statusMessage");
    openapiFields.add("updateInfo");
    openapiFields.add("upgradeSettings");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NodePool
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodePool.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodePool is not found in the empty JSON string", NodePool.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodePool.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodePool` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `autoscaling`
      if (jsonObj.get("autoscaling") != null && !jsonObj.get("autoscaling").isJsonNull()) {
        NodePoolAutoscaling.validateJsonElement(jsonObj.get("autoscaling"));
      }
      // validate the optional field `bestEffortProvisioning`
      if (jsonObj.get("bestEffortProvisioning") != null && !jsonObj.get("bestEffortProvisioning").isJsonNull()) {
        BestEffortProvisioning.validateJsonElement(jsonObj.get("bestEffortProvisioning"));
      }
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull()) {
        JsonArray jsonArrayconditions = jsonObj.getAsJsonArray("conditions");
        if (jsonArrayconditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("conditions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
          }

          // validate the optional field `conditions` (array)
          for (int i = 0; i < jsonArrayconditions.size(); i++) {
            StatusCondition.validateJsonElement(jsonArrayconditions.get(i));
          };
        }
      }
      // validate the optional field `config`
      if (jsonObj.get("config") != null && !jsonObj.get("config").isJsonNull()) {
        NodeConfig.validateJsonElement(jsonObj.get("config"));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instanceGroupUrls") != null && !jsonObj.get("instanceGroupUrls").isJsonNull() && !jsonObj.get("instanceGroupUrls").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceGroupUrls` to be an array in the JSON string but got `%s`", jsonObj.get("instanceGroupUrls").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("locations") != null && !jsonObj.get("locations").isJsonNull() && !jsonObj.get("locations").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `locations` to be an array in the JSON string but got `%s`", jsonObj.get("locations").toString()));
      }
      // validate the optional field `management`
      if (jsonObj.get("management") != null && !jsonObj.get("management").isJsonNull()) {
        NodeManagement.validateJsonElement(jsonObj.get("management"));
      }
      // validate the optional field `maxPodsConstraint`
      if (jsonObj.get("maxPodsConstraint") != null && !jsonObj.get("maxPodsConstraint").isJsonNull()) {
        MaxPodsConstraint.validateJsonElement(jsonObj.get("maxPodsConstraint"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `networkConfig`
      if (jsonObj.get("networkConfig") != null && !jsonObj.get("networkConfig").isJsonNull()) {
        NodeNetworkConfig.validateJsonElement(jsonObj.get("networkConfig"));
      }
      // validate the optional field `placementPolicy`
      if (jsonObj.get("placementPolicy") != null && !jsonObj.get("placementPolicy").isJsonNull()) {
        PlacementPolicy.validateJsonElement(jsonObj.get("placementPolicy"));
      }
      // validate the optional field `queuedProvisioning`
      if (jsonObj.get("queuedProvisioning") != null && !jsonObj.get("queuedProvisioning").isJsonNull()) {
        QueuedProvisioning.validateJsonElement(jsonObj.get("queuedProvisioning"));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("statusMessage") != null && !jsonObj.get("statusMessage").isJsonNull()) && !jsonObj.get("statusMessage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statusMessage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statusMessage").toString()));
      }
      // validate the optional field `updateInfo`
      if (jsonObj.get("updateInfo") != null && !jsonObj.get("updateInfo").isJsonNull()) {
        UpdateInfo.validateJsonElement(jsonObj.get("updateInfo"));
      }
      // validate the optional field `upgradeSettings`
      if (jsonObj.get("upgradeSettings") != null && !jsonObj.get("upgradeSettings").isJsonNull()) {
        UpgradeSettings.validateJsonElement(jsonObj.get("upgradeSettings"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodePool.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodePool' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodePool> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodePool.class));

       return (TypeAdapter<T>) new TypeAdapter<NodePool>() {
           @Override
           public void write(JsonWriter out, NodePool value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodePool read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NodePool given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NodePool
   * @throws IOException if the JSON string is invalid with respect to NodePool
   */
  public static NodePool fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodePool.class);
  }

  /**
   * Convert an instance of NodePool to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

