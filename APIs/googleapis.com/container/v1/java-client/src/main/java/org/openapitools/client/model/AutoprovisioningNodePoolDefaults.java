/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.NodeManagement;
import org.openapitools.client.model.ShieldedInstanceConfig;
import org.openapitools.client.model.UpgradeSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AutoprovisioningNodePoolDefaults contains defaults for a node pool created by NAP.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AutoprovisioningNodePoolDefaults {
  public static final String SERIALIZED_NAME_BOOT_DISK_KMS_KEY = "bootDiskKmsKey";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_KMS_KEY)
  private String bootDiskKmsKey;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private Integer diskSizeGb;

  public static final String SERIALIZED_NAME_DISK_TYPE = "diskType";
  @SerializedName(SERIALIZED_NAME_DISK_TYPE)
  private String diskType;

  public static final String SERIALIZED_NAME_IMAGE_TYPE = "imageType";
  @SerializedName(SERIALIZED_NAME_IMAGE_TYPE)
  private String imageType;

  public static final String SERIALIZED_NAME_INSECURE_KUBELET_READONLY_PORT_ENABLED = "insecureKubeletReadonlyPortEnabled";
  @SerializedName(SERIALIZED_NAME_INSECURE_KUBELET_READONLY_PORT_ENABLED)
  private Boolean insecureKubeletReadonlyPortEnabled;

  public static final String SERIALIZED_NAME_MANAGEMENT = "management";
  @SerializedName(SERIALIZED_NAME_MANAGEMENT)
  private NodeManagement management;

  public static final String SERIALIZED_NAME_MIN_CPU_PLATFORM = "minCpuPlatform";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_MIN_CPU_PLATFORM)
  private String minCpuPlatform;

  public static final String SERIALIZED_NAME_OAUTH_SCOPES = "oauthScopes";
  @SerializedName(SERIALIZED_NAME_OAUTH_SCOPES)
  private List<String> oauthScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG = "shieldedInstanceConfig";
  @SerializedName(SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG)
  private ShieldedInstanceConfig shieldedInstanceConfig;

  public static final String SERIALIZED_NAME_UPGRADE_SETTINGS = "upgradeSettings";
  @SerializedName(SERIALIZED_NAME_UPGRADE_SETTINGS)
  private UpgradeSettings upgradeSettings;

  public AutoprovisioningNodePoolDefaults() {
  }

  public AutoprovisioningNodePoolDefaults bootDiskKmsKey(String bootDiskKmsKey) {
    this.bootDiskKmsKey = bootDiskKmsKey;
    return this;
  }

  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   * @return bootDiskKmsKey
   */
  @javax.annotation.Nullable
  public String getBootDiskKmsKey() {
    return bootDiskKmsKey;
  }

  public void setBootDiskKmsKey(String bootDiskKmsKey) {
    this.bootDiskKmsKey = bootDiskKmsKey;
  }


  public AutoprovisioningNodePoolDefaults diskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(Integer diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public AutoprovisioningNodePoolDefaults diskType(String diskType) {
    this.diskType = diskType;
    return this;
  }

  /**
   * Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
   * @return diskType
   */
  @javax.annotation.Nullable
  public String getDiskType() {
    return diskType;
  }

  public void setDiskType(String diskType) {
    this.diskType = diskType;
  }


  public AutoprovisioningNodePoolDefaults imageType(String imageType) {
    this.imageType = imageType;
    return this;
  }

  /**
   * The image type to use for NAP created node. Please see https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for available image types.
   * @return imageType
   */
  @javax.annotation.Nullable
  public String getImageType() {
    return imageType;
  }

  public void setImageType(String imageType) {
    this.imageType = imageType;
  }


  public AutoprovisioningNodePoolDefaults insecureKubeletReadonlyPortEnabled(Boolean insecureKubeletReadonlyPortEnabled) {
    this.insecureKubeletReadonlyPortEnabled = insecureKubeletReadonlyPortEnabled;
    return this;
  }

  /**
   * Enable or disable Kubelet read only port.
   * @return insecureKubeletReadonlyPortEnabled
   */
  @javax.annotation.Nullable
  public Boolean getInsecureKubeletReadonlyPortEnabled() {
    return insecureKubeletReadonlyPortEnabled;
  }

  public void setInsecureKubeletReadonlyPortEnabled(Boolean insecureKubeletReadonlyPortEnabled) {
    this.insecureKubeletReadonlyPortEnabled = insecureKubeletReadonlyPortEnabled;
  }


  public AutoprovisioningNodePoolDefaults management(NodeManagement management) {
    this.management = management;
    return this;
  }

  /**
   * Get management
   * @return management
   */
  @javax.annotation.Nullable
  public NodeManagement getManagement() {
    return management;
  }

  public void setManagement(NodeManagement management) {
    this.management = management;
  }


  @Deprecated
  public AutoprovisioningNodePoolDefaults minCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
    return this;
  }

  /**
   * Deprecated. Minimum CPU platform to be used for NAP created node pools. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: Intel Haswell or minCpuPlatform: Intel Sandy Bridge. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform). This field is deprecated, min_cpu_platform should be specified using &#x60;cloud.google.com/requested-min-cpu-platform&#x60; label selector on the pod. To unset the min cpu platform field pass \&quot;automatic\&quot; as field value.
   * @return minCpuPlatform
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getMinCpuPlatform() {
    return minCpuPlatform;
  }

  @Deprecated
  public void setMinCpuPlatform(String minCpuPlatform) {
    this.minCpuPlatform = minCpuPlatform;
  }


  public AutoprovisioningNodePoolDefaults oauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
    return this;
  }

  public AutoprovisioningNodePoolDefaults addOauthScopesItem(String oauthScopesItem) {
    if (this.oauthScopes == null) {
      this.oauthScopes = new ArrayList<>();
    }
    this.oauthScopes.add(oauthScopesItem);
    return this;
  }

  /**
   * Scopes that are used by NAP when creating node pools.
   * @return oauthScopes
   */
  @javax.annotation.Nullable
  public List<String> getOauthScopes() {
    return oauthScopes;
  }

  public void setOauthScopes(List<String> oauthScopes) {
    this.oauthScopes = oauthScopes;
  }


  public AutoprovisioningNodePoolDefaults serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * The Google Cloud Platform Service Account to be used by the node VMs.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public AutoprovisioningNodePoolDefaults shieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
    return this;
  }

  /**
   * Get shieldedInstanceConfig
   * @return shieldedInstanceConfig
   */
  @javax.annotation.Nullable
  public ShieldedInstanceConfig getShieldedInstanceConfig() {
    return shieldedInstanceConfig;
  }

  public void setShieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
  }


  public AutoprovisioningNodePoolDefaults upgradeSettings(UpgradeSettings upgradeSettings) {
    this.upgradeSettings = upgradeSettings;
    return this;
  }

  /**
   * Get upgradeSettings
   * @return upgradeSettings
   */
  @javax.annotation.Nullable
  public UpgradeSettings getUpgradeSettings() {
    return upgradeSettings;
  }

  public void setUpgradeSettings(UpgradeSettings upgradeSettings) {
    this.upgradeSettings = upgradeSettings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AutoprovisioningNodePoolDefaults autoprovisioningNodePoolDefaults = (AutoprovisioningNodePoolDefaults) o;
    return Objects.equals(this.bootDiskKmsKey, autoprovisioningNodePoolDefaults.bootDiskKmsKey) &&
        Objects.equals(this.diskSizeGb, autoprovisioningNodePoolDefaults.diskSizeGb) &&
        Objects.equals(this.diskType, autoprovisioningNodePoolDefaults.diskType) &&
        Objects.equals(this.imageType, autoprovisioningNodePoolDefaults.imageType) &&
        Objects.equals(this.insecureKubeletReadonlyPortEnabled, autoprovisioningNodePoolDefaults.insecureKubeletReadonlyPortEnabled) &&
        Objects.equals(this.management, autoprovisioningNodePoolDefaults.management) &&
        Objects.equals(this.minCpuPlatform, autoprovisioningNodePoolDefaults.minCpuPlatform) &&
        Objects.equals(this.oauthScopes, autoprovisioningNodePoolDefaults.oauthScopes) &&
        Objects.equals(this.serviceAccount, autoprovisioningNodePoolDefaults.serviceAccount) &&
        Objects.equals(this.shieldedInstanceConfig, autoprovisioningNodePoolDefaults.shieldedInstanceConfig) &&
        Objects.equals(this.upgradeSettings, autoprovisioningNodePoolDefaults.upgradeSettings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bootDiskKmsKey, diskSizeGb, diskType, imageType, insecureKubeletReadonlyPortEnabled, management, minCpuPlatform, oauthScopes, serviceAccount, shieldedInstanceConfig, upgradeSettings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AutoprovisioningNodePoolDefaults {\n");
    sb.append("    bootDiskKmsKey: ").append(toIndentedString(bootDiskKmsKey)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    diskType: ").append(toIndentedString(diskType)).append("\n");
    sb.append("    imageType: ").append(toIndentedString(imageType)).append("\n");
    sb.append("    insecureKubeletReadonlyPortEnabled: ").append(toIndentedString(insecureKubeletReadonlyPortEnabled)).append("\n");
    sb.append("    management: ").append(toIndentedString(management)).append("\n");
    sb.append("    minCpuPlatform: ").append(toIndentedString(minCpuPlatform)).append("\n");
    sb.append("    oauthScopes: ").append(toIndentedString(oauthScopes)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    shieldedInstanceConfig: ").append(toIndentedString(shieldedInstanceConfig)).append("\n");
    sb.append("    upgradeSettings: ").append(toIndentedString(upgradeSettings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bootDiskKmsKey");
    openapiFields.add("diskSizeGb");
    openapiFields.add("diskType");
    openapiFields.add("imageType");
    openapiFields.add("insecureKubeletReadonlyPortEnabled");
    openapiFields.add("management");
    openapiFields.add("minCpuPlatform");
    openapiFields.add("oauthScopes");
    openapiFields.add("serviceAccount");
    openapiFields.add("shieldedInstanceConfig");
    openapiFields.add("upgradeSettings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AutoprovisioningNodePoolDefaults
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AutoprovisioningNodePoolDefaults.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AutoprovisioningNodePoolDefaults is not found in the empty JSON string", AutoprovisioningNodePoolDefaults.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AutoprovisioningNodePoolDefaults.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AutoprovisioningNodePoolDefaults` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bootDiskKmsKey") != null && !jsonObj.get("bootDiskKmsKey").isJsonNull()) && !jsonObj.get("bootDiskKmsKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskKmsKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskKmsKey").toString()));
      }
      if ((jsonObj.get("diskType") != null && !jsonObj.get("diskType").isJsonNull()) && !jsonObj.get("diskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskType").toString()));
      }
      if ((jsonObj.get("imageType") != null && !jsonObj.get("imageType").isJsonNull()) && !jsonObj.get("imageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageType").toString()));
      }
      // validate the optional field `management`
      if (jsonObj.get("management") != null && !jsonObj.get("management").isJsonNull()) {
        NodeManagement.validateJsonElement(jsonObj.get("management"));
      }
      if ((jsonObj.get("minCpuPlatform") != null && !jsonObj.get("minCpuPlatform").isJsonNull()) && !jsonObj.get("minCpuPlatform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minCpuPlatform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minCpuPlatform").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("oauthScopes") != null && !jsonObj.get("oauthScopes").isJsonNull() && !jsonObj.get("oauthScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthScopes` to be an array in the JSON string but got `%s`", jsonObj.get("oauthScopes").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // validate the optional field `shieldedInstanceConfig`
      if (jsonObj.get("shieldedInstanceConfig") != null && !jsonObj.get("shieldedInstanceConfig").isJsonNull()) {
        ShieldedInstanceConfig.validateJsonElement(jsonObj.get("shieldedInstanceConfig"));
      }
      // validate the optional field `upgradeSettings`
      if (jsonObj.get("upgradeSettings") != null && !jsonObj.get("upgradeSettings").isJsonNull()) {
        UpgradeSettings.validateJsonElement(jsonObj.get("upgradeSettings"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AutoprovisioningNodePoolDefaults.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AutoprovisioningNodePoolDefaults' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AutoprovisioningNodePoolDefaults> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AutoprovisioningNodePoolDefaults.class));

       return (TypeAdapter<T>) new TypeAdapter<AutoprovisioningNodePoolDefaults>() {
           @Override
           public void write(JsonWriter out, AutoprovisioningNodePoolDefaults value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AutoprovisioningNodePoolDefaults read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AutoprovisioningNodePoolDefaults given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AutoprovisioningNodePoolDefaults
   * @throws IOException if the JSON string is invalid with respect to AutoprovisioningNodePoolDefaults
   */
  public static AutoprovisioningNodePoolDefaults fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AutoprovisioningNodePoolDefaults.class);
  }

  /**
   * Convert an instance of AutoprovisioningNodePoolDefaults to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

