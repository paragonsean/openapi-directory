/*
 * Kubernetes Engine API
 * Builds and manages container-based applications, powered by the open source Kubernetes technology.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.PrivateClusterMasterGlobalAccessConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration options for private clusters.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:25.935819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PrivateClusterConfig {
  public static final String SERIALIZED_NAME_ENABLE_PRIVATE_ENDPOINT = "enablePrivateEndpoint";
  @SerializedName(SERIALIZED_NAME_ENABLE_PRIVATE_ENDPOINT)
  private Boolean enablePrivateEndpoint;

  public static final String SERIALIZED_NAME_ENABLE_PRIVATE_NODES = "enablePrivateNodes";
  @SerializedName(SERIALIZED_NAME_ENABLE_PRIVATE_NODES)
  private Boolean enablePrivateNodes;

  public static final String SERIALIZED_NAME_MASTER_GLOBAL_ACCESS_CONFIG = "masterGlobalAccessConfig";
  @SerializedName(SERIALIZED_NAME_MASTER_GLOBAL_ACCESS_CONFIG)
  private PrivateClusterMasterGlobalAccessConfig masterGlobalAccessConfig;

  public static final String SERIALIZED_NAME_MASTER_IPV4_CIDR_BLOCK = "masterIpv4CidrBlock";
  @SerializedName(SERIALIZED_NAME_MASTER_IPV4_CIDR_BLOCK)
  private String masterIpv4CidrBlock;

  public static final String SERIALIZED_NAME_PEERING_NAME = "peeringName";
  @SerializedName(SERIALIZED_NAME_PEERING_NAME)
  private String peeringName;

  public static final String SERIALIZED_NAME_PRIVATE_ENDPOINT = "privateEndpoint";
  @SerializedName(SERIALIZED_NAME_PRIVATE_ENDPOINT)
  private String privateEndpoint;

  public static final String SERIALIZED_NAME_PRIVATE_ENDPOINT_SUBNETWORK = "privateEndpointSubnetwork";
  @SerializedName(SERIALIZED_NAME_PRIVATE_ENDPOINT_SUBNETWORK)
  private String privateEndpointSubnetwork;

  public static final String SERIALIZED_NAME_PUBLIC_ENDPOINT = "publicEndpoint";
  @SerializedName(SERIALIZED_NAME_PUBLIC_ENDPOINT)
  private String publicEndpoint;

  public PrivateClusterConfig() {
  }

  public PrivateClusterConfig enablePrivateEndpoint(Boolean enablePrivateEndpoint) {
    this.enablePrivateEndpoint = enablePrivateEndpoint;
    return this;
  }

  /**
   * Whether the master&#39;s internal IP address is used as the cluster endpoint.
   * @return enablePrivateEndpoint
   */
  @javax.annotation.Nullable
  public Boolean getEnablePrivateEndpoint() {
    return enablePrivateEndpoint;
  }

  public void setEnablePrivateEndpoint(Boolean enablePrivateEndpoint) {
    this.enablePrivateEndpoint = enablePrivateEndpoint;
  }


  public PrivateClusterConfig enablePrivateNodes(Boolean enablePrivateNodes) {
    this.enablePrivateNodes = enablePrivateNodes;
    return this;
  }

  /**
   * Whether nodes have internal IP addresses only. If enabled, all nodes are given only RFC 1918 private addresses and communicate with the master via private networking.
   * @return enablePrivateNodes
   */
  @javax.annotation.Nullable
  public Boolean getEnablePrivateNodes() {
    return enablePrivateNodes;
  }

  public void setEnablePrivateNodes(Boolean enablePrivateNodes) {
    this.enablePrivateNodes = enablePrivateNodes;
  }


  public PrivateClusterConfig masterGlobalAccessConfig(PrivateClusterMasterGlobalAccessConfig masterGlobalAccessConfig) {
    this.masterGlobalAccessConfig = masterGlobalAccessConfig;
    return this;
  }

  /**
   * Get masterGlobalAccessConfig
   * @return masterGlobalAccessConfig
   */
  @javax.annotation.Nullable
  public PrivateClusterMasterGlobalAccessConfig getMasterGlobalAccessConfig() {
    return masterGlobalAccessConfig;
  }

  public void setMasterGlobalAccessConfig(PrivateClusterMasterGlobalAccessConfig masterGlobalAccessConfig) {
    this.masterGlobalAccessConfig = masterGlobalAccessConfig;
  }


  public PrivateClusterConfig masterIpv4CidrBlock(String masterIpv4CidrBlock) {
    this.masterIpv4CidrBlock = masterIpv4CidrBlock;
    return this;
  }

  /**
   * The IP range in CIDR notation to use for the hosted master network. This range will be used for assigning internal IP addresses to the master or set of masters, as well as the ILB VIP. This range must not overlap with any other ranges in use within the cluster&#39;s network.
   * @return masterIpv4CidrBlock
   */
  @javax.annotation.Nullable
  public String getMasterIpv4CidrBlock() {
    return masterIpv4CidrBlock;
  }

  public void setMasterIpv4CidrBlock(String masterIpv4CidrBlock) {
    this.masterIpv4CidrBlock = masterIpv4CidrBlock;
  }


  public PrivateClusterConfig peeringName(String peeringName) {
    this.peeringName = peeringName;
    return this;
  }

  /**
   * Output only. The peering name in the customer VPC used by this cluster.
   * @return peeringName
   */
  @javax.annotation.Nullable
  public String getPeeringName() {
    return peeringName;
  }

  public void setPeeringName(String peeringName) {
    this.peeringName = peeringName;
  }


  public PrivateClusterConfig privateEndpoint(String privateEndpoint) {
    this.privateEndpoint = privateEndpoint;
    return this;
  }

  /**
   * Output only. The internal IP address of this cluster&#39;s master endpoint.
   * @return privateEndpoint
   */
  @javax.annotation.Nullable
  public String getPrivateEndpoint() {
    return privateEndpoint;
  }

  public void setPrivateEndpoint(String privateEndpoint) {
    this.privateEndpoint = privateEndpoint;
  }


  public PrivateClusterConfig privateEndpointSubnetwork(String privateEndpointSubnetwork) {
    this.privateEndpointSubnetwork = privateEndpointSubnetwork;
    return this;
  }

  /**
   * Subnet to provision the master&#39;s private endpoint during cluster creation. Specified in projects/_*_/regions/_*_/subnetworks/_* format.
   * @return privateEndpointSubnetwork
   */
  @javax.annotation.Nullable
  public String getPrivateEndpointSubnetwork() {
    return privateEndpointSubnetwork;
  }

  public void setPrivateEndpointSubnetwork(String privateEndpointSubnetwork) {
    this.privateEndpointSubnetwork = privateEndpointSubnetwork;
  }


  public PrivateClusterConfig publicEndpoint(String publicEndpoint) {
    this.publicEndpoint = publicEndpoint;
    return this;
  }

  /**
   * Output only. The external IP address of this cluster&#39;s master endpoint.
   * @return publicEndpoint
   */
  @javax.annotation.Nullable
  public String getPublicEndpoint() {
    return publicEndpoint;
  }

  public void setPublicEndpoint(String publicEndpoint) {
    this.publicEndpoint = publicEndpoint;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PrivateClusterConfig privateClusterConfig = (PrivateClusterConfig) o;
    return Objects.equals(this.enablePrivateEndpoint, privateClusterConfig.enablePrivateEndpoint) &&
        Objects.equals(this.enablePrivateNodes, privateClusterConfig.enablePrivateNodes) &&
        Objects.equals(this.masterGlobalAccessConfig, privateClusterConfig.masterGlobalAccessConfig) &&
        Objects.equals(this.masterIpv4CidrBlock, privateClusterConfig.masterIpv4CidrBlock) &&
        Objects.equals(this.peeringName, privateClusterConfig.peeringName) &&
        Objects.equals(this.privateEndpoint, privateClusterConfig.privateEndpoint) &&
        Objects.equals(this.privateEndpointSubnetwork, privateClusterConfig.privateEndpointSubnetwork) &&
        Objects.equals(this.publicEndpoint, privateClusterConfig.publicEndpoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(enablePrivateEndpoint, enablePrivateNodes, masterGlobalAccessConfig, masterIpv4CidrBlock, peeringName, privateEndpoint, privateEndpointSubnetwork, publicEndpoint);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PrivateClusterConfig {\n");
    sb.append("    enablePrivateEndpoint: ").append(toIndentedString(enablePrivateEndpoint)).append("\n");
    sb.append("    enablePrivateNodes: ").append(toIndentedString(enablePrivateNodes)).append("\n");
    sb.append("    masterGlobalAccessConfig: ").append(toIndentedString(masterGlobalAccessConfig)).append("\n");
    sb.append("    masterIpv4CidrBlock: ").append(toIndentedString(masterIpv4CidrBlock)).append("\n");
    sb.append("    peeringName: ").append(toIndentedString(peeringName)).append("\n");
    sb.append("    privateEndpoint: ").append(toIndentedString(privateEndpoint)).append("\n");
    sb.append("    privateEndpointSubnetwork: ").append(toIndentedString(privateEndpointSubnetwork)).append("\n");
    sb.append("    publicEndpoint: ").append(toIndentedString(publicEndpoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("enablePrivateEndpoint");
    openapiFields.add("enablePrivateNodes");
    openapiFields.add("masterGlobalAccessConfig");
    openapiFields.add("masterIpv4CidrBlock");
    openapiFields.add("peeringName");
    openapiFields.add("privateEndpoint");
    openapiFields.add("privateEndpointSubnetwork");
    openapiFields.add("publicEndpoint");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PrivateClusterConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PrivateClusterConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PrivateClusterConfig is not found in the empty JSON string", PrivateClusterConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PrivateClusterConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PrivateClusterConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `masterGlobalAccessConfig`
      if (jsonObj.get("masterGlobalAccessConfig") != null && !jsonObj.get("masterGlobalAccessConfig").isJsonNull()) {
        PrivateClusterMasterGlobalAccessConfig.validateJsonElement(jsonObj.get("masterGlobalAccessConfig"));
      }
      if ((jsonObj.get("masterIpv4CidrBlock") != null && !jsonObj.get("masterIpv4CidrBlock").isJsonNull()) && !jsonObj.get("masterIpv4CidrBlock").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `masterIpv4CidrBlock` to be a primitive type in the JSON string but got `%s`", jsonObj.get("masterIpv4CidrBlock").toString()));
      }
      if ((jsonObj.get("peeringName") != null && !jsonObj.get("peeringName").isJsonNull()) && !jsonObj.get("peeringName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `peeringName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("peeringName").toString()));
      }
      if ((jsonObj.get("privateEndpoint") != null && !jsonObj.get("privateEndpoint").isJsonNull()) && !jsonObj.get("privateEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `privateEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("privateEndpoint").toString()));
      }
      if ((jsonObj.get("privateEndpointSubnetwork") != null && !jsonObj.get("privateEndpointSubnetwork").isJsonNull()) && !jsonObj.get("privateEndpointSubnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `privateEndpointSubnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("privateEndpointSubnetwork").toString()));
      }
      if ((jsonObj.get("publicEndpoint") != null && !jsonObj.get("publicEndpoint").isJsonNull()) && !jsonObj.get("publicEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publicEndpoint").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PrivateClusterConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PrivateClusterConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PrivateClusterConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PrivateClusterConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<PrivateClusterConfig>() {
           @Override
           public void write(JsonWriter out, PrivateClusterConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PrivateClusterConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PrivateClusterConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PrivateClusterConfig
   * @throws IOException if the JSON string is invalid with respect to PrivateClusterConfig
   */
  public static PrivateClusterConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PrivateClusterConfig.class);
  }

  /**
   * Convert an instance of PrivateClusterConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

