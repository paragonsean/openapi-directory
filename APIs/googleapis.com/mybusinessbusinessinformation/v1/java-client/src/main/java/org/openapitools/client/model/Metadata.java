/*
 * My Business Business Information API
 * The My Business Business Information API provides an interface for managing business information. Note - If you have a quota of 0 after enabling the API, please request for GBP API access.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Additional non-user-editable information about the location.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:19.282285-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Metadata {
  public static final String SERIALIZED_NAME_CAN_DELETE = "canDelete";
  @SerializedName(SERIALIZED_NAME_CAN_DELETE)
  private Boolean canDelete;

  public static final String SERIALIZED_NAME_CAN_HAVE_BUSINESS_CALLS = "canHaveBusinessCalls";
  @SerializedName(SERIALIZED_NAME_CAN_HAVE_BUSINESS_CALLS)
  private Boolean canHaveBusinessCalls;

  public static final String SERIALIZED_NAME_CAN_HAVE_FOOD_MENUS = "canHaveFoodMenus";
  @SerializedName(SERIALIZED_NAME_CAN_HAVE_FOOD_MENUS)
  private Boolean canHaveFoodMenus;

  public static final String SERIALIZED_NAME_CAN_MODIFY_SERVICE_LIST = "canModifyServiceList";
  @SerializedName(SERIALIZED_NAME_CAN_MODIFY_SERVICE_LIST)
  private Boolean canModifyServiceList;

  public static final String SERIALIZED_NAME_CAN_OPERATE_HEALTH_DATA = "canOperateHealthData";
  @SerializedName(SERIALIZED_NAME_CAN_OPERATE_HEALTH_DATA)
  private Boolean canOperateHealthData;

  public static final String SERIALIZED_NAME_CAN_OPERATE_LOCAL_POST = "canOperateLocalPost";
  @SerializedName(SERIALIZED_NAME_CAN_OPERATE_LOCAL_POST)
  private Boolean canOperateLocalPost;

  public static final String SERIALIZED_NAME_CAN_OPERATE_LODGING_DATA = "canOperateLodgingData";
  @SerializedName(SERIALIZED_NAME_CAN_OPERATE_LODGING_DATA)
  private Boolean canOperateLodgingData;

  public static final String SERIALIZED_NAME_DUPLICATE_LOCATION = "duplicateLocation";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_LOCATION)
  private String duplicateLocation;

  public static final String SERIALIZED_NAME_HAS_GOOGLE_UPDATED = "hasGoogleUpdated";
  @SerializedName(SERIALIZED_NAME_HAS_GOOGLE_UPDATED)
  private Boolean hasGoogleUpdated;

  public static final String SERIALIZED_NAME_HAS_PENDING_EDITS = "hasPendingEdits";
  @SerializedName(SERIALIZED_NAME_HAS_PENDING_EDITS)
  private Boolean hasPendingEdits;

  public static final String SERIALIZED_NAME_HAS_VOICE_OF_MERCHANT = "hasVoiceOfMerchant";
  @SerializedName(SERIALIZED_NAME_HAS_VOICE_OF_MERCHANT)
  private Boolean hasVoiceOfMerchant;

  public static final String SERIALIZED_NAME_MAPS_URI = "mapsUri";
  @SerializedName(SERIALIZED_NAME_MAPS_URI)
  private String mapsUri;

  public static final String SERIALIZED_NAME_NEW_REVIEW_URI = "newReviewUri";
  @SerializedName(SERIALIZED_NAME_NEW_REVIEW_URI)
  private String newReviewUri;

  public static final String SERIALIZED_NAME_PLACE_ID = "placeId";
  @SerializedName(SERIALIZED_NAME_PLACE_ID)
  private String placeId;

  public Metadata() {
  }

  public Metadata(
     Boolean canDelete, 
     Boolean canHaveBusinessCalls, 
     Boolean canHaveFoodMenus, 
     Boolean canModifyServiceList, 
     Boolean canOperateHealthData, 
     Boolean canOperateLocalPost, 
     Boolean canOperateLodgingData, 
     String duplicateLocation, 
     Boolean hasGoogleUpdated, 
     Boolean hasPendingEdits, 
     Boolean hasVoiceOfMerchant, 
     String mapsUri, 
     String newReviewUri, 
     String placeId
  ) {
    this();
    this.canDelete = canDelete;
    this.canHaveBusinessCalls = canHaveBusinessCalls;
    this.canHaveFoodMenus = canHaveFoodMenus;
    this.canModifyServiceList = canModifyServiceList;
    this.canOperateHealthData = canOperateHealthData;
    this.canOperateLocalPost = canOperateLocalPost;
    this.canOperateLodgingData = canOperateLodgingData;
    this.duplicateLocation = duplicateLocation;
    this.hasGoogleUpdated = hasGoogleUpdated;
    this.hasPendingEdits = hasPendingEdits;
    this.hasVoiceOfMerchant = hasVoiceOfMerchant;
    this.mapsUri = mapsUri;
    this.newReviewUri = newReviewUri;
    this.placeId = placeId;
  }

  /**
   * Output only. Indicates whether the location can be deleted using the API.
   * @return canDelete
   */
  @javax.annotation.Nullable
  public Boolean getCanDelete() {
    return canDelete;
  }



  /**
   * Output only. Indicates if the listing is eligible for business calls.
   * @return canHaveBusinessCalls
   */
  @javax.annotation.Nullable
  public Boolean getCanHaveBusinessCalls() {
    return canHaveBusinessCalls;
  }



  /**
   * Output only. Indicates if the listing is eligible for food menu.
   * @return canHaveFoodMenus
   */
  @javax.annotation.Nullable
  public Boolean getCanHaveFoodMenus() {
    return canHaveFoodMenus;
  }



  /**
   * Output only. Indicates if the listing can modify the service list.
   * @return canModifyServiceList
   */
  @javax.annotation.Nullable
  public Boolean getCanModifyServiceList() {
    return canModifyServiceList;
  }



  /**
   * Output only. Indicates whether the location can operate on Health data.
   * @return canOperateHealthData
   */
  @javax.annotation.Nullable
  public Boolean getCanOperateHealthData() {
    return canOperateHealthData;
  }



  /**
   * Output only. Indicates if the listing can manage local posts.
   * @return canOperateLocalPost
   */
  @javax.annotation.Nullable
  public Boolean getCanOperateLocalPost() {
    return canOperateLocalPost;
  }



  /**
   * Output only. Indicates whether the location can operate on Lodging data.
   * @return canOperateLodgingData
   */
  @javax.annotation.Nullable
  public Boolean getCanOperateLodgingData() {
    return canOperateLodgingData;
  }



  /**
   * Output only. The location resource that this location duplicates.
   * @return duplicateLocation
   */
  @javax.annotation.Nullable
  public String getDuplicateLocation() {
    return duplicateLocation;
  }



  /**
   * Output only. Indicates whether the place ID associated with this location has updates that need to be updated or rejected by the client. If this boolean is set, you should call the &#x60;getGoogleUpdated&#x60; method to lookup information that&#39;s needs to be verified.
   * @return hasGoogleUpdated
   */
  @javax.annotation.Nullable
  public Boolean getHasGoogleUpdated() {
    return hasGoogleUpdated;
  }



  /**
   * Output only. Indicates whether any of this Location&#39;s properties are in the edit pending state.
   * @return hasPendingEdits
   */
  @javax.annotation.Nullable
  public Boolean getHasPendingEdits() {
    return hasPendingEdits;
  }



  /**
   * Output only. Indicates if the listing has Voice of Merchant. If this boolean is false, you should call the locations.getVoiceOfMerchantState API to get details as to why they do not have Voice of Merchant.
   * @return hasVoiceOfMerchant
   */
  @javax.annotation.Nullable
  public Boolean getHasVoiceOfMerchant() {
    return hasVoiceOfMerchant;
  }



  /**
   * Output only. A link to the location on Maps.
   * @return mapsUri
   */
  @javax.annotation.Nullable
  public String getMapsUri() {
    return mapsUri;
  }



  /**
   * Output only. A link to the page on Google Search where a customer can leave a review for the location.
   * @return newReviewUri
   */
  @javax.annotation.Nullable
  public String getNewReviewUri() {
    return newReviewUri;
  }



  /**
   * Output only. If this locationappears on Google Maps, this field is populated with the place ID for the location. This ID can be used in various Places APIs. This field can be set during Create calls, but not for Update.
   * @return placeId
   */
  @javax.annotation.Nullable
  public String getPlaceId() {
    return placeId;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Metadata metadata = (Metadata) o;
    return Objects.equals(this.canDelete, metadata.canDelete) &&
        Objects.equals(this.canHaveBusinessCalls, metadata.canHaveBusinessCalls) &&
        Objects.equals(this.canHaveFoodMenus, metadata.canHaveFoodMenus) &&
        Objects.equals(this.canModifyServiceList, metadata.canModifyServiceList) &&
        Objects.equals(this.canOperateHealthData, metadata.canOperateHealthData) &&
        Objects.equals(this.canOperateLocalPost, metadata.canOperateLocalPost) &&
        Objects.equals(this.canOperateLodgingData, metadata.canOperateLodgingData) &&
        Objects.equals(this.duplicateLocation, metadata.duplicateLocation) &&
        Objects.equals(this.hasGoogleUpdated, metadata.hasGoogleUpdated) &&
        Objects.equals(this.hasPendingEdits, metadata.hasPendingEdits) &&
        Objects.equals(this.hasVoiceOfMerchant, metadata.hasVoiceOfMerchant) &&
        Objects.equals(this.mapsUri, metadata.mapsUri) &&
        Objects.equals(this.newReviewUri, metadata.newReviewUri) &&
        Objects.equals(this.placeId, metadata.placeId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(canDelete, canHaveBusinessCalls, canHaveFoodMenus, canModifyServiceList, canOperateHealthData, canOperateLocalPost, canOperateLodgingData, duplicateLocation, hasGoogleUpdated, hasPendingEdits, hasVoiceOfMerchant, mapsUri, newReviewUri, placeId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Metadata {\n");
    sb.append("    canDelete: ").append(toIndentedString(canDelete)).append("\n");
    sb.append("    canHaveBusinessCalls: ").append(toIndentedString(canHaveBusinessCalls)).append("\n");
    sb.append("    canHaveFoodMenus: ").append(toIndentedString(canHaveFoodMenus)).append("\n");
    sb.append("    canModifyServiceList: ").append(toIndentedString(canModifyServiceList)).append("\n");
    sb.append("    canOperateHealthData: ").append(toIndentedString(canOperateHealthData)).append("\n");
    sb.append("    canOperateLocalPost: ").append(toIndentedString(canOperateLocalPost)).append("\n");
    sb.append("    canOperateLodgingData: ").append(toIndentedString(canOperateLodgingData)).append("\n");
    sb.append("    duplicateLocation: ").append(toIndentedString(duplicateLocation)).append("\n");
    sb.append("    hasGoogleUpdated: ").append(toIndentedString(hasGoogleUpdated)).append("\n");
    sb.append("    hasPendingEdits: ").append(toIndentedString(hasPendingEdits)).append("\n");
    sb.append("    hasVoiceOfMerchant: ").append(toIndentedString(hasVoiceOfMerchant)).append("\n");
    sb.append("    mapsUri: ").append(toIndentedString(mapsUri)).append("\n");
    sb.append("    newReviewUri: ").append(toIndentedString(newReviewUri)).append("\n");
    sb.append("    placeId: ").append(toIndentedString(placeId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("canDelete");
    openapiFields.add("canHaveBusinessCalls");
    openapiFields.add("canHaveFoodMenus");
    openapiFields.add("canModifyServiceList");
    openapiFields.add("canOperateHealthData");
    openapiFields.add("canOperateLocalPost");
    openapiFields.add("canOperateLodgingData");
    openapiFields.add("duplicateLocation");
    openapiFields.add("hasGoogleUpdated");
    openapiFields.add("hasPendingEdits");
    openapiFields.add("hasVoiceOfMerchant");
    openapiFields.add("mapsUri");
    openapiFields.add("newReviewUri");
    openapiFields.add("placeId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Metadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Metadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Metadata is not found in the empty JSON string", Metadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Metadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Metadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("duplicateLocation") != null && !jsonObj.get("duplicateLocation").isJsonNull()) && !jsonObj.get("duplicateLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `duplicateLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("duplicateLocation").toString()));
      }
      if ((jsonObj.get("mapsUri") != null && !jsonObj.get("mapsUri").isJsonNull()) && !jsonObj.get("mapsUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapsUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapsUri").toString()));
      }
      if ((jsonObj.get("newReviewUri") != null && !jsonObj.get("newReviewUri").isJsonNull()) && !jsonObj.get("newReviewUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `newReviewUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("newReviewUri").toString()));
      }
      if ((jsonObj.get("placeId") != null && !jsonObj.get("placeId").isJsonNull()) && !jsonObj.get("placeId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `placeId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("placeId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Metadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Metadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Metadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Metadata.class));

       return (TypeAdapter<T>) new TypeAdapter<Metadata>() {
           @Override
           public void write(JsonWriter out, Metadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Metadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Metadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Metadata
   * @throws IOException if the JSON string is invalid with respect to Metadata
   */
  public static Metadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Metadata.class);
  }

  /**
   * Convert an instance of Metadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

