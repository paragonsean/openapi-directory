/*
 * Cloud Dataproc API
 * Manages Hadoop-based clusters and jobs on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A request to resize a node group.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:50.925918-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ResizeNodeGroupRequest {
  public static final String SERIALIZED_NAME_GRACEFUL_DECOMMISSION_TIMEOUT = "gracefulDecommissionTimeout";
  @SerializedName(SERIALIZED_NAME_GRACEFUL_DECOMMISSION_TIMEOUT)
  private String gracefulDecommissionTimeout;

  public static final String SERIALIZED_NAME_PARENT_OPERATION_ID = "parentOperationId";
  @SerializedName(SERIALIZED_NAME_PARENT_OPERATION_ID)
  private String parentOperationId;

  public static final String SERIALIZED_NAME_REQUEST_ID = "requestId";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private Integer size;

  public ResizeNodeGroupRequest() {
  }

  public ResizeNodeGroupRequest gracefulDecommissionTimeout(String gracefulDecommissionTimeout) {
    this.gracefulDecommissionTimeout = gracefulDecommissionTimeout;
    return this;
  }

  /**
   * Optional. Timeout for graceful YARN decommissioning. Graceful decommissioning (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/scaling-clusters#graceful_decommissioning) allows the removal of nodes from the Compute Engine node group without interrupting jobs in progress. This timeout specifies how long to wait for jobs in progress to finish before forcefully removing nodes (and potentially interrupting jobs). Default timeout is 0 (for forceful decommission), and the maximum allowed timeout is 1 day. (see JSON representation of Duration (https://developers.google.com/protocol-buffers/docs/proto3#json)).Only supported on Dataproc image versions 1.2 and higher.
   * @return gracefulDecommissionTimeout
   */
  @javax.annotation.Nullable
  public String getGracefulDecommissionTimeout() {
    return gracefulDecommissionTimeout;
  }

  public void setGracefulDecommissionTimeout(String gracefulDecommissionTimeout) {
    this.gracefulDecommissionTimeout = gracefulDecommissionTimeout;
  }


  public ResizeNodeGroupRequest parentOperationId(String parentOperationId) {
    this.parentOperationId = parentOperationId;
    return this;
  }

  /**
   * Optional. operation id of the parent operation sending the resize request
   * @return parentOperationId
   */
  @javax.annotation.Nullable
  public String getParentOperationId() {
    return parentOperationId;
  }

  public void setParentOperationId(String parentOperationId) {
    this.parentOperationId = parentOperationId;
  }


  public ResizeNodeGroupRequest requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

  /**
   * Optional. A unique ID used to identify the request. If the server receives two ResizeNodeGroupRequest (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.ResizeNodeGroupRequests) with the same ID, the second request is ignored and the first google.longrunning.Operation created and stored in the backend is returned.Recommendation: Set this value to a UUID (https://en.wikipedia.org/wiki/Universally_unique_identifier).The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). The maximum length is 40 characters.
   * @return requestId
   */
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public ResizeNodeGroupRequest size(Integer size) {
    this.size = size;
    return this;
  }

  /**
   * Required. The number of running instances for the node group to maintain. The group adds or removes instances to maintain the number of instances specified by this parameter.
   * @return size
   */
  @javax.annotation.Nullable
  public Integer getSize() {
    return size;
  }

  public void setSize(Integer size) {
    this.size = size;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResizeNodeGroupRequest resizeNodeGroupRequest = (ResizeNodeGroupRequest) o;
    return Objects.equals(this.gracefulDecommissionTimeout, resizeNodeGroupRequest.gracefulDecommissionTimeout) &&
        Objects.equals(this.parentOperationId, resizeNodeGroupRequest.parentOperationId) &&
        Objects.equals(this.requestId, resizeNodeGroupRequest.requestId) &&
        Objects.equals(this.size, resizeNodeGroupRequest.size);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gracefulDecommissionTimeout, parentOperationId, requestId, size);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResizeNodeGroupRequest {\n");
    sb.append("    gracefulDecommissionTimeout: ").append(toIndentedString(gracefulDecommissionTimeout)).append("\n");
    sb.append("    parentOperationId: ").append(toIndentedString(parentOperationId)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("gracefulDecommissionTimeout");
    openapiFields.add("parentOperationId");
    openapiFields.add("requestId");
    openapiFields.add("size");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ResizeNodeGroupRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ResizeNodeGroupRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ResizeNodeGroupRequest is not found in the empty JSON string", ResizeNodeGroupRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ResizeNodeGroupRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ResizeNodeGroupRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("gracefulDecommissionTimeout") != null && !jsonObj.get("gracefulDecommissionTimeout").isJsonNull()) && !jsonObj.get("gracefulDecommissionTimeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gracefulDecommissionTimeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gracefulDecommissionTimeout").toString()));
      }
      if ((jsonObj.get("parentOperationId") != null && !jsonObj.get("parentOperationId").isJsonNull()) && !jsonObj.get("parentOperationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentOperationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parentOperationId").toString()));
      }
      if ((jsonObj.get("requestId") != null && !jsonObj.get("requestId").isJsonNull()) && !jsonObj.get("requestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ResizeNodeGroupRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ResizeNodeGroupRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ResizeNodeGroupRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ResizeNodeGroupRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ResizeNodeGroupRequest>() {
           @Override
           public void write(JsonWriter out, ResizeNodeGroupRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ResizeNodeGroupRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ResizeNodeGroupRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ResizeNodeGroupRequest
   * @throws IOException if the JSON string is invalid with respect to ResizeNodeGroupRequest
   */
  public static ResizeNodeGroupRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ResizeNodeGroupRequest.class);
  }

  /**
   * Convert an instance of ResizeNodeGroupRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

