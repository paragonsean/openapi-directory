/*
 * Cloud Dataproc API
 * Manages Hadoop-based clusters and jobs on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies Kerberos related configuration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:50.925918-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class KerberosConfig {
  public static final String SERIALIZED_NAME_CROSS_REALM_TRUST_ADMIN_SERVER = "crossRealmTrustAdminServer";
  @SerializedName(SERIALIZED_NAME_CROSS_REALM_TRUST_ADMIN_SERVER)
  private String crossRealmTrustAdminServer;

  public static final String SERIALIZED_NAME_CROSS_REALM_TRUST_KDC = "crossRealmTrustKdc";
  @SerializedName(SERIALIZED_NAME_CROSS_REALM_TRUST_KDC)
  private String crossRealmTrustKdc;

  public static final String SERIALIZED_NAME_CROSS_REALM_TRUST_REALM = "crossRealmTrustRealm";
  @SerializedName(SERIALIZED_NAME_CROSS_REALM_TRUST_REALM)
  private String crossRealmTrustRealm;

  public static final String SERIALIZED_NAME_CROSS_REALM_TRUST_SHARED_PASSWORD_URI = "crossRealmTrustSharedPasswordUri";
  @SerializedName(SERIALIZED_NAME_CROSS_REALM_TRUST_SHARED_PASSWORD_URI)
  private String crossRealmTrustSharedPasswordUri;

  public static final String SERIALIZED_NAME_ENABLE_KERBEROS = "enableKerberos";
  @SerializedName(SERIALIZED_NAME_ENABLE_KERBEROS)
  private Boolean enableKerberos;

  public static final String SERIALIZED_NAME_KDC_DB_KEY_URI = "kdcDbKeyUri";
  @SerializedName(SERIALIZED_NAME_KDC_DB_KEY_URI)
  private String kdcDbKeyUri;

  public static final String SERIALIZED_NAME_KEY_PASSWORD_URI = "keyPasswordUri";
  @SerializedName(SERIALIZED_NAME_KEY_PASSWORD_URI)
  private String keyPasswordUri;

  public static final String SERIALIZED_NAME_KEYSTORE_PASSWORD_URI = "keystorePasswordUri";
  @SerializedName(SERIALIZED_NAME_KEYSTORE_PASSWORD_URI)
  private String keystorePasswordUri;

  public static final String SERIALIZED_NAME_KEYSTORE_URI = "keystoreUri";
  @SerializedName(SERIALIZED_NAME_KEYSTORE_URI)
  private String keystoreUri;

  public static final String SERIALIZED_NAME_KMS_KEY_URI = "kmsKeyUri";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_URI)
  private String kmsKeyUri;

  public static final String SERIALIZED_NAME_REALM = "realm";
  @SerializedName(SERIALIZED_NAME_REALM)
  private String realm;

  public static final String SERIALIZED_NAME_ROOT_PRINCIPAL_PASSWORD_URI = "rootPrincipalPasswordUri";
  @SerializedName(SERIALIZED_NAME_ROOT_PRINCIPAL_PASSWORD_URI)
  private String rootPrincipalPasswordUri;

  public static final String SERIALIZED_NAME_TGT_LIFETIME_HOURS = "tgtLifetimeHours";
  @SerializedName(SERIALIZED_NAME_TGT_LIFETIME_HOURS)
  private Integer tgtLifetimeHours;

  public static final String SERIALIZED_NAME_TRUSTSTORE_PASSWORD_URI = "truststorePasswordUri";
  @SerializedName(SERIALIZED_NAME_TRUSTSTORE_PASSWORD_URI)
  private String truststorePasswordUri;

  public static final String SERIALIZED_NAME_TRUSTSTORE_URI = "truststoreUri";
  @SerializedName(SERIALIZED_NAME_TRUSTSTORE_URI)
  private String truststoreUri;

  public KerberosConfig() {
  }

  public KerberosConfig crossRealmTrustAdminServer(String crossRealmTrustAdminServer) {
    this.crossRealmTrustAdminServer = crossRealmTrustAdminServer;
    return this;
  }

  /**
   * Optional. The admin server (IP or hostname) for the remote trusted realm in a cross realm trust relationship.
   * @return crossRealmTrustAdminServer
   */
  @javax.annotation.Nullable
  public String getCrossRealmTrustAdminServer() {
    return crossRealmTrustAdminServer;
  }

  public void setCrossRealmTrustAdminServer(String crossRealmTrustAdminServer) {
    this.crossRealmTrustAdminServer = crossRealmTrustAdminServer;
  }


  public KerberosConfig crossRealmTrustKdc(String crossRealmTrustKdc) {
    this.crossRealmTrustKdc = crossRealmTrustKdc;
    return this;
  }

  /**
   * Optional. The KDC (IP or hostname) for the remote trusted realm in a cross realm trust relationship.
   * @return crossRealmTrustKdc
   */
  @javax.annotation.Nullable
  public String getCrossRealmTrustKdc() {
    return crossRealmTrustKdc;
  }

  public void setCrossRealmTrustKdc(String crossRealmTrustKdc) {
    this.crossRealmTrustKdc = crossRealmTrustKdc;
  }


  public KerberosConfig crossRealmTrustRealm(String crossRealmTrustRealm) {
    this.crossRealmTrustRealm = crossRealmTrustRealm;
    return this;
  }

  /**
   * Optional. The remote realm the Dataproc on-cluster KDC will trust, should the user enable cross realm trust.
   * @return crossRealmTrustRealm
   */
  @javax.annotation.Nullable
  public String getCrossRealmTrustRealm() {
    return crossRealmTrustRealm;
  }

  public void setCrossRealmTrustRealm(String crossRealmTrustRealm) {
    this.crossRealmTrustRealm = crossRealmTrustRealm;
  }


  public KerberosConfig crossRealmTrustSharedPasswordUri(String crossRealmTrustSharedPasswordUri) {
    this.crossRealmTrustSharedPasswordUri = crossRealmTrustSharedPasswordUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the shared password between the on-cluster Kerberos realm and the remote trusted realm, in a cross realm trust relationship.
   * @return crossRealmTrustSharedPasswordUri
   */
  @javax.annotation.Nullable
  public String getCrossRealmTrustSharedPasswordUri() {
    return crossRealmTrustSharedPasswordUri;
  }

  public void setCrossRealmTrustSharedPasswordUri(String crossRealmTrustSharedPasswordUri) {
    this.crossRealmTrustSharedPasswordUri = crossRealmTrustSharedPasswordUri;
  }


  public KerberosConfig enableKerberos(Boolean enableKerberos) {
    this.enableKerberos = enableKerberos;
    return this;
  }

  /**
   * Optional. Flag to indicate whether to Kerberize the cluster (default: false). Set this field to true to enable Kerberos on a cluster.
   * @return enableKerberos
   */
  @javax.annotation.Nullable
  public Boolean getEnableKerberos() {
    return enableKerberos;
  }

  public void setEnableKerberos(Boolean enableKerberos) {
    this.enableKerberos = enableKerberos;
  }


  public KerberosConfig kdcDbKeyUri(String kdcDbKeyUri) {
    this.kdcDbKeyUri = kdcDbKeyUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the master key of the KDC database.
   * @return kdcDbKeyUri
   */
  @javax.annotation.Nullable
  public String getKdcDbKeyUri() {
    return kdcDbKeyUri;
  }

  public void setKdcDbKeyUri(String kdcDbKeyUri) {
    this.kdcDbKeyUri = kdcDbKeyUri;
  }


  public KerberosConfig keyPasswordUri(String keyPasswordUri) {
    this.keyPasswordUri = keyPasswordUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided key. For the self-signed certificate, this password is generated by Dataproc.
   * @return keyPasswordUri
   */
  @javax.annotation.Nullable
  public String getKeyPasswordUri() {
    return keyPasswordUri;
  }

  public void setKeyPasswordUri(String keyPasswordUri) {
    this.keyPasswordUri = keyPasswordUri;
  }


  public KerberosConfig keystorePasswordUri(String keystorePasswordUri) {
    this.keystorePasswordUri = keystorePasswordUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided keystore. For the self-signed certificate, this password is generated by Dataproc.
   * @return keystorePasswordUri
   */
  @javax.annotation.Nullable
  public String getKeystorePasswordUri() {
    return keystorePasswordUri;
  }

  public void setKeystorePasswordUri(String keystorePasswordUri) {
    this.keystorePasswordUri = keystorePasswordUri;
  }


  public KerberosConfig keystoreUri(String keystoreUri) {
    this.keystoreUri = keystoreUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of the keystore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
   * @return keystoreUri
   */
  @javax.annotation.Nullable
  public String getKeystoreUri() {
    return keystoreUri;
  }

  public void setKeystoreUri(String keystoreUri) {
    this.keystoreUri = keystoreUri;
  }


  public KerberosConfig kmsKeyUri(String kmsKeyUri) {
    this.kmsKeyUri = kmsKeyUri;
    return this;
  }

  /**
   * Optional. The URI of the KMS key used to encrypt sensitive files.
   * @return kmsKeyUri
   */
  @javax.annotation.Nullable
  public String getKmsKeyUri() {
    return kmsKeyUri;
  }

  public void setKmsKeyUri(String kmsKeyUri) {
    this.kmsKeyUri = kmsKeyUri;
  }


  public KerberosConfig realm(String realm) {
    this.realm = realm;
    return this;
  }

  /**
   * Optional. The name of the on-cluster Kerberos realm. If not specified, the uppercased domain of hostnames will be the realm.
   * @return realm
   */
  @javax.annotation.Nullable
  public String getRealm() {
    return realm;
  }

  public void setRealm(String realm) {
    this.realm = realm;
  }


  public KerberosConfig rootPrincipalPasswordUri(String rootPrincipalPasswordUri) {
    this.rootPrincipalPasswordUri = rootPrincipalPasswordUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the root principal password.
   * @return rootPrincipalPasswordUri
   */
  @javax.annotation.Nullable
  public String getRootPrincipalPasswordUri() {
    return rootPrincipalPasswordUri;
  }

  public void setRootPrincipalPasswordUri(String rootPrincipalPasswordUri) {
    this.rootPrincipalPasswordUri = rootPrincipalPasswordUri;
  }


  public KerberosConfig tgtLifetimeHours(Integer tgtLifetimeHours) {
    this.tgtLifetimeHours = tgtLifetimeHours;
    return this;
  }

  /**
   * Optional. The lifetime of the ticket granting ticket, in hours. If not specified, or user specifies 0, then default value 10 will be used.
   * @return tgtLifetimeHours
   */
  @javax.annotation.Nullable
  public Integer getTgtLifetimeHours() {
    return tgtLifetimeHours;
  }

  public void setTgtLifetimeHours(Integer tgtLifetimeHours) {
    this.tgtLifetimeHours = tgtLifetimeHours;
  }


  public KerberosConfig truststorePasswordUri(String truststorePasswordUri) {
    this.truststorePasswordUri = truststorePasswordUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided truststore. For the self-signed certificate, this password is generated by Dataproc.
   * @return truststorePasswordUri
   */
  @javax.annotation.Nullable
  public String getTruststorePasswordUri() {
    return truststorePasswordUri;
  }

  public void setTruststorePasswordUri(String truststorePasswordUri) {
    this.truststorePasswordUri = truststorePasswordUri;
  }


  public KerberosConfig truststoreUri(String truststoreUri) {
    this.truststoreUri = truststoreUri;
    return this;
  }

  /**
   * Optional. The Cloud Storage URI of the truststore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
   * @return truststoreUri
   */
  @javax.annotation.Nullable
  public String getTruststoreUri() {
    return truststoreUri;
  }

  public void setTruststoreUri(String truststoreUri) {
    this.truststoreUri = truststoreUri;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KerberosConfig kerberosConfig = (KerberosConfig) o;
    return Objects.equals(this.crossRealmTrustAdminServer, kerberosConfig.crossRealmTrustAdminServer) &&
        Objects.equals(this.crossRealmTrustKdc, kerberosConfig.crossRealmTrustKdc) &&
        Objects.equals(this.crossRealmTrustRealm, kerberosConfig.crossRealmTrustRealm) &&
        Objects.equals(this.crossRealmTrustSharedPasswordUri, kerberosConfig.crossRealmTrustSharedPasswordUri) &&
        Objects.equals(this.enableKerberos, kerberosConfig.enableKerberos) &&
        Objects.equals(this.kdcDbKeyUri, kerberosConfig.kdcDbKeyUri) &&
        Objects.equals(this.keyPasswordUri, kerberosConfig.keyPasswordUri) &&
        Objects.equals(this.keystorePasswordUri, kerberosConfig.keystorePasswordUri) &&
        Objects.equals(this.keystoreUri, kerberosConfig.keystoreUri) &&
        Objects.equals(this.kmsKeyUri, kerberosConfig.kmsKeyUri) &&
        Objects.equals(this.realm, kerberosConfig.realm) &&
        Objects.equals(this.rootPrincipalPasswordUri, kerberosConfig.rootPrincipalPasswordUri) &&
        Objects.equals(this.tgtLifetimeHours, kerberosConfig.tgtLifetimeHours) &&
        Objects.equals(this.truststorePasswordUri, kerberosConfig.truststorePasswordUri) &&
        Objects.equals(this.truststoreUri, kerberosConfig.truststoreUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(crossRealmTrustAdminServer, crossRealmTrustKdc, crossRealmTrustRealm, crossRealmTrustSharedPasswordUri, enableKerberos, kdcDbKeyUri, keyPasswordUri, keystorePasswordUri, keystoreUri, kmsKeyUri, realm, rootPrincipalPasswordUri, tgtLifetimeHours, truststorePasswordUri, truststoreUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KerberosConfig {\n");
    sb.append("    crossRealmTrustAdminServer: ").append(toIndentedString(crossRealmTrustAdminServer)).append("\n");
    sb.append("    crossRealmTrustKdc: ").append(toIndentedString(crossRealmTrustKdc)).append("\n");
    sb.append("    crossRealmTrustRealm: ").append(toIndentedString(crossRealmTrustRealm)).append("\n");
    sb.append("    crossRealmTrustSharedPasswordUri: ").append(toIndentedString(crossRealmTrustSharedPasswordUri)).append("\n");
    sb.append("    enableKerberos: ").append(toIndentedString(enableKerberos)).append("\n");
    sb.append("    kdcDbKeyUri: ").append(toIndentedString(kdcDbKeyUri)).append("\n");
    sb.append("    keyPasswordUri: ").append(toIndentedString(keyPasswordUri)).append("\n");
    sb.append("    keystorePasswordUri: ").append(toIndentedString(keystorePasswordUri)).append("\n");
    sb.append("    keystoreUri: ").append(toIndentedString(keystoreUri)).append("\n");
    sb.append("    kmsKeyUri: ").append(toIndentedString(kmsKeyUri)).append("\n");
    sb.append("    realm: ").append(toIndentedString(realm)).append("\n");
    sb.append("    rootPrincipalPasswordUri: ").append(toIndentedString(rootPrincipalPasswordUri)).append("\n");
    sb.append("    tgtLifetimeHours: ").append(toIndentedString(tgtLifetimeHours)).append("\n");
    sb.append("    truststorePasswordUri: ").append(toIndentedString(truststorePasswordUri)).append("\n");
    sb.append("    truststoreUri: ").append(toIndentedString(truststoreUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("crossRealmTrustAdminServer");
    openapiFields.add("crossRealmTrustKdc");
    openapiFields.add("crossRealmTrustRealm");
    openapiFields.add("crossRealmTrustSharedPasswordUri");
    openapiFields.add("enableKerberos");
    openapiFields.add("kdcDbKeyUri");
    openapiFields.add("keyPasswordUri");
    openapiFields.add("keystorePasswordUri");
    openapiFields.add("keystoreUri");
    openapiFields.add("kmsKeyUri");
    openapiFields.add("realm");
    openapiFields.add("rootPrincipalPasswordUri");
    openapiFields.add("tgtLifetimeHours");
    openapiFields.add("truststorePasswordUri");
    openapiFields.add("truststoreUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to KerberosConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!KerberosConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in KerberosConfig is not found in the empty JSON string", KerberosConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!KerberosConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `KerberosConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("crossRealmTrustAdminServer") != null && !jsonObj.get("crossRealmTrustAdminServer").isJsonNull()) && !jsonObj.get("crossRealmTrustAdminServer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossRealmTrustAdminServer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossRealmTrustAdminServer").toString()));
      }
      if ((jsonObj.get("crossRealmTrustKdc") != null && !jsonObj.get("crossRealmTrustKdc").isJsonNull()) && !jsonObj.get("crossRealmTrustKdc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossRealmTrustKdc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossRealmTrustKdc").toString()));
      }
      if ((jsonObj.get("crossRealmTrustRealm") != null && !jsonObj.get("crossRealmTrustRealm").isJsonNull()) && !jsonObj.get("crossRealmTrustRealm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossRealmTrustRealm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossRealmTrustRealm").toString()));
      }
      if ((jsonObj.get("crossRealmTrustSharedPasswordUri") != null && !jsonObj.get("crossRealmTrustSharedPasswordUri").isJsonNull()) && !jsonObj.get("crossRealmTrustSharedPasswordUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossRealmTrustSharedPasswordUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossRealmTrustSharedPasswordUri").toString()));
      }
      if ((jsonObj.get("kdcDbKeyUri") != null && !jsonObj.get("kdcDbKeyUri").isJsonNull()) && !jsonObj.get("kdcDbKeyUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kdcDbKeyUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kdcDbKeyUri").toString()));
      }
      if ((jsonObj.get("keyPasswordUri") != null && !jsonObj.get("keyPasswordUri").isJsonNull()) && !jsonObj.get("keyPasswordUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keyPasswordUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keyPasswordUri").toString()));
      }
      if ((jsonObj.get("keystorePasswordUri") != null && !jsonObj.get("keystorePasswordUri").isJsonNull()) && !jsonObj.get("keystorePasswordUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keystorePasswordUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keystorePasswordUri").toString()));
      }
      if ((jsonObj.get("keystoreUri") != null && !jsonObj.get("keystoreUri").isJsonNull()) && !jsonObj.get("keystoreUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keystoreUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keystoreUri").toString()));
      }
      if ((jsonObj.get("kmsKeyUri") != null && !jsonObj.get("kmsKeyUri").isJsonNull()) && !jsonObj.get("kmsKeyUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKeyUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKeyUri").toString()));
      }
      if ((jsonObj.get("realm") != null && !jsonObj.get("realm").isJsonNull()) && !jsonObj.get("realm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `realm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("realm").toString()));
      }
      if ((jsonObj.get("rootPrincipalPasswordUri") != null && !jsonObj.get("rootPrincipalPasswordUri").isJsonNull()) && !jsonObj.get("rootPrincipalPasswordUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rootPrincipalPasswordUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rootPrincipalPasswordUri").toString()));
      }
      if ((jsonObj.get("truststorePasswordUri") != null && !jsonObj.get("truststorePasswordUri").isJsonNull()) && !jsonObj.get("truststorePasswordUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `truststorePasswordUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("truststorePasswordUri").toString()));
      }
      if ((jsonObj.get("truststoreUri") != null && !jsonObj.get("truststoreUri").isJsonNull()) && !jsonObj.get("truststoreUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `truststoreUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("truststoreUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!KerberosConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'KerberosConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<KerberosConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(KerberosConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<KerberosConfig>() {
           @Override
           public void write(JsonWriter out, KerberosConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public KerberosConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of KerberosConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of KerberosConfig
   * @throws IOException if the JSON string is invalid with respect to KerberosConfig
   */
  public static KerberosConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, KerberosConfig.class);
  }

  /**
   * Convert an instance of KerberosConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

