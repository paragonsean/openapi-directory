/*
 * Cloud Dataproc API
 * Manages Hadoop-based clusters and jobs on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ConfidentialInstanceConfig;
import org.openapitools.client.model.NodeGroupAffinity;
import org.openapitools.client.model.ReservationAffinity;
import org.openapitools.client.model.ShieldedInstanceConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Common config settings for resources of Compute Engine cluster instances, applicable to all instances in the cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:50.925918-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GceClusterConfig {
  public static final String SERIALIZED_NAME_CONFIDENTIAL_INSTANCE_CONFIG = "confidentialInstanceConfig";
  @SerializedName(SERIALIZED_NAME_CONFIDENTIAL_INSTANCE_CONFIG)
  private ConfidentialInstanceConfig confidentialInstanceConfig;

  public static final String SERIALIZED_NAME_INTERNAL_IP_ONLY = "internalIpOnly";
  @SerializedName(SERIALIZED_NAME_INTERNAL_IP_ONLY)
  private Boolean internalIpOnly;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_NETWORK_URI = "networkUri";
  @SerializedName(SERIALIZED_NAME_NETWORK_URI)
  private String networkUri;

  public static final String SERIALIZED_NAME_NODE_GROUP_AFFINITY = "nodeGroupAffinity";
  @SerializedName(SERIALIZED_NAME_NODE_GROUP_AFFINITY)
  private NodeGroupAffinity nodeGroupAffinity;

  /**
   * Optional. The type of IPv6 access for a cluster.
   */
  @JsonAdapter(PrivateIpv6GoogleAccessEnum.Adapter.class)
  public enum PrivateIpv6GoogleAccessEnum {
    PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED"),
    
    INHERIT_FROM_SUBNETWORK("INHERIT_FROM_SUBNETWORK"),
    
    OUTBOUND("OUTBOUND"),
    
    BIDIRECTIONAL("BIDIRECTIONAL");

    private String value;

    PrivateIpv6GoogleAccessEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PrivateIpv6GoogleAccessEnum fromValue(String value) {
      for (PrivateIpv6GoogleAccessEnum b : PrivateIpv6GoogleAccessEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PrivateIpv6GoogleAccessEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PrivateIpv6GoogleAccessEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PrivateIpv6GoogleAccessEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PrivateIpv6GoogleAccessEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PrivateIpv6GoogleAccessEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS = "privateIpv6GoogleAccess";
  @SerializedName(SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS)
  private PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess;

  public static final String SERIALIZED_NAME_RESERVATION_AFFINITY = "reservationAffinity";
  @SerializedName(SERIALIZED_NAME_RESERVATION_AFFINITY)
  private ReservationAffinity reservationAffinity;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES = "serviceAccountScopes";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES)
  private List<String> serviceAccountScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG = "shieldedInstanceConfig";
  @SerializedName(SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG)
  private ShieldedInstanceConfig shieldedInstanceConfig;

  public static final String SERIALIZED_NAME_SUBNETWORK_URI = "subnetworkUri";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK_URI)
  private String subnetworkUri;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_ZONE_URI = "zoneUri";
  @SerializedName(SERIALIZED_NAME_ZONE_URI)
  private String zoneUri;

  public GceClusterConfig() {
  }

  public GceClusterConfig confidentialInstanceConfig(ConfidentialInstanceConfig confidentialInstanceConfig) {
    this.confidentialInstanceConfig = confidentialInstanceConfig;
    return this;
  }

  /**
   * Get confidentialInstanceConfig
   * @return confidentialInstanceConfig
   */
  @javax.annotation.Nullable
  public ConfidentialInstanceConfig getConfidentialInstanceConfig() {
    return confidentialInstanceConfig;
  }

  public void setConfidentialInstanceConfig(ConfidentialInstanceConfig confidentialInstanceConfig) {
    this.confidentialInstanceConfig = confidentialInstanceConfig;
  }


  public GceClusterConfig internalIpOnly(Boolean internalIpOnly) {
    this.internalIpOnly = internalIpOnly;
    return this;
  }

  /**
   * Optional. If true, all instances in the cluster will only have internal IP addresses. By default, clusters are not restricted to internal IP addresses, and will have ephemeral external IP addresses assigned to each instance. This internal_ip_only restriction can only be enabled for subnetwork enabled networks, and all off-cluster dependencies must be configured to be accessible without external IP addresses.
   * @return internalIpOnly
   */
  @javax.annotation.Nullable
  public Boolean getInternalIpOnly() {
    return internalIpOnly;
  }

  public void setInternalIpOnly(Boolean internalIpOnly) {
    this.internalIpOnly = internalIpOnly;
  }


  public GceClusterConfig metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public GceClusterConfig putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Optional. The Compute Engine metadata entries to add to all instances (see Project and instance metadata (https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public GceClusterConfig networkUri(String networkUri) {
    this.networkUri = networkUri;
    return this;
  }

  /**
   * Optional. The Compute Engine network to be used for machine communications. Cannot be specified with subnetwork_uri. If neither network_uri nor subnetwork_uri is specified, the \&quot;default\&quot; network of the project is used, if it exists. Cannot be a \&quot;Custom Subnet Network\&quot; (see Using Subnetworks (https://cloud.google.com/compute/docs/subnetworks) for more information).A full URL, partial URI, or short name are valid. Examples: https://www.googleapis.com/compute/v1/projects/[project_id]/global/networks/default projects/[project_id]/global/networks/default default
   * @return networkUri
   */
  @javax.annotation.Nullable
  public String getNetworkUri() {
    return networkUri;
  }

  public void setNetworkUri(String networkUri) {
    this.networkUri = networkUri;
  }


  public GceClusterConfig nodeGroupAffinity(NodeGroupAffinity nodeGroupAffinity) {
    this.nodeGroupAffinity = nodeGroupAffinity;
    return this;
  }

  /**
   * Get nodeGroupAffinity
   * @return nodeGroupAffinity
   */
  @javax.annotation.Nullable
  public NodeGroupAffinity getNodeGroupAffinity() {
    return nodeGroupAffinity;
  }

  public void setNodeGroupAffinity(NodeGroupAffinity nodeGroupAffinity) {
    this.nodeGroupAffinity = nodeGroupAffinity;
  }


  public GceClusterConfig privateIpv6GoogleAccess(PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
    return this;
  }

  /**
   * Optional. The type of IPv6 access for a cluster.
   * @return privateIpv6GoogleAccess
   */
  @javax.annotation.Nullable
  public PrivateIpv6GoogleAccessEnum getPrivateIpv6GoogleAccess() {
    return privateIpv6GoogleAccess;
  }

  public void setPrivateIpv6GoogleAccess(PrivateIpv6GoogleAccessEnum privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
  }


  public GceClusterConfig reservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
    return this;
  }

  /**
   * Get reservationAffinity
   * @return reservationAffinity
   */
  @javax.annotation.Nullable
  public ReservationAffinity getReservationAffinity() {
    return reservationAffinity;
  }

  public void setReservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
  }


  public GceClusterConfig serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * Optional. The Dataproc service account (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/service-accounts#service_accounts_in_dataproc) (also see VM Data Plane identity (https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-principals#vm_service_account_data_plane_identity)) used by Dataproc cluster VM instances to access Google Cloud Platform services.If not specified, the Compute Engine default service account (https://cloud.google.com/compute/docs/access/service-accounts#default_service_account) is used.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public GceClusterConfig serviceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
    return this;
  }

  public GceClusterConfig addServiceAccountScopesItem(String serviceAccountScopesItem) {
    if (this.serviceAccountScopes == null) {
      this.serviceAccountScopes = new ArrayList<>();
    }
    this.serviceAccountScopes.add(serviceAccountScopesItem);
    return this;
  }

  /**
   * Optional. The URIs of service account scopes to be included in Compute Engine instances. The following base set of scopes is always included: https://www.googleapis.com/auth/cloud.useraccounts.readonly https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/logging.writeIf no scopes are specified, the following defaults are also provided: https://www.googleapis.com/auth/bigquery https://www.googleapis.com/auth/bigtable.admin.table https://www.googleapis.com/auth/bigtable.data https://www.googleapis.com/auth/devstorage.full_control
   * @return serviceAccountScopes
   */
  @javax.annotation.Nullable
  public List<String> getServiceAccountScopes() {
    return serviceAccountScopes;
  }

  public void setServiceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
  }


  public GceClusterConfig shieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
    return this;
  }

  /**
   * Get shieldedInstanceConfig
   * @return shieldedInstanceConfig
   */
  @javax.annotation.Nullable
  public ShieldedInstanceConfig getShieldedInstanceConfig() {
    return shieldedInstanceConfig;
  }

  public void setShieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
  }


  public GceClusterConfig subnetworkUri(String subnetworkUri) {
    this.subnetworkUri = subnetworkUri;
    return this;
  }

  /**
   * Optional. The Compute Engine subnetwork to be used for machine communications. Cannot be specified with network_uri.A full URL, partial URI, or short name are valid. Examples: https://www.googleapis.com/compute/v1/projects/[project_id]/regions/[region]/subnetworks/sub0 projects/[project_id]/regions/[region]/subnetworks/sub0 sub0
   * @return subnetworkUri
   */
  @javax.annotation.Nullable
  public String getSubnetworkUri() {
    return subnetworkUri;
  }

  public void setSubnetworkUri(String subnetworkUri) {
    this.subnetworkUri = subnetworkUri;
  }


  public GceClusterConfig tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public GceClusterConfig addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * The Compute Engine tags to add to all instances (see Tagging instances (https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }


  public GceClusterConfig zoneUri(String zoneUri) {
    this.zoneUri = zoneUri;
    return this;
  }

  /**
   * Optional. The Compute Engine zone where the Dataproc cluster will be located. If omitted, the service will pick a zone in the cluster&#39;s Compute Engine region. On a get request, zone will always be present.A full URL, partial URI, or short name are valid. Examples: https://www.googleapis.com/compute/v1/projects/[project_id]/zones/[zone] projects/[project_id]/zones/[zone] [zone]
   * @return zoneUri
   */
  @javax.annotation.Nullable
  public String getZoneUri() {
    return zoneUri;
  }

  public void setZoneUri(String zoneUri) {
    this.zoneUri = zoneUri;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GceClusterConfig gceClusterConfig = (GceClusterConfig) o;
    return Objects.equals(this.confidentialInstanceConfig, gceClusterConfig.confidentialInstanceConfig) &&
        Objects.equals(this.internalIpOnly, gceClusterConfig.internalIpOnly) &&
        Objects.equals(this.metadata, gceClusterConfig.metadata) &&
        Objects.equals(this.networkUri, gceClusterConfig.networkUri) &&
        Objects.equals(this.nodeGroupAffinity, gceClusterConfig.nodeGroupAffinity) &&
        Objects.equals(this.privateIpv6GoogleAccess, gceClusterConfig.privateIpv6GoogleAccess) &&
        Objects.equals(this.reservationAffinity, gceClusterConfig.reservationAffinity) &&
        Objects.equals(this.serviceAccount, gceClusterConfig.serviceAccount) &&
        Objects.equals(this.serviceAccountScopes, gceClusterConfig.serviceAccountScopes) &&
        Objects.equals(this.shieldedInstanceConfig, gceClusterConfig.shieldedInstanceConfig) &&
        Objects.equals(this.subnetworkUri, gceClusterConfig.subnetworkUri) &&
        Objects.equals(this.tags, gceClusterConfig.tags) &&
        Objects.equals(this.zoneUri, gceClusterConfig.zoneUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(confidentialInstanceConfig, internalIpOnly, metadata, networkUri, nodeGroupAffinity, privateIpv6GoogleAccess, reservationAffinity, serviceAccount, serviceAccountScopes, shieldedInstanceConfig, subnetworkUri, tags, zoneUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GceClusterConfig {\n");
    sb.append("    confidentialInstanceConfig: ").append(toIndentedString(confidentialInstanceConfig)).append("\n");
    sb.append("    internalIpOnly: ").append(toIndentedString(internalIpOnly)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    networkUri: ").append(toIndentedString(networkUri)).append("\n");
    sb.append("    nodeGroupAffinity: ").append(toIndentedString(nodeGroupAffinity)).append("\n");
    sb.append("    privateIpv6GoogleAccess: ").append(toIndentedString(privateIpv6GoogleAccess)).append("\n");
    sb.append("    reservationAffinity: ").append(toIndentedString(reservationAffinity)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    serviceAccountScopes: ").append(toIndentedString(serviceAccountScopes)).append("\n");
    sb.append("    shieldedInstanceConfig: ").append(toIndentedString(shieldedInstanceConfig)).append("\n");
    sb.append("    subnetworkUri: ").append(toIndentedString(subnetworkUri)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    zoneUri: ").append(toIndentedString(zoneUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("confidentialInstanceConfig");
    openapiFields.add("internalIpOnly");
    openapiFields.add("metadata");
    openapiFields.add("networkUri");
    openapiFields.add("nodeGroupAffinity");
    openapiFields.add("privateIpv6GoogleAccess");
    openapiFields.add("reservationAffinity");
    openapiFields.add("serviceAccount");
    openapiFields.add("serviceAccountScopes");
    openapiFields.add("shieldedInstanceConfig");
    openapiFields.add("subnetworkUri");
    openapiFields.add("tags");
    openapiFields.add("zoneUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GceClusterConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GceClusterConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GceClusterConfig is not found in the empty JSON string", GceClusterConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GceClusterConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GceClusterConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `confidentialInstanceConfig`
      if (jsonObj.get("confidentialInstanceConfig") != null && !jsonObj.get("confidentialInstanceConfig").isJsonNull()) {
        ConfidentialInstanceConfig.validateJsonElement(jsonObj.get("confidentialInstanceConfig"));
      }
      if ((jsonObj.get("networkUri") != null && !jsonObj.get("networkUri").isJsonNull()) && !jsonObj.get("networkUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkUri").toString()));
      }
      // validate the optional field `nodeGroupAffinity`
      if (jsonObj.get("nodeGroupAffinity") != null && !jsonObj.get("nodeGroupAffinity").isJsonNull()) {
        NodeGroupAffinity.validateJsonElement(jsonObj.get("nodeGroupAffinity"));
      }
      if ((jsonObj.get("privateIpv6GoogleAccess") != null && !jsonObj.get("privateIpv6GoogleAccess").isJsonNull()) && !jsonObj.get("privateIpv6GoogleAccess").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `privateIpv6GoogleAccess` to be a primitive type in the JSON string but got `%s`", jsonObj.get("privateIpv6GoogleAccess").toString()));
      }
      // validate the optional field `privateIpv6GoogleAccess`
      if (jsonObj.get("privateIpv6GoogleAccess") != null && !jsonObj.get("privateIpv6GoogleAccess").isJsonNull()) {
        PrivateIpv6GoogleAccessEnum.validateJsonElement(jsonObj.get("privateIpv6GoogleAccess"));
      }
      // validate the optional field `reservationAffinity`
      if (jsonObj.get("reservationAffinity") != null && !jsonObj.get("reservationAffinity").isJsonNull()) {
        ReservationAffinity.validateJsonElement(jsonObj.get("reservationAffinity"));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("serviceAccountScopes") != null && !jsonObj.get("serviceAccountScopes").isJsonNull() && !jsonObj.get("serviceAccountScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountScopes` to be an array in the JSON string but got `%s`", jsonObj.get("serviceAccountScopes").toString()));
      }
      // validate the optional field `shieldedInstanceConfig`
      if (jsonObj.get("shieldedInstanceConfig") != null && !jsonObj.get("shieldedInstanceConfig").isJsonNull()) {
        ShieldedInstanceConfig.validateJsonElement(jsonObj.get("shieldedInstanceConfig"));
      }
      if ((jsonObj.get("subnetworkUri") != null && !jsonObj.get("subnetworkUri").isJsonNull()) && !jsonObj.get("subnetworkUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetworkUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetworkUri").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if ((jsonObj.get("zoneUri") != null && !jsonObj.get("zoneUri").isJsonNull()) && !jsonObj.get("zoneUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zoneUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zoneUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GceClusterConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GceClusterConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GceClusterConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GceClusterConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GceClusterConfig>() {
           @Override
           public void write(JsonWriter out, GceClusterConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GceClusterConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GceClusterConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GceClusterConfig
   * @throws IOException if the JSON string is invalid with respect to GceClusterConfig
   */
  public static GceClusterConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GceClusterConfig.class);
  }

  /**
   * Convert an instance of GceClusterConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

