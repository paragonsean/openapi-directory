/*
 * Cloud Dataproc API
 * Manages Hadoop-based clusters and jobs on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Execution configuration for a workload.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:50.925918-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExecutionConfig {
  public static final String SERIALIZED_NAME_IDLE_TTL = "idleTtl";
  @SerializedName(SERIALIZED_NAME_IDLE_TTL)
  private String idleTtl;

  public static final String SERIALIZED_NAME_KMS_KEY = "kmsKey";
  @SerializedName(SERIALIZED_NAME_KMS_KEY)
  private String kmsKey;

  public static final String SERIALIZED_NAME_NETWORK_TAGS = "networkTags";
  @SerializedName(SERIALIZED_NAME_NETWORK_TAGS)
  private List<String> networkTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_NETWORK_URI = "networkUri";
  @SerializedName(SERIALIZED_NAME_NETWORK_URI)
  private String networkUri;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_STAGING_BUCKET = "stagingBucket";
  @SerializedName(SERIALIZED_NAME_STAGING_BUCKET)
  private String stagingBucket;

  public static final String SERIALIZED_NAME_SUBNETWORK_URI = "subnetworkUri";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK_URI)
  private String subnetworkUri;

  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  private String ttl;

  public ExecutionConfig() {
  }

  public ExecutionConfig idleTtl(String idleTtl) {
    this.idleTtl = idleTtl;
    return this;
  }

  /**
   * Optional. Applies to sessions only. The duration to keep the session alive while it&#39;s idling. Exceeding this threshold causes the session to terminate. This field cannot be set on a batch workload. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of Duration (https://developers.google.com/protocol-buffers/docs/proto3#json)). Defaults to 1 hour if not set. If both ttl and idle_ttl are specified for an interactive session, the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.
   * @return idleTtl
   */
  @javax.annotation.Nullable
  public String getIdleTtl() {
    return idleTtl;
  }

  public void setIdleTtl(String idleTtl) {
    this.idleTtl = idleTtl;
  }


  public ExecutionConfig kmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
    return this;
  }

  /**
   * Optional. The Cloud KMS key to use for encryption.
   * @return kmsKey
   */
  @javax.annotation.Nullable
  public String getKmsKey() {
    return kmsKey;
  }

  public void setKmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
  }


  public ExecutionConfig networkTags(List<String> networkTags) {
    this.networkTags = networkTags;
    return this;
  }

  public ExecutionConfig addNetworkTagsItem(String networkTagsItem) {
    if (this.networkTags == null) {
      this.networkTags = new ArrayList<>();
    }
    this.networkTags.add(networkTagsItem);
    return this;
  }

  /**
   * Optional. Tags used for network traffic control.
   * @return networkTags
   */
  @javax.annotation.Nullable
  public List<String> getNetworkTags() {
    return networkTags;
  }

  public void setNetworkTags(List<String> networkTags) {
    this.networkTags = networkTags;
  }


  public ExecutionConfig networkUri(String networkUri) {
    this.networkUri = networkUri;
    return this;
  }

  /**
   * Optional. Network URI to connect workload to.
   * @return networkUri
   */
  @javax.annotation.Nullable
  public String getNetworkUri() {
    return networkUri;
  }

  public void setNetworkUri(String networkUri) {
    this.networkUri = networkUri;
  }


  public ExecutionConfig serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * Optional. Service account that used to execute workload.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public ExecutionConfig stagingBucket(String stagingBucket) {
    this.stagingBucket = stagingBucket;
    return this;
  }

  /**
   * Optional. A Cloud Storage bucket used to stage workload dependencies, config files, and store workload output and other ephemeral data, such as Spark history files. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location according to the region where your workload is running, and then create and manage project-level, per-location staging and temporary buckets. This field requires a Cloud Storage bucket name, not a gs://... URI to a Cloud Storage bucket.
   * @return stagingBucket
   */
  @javax.annotation.Nullable
  public String getStagingBucket() {
    return stagingBucket;
  }

  public void setStagingBucket(String stagingBucket) {
    this.stagingBucket = stagingBucket;
  }


  public ExecutionConfig subnetworkUri(String subnetworkUri) {
    this.subnetworkUri = subnetworkUri;
    return this;
  }

  /**
   * Optional. Subnetwork URI to connect workload to.
   * @return subnetworkUri
   */
  @javax.annotation.Nullable
  public String getSubnetworkUri() {
    return subnetworkUri;
  }

  public void setSubnetworkUri(String subnetworkUri) {
    this.subnetworkUri = subnetworkUri;
  }


  public ExecutionConfig ttl(String ttl) {
    this.ttl = ttl;
    return this;
  }

  /**
   * Optional. The duration after which the workload will be terminated, specified as the JSON representation for Duration (https://protobuf.dev/programming-guides/proto3/#json). When the workload exceeds this duration, it will be unconditionally terminated without waiting for ongoing work to finish. If ttl is not specified for a batch workload, the workload will be allowed to run until it exits naturally (or run forever without exiting). If ttl is not specified for an interactive session, it defaults to 24 hours. If ttl is not specified for a batch that uses 2.1+ runtime version, it defaults to 4 hours. Minimum value is 10 minutes; maximum value is 14 days. If both ttl and idle_ttl are specified (for an interactive session), the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.
   * @return ttl
   */
  @javax.annotation.Nullable
  public String getTtl() {
    return ttl;
  }

  public void setTtl(String ttl) {
    this.ttl = ttl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExecutionConfig executionConfig = (ExecutionConfig) o;
    return Objects.equals(this.idleTtl, executionConfig.idleTtl) &&
        Objects.equals(this.kmsKey, executionConfig.kmsKey) &&
        Objects.equals(this.networkTags, executionConfig.networkTags) &&
        Objects.equals(this.networkUri, executionConfig.networkUri) &&
        Objects.equals(this.serviceAccount, executionConfig.serviceAccount) &&
        Objects.equals(this.stagingBucket, executionConfig.stagingBucket) &&
        Objects.equals(this.subnetworkUri, executionConfig.subnetworkUri) &&
        Objects.equals(this.ttl, executionConfig.ttl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(idleTtl, kmsKey, networkTags, networkUri, serviceAccount, stagingBucket, subnetworkUri, ttl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExecutionConfig {\n");
    sb.append("    idleTtl: ").append(toIndentedString(idleTtl)).append("\n");
    sb.append("    kmsKey: ").append(toIndentedString(kmsKey)).append("\n");
    sb.append("    networkTags: ").append(toIndentedString(networkTags)).append("\n");
    sb.append("    networkUri: ").append(toIndentedString(networkUri)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    stagingBucket: ").append(toIndentedString(stagingBucket)).append("\n");
    sb.append("    subnetworkUri: ").append(toIndentedString(subnetworkUri)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("idleTtl");
    openapiFields.add("kmsKey");
    openapiFields.add("networkTags");
    openapiFields.add("networkUri");
    openapiFields.add("serviceAccount");
    openapiFields.add("stagingBucket");
    openapiFields.add("subnetworkUri");
    openapiFields.add("ttl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExecutionConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExecutionConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExecutionConfig is not found in the empty JSON string", ExecutionConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExecutionConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExecutionConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("idleTtl") != null && !jsonObj.get("idleTtl").isJsonNull()) && !jsonObj.get("idleTtl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `idleTtl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("idleTtl").toString()));
      }
      if ((jsonObj.get("kmsKey") != null && !jsonObj.get("kmsKey").isJsonNull()) && !jsonObj.get("kmsKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKey").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("networkTags") != null && !jsonObj.get("networkTags").isJsonNull() && !jsonObj.get("networkTags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkTags` to be an array in the JSON string but got `%s`", jsonObj.get("networkTags").toString()));
      }
      if ((jsonObj.get("networkUri") != null && !jsonObj.get("networkUri").isJsonNull()) && !jsonObj.get("networkUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkUri").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      if ((jsonObj.get("stagingBucket") != null && !jsonObj.get("stagingBucket").isJsonNull()) && !jsonObj.get("stagingBucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stagingBucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stagingBucket").toString()));
      }
      if ((jsonObj.get("subnetworkUri") != null && !jsonObj.get("subnetworkUri").isJsonNull()) && !jsonObj.get("subnetworkUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetworkUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetworkUri").toString()));
      }
      if ((jsonObj.get("ttl") != null && !jsonObj.get("ttl").isJsonNull()) && !jsonObj.get("ttl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ttl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ttl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExecutionConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExecutionConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExecutionConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExecutionConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ExecutionConfig>() {
           @Override
           public void write(JsonWriter out, ExecutionConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExecutionConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExecutionConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExecutionConfig
   * @throws IOException if the JSON string is invalid with respect to ExecutionConfig
   */
  public static ExecutionConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExecutionConfig.class);
  }

  /**
   * Convert an instance of ExecutionConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

