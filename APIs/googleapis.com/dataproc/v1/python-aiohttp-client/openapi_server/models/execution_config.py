# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class ExecutionConfig(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, idle_ttl: str=None, kms_key: str=None, network_tags: List[str]=None, network_uri: str=None, service_account: str=None, staging_bucket: str=None, subnetwork_uri: str=None, ttl: str=None):
        """ExecutionConfig - a model defined in OpenAPI

        :param idle_ttl: The idle_ttl of this ExecutionConfig.
        :param kms_key: The kms_key of this ExecutionConfig.
        :param network_tags: The network_tags of this ExecutionConfig.
        :param network_uri: The network_uri of this ExecutionConfig.
        :param service_account: The service_account of this ExecutionConfig.
        :param staging_bucket: The staging_bucket of this ExecutionConfig.
        :param subnetwork_uri: The subnetwork_uri of this ExecutionConfig.
        :param ttl: The ttl of this ExecutionConfig.
        """
        self.openapi_types = {
            'idle_ttl': str,
            'kms_key': str,
            'network_tags': List[str],
            'network_uri': str,
            'service_account': str,
            'staging_bucket': str,
            'subnetwork_uri': str,
            'ttl': str
        }

        self.attribute_map = {
            'idle_ttl': 'idleTtl',
            'kms_key': 'kmsKey',
            'network_tags': 'networkTags',
            'network_uri': 'networkUri',
            'service_account': 'serviceAccount',
            'staging_bucket': 'stagingBucket',
            'subnetwork_uri': 'subnetworkUri',
            'ttl': 'ttl'
        }

        self._idle_ttl = idle_ttl
        self._kms_key = kms_key
        self._network_tags = network_tags
        self._network_uri = network_uri
        self._service_account = service_account
        self._staging_bucket = staging_bucket
        self._subnetwork_uri = subnetwork_uri
        self._ttl = ttl

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ExecutionConfig':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ExecutionConfig of this ExecutionConfig.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def idle_ttl(self):
        """Gets the idle_ttl of this ExecutionConfig.

        Optional. Applies to sessions only. The duration to keep the session alive while it's idling. Exceeding this threshold causes the session to terminate. This field cannot be set on a batch workload. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of Duration (https://developers.google.com/protocol-buffers/docs/proto3#json)). Defaults to 1 hour if not set. If both ttl and idle_ttl are specified for an interactive session, the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.

        :return: The idle_ttl of this ExecutionConfig.
        :rtype: str
        """
        return self._idle_ttl

    @idle_ttl.setter
    def idle_ttl(self, idle_ttl):
        """Sets the idle_ttl of this ExecutionConfig.

        Optional. Applies to sessions only. The duration to keep the session alive while it's idling. Exceeding this threshold causes the session to terminate. This field cannot be set on a batch workload. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of Duration (https://developers.google.com/protocol-buffers/docs/proto3#json)). Defaults to 1 hour if not set. If both ttl and idle_ttl are specified for an interactive session, the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.

        :param idle_ttl: The idle_ttl of this ExecutionConfig.
        :type idle_ttl: str
        """

        self._idle_ttl = idle_ttl

    @property
    def kms_key(self):
        """Gets the kms_key of this ExecutionConfig.

        Optional. The Cloud KMS key to use for encryption.

        :return: The kms_key of this ExecutionConfig.
        :rtype: str
        """
        return self._kms_key

    @kms_key.setter
    def kms_key(self, kms_key):
        """Sets the kms_key of this ExecutionConfig.

        Optional. The Cloud KMS key to use for encryption.

        :param kms_key: The kms_key of this ExecutionConfig.
        :type kms_key: str
        """

        self._kms_key = kms_key

    @property
    def network_tags(self):
        """Gets the network_tags of this ExecutionConfig.

        Optional. Tags used for network traffic control.

        :return: The network_tags of this ExecutionConfig.
        :rtype: List[str]
        """
        return self._network_tags

    @network_tags.setter
    def network_tags(self, network_tags):
        """Sets the network_tags of this ExecutionConfig.

        Optional. Tags used for network traffic control.

        :param network_tags: The network_tags of this ExecutionConfig.
        :type network_tags: List[str]
        """

        self._network_tags = network_tags

    @property
    def network_uri(self):
        """Gets the network_uri of this ExecutionConfig.

        Optional. Network URI to connect workload to.

        :return: The network_uri of this ExecutionConfig.
        :rtype: str
        """
        return self._network_uri

    @network_uri.setter
    def network_uri(self, network_uri):
        """Sets the network_uri of this ExecutionConfig.

        Optional. Network URI to connect workload to.

        :param network_uri: The network_uri of this ExecutionConfig.
        :type network_uri: str
        """

        self._network_uri = network_uri

    @property
    def service_account(self):
        """Gets the service_account of this ExecutionConfig.

        Optional. Service account that used to execute workload.

        :return: The service_account of this ExecutionConfig.
        :rtype: str
        """
        return self._service_account

    @service_account.setter
    def service_account(self, service_account):
        """Sets the service_account of this ExecutionConfig.

        Optional. Service account that used to execute workload.

        :param service_account: The service_account of this ExecutionConfig.
        :type service_account: str
        """

        self._service_account = service_account

    @property
    def staging_bucket(self):
        """Gets the staging_bucket of this ExecutionConfig.

        Optional. A Cloud Storage bucket used to stage workload dependencies, config files, and store workload output and other ephemeral data, such as Spark history files. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location according to the region where your workload is running, and then create and manage project-level, per-location staging and temporary buckets. This field requires a Cloud Storage bucket name, not a gs://... URI to a Cloud Storage bucket.

        :return: The staging_bucket of this ExecutionConfig.
        :rtype: str
        """
        return self._staging_bucket

    @staging_bucket.setter
    def staging_bucket(self, staging_bucket):
        """Sets the staging_bucket of this ExecutionConfig.

        Optional. A Cloud Storage bucket used to stage workload dependencies, config files, and store workload output and other ephemeral data, such as Spark history files. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location according to the region where your workload is running, and then create and manage project-level, per-location staging and temporary buckets. This field requires a Cloud Storage bucket name, not a gs://... URI to a Cloud Storage bucket.

        :param staging_bucket: The staging_bucket of this ExecutionConfig.
        :type staging_bucket: str
        """

        self._staging_bucket = staging_bucket

    @property
    def subnetwork_uri(self):
        """Gets the subnetwork_uri of this ExecutionConfig.

        Optional. Subnetwork URI to connect workload to.

        :return: The subnetwork_uri of this ExecutionConfig.
        :rtype: str
        """
        return self._subnetwork_uri

    @subnetwork_uri.setter
    def subnetwork_uri(self, subnetwork_uri):
        """Sets the subnetwork_uri of this ExecutionConfig.

        Optional. Subnetwork URI to connect workload to.

        :param subnetwork_uri: The subnetwork_uri of this ExecutionConfig.
        :type subnetwork_uri: str
        """

        self._subnetwork_uri = subnetwork_uri

    @property
    def ttl(self):
        """Gets the ttl of this ExecutionConfig.

        Optional. The duration after which the workload will be terminated, specified as the JSON representation for Duration (https://protobuf.dev/programming-guides/proto3/#json). When the workload exceeds this duration, it will be unconditionally terminated without waiting for ongoing work to finish. If ttl is not specified for a batch workload, the workload will be allowed to run until it exits naturally (or run forever without exiting). If ttl is not specified for an interactive session, it defaults to 24 hours. If ttl is not specified for a batch that uses 2.1+ runtime version, it defaults to 4 hours. Minimum value is 10 minutes; maximum value is 14 days. If both ttl and idle_ttl are specified (for an interactive session), the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.

        :return: The ttl of this ExecutionConfig.
        :rtype: str
        """
        return self._ttl

    @ttl.setter
    def ttl(self, ttl):
        """Sets the ttl of this ExecutionConfig.

        Optional. The duration after which the workload will be terminated, specified as the JSON representation for Duration (https://protobuf.dev/programming-guides/proto3/#json). When the workload exceeds this duration, it will be unconditionally terminated without waiting for ongoing work to finish. If ttl is not specified for a batch workload, the workload will be allowed to run until it exits naturally (or run forever without exiting). If ttl is not specified for an interactive session, it defaults to 24 hours. If ttl is not specified for a batch that uses 2.1+ runtime version, it defaults to 4 hours. Minimum value is 10 minutes; maximum value is 14 days. If both ttl and idle_ttl are specified (for an interactive session), the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idle_ttl or when ttl has been exceeded, whichever occurs first.

        :param ttl: The ttl of this ExecutionConfig.
        :type ttl: str
        """

        self._ttl = ttl
