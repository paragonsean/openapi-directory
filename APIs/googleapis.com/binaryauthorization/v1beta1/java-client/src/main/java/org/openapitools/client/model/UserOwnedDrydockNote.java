/*
 * Binary Authorization API
 * The management interface for Binary Authorization, a service that provides policy-based deployment validation and control for images deployed to Google Kubernetes Engine (GKE), Anthos Service Mesh, Anthos Clusters, and Cloud Run. 
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AttestorPublicKey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An user owned drydock note references a Drydock ATTESTATION_AUTHORITY Note created by the user.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:34.556318-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UserOwnedDrydockNote {
  public static final String SERIALIZED_NAME_DELEGATION_SERVICE_ACCOUNT_EMAIL = "delegationServiceAccountEmail";
  @SerializedName(SERIALIZED_NAME_DELEGATION_SERVICE_ACCOUNT_EMAIL)
  private String delegationServiceAccountEmail;

  public static final String SERIALIZED_NAME_NOTE_REFERENCE = "noteReference";
  @SerializedName(SERIALIZED_NAME_NOTE_REFERENCE)
  private String noteReference;

  public static final String SERIALIZED_NAME_PUBLIC_KEYS = "publicKeys";
  @SerializedName(SERIALIZED_NAME_PUBLIC_KEYS)
  private List<AttestorPublicKey> publicKeys = new ArrayList<>();

  public UserOwnedDrydockNote() {
  }

  public UserOwnedDrydockNote(
     String delegationServiceAccountEmail
  ) {
    this();
    this.delegationServiceAccountEmail = delegationServiceAccountEmail;
  }

  /**
   * Output only. This field will contain the service account email address that this Attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the note_reference in Container Analysis (&#x60;containeranalysis.notes.occurrences.viewer&#x60;). This email address is fixed for the lifetime of the Attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.
   * @return delegationServiceAccountEmail
   */
  @javax.annotation.Nullable
  public String getDelegationServiceAccountEmail() {
    return delegationServiceAccountEmail;
  }



  public UserOwnedDrydockNote noteReference(String noteReference) {
    this.noteReference = noteReference;
    return this;
  }

  /**
   * Required. The Drydock resource name of a ATTESTATION_AUTHORITY Note, created by the user, in the format: &#x60;projects/_*_/notes/_*&#x60; (or the legacy &#x60;providers/_*_/notes/_*&#x60;). This field may not be updated. An attestation by this attestor is stored as a Drydock ATTESTATION_AUTHORITY Occurrence that names a container image and that links to this Note. Drydock is an external dependency.
   * @return noteReference
   */
  @javax.annotation.Nullable
  public String getNoteReference() {
    return noteReference;
  }

  public void setNoteReference(String noteReference) {
    this.noteReference = noteReference;
  }


  public UserOwnedDrydockNote publicKeys(List<AttestorPublicKey> publicKeys) {
    this.publicKeys = publicKeys;
    return this;
  }

  public UserOwnedDrydockNote addPublicKeysItem(AttestorPublicKey publicKeysItem) {
    if (this.publicKeys == null) {
      this.publicKeys = new ArrayList<>();
    }
    this.publicKeys.add(publicKeysItem);
    return this;
  }

  /**
   * Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
   * @return publicKeys
   */
  @javax.annotation.Nullable
  public List<AttestorPublicKey> getPublicKeys() {
    return publicKeys;
  }

  public void setPublicKeys(List<AttestorPublicKey> publicKeys) {
    this.publicKeys = publicKeys;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UserOwnedDrydockNote userOwnedDrydockNote = (UserOwnedDrydockNote) o;
    return Objects.equals(this.delegationServiceAccountEmail, userOwnedDrydockNote.delegationServiceAccountEmail) &&
        Objects.equals(this.noteReference, userOwnedDrydockNote.noteReference) &&
        Objects.equals(this.publicKeys, userOwnedDrydockNote.publicKeys);
  }

  @Override
  public int hashCode() {
    return Objects.hash(delegationServiceAccountEmail, noteReference, publicKeys);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UserOwnedDrydockNote {\n");
    sb.append("    delegationServiceAccountEmail: ").append(toIndentedString(delegationServiceAccountEmail)).append("\n");
    sb.append("    noteReference: ").append(toIndentedString(noteReference)).append("\n");
    sb.append("    publicKeys: ").append(toIndentedString(publicKeys)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("delegationServiceAccountEmail");
    openapiFields.add("noteReference");
    openapiFields.add("publicKeys");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UserOwnedDrydockNote
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UserOwnedDrydockNote.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UserOwnedDrydockNote is not found in the empty JSON string", UserOwnedDrydockNote.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UserOwnedDrydockNote.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UserOwnedDrydockNote` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("delegationServiceAccountEmail") != null && !jsonObj.get("delegationServiceAccountEmail").isJsonNull()) && !jsonObj.get("delegationServiceAccountEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delegationServiceAccountEmail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delegationServiceAccountEmail").toString()));
      }
      if ((jsonObj.get("noteReference") != null && !jsonObj.get("noteReference").isJsonNull()) && !jsonObj.get("noteReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `noteReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("noteReference").toString()));
      }
      if (jsonObj.get("publicKeys") != null && !jsonObj.get("publicKeys").isJsonNull()) {
        JsonArray jsonArraypublicKeys = jsonObj.getAsJsonArray("publicKeys");
        if (jsonArraypublicKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("publicKeys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `publicKeys` to be an array in the JSON string but got `%s`", jsonObj.get("publicKeys").toString()));
          }

          // validate the optional field `publicKeys` (array)
          for (int i = 0; i < jsonArraypublicKeys.size(); i++) {
            AttestorPublicKey.validateJsonElement(jsonArraypublicKeys.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UserOwnedDrydockNote.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UserOwnedDrydockNote' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UserOwnedDrydockNote> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UserOwnedDrydockNote.class));

       return (TypeAdapter<T>) new TypeAdapter<UserOwnedDrydockNote>() {
           @Override
           public void write(JsonWriter out, UserOwnedDrydockNote value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UserOwnedDrydockNote read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UserOwnedDrydockNote given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UserOwnedDrydockNote
   * @throws IOException if the JSON string is invalid with respect to UserOwnedDrydockNote
   */
  public static UserOwnedDrydockNote fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UserOwnedDrydockNote.class);
  }

  /**
   * Convert an instance of UserOwnedDrydockNote to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

