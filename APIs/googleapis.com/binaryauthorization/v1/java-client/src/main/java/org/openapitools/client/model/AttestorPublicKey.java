/*
 * Binary Authorization API
 * The management interface for Binary Authorization, a service that provides policy-based deployment validation and control for images deployed to Google Kubernetes Engine (GKE), Anthos Service Mesh, Anthos Clusters, and Cloud Run. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.PkixPublicKey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An attestor public key that will be used to verify attestations signed by this attestor.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:36.269071-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AttestorPublicKey {
  public static final String SERIALIZED_NAME_ASCII_ARMORED_PGP_PUBLIC_KEY = "asciiArmoredPgpPublicKey";
  @SerializedName(SERIALIZED_NAME_ASCII_ARMORED_PGP_PUBLIC_KEY)
  private String asciiArmoredPgpPublicKey;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  private String comment;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_PKIX_PUBLIC_KEY = "pkixPublicKey";
  @SerializedName(SERIALIZED_NAME_PKIX_PUBLIC_KEY)
  private PkixPublicKey pkixPublicKey;

  public AttestorPublicKey() {
  }

  public AttestorPublicKey asciiArmoredPgpPublicKey(String asciiArmoredPgpPublicKey) {
    this.asciiArmoredPgpPublicKey = asciiArmoredPgpPublicKey;
    return this;
  }

  /**
   * ASCII-armored representation of a PGP public key, as the entire output by the command &#x60;gpg --export --armor foo@example.com&#x60; (either LF or CRLF line endings). When using this field, &#x60;id&#x60; should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If &#x60;id&#x60; is provided by the caller, it will be overwritten by the API-calculated ID.
   * @return asciiArmoredPgpPublicKey
   */
  @javax.annotation.Nullable
  public String getAsciiArmoredPgpPublicKey() {
    return asciiArmoredPgpPublicKey;
  }

  public void setAsciiArmoredPgpPublicKey(String asciiArmoredPgpPublicKey) {
    this.asciiArmoredPgpPublicKey = asciiArmoredPgpPublicKey;
  }


  public AttestorPublicKey comment(String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Optional. A descriptive comment. This field may be updated.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(String comment) {
    this.comment = comment;
  }


  public AttestorPublicKey id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on &#x60;public_key&#x60; cases below for details.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public AttestorPublicKey pkixPublicKey(PkixPublicKey pkixPublicKey) {
    this.pkixPublicKey = pkixPublicKey;
    return this;
  }

  /**
   * Get pkixPublicKey
   * @return pkixPublicKey
   */
  @javax.annotation.Nullable
  public PkixPublicKey getPkixPublicKey() {
    return pkixPublicKey;
  }

  public void setPkixPublicKey(PkixPublicKey pkixPublicKey) {
    this.pkixPublicKey = pkixPublicKey;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AttestorPublicKey attestorPublicKey = (AttestorPublicKey) o;
    return Objects.equals(this.asciiArmoredPgpPublicKey, attestorPublicKey.asciiArmoredPgpPublicKey) &&
        Objects.equals(this.comment, attestorPublicKey.comment) &&
        Objects.equals(this.id, attestorPublicKey.id) &&
        Objects.equals(this.pkixPublicKey, attestorPublicKey.pkixPublicKey);
  }

  @Override
  public int hashCode() {
    return Objects.hash(asciiArmoredPgpPublicKey, comment, id, pkixPublicKey);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AttestorPublicKey {\n");
    sb.append("    asciiArmoredPgpPublicKey: ").append(toIndentedString(asciiArmoredPgpPublicKey)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    pkixPublicKey: ").append(toIndentedString(pkixPublicKey)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("asciiArmoredPgpPublicKey");
    openapiFields.add("comment");
    openapiFields.add("id");
    openapiFields.add("pkixPublicKey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AttestorPublicKey
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AttestorPublicKey.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AttestorPublicKey is not found in the empty JSON string", AttestorPublicKey.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AttestorPublicKey.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AttestorPublicKey` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("asciiArmoredPgpPublicKey") != null && !jsonObj.get("asciiArmoredPgpPublicKey").isJsonNull()) && !jsonObj.get("asciiArmoredPgpPublicKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `asciiArmoredPgpPublicKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("asciiArmoredPgpPublicKey").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `pkixPublicKey`
      if (jsonObj.get("pkixPublicKey") != null && !jsonObj.get("pkixPublicKey").isJsonNull()) {
        PkixPublicKey.validateJsonElement(jsonObj.get("pkixPublicKey"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AttestorPublicKey.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AttestorPublicKey' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AttestorPublicKey> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AttestorPublicKey.class));

       return (TypeAdapter<T>) new TypeAdapter<AttestorPublicKey>() {
           @Override
           public void write(JsonWriter out, AttestorPublicKey value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AttestorPublicKey read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AttestorPublicKey given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AttestorPublicKey
   * @throws IOException if the JSON string is invalid with respect to AttestorPublicKey
   */
  public static AttestorPublicKey fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AttestorPublicKey.class);
  }

  /**
   * Convert an instance of AttestorPublicKey to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

