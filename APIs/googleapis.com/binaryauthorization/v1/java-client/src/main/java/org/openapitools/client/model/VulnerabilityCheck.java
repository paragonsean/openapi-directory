/*
 * Binary Authorization API
 * The management interface for Binary Authorization, a service that provides policy-based deployment validation and control for images deployed to Google Kubernetes Engine (GKE), Anthos Service Mesh, Anthos Clusters, and Cloud Run. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An image vulnerability check, which rejects images that violate the configured vulnerability rules.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:36.269071-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VulnerabilityCheck {
  public static final String SERIALIZED_NAME_ALLOWED_CVES = "allowedCves";
  @SerializedName(SERIALIZED_NAME_ALLOWED_CVES)
  private List<String> allowedCves = new ArrayList<>();

  public static final String SERIALIZED_NAME_BLOCKED_CVES = "blockedCves";
  @SerializedName(SERIALIZED_NAME_BLOCKED_CVES)
  private List<String> blockedCves = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTAINER_ANALYSIS_VULNERABILITY_PROJECTS = "containerAnalysisVulnerabilityProjects";
  @SerializedName(SERIALIZED_NAME_CONTAINER_ANALYSIS_VULNERABILITY_PROJECTS)
  private List<String> containerAnalysisVulnerabilityProjects = new ArrayList<>();

  /**
   * Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
   */
  @JsonAdapter(MaximumFixableSeverityEnum.Adapter.class)
  public enum MaximumFixableSeverityEnum {
    MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED("MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED"),
    
    BLOCK_ALL("BLOCK_ALL"),
    
    MINIMAL("MINIMAL"),
    
    LOW("LOW"),
    
    MEDIUM("MEDIUM"),
    
    HIGH("HIGH"),
    
    CRITICAL("CRITICAL"),
    
    ALLOW_ALL("ALLOW_ALL");

    private String value;

    MaximumFixableSeverityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MaximumFixableSeverityEnum fromValue(String value) {
      for (MaximumFixableSeverityEnum b : MaximumFixableSeverityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MaximumFixableSeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MaximumFixableSeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MaximumFixableSeverityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MaximumFixableSeverityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MaximumFixableSeverityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MAXIMUM_FIXABLE_SEVERITY = "maximumFixableSeverity";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_FIXABLE_SEVERITY)
  private MaximumFixableSeverityEnum maximumFixableSeverity;

  /**
   * Required. The threshold for severity for which a fix isn&#39;t currently available. This field is required and must be set.
   */
  @JsonAdapter(MaximumUnfixableSeverityEnum.Adapter.class)
  public enum MaximumUnfixableSeverityEnum {
    MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED("MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED"),
    
    BLOCK_ALL("BLOCK_ALL"),
    
    MINIMAL("MINIMAL"),
    
    LOW("LOW"),
    
    MEDIUM("MEDIUM"),
    
    HIGH("HIGH"),
    
    CRITICAL("CRITICAL"),
    
    ALLOW_ALL("ALLOW_ALL");

    private String value;

    MaximumUnfixableSeverityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MaximumUnfixableSeverityEnum fromValue(String value) {
      for (MaximumUnfixableSeverityEnum b : MaximumUnfixableSeverityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MaximumUnfixableSeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MaximumUnfixableSeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MaximumUnfixableSeverityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MaximumUnfixableSeverityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MaximumUnfixableSeverityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MAXIMUM_UNFIXABLE_SEVERITY = "maximumUnfixableSeverity";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_UNFIXABLE_SEVERITY)
  private MaximumUnfixableSeverityEnum maximumUnfixableSeverity;

  public VulnerabilityCheck() {
  }

  public VulnerabilityCheck allowedCves(List<String> allowedCves) {
    this.allowedCves = allowedCves;
    return this;
  }

  public VulnerabilityCheck addAllowedCvesItem(String allowedCvesItem) {
    if (this.allowedCves == null) {
      this.allowedCves = new ArrayList<>();
    }
    this.allowedCves.add(allowedCvesItem);
    return this;
  }

  /**
   * Optional. A list of specific CVEs to ignore even if the vulnerability level violates &#x60;maximumUnfixableSeverity&#x60; or &#x60;maximumFixableSeverity&#x60;. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of &#x60;CVE-2021-20305&#x60; will allow vulnerabilities with a note name of either &#x60;projects/goog-vulnz/notes/CVE-2021-20305&#x60; or &#x60;projects/CUSTOM-PROJECT/notes/CVE-2021-20305&#x60;.
   * @return allowedCves
   */
  @javax.annotation.Nullable
  public List<String> getAllowedCves() {
    return allowedCves;
  }

  public void setAllowedCves(List<String> allowedCves) {
    this.allowedCves = allowedCves;
  }


  public VulnerabilityCheck blockedCves(List<String> blockedCves) {
    this.blockedCves = blockedCves;
    return this;
  }

  public VulnerabilityCheck addBlockedCvesItem(String blockedCvesItem) {
    if (this.blockedCves == null) {
      this.blockedCves = new ArrayList<>();
    }
    this.blockedCves.add(blockedCvesItem);
    return this;
  }

  /**
   * Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets &#x60;maximumUnfixableSeverity&#x60; or &#x60;maximumFixableSeverity&#x60;. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of &#x60;CVE-2021-20305&#x60; will block vulnerabilities with a note name of either &#x60;projects/goog-vulnz/notes/CVE-2021-20305&#x60; or &#x60;projects/CUSTOM-PROJECT/notes/CVE-2021-20305&#x60;.
   * @return blockedCves
   */
  @javax.annotation.Nullable
  public List<String> getBlockedCves() {
    return blockedCves;
  }

  public void setBlockedCves(List<String> blockedCves) {
    this.blockedCves = blockedCves;
  }


  public VulnerabilityCheck containerAnalysisVulnerabilityProjects(List<String> containerAnalysisVulnerabilityProjects) {
    this.containerAnalysisVulnerabilityProjects = containerAnalysisVulnerabilityProjects;
    return this;
  }

  public VulnerabilityCheck addContainerAnalysisVulnerabilityProjectsItem(String containerAnalysisVulnerabilityProjectsItem) {
    if (this.containerAnalysisVulnerabilityProjects == null) {
      this.containerAnalysisVulnerabilityProjects = new ArrayList<>();
    }
    this.containerAnalysisVulnerabilityProjects.add(containerAnalysisVulnerabilityProjectsItem);
    return this;
  }

  /**
   * Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of &#x60;projects/[PROJECT_ID]&#x60;, e.g., &#x60;projects/my-gcp-project&#x60;. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of &#x60;container_analysis_vulnerability_projects&#x60; allowed in each &#x60;VulnerabilityCheck&#x60; is 10.
   * @return containerAnalysisVulnerabilityProjects
   */
  @javax.annotation.Nullable
  public List<String> getContainerAnalysisVulnerabilityProjects() {
    return containerAnalysisVulnerabilityProjects;
  }

  public void setContainerAnalysisVulnerabilityProjects(List<String> containerAnalysisVulnerabilityProjects) {
    this.containerAnalysisVulnerabilityProjects = containerAnalysisVulnerabilityProjects;
  }


  public VulnerabilityCheck maximumFixableSeverity(MaximumFixableSeverityEnum maximumFixableSeverity) {
    this.maximumFixableSeverity = maximumFixableSeverity;
    return this;
  }

  /**
   * Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
   * @return maximumFixableSeverity
   */
  @javax.annotation.Nullable
  public MaximumFixableSeverityEnum getMaximumFixableSeverity() {
    return maximumFixableSeverity;
  }

  public void setMaximumFixableSeverity(MaximumFixableSeverityEnum maximumFixableSeverity) {
    this.maximumFixableSeverity = maximumFixableSeverity;
  }


  public VulnerabilityCheck maximumUnfixableSeverity(MaximumUnfixableSeverityEnum maximumUnfixableSeverity) {
    this.maximumUnfixableSeverity = maximumUnfixableSeverity;
    return this;
  }

  /**
   * Required. The threshold for severity for which a fix isn&#39;t currently available. This field is required and must be set.
   * @return maximumUnfixableSeverity
   */
  @javax.annotation.Nullable
  public MaximumUnfixableSeverityEnum getMaximumUnfixableSeverity() {
    return maximumUnfixableSeverity;
  }

  public void setMaximumUnfixableSeverity(MaximumUnfixableSeverityEnum maximumUnfixableSeverity) {
    this.maximumUnfixableSeverity = maximumUnfixableSeverity;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VulnerabilityCheck vulnerabilityCheck = (VulnerabilityCheck) o;
    return Objects.equals(this.allowedCves, vulnerabilityCheck.allowedCves) &&
        Objects.equals(this.blockedCves, vulnerabilityCheck.blockedCves) &&
        Objects.equals(this.containerAnalysisVulnerabilityProjects, vulnerabilityCheck.containerAnalysisVulnerabilityProjects) &&
        Objects.equals(this.maximumFixableSeverity, vulnerabilityCheck.maximumFixableSeverity) &&
        Objects.equals(this.maximumUnfixableSeverity, vulnerabilityCheck.maximumUnfixableSeverity);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowedCves, blockedCves, containerAnalysisVulnerabilityProjects, maximumFixableSeverity, maximumUnfixableSeverity);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VulnerabilityCheck {\n");
    sb.append("    allowedCves: ").append(toIndentedString(allowedCves)).append("\n");
    sb.append("    blockedCves: ").append(toIndentedString(blockedCves)).append("\n");
    sb.append("    containerAnalysisVulnerabilityProjects: ").append(toIndentedString(containerAnalysisVulnerabilityProjects)).append("\n");
    sb.append("    maximumFixableSeverity: ").append(toIndentedString(maximumFixableSeverity)).append("\n");
    sb.append("    maximumUnfixableSeverity: ").append(toIndentedString(maximumUnfixableSeverity)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowedCves");
    openapiFields.add("blockedCves");
    openapiFields.add("containerAnalysisVulnerabilityProjects");
    openapiFields.add("maximumFixableSeverity");
    openapiFields.add("maximumUnfixableSeverity");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VulnerabilityCheck
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VulnerabilityCheck.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VulnerabilityCheck is not found in the empty JSON string", VulnerabilityCheck.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VulnerabilityCheck.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VulnerabilityCheck` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedCves") != null && !jsonObj.get("allowedCves").isJsonNull() && !jsonObj.get("allowedCves").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedCves` to be an array in the JSON string but got `%s`", jsonObj.get("allowedCves").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("blockedCves") != null && !jsonObj.get("blockedCves").isJsonNull() && !jsonObj.get("blockedCves").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `blockedCves` to be an array in the JSON string but got `%s`", jsonObj.get("blockedCves").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("containerAnalysisVulnerabilityProjects") != null && !jsonObj.get("containerAnalysisVulnerabilityProjects").isJsonNull() && !jsonObj.get("containerAnalysisVulnerabilityProjects").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerAnalysisVulnerabilityProjects` to be an array in the JSON string but got `%s`", jsonObj.get("containerAnalysisVulnerabilityProjects").toString()));
      }
      if ((jsonObj.get("maximumFixableSeverity") != null && !jsonObj.get("maximumFixableSeverity").isJsonNull()) && !jsonObj.get("maximumFixableSeverity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumFixableSeverity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumFixableSeverity").toString()));
      }
      // validate the optional field `maximumFixableSeverity`
      if (jsonObj.get("maximumFixableSeverity") != null && !jsonObj.get("maximumFixableSeverity").isJsonNull()) {
        MaximumFixableSeverityEnum.validateJsonElement(jsonObj.get("maximumFixableSeverity"));
      }
      if ((jsonObj.get("maximumUnfixableSeverity") != null && !jsonObj.get("maximumUnfixableSeverity").isJsonNull()) && !jsonObj.get("maximumUnfixableSeverity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maximumUnfixableSeverity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maximumUnfixableSeverity").toString()));
      }
      // validate the optional field `maximumUnfixableSeverity`
      if (jsonObj.get("maximumUnfixableSeverity") != null && !jsonObj.get("maximumUnfixableSeverity").isJsonNull()) {
        MaximumUnfixableSeverityEnum.validateJsonElement(jsonObj.get("maximumUnfixableSeverity"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VulnerabilityCheck.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VulnerabilityCheck' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VulnerabilityCheck> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VulnerabilityCheck.class));

       return (TypeAdapter<T>) new TypeAdapter<VulnerabilityCheck>() {
           @Override
           public void write(JsonWriter out, VulnerabilityCheck value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VulnerabilityCheck read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VulnerabilityCheck given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VulnerabilityCheck
   * @throws IOException if the JSON string is invalid with respect to VulnerabilityCheck
   */
  public static VulnerabilityCheck fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VulnerabilityCheck.class);
  }

  /**
   * Convert an instance of VulnerabilityCheck to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

