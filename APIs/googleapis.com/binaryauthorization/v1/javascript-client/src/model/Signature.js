/**
 * Binary Authorization API
 * The management interface for Binary Authorization, a service that provides policy-based deployment validation and control for images deployed to Google Kubernetes Engine (GKE), Anthos Service Mesh, Anthos Clusters, and Cloud Run. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The Signature model module.
 * @module model/Signature
 * @version v1
 */
class Signature {
    /**
     * Constructs a new <code>Signature</code>.
     * Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from &#x60;public_key_id&#x60; to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature &#x60;public_key_id&#x60; as anything more than a key lookup hint. The &#x60;public_key_id&#x60; DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The &#x60;public_key_id&#x60; is not recognized by the verifier. * The public key that &#x60;public_key_id&#x60; refers to does not verify the signature with respect to the payload. The &#x60;signature&#x60; contents SHOULD NOT be \&quot;attached\&quot; (where the payload is included with the serialized &#x60;signature&#x60; bytes). Verifiers MUST ignore any \&quot;attached\&quot; payload and only verify signatures with respect to explicitly provided payload (e.g. a &#x60;payload&#x60; field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
     * @alias module:model/Signature
     */
    constructor() { 
        
        Signature.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Signature</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Signature} obj Optional instance to populate.
     * @return {module:model/Signature} The populated <code>Signature</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Signature();

            if (data.hasOwnProperty('publicKeyId')) {
                obj['publicKeyId'] = ApiClient.convertToType(data['publicKeyId'], 'String');
            }
            if (data.hasOwnProperty('signature')) {
                obj['signature'] = ApiClient.convertToType(data['signature'], 'Blob');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Signature</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Signature</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['publicKeyId'] && !(typeof data['publicKeyId'] === 'string' || data['publicKeyId'] instanceof String)) {
            throw new Error("Expected the field `publicKeyId` to be a primitive type in the JSON string but got " + data['publicKeyId']);
        }

        return true;
    }


}



/**
 * The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * \"openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA\" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * \"ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU\" * \"nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5\"
 * @member {String} publicKeyId
 */
Signature.prototype['publicKeyId'] = undefined;

/**
 * The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
 * @member {Blob} signature
 */
Signature.prototype['signature'] = undefined;






export default Signature;

