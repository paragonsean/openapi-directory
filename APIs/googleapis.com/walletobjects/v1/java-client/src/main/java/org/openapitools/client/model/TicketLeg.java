/*
 * Google Wallet API
 * API for issuers to save and manage Google Wallet Objects.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.LocalizedString;
import org.openapitools.client.model.TicketSeat;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * TicketLeg
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:24.677339-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TicketLeg {
  public static final String SERIALIZED_NAME_ARRIVAL_DATE_TIME = "arrivalDateTime";
  @SerializedName(SERIALIZED_NAME_ARRIVAL_DATE_TIME)
  private String arrivalDateTime;

  public static final String SERIALIZED_NAME_CARRIAGE = "carriage";
  @SerializedName(SERIALIZED_NAME_CARRIAGE)
  private String carriage;

  public static final String SERIALIZED_NAME_DEPARTURE_DATE_TIME = "departureDateTime";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_DATE_TIME)
  private String departureDateTime;

  public static final String SERIALIZED_NAME_DESTINATION_NAME = "destinationName";
  @SerializedName(SERIALIZED_NAME_DESTINATION_NAME)
  private LocalizedString destinationName;

  public static final String SERIALIZED_NAME_DESTINATION_STATION_CODE = "destinationStationCode";
  @SerializedName(SERIALIZED_NAME_DESTINATION_STATION_CODE)
  private String destinationStationCode;

  public static final String SERIALIZED_NAME_FARE_NAME = "fareName";
  @SerializedName(SERIALIZED_NAME_FARE_NAME)
  private LocalizedString fareName;

  public static final String SERIALIZED_NAME_ORIGIN_NAME = "originName";
  @SerializedName(SERIALIZED_NAME_ORIGIN_NAME)
  private LocalizedString originName;

  public static final String SERIALIZED_NAME_ORIGIN_STATION_CODE = "originStationCode";
  @SerializedName(SERIALIZED_NAME_ORIGIN_STATION_CODE)
  private String originStationCode;

  public static final String SERIALIZED_NAME_PLATFORM = "platform";
  @SerializedName(SERIALIZED_NAME_PLATFORM)
  private String platform;

  public static final String SERIALIZED_NAME_TICKET_SEAT = "ticketSeat";
  @SerializedName(SERIALIZED_NAME_TICKET_SEAT)
  private TicketSeat ticketSeat;

  public static final String SERIALIZED_NAME_TICKET_SEATS = "ticketSeats";
  @SerializedName(SERIALIZED_NAME_TICKET_SEATS)
  private List<TicketSeat> ticketSeats = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSIT_OPERATOR_NAME = "transitOperatorName";
  @SerializedName(SERIALIZED_NAME_TRANSIT_OPERATOR_NAME)
  private LocalizedString transitOperatorName;

  public static final String SERIALIZED_NAME_TRANSIT_TERMINUS_NAME = "transitTerminusName";
  @SerializedName(SERIALIZED_NAME_TRANSIT_TERMINUS_NAME)
  private LocalizedString transitTerminusName;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public TicketLeg() {
  }

  public TicketLeg arrivalDateTime(String arrivalDateTime) {
    this.arrivalDateTime = arrivalDateTime;
    return this;
  }

  /**
   * The date/time of arrival. This is an ISO 8601 extended format date/time, with or without an offset. Time may be specified up to nanosecond precision. Offsets may be specified with seconds precision (even though offset seconds is not part of ISO 8601). For example: &#x60;1985-04-12T23:20:50.52Z&#x60; would be 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC. &#x60;1985-04-12T19:20:50.52-04:00&#x60; would be 20 minutes and 50.52 seconds after the 19th hour of April 12th, 1985, 4 hours before UTC (same instant in time as the above example). If the event were in New York, this would be the equivalent of Eastern Daylight Time (EDT). Remember that offset varies in regions that observe Daylight Saving Time (or Summer Time), depending on the time of the year. &#x60;1985-04-12T19:20:50.52&#x60; would be 20 minutes and 50.52 seconds after the 19th hour of April 12th, 1985 with no offset information. The portion of the date/time without the offset is considered the \&quot;local date/time\&quot;. This should be the local date/time at the destination station. For example, if the event occurs at the 20th hour of June 5th, 2018 at the destination station, the local date/time portion should be &#x60;2018-06-05T20:00:00&#x60;. If the local date/time at the destination station is 4 hours before UTC, an offset of &#x60;-04:00&#x60; may be appended. Without offset information, some rich features may not be available.
   * @return arrivalDateTime
   */
  @javax.annotation.Nullable
  public String getArrivalDateTime() {
    return arrivalDateTime;
  }

  public void setArrivalDateTime(String arrivalDateTime) {
    this.arrivalDateTime = arrivalDateTime;
  }


  public TicketLeg carriage(String carriage) {
    this.carriage = carriage;
    return this;
  }

  /**
   * The train or ship name/number that the passsenger needs to board.
   * @return carriage
   */
  @javax.annotation.Nullable
  public String getCarriage() {
    return carriage;
  }

  public void setCarriage(String carriage) {
    this.carriage = carriage;
  }


  public TicketLeg departureDateTime(String departureDateTime) {
    this.departureDateTime = departureDateTime;
    return this;
  }

  /**
   * The date/time of departure. This is required if there is no validity time interval set on the transit object. This is an ISO 8601 extended format date/time, with or without an offset. Time may be specified up to nanosecond precision. Offsets may be specified with seconds precision (even though offset seconds is not part of ISO 8601). For example: &#x60;1985-04-12T23:20:50.52Z&#x60; would be 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC. &#x60;1985-04-12T19:20:50.52-04:00&#x60; would be 20 minutes and 50.52 seconds after the 19th hour of April 12th, 1985, 4 hours before UTC (same instant in time as the above example). If the event were in New York, this would be the equivalent of Eastern Daylight Time (EDT). Remember that offset varies in regions that observe Daylight Saving Time (or Summer Time), depending on the time of the year. &#x60;1985-04-12T19:20:50.52&#x60; would be 20 minutes and 50.52 seconds after the 19th hour of April 12th, 1985 with no offset information. The portion of the date/time without the offset is considered the \&quot;local date/time\&quot;. This should be the local date/time at the origin station. For example, if the departure occurs at the 20th hour of June 5th, 2018 at the origin station, the local date/time portion should be &#x60;2018-06-05T20:00:00&#x60;. If the local date/time at the origin station is 4 hours before UTC, an offset of &#x60;-04:00&#x60; may be appended. Without offset information, some rich features may not be available.
   * @return departureDateTime
   */
  @javax.annotation.Nullable
  public String getDepartureDateTime() {
    return departureDateTime;
  }

  public void setDepartureDateTime(String departureDateTime) {
    this.departureDateTime = departureDateTime;
  }


  public TicketLeg destinationName(LocalizedString destinationName) {
    this.destinationName = destinationName;
    return this;
  }

  /**
   * Get destinationName
   * @return destinationName
   */
  @javax.annotation.Nullable
  public LocalizedString getDestinationName() {
    return destinationName;
  }

  public void setDestinationName(LocalizedString destinationName) {
    this.destinationName = destinationName;
  }


  public TicketLeg destinationStationCode(String destinationStationCode) {
    this.destinationStationCode = destinationStationCode;
    return this;
  }

  /**
   * The destination station code.
   * @return destinationStationCode
   */
  @javax.annotation.Nullable
  public String getDestinationStationCode() {
    return destinationStationCode;
  }

  public void setDestinationStationCode(String destinationStationCode) {
    this.destinationStationCode = destinationStationCode;
  }


  public TicketLeg fareName(LocalizedString fareName) {
    this.fareName = fareName;
    return this;
  }

  /**
   * Get fareName
   * @return fareName
   */
  @javax.annotation.Nullable
  public LocalizedString getFareName() {
    return fareName;
  }

  public void setFareName(LocalizedString fareName) {
    this.fareName = fareName;
  }


  public TicketLeg originName(LocalizedString originName) {
    this.originName = originName;
    return this;
  }

  /**
   * Get originName
   * @return originName
   */
  @javax.annotation.Nullable
  public LocalizedString getOriginName() {
    return originName;
  }

  public void setOriginName(LocalizedString originName) {
    this.originName = originName;
  }


  public TicketLeg originStationCode(String originStationCode) {
    this.originStationCode = originStationCode;
    return this;
  }

  /**
   * The origin station code. This is required if &#x60;destinationStationCode&#x60; is present or if &#x60;originName&#x60; is not present.
   * @return originStationCode
   */
  @javax.annotation.Nullable
  public String getOriginStationCode() {
    return originStationCode;
  }

  public void setOriginStationCode(String originStationCode) {
    this.originStationCode = originStationCode;
  }


  public TicketLeg platform(String platform) {
    this.platform = platform;
    return this;
  }

  /**
   * The platform or gate where the passenger can board the carriage.
   * @return platform
   */
  @javax.annotation.Nullable
  public String getPlatform() {
    return platform;
  }

  public void setPlatform(String platform) {
    this.platform = platform;
  }


  public TicketLeg ticketSeat(TicketSeat ticketSeat) {
    this.ticketSeat = ticketSeat;
    return this;
  }

  /**
   * Get ticketSeat
   * @return ticketSeat
   */
  @javax.annotation.Nullable
  public TicketSeat getTicketSeat() {
    return ticketSeat;
  }

  public void setTicketSeat(TicketSeat ticketSeat) {
    this.ticketSeat = ticketSeat;
  }


  public TicketLeg ticketSeats(List<TicketSeat> ticketSeats) {
    this.ticketSeats = ticketSeats;
    return this;
  }

  public TicketLeg addTicketSeatsItem(TicketSeat ticketSeatsItem) {
    if (this.ticketSeats == null) {
      this.ticketSeats = new ArrayList<>();
    }
    this.ticketSeats.add(ticketSeatsItem);
    return this;
  }

  /**
   * The reserved seat for the passenger(s). If only one seat is to be specified then use the &#x60;ticketSeat&#x60; field instead. Both &#x60;ticketSeat&#x60; and &#x60;ticketSeats&#x60; may not be set.
   * @return ticketSeats
   */
  @javax.annotation.Nullable
  public List<TicketSeat> getTicketSeats() {
    return ticketSeats;
  }

  public void setTicketSeats(List<TicketSeat> ticketSeats) {
    this.ticketSeats = ticketSeats;
  }


  public TicketLeg transitOperatorName(LocalizedString transitOperatorName) {
    this.transitOperatorName = transitOperatorName;
    return this;
  }

  /**
   * Get transitOperatorName
   * @return transitOperatorName
   */
  @javax.annotation.Nullable
  public LocalizedString getTransitOperatorName() {
    return transitOperatorName;
  }

  public void setTransitOperatorName(LocalizedString transitOperatorName) {
    this.transitOperatorName = transitOperatorName;
  }


  public TicketLeg transitTerminusName(LocalizedString transitTerminusName) {
    this.transitTerminusName = transitTerminusName;
    return this;
  }

  /**
   * Get transitTerminusName
   * @return transitTerminusName
   */
  @javax.annotation.Nullable
  public LocalizedString getTransitTerminusName() {
    return transitTerminusName;
  }

  public void setTransitTerminusName(LocalizedString transitTerminusName) {
    this.transitTerminusName = transitTerminusName;
  }


  public TicketLeg zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * The zone of boarding within the platform.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TicketLeg ticketLeg = (TicketLeg) o;
    return Objects.equals(this.arrivalDateTime, ticketLeg.arrivalDateTime) &&
        Objects.equals(this.carriage, ticketLeg.carriage) &&
        Objects.equals(this.departureDateTime, ticketLeg.departureDateTime) &&
        Objects.equals(this.destinationName, ticketLeg.destinationName) &&
        Objects.equals(this.destinationStationCode, ticketLeg.destinationStationCode) &&
        Objects.equals(this.fareName, ticketLeg.fareName) &&
        Objects.equals(this.originName, ticketLeg.originName) &&
        Objects.equals(this.originStationCode, ticketLeg.originStationCode) &&
        Objects.equals(this.platform, ticketLeg.platform) &&
        Objects.equals(this.ticketSeat, ticketLeg.ticketSeat) &&
        Objects.equals(this.ticketSeats, ticketLeg.ticketSeats) &&
        Objects.equals(this.transitOperatorName, ticketLeg.transitOperatorName) &&
        Objects.equals(this.transitTerminusName, ticketLeg.transitTerminusName) &&
        Objects.equals(this.zone, ticketLeg.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arrivalDateTime, carriage, departureDateTime, destinationName, destinationStationCode, fareName, originName, originStationCode, platform, ticketSeat, ticketSeats, transitOperatorName, transitTerminusName, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TicketLeg {\n");
    sb.append("    arrivalDateTime: ").append(toIndentedString(arrivalDateTime)).append("\n");
    sb.append("    carriage: ").append(toIndentedString(carriage)).append("\n");
    sb.append("    departureDateTime: ").append(toIndentedString(departureDateTime)).append("\n");
    sb.append("    destinationName: ").append(toIndentedString(destinationName)).append("\n");
    sb.append("    destinationStationCode: ").append(toIndentedString(destinationStationCode)).append("\n");
    sb.append("    fareName: ").append(toIndentedString(fareName)).append("\n");
    sb.append("    originName: ").append(toIndentedString(originName)).append("\n");
    sb.append("    originStationCode: ").append(toIndentedString(originStationCode)).append("\n");
    sb.append("    platform: ").append(toIndentedString(platform)).append("\n");
    sb.append("    ticketSeat: ").append(toIndentedString(ticketSeat)).append("\n");
    sb.append("    ticketSeats: ").append(toIndentedString(ticketSeats)).append("\n");
    sb.append("    transitOperatorName: ").append(toIndentedString(transitOperatorName)).append("\n");
    sb.append("    transitTerminusName: ").append(toIndentedString(transitTerminusName)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("arrivalDateTime");
    openapiFields.add("carriage");
    openapiFields.add("departureDateTime");
    openapiFields.add("destinationName");
    openapiFields.add("destinationStationCode");
    openapiFields.add("fareName");
    openapiFields.add("originName");
    openapiFields.add("originStationCode");
    openapiFields.add("platform");
    openapiFields.add("ticketSeat");
    openapiFields.add("ticketSeats");
    openapiFields.add("transitOperatorName");
    openapiFields.add("transitTerminusName");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TicketLeg
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TicketLeg.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TicketLeg is not found in the empty JSON string", TicketLeg.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TicketLeg.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TicketLeg` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("arrivalDateTime") != null && !jsonObj.get("arrivalDateTime").isJsonNull()) && !jsonObj.get("arrivalDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `arrivalDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("arrivalDateTime").toString()));
      }
      if ((jsonObj.get("carriage") != null && !jsonObj.get("carriage").isJsonNull()) && !jsonObj.get("carriage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `carriage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("carriage").toString()));
      }
      if ((jsonObj.get("departureDateTime") != null && !jsonObj.get("departureDateTime").isJsonNull()) && !jsonObj.get("departureDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `departureDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("departureDateTime").toString()));
      }
      // validate the optional field `destinationName`
      if (jsonObj.get("destinationName") != null && !jsonObj.get("destinationName").isJsonNull()) {
        LocalizedString.validateJsonElement(jsonObj.get("destinationName"));
      }
      if ((jsonObj.get("destinationStationCode") != null && !jsonObj.get("destinationStationCode").isJsonNull()) && !jsonObj.get("destinationStationCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationStationCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destinationStationCode").toString()));
      }
      // validate the optional field `fareName`
      if (jsonObj.get("fareName") != null && !jsonObj.get("fareName").isJsonNull()) {
        LocalizedString.validateJsonElement(jsonObj.get("fareName"));
      }
      // validate the optional field `originName`
      if (jsonObj.get("originName") != null && !jsonObj.get("originName").isJsonNull()) {
        LocalizedString.validateJsonElement(jsonObj.get("originName"));
      }
      if ((jsonObj.get("originStationCode") != null && !jsonObj.get("originStationCode").isJsonNull()) && !jsonObj.get("originStationCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originStationCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originStationCode").toString()));
      }
      if ((jsonObj.get("platform") != null && !jsonObj.get("platform").isJsonNull()) && !jsonObj.get("platform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `platform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("platform").toString()));
      }
      // validate the optional field `ticketSeat`
      if (jsonObj.get("ticketSeat") != null && !jsonObj.get("ticketSeat").isJsonNull()) {
        TicketSeat.validateJsonElement(jsonObj.get("ticketSeat"));
      }
      if (jsonObj.get("ticketSeats") != null && !jsonObj.get("ticketSeats").isJsonNull()) {
        JsonArray jsonArrayticketSeats = jsonObj.getAsJsonArray("ticketSeats");
        if (jsonArrayticketSeats != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ticketSeats").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ticketSeats` to be an array in the JSON string but got `%s`", jsonObj.get("ticketSeats").toString()));
          }

          // validate the optional field `ticketSeats` (array)
          for (int i = 0; i < jsonArrayticketSeats.size(); i++) {
            TicketSeat.validateJsonElement(jsonArrayticketSeats.get(i));
          };
        }
      }
      // validate the optional field `transitOperatorName`
      if (jsonObj.get("transitOperatorName") != null && !jsonObj.get("transitOperatorName").isJsonNull()) {
        LocalizedString.validateJsonElement(jsonObj.get("transitOperatorName"));
      }
      // validate the optional field `transitTerminusName`
      if (jsonObj.get("transitTerminusName") != null && !jsonObj.get("transitTerminusName").isJsonNull()) {
        LocalizedString.validateJsonElement(jsonObj.get("transitTerminusName"));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TicketLeg.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TicketLeg' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TicketLeg> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TicketLeg.class));

       return (TypeAdapter<T>) new TypeAdapter<TicketLeg>() {
           @Override
           public void write(JsonWriter out, TicketLeg value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TicketLeg read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TicketLeg given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TicketLeg
   * @throws IOException if the JSON string is invalid with respect to TicketLeg
   */
  public static TicketLeg fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TicketLeg.class);
  }

  /**
   * Convert an instance of TicketLeg to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

