/*
 * Google Wallet API
 * API for issuers to save and manage Google Wallet Objects.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Blobstore2Info;
import org.openapitools.client.model.CompositeMedia;
import org.openapitools.client.model.ContentTypeInfo;
import org.openapitools.client.model.DiffChecksumsResponse;
import org.openapitools.client.model.DiffDownloadResponse;
import org.openapitools.client.model.DiffUploadRequest;
import org.openapitools.client.model.DiffUploadResponse;
import org.openapitools.client.model.DiffVersionResponse;
import org.openapitools.client.model.DownloadParameters;
import org.openapitools.client.model.ObjectId;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A reference to data stored on the filesystem, on GFS or in blobstore.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:24.677339-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Media {
  public static final String SERIALIZED_NAME_ALGORITHM = "algorithm";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_ALGORITHM)
  private String algorithm;

  public static final String SERIALIZED_NAME_BIGSTORE_OBJECT_REF = "bigstoreObjectRef";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_BIGSTORE_OBJECT_REF)
  private byte[] bigstoreObjectRef;

  public static final String SERIALIZED_NAME_BLOB_REF = "blobRef";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_BLOB_REF)
  private byte[] blobRef;

  public static final String SERIALIZED_NAME_BLOBSTORE2_INFO = "blobstore2Info";
  @SerializedName(SERIALIZED_NAME_BLOBSTORE2_INFO)
  private Blobstore2Info blobstore2Info;

  public static final String SERIALIZED_NAME_COMPOSITE_MEDIA = "compositeMedia";
  @SerializedName(SERIALIZED_NAME_COMPOSITE_MEDIA)
  private List<CompositeMedia> compositeMedia = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTENT_TYPE = "contentType";
  @SerializedName(SERIALIZED_NAME_CONTENT_TYPE)
  private String contentType;

  public static final String SERIALIZED_NAME_CONTENT_TYPE_INFO = "contentTypeInfo";
  @SerializedName(SERIALIZED_NAME_CONTENT_TYPE_INFO)
  private ContentTypeInfo contentTypeInfo;

  public static final String SERIALIZED_NAME_COSMO_BINARY_REFERENCE = "cosmoBinaryReference";
  @SerializedName(SERIALIZED_NAME_COSMO_BINARY_REFERENCE)
  private byte[] cosmoBinaryReference;

  public static final String SERIALIZED_NAME_CRC32C_HASH = "crc32cHash";
  @SerializedName(SERIALIZED_NAME_CRC32C_HASH)
  private Integer crc32cHash;

  public static final String SERIALIZED_NAME_DIFF_CHECKSUMS_RESPONSE = "diffChecksumsResponse";
  @SerializedName(SERIALIZED_NAME_DIFF_CHECKSUMS_RESPONSE)
  private DiffChecksumsResponse diffChecksumsResponse;

  public static final String SERIALIZED_NAME_DIFF_DOWNLOAD_RESPONSE = "diffDownloadResponse";
  @SerializedName(SERIALIZED_NAME_DIFF_DOWNLOAD_RESPONSE)
  private DiffDownloadResponse diffDownloadResponse;

  public static final String SERIALIZED_NAME_DIFF_UPLOAD_REQUEST = "diffUploadRequest";
  @SerializedName(SERIALIZED_NAME_DIFF_UPLOAD_REQUEST)
  private DiffUploadRequest diffUploadRequest;

  public static final String SERIALIZED_NAME_DIFF_UPLOAD_RESPONSE = "diffUploadResponse";
  @SerializedName(SERIALIZED_NAME_DIFF_UPLOAD_RESPONSE)
  private DiffUploadResponse diffUploadResponse;

  public static final String SERIALIZED_NAME_DIFF_VERSION_RESPONSE = "diffVersionResponse";
  @SerializedName(SERIALIZED_NAME_DIFF_VERSION_RESPONSE)
  private DiffVersionResponse diffVersionResponse;

  public static final String SERIALIZED_NAME_DOWNLOAD_PARAMETERS = "downloadParameters";
  @SerializedName(SERIALIZED_NAME_DOWNLOAD_PARAMETERS)
  private DownloadParameters downloadParameters;

  public static final String SERIALIZED_NAME_FILENAME = "filename";
  @SerializedName(SERIALIZED_NAME_FILENAME)
  private String filename;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_HASH_VERIFIED = "hashVerified";
  @SerializedName(SERIALIZED_NAME_HASH_VERIFIED)
  private Boolean hashVerified;

  public static final String SERIALIZED_NAME_INLINE = "inline";
  @SerializedName(SERIALIZED_NAME_INLINE)
  private byte[] inline;

  public static final String SERIALIZED_NAME_IS_POTENTIAL_RETRY = "isPotentialRetry";
  @SerializedName(SERIALIZED_NAME_IS_POTENTIAL_RETRY)
  private Boolean isPotentialRetry;

  public static final String SERIALIZED_NAME_LENGTH = "length";
  @SerializedName(SERIALIZED_NAME_LENGTH)
  private String length;

  public static final String SERIALIZED_NAME_MD5_HASH = "md5Hash";
  @SerializedName(SERIALIZED_NAME_MD5_HASH)
  private byte[] md5Hash;

  public static final String SERIALIZED_NAME_MEDIA_ID = "mediaId";
  @SerializedName(SERIALIZED_NAME_MEDIA_ID)
  private byte[] mediaId;

  public static final String SERIALIZED_NAME_OBJECT_ID = "objectId";
  @SerializedName(SERIALIZED_NAME_OBJECT_ID)
  private ObjectId objectId;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  /**
   * Describes what the field reference contains.
   */
  @JsonAdapter(ReferenceTypeEnum.Adapter.class)
  public enum ReferenceTypeEnum {
    PATH("PATH"),
    
    BLOB_REF("BLOB_REF"),
    
    INLINE("INLINE"),
    
    GET_MEDIA("GET_MEDIA"),
    
    COMPOSITE_MEDIA("COMPOSITE_MEDIA"),
    
    BIGSTORE_REF("BIGSTORE_REF"),
    
    DIFF_VERSION_RESPONSE("DIFF_VERSION_RESPONSE"),
    
    DIFF_CHECKSUMS_RESPONSE("DIFF_CHECKSUMS_RESPONSE"),
    
    DIFF_DOWNLOAD_RESPONSE("DIFF_DOWNLOAD_RESPONSE"),
    
    DIFF_UPLOAD_REQUEST("DIFF_UPLOAD_REQUEST"),
    
    DIFF_UPLOAD_RESPONSE("DIFF_UPLOAD_RESPONSE"),
    
    COSMO_BINARY_REFERENCE("COSMO_BINARY_REFERENCE"),
    
    ARBITRARY_BYTES("ARBITRARY_BYTES");

    private String value;

    ReferenceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReferenceTypeEnum fromValue(String value) {
      for (ReferenceTypeEnum b : ReferenceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ReferenceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReferenceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReferenceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReferenceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReferenceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REFERENCE_TYPE = "referenceType";
  @SerializedName(SERIALIZED_NAME_REFERENCE_TYPE)
  private ReferenceTypeEnum referenceType;

  public static final String SERIALIZED_NAME_SHA1_HASH = "sha1Hash";
  @SerializedName(SERIALIZED_NAME_SHA1_HASH)
  private byte[] sha1Hash;

  public static final String SERIALIZED_NAME_SHA256_HASH = "sha256Hash";
  @SerializedName(SERIALIZED_NAME_SHA256_HASH)
  private byte[] sha256Hash;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private String timestamp;

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  private String token;

  public Media() {
  }

  @Deprecated
  public Media algorithm(String algorithm) {
    this.algorithm = algorithm;
    return this;
  }

  /**
   * Deprecated, use one of explicit hash type fields instead. Algorithm used for calculating the hash. As of 2011/01/21, \&quot;MD5\&quot; is the only possible value for this field. New values may be added at any time.
   * @return algorithm
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getAlgorithm() {
    return algorithm;
  }

  @Deprecated
  public void setAlgorithm(String algorithm) {
    this.algorithm = algorithm;
  }


  @Deprecated
  public Media bigstoreObjectRef(byte[] bigstoreObjectRef) {
    this.bigstoreObjectRef = bigstoreObjectRef;
    return this;
  }

  /**
   * Use object_id instead.
   * @return bigstoreObjectRef
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public byte[] getBigstoreObjectRef() {
    return bigstoreObjectRef;
  }

  @Deprecated
  public void setBigstoreObjectRef(byte[] bigstoreObjectRef) {
    this.bigstoreObjectRef = bigstoreObjectRef;
  }


  @Deprecated
  public Media blobRef(byte[] blobRef) {
    this.blobRef = blobRef;
    return this;
  }

  /**
   * Blobstore v1 reference, set if reference_type is BLOBSTORE_REF This should be the byte representation of a blobstore.BlobRef. Since Blobstore is deprecating v1, use blobstore2_info instead. For now, any v2 blob will also be represented in this field as v1 BlobRef.
   * @return blobRef
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public byte[] getBlobRef() {
    return blobRef;
  }

  @Deprecated
  public void setBlobRef(byte[] blobRef) {
    this.blobRef = blobRef;
  }


  public Media blobstore2Info(Blobstore2Info blobstore2Info) {
    this.blobstore2Info = blobstore2Info;
    return this;
  }

  /**
   * Get blobstore2Info
   * @return blobstore2Info
   */
  @javax.annotation.Nullable
  public Blobstore2Info getBlobstore2Info() {
    return blobstore2Info;
  }

  public void setBlobstore2Info(Blobstore2Info blobstore2Info) {
    this.blobstore2Info = blobstore2Info;
  }


  public Media compositeMedia(List<CompositeMedia> compositeMedia) {
    this.compositeMedia = compositeMedia;
    return this;
  }

  public Media addCompositeMediaItem(CompositeMedia compositeMediaItem) {
    if (this.compositeMedia == null) {
      this.compositeMedia = new ArrayList<>();
    }
    this.compositeMedia.add(compositeMediaItem);
    return this;
  }

  /**
   * A composite media composed of one or more media objects, set if reference_type is COMPOSITE_MEDIA. The media length field must be set to the sum of the lengths of all composite media objects. Note: All composite media must have length specified.
   * @return compositeMedia
   */
  @javax.annotation.Nullable
  public List<CompositeMedia> getCompositeMedia() {
    return compositeMedia;
  }

  public void setCompositeMedia(List<CompositeMedia> compositeMedia) {
    this.compositeMedia = compositeMedia;
  }


  public Media contentType(String contentType) {
    this.contentType = contentType;
    return this;
  }

  /**
   * MIME type of the data
   * @return contentType
   */
  @javax.annotation.Nullable
  public String getContentType() {
    return contentType;
  }

  public void setContentType(String contentType) {
    this.contentType = contentType;
  }


  public Media contentTypeInfo(ContentTypeInfo contentTypeInfo) {
    this.contentTypeInfo = contentTypeInfo;
    return this;
  }

  /**
   * Get contentTypeInfo
   * @return contentTypeInfo
   */
  @javax.annotation.Nullable
  public ContentTypeInfo getContentTypeInfo() {
    return contentTypeInfo;
  }

  public void setContentTypeInfo(ContentTypeInfo contentTypeInfo) {
    this.contentTypeInfo = contentTypeInfo;
  }


  public Media cosmoBinaryReference(byte[] cosmoBinaryReference) {
    this.cosmoBinaryReference = cosmoBinaryReference;
    return this;
  }

  /**
   * A binary data reference for a media download. Serves as a technology-agnostic binary reference in some Google infrastructure. This value is a serialized storage_cosmo.BinaryReference proto. Storing it as bytes is a hack to get around the fact that the cosmo proto (as well as others it includes) doesn&#39;t support JavaScript. This prevents us from including the actual type of this field.
   * @return cosmoBinaryReference
   */
  @javax.annotation.Nullable
  public byte[] getCosmoBinaryReference() {
    return cosmoBinaryReference;
  }

  public void setCosmoBinaryReference(byte[] cosmoBinaryReference) {
    this.cosmoBinaryReference = cosmoBinaryReference;
  }


  public Media crc32cHash(Integer crc32cHash) {
    this.crc32cHash = crc32cHash;
    return this;
  }

  /**
   * For Scotty Uploads: Scotty-provided hashes for uploads For Scotty Downloads: (WARNING: DO NOT USE WITHOUT PERMISSION FROM THE SCOTTY TEAM.) A Hash provided by the agent to be used to verify the data being downloaded. Currently only supported for inline payloads. Further, only crc32c_hash is currently supported.
   * @return crc32cHash
   */
  @javax.annotation.Nullable
  public Integer getCrc32cHash() {
    return crc32cHash;
  }

  public void setCrc32cHash(Integer crc32cHash) {
    this.crc32cHash = crc32cHash;
  }


  public Media diffChecksumsResponse(DiffChecksumsResponse diffChecksumsResponse) {
    this.diffChecksumsResponse = diffChecksumsResponse;
    return this;
  }

  /**
   * Get diffChecksumsResponse
   * @return diffChecksumsResponse
   */
  @javax.annotation.Nullable
  public DiffChecksumsResponse getDiffChecksumsResponse() {
    return diffChecksumsResponse;
  }

  public void setDiffChecksumsResponse(DiffChecksumsResponse diffChecksumsResponse) {
    this.diffChecksumsResponse = diffChecksumsResponse;
  }


  public Media diffDownloadResponse(DiffDownloadResponse diffDownloadResponse) {
    this.diffDownloadResponse = diffDownloadResponse;
    return this;
  }

  /**
   * Get diffDownloadResponse
   * @return diffDownloadResponse
   */
  @javax.annotation.Nullable
  public DiffDownloadResponse getDiffDownloadResponse() {
    return diffDownloadResponse;
  }

  public void setDiffDownloadResponse(DiffDownloadResponse diffDownloadResponse) {
    this.diffDownloadResponse = diffDownloadResponse;
  }


  public Media diffUploadRequest(DiffUploadRequest diffUploadRequest) {
    this.diffUploadRequest = diffUploadRequest;
    return this;
  }

  /**
   * Get diffUploadRequest
   * @return diffUploadRequest
   */
  @javax.annotation.Nullable
  public DiffUploadRequest getDiffUploadRequest() {
    return diffUploadRequest;
  }

  public void setDiffUploadRequest(DiffUploadRequest diffUploadRequest) {
    this.diffUploadRequest = diffUploadRequest;
  }


  public Media diffUploadResponse(DiffUploadResponse diffUploadResponse) {
    this.diffUploadResponse = diffUploadResponse;
    return this;
  }

  /**
   * Get diffUploadResponse
   * @return diffUploadResponse
   */
  @javax.annotation.Nullable
  public DiffUploadResponse getDiffUploadResponse() {
    return diffUploadResponse;
  }

  public void setDiffUploadResponse(DiffUploadResponse diffUploadResponse) {
    this.diffUploadResponse = diffUploadResponse;
  }


  public Media diffVersionResponse(DiffVersionResponse diffVersionResponse) {
    this.diffVersionResponse = diffVersionResponse;
    return this;
  }

  /**
   * Get diffVersionResponse
   * @return diffVersionResponse
   */
  @javax.annotation.Nullable
  public DiffVersionResponse getDiffVersionResponse() {
    return diffVersionResponse;
  }

  public void setDiffVersionResponse(DiffVersionResponse diffVersionResponse) {
    this.diffVersionResponse = diffVersionResponse;
  }


  public Media downloadParameters(DownloadParameters downloadParameters) {
    this.downloadParameters = downloadParameters;
    return this;
  }

  /**
   * Get downloadParameters
   * @return downloadParameters
   */
  @javax.annotation.Nullable
  public DownloadParameters getDownloadParameters() {
    return downloadParameters;
  }

  public void setDownloadParameters(DownloadParameters downloadParameters) {
    this.downloadParameters = downloadParameters;
  }


  public Media filename(String filename) {
    this.filename = filename;
    return this;
  }

  /**
   * Original file name
   * @return filename
   */
  @javax.annotation.Nullable
  public String getFilename() {
    return filename;
  }

  public void setFilename(String filename) {
    this.filename = filename;
  }


  @Deprecated
  public Media hash(String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * Deprecated, use one of explicit hash type fields instead. These two hash related fields will only be populated on Scotty based media uploads and will contain the content of the hash group in the NotificationRequest: http://cs/#google3/uploader/service/proto/upload_listener.proto&amp;q&#x3D;class:Hash Hex encoded hash value of the uploaded media.
   * @return hash
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  @Deprecated
  public void setHash(String hash) {
    this.hash = hash;
  }


  public Media hashVerified(Boolean hashVerified) {
    this.hashVerified = hashVerified;
    return this;
  }

  /**
   * For Scotty uploads only. If a user sends a hash code and the backend has requested that Scotty verify the upload against the client hash, Scotty will perform the check on behalf of the backend and will reject it if the hashes don&#39;t match. This is set to true if Scotty performed this verification.
   * @return hashVerified
   */
  @javax.annotation.Nullable
  public Boolean getHashVerified() {
    return hashVerified;
  }

  public void setHashVerified(Boolean hashVerified) {
    this.hashVerified = hashVerified;
  }


  public Media inline(byte[] inline) {
    this.inline = inline;
    return this;
  }

  /**
   * Media data, set if reference_type is INLINE
   * @return inline
   */
  @javax.annotation.Nullable
  public byte[] getInline() {
    return inline;
  }

  public void setInline(byte[] inline) {
    this.inline = inline;
  }


  public Media isPotentialRetry(Boolean isPotentialRetry) {
    this.isPotentialRetry = isPotentialRetry;
    return this;
  }

  /**
   * |is_potential_retry| is set false only when Scotty is certain that it has not sent the request before. When a client resumes an upload, this field must be set true in agent calls, because Scotty cannot be certain that it has never sent the request before due to potential failure in the session state persistence.
   * @return isPotentialRetry
   */
  @javax.annotation.Nullable
  public Boolean getIsPotentialRetry() {
    return isPotentialRetry;
  }

  public void setIsPotentialRetry(Boolean isPotentialRetry) {
    this.isPotentialRetry = isPotentialRetry;
  }


  public Media length(String length) {
    this.length = length;
    return this;
  }

  /**
   * Size of the data, in bytes
   * @return length
   */
  @javax.annotation.Nullable
  public String getLength() {
    return length;
  }

  public void setLength(String length) {
    this.length = length;
  }


  public Media md5Hash(byte[] md5Hash) {
    this.md5Hash = md5Hash;
    return this;
  }

  /**
   * Scotty-provided MD5 hash for an upload.
   * @return md5Hash
   */
  @javax.annotation.Nullable
  public byte[] getMd5Hash() {
    return md5Hash;
  }

  public void setMd5Hash(byte[] md5Hash) {
    this.md5Hash = md5Hash;
  }


  public Media mediaId(byte[] mediaId) {
    this.mediaId = mediaId;
    return this;
  }

  /**
   * Media id to forward to the operation GetMedia. Can be set if reference_type is GET_MEDIA.
   * @return mediaId
   */
  @javax.annotation.Nullable
  public byte[] getMediaId() {
    return mediaId;
  }

  public void setMediaId(byte[] mediaId) {
    this.mediaId = mediaId;
  }


  public Media objectId(ObjectId objectId) {
    this.objectId = objectId;
    return this;
  }

  /**
   * Get objectId
   * @return objectId
   */
  @javax.annotation.Nullable
  public ObjectId getObjectId() {
    return objectId;
  }

  public void setObjectId(ObjectId objectId) {
    this.objectId = objectId;
  }


  public Media path(String path) {
    this.path = path;
    return this;
  }

  /**
   * Path to the data, set if reference_type is PATH
   * @return path
   */
  @javax.annotation.Nullable
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public Media referenceType(ReferenceTypeEnum referenceType) {
    this.referenceType = referenceType;
    return this;
  }

  /**
   * Describes what the field reference contains.
   * @return referenceType
   */
  @javax.annotation.Nullable
  public ReferenceTypeEnum getReferenceType() {
    return referenceType;
  }

  public void setReferenceType(ReferenceTypeEnum referenceType) {
    this.referenceType = referenceType;
  }


  public Media sha1Hash(byte[] sha1Hash) {
    this.sha1Hash = sha1Hash;
    return this;
  }

  /**
   * Scotty-provided SHA1 hash for an upload.
   * @return sha1Hash
   */
  @javax.annotation.Nullable
  public byte[] getSha1Hash() {
    return sha1Hash;
  }

  public void setSha1Hash(byte[] sha1Hash) {
    this.sha1Hash = sha1Hash;
  }


  public Media sha256Hash(byte[] sha256Hash) {
    this.sha256Hash = sha256Hash;
    return this;
  }

  /**
   * Scotty-provided SHA256 hash for an upload.
   * @return sha256Hash
   */
  @javax.annotation.Nullable
  public byte[] getSha256Hash() {
    return sha256Hash;
  }

  public void setSha256Hash(byte[] sha256Hash) {
    this.sha256Hash = sha256Hash;
  }


  public Media timestamp(String timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * Time at which the media data was last updated, in milliseconds since UNIX epoch
   * @return timestamp
   */
  @javax.annotation.Nullable
  public String getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(String timestamp) {
    this.timestamp = timestamp;
  }


  public Media token(String token) {
    this.token = token;
    return this;
  }

  /**
   * A unique fingerprint/version id for the media data
   * @return token
   */
  @javax.annotation.Nullable
  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Media media = (Media) o;
    return Objects.equals(this.algorithm, media.algorithm) &&
        Arrays.equals(this.bigstoreObjectRef, media.bigstoreObjectRef) &&
        Arrays.equals(this.blobRef, media.blobRef) &&
        Objects.equals(this.blobstore2Info, media.blobstore2Info) &&
        Objects.equals(this.compositeMedia, media.compositeMedia) &&
        Objects.equals(this.contentType, media.contentType) &&
        Objects.equals(this.contentTypeInfo, media.contentTypeInfo) &&
        Arrays.equals(this.cosmoBinaryReference, media.cosmoBinaryReference) &&
        Objects.equals(this.crc32cHash, media.crc32cHash) &&
        Objects.equals(this.diffChecksumsResponse, media.diffChecksumsResponse) &&
        Objects.equals(this.diffDownloadResponse, media.diffDownloadResponse) &&
        Objects.equals(this.diffUploadRequest, media.diffUploadRequest) &&
        Objects.equals(this.diffUploadResponse, media.diffUploadResponse) &&
        Objects.equals(this.diffVersionResponse, media.diffVersionResponse) &&
        Objects.equals(this.downloadParameters, media.downloadParameters) &&
        Objects.equals(this.filename, media.filename) &&
        Objects.equals(this.hash, media.hash) &&
        Objects.equals(this.hashVerified, media.hashVerified) &&
        Arrays.equals(this.inline, media.inline) &&
        Objects.equals(this.isPotentialRetry, media.isPotentialRetry) &&
        Objects.equals(this.length, media.length) &&
        Arrays.equals(this.md5Hash, media.md5Hash) &&
        Arrays.equals(this.mediaId, media.mediaId) &&
        Objects.equals(this.objectId, media.objectId) &&
        Objects.equals(this.path, media.path) &&
        Objects.equals(this.referenceType, media.referenceType) &&
        Arrays.equals(this.sha1Hash, media.sha1Hash) &&
        Arrays.equals(this.sha256Hash, media.sha256Hash) &&
        Objects.equals(this.timestamp, media.timestamp) &&
        Objects.equals(this.token, media.token);
  }

  @Override
  public int hashCode() {
    return Objects.hash(algorithm, Arrays.hashCode(bigstoreObjectRef), Arrays.hashCode(blobRef), blobstore2Info, compositeMedia, contentType, contentTypeInfo, Arrays.hashCode(cosmoBinaryReference), crc32cHash, diffChecksumsResponse, diffDownloadResponse, diffUploadRequest, diffUploadResponse, diffVersionResponse, downloadParameters, filename, hash, hashVerified, Arrays.hashCode(inline), isPotentialRetry, length, Arrays.hashCode(md5Hash), Arrays.hashCode(mediaId), objectId, path, referenceType, Arrays.hashCode(sha1Hash), Arrays.hashCode(sha256Hash), timestamp, token);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Media {\n");
    sb.append("    algorithm: ").append(toIndentedString(algorithm)).append("\n");
    sb.append("    bigstoreObjectRef: ").append(toIndentedString(bigstoreObjectRef)).append("\n");
    sb.append("    blobRef: ").append(toIndentedString(blobRef)).append("\n");
    sb.append("    blobstore2Info: ").append(toIndentedString(blobstore2Info)).append("\n");
    sb.append("    compositeMedia: ").append(toIndentedString(compositeMedia)).append("\n");
    sb.append("    contentType: ").append(toIndentedString(contentType)).append("\n");
    sb.append("    contentTypeInfo: ").append(toIndentedString(contentTypeInfo)).append("\n");
    sb.append("    cosmoBinaryReference: ").append(toIndentedString(cosmoBinaryReference)).append("\n");
    sb.append("    crc32cHash: ").append(toIndentedString(crc32cHash)).append("\n");
    sb.append("    diffChecksumsResponse: ").append(toIndentedString(diffChecksumsResponse)).append("\n");
    sb.append("    diffDownloadResponse: ").append(toIndentedString(diffDownloadResponse)).append("\n");
    sb.append("    diffUploadRequest: ").append(toIndentedString(diffUploadRequest)).append("\n");
    sb.append("    diffUploadResponse: ").append(toIndentedString(diffUploadResponse)).append("\n");
    sb.append("    diffVersionResponse: ").append(toIndentedString(diffVersionResponse)).append("\n");
    sb.append("    downloadParameters: ").append(toIndentedString(downloadParameters)).append("\n");
    sb.append("    filename: ").append(toIndentedString(filename)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    hashVerified: ").append(toIndentedString(hashVerified)).append("\n");
    sb.append("    inline: ").append(toIndentedString(inline)).append("\n");
    sb.append("    isPotentialRetry: ").append(toIndentedString(isPotentialRetry)).append("\n");
    sb.append("    length: ").append(toIndentedString(length)).append("\n");
    sb.append("    md5Hash: ").append(toIndentedString(md5Hash)).append("\n");
    sb.append("    mediaId: ").append(toIndentedString(mediaId)).append("\n");
    sb.append("    objectId: ").append(toIndentedString(objectId)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    referenceType: ").append(toIndentedString(referenceType)).append("\n");
    sb.append("    sha1Hash: ").append(toIndentedString(sha1Hash)).append("\n");
    sb.append("    sha256Hash: ").append(toIndentedString(sha256Hash)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("algorithm");
    openapiFields.add("bigstoreObjectRef");
    openapiFields.add("blobRef");
    openapiFields.add("blobstore2Info");
    openapiFields.add("compositeMedia");
    openapiFields.add("contentType");
    openapiFields.add("contentTypeInfo");
    openapiFields.add("cosmoBinaryReference");
    openapiFields.add("crc32cHash");
    openapiFields.add("diffChecksumsResponse");
    openapiFields.add("diffDownloadResponse");
    openapiFields.add("diffUploadRequest");
    openapiFields.add("diffUploadResponse");
    openapiFields.add("diffVersionResponse");
    openapiFields.add("downloadParameters");
    openapiFields.add("filename");
    openapiFields.add("hash");
    openapiFields.add("hashVerified");
    openapiFields.add("inline");
    openapiFields.add("isPotentialRetry");
    openapiFields.add("length");
    openapiFields.add("md5Hash");
    openapiFields.add("mediaId");
    openapiFields.add("objectId");
    openapiFields.add("path");
    openapiFields.add("referenceType");
    openapiFields.add("sha1Hash");
    openapiFields.add("sha256Hash");
    openapiFields.add("timestamp");
    openapiFields.add("token");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Media
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Media.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Media is not found in the empty JSON string", Media.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Media.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Media` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("algorithm") != null && !jsonObj.get("algorithm").isJsonNull()) && !jsonObj.get("algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("algorithm").toString()));
      }
      // validate the optional field `blobstore2Info`
      if (jsonObj.get("blobstore2Info") != null && !jsonObj.get("blobstore2Info").isJsonNull()) {
        Blobstore2Info.validateJsonElement(jsonObj.get("blobstore2Info"));
      }
      if (jsonObj.get("compositeMedia") != null && !jsonObj.get("compositeMedia").isJsonNull()) {
        JsonArray jsonArraycompositeMedia = jsonObj.getAsJsonArray("compositeMedia");
        if (jsonArraycompositeMedia != null) {
          // ensure the json data is an array
          if (!jsonObj.get("compositeMedia").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `compositeMedia` to be an array in the JSON string but got `%s`", jsonObj.get("compositeMedia").toString()));
          }

          // validate the optional field `compositeMedia` (array)
          for (int i = 0; i < jsonArraycompositeMedia.size(); i++) {
            CompositeMedia.validateJsonElement(jsonArraycompositeMedia.get(i));
          };
        }
      }
      if ((jsonObj.get("contentType") != null && !jsonObj.get("contentType").isJsonNull()) && !jsonObj.get("contentType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentType").toString()));
      }
      // validate the optional field `contentTypeInfo`
      if (jsonObj.get("contentTypeInfo") != null && !jsonObj.get("contentTypeInfo").isJsonNull()) {
        ContentTypeInfo.validateJsonElement(jsonObj.get("contentTypeInfo"));
      }
      // validate the optional field `diffChecksumsResponse`
      if (jsonObj.get("diffChecksumsResponse") != null && !jsonObj.get("diffChecksumsResponse").isJsonNull()) {
        DiffChecksumsResponse.validateJsonElement(jsonObj.get("diffChecksumsResponse"));
      }
      // validate the optional field `diffDownloadResponse`
      if (jsonObj.get("diffDownloadResponse") != null && !jsonObj.get("diffDownloadResponse").isJsonNull()) {
        DiffDownloadResponse.validateJsonElement(jsonObj.get("diffDownloadResponse"));
      }
      // validate the optional field `diffUploadRequest`
      if (jsonObj.get("diffUploadRequest") != null && !jsonObj.get("diffUploadRequest").isJsonNull()) {
        DiffUploadRequest.validateJsonElement(jsonObj.get("diffUploadRequest"));
      }
      // validate the optional field `diffUploadResponse`
      if (jsonObj.get("diffUploadResponse") != null && !jsonObj.get("diffUploadResponse").isJsonNull()) {
        DiffUploadResponse.validateJsonElement(jsonObj.get("diffUploadResponse"));
      }
      // validate the optional field `diffVersionResponse`
      if (jsonObj.get("diffVersionResponse") != null && !jsonObj.get("diffVersionResponse").isJsonNull()) {
        DiffVersionResponse.validateJsonElement(jsonObj.get("diffVersionResponse"));
      }
      // validate the optional field `downloadParameters`
      if (jsonObj.get("downloadParameters") != null && !jsonObj.get("downloadParameters").isJsonNull()) {
        DownloadParameters.validateJsonElement(jsonObj.get("downloadParameters"));
      }
      if ((jsonObj.get("filename") != null && !jsonObj.get("filename").isJsonNull()) && !jsonObj.get("filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filename").toString()));
      }
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      if ((jsonObj.get("length") != null && !jsonObj.get("length").isJsonNull()) && !jsonObj.get("length").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `length` to be a primitive type in the JSON string but got `%s`", jsonObj.get("length").toString()));
      }
      // validate the optional field `objectId`
      if (jsonObj.get("objectId") != null && !jsonObj.get("objectId").isJsonNull()) {
        ObjectId.validateJsonElement(jsonObj.get("objectId"));
      }
      if ((jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) && !jsonObj.get("path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("path").toString()));
      }
      if ((jsonObj.get("referenceType") != null && !jsonObj.get("referenceType").isJsonNull()) && !jsonObj.get("referenceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `referenceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("referenceType").toString()));
      }
      // validate the optional field `referenceType`
      if (jsonObj.get("referenceType") != null && !jsonObj.get("referenceType").isJsonNull()) {
        ReferenceTypeEnum.validateJsonElement(jsonObj.get("referenceType"));
      }
      if ((jsonObj.get("timestamp") != null && !jsonObj.get("timestamp").isJsonNull()) && !jsonObj.get("timestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestamp").toString()));
      }
      if ((jsonObj.get("token") != null && !jsonObj.get("token").isJsonNull()) && !jsonObj.get("token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Media.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Media' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Media> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Media.class));

       return (TypeAdapter<T>) new TypeAdapter<Media>() {
           @Override
           public void write(JsonWriter out, Media value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Media read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Media given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Media
   * @throws IOException if the JSON string is invalid with respect to Media
   */
  public static Media fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Media.class);
  }

  /**
   * Convert an instance of Media to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

