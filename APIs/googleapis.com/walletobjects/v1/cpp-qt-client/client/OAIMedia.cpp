/**
 * Google Wallet API
 * API for issuers to save and manage Google Wallet Objects.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMedia.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMedia::OAIMedia(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMedia::OAIMedia() {
    this->initializeModel();
}

OAIMedia::~OAIMedia() {}

void OAIMedia::initializeModel() {

    m_algorithm_isSet = false;
    m_algorithm_isValid = false;

    m_bigstore_object_ref_isSet = false;
    m_bigstore_object_ref_isValid = false;

    m_blob_ref_isSet = false;
    m_blob_ref_isValid = false;

    m_blobstore2_info_isSet = false;
    m_blobstore2_info_isValid = false;

    m_composite_media_isSet = false;
    m_composite_media_isValid = false;

    m_content_type_isSet = false;
    m_content_type_isValid = false;

    m_content_type_info_isSet = false;
    m_content_type_info_isValid = false;

    m_cosmo_binary_reference_isSet = false;
    m_cosmo_binary_reference_isValid = false;

    m_crc32c_hash_isSet = false;
    m_crc32c_hash_isValid = false;

    m_diff_checksums_response_isSet = false;
    m_diff_checksums_response_isValid = false;

    m_diff_download_response_isSet = false;
    m_diff_download_response_isValid = false;

    m_diff_upload_request_isSet = false;
    m_diff_upload_request_isValid = false;

    m_diff_upload_response_isSet = false;
    m_diff_upload_response_isValid = false;

    m_diff_version_response_isSet = false;
    m_diff_version_response_isValid = false;

    m_download_parameters_isSet = false;
    m_download_parameters_isValid = false;

    m_filename_isSet = false;
    m_filename_isValid = false;

    m_hash_isSet = false;
    m_hash_isValid = false;

    m_hash_verified_isSet = false;
    m_hash_verified_isValid = false;

    m_r_inline_isSet = false;
    m_r_inline_isValid = false;

    m_is_potential_retry_isSet = false;
    m_is_potential_retry_isValid = false;

    m_length_isSet = false;
    m_length_isValid = false;

    m_md5_hash_isSet = false;
    m_md5_hash_isValid = false;

    m_media_id_isSet = false;
    m_media_id_isValid = false;

    m_object_id_isSet = false;
    m_object_id_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_reference_type_isSet = false;
    m_reference_type_isValid = false;

    m_sha1_hash_isSet = false;
    m_sha1_hash_isValid = false;

    m_sha256_hash_isSet = false;
    m_sha256_hash_isValid = false;

    m_timestamp_isSet = false;
    m_timestamp_isValid = false;

    m_token_isSet = false;
    m_token_isValid = false;
}

void OAIMedia::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMedia::fromJsonObject(QJsonObject json) {

    m_algorithm_isValid = ::OpenAPI::fromJsonValue(m_algorithm, json[QString("algorithm")]);
    m_algorithm_isSet = !json[QString("algorithm")].isNull() && m_algorithm_isValid;

    m_bigstore_object_ref_isValid = ::OpenAPI::fromJsonValue(m_bigstore_object_ref, json[QString("bigstoreObjectRef")]);
    m_bigstore_object_ref_isSet = !json[QString("bigstoreObjectRef")].isNull() && m_bigstore_object_ref_isValid;

    m_blob_ref_isValid = ::OpenAPI::fromJsonValue(m_blob_ref, json[QString("blobRef")]);
    m_blob_ref_isSet = !json[QString("blobRef")].isNull() && m_blob_ref_isValid;

    m_blobstore2_info_isValid = ::OpenAPI::fromJsonValue(m_blobstore2_info, json[QString("blobstore2Info")]);
    m_blobstore2_info_isSet = !json[QString("blobstore2Info")].isNull() && m_blobstore2_info_isValid;

    m_composite_media_isValid = ::OpenAPI::fromJsonValue(m_composite_media, json[QString("compositeMedia")]);
    m_composite_media_isSet = !json[QString("compositeMedia")].isNull() && m_composite_media_isValid;

    m_content_type_isValid = ::OpenAPI::fromJsonValue(m_content_type, json[QString("contentType")]);
    m_content_type_isSet = !json[QString("contentType")].isNull() && m_content_type_isValid;

    m_content_type_info_isValid = ::OpenAPI::fromJsonValue(m_content_type_info, json[QString("contentTypeInfo")]);
    m_content_type_info_isSet = !json[QString("contentTypeInfo")].isNull() && m_content_type_info_isValid;

    m_cosmo_binary_reference_isValid = ::OpenAPI::fromJsonValue(m_cosmo_binary_reference, json[QString("cosmoBinaryReference")]);
    m_cosmo_binary_reference_isSet = !json[QString("cosmoBinaryReference")].isNull() && m_cosmo_binary_reference_isValid;

    m_crc32c_hash_isValid = ::OpenAPI::fromJsonValue(m_crc32c_hash, json[QString("crc32cHash")]);
    m_crc32c_hash_isSet = !json[QString("crc32cHash")].isNull() && m_crc32c_hash_isValid;

    m_diff_checksums_response_isValid = ::OpenAPI::fromJsonValue(m_diff_checksums_response, json[QString("diffChecksumsResponse")]);
    m_diff_checksums_response_isSet = !json[QString("diffChecksumsResponse")].isNull() && m_diff_checksums_response_isValid;

    m_diff_download_response_isValid = ::OpenAPI::fromJsonValue(m_diff_download_response, json[QString("diffDownloadResponse")]);
    m_diff_download_response_isSet = !json[QString("diffDownloadResponse")].isNull() && m_diff_download_response_isValid;

    m_diff_upload_request_isValid = ::OpenAPI::fromJsonValue(m_diff_upload_request, json[QString("diffUploadRequest")]);
    m_diff_upload_request_isSet = !json[QString("diffUploadRequest")].isNull() && m_diff_upload_request_isValid;

    m_diff_upload_response_isValid = ::OpenAPI::fromJsonValue(m_diff_upload_response, json[QString("diffUploadResponse")]);
    m_diff_upload_response_isSet = !json[QString("diffUploadResponse")].isNull() && m_diff_upload_response_isValid;

    m_diff_version_response_isValid = ::OpenAPI::fromJsonValue(m_diff_version_response, json[QString("diffVersionResponse")]);
    m_diff_version_response_isSet = !json[QString("diffVersionResponse")].isNull() && m_diff_version_response_isValid;

    m_download_parameters_isValid = ::OpenAPI::fromJsonValue(m_download_parameters, json[QString("downloadParameters")]);
    m_download_parameters_isSet = !json[QString("downloadParameters")].isNull() && m_download_parameters_isValid;

    m_filename_isValid = ::OpenAPI::fromJsonValue(m_filename, json[QString("filename")]);
    m_filename_isSet = !json[QString("filename")].isNull() && m_filename_isValid;

    m_hash_isValid = ::OpenAPI::fromJsonValue(m_hash, json[QString("hash")]);
    m_hash_isSet = !json[QString("hash")].isNull() && m_hash_isValid;

    m_hash_verified_isValid = ::OpenAPI::fromJsonValue(m_hash_verified, json[QString("hashVerified")]);
    m_hash_verified_isSet = !json[QString("hashVerified")].isNull() && m_hash_verified_isValid;

    m_r_inline_isValid = ::OpenAPI::fromJsonValue(m_r_inline, json[QString("inline")]);
    m_r_inline_isSet = !json[QString("inline")].isNull() && m_r_inline_isValid;

    m_is_potential_retry_isValid = ::OpenAPI::fromJsonValue(m_is_potential_retry, json[QString("isPotentialRetry")]);
    m_is_potential_retry_isSet = !json[QString("isPotentialRetry")].isNull() && m_is_potential_retry_isValid;

    m_length_isValid = ::OpenAPI::fromJsonValue(m_length, json[QString("length")]);
    m_length_isSet = !json[QString("length")].isNull() && m_length_isValid;

    m_md5_hash_isValid = ::OpenAPI::fromJsonValue(m_md5_hash, json[QString("md5Hash")]);
    m_md5_hash_isSet = !json[QString("md5Hash")].isNull() && m_md5_hash_isValid;

    m_media_id_isValid = ::OpenAPI::fromJsonValue(m_media_id, json[QString("mediaId")]);
    m_media_id_isSet = !json[QString("mediaId")].isNull() && m_media_id_isValid;

    m_object_id_isValid = ::OpenAPI::fromJsonValue(m_object_id, json[QString("objectId")]);
    m_object_id_isSet = !json[QString("objectId")].isNull() && m_object_id_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_reference_type_isValid = ::OpenAPI::fromJsonValue(m_reference_type, json[QString("referenceType")]);
    m_reference_type_isSet = !json[QString("referenceType")].isNull() && m_reference_type_isValid;

    m_sha1_hash_isValid = ::OpenAPI::fromJsonValue(m_sha1_hash, json[QString("sha1Hash")]);
    m_sha1_hash_isSet = !json[QString("sha1Hash")].isNull() && m_sha1_hash_isValid;

    m_sha256_hash_isValid = ::OpenAPI::fromJsonValue(m_sha256_hash, json[QString("sha256Hash")]);
    m_sha256_hash_isSet = !json[QString("sha256Hash")].isNull() && m_sha256_hash_isValid;

    m_timestamp_isValid = ::OpenAPI::fromJsonValue(m_timestamp, json[QString("timestamp")]);
    m_timestamp_isSet = !json[QString("timestamp")].isNull() && m_timestamp_isValid;

    m_token_isValid = ::OpenAPI::fromJsonValue(m_token, json[QString("token")]);
    m_token_isSet = !json[QString("token")].isNull() && m_token_isValid;
}

QString OAIMedia::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMedia::asJsonObject() const {
    QJsonObject obj;
    if (m_algorithm_isSet) {
        obj.insert(QString("algorithm"), ::OpenAPI::toJsonValue(m_algorithm));
    }
    if (m_bigstore_object_ref_isSet) {
        obj.insert(QString("bigstoreObjectRef"), ::OpenAPI::toJsonValue(m_bigstore_object_ref));
    }
    if (m_blob_ref_isSet) {
        obj.insert(QString("blobRef"), ::OpenAPI::toJsonValue(m_blob_ref));
    }
    if (m_blobstore2_info.isSet()) {
        obj.insert(QString("blobstore2Info"), ::OpenAPI::toJsonValue(m_blobstore2_info));
    }
    if (m_composite_media.size() > 0) {
        obj.insert(QString("compositeMedia"), ::OpenAPI::toJsonValue(m_composite_media));
    }
    if (m_content_type_isSet) {
        obj.insert(QString("contentType"), ::OpenAPI::toJsonValue(m_content_type));
    }
    if (m_content_type_info.isSet()) {
        obj.insert(QString("contentTypeInfo"), ::OpenAPI::toJsonValue(m_content_type_info));
    }
    if (m_cosmo_binary_reference_isSet) {
        obj.insert(QString("cosmoBinaryReference"), ::OpenAPI::toJsonValue(m_cosmo_binary_reference));
    }
    if (m_crc32c_hash_isSet) {
        obj.insert(QString("crc32cHash"), ::OpenAPI::toJsonValue(m_crc32c_hash));
    }
    if (m_diff_checksums_response.isSet()) {
        obj.insert(QString("diffChecksumsResponse"), ::OpenAPI::toJsonValue(m_diff_checksums_response));
    }
    if (m_diff_download_response.isSet()) {
        obj.insert(QString("diffDownloadResponse"), ::OpenAPI::toJsonValue(m_diff_download_response));
    }
    if (m_diff_upload_request.isSet()) {
        obj.insert(QString("diffUploadRequest"), ::OpenAPI::toJsonValue(m_diff_upload_request));
    }
    if (m_diff_upload_response.isSet()) {
        obj.insert(QString("diffUploadResponse"), ::OpenAPI::toJsonValue(m_diff_upload_response));
    }
    if (m_diff_version_response.isSet()) {
        obj.insert(QString("diffVersionResponse"), ::OpenAPI::toJsonValue(m_diff_version_response));
    }
    if (m_download_parameters.isSet()) {
        obj.insert(QString("downloadParameters"), ::OpenAPI::toJsonValue(m_download_parameters));
    }
    if (m_filename_isSet) {
        obj.insert(QString("filename"), ::OpenAPI::toJsonValue(m_filename));
    }
    if (m_hash_isSet) {
        obj.insert(QString("hash"), ::OpenAPI::toJsonValue(m_hash));
    }
    if (m_hash_verified_isSet) {
        obj.insert(QString("hashVerified"), ::OpenAPI::toJsonValue(m_hash_verified));
    }
    if (m_r_inline_isSet) {
        obj.insert(QString("inline"), ::OpenAPI::toJsonValue(m_r_inline));
    }
    if (m_is_potential_retry_isSet) {
        obj.insert(QString("isPotentialRetry"), ::OpenAPI::toJsonValue(m_is_potential_retry));
    }
    if (m_length_isSet) {
        obj.insert(QString("length"), ::OpenAPI::toJsonValue(m_length));
    }
    if (m_md5_hash_isSet) {
        obj.insert(QString("md5Hash"), ::OpenAPI::toJsonValue(m_md5_hash));
    }
    if (m_media_id_isSet) {
        obj.insert(QString("mediaId"), ::OpenAPI::toJsonValue(m_media_id));
    }
    if (m_object_id.isSet()) {
        obj.insert(QString("objectId"), ::OpenAPI::toJsonValue(m_object_id));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_reference_type_isSet) {
        obj.insert(QString("referenceType"), ::OpenAPI::toJsonValue(m_reference_type));
    }
    if (m_sha1_hash_isSet) {
        obj.insert(QString("sha1Hash"), ::OpenAPI::toJsonValue(m_sha1_hash));
    }
    if (m_sha256_hash_isSet) {
        obj.insert(QString("sha256Hash"), ::OpenAPI::toJsonValue(m_sha256_hash));
    }
    if (m_timestamp_isSet) {
        obj.insert(QString("timestamp"), ::OpenAPI::toJsonValue(m_timestamp));
    }
    if (m_token_isSet) {
        obj.insert(QString("token"), ::OpenAPI::toJsonValue(m_token));
    }
    return obj;
}

QString OAIMedia::getAlgorithm() const {
    return m_algorithm;
}
void OAIMedia::setAlgorithm(const QString &algorithm) {
    m_algorithm = algorithm;
    m_algorithm_isSet = true;
}

bool OAIMedia::is_algorithm_Set() const{
    return m_algorithm_isSet;
}

bool OAIMedia::is_algorithm_Valid() const{
    return m_algorithm_isValid;
}

QByteArray OAIMedia::getBigstoreObjectRef() const {
    return m_bigstore_object_ref;
}
void OAIMedia::setBigstoreObjectRef(const QByteArray &bigstore_object_ref) {
    m_bigstore_object_ref = bigstore_object_ref;
    m_bigstore_object_ref_isSet = true;
}

bool OAIMedia::is_bigstore_object_ref_Set() const{
    return m_bigstore_object_ref_isSet;
}

bool OAIMedia::is_bigstore_object_ref_Valid() const{
    return m_bigstore_object_ref_isValid;
}

QByteArray OAIMedia::getBlobRef() const {
    return m_blob_ref;
}
void OAIMedia::setBlobRef(const QByteArray &blob_ref) {
    m_blob_ref = blob_ref;
    m_blob_ref_isSet = true;
}

bool OAIMedia::is_blob_ref_Set() const{
    return m_blob_ref_isSet;
}

bool OAIMedia::is_blob_ref_Valid() const{
    return m_blob_ref_isValid;
}

OAIBlobstore2Info OAIMedia::getBlobstore2Info() const {
    return m_blobstore2_info;
}
void OAIMedia::setBlobstore2Info(const OAIBlobstore2Info &blobstore2_info) {
    m_blobstore2_info = blobstore2_info;
    m_blobstore2_info_isSet = true;
}

bool OAIMedia::is_blobstore2_info_Set() const{
    return m_blobstore2_info_isSet;
}

bool OAIMedia::is_blobstore2_info_Valid() const{
    return m_blobstore2_info_isValid;
}

QList<OAICompositeMedia> OAIMedia::getCompositeMedia() const {
    return m_composite_media;
}
void OAIMedia::setCompositeMedia(const QList<OAICompositeMedia> &composite_media) {
    m_composite_media = composite_media;
    m_composite_media_isSet = true;
}

bool OAIMedia::is_composite_media_Set() const{
    return m_composite_media_isSet;
}

bool OAIMedia::is_composite_media_Valid() const{
    return m_composite_media_isValid;
}

QString OAIMedia::getContentType() const {
    return m_content_type;
}
void OAIMedia::setContentType(const QString &content_type) {
    m_content_type = content_type;
    m_content_type_isSet = true;
}

bool OAIMedia::is_content_type_Set() const{
    return m_content_type_isSet;
}

bool OAIMedia::is_content_type_Valid() const{
    return m_content_type_isValid;
}

OAIContentTypeInfo OAIMedia::getContentTypeInfo() const {
    return m_content_type_info;
}
void OAIMedia::setContentTypeInfo(const OAIContentTypeInfo &content_type_info) {
    m_content_type_info = content_type_info;
    m_content_type_info_isSet = true;
}

bool OAIMedia::is_content_type_info_Set() const{
    return m_content_type_info_isSet;
}

bool OAIMedia::is_content_type_info_Valid() const{
    return m_content_type_info_isValid;
}

QByteArray OAIMedia::getCosmoBinaryReference() const {
    return m_cosmo_binary_reference;
}
void OAIMedia::setCosmoBinaryReference(const QByteArray &cosmo_binary_reference) {
    m_cosmo_binary_reference = cosmo_binary_reference;
    m_cosmo_binary_reference_isSet = true;
}

bool OAIMedia::is_cosmo_binary_reference_Set() const{
    return m_cosmo_binary_reference_isSet;
}

bool OAIMedia::is_cosmo_binary_reference_Valid() const{
    return m_cosmo_binary_reference_isValid;
}

qint32 OAIMedia::getCrc32cHash() const {
    return m_crc32c_hash;
}
void OAIMedia::setCrc32cHash(const qint32 &crc32c_hash) {
    m_crc32c_hash = crc32c_hash;
    m_crc32c_hash_isSet = true;
}

bool OAIMedia::is_crc32c_hash_Set() const{
    return m_crc32c_hash_isSet;
}

bool OAIMedia::is_crc32c_hash_Valid() const{
    return m_crc32c_hash_isValid;
}

OAIDiffChecksumsResponse OAIMedia::getDiffChecksumsResponse() const {
    return m_diff_checksums_response;
}
void OAIMedia::setDiffChecksumsResponse(const OAIDiffChecksumsResponse &diff_checksums_response) {
    m_diff_checksums_response = diff_checksums_response;
    m_diff_checksums_response_isSet = true;
}

bool OAIMedia::is_diff_checksums_response_Set() const{
    return m_diff_checksums_response_isSet;
}

bool OAIMedia::is_diff_checksums_response_Valid() const{
    return m_diff_checksums_response_isValid;
}

OAIDiffDownloadResponse OAIMedia::getDiffDownloadResponse() const {
    return m_diff_download_response;
}
void OAIMedia::setDiffDownloadResponse(const OAIDiffDownloadResponse &diff_download_response) {
    m_diff_download_response = diff_download_response;
    m_diff_download_response_isSet = true;
}

bool OAIMedia::is_diff_download_response_Set() const{
    return m_diff_download_response_isSet;
}

bool OAIMedia::is_diff_download_response_Valid() const{
    return m_diff_download_response_isValid;
}

OAIDiffUploadRequest OAIMedia::getDiffUploadRequest() const {
    return m_diff_upload_request;
}
void OAIMedia::setDiffUploadRequest(const OAIDiffUploadRequest &diff_upload_request) {
    m_diff_upload_request = diff_upload_request;
    m_diff_upload_request_isSet = true;
}

bool OAIMedia::is_diff_upload_request_Set() const{
    return m_diff_upload_request_isSet;
}

bool OAIMedia::is_diff_upload_request_Valid() const{
    return m_diff_upload_request_isValid;
}

OAIDiffUploadResponse OAIMedia::getDiffUploadResponse() const {
    return m_diff_upload_response;
}
void OAIMedia::setDiffUploadResponse(const OAIDiffUploadResponse &diff_upload_response) {
    m_diff_upload_response = diff_upload_response;
    m_diff_upload_response_isSet = true;
}

bool OAIMedia::is_diff_upload_response_Set() const{
    return m_diff_upload_response_isSet;
}

bool OAIMedia::is_diff_upload_response_Valid() const{
    return m_diff_upload_response_isValid;
}

OAIDiffVersionResponse OAIMedia::getDiffVersionResponse() const {
    return m_diff_version_response;
}
void OAIMedia::setDiffVersionResponse(const OAIDiffVersionResponse &diff_version_response) {
    m_diff_version_response = diff_version_response;
    m_diff_version_response_isSet = true;
}

bool OAIMedia::is_diff_version_response_Set() const{
    return m_diff_version_response_isSet;
}

bool OAIMedia::is_diff_version_response_Valid() const{
    return m_diff_version_response_isValid;
}

OAIDownloadParameters OAIMedia::getDownloadParameters() const {
    return m_download_parameters;
}
void OAIMedia::setDownloadParameters(const OAIDownloadParameters &download_parameters) {
    m_download_parameters = download_parameters;
    m_download_parameters_isSet = true;
}

bool OAIMedia::is_download_parameters_Set() const{
    return m_download_parameters_isSet;
}

bool OAIMedia::is_download_parameters_Valid() const{
    return m_download_parameters_isValid;
}

QString OAIMedia::getFilename() const {
    return m_filename;
}
void OAIMedia::setFilename(const QString &filename) {
    m_filename = filename;
    m_filename_isSet = true;
}

bool OAIMedia::is_filename_Set() const{
    return m_filename_isSet;
}

bool OAIMedia::is_filename_Valid() const{
    return m_filename_isValid;
}

QString OAIMedia::getHash() const {
    return m_hash;
}
void OAIMedia::setHash(const QString &hash) {
    m_hash = hash;
    m_hash_isSet = true;
}

bool OAIMedia::is_hash_Set() const{
    return m_hash_isSet;
}

bool OAIMedia::is_hash_Valid() const{
    return m_hash_isValid;
}

bool OAIMedia::isHashVerified() const {
    return m_hash_verified;
}
void OAIMedia::setHashVerified(const bool &hash_verified) {
    m_hash_verified = hash_verified;
    m_hash_verified_isSet = true;
}

bool OAIMedia::is_hash_verified_Set() const{
    return m_hash_verified_isSet;
}

bool OAIMedia::is_hash_verified_Valid() const{
    return m_hash_verified_isValid;
}

QByteArray OAIMedia::getRInline() const {
    return m_r_inline;
}
void OAIMedia::setRInline(const QByteArray &r_inline) {
    m_r_inline = r_inline;
    m_r_inline_isSet = true;
}

bool OAIMedia::is_r_inline_Set() const{
    return m_r_inline_isSet;
}

bool OAIMedia::is_r_inline_Valid() const{
    return m_r_inline_isValid;
}

bool OAIMedia::isIsPotentialRetry() const {
    return m_is_potential_retry;
}
void OAIMedia::setIsPotentialRetry(const bool &is_potential_retry) {
    m_is_potential_retry = is_potential_retry;
    m_is_potential_retry_isSet = true;
}

bool OAIMedia::is_is_potential_retry_Set() const{
    return m_is_potential_retry_isSet;
}

bool OAIMedia::is_is_potential_retry_Valid() const{
    return m_is_potential_retry_isValid;
}

QString OAIMedia::getLength() const {
    return m_length;
}
void OAIMedia::setLength(const QString &length) {
    m_length = length;
    m_length_isSet = true;
}

bool OAIMedia::is_length_Set() const{
    return m_length_isSet;
}

bool OAIMedia::is_length_Valid() const{
    return m_length_isValid;
}

QByteArray OAIMedia::getMd5Hash() const {
    return m_md5_hash;
}
void OAIMedia::setMd5Hash(const QByteArray &md5_hash) {
    m_md5_hash = md5_hash;
    m_md5_hash_isSet = true;
}

bool OAIMedia::is_md5_hash_Set() const{
    return m_md5_hash_isSet;
}

bool OAIMedia::is_md5_hash_Valid() const{
    return m_md5_hash_isValid;
}

QByteArray OAIMedia::getMediaId() const {
    return m_media_id;
}
void OAIMedia::setMediaId(const QByteArray &media_id) {
    m_media_id = media_id;
    m_media_id_isSet = true;
}

bool OAIMedia::is_media_id_Set() const{
    return m_media_id_isSet;
}

bool OAIMedia::is_media_id_Valid() const{
    return m_media_id_isValid;
}

OAIObjectId OAIMedia::getObjectId() const {
    return m_object_id;
}
void OAIMedia::setObjectId(const OAIObjectId &object_id) {
    m_object_id = object_id;
    m_object_id_isSet = true;
}

bool OAIMedia::is_object_id_Set() const{
    return m_object_id_isSet;
}

bool OAIMedia::is_object_id_Valid() const{
    return m_object_id_isValid;
}

QString OAIMedia::getPath() const {
    return m_path;
}
void OAIMedia::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIMedia::is_path_Set() const{
    return m_path_isSet;
}

bool OAIMedia::is_path_Valid() const{
    return m_path_isValid;
}

QString OAIMedia::getReferenceType() const {
    return m_reference_type;
}
void OAIMedia::setReferenceType(const QString &reference_type) {
    m_reference_type = reference_type;
    m_reference_type_isSet = true;
}

bool OAIMedia::is_reference_type_Set() const{
    return m_reference_type_isSet;
}

bool OAIMedia::is_reference_type_Valid() const{
    return m_reference_type_isValid;
}

QByteArray OAIMedia::getSha1Hash() const {
    return m_sha1_hash;
}
void OAIMedia::setSha1Hash(const QByteArray &sha1_hash) {
    m_sha1_hash = sha1_hash;
    m_sha1_hash_isSet = true;
}

bool OAIMedia::is_sha1_hash_Set() const{
    return m_sha1_hash_isSet;
}

bool OAIMedia::is_sha1_hash_Valid() const{
    return m_sha1_hash_isValid;
}

QByteArray OAIMedia::getSha256Hash() const {
    return m_sha256_hash;
}
void OAIMedia::setSha256Hash(const QByteArray &sha256_hash) {
    m_sha256_hash = sha256_hash;
    m_sha256_hash_isSet = true;
}

bool OAIMedia::is_sha256_hash_Set() const{
    return m_sha256_hash_isSet;
}

bool OAIMedia::is_sha256_hash_Valid() const{
    return m_sha256_hash_isValid;
}

QString OAIMedia::getTimestamp() const {
    return m_timestamp;
}
void OAIMedia::setTimestamp(const QString &timestamp) {
    m_timestamp = timestamp;
    m_timestamp_isSet = true;
}

bool OAIMedia::is_timestamp_Set() const{
    return m_timestamp_isSet;
}

bool OAIMedia::is_timestamp_Valid() const{
    return m_timestamp_isValid;
}

QString OAIMedia::getToken() const {
    return m_token;
}
void OAIMedia::setToken(const QString &token) {
    m_token = token;
    m_token_isSet = true;
}

bool OAIMedia::is_token_Set() const{
    return m_token_isSet;
}

bool OAIMedia::is_token_Valid() const{
    return m_token_isValid;
}

bool OAIMedia::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_algorithm_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bigstore_object_ref_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_blob_ref_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_blobstore2_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_composite_media.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_type_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cosmo_binary_reference_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_crc32c_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_diff_checksums_response.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_diff_download_response.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_diff_upload_request.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_diff_upload_response.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_diff_version_response.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_download_parameters.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_filename_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hash_verified_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_inline_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_potential_retry_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_md5_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_object_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reference_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sha1_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sha256_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_token_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMedia::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
