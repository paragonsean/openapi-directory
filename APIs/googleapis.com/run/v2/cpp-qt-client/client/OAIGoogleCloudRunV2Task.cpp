/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGoogleCloudRunV2Task.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGoogleCloudRunV2Task::OAIGoogleCloudRunV2Task(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGoogleCloudRunV2Task::OAIGoogleCloudRunV2Task() {
    this->initializeModel();
}

OAIGoogleCloudRunV2Task::~OAIGoogleCloudRunV2Task() {}

void OAIGoogleCloudRunV2Task::initializeModel() {

    m_annotations_isSet = false;
    m_annotations_isValid = false;

    m_completion_time_isSet = false;
    m_completion_time_isValid = false;

    m_conditions_isSet = false;
    m_conditions_isValid = false;

    m_containers_isSet = false;
    m_containers_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_delete_time_isSet = false;
    m_delete_time_isValid = false;

    m_encryption_key_isSet = false;
    m_encryption_key_isValid = false;

    m_etag_isSet = false;
    m_etag_isValid = false;

    m_execution_isSet = false;
    m_execution_isValid = false;

    m_execution_environment_isSet = false;
    m_execution_environment_isValid = false;

    m_expire_time_isSet = false;
    m_expire_time_isValid = false;

    m_generation_isSet = false;
    m_generation_isValid = false;

    m_index_isSet = false;
    m_index_isValid = false;

    m_job_isSet = false;
    m_job_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_last_attempt_result_isSet = false;
    m_last_attempt_result_isValid = false;

    m_log_uri_isSet = false;
    m_log_uri_isValid = false;

    m_max_retries_isSet = false;
    m_max_retries_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_observed_generation_isSet = false;
    m_observed_generation_isValid = false;

    m_reconciling_isSet = false;
    m_reconciling_isValid = false;

    m_retried_isSet = false;
    m_retried_isValid = false;

    m_satisfies_pzs_isSet = false;
    m_satisfies_pzs_isValid = false;

    m_scheduled_time_isSet = false;
    m_scheduled_time_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_start_time_isSet = false;
    m_start_time_isValid = false;

    m_timeout_isSet = false;
    m_timeout_isValid = false;

    m_uid_isSet = false;
    m_uid_isValid = false;

    m_update_time_isSet = false;
    m_update_time_isValid = false;

    m_volumes_isSet = false;
    m_volumes_isValid = false;

    m_vpc_access_isSet = false;
    m_vpc_access_isValid = false;
}

void OAIGoogleCloudRunV2Task::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGoogleCloudRunV2Task::fromJsonObject(QJsonObject json) {

    m_annotations_isValid = ::OpenAPI::fromJsonValue(m_annotations, json[QString("annotations")]);
    m_annotations_isSet = !json[QString("annotations")].isNull() && m_annotations_isValid;

    m_completion_time_isValid = ::OpenAPI::fromJsonValue(m_completion_time, json[QString("completionTime")]);
    m_completion_time_isSet = !json[QString("completionTime")].isNull() && m_completion_time_isValid;

    m_conditions_isValid = ::OpenAPI::fromJsonValue(m_conditions, json[QString("conditions")]);
    m_conditions_isSet = !json[QString("conditions")].isNull() && m_conditions_isValid;

    m_containers_isValid = ::OpenAPI::fromJsonValue(m_containers, json[QString("containers")]);
    m_containers_isSet = !json[QString("containers")].isNull() && m_containers_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_delete_time_isValid = ::OpenAPI::fromJsonValue(m_delete_time, json[QString("deleteTime")]);
    m_delete_time_isSet = !json[QString("deleteTime")].isNull() && m_delete_time_isValid;

    m_encryption_key_isValid = ::OpenAPI::fromJsonValue(m_encryption_key, json[QString("encryptionKey")]);
    m_encryption_key_isSet = !json[QString("encryptionKey")].isNull() && m_encryption_key_isValid;

    m_etag_isValid = ::OpenAPI::fromJsonValue(m_etag, json[QString("etag")]);
    m_etag_isSet = !json[QString("etag")].isNull() && m_etag_isValid;

    m_execution_isValid = ::OpenAPI::fromJsonValue(m_execution, json[QString("execution")]);
    m_execution_isSet = !json[QString("execution")].isNull() && m_execution_isValid;

    m_execution_environment_isValid = ::OpenAPI::fromJsonValue(m_execution_environment, json[QString("executionEnvironment")]);
    m_execution_environment_isSet = !json[QString("executionEnvironment")].isNull() && m_execution_environment_isValid;

    m_expire_time_isValid = ::OpenAPI::fromJsonValue(m_expire_time, json[QString("expireTime")]);
    m_expire_time_isSet = !json[QString("expireTime")].isNull() && m_expire_time_isValid;

    m_generation_isValid = ::OpenAPI::fromJsonValue(m_generation, json[QString("generation")]);
    m_generation_isSet = !json[QString("generation")].isNull() && m_generation_isValid;

    m_index_isValid = ::OpenAPI::fromJsonValue(m_index, json[QString("index")]);
    m_index_isSet = !json[QString("index")].isNull() && m_index_isValid;

    m_job_isValid = ::OpenAPI::fromJsonValue(m_job, json[QString("job")]);
    m_job_isSet = !json[QString("job")].isNull() && m_job_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_last_attempt_result_isValid = ::OpenAPI::fromJsonValue(m_last_attempt_result, json[QString("lastAttemptResult")]);
    m_last_attempt_result_isSet = !json[QString("lastAttemptResult")].isNull() && m_last_attempt_result_isValid;

    m_log_uri_isValid = ::OpenAPI::fromJsonValue(m_log_uri, json[QString("logUri")]);
    m_log_uri_isSet = !json[QString("logUri")].isNull() && m_log_uri_isValid;

    m_max_retries_isValid = ::OpenAPI::fromJsonValue(m_max_retries, json[QString("maxRetries")]);
    m_max_retries_isSet = !json[QString("maxRetries")].isNull() && m_max_retries_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_observed_generation_isValid = ::OpenAPI::fromJsonValue(m_observed_generation, json[QString("observedGeneration")]);
    m_observed_generation_isSet = !json[QString("observedGeneration")].isNull() && m_observed_generation_isValid;

    m_reconciling_isValid = ::OpenAPI::fromJsonValue(m_reconciling, json[QString("reconciling")]);
    m_reconciling_isSet = !json[QString("reconciling")].isNull() && m_reconciling_isValid;

    m_retried_isValid = ::OpenAPI::fromJsonValue(m_retried, json[QString("retried")]);
    m_retried_isSet = !json[QString("retried")].isNull() && m_retried_isValid;

    m_satisfies_pzs_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzs, json[QString("satisfiesPzs")]);
    m_satisfies_pzs_isSet = !json[QString("satisfiesPzs")].isNull() && m_satisfies_pzs_isValid;

    m_scheduled_time_isValid = ::OpenAPI::fromJsonValue(m_scheduled_time, json[QString("scheduledTime")]);
    m_scheduled_time_isSet = !json[QString("scheduledTime")].isNull() && m_scheduled_time_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_start_time_isValid = ::OpenAPI::fromJsonValue(m_start_time, json[QString("startTime")]);
    m_start_time_isSet = !json[QString("startTime")].isNull() && m_start_time_isValid;

    m_timeout_isValid = ::OpenAPI::fromJsonValue(m_timeout, json[QString("timeout")]);
    m_timeout_isSet = !json[QString("timeout")].isNull() && m_timeout_isValid;

    m_uid_isValid = ::OpenAPI::fromJsonValue(m_uid, json[QString("uid")]);
    m_uid_isSet = !json[QString("uid")].isNull() && m_uid_isValid;

    m_update_time_isValid = ::OpenAPI::fromJsonValue(m_update_time, json[QString("updateTime")]);
    m_update_time_isSet = !json[QString("updateTime")].isNull() && m_update_time_isValid;

    m_volumes_isValid = ::OpenAPI::fromJsonValue(m_volumes, json[QString("volumes")]);
    m_volumes_isSet = !json[QString("volumes")].isNull() && m_volumes_isValid;

    m_vpc_access_isValid = ::OpenAPI::fromJsonValue(m_vpc_access, json[QString("vpcAccess")]);
    m_vpc_access_isSet = !json[QString("vpcAccess")].isNull() && m_vpc_access_isValid;
}

QString OAIGoogleCloudRunV2Task::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGoogleCloudRunV2Task::asJsonObject() const {
    QJsonObject obj;
    if (m_annotations.size() > 0) {
        obj.insert(QString("annotations"), ::OpenAPI::toJsonValue(m_annotations));
    }
    if (m_completion_time_isSet) {
        obj.insert(QString("completionTime"), ::OpenAPI::toJsonValue(m_completion_time));
    }
    if (m_conditions.size() > 0) {
        obj.insert(QString("conditions"), ::OpenAPI::toJsonValue(m_conditions));
    }
    if (m_containers.size() > 0) {
        obj.insert(QString("containers"), ::OpenAPI::toJsonValue(m_containers));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_delete_time_isSet) {
        obj.insert(QString("deleteTime"), ::OpenAPI::toJsonValue(m_delete_time));
    }
    if (m_encryption_key_isSet) {
        obj.insert(QString("encryptionKey"), ::OpenAPI::toJsonValue(m_encryption_key));
    }
    if (m_etag_isSet) {
        obj.insert(QString("etag"), ::OpenAPI::toJsonValue(m_etag));
    }
    if (m_execution_isSet) {
        obj.insert(QString("execution"), ::OpenAPI::toJsonValue(m_execution));
    }
    if (m_execution_environment_isSet) {
        obj.insert(QString("executionEnvironment"), ::OpenAPI::toJsonValue(m_execution_environment));
    }
    if (m_expire_time_isSet) {
        obj.insert(QString("expireTime"), ::OpenAPI::toJsonValue(m_expire_time));
    }
    if (m_generation_isSet) {
        obj.insert(QString("generation"), ::OpenAPI::toJsonValue(m_generation));
    }
    if (m_index_isSet) {
        obj.insert(QString("index"), ::OpenAPI::toJsonValue(m_index));
    }
    if (m_job_isSet) {
        obj.insert(QString("job"), ::OpenAPI::toJsonValue(m_job));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_last_attempt_result.isSet()) {
        obj.insert(QString("lastAttemptResult"), ::OpenAPI::toJsonValue(m_last_attempt_result));
    }
    if (m_log_uri_isSet) {
        obj.insert(QString("logUri"), ::OpenAPI::toJsonValue(m_log_uri));
    }
    if (m_max_retries_isSet) {
        obj.insert(QString("maxRetries"), ::OpenAPI::toJsonValue(m_max_retries));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_observed_generation_isSet) {
        obj.insert(QString("observedGeneration"), ::OpenAPI::toJsonValue(m_observed_generation));
    }
    if (m_reconciling_isSet) {
        obj.insert(QString("reconciling"), ::OpenAPI::toJsonValue(m_reconciling));
    }
    if (m_retried_isSet) {
        obj.insert(QString("retried"), ::OpenAPI::toJsonValue(m_retried));
    }
    if (m_satisfies_pzs_isSet) {
        obj.insert(QString("satisfiesPzs"), ::OpenAPI::toJsonValue(m_satisfies_pzs));
    }
    if (m_scheduled_time_isSet) {
        obj.insert(QString("scheduledTime"), ::OpenAPI::toJsonValue(m_scheduled_time));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_start_time_isSet) {
        obj.insert(QString("startTime"), ::OpenAPI::toJsonValue(m_start_time));
    }
    if (m_timeout_isSet) {
        obj.insert(QString("timeout"), ::OpenAPI::toJsonValue(m_timeout));
    }
    if (m_uid_isSet) {
        obj.insert(QString("uid"), ::OpenAPI::toJsonValue(m_uid));
    }
    if (m_update_time_isSet) {
        obj.insert(QString("updateTime"), ::OpenAPI::toJsonValue(m_update_time));
    }
    if (m_volumes.size() > 0) {
        obj.insert(QString("volumes"), ::OpenAPI::toJsonValue(m_volumes));
    }
    if (m_vpc_access.isSet()) {
        obj.insert(QString("vpcAccess"), ::OpenAPI::toJsonValue(m_vpc_access));
    }
    return obj;
}

QMap<QString, QString> OAIGoogleCloudRunV2Task::getAnnotations() const {
    return m_annotations;
}
void OAIGoogleCloudRunV2Task::setAnnotations(const QMap<QString, QString> &annotations) {
    m_annotations = annotations;
    m_annotations_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_annotations_Set() const{
    return m_annotations_isSet;
}

bool OAIGoogleCloudRunV2Task::is_annotations_Valid() const{
    return m_annotations_isValid;
}

QString OAIGoogleCloudRunV2Task::getCompletionTime() const {
    return m_completion_time;
}
void OAIGoogleCloudRunV2Task::setCompletionTime(const QString &completion_time) {
    m_completion_time = completion_time;
    m_completion_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_completion_time_Set() const{
    return m_completion_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_completion_time_Valid() const{
    return m_completion_time_isValid;
}

QList<OAIGoogleCloudRunV2Condition> OAIGoogleCloudRunV2Task::getConditions() const {
    return m_conditions;
}
void OAIGoogleCloudRunV2Task::setConditions(const QList<OAIGoogleCloudRunV2Condition> &conditions) {
    m_conditions = conditions;
    m_conditions_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_conditions_Set() const{
    return m_conditions_isSet;
}

bool OAIGoogleCloudRunV2Task::is_conditions_Valid() const{
    return m_conditions_isValid;
}

QList<OAIGoogleCloudRunV2Container> OAIGoogleCloudRunV2Task::getContainers() const {
    return m_containers;
}
void OAIGoogleCloudRunV2Task::setContainers(const QList<OAIGoogleCloudRunV2Container> &containers) {
    m_containers = containers;
    m_containers_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_containers_Set() const{
    return m_containers_isSet;
}

bool OAIGoogleCloudRunV2Task::is_containers_Valid() const{
    return m_containers_isValid;
}

QString OAIGoogleCloudRunV2Task::getCreateTime() const {
    return m_create_time;
}
void OAIGoogleCloudRunV2Task::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QString OAIGoogleCloudRunV2Task::getDeleteTime() const {
    return m_delete_time;
}
void OAIGoogleCloudRunV2Task::setDeleteTime(const QString &delete_time) {
    m_delete_time = delete_time;
    m_delete_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_delete_time_Set() const{
    return m_delete_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_delete_time_Valid() const{
    return m_delete_time_isValid;
}

QString OAIGoogleCloudRunV2Task::getEncryptionKey() const {
    return m_encryption_key;
}
void OAIGoogleCloudRunV2Task::setEncryptionKey(const QString &encryption_key) {
    m_encryption_key = encryption_key;
    m_encryption_key_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_encryption_key_Set() const{
    return m_encryption_key_isSet;
}

bool OAIGoogleCloudRunV2Task::is_encryption_key_Valid() const{
    return m_encryption_key_isValid;
}

QString OAIGoogleCloudRunV2Task::getEtag() const {
    return m_etag;
}
void OAIGoogleCloudRunV2Task::setEtag(const QString &etag) {
    m_etag = etag;
    m_etag_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_etag_Set() const{
    return m_etag_isSet;
}

bool OAIGoogleCloudRunV2Task::is_etag_Valid() const{
    return m_etag_isValid;
}

QString OAIGoogleCloudRunV2Task::getExecution() const {
    return m_execution;
}
void OAIGoogleCloudRunV2Task::setExecution(const QString &execution) {
    m_execution = execution;
    m_execution_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_execution_Set() const{
    return m_execution_isSet;
}

bool OAIGoogleCloudRunV2Task::is_execution_Valid() const{
    return m_execution_isValid;
}

QString OAIGoogleCloudRunV2Task::getExecutionEnvironment() const {
    return m_execution_environment;
}
void OAIGoogleCloudRunV2Task::setExecutionEnvironment(const QString &execution_environment) {
    m_execution_environment = execution_environment;
    m_execution_environment_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_execution_environment_Set() const{
    return m_execution_environment_isSet;
}

bool OAIGoogleCloudRunV2Task::is_execution_environment_Valid() const{
    return m_execution_environment_isValid;
}

QString OAIGoogleCloudRunV2Task::getExpireTime() const {
    return m_expire_time;
}
void OAIGoogleCloudRunV2Task::setExpireTime(const QString &expire_time) {
    m_expire_time = expire_time;
    m_expire_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_expire_time_Set() const{
    return m_expire_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_expire_time_Valid() const{
    return m_expire_time_isValid;
}

QString OAIGoogleCloudRunV2Task::getGeneration() const {
    return m_generation;
}
void OAIGoogleCloudRunV2Task::setGeneration(const QString &generation) {
    m_generation = generation;
    m_generation_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_generation_Set() const{
    return m_generation_isSet;
}

bool OAIGoogleCloudRunV2Task::is_generation_Valid() const{
    return m_generation_isValid;
}

qint32 OAIGoogleCloudRunV2Task::getIndex() const {
    return m_index;
}
void OAIGoogleCloudRunV2Task::setIndex(const qint32 &index) {
    m_index = index;
    m_index_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_index_Set() const{
    return m_index_isSet;
}

bool OAIGoogleCloudRunV2Task::is_index_Valid() const{
    return m_index_isValid;
}

QString OAIGoogleCloudRunV2Task::getJob() const {
    return m_job;
}
void OAIGoogleCloudRunV2Task::setJob(const QString &job) {
    m_job = job;
    m_job_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_job_Set() const{
    return m_job_isSet;
}

bool OAIGoogleCloudRunV2Task::is_job_Valid() const{
    return m_job_isValid;
}

QMap<QString, QString> OAIGoogleCloudRunV2Task::getLabels() const {
    return m_labels;
}
void OAIGoogleCloudRunV2Task::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIGoogleCloudRunV2Task::is_labels_Valid() const{
    return m_labels_isValid;
}

OAIGoogleCloudRunV2TaskAttemptResult OAIGoogleCloudRunV2Task::getLastAttemptResult() const {
    return m_last_attempt_result;
}
void OAIGoogleCloudRunV2Task::setLastAttemptResult(const OAIGoogleCloudRunV2TaskAttemptResult &last_attempt_result) {
    m_last_attempt_result = last_attempt_result;
    m_last_attempt_result_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_last_attempt_result_Set() const{
    return m_last_attempt_result_isSet;
}

bool OAIGoogleCloudRunV2Task::is_last_attempt_result_Valid() const{
    return m_last_attempt_result_isValid;
}

QString OAIGoogleCloudRunV2Task::getLogUri() const {
    return m_log_uri;
}
void OAIGoogleCloudRunV2Task::setLogUri(const QString &log_uri) {
    m_log_uri = log_uri;
    m_log_uri_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_log_uri_Set() const{
    return m_log_uri_isSet;
}

bool OAIGoogleCloudRunV2Task::is_log_uri_Valid() const{
    return m_log_uri_isValid;
}

qint32 OAIGoogleCloudRunV2Task::getMaxRetries() const {
    return m_max_retries;
}
void OAIGoogleCloudRunV2Task::setMaxRetries(const qint32 &max_retries) {
    m_max_retries = max_retries;
    m_max_retries_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_max_retries_Set() const{
    return m_max_retries_isSet;
}

bool OAIGoogleCloudRunV2Task::is_max_retries_Valid() const{
    return m_max_retries_isValid;
}

QString OAIGoogleCloudRunV2Task::getName() const {
    return m_name;
}
void OAIGoogleCloudRunV2Task::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_name_Set() const{
    return m_name_isSet;
}

bool OAIGoogleCloudRunV2Task::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIGoogleCloudRunV2Task::getObservedGeneration() const {
    return m_observed_generation;
}
void OAIGoogleCloudRunV2Task::setObservedGeneration(const QString &observed_generation) {
    m_observed_generation = observed_generation;
    m_observed_generation_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_observed_generation_Set() const{
    return m_observed_generation_isSet;
}

bool OAIGoogleCloudRunV2Task::is_observed_generation_Valid() const{
    return m_observed_generation_isValid;
}

bool OAIGoogleCloudRunV2Task::isReconciling() const {
    return m_reconciling;
}
void OAIGoogleCloudRunV2Task::setReconciling(const bool &reconciling) {
    m_reconciling = reconciling;
    m_reconciling_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_reconciling_Set() const{
    return m_reconciling_isSet;
}

bool OAIGoogleCloudRunV2Task::is_reconciling_Valid() const{
    return m_reconciling_isValid;
}

qint32 OAIGoogleCloudRunV2Task::getRetried() const {
    return m_retried;
}
void OAIGoogleCloudRunV2Task::setRetried(const qint32 &retried) {
    m_retried = retried;
    m_retried_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_retried_Set() const{
    return m_retried_isSet;
}

bool OAIGoogleCloudRunV2Task::is_retried_Valid() const{
    return m_retried_isValid;
}

bool OAIGoogleCloudRunV2Task::isSatisfiesPzs() const {
    return m_satisfies_pzs;
}
void OAIGoogleCloudRunV2Task::setSatisfiesPzs(const bool &satisfies_pzs) {
    m_satisfies_pzs = satisfies_pzs;
    m_satisfies_pzs_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_satisfies_pzs_Set() const{
    return m_satisfies_pzs_isSet;
}

bool OAIGoogleCloudRunV2Task::is_satisfies_pzs_Valid() const{
    return m_satisfies_pzs_isValid;
}

QString OAIGoogleCloudRunV2Task::getScheduledTime() const {
    return m_scheduled_time;
}
void OAIGoogleCloudRunV2Task::setScheduledTime(const QString &scheduled_time) {
    m_scheduled_time = scheduled_time;
    m_scheduled_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_scheduled_time_Set() const{
    return m_scheduled_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_scheduled_time_Valid() const{
    return m_scheduled_time_isValid;
}

QString OAIGoogleCloudRunV2Task::getServiceAccount() const {
    return m_service_account;
}
void OAIGoogleCloudRunV2Task::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAIGoogleCloudRunV2Task::is_service_account_Valid() const{
    return m_service_account_isValid;
}

QString OAIGoogleCloudRunV2Task::getStartTime() const {
    return m_start_time;
}
void OAIGoogleCloudRunV2Task::setStartTime(const QString &start_time) {
    m_start_time = start_time;
    m_start_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_start_time_Set() const{
    return m_start_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_start_time_Valid() const{
    return m_start_time_isValid;
}

QString OAIGoogleCloudRunV2Task::getTimeout() const {
    return m_timeout;
}
void OAIGoogleCloudRunV2Task::setTimeout(const QString &timeout) {
    m_timeout = timeout;
    m_timeout_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_timeout_Set() const{
    return m_timeout_isSet;
}

bool OAIGoogleCloudRunV2Task::is_timeout_Valid() const{
    return m_timeout_isValid;
}

QString OAIGoogleCloudRunV2Task::getUid() const {
    return m_uid;
}
void OAIGoogleCloudRunV2Task::setUid(const QString &uid) {
    m_uid = uid;
    m_uid_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_uid_Set() const{
    return m_uid_isSet;
}

bool OAIGoogleCloudRunV2Task::is_uid_Valid() const{
    return m_uid_isValid;
}

QString OAIGoogleCloudRunV2Task::getUpdateTime() const {
    return m_update_time;
}
void OAIGoogleCloudRunV2Task::setUpdateTime(const QString &update_time) {
    m_update_time = update_time;
    m_update_time_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_update_time_Set() const{
    return m_update_time_isSet;
}

bool OAIGoogleCloudRunV2Task::is_update_time_Valid() const{
    return m_update_time_isValid;
}

QList<OAIGoogleCloudRunV2Volume> OAIGoogleCloudRunV2Task::getVolumes() const {
    return m_volumes;
}
void OAIGoogleCloudRunV2Task::setVolumes(const QList<OAIGoogleCloudRunV2Volume> &volumes) {
    m_volumes = volumes;
    m_volumes_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_volumes_Set() const{
    return m_volumes_isSet;
}

bool OAIGoogleCloudRunV2Task::is_volumes_Valid() const{
    return m_volumes_isValid;
}

OAIGoogleCloudRunV2VpcAccess OAIGoogleCloudRunV2Task::getVpcAccess() const {
    return m_vpc_access;
}
void OAIGoogleCloudRunV2Task::setVpcAccess(const OAIGoogleCloudRunV2VpcAccess &vpc_access) {
    m_vpc_access = vpc_access;
    m_vpc_access_isSet = true;
}

bool OAIGoogleCloudRunV2Task::is_vpc_access_Set() const{
    return m_vpc_access_isSet;
}

bool OAIGoogleCloudRunV2Task::is_vpc_access_Valid() const{
    return m_vpc_access_isValid;
}

bool OAIGoogleCloudRunV2Task::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_completion_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_conditions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_containers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_delete_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_etag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_execution_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_execution_environment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expire_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_generation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_index_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_job_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_attempt_result.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_log_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_retries_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_observed_generation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reconciling_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retried_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzs_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduled_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_volumes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_vpc_access.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGoogleCloudRunV2Task::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
