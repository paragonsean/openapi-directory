/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGoogleCloudRunV2TaskTemplate.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGoogleCloudRunV2TaskTemplate::OAIGoogleCloudRunV2TaskTemplate(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGoogleCloudRunV2TaskTemplate::OAIGoogleCloudRunV2TaskTemplate() {
    this->initializeModel();
}

OAIGoogleCloudRunV2TaskTemplate::~OAIGoogleCloudRunV2TaskTemplate() {}

void OAIGoogleCloudRunV2TaskTemplate::initializeModel() {

    m_containers_isSet = false;
    m_containers_isValid = false;

    m_encryption_key_isSet = false;
    m_encryption_key_isValid = false;

    m_execution_environment_isSet = false;
    m_execution_environment_isValid = false;

    m_max_retries_isSet = false;
    m_max_retries_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_timeout_isSet = false;
    m_timeout_isValid = false;

    m_volumes_isSet = false;
    m_volumes_isValid = false;

    m_vpc_access_isSet = false;
    m_vpc_access_isValid = false;
}

void OAIGoogleCloudRunV2TaskTemplate::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGoogleCloudRunV2TaskTemplate::fromJsonObject(QJsonObject json) {

    m_containers_isValid = ::OpenAPI::fromJsonValue(m_containers, json[QString("containers")]);
    m_containers_isSet = !json[QString("containers")].isNull() && m_containers_isValid;

    m_encryption_key_isValid = ::OpenAPI::fromJsonValue(m_encryption_key, json[QString("encryptionKey")]);
    m_encryption_key_isSet = !json[QString("encryptionKey")].isNull() && m_encryption_key_isValid;

    m_execution_environment_isValid = ::OpenAPI::fromJsonValue(m_execution_environment, json[QString("executionEnvironment")]);
    m_execution_environment_isSet = !json[QString("executionEnvironment")].isNull() && m_execution_environment_isValid;

    m_max_retries_isValid = ::OpenAPI::fromJsonValue(m_max_retries, json[QString("maxRetries")]);
    m_max_retries_isSet = !json[QString("maxRetries")].isNull() && m_max_retries_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_timeout_isValid = ::OpenAPI::fromJsonValue(m_timeout, json[QString("timeout")]);
    m_timeout_isSet = !json[QString("timeout")].isNull() && m_timeout_isValid;

    m_volumes_isValid = ::OpenAPI::fromJsonValue(m_volumes, json[QString("volumes")]);
    m_volumes_isSet = !json[QString("volumes")].isNull() && m_volumes_isValid;

    m_vpc_access_isValid = ::OpenAPI::fromJsonValue(m_vpc_access, json[QString("vpcAccess")]);
    m_vpc_access_isSet = !json[QString("vpcAccess")].isNull() && m_vpc_access_isValid;
}

QString OAIGoogleCloudRunV2TaskTemplate::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGoogleCloudRunV2TaskTemplate::asJsonObject() const {
    QJsonObject obj;
    if (m_containers.size() > 0) {
        obj.insert(QString("containers"), ::OpenAPI::toJsonValue(m_containers));
    }
    if (m_encryption_key_isSet) {
        obj.insert(QString("encryptionKey"), ::OpenAPI::toJsonValue(m_encryption_key));
    }
    if (m_execution_environment_isSet) {
        obj.insert(QString("executionEnvironment"), ::OpenAPI::toJsonValue(m_execution_environment));
    }
    if (m_max_retries_isSet) {
        obj.insert(QString("maxRetries"), ::OpenAPI::toJsonValue(m_max_retries));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_timeout_isSet) {
        obj.insert(QString("timeout"), ::OpenAPI::toJsonValue(m_timeout));
    }
    if (m_volumes.size() > 0) {
        obj.insert(QString("volumes"), ::OpenAPI::toJsonValue(m_volumes));
    }
    if (m_vpc_access.isSet()) {
        obj.insert(QString("vpcAccess"), ::OpenAPI::toJsonValue(m_vpc_access));
    }
    return obj;
}

QList<OAIGoogleCloudRunV2Container> OAIGoogleCloudRunV2TaskTemplate::getContainers() const {
    return m_containers;
}
void OAIGoogleCloudRunV2TaskTemplate::setContainers(const QList<OAIGoogleCloudRunV2Container> &containers) {
    m_containers = containers;
    m_containers_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_containers_Set() const{
    return m_containers_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_containers_Valid() const{
    return m_containers_isValid;
}

QString OAIGoogleCloudRunV2TaskTemplate::getEncryptionKey() const {
    return m_encryption_key;
}
void OAIGoogleCloudRunV2TaskTemplate::setEncryptionKey(const QString &encryption_key) {
    m_encryption_key = encryption_key;
    m_encryption_key_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_encryption_key_Set() const{
    return m_encryption_key_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_encryption_key_Valid() const{
    return m_encryption_key_isValid;
}

QString OAIGoogleCloudRunV2TaskTemplate::getExecutionEnvironment() const {
    return m_execution_environment;
}
void OAIGoogleCloudRunV2TaskTemplate::setExecutionEnvironment(const QString &execution_environment) {
    m_execution_environment = execution_environment;
    m_execution_environment_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_execution_environment_Set() const{
    return m_execution_environment_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_execution_environment_Valid() const{
    return m_execution_environment_isValid;
}

qint32 OAIGoogleCloudRunV2TaskTemplate::getMaxRetries() const {
    return m_max_retries;
}
void OAIGoogleCloudRunV2TaskTemplate::setMaxRetries(const qint32 &max_retries) {
    m_max_retries = max_retries;
    m_max_retries_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_max_retries_Set() const{
    return m_max_retries_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_max_retries_Valid() const{
    return m_max_retries_isValid;
}

QString OAIGoogleCloudRunV2TaskTemplate::getServiceAccount() const {
    return m_service_account;
}
void OAIGoogleCloudRunV2TaskTemplate::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_service_account_Valid() const{
    return m_service_account_isValid;
}

QString OAIGoogleCloudRunV2TaskTemplate::getTimeout() const {
    return m_timeout;
}
void OAIGoogleCloudRunV2TaskTemplate::setTimeout(const QString &timeout) {
    m_timeout = timeout;
    m_timeout_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_timeout_Set() const{
    return m_timeout_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_timeout_Valid() const{
    return m_timeout_isValid;
}

QList<OAIGoogleCloudRunV2Volume> OAIGoogleCloudRunV2TaskTemplate::getVolumes() const {
    return m_volumes;
}
void OAIGoogleCloudRunV2TaskTemplate::setVolumes(const QList<OAIGoogleCloudRunV2Volume> &volumes) {
    m_volumes = volumes;
    m_volumes_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_volumes_Set() const{
    return m_volumes_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_volumes_Valid() const{
    return m_volumes_isValid;
}

OAIGoogleCloudRunV2VpcAccess OAIGoogleCloudRunV2TaskTemplate::getVpcAccess() const {
    return m_vpc_access;
}
void OAIGoogleCloudRunV2TaskTemplate::setVpcAccess(const OAIGoogleCloudRunV2VpcAccess &vpc_access) {
    m_vpc_access = vpc_access;
    m_vpc_access_isSet = true;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_vpc_access_Set() const{
    return m_vpc_access_isSet;
}

bool OAIGoogleCloudRunV2TaskTemplate::is_vpc_access_Valid() const{
    return m_vpc_access_isValid;
}

bool OAIGoogleCloudRunV2TaskTemplate::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_containers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_execution_environment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_retries_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_volumes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_vpc_access.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGoogleCloudRunV2TaskTemplate::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
