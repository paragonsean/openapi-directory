/*
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * TrafficTarget holds a single entry of the routing table for a Route.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:35:12.475272-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TrafficTarget {
  public static final String SERIALIZED_NAME_CONFIGURATION_NAME = "configurationName";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CONFIGURATION_NAME)
  private String configurationName;

  public static final String SERIALIZED_NAME_LATEST_REVISION = "latestRevision";
  @SerializedName(SERIALIZED_NAME_LATEST_REVISION)
  private Boolean latestRevision;

  public static final String SERIALIZED_NAME_PERCENT = "percent";
  @SerializedName(SERIALIZED_NAME_PERCENT)
  private Integer percent;

  public static final String SERIALIZED_NAME_REVISION_NAME = "revisionName";
  @SerializedName(SERIALIZED_NAME_REVISION_NAME)
  private String revisionName;

  public static final String SERIALIZED_NAME_TAG = "tag";
  @SerializedName(SERIALIZED_NAME_TAG)
  private String tag;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public TrafficTarget() {
  }

  public TrafficTarget(
     String url
  ) {
    this();
    this.url = url;
  }

  @Deprecated
  public TrafficTarget configurationName(String configurationName) {
    this.configurationName = configurationName;
    return this;
  }

  /**
   * [Deprecated] Not supported in Cloud Run. It must be empty.
   * @return configurationName
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getConfigurationName() {
    return configurationName;
  }

  @Deprecated
  public void setConfigurationName(String configurationName) {
    this.configurationName = configurationName;
  }


  public TrafficTarget latestRevision(Boolean latestRevision) {
    this.latestRevision = latestRevision;
    return this;
  }

  /**
   * Uses the \&quot;status.latestReadyRevisionName\&quot; of the Service to determine the traffic target. When it changes, traffic will automatically migrate from the prior \&quot;latest ready\&quot; revision to the new one. This field must be false if RevisionName is set. This field defaults to true otherwise. If the field is set to true on Status, this means that the Revision was resolved from the Service&#39;s latest ready revision.
   * @return latestRevision
   */
  @javax.annotation.Nullable
  public Boolean getLatestRevision() {
    return latestRevision;
  }

  public void setLatestRevision(Boolean latestRevision) {
    this.latestRevision = latestRevision;
  }


  public TrafficTarget percent(Integer percent) {
    this.percent = percent;
    return this;
  }

  /**
   * Percent specifies percent of the traffic to this Revision or Configuration. This defaults to zero if unspecified.
   * @return percent
   */
  @javax.annotation.Nullable
  public Integer getPercent() {
    return percent;
  }

  public void setPercent(Integer percent) {
    this.percent = percent;
  }


  public TrafficTarget revisionName(String revisionName) {
    this.revisionName = revisionName;
    return this;
  }

  /**
   * Points this traffic target to a specific Revision. This field is mutually exclusive with latest_revision.
   * @return revisionName
   */
  @javax.annotation.Nullable
  public String getRevisionName() {
    return revisionName;
  }

  public void setRevisionName(String revisionName) {
    this.revisionName = revisionName;
  }


  public TrafficTarget tag(String tag) {
    this.tag = tag;
    return this;
  }

  /**
   * Tag is used to expose a dedicated url for referencing this target exclusively.
   * @return tag
   */
  @javax.annotation.Nullable
  public String getTag() {
    return tag;
  }

  public void setTag(String tag) {
    this.tag = tag;
  }


  /**
   * Output only. URL displays the URL for accessing tagged traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. https://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
   * @return url
   */
  @javax.annotation.Nullable
  public String getUrl() {
    return url;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TrafficTarget trafficTarget = (TrafficTarget) o;
    return Objects.equals(this.configurationName, trafficTarget.configurationName) &&
        Objects.equals(this.latestRevision, trafficTarget.latestRevision) &&
        Objects.equals(this.percent, trafficTarget.percent) &&
        Objects.equals(this.revisionName, trafficTarget.revisionName) &&
        Objects.equals(this.tag, trafficTarget.tag) &&
        Objects.equals(this.url, trafficTarget.url);
  }

  @Override
  public int hashCode() {
    return Objects.hash(configurationName, latestRevision, percent, revisionName, tag, url);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TrafficTarget {\n");
    sb.append("    configurationName: ").append(toIndentedString(configurationName)).append("\n");
    sb.append("    latestRevision: ").append(toIndentedString(latestRevision)).append("\n");
    sb.append("    percent: ").append(toIndentedString(percent)).append("\n");
    sb.append("    revisionName: ").append(toIndentedString(revisionName)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("configurationName");
    openapiFields.add("latestRevision");
    openapiFields.add("percent");
    openapiFields.add("revisionName");
    openapiFields.add("tag");
    openapiFields.add("url");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TrafficTarget
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TrafficTarget.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TrafficTarget is not found in the empty JSON string", TrafficTarget.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TrafficTarget.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TrafficTarget` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("configurationName") != null && !jsonObj.get("configurationName").isJsonNull()) && !jsonObj.get("configurationName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `configurationName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("configurationName").toString()));
      }
      if ((jsonObj.get("revisionName") != null && !jsonObj.get("revisionName").isJsonNull()) && !jsonObj.get("revisionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionName").toString()));
      }
      if ((jsonObj.get("tag") != null && !jsonObj.get("tag").isJsonNull()) && !jsonObj.get("tag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tag").toString()));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TrafficTarget.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TrafficTarget' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TrafficTarget> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TrafficTarget.class));

       return (TypeAdapter<T>) new TypeAdapter<TrafficTarget>() {
           @Override
           public void write(JsonWriter out, TrafficTarget value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TrafficTarget read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TrafficTarget given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TrafficTarget
   * @throws IOException if the JSON string is invalid with respect to TrafficTarget
   */
  public static TrafficTarget fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TrafficTarget.class);
  }

  /**
   * Convert an instance of TrafficTarget to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

