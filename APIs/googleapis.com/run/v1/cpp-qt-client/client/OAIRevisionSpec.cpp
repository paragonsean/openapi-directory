/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRevisionSpec.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRevisionSpec::OAIRevisionSpec(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRevisionSpec::OAIRevisionSpec() {
    this->initializeModel();
}

OAIRevisionSpec::~OAIRevisionSpec() {}

void OAIRevisionSpec::initializeModel() {

    m_container_concurrency_isSet = false;
    m_container_concurrency_isValid = false;

    m_containers_isSet = false;
    m_containers_isValid = false;

    m_enable_service_links_isSet = false;
    m_enable_service_links_isValid = false;

    m_image_pull_secrets_isSet = false;
    m_image_pull_secrets_isValid = false;

    m_service_account_name_isSet = false;
    m_service_account_name_isValid = false;

    m_timeout_seconds_isSet = false;
    m_timeout_seconds_isValid = false;

    m_volumes_isSet = false;
    m_volumes_isValid = false;
}

void OAIRevisionSpec::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRevisionSpec::fromJsonObject(QJsonObject json) {

    m_container_concurrency_isValid = ::OpenAPI::fromJsonValue(m_container_concurrency, json[QString("containerConcurrency")]);
    m_container_concurrency_isSet = !json[QString("containerConcurrency")].isNull() && m_container_concurrency_isValid;

    m_containers_isValid = ::OpenAPI::fromJsonValue(m_containers, json[QString("containers")]);
    m_containers_isSet = !json[QString("containers")].isNull() && m_containers_isValid;

    m_enable_service_links_isValid = ::OpenAPI::fromJsonValue(m_enable_service_links, json[QString("enableServiceLinks")]);
    m_enable_service_links_isSet = !json[QString("enableServiceLinks")].isNull() && m_enable_service_links_isValid;

    m_image_pull_secrets_isValid = ::OpenAPI::fromJsonValue(m_image_pull_secrets, json[QString("imagePullSecrets")]);
    m_image_pull_secrets_isSet = !json[QString("imagePullSecrets")].isNull() && m_image_pull_secrets_isValid;

    m_service_account_name_isValid = ::OpenAPI::fromJsonValue(m_service_account_name, json[QString("serviceAccountName")]);
    m_service_account_name_isSet = !json[QString("serviceAccountName")].isNull() && m_service_account_name_isValid;

    m_timeout_seconds_isValid = ::OpenAPI::fromJsonValue(m_timeout_seconds, json[QString("timeoutSeconds")]);
    m_timeout_seconds_isSet = !json[QString("timeoutSeconds")].isNull() && m_timeout_seconds_isValid;

    m_volumes_isValid = ::OpenAPI::fromJsonValue(m_volumes, json[QString("volumes")]);
    m_volumes_isSet = !json[QString("volumes")].isNull() && m_volumes_isValid;
}

QString OAIRevisionSpec::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRevisionSpec::asJsonObject() const {
    QJsonObject obj;
    if (m_container_concurrency_isSet) {
        obj.insert(QString("containerConcurrency"), ::OpenAPI::toJsonValue(m_container_concurrency));
    }
    if (m_containers.size() > 0) {
        obj.insert(QString("containers"), ::OpenAPI::toJsonValue(m_containers));
    }
    if (m_enable_service_links_isSet) {
        obj.insert(QString("enableServiceLinks"), ::OpenAPI::toJsonValue(m_enable_service_links));
    }
    if (m_image_pull_secrets.size() > 0) {
        obj.insert(QString("imagePullSecrets"), ::OpenAPI::toJsonValue(m_image_pull_secrets));
    }
    if (m_service_account_name_isSet) {
        obj.insert(QString("serviceAccountName"), ::OpenAPI::toJsonValue(m_service_account_name));
    }
    if (m_timeout_seconds_isSet) {
        obj.insert(QString("timeoutSeconds"), ::OpenAPI::toJsonValue(m_timeout_seconds));
    }
    if (m_volumes.size() > 0) {
        obj.insert(QString("volumes"), ::OpenAPI::toJsonValue(m_volumes));
    }
    return obj;
}

qint32 OAIRevisionSpec::getContainerConcurrency() const {
    return m_container_concurrency;
}
void OAIRevisionSpec::setContainerConcurrency(const qint32 &container_concurrency) {
    m_container_concurrency = container_concurrency;
    m_container_concurrency_isSet = true;
}

bool OAIRevisionSpec::is_container_concurrency_Set() const{
    return m_container_concurrency_isSet;
}

bool OAIRevisionSpec::is_container_concurrency_Valid() const{
    return m_container_concurrency_isValid;
}

QList<OAIContainer> OAIRevisionSpec::getContainers() const {
    return m_containers;
}
void OAIRevisionSpec::setContainers(const QList<OAIContainer> &containers) {
    m_containers = containers;
    m_containers_isSet = true;
}

bool OAIRevisionSpec::is_containers_Set() const{
    return m_containers_isSet;
}

bool OAIRevisionSpec::is_containers_Valid() const{
    return m_containers_isValid;
}

bool OAIRevisionSpec::isEnableServiceLinks() const {
    return m_enable_service_links;
}
void OAIRevisionSpec::setEnableServiceLinks(const bool &enable_service_links) {
    m_enable_service_links = enable_service_links;
    m_enable_service_links_isSet = true;
}

bool OAIRevisionSpec::is_enable_service_links_Set() const{
    return m_enable_service_links_isSet;
}

bool OAIRevisionSpec::is_enable_service_links_Valid() const{
    return m_enable_service_links_isValid;
}

QList<OAILocalObjectReference> OAIRevisionSpec::getImagePullSecrets() const {
    return m_image_pull_secrets;
}
void OAIRevisionSpec::setImagePullSecrets(const QList<OAILocalObjectReference> &image_pull_secrets) {
    m_image_pull_secrets = image_pull_secrets;
    m_image_pull_secrets_isSet = true;
}

bool OAIRevisionSpec::is_image_pull_secrets_Set() const{
    return m_image_pull_secrets_isSet;
}

bool OAIRevisionSpec::is_image_pull_secrets_Valid() const{
    return m_image_pull_secrets_isValid;
}

QString OAIRevisionSpec::getServiceAccountName() const {
    return m_service_account_name;
}
void OAIRevisionSpec::setServiceAccountName(const QString &service_account_name) {
    m_service_account_name = service_account_name;
    m_service_account_name_isSet = true;
}

bool OAIRevisionSpec::is_service_account_name_Set() const{
    return m_service_account_name_isSet;
}

bool OAIRevisionSpec::is_service_account_name_Valid() const{
    return m_service_account_name_isValid;
}

qint32 OAIRevisionSpec::getTimeoutSeconds() const {
    return m_timeout_seconds;
}
void OAIRevisionSpec::setTimeoutSeconds(const qint32 &timeout_seconds) {
    m_timeout_seconds = timeout_seconds;
    m_timeout_seconds_isSet = true;
}

bool OAIRevisionSpec::is_timeout_seconds_Set() const{
    return m_timeout_seconds_isSet;
}

bool OAIRevisionSpec::is_timeout_seconds_Valid() const{
    return m_timeout_seconds_isValid;
}

QList<OAIVolume> OAIRevisionSpec::getVolumes() const {
    return m_volumes;
}
void OAIRevisionSpec::setVolumes(const QList<OAIVolume> &volumes) {
    m_volumes = volumes;
    m_volumes_isSet = true;
}

bool OAIRevisionSpec::is_volumes_Set() const{
    return m_volumes_isSet;
}

bool OAIRevisionSpec::is_volumes_Valid() const{
    return m_volumes_isValid;
}

bool OAIRevisionSpec::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_container_concurrency_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_containers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_service_links_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_pull_secrets.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_volumes.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRevisionSpec::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
