/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIObjectMeta.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIObjectMeta::OAIObjectMeta(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIObjectMeta::OAIObjectMeta() {
    this->initializeModel();
}

OAIObjectMeta::~OAIObjectMeta() {}

void OAIObjectMeta::initializeModel() {

    m_annotations_isSet = false;
    m_annotations_isValid = false;

    m_cluster_name_isSet = false;
    m_cluster_name_isValid = false;

    m_creation_timestamp_isSet = false;
    m_creation_timestamp_isValid = false;

    m_deletion_grace_period_seconds_isSet = false;
    m_deletion_grace_period_seconds_isValid = false;

    m_deletion_timestamp_isSet = false;
    m_deletion_timestamp_isValid = false;

    m_finalizers_isSet = false;
    m_finalizers_isValid = false;

    m_generate_name_isSet = false;
    m_generate_name_isValid = false;

    m_generation_isSet = false;
    m_generation_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_r_namespace_isSet = false;
    m_r_namespace_isValid = false;

    m_owner_references_isSet = false;
    m_owner_references_isValid = false;

    m_resource_version_isSet = false;
    m_resource_version_isValid = false;

    m_self_link_isSet = false;
    m_self_link_isValid = false;

    m_uid_isSet = false;
    m_uid_isValid = false;
}

void OAIObjectMeta::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIObjectMeta::fromJsonObject(QJsonObject json) {

    m_annotations_isValid = ::OpenAPI::fromJsonValue(m_annotations, json[QString("annotations")]);
    m_annotations_isSet = !json[QString("annotations")].isNull() && m_annotations_isValid;

    m_cluster_name_isValid = ::OpenAPI::fromJsonValue(m_cluster_name, json[QString("clusterName")]);
    m_cluster_name_isSet = !json[QString("clusterName")].isNull() && m_cluster_name_isValid;

    m_creation_timestamp_isValid = ::OpenAPI::fromJsonValue(m_creation_timestamp, json[QString("creationTimestamp")]);
    m_creation_timestamp_isSet = !json[QString("creationTimestamp")].isNull() && m_creation_timestamp_isValid;

    m_deletion_grace_period_seconds_isValid = ::OpenAPI::fromJsonValue(m_deletion_grace_period_seconds, json[QString("deletionGracePeriodSeconds")]);
    m_deletion_grace_period_seconds_isSet = !json[QString("deletionGracePeriodSeconds")].isNull() && m_deletion_grace_period_seconds_isValid;

    m_deletion_timestamp_isValid = ::OpenAPI::fromJsonValue(m_deletion_timestamp, json[QString("deletionTimestamp")]);
    m_deletion_timestamp_isSet = !json[QString("deletionTimestamp")].isNull() && m_deletion_timestamp_isValid;

    m_finalizers_isValid = ::OpenAPI::fromJsonValue(m_finalizers, json[QString("finalizers")]);
    m_finalizers_isSet = !json[QString("finalizers")].isNull() && m_finalizers_isValid;

    m_generate_name_isValid = ::OpenAPI::fromJsonValue(m_generate_name, json[QString("generateName")]);
    m_generate_name_isSet = !json[QString("generateName")].isNull() && m_generate_name_isValid;

    m_generation_isValid = ::OpenAPI::fromJsonValue(m_generation, json[QString("generation")]);
    m_generation_isSet = !json[QString("generation")].isNull() && m_generation_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_r_namespace_isValid = ::OpenAPI::fromJsonValue(m_r_namespace, json[QString("namespace")]);
    m_r_namespace_isSet = !json[QString("namespace")].isNull() && m_r_namespace_isValid;

    m_owner_references_isValid = ::OpenAPI::fromJsonValue(m_owner_references, json[QString("ownerReferences")]);
    m_owner_references_isSet = !json[QString("ownerReferences")].isNull() && m_owner_references_isValid;

    m_resource_version_isValid = ::OpenAPI::fromJsonValue(m_resource_version, json[QString("resourceVersion")]);
    m_resource_version_isSet = !json[QString("resourceVersion")].isNull() && m_resource_version_isValid;

    m_self_link_isValid = ::OpenAPI::fromJsonValue(m_self_link, json[QString("selfLink")]);
    m_self_link_isSet = !json[QString("selfLink")].isNull() && m_self_link_isValid;

    m_uid_isValid = ::OpenAPI::fromJsonValue(m_uid, json[QString("uid")]);
    m_uid_isSet = !json[QString("uid")].isNull() && m_uid_isValid;
}

QString OAIObjectMeta::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIObjectMeta::asJsonObject() const {
    QJsonObject obj;
    if (m_annotations.size() > 0) {
        obj.insert(QString("annotations"), ::OpenAPI::toJsonValue(m_annotations));
    }
    if (m_cluster_name_isSet) {
        obj.insert(QString("clusterName"), ::OpenAPI::toJsonValue(m_cluster_name));
    }
    if (m_creation_timestamp_isSet) {
        obj.insert(QString("creationTimestamp"), ::OpenAPI::toJsonValue(m_creation_timestamp));
    }
    if (m_deletion_grace_period_seconds_isSet) {
        obj.insert(QString("deletionGracePeriodSeconds"), ::OpenAPI::toJsonValue(m_deletion_grace_period_seconds));
    }
    if (m_deletion_timestamp_isSet) {
        obj.insert(QString("deletionTimestamp"), ::OpenAPI::toJsonValue(m_deletion_timestamp));
    }
    if (m_finalizers.size() > 0) {
        obj.insert(QString("finalizers"), ::OpenAPI::toJsonValue(m_finalizers));
    }
    if (m_generate_name_isSet) {
        obj.insert(QString("generateName"), ::OpenAPI::toJsonValue(m_generate_name));
    }
    if (m_generation_isSet) {
        obj.insert(QString("generation"), ::OpenAPI::toJsonValue(m_generation));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_r_namespace_isSet) {
        obj.insert(QString("namespace"), ::OpenAPI::toJsonValue(m_r_namespace));
    }
    if (m_owner_references.size() > 0) {
        obj.insert(QString("ownerReferences"), ::OpenAPI::toJsonValue(m_owner_references));
    }
    if (m_resource_version_isSet) {
        obj.insert(QString("resourceVersion"), ::OpenAPI::toJsonValue(m_resource_version));
    }
    if (m_self_link_isSet) {
        obj.insert(QString("selfLink"), ::OpenAPI::toJsonValue(m_self_link));
    }
    if (m_uid_isSet) {
        obj.insert(QString("uid"), ::OpenAPI::toJsonValue(m_uid));
    }
    return obj;
}

QMap<QString, QString> OAIObjectMeta::getAnnotations() const {
    return m_annotations;
}
void OAIObjectMeta::setAnnotations(const QMap<QString, QString> &annotations) {
    m_annotations = annotations;
    m_annotations_isSet = true;
}

bool OAIObjectMeta::is_annotations_Set() const{
    return m_annotations_isSet;
}

bool OAIObjectMeta::is_annotations_Valid() const{
    return m_annotations_isValid;
}

QString OAIObjectMeta::getClusterName() const {
    return m_cluster_name;
}
void OAIObjectMeta::setClusterName(const QString &cluster_name) {
    m_cluster_name = cluster_name;
    m_cluster_name_isSet = true;
}

bool OAIObjectMeta::is_cluster_name_Set() const{
    return m_cluster_name_isSet;
}

bool OAIObjectMeta::is_cluster_name_Valid() const{
    return m_cluster_name_isValid;
}

QString OAIObjectMeta::getCreationTimestamp() const {
    return m_creation_timestamp;
}
void OAIObjectMeta::setCreationTimestamp(const QString &creation_timestamp) {
    m_creation_timestamp = creation_timestamp;
    m_creation_timestamp_isSet = true;
}

bool OAIObjectMeta::is_creation_timestamp_Set() const{
    return m_creation_timestamp_isSet;
}

bool OAIObjectMeta::is_creation_timestamp_Valid() const{
    return m_creation_timestamp_isValid;
}

qint32 OAIObjectMeta::getDeletionGracePeriodSeconds() const {
    return m_deletion_grace_period_seconds;
}
void OAIObjectMeta::setDeletionGracePeriodSeconds(const qint32 &deletion_grace_period_seconds) {
    m_deletion_grace_period_seconds = deletion_grace_period_seconds;
    m_deletion_grace_period_seconds_isSet = true;
}

bool OAIObjectMeta::is_deletion_grace_period_seconds_Set() const{
    return m_deletion_grace_period_seconds_isSet;
}

bool OAIObjectMeta::is_deletion_grace_period_seconds_Valid() const{
    return m_deletion_grace_period_seconds_isValid;
}

QString OAIObjectMeta::getDeletionTimestamp() const {
    return m_deletion_timestamp;
}
void OAIObjectMeta::setDeletionTimestamp(const QString &deletion_timestamp) {
    m_deletion_timestamp = deletion_timestamp;
    m_deletion_timestamp_isSet = true;
}

bool OAIObjectMeta::is_deletion_timestamp_Set() const{
    return m_deletion_timestamp_isSet;
}

bool OAIObjectMeta::is_deletion_timestamp_Valid() const{
    return m_deletion_timestamp_isValid;
}

QList<QString> OAIObjectMeta::getFinalizers() const {
    return m_finalizers;
}
void OAIObjectMeta::setFinalizers(const QList<QString> &finalizers) {
    m_finalizers = finalizers;
    m_finalizers_isSet = true;
}

bool OAIObjectMeta::is_finalizers_Set() const{
    return m_finalizers_isSet;
}

bool OAIObjectMeta::is_finalizers_Valid() const{
    return m_finalizers_isValid;
}

QString OAIObjectMeta::getGenerateName() const {
    return m_generate_name;
}
void OAIObjectMeta::setGenerateName(const QString &generate_name) {
    m_generate_name = generate_name;
    m_generate_name_isSet = true;
}

bool OAIObjectMeta::is_generate_name_Set() const{
    return m_generate_name_isSet;
}

bool OAIObjectMeta::is_generate_name_Valid() const{
    return m_generate_name_isValid;
}

qint32 OAIObjectMeta::getGeneration() const {
    return m_generation;
}
void OAIObjectMeta::setGeneration(const qint32 &generation) {
    m_generation = generation;
    m_generation_isSet = true;
}

bool OAIObjectMeta::is_generation_Set() const{
    return m_generation_isSet;
}

bool OAIObjectMeta::is_generation_Valid() const{
    return m_generation_isValid;
}

QMap<QString, QString> OAIObjectMeta::getLabels() const {
    return m_labels;
}
void OAIObjectMeta::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIObjectMeta::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIObjectMeta::is_labels_Valid() const{
    return m_labels_isValid;
}

QString OAIObjectMeta::getName() const {
    return m_name;
}
void OAIObjectMeta::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIObjectMeta::is_name_Set() const{
    return m_name_isSet;
}

bool OAIObjectMeta::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIObjectMeta::getRNamespace() const {
    return m_r_namespace;
}
void OAIObjectMeta::setRNamespace(const QString &r_namespace) {
    m_r_namespace = r_namespace;
    m_r_namespace_isSet = true;
}

bool OAIObjectMeta::is_r_namespace_Set() const{
    return m_r_namespace_isSet;
}

bool OAIObjectMeta::is_r_namespace_Valid() const{
    return m_r_namespace_isValid;
}

QList<OAIOwnerReference> OAIObjectMeta::getOwnerReferences() const {
    return m_owner_references;
}
void OAIObjectMeta::setOwnerReferences(const QList<OAIOwnerReference> &owner_references) {
    m_owner_references = owner_references;
    m_owner_references_isSet = true;
}

bool OAIObjectMeta::is_owner_references_Set() const{
    return m_owner_references_isSet;
}

bool OAIObjectMeta::is_owner_references_Valid() const{
    return m_owner_references_isValid;
}

QString OAIObjectMeta::getResourceVersion() const {
    return m_resource_version;
}
void OAIObjectMeta::setResourceVersion(const QString &resource_version) {
    m_resource_version = resource_version;
    m_resource_version_isSet = true;
}

bool OAIObjectMeta::is_resource_version_Set() const{
    return m_resource_version_isSet;
}

bool OAIObjectMeta::is_resource_version_Valid() const{
    return m_resource_version_isValid;
}

QString OAIObjectMeta::getSelfLink() const {
    return m_self_link;
}
void OAIObjectMeta::setSelfLink(const QString &self_link) {
    m_self_link = self_link;
    m_self_link_isSet = true;
}

bool OAIObjectMeta::is_self_link_Set() const{
    return m_self_link_isSet;
}

bool OAIObjectMeta::is_self_link_Valid() const{
    return m_self_link_isValid;
}

QString OAIObjectMeta::getUid() const {
    return m_uid;
}
void OAIObjectMeta::setUid(const QString &uid) {
    m_uid = uid;
    m_uid_isSet = true;
}

bool OAIObjectMeta::is_uid_Set() const{
    return m_uid_isSet;
}

bool OAIObjectMeta::is_uid_Valid() const{
    return m_uid_isValid;
}

bool OAIObjectMeta::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_creation_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_deletion_grace_period_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_deletion_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_finalizers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_generate_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_generation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_namespace_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_owner_references.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_self_link_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uid_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIObjectMeta::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
