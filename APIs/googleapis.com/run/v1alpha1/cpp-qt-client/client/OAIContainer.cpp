/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIContainer.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIContainer::OAIContainer(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIContainer::OAIContainer() {
    this->initializeModel();
}

OAIContainer::~OAIContainer() {}

void OAIContainer::initializeModel() {

    m_args_isSet = false;
    m_args_isValid = false;

    m_command_isSet = false;
    m_command_isValid = false;

    m_env_isSet = false;
    m_env_isValid = false;

    m_env_from_isSet = false;
    m_env_from_isValid = false;

    m_image_isSet = false;
    m_image_isValid = false;

    m_image_pull_policy_isSet = false;
    m_image_pull_policy_isValid = false;

    m_liveness_probe_isSet = false;
    m_liveness_probe_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_ports_isSet = false;
    m_ports_isValid = false;

    m_readiness_probe_isSet = false;
    m_readiness_probe_isValid = false;

    m_resources_isSet = false;
    m_resources_isValid = false;

    m_security_context_isSet = false;
    m_security_context_isValid = false;

    m_startup_probe_isSet = false;
    m_startup_probe_isValid = false;

    m_termination_message_path_isSet = false;
    m_termination_message_path_isValid = false;

    m_termination_message_policy_isSet = false;
    m_termination_message_policy_isValid = false;

    m_volume_mounts_isSet = false;
    m_volume_mounts_isValid = false;

    m_working_dir_isSet = false;
    m_working_dir_isValid = false;
}

void OAIContainer::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIContainer::fromJsonObject(QJsonObject json) {

    m_args_isValid = ::OpenAPI::fromJsonValue(m_args, json[QString("args")]);
    m_args_isSet = !json[QString("args")].isNull() && m_args_isValid;

    m_command_isValid = ::OpenAPI::fromJsonValue(m_command, json[QString("command")]);
    m_command_isSet = !json[QString("command")].isNull() && m_command_isValid;

    m_env_isValid = ::OpenAPI::fromJsonValue(m_env, json[QString("env")]);
    m_env_isSet = !json[QString("env")].isNull() && m_env_isValid;

    m_env_from_isValid = ::OpenAPI::fromJsonValue(m_env_from, json[QString("envFrom")]);
    m_env_from_isSet = !json[QString("envFrom")].isNull() && m_env_from_isValid;

    m_image_isValid = ::OpenAPI::fromJsonValue(m_image, json[QString("image")]);
    m_image_isSet = !json[QString("image")].isNull() && m_image_isValid;

    m_image_pull_policy_isValid = ::OpenAPI::fromJsonValue(m_image_pull_policy, json[QString("imagePullPolicy")]);
    m_image_pull_policy_isSet = !json[QString("imagePullPolicy")].isNull() && m_image_pull_policy_isValid;

    m_liveness_probe_isValid = ::OpenAPI::fromJsonValue(m_liveness_probe, json[QString("livenessProbe")]);
    m_liveness_probe_isSet = !json[QString("livenessProbe")].isNull() && m_liveness_probe_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_ports_isValid = ::OpenAPI::fromJsonValue(m_ports, json[QString("ports")]);
    m_ports_isSet = !json[QString("ports")].isNull() && m_ports_isValid;

    m_readiness_probe_isValid = ::OpenAPI::fromJsonValue(m_readiness_probe, json[QString("readinessProbe")]);
    m_readiness_probe_isSet = !json[QString("readinessProbe")].isNull() && m_readiness_probe_isValid;

    m_resources_isValid = ::OpenAPI::fromJsonValue(m_resources, json[QString("resources")]);
    m_resources_isSet = !json[QString("resources")].isNull() && m_resources_isValid;

    m_security_context_isValid = ::OpenAPI::fromJsonValue(m_security_context, json[QString("securityContext")]);
    m_security_context_isSet = !json[QString("securityContext")].isNull() && m_security_context_isValid;

    m_startup_probe_isValid = ::OpenAPI::fromJsonValue(m_startup_probe, json[QString("startupProbe")]);
    m_startup_probe_isSet = !json[QString("startupProbe")].isNull() && m_startup_probe_isValid;

    m_termination_message_path_isValid = ::OpenAPI::fromJsonValue(m_termination_message_path, json[QString("terminationMessagePath")]);
    m_termination_message_path_isSet = !json[QString("terminationMessagePath")].isNull() && m_termination_message_path_isValid;

    m_termination_message_policy_isValid = ::OpenAPI::fromJsonValue(m_termination_message_policy, json[QString("terminationMessagePolicy")]);
    m_termination_message_policy_isSet = !json[QString("terminationMessagePolicy")].isNull() && m_termination_message_policy_isValid;

    m_volume_mounts_isValid = ::OpenAPI::fromJsonValue(m_volume_mounts, json[QString("volumeMounts")]);
    m_volume_mounts_isSet = !json[QString("volumeMounts")].isNull() && m_volume_mounts_isValid;

    m_working_dir_isValid = ::OpenAPI::fromJsonValue(m_working_dir, json[QString("workingDir")]);
    m_working_dir_isSet = !json[QString("workingDir")].isNull() && m_working_dir_isValid;
}

QString OAIContainer::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIContainer::asJsonObject() const {
    QJsonObject obj;
    if (m_args.size() > 0) {
        obj.insert(QString("args"), ::OpenAPI::toJsonValue(m_args));
    }
    if (m_command.size() > 0) {
        obj.insert(QString("command"), ::OpenAPI::toJsonValue(m_command));
    }
    if (m_env.size() > 0) {
        obj.insert(QString("env"), ::OpenAPI::toJsonValue(m_env));
    }
    if (m_env_from.size() > 0) {
        obj.insert(QString("envFrom"), ::OpenAPI::toJsonValue(m_env_from));
    }
    if (m_image_isSet) {
        obj.insert(QString("image"), ::OpenAPI::toJsonValue(m_image));
    }
    if (m_image_pull_policy_isSet) {
        obj.insert(QString("imagePullPolicy"), ::OpenAPI::toJsonValue(m_image_pull_policy));
    }
    if (m_liveness_probe.isSet()) {
        obj.insert(QString("livenessProbe"), ::OpenAPI::toJsonValue(m_liveness_probe));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_ports.size() > 0) {
        obj.insert(QString("ports"), ::OpenAPI::toJsonValue(m_ports));
    }
    if (m_readiness_probe.isSet()) {
        obj.insert(QString("readinessProbe"), ::OpenAPI::toJsonValue(m_readiness_probe));
    }
    if (m_resources.isSet()) {
        obj.insert(QString("resources"), ::OpenAPI::toJsonValue(m_resources));
    }
    if (m_security_context.isSet()) {
        obj.insert(QString("securityContext"), ::OpenAPI::toJsonValue(m_security_context));
    }
    if (m_startup_probe.isSet()) {
        obj.insert(QString("startupProbe"), ::OpenAPI::toJsonValue(m_startup_probe));
    }
    if (m_termination_message_path_isSet) {
        obj.insert(QString("terminationMessagePath"), ::OpenAPI::toJsonValue(m_termination_message_path));
    }
    if (m_termination_message_policy_isSet) {
        obj.insert(QString("terminationMessagePolicy"), ::OpenAPI::toJsonValue(m_termination_message_policy));
    }
    if (m_volume_mounts.size() > 0) {
        obj.insert(QString("volumeMounts"), ::OpenAPI::toJsonValue(m_volume_mounts));
    }
    if (m_working_dir_isSet) {
        obj.insert(QString("workingDir"), ::OpenAPI::toJsonValue(m_working_dir));
    }
    return obj;
}

QList<QString> OAIContainer::getArgs() const {
    return m_args;
}
void OAIContainer::setArgs(const QList<QString> &args) {
    m_args = args;
    m_args_isSet = true;
}

bool OAIContainer::is_args_Set() const{
    return m_args_isSet;
}

bool OAIContainer::is_args_Valid() const{
    return m_args_isValid;
}

QList<QString> OAIContainer::getCommand() const {
    return m_command;
}
void OAIContainer::setCommand(const QList<QString> &command) {
    m_command = command;
    m_command_isSet = true;
}

bool OAIContainer::is_command_Set() const{
    return m_command_isSet;
}

bool OAIContainer::is_command_Valid() const{
    return m_command_isValid;
}

QList<OAIEnvVar> OAIContainer::getEnv() const {
    return m_env;
}
void OAIContainer::setEnv(const QList<OAIEnvVar> &env) {
    m_env = env;
    m_env_isSet = true;
}

bool OAIContainer::is_env_Set() const{
    return m_env_isSet;
}

bool OAIContainer::is_env_Valid() const{
    return m_env_isValid;
}

QList<OAIEnvFromSource> OAIContainer::getEnvFrom() const {
    return m_env_from;
}
void OAIContainer::setEnvFrom(const QList<OAIEnvFromSource> &env_from) {
    m_env_from = env_from;
    m_env_from_isSet = true;
}

bool OAIContainer::is_env_from_Set() const{
    return m_env_from_isSet;
}

bool OAIContainer::is_env_from_Valid() const{
    return m_env_from_isValid;
}

QString OAIContainer::getImage() const {
    return m_image;
}
void OAIContainer::setImage(const QString &image) {
    m_image = image;
    m_image_isSet = true;
}

bool OAIContainer::is_image_Set() const{
    return m_image_isSet;
}

bool OAIContainer::is_image_Valid() const{
    return m_image_isValid;
}

QString OAIContainer::getImagePullPolicy() const {
    return m_image_pull_policy;
}
void OAIContainer::setImagePullPolicy(const QString &image_pull_policy) {
    m_image_pull_policy = image_pull_policy;
    m_image_pull_policy_isSet = true;
}

bool OAIContainer::is_image_pull_policy_Set() const{
    return m_image_pull_policy_isSet;
}

bool OAIContainer::is_image_pull_policy_Valid() const{
    return m_image_pull_policy_isValid;
}

OAIProbe OAIContainer::getLivenessProbe() const {
    return m_liveness_probe;
}
void OAIContainer::setLivenessProbe(const OAIProbe &liveness_probe) {
    m_liveness_probe = liveness_probe;
    m_liveness_probe_isSet = true;
}

bool OAIContainer::is_liveness_probe_Set() const{
    return m_liveness_probe_isSet;
}

bool OAIContainer::is_liveness_probe_Valid() const{
    return m_liveness_probe_isValid;
}

QString OAIContainer::getName() const {
    return m_name;
}
void OAIContainer::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIContainer::is_name_Set() const{
    return m_name_isSet;
}

bool OAIContainer::is_name_Valid() const{
    return m_name_isValid;
}

QList<OAIContainerPort> OAIContainer::getPorts() const {
    return m_ports;
}
void OAIContainer::setPorts(const QList<OAIContainerPort> &ports) {
    m_ports = ports;
    m_ports_isSet = true;
}

bool OAIContainer::is_ports_Set() const{
    return m_ports_isSet;
}

bool OAIContainer::is_ports_Valid() const{
    return m_ports_isValid;
}

OAIProbe OAIContainer::getReadinessProbe() const {
    return m_readiness_probe;
}
void OAIContainer::setReadinessProbe(const OAIProbe &readiness_probe) {
    m_readiness_probe = readiness_probe;
    m_readiness_probe_isSet = true;
}

bool OAIContainer::is_readiness_probe_Set() const{
    return m_readiness_probe_isSet;
}

bool OAIContainer::is_readiness_probe_Valid() const{
    return m_readiness_probe_isValid;
}

OAIResourceRequirements OAIContainer::getResources() const {
    return m_resources;
}
void OAIContainer::setResources(const OAIResourceRequirements &resources) {
    m_resources = resources;
    m_resources_isSet = true;
}

bool OAIContainer::is_resources_Set() const{
    return m_resources_isSet;
}

bool OAIContainer::is_resources_Valid() const{
    return m_resources_isValid;
}

OAISecurityContext OAIContainer::getSecurityContext() const {
    return m_security_context;
}
void OAIContainer::setSecurityContext(const OAISecurityContext &security_context) {
    m_security_context = security_context;
    m_security_context_isSet = true;
}

bool OAIContainer::is_security_context_Set() const{
    return m_security_context_isSet;
}

bool OAIContainer::is_security_context_Valid() const{
    return m_security_context_isValid;
}

OAIProbe OAIContainer::getStartupProbe() const {
    return m_startup_probe;
}
void OAIContainer::setStartupProbe(const OAIProbe &startup_probe) {
    m_startup_probe = startup_probe;
    m_startup_probe_isSet = true;
}

bool OAIContainer::is_startup_probe_Set() const{
    return m_startup_probe_isSet;
}

bool OAIContainer::is_startup_probe_Valid() const{
    return m_startup_probe_isValid;
}

QString OAIContainer::getTerminationMessagePath() const {
    return m_termination_message_path;
}
void OAIContainer::setTerminationMessagePath(const QString &termination_message_path) {
    m_termination_message_path = termination_message_path;
    m_termination_message_path_isSet = true;
}

bool OAIContainer::is_termination_message_path_Set() const{
    return m_termination_message_path_isSet;
}

bool OAIContainer::is_termination_message_path_Valid() const{
    return m_termination_message_path_isValid;
}

QString OAIContainer::getTerminationMessagePolicy() const {
    return m_termination_message_policy;
}
void OAIContainer::setTerminationMessagePolicy(const QString &termination_message_policy) {
    m_termination_message_policy = termination_message_policy;
    m_termination_message_policy_isSet = true;
}

bool OAIContainer::is_termination_message_policy_Set() const{
    return m_termination_message_policy_isSet;
}

bool OAIContainer::is_termination_message_policy_Valid() const{
    return m_termination_message_policy_isValid;
}

QList<OAIVolumeMount> OAIContainer::getVolumeMounts() const {
    return m_volume_mounts;
}
void OAIContainer::setVolumeMounts(const QList<OAIVolumeMount> &volume_mounts) {
    m_volume_mounts = volume_mounts;
    m_volume_mounts_isSet = true;
}

bool OAIContainer::is_volume_mounts_Set() const{
    return m_volume_mounts_isSet;
}

bool OAIContainer::is_volume_mounts_Valid() const{
    return m_volume_mounts_isValid;
}

QString OAIContainer::getWorkingDir() const {
    return m_working_dir;
}
void OAIContainer::setWorkingDir(const QString &working_dir) {
    m_working_dir = working_dir;
    m_working_dir_isSet = true;
}

bool OAIContainer::is_working_dir_Set() const{
    return m_working_dir_isSet;
}

bool OAIContainer::is_working_dir_Valid() const{
    return m_working_dir_isValid;
}

bool OAIContainer::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_args.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_command.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_env.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_env_from.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_pull_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_liveness_probe.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ports.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_readiness_probe.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resources.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_context.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_startup_probe.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_termination_message_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_termination_message_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_volume_mounts.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_working_dir_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIContainer::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
