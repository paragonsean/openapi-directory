/**
 * Cloud Run Admin API
 * Deploy and manage user provided container images that scale automatically based on incoming requests. The Cloud Run Admin API v1 follows the Knative Serving API specification, while v2 is aligned with Google Cloud AIP-based API standards, as described in https://google.aip.dev/.
 *
 * The version of the OpenAPI document: v1alpha1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIProbe.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIProbe::OAIProbe(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIProbe::OAIProbe() {
    this->initializeModel();
}

OAIProbe::~OAIProbe() {}

void OAIProbe::initializeModel() {

    m_exec_isSet = false;
    m_exec_isValid = false;

    m_failure_threshold_isSet = false;
    m_failure_threshold_isValid = false;

    m_grpc_isSet = false;
    m_grpc_isValid = false;

    m_http_get_isSet = false;
    m_http_get_isValid = false;

    m_initial_delay_seconds_isSet = false;
    m_initial_delay_seconds_isValid = false;

    m_period_seconds_isSet = false;
    m_period_seconds_isValid = false;

    m_success_threshold_isSet = false;
    m_success_threshold_isValid = false;

    m_tcp_socket_isSet = false;
    m_tcp_socket_isValid = false;

    m_timeout_seconds_isSet = false;
    m_timeout_seconds_isValid = false;
}

void OAIProbe::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIProbe::fromJsonObject(QJsonObject json) {

    m_exec_isValid = ::OpenAPI::fromJsonValue(m_exec, json[QString("exec")]);
    m_exec_isSet = !json[QString("exec")].isNull() && m_exec_isValid;

    m_failure_threshold_isValid = ::OpenAPI::fromJsonValue(m_failure_threshold, json[QString("failureThreshold")]);
    m_failure_threshold_isSet = !json[QString("failureThreshold")].isNull() && m_failure_threshold_isValid;

    m_grpc_isValid = ::OpenAPI::fromJsonValue(m_grpc, json[QString("grpc")]);
    m_grpc_isSet = !json[QString("grpc")].isNull() && m_grpc_isValid;

    m_http_get_isValid = ::OpenAPI::fromJsonValue(m_http_get, json[QString("httpGet")]);
    m_http_get_isSet = !json[QString("httpGet")].isNull() && m_http_get_isValid;

    m_initial_delay_seconds_isValid = ::OpenAPI::fromJsonValue(m_initial_delay_seconds, json[QString("initialDelaySeconds")]);
    m_initial_delay_seconds_isSet = !json[QString("initialDelaySeconds")].isNull() && m_initial_delay_seconds_isValid;

    m_period_seconds_isValid = ::OpenAPI::fromJsonValue(m_period_seconds, json[QString("periodSeconds")]);
    m_period_seconds_isSet = !json[QString("periodSeconds")].isNull() && m_period_seconds_isValid;

    m_success_threshold_isValid = ::OpenAPI::fromJsonValue(m_success_threshold, json[QString("successThreshold")]);
    m_success_threshold_isSet = !json[QString("successThreshold")].isNull() && m_success_threshold_isValid;

    m_tcp_socket_isValid = ::OpenAPI::fromJsonValue(m_tcp_socket, json[QString("tcpSocket")]);
    m_tcp_socket_isSet = !json[QString("tcpSocket")].isNull() && m_tcp_socket_isValid;

    m_timeout_seconds_isValid = ::OpenAPI::fromJsonValue(m_timeout_seconds, json[QString("timeoutSeconds")]);
    m_timeout_seconds_isSet = !json[QString("timeoutSeconds")].isNull() && m_timeout_seconds_isValid;
}

QString OAIProbe::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIProbe::asJsonObject() const {
    QJsonObject obj;
    if (m_exec.isSet()) {
        obj.insert(QString("exec"), ::OpenAPI::toJsonValue(m_exec));
    }
    if (m_failure_threshold_isSet) {
        obj.insert(QString("failureThreshold"), ::OpenAPI::toJsonValue(m_failure_threshold));
    }
    if (m_grpc.isSet()) {
        obj.insert(QString("grpc"), ::OpenAPI::toJsonValue(m_grpc));
    }
    if (m_http_get.isSet()) {
        obj.insert(QString("httpGet"), ::OpenAPI::toJsonValue(m_http_get));
    }
    if (m_initial_delay_seconds_isSet) {
        obj.insert(QString("initialDelaySeconds"), ::OpenAPI::toJsonValue(m_initial_delay_seconds));
    }
    if (m_period_seconds_isSet) {
        obj.insert(QString("periodSeconds"), ::OpenAPI::toJsonValue(m_period_seconds));
    }
    if (m_success_threshold_isSet) {
        obj.insert(QString("successThreshold"), ::OpenAPI::toJsonValue(m_success_threshold));
    }
    if (m_tcp_socket.isSet()) {
        obj.insert(QString("tcpSocket"), ::OpenAPI::toJsonValue(m_tcp_socket));
    }
    if (m_timeout_seconds_isSet) {
        obj.insert(QString("timeoutSeconds"), ::OpenAPI::toJsonValue(m_timeout_seconds));
    }
    return obj;
}

OAIExecAction OAIProbe::getExec() const {
    return m_exec;
}
void OAIProbe::setExec(const OAIExecAction &exec) {
    m_exec = exec;
    m_exec_isSet = true;
}

bool OAIProbe::is_exec_Set() const{
    return m_exec_isSet;
}

bool OAIProbe::is_exec_Valid() const{
    return m_exec_isValid;
}

qint32 OAIProbe::getFailureThreshold() const {
    return m_failure_threshold;
}
void OAIProbe::setFailureThreshold(const qint32 &failure_threshold) {
    m_failure_threshold = failure_threshold;
    m_failure_threshold_isSet = true;
}

bool OAIProbe::is_failure_threshold_Set() const{
    return m_failure_threshold_isSet;
}

bool OAIProbe::is_failure_threshold_Valid() const{
    return m_failure_threshold_isValid;
}

OAIGRPCAction OAIProbe::getGrpc() const {
    return m_grpc;
}
void OAIProbe::setGrpc(const OAIGRPCAction &grpc) {
    m_grpc = grpc;
    m_grpc_isSet = true;
}

bool OAIProbe::is_grpc_Set() const{
    return m_grpc_isSet;
}

bool OAIProbe::is_grpc_Valid() const{
    return m_grpc_isValid;
}

OAIHTTPGetAction OAIProbe::getHttpGet() const {
    return m_http_get;
}
void OAIProbe::setHttpGet(const OAIHTTPGetAction &http_get) {
    m_http_get = http_get;
    m_http_get_isSet = true;
}

bool OAIProbe::is_http_get_Set() const{
    return m_http_get_isSet;
}

bool OAIProbe::is_http_get_Valid() const{
    return m_http_get_isValid;
}

qint32 OAIProbe::getInitialDelaySeconds() const {
    return m_initial_delay_seconds;
}
void OAIProbe::setInitialDelaySeconds(const qint32 &initial_delay_seconds) {
    m_initial_delay_seconds = initial_delay_seconds;
    m_initial_delay_seconds_isSet = true;
}

bool OAIProbe::is_initial_delay_seconds_Set() const{
    return m_initial_delay_seconds_isSet;
}

bool OAIProbe::is_initial_delay_seconds_Valid() const{
    return m_initial_delay_seconds_isValid;
}

qint32 OAIProbe::getPeriodSeconds() const {
    return m_period_seconds;
}
void OAIProbe::setPeriodSeconds(const qint32 &period_seconds) {
    m_period_seconds = period_seconds;
    m_period_seconds_isSet = true;
}

bool OAIProbe::is_period_seconds_Set() const{
    return m_period_seconds_isSet;
}

bool OAIProbe::is_period_seconds_Valid() const{
    return m_period_seconds_isValid;
}

qint32 OAIProbe::getSuccessThreshold() const {
    return m_success_threshold;
}
void OAIProbe::setSuccessThreshold(const qint32 &success_threshold) {
    m_success_threshold = success_threshold;
    m_success_threshold_isSet = true;
}

bool OAIProbe::is_success_threshold_Set() const{
    return m_success_threshold_isSet;
}

bool OAIProbe::is_success_threshold_Valid() const{
    return m_success_threshold_isValid;
}

OAITCPSocketAction OAIProbe::getTcpSocket() const {
    return m_tcp_socket;
}
void OAIProbe::setTcpSocket(const OAITCPSocketAction &tcp_socket) {
    m_tcp_socket = tcp_socket;
    m_tcp_socket_isSet = true;
}

bool OAIProbe::is_tcp_socket_Set() const{
    return m_tcp_socket_isSet;
}

bool OAIProbe::is_tcp_socket_Valid() const{
    return m_tcp_socket_isValid;
}

qint32 OAIProbe::getTimeoutSeconds() const {
    return m_timeout_seconds;
}
void OAIProbe::setTimeoutSeconds(const qint32 &timeout_seconds) {
    m_timeout_seconds = timeout_seconds;
    m_timeout_seconds_isSet = true;
}

bool OAIProbe::is_timeout_seconds_Set() const{
    return m_timeout_seconds_isSet;
}

bool OAIProbe::is_timeout_seconds_Valid() const{
    return m_timeout_seconds_isValid;
}

bool OAIProbe::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_exec.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_failure_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_grpc.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_http_get.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_initial_delay_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_success_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tcp_socket.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIProbe::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
