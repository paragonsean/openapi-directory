/*
 * On-Demand Scanning API
 * A service to scan container images for vulnerabilities.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BinarySourceInfo;
import org.openapitools.client.model.FileLocation;
import org.openapitools.client.model.LanguagePackageDependency;
import org.openapitools.client.model.Maintainer;
import org.openapitools.client.model.PackageVersion;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PackageData
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:36.182229-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PackageData {
  public static final String SERIALIZED_NAME_ARCHITECTURE = "architecture";
  @SerializedName(SERIALIZED_NAME_ARCHITECTURE)
  private String architecture;

  public static final String SERIALIZED_NAME_BINARY_SOURCE_INFO = "binarySourceInfo";
  @SerializedName(SERIALIZED_NAME_BINARY_SOURCE_INFO)
  private List<BinarySourceInfo> binarySourceInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_BINARY_VERSION = "binaryVersion";
  @SerializedName(SERIALIZED_NAME_BINARY_VERSION)
  private PackageVersion binaryVersion;

  public static final String SERIALIZED_NAME_CPE_URI = "cpeUri";
  @SerializedName(SERIALIZED_NAME_CPE_URI)
  private String cpeUri;

  public static final String SERIALIZED_NAME_DEPENDENCY_CHAIN = "dependencyChain";
  @SerializedName(SERIALIZED_NAME_DEPENDENCY_CHAIN)
  private List<LanguagePackageDependency> dependencyChain = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILE_LOCATION = "fileLocation";
  @SerializedName(SERIALIZED_NAME_FILE_LOCATION)
  private List<FileLocation> fileLocation = new ArrayList<>();

  public static final String SERIALIZED_NAME_HASH_DIGEST = "hashDigest";
  @SerializedName(SERIALIZED_NAME_HASH_DIGEST)
  private String hashDigest;

  public static final String SERIALIZED_NAME_LICENSES = "licenses";
  @SerializedName(SERIALIZED_NAME_LICENSES)
  private List<String> licenses = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAINTAINER = "maintainer";
  @SerializedName(SERIALIZED_NAME_MAINTAINER)
  private Maintainer maintainer;

  public static final String SERIALIZED_NAME_OS = "os";
  @SerializedName(SERIALIZED_NAME_OS)
  private String os;

  public static final String SERIALIZED_NAME_OS_VERSION = "osVersion";
  @SerializedName(SERIALIZED_NAME_OS_VERSION)
  private String osVersion;

  public static final String SERIALIZED_NAME_PACKAGE = "package";
  @SerializedName(SERIALIZED_NAME_PACKAGE)
  private String _package;

  /**
   * The type of package: os, maven, go, etc.
   */
  @JsonAdapter(PackageTypeEnum.Adapter.class)
  public enum PackageTypeEnum {
    PACKAGE_TYPE_UNSPECIFIED("PACKAGE_TYPE_UNSPECIFIED"),
    
    OS("OS"),
    
    MAVEN("MAVEN"),
    
    GO("GO"),
    
    GO_STDLIB("GO_STDLIB"),
    
    PYPI("PYPI"),
    
    NPM("NPM"),
    
    NUGET("NUGET"),
    
    RUBYGEMS("RUBYGEMS"),
    
    RUST("RUST"),
    
    COMPOSER("COMPOSER");

    private String value;

    PackageTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PackageTypeEnum fromValue(String value) {
      for (PackageTypeEnum b : PackageTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PackageTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PackageTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PackageTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PackageTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PackageTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PACKAGE_TYPE = "packageType";
  @SerializedName(SERIALIZED_NAME_PACKAGE_TYPE)
  private PackageTypeEnum packageType;

  public static final String SERIALIZED_NAME_PATCHED_CVE = "patchedCve";
  @SerializedName(SERIALIZED_NAME_PATCHED_CVE)
  private List<String> patchedCve = new ArrayList<>();

  public static final String SERIALIZED_NAME_SOURCE_VERSION = "sourceVersion";
  @SerializedName(SERIALIZED_NAME_SOURCE_VERSION)
  private PackageVersion sourceVersion;

  public static final String SERIALIZED_NAME_UNUSED = "unused";
  @SerializedName(SERIALIZED_NAME_UNUSED)
  private String unused;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public PackageData() {
  }

  public PackageData architecture(String architecture) {
    this.architecture = architecture;
    return this;
  }

  /**
   * The architecture of the package.
   * @return architecture
   */
  @javax.annotation.Nullable
  public String getArchitecture() {
    return architecture;
  }

  public void setArchitecture(String architecture) {
    this.architecture = architecture;
  }


  public PackageData binarySourceInfo(List<BinarySourceInfo> binarySourceInfo) {
    this.binarySourceInfo = binarySourceInfo;
    return this;
  }

  public PackageData addBinarySourceInfoItem(BinarySourceInfo binarySourceInfoItem) {
    if (this.binarySourceInfo == null) {
      this.binarySourceInfo = new ArrayList<>();
    }
    this.binarySourceInfo.add(binarySourceInfoItem);
    return this;
  }

  /**
   * A bundle containing the binary and source information.
   * @return binarySourceInfo
   */
  @javax.annotation.Nullable
  public List<BinarySourceInfo> getBinarySourceInfo() {
    return binarySourceInfo;
  }

  public void setBinarySourceInfo(List<BinarySourceInfo> binarySourceInfo) {
    this.binarySourceInfo = binarySourceInfo;
  }


  public PackageData binaryVersion(PackageVersion binaryVersion) {
    this.binaryVersion = binaryVersion;
    return this;
  }

  /**
   * Get binaryVersion
   * @return binaryVersion
   */
  @javax.annotation.Nullable
  public PackageVersion getBinaryVersion() {
    return binaryVersion;
  }

  public void setBinaryVersion(PackageVersion binaryVersion) {
    this.binaryVersion = binaryVersion;
  }


  public PackageData cpeUri(String cpeUri) {
    this.cpeUri = cpeUri;
    return this;
  }

  /**
   * The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which the vulnerability may manifest. Examples include distro or storage location for vulnerable jar.
   * @return cpeUri
   */
  @javax.annotation.Nullable
  public String getCpeUri() {
    return cpeUri;
  }

  public void setCpeUri(String cpeUri) {
    this.cpeUri = cpeUri;
  }


  public PackageData dependencyChain(List<LanguagePackageDependency> dependencyChain) {
    this.dependencyChain = dependencyChain;
    return this;
  }

  public PackageData addDependencyChainItem(LanguagePackageDependency dependencyChainItem) {
    if (this.dependencyChain == null) {
      this.dependencyChain = new ArrayList<>();
    }
    this.dependencyChain.add(dependencyChainItem);
    return this;
  }

  /**
   * The dependency chain between this package and the user&#39;s artifact. List in order from the customer&#39;s package under review first, to the current package last. Inclusive of the original package and the current package.
   * @return dependencyChain
   */
  @javax.annotation.Nullable
  public List<LanguagePackageDependency> getDependencyChain() {
    return dependencyChain;
  }

  public void setDependencyChain(List<LanguagePackageDependency> dependencyChain) {
    this.dependencyChain = dependencyChain;
  }


  public PackageData fileLocation(List<FileLocation> fileLocation) {
    this.fileLocation = fileLocation;
    return this;
  }

  public PackageData addFileLocationItem(FileLocation fileLocationItem) {
    if (this.fileLocation == null) {
      this.fileLocation = new ArrayList<>();
    }
    this.fileLocation.add(fileLocationItem);
    return this;
  }

  /**
   * The path to the jar file / go binary file.
   * @return fileLocation
   */
  @javax.annotation.Nullable
  public List<FileLocation> getFileLocation() {
    return fileLocation;
  }

  public void setFileLocation(List<FileLocation> fileLocation) {
    this.fileLocation = fileLocation;
  }


  public PackageData hashDigest(String hashDigest) {
    this.hashDigest = hashDigest;
    return this;
  }

  /**
   * HashDigest stores the SHA512 hash digest of the jar file if the package is of type Maven. This field will be unset for non Maven packages.
   * @return hashDigest
   */
  @javax.annotation.Nullable
  public String getHashDigest() {
    return hashDigest;
  }

  public void setHashDigest(String hashDigest) {
    this.hashDigest = hashDigest;
  }


  public PackageData licenses(List<String> licenses) {
    this.licenses = licenses;
    return this;
  }

  public PackageData addLicensesItem(String licensesItem) {
    if (this.licenses == null) {
      this.licenses = new ArrayList<>();
    }
    this.licenses.add(licensesItem);
    return this;
  }

  /**
   * The list of licenses found that are related to a given package. Note that licenses may also be stored on the BinarySourceInfo. If there is no BinarySourceInfo (because there&#39;s no concept of source vs binary), then it will be stored here, while if there are BinarySourceInfos, it will be stored there, as one source can have multiple binaries with different licenses.
   * @return licenses
   */
  @javax.annotation.Nullable
  public List<String> getLicenses() {
    return licenses;
  }

  public void setLicenses(List<String> licenses) {
    this.licenses = licenses;
  }


  public PackageData maintainer(Maintainer maintainer) {
    this.maintainer = maintainer;
    return this;
  }

  /**
   * Get maintainer
   * @return maintainer
   */
  @javax.annotation.Nullable
  public Maintainer getMaintainer() {
    return maintainer;
  }

  public void setMaintainer(Maintainer maintainer) {
    this.maintainer = maintainer;
  }


  public PackageData os(String os) {
    this.os = os;
    return this;
  }

  /**
   * The OS affected by a vulnerability Used to generate the cpe_uri for OS packages
   * @return os
   */
  @javax.annotation.Nullable
  public String getOs() {
    return os;
  }

  public void setOs(String os) {
    this.os = os;
  }


  public PackageData osVersion(String osVersion) {
    this.osVersion = osVersion;
    return this;
  }

  /**
   * The version of the OS Used to generate the cpe_uri for OS packages
   * @return osVersion
   */
  @javax.annotation.Nullable
  public String getOsVersion() {
    return osVersion;
  }

  public void setOsVersion(String osVersion) {
    this.osVersion = osVersion;
  }


  public PackageData _package(String _package) {
    this._package = _package;
    return this;
  }

  /**
   * The package being analysed for vulnerabilities
   * @return _package
   */
  @javax.annotation.Nullable
  public String getPackage() {
    return _package;
  }

  public void setPackage(String _package) {
    this._package = _package;
  }


  public PackageData packageType(PackageTypeEnum packageType) {
    this.packageType = packageType;
    return this;
  }

  /**
   * The type of package: os, maven, go, etc.
   * @return packageType
   */
  @javax.annotation.Nullable
  public PackageTypeEnum getPackageType() {
    return packageType;
  }

  public void setPackageType(PackageTypeEnum packageType) {
    this.packageType = packageType;
  }


  public PackageData patchedCve(List<String> patchedCve) {
    this.patchedCve = patchedCve;
    return this;
  }

  public PackageData addPatchedCveItem(String patchedCveItem) {
    if (this.patchedCve == null) {
      this.patchedCve = new ArrayList<>();
    }
    this.patchedCve.add(patchedCveItem);
    return this;
  }

  /**
   * CVEs that this package is no longer vulnerable to go/drydock-dd-custom-binary-scanning
   * @return patchedCve
   */
  @javax.annotation.Nullable
  public List<String> getPatchedCve() {
    return patchedCve;
  }

  public void setPatchedCve(List<String> patchedCve) {
    this.patchedCve = patchedCve;
  }


  public PackageData sourceVersion(PackageVersion sourceVersion) {
    this.sourceVersion = sourceVersion;
    return this;
  }

  /**
   * Get sourceVersion
   * @return sourceVersion
   */
  @javax.annotation.Nullable
  public PackageVersion getSourceVersion() {
    return sourceVersion;
  }

  public void setSourceVersion(PackageVersion sourceVersion) {
    this.sourceVersion = sourceVersion;
  }


  public PackageData unused(String unused) {
    this.unused = unused;
    return this;
  }

  /**
   * Get unused
   * @return unused
   */
  @javax.annotation.Nullable
  public String getUnused() {
    return unused;
  }

  public void setUnused(String unused) {
    this.unused = unused;
  }


  public PackageData version(String version) {
    this.version = version;
    return this;
  }

  /**
   * The version of the package being analysed
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PackageData packageData = (PackageData) o;
    return Objects.equals(this.architecture, packageData.architecture) &&
        Objects.equals(this.binarySourceInfo, packageData.binarySourceInfo) &&
        Objects.equals(this.binaryVersion, packageData.binaryVersion) &&
        Objects.equals(this.cpeUri, packageData.cpeUri) &&
        Objects.equals(this.dependencyChain, packageData.dependencyChain) &&
        Objects.equals(this.fileLocation, packageData.fileLocation) &&
        Objects.equals(this.hashDigest, packageData.hashDigest) &&
        Objects.equals(this.licenses, packageData.licenses) &&
        Objects.equals(this.maintainer, packageData.maintainer) &&
        Objects.equals(this.os, packageData.os) &&
        Objects.equals(this.osVersion, packageData.osVersion) &&
        Objects.equals(this._package, packageData._package) &&
        Objects.equals(this.packageType, packageData.packageType) &&
        Objects.equals(this.patchedCve, packageData.patchedCve) &&
        Objects.equals(this.sourceVersion, packageData.sourceVersion) &&
        Objects.equals(this.unused, packageData.unused) &&
        Objects.equals(this.version, packageData.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(architecture, binarySourceInfo, binaryVersion, cpeUri, dependencyChain, fileLocation, hashDigest, licenses, maintainer, os, osVersion, _package, packageType, patchedCve, sourceVersion, unused, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PackageData {\n");
    sb.append("    architecture: ").append(toIndentedString(architecture)).append("\n");
    sb.append("    binarySourceInfo: ").append(toIndentedString(binarySourceInfo)).append("\n");
    sb.append("    binaryVersion: ").append(toIndentedString(binaryVersion)).append("\n");
    sb.append("    cpeUri: ").append(toIndentedString(cpeUri)).append("\n");
    sb.append("    dependencyChain: ").append(toIndentedString(dependencyChain)).append("\n");
    sb.append("    fileLocation: ").append(toIndentedString(fileLocation)).append("\n");
    sb.append("    hashDigest: ").append(toIndentedString(hashDigest)).append("\n");
    sb.append("    licenses: ").append(toIndentedString(licenses)).append("\n");
    sb.append("    maintainer: ").append(toIndentedString(maintainer)).append("\n");
    sb.append("    os: ").append(toIndentedString(os)).append("\n");
    sb.append("    osVersion: ").append(toIndentedString(osVersion)).append("\n");
    sb.append("    _package: ").append(toIndentedString(_package)).append("\n");
    sb.append("    packageType: ").append(toIndentedString(packageType)).append("\n");
    sb.append("    patchedCve: ").append(toIndentedString(patchedCve)).append("\n");
    sb.append("    sourceVersion: ").append(toIndentedString(sourceVersion)).append("\n");
    sb.append("    unused: ").append(toIndentedString(unused)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("architecture");
    openapiFields.add("binarySourceInfo");
    openapiFields.add("binaryVersion");
    openapiFields.add("cpeUri");
    openapiFields.add("dependencyChain");
    openapiFields.add("fileLocation");
    openapiFields.add("hashDigest");
    openapiFields.add("licenses");
    openapiFields.add("maintainer");
    openapiFields.add("os");
    openapiFields.add("osVersion");
    openapiFields.add("package");
    openapiFields.add("packageType");
    openapiFields.add("patchedCve");
    openapiFields.add("sourceVersion");
    openapiFields.add("unused");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PackageData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PackageData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PackageData is not found in the empty JSON string", PackageData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PackageData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PackageData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("architecture") != null && !jsonObj.get("architecture").isJsonNull()) && !jsonObj.get("architecture").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `architecture` to be a primitive type in the JSON string but got `%s`", jsonObj.get("architecture").toString()));
      }
      if (jsonObj.get("binarySourceInfo") != null && !jsonObj.get("binarySourceInfo").isJsonNull()) {
        JsonArray jsonArraybinarySourceInfo = jsonObj.getAsJsonArray("binarySourceInfo");
        if (jsonArraybinarySourceInfo != null) {
          // ensure the json data is an array
          if (!jsonObj.get("binarySourceInfo").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `binarySourceInfo` to be an array in the JSON string but got `%s`", jsonObj.get("binarySourceInfo").toString()));
          }

          // validate the optional field `binarySourceInfo` (array)
          for (int i = 0; i < jsonArraybinarySourceInfo.size(); i++) {
            BinarySourceInfo.validateJsonElement(jsonArraybinarySourceInfo.get(i));
          };
        }
      }
      // validate the optional field `binaryVersion`
      if (jsonObj.get("binaryVersion") != null && !jsonObj.get("binaryVersion").isJsonNull()) {
        PackageVersion.validateJsonElement(jsonObj.get("binaryVersion"));
      }
      if ((jsonObj.get("cpeUri") != null && !jsonObj.get("cpeUri").isJsonNull()) && !jsonObj.get("cpeUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpeUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpeUri").toString()));
      }
      if (jsonObj.get("dependencyChain") != null && !jsonObj.get("dependencyChain").isJsonNull()) {
        JsonArray jsonArraydependencyChain = jsonObj.getAsJsonArray("dependencyChain");
        if (jsonArraydependencyChain != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dependencyChain").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dependencyChain` to be an array in the JSON string but got `%s`", jsonObj.get("dependencyChain").toString()));
          }

          // validate the optional field `dependencyChain` (array)
          for (int i = 0; i < jsonArraydependencyChain.size(); i++) {
            LanguagePackageDependency.validateJsonElement(jsonArraydependencyChain.get(i));
          };
        }
      }
      if (jsonObj.get("fileLocation") != null && !jsonObj.get("fileLocation").isJsonNull()) {
        JsonArray jsonArrayfileLocation = jsonObj.getAsJsonArray("fileLocation");
        if (jsonArrayfileLocation != null) {
          // ensure the json data is an array
          if (!jsonObj.get("fileLocation").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `fileLocation` to be an array in the JSON string but got `%s`", jsonObj.get("fileLocation").toString()));
          }

          // validate the optional field `fileLocation` (array)
          for (int i = 0; i < jsonArrayfileLocation.size(); i++) {
            FileLocation.validateJsonElement(jsonArrayfileLocation.get(i));
          };
        }
      }
      if ((jsonObj.get("hashDigest") != null && !jsonObj.get("hashDigest").isJsonNull()) && !jsonObj.get("hashDigest").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hashDigest` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hashDigest").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("licenses") != null && !jsonObj.get("licenses").isJsonNull() && !jsonObj.get("licenses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenses` to be an array in the JSON string but got `%s`", jsonObj.get("licenses").toString()));
      }
      // validate the optional field `maintainer`
      if (jsonObj.get("maintainer") != null && !jsonObj.get("maintainer").isJsonNull()) {
        Maintainer.validateJsonElement(jsonObj.get("maintainer"));
      }
      if ((jsonObj.get("os") != null && !jsonObj.get("os").isJsonNull()) && !jsonObj.get("os").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `os` to be a primitive type in the JSON string but got `%s`", jsonObj.get("os").toString()));
      }
      if ((jsonObj.get("osVersion") != null && !jsonObj.get("osVersion").isJsonNull()) && !jsonObj.get("osVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `osVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("osVersion").toString()));
      }
      if ((jsonObj.get("package") != null && !jsonObj.get("package").isJsonNull()) && !jsonObj.get("package").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `package` to be a primitive type in the JSON string but got `%s`", jsonObj.get("package").toString()));
      }
      if ((jsonObj.get("packageType") != null && !jsonObj.get("packageType").isJsonNull()) && !jsonObj.get("packageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `packageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("packageType").toString()));
      }
      // validate the optional field `packageType`
      if (jsonObj.get("packageType") != null && !jsonObj.get("packageType").isJsonNull()) {
        PackageTypeEnum.validateJsonElement(jsonObj.get("packageType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("patchedCve") != null && !jsonObj.get("patchedCve").isJsonNull() && !jsonObj.get("patchedCve").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `patchedCve` to be an array in the JSON string but got `%s`", jsonObj.get("patchedCve").toString()));
      }
      // validate the optional field `sourceVersion`
      if (jsonObj.get("sourceVersion") != null && !jsonObj.get("sourceVersion").isJsonNull()) {
        PackageVersion.validateJsonElement(jsonObj.get("sourceVersion"));
      }
      if ((jsonObj.get("unused") != null && !jsonObj.get("unused").isJsonNull()) && !jsonObj.get("unused").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unused` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unused").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PackageData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PackageData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PackageData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PackageData.class));

       return (TypeAdapter<T>) new TypeAdapter<PackageData>() {
           @Override
           public void write(JsonWriter out, PackageData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PackageData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PackageData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PackageData
   * @throws IOException if the JSON string is invalid with respect to PackageData
   */
  public static PackageData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PackageData.class);
  }

  /**
   * Convert an instance of PackageData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

