/*
 * On-Demand Scanning API
 * A service to scan container images for vulnerabilities.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Steps taken to build the artifact. For a TaskRun, typically each container corresponds to one step in the recipe.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:31.988614-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Recipe {
  public static final String SERIALIZED_NAME_ARGUMENTS = "arguments";
  @SerializedName(SERIALIZED_NAME_ARGUMENTS)
  private List<Map<String, Object>> arguments = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEFINED_IN_MATERIAL = "definedInMaterial";
  @SerializedName(SERIALIZED_NAME_DEFINED_IN_MATERIAL)
  private String definedInMaterial;

  public static final String SERIALIZED_NAME_ENTRY_POINT = "entryPoint";
  @SerializedName(SERIALIZED_NAME_ENTRY_POINT)
  private String entryPoint;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private List<Map<String, Object>> environment = new ArrayList<>();

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public Recipe() {
  }

  public Recipe arguments(List<Map<String, Object>> arguments) {
    this.arguments = arguments;
    return this;
  }

  public Recipe addArgumentsItem(Map<String, Object> argumentsItem) {
    if (this.arguments == null) {
      this.arguments = new ArrayList<>();
    }
    this.arguments.add(argumentsItem);
    return this;
  }

  /**
   * Collection of all external inputs that influenced the build on top of recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe type were \&quot;make\&quot;, then this might be the flags passed to make aside from the target, which is captured in recipe.entryPoint. Since the arguments field can greatly vary in structure, depending on the builder and recipe type, this is of form \&quot;Any\&quot;.
   * @return arguments
   */
  @javax.annotation.Nullable
  public List<Map<String, Object>> getArguments() {
    return arguments;
  }

  public void setArguments(List<Map<String, Object>> arguments) {
    this.arguments = arguments;
  }


  public Recipe definedInMaterial(String definedInMaterial) {
    this.definedInMaterial = definedInMaterial;
    return this;
  }

  /**
   * Index in materials containing the recipe steps that are not implied by recipe.type. For example, if the recipe type were \&quot;make\&quot;, then this would point to the source containing the Makefile, not the make program itself. Set to -1 if the recipe doesn&#39;t come from a material, as zero is default unset value for int64.
   * @return definedInMaterial
   */
  @javax.annotation.Nullable
  public String getDefinedInMaterial() {
    return definedInMaterial;
  }

  public void setDefinedInMaterial(String definedInMaterial) {
    this.definedInMaterial = definedInMaterial;
  }


  public Recipe entryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
    return this;
  }

  /**
   * String identifying the entry point into the build. This is often a path to a configuration file and/or a target label within that file. The syntax and meaning are defined by recipe.type. For example, if the recipe type were \&quot;make\&quot;, then this would reference the directory in which to run make as well as which target to use.
   * @return entryPoint
   */
  @javax.annotation.Nullable
  public String getEntryPoint() {
    return entryPoint;
  }

  public void setEntryPoint(String entryPoint) {
    this.entryPoint = entryPoint;
  }


  public Recipe environment(List<Map<String, Object>> environment) {
    this.environment = environment;
    return this;
  }

  public Recipe addEnvironmentItem(Map<String, Object> environmentItem) {
    if (this.environment == null) {
      this.environment = new ArrayList<>();
    }
    this.environment.add(environmentItem);
    return this;
  }

  /**
   * Any other builder-controlled inputs necessary for correctly evaluating the recipe. Usually only needed for reproducing the build but not evaluated as part of policy. Since the environment field can greatly vary in structure, depending on the builder and recipe type, this is of form \&quot;Any\&quot;.
   * @return environment
   */
  @javax.annotation.Nullable
  public List<Map<String, Object>> getEnvironment() {
    return environment;
  }

  public void setEnvironment(List<Map<String, Object>> environment) {
    this.environment = environment;
  }


  public Recipe type(String type) {
    this.type = type;
    return this;
  }

  /**
   * URI indicating what type of recipe was performed. It determines the meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Recipe recipe = (Recipe) o;
    return Objects.equals(this.arguments, recipe.arguments) &&
        Objects.equals(this.definedInMaterial, recipe.definedInMaterial) &&
        Objects.equals(this.entryPoint, recipe.entryPoint) &&
        Objects.equals(this.environment, recipe.environment) &&
        Objects.equals(this.type, recipe.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arguments, definedInMaterial, entryPoint, environment, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Recipe {\n");
    sb.append("    arguments: ").append(toIndentedString(arguments)).append("\n");
    sb.append("    definedInMaterial: ").append(toIndentedString(definedInMaterial)).append("\n");
    sb.append("    entryPoint: ").append(toIndentedString(entryPoint)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("arguments");
    openapiFields.add("definedInMaterial");
    openapiFields.add("entryPoint");
    openapiFields.add("environment");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Recipe
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Recipe.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Recipe is not found in the empty JSON string", Recipe.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Recipe.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Recipe` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("arguments") != null && !jsonObj.get("arguments").isJsonNull() && !jsonObj.get("arguments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `arguments` to be an array in the JSON string but got `%s`", jsonObj.get("arguments").toString()));
      }
      if ((jsonObj.get("definedInMaterial") != null && !jsonObj.get("definedInMaterial").isJsonNull()) && !jsonObj.get("definedInMaterial").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definedInMaterial` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definedInMaterial").toString()));
      }
      if ((jsonObj.get("entryPoint") != null && !jsonObj.get("entryPoint").isJsonNull()) && !jsonObj.get("entryPoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entryPoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entryPoint").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull() && !jsonObj.get("environment").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `environment` to be an array in the JSON string but got `%s`", jsonObj.get("environment").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Recipe.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Recipe' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Recipe> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Recipe.class));

       return (TypeAdapter<T>) new TypeAdapter<Recipe>() {
           @Override
           public void write(JsonWriter out, Recipe value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Recipe read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Recipe given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Recipe
   * @throws IOException if the JSON string is invalid with respect to Recipe
   */
  public static Recipe fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Recipe.class);
  }

  /**
   * Convert an instance of Recipe to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

