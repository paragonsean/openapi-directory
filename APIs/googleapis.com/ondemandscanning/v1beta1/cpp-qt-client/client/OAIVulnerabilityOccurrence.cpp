/**
 * On-Demand Scanning API
 * A service to scan container images for vulnerabilities.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVulnerabilityOccurrence.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVulnerabilityOccurrence::OAIVulnerabilityOccurrence(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVulnerabilityOccurrence::OAIVulnerabilityOccurrence() {
    this->initializeModel();
}

OAIVulnerabilityOccurrence::~OAIVulnerabilityOccurrence() {}

void OAIVulnerabilityOccurrence::initializeModel() {

    m_cvss_score_isSet = false;
    m_cvss_score_isValid = false;

    m_cvss_v2_isSet = false;
    m_cvss_v2_isValid = false;

    m_cvss_version_isSet = false;
    m_cvss_version_isValid = false;

    m_cvssv3_isSet = false;
    m_cvssv3_isValid = false;

    m_effective_severity_isSet = false;
    m_effective_severity_isValid = false;

    m_extra_details_isSet = false;
    m_extra_details_isValid = false;

    m_fix_available_isSet = false;
    m_fix_available_isValid = false;

    m_long_description_isSet = false;
    m_long_description_isValid = false;

    m_package_issue_isSet = false;
    m_package_issue_isValid = false;

    m_related_urls_isSet = false;
    m_related_urls_isValid = false;

    m_severity_isSet = false;
    m_severity_isValid = false;

    m_short_description_isSet = false;
    m_short_description_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_vex_assessment_isSet = false;
    m_vex_assessment_isValid = false;
}

void OAIVulnerabilityOccurrence::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVulnerabilityOccurrence::fromJsonObject(QJsonObject json) {

    m_cvss_score_isValid = ::OpenAPI::fromJsonValue(m_cvss_score, json[QString("cvssScore")]);
    m_cvss_score_isSet = !json[QString("cvssScore")].isNull() && m_cvss_score_isValid;

    m_cvss_v2_isValid = ::OpenAPI::fromJsonValue(m_cvss_v2, json[QString("cvssV2")]);
    m_cvss_v2_isSet = !json[QString("cvssV2")].isNull() && m_cvss_v2_isValid;

    m_cvss_version_isValid = ::OpenAPI::fromJsonValue(m_cvss_version, json[QString("cvssVersion")]);
    m_cvss_version_isSet = !json[QString("cvssVersion")].isNull() && m_cvss_version_isValid;

    m_cvssv3_isValid = ::OpenAPI::fromJsonValue(m_cvssv3, json[QString("cvssv3")]);
    m_cvssv3_isSet = !json[QString("cvssv3")].isNull() && m_cvssv3_isValid;

    m_effective_severity_isValid = ::OpenAPI::fromJsonValue(m_effective_severity, json[QString("effectiveSeverity")]);
    m_effective_severity_isSet = !json[QString("effectiveSeverity")].isNull() && m_effective_severity_isValid;

    m_extra_details_isValid = ::OpenAPI::fromJsonValue(m_extra_details, json[QString("extraDetails")]);
    m_extra_details_isSet = !json[QString("extraDetails")].isNull() && m_extra_details_isValid;

    m_fix_available_isValid = ::OpenAPI::fromJsonValue(m_fix_available, json[QString("fixAvailable")]);
    m_fix_available_isSet = !json[QString("fixAvailable")].isNull() && m_fix_available_isValid;

    m_long_description_isValid = ::OpenAPI::fromJsonValue(m_long_description, json[QString("longDescription")]);
    m_long_description_isSet = !json[QString("longDescription")].isNull() && m_long_description_isValid;

    m_package_issue_isValid = ::OpenAPI::fromJsonValue(m_package_issue, json[QString("packageIssue")]);
    m_package_issue_isSet = !json[QString("packageIssue")].isNull() && m_package_issue_isValid;

    m_related_urls_isValid = ::OpenAPI::fromJsonValue(m_related_urls, json[QString("relatedUrls")]);
    m_related_urls_isSet = !json[QString("relatedUrls")].isNull() && m_related_urls_isValid;

    m_severity_isValid = ::OpenAPI::fromJsonValue(m_severity, json[QString("severity")]);
    m_severity_isSet = !json[QString("severity")].isNull() && m_severity_isValid;

    m_short_description_isValid = ::OpenAPI::fromJsonValue(m_short_description, json[QString("shortDescription")]);
    m_short_description_isSet = !json[QString("shortDescription")].isNull() && m_short_description_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_vex_assessment_isValid = ::OpenAPI::fromJsonValue(m_vex_assessment, json[QString("vexAssessment")]);
    m_vex_assessment_isSet = !json[QString("vexAssessment")].isNull() && m_vex_assessment_isValid;
}

QString OAIVulnerabilityOccurrence::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVulnerabilityOccurrence::asJsonObject() const {
    QJsonObject obj;
    if (m_cvss_score_isSet) {
        obj.insert(QString("cvssScore"), ::OpenAPI::toJsonValue(m_cvss_score));
    }
    if (m_cvss_v2.isSet()) {
        obj.insert(QString("cvssV2"), ::OpenAPI::toJsonValue(m_cvss_v2));
    }
    if (m_cvss_version_isSet) {
        obj.insert(QString("cvssVersion"), ::OpenAPI::toJsonValue(m_cvss_version));
    }
    if (m_cvssv3.isSet()) {
        obj.insert(QString("cvssv3"), ::OpenAPI::toJsonValue(m_cvssv3));
    }
    if (m_effective_severity_isSet) {
        obj.insert(QString("effectiveSeverity"), ::OpenAPI::toJsonValue(m_effective_severity));
    }
    if (m_extra_details_isSet) {
        obj.insert(QString("extraDetails"), ::OpenAPI::toJsonValue(m_extra_details));
    }
    if (m_fix_available_isSet) {
        obj.insert(QString("fixAvailable"), ::OpenAPI::toJsonValue(m_fix_available));
    }
    if (m_long_description_isSet) {
        obj.insert(QString("longDescription"), ::OpenAPI::toJsonValue(m_long_description));
    }
    if (m_package_issue.size() > 0) {
        obj.insert(QString("packageIssue"), ::OpenAPI::toJsonValue(m_package_issue));
    }
    if (m_related_urls.size() > 0) {
        obj.insert(QString("relatedUrls"), ::OpenAPI::toJsonValue(m_related_urls));
    }
    if (m_severity_isSet) {
        obj.insert(QString("severity"), ::OpenAPI::toJsonValue(m_severity));
    }
    if (m_short_description_isSet) {
        obj.insert(QString("shortDescription"), ::OpenAPI::toJsonValue(m_short_description));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_vex_assessment.isSet()) {
        obj.insert(QString("vexAssessment"), ::OpenAPI::toJsonValue(m_vex_assessment));
    }
    return obj;
}

float OAIVulnerabilityOccurrence::getCvssScore() const {
    return m_cvss_score;
}
void OAIVulnerabilityOccurrence::setCvssScore(const float &cvss_score) {
    m_cvss_score = cvss_score;
    m_cvss_score_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_cvss_score_Set() const{
    return m_cvss_score_isSet;
}

bool OAIVulnerabilityOccurrence::is_cvss_score_Valid() const{
    return m_cvss_score_isValid;
}

OAICVSS OAIVulnerabilityOccurrence::getCvssV2() const {
    return m_cvss_v2;
}
void OAIVulnerabilityOccurrence::setCvssV2(const OAICVSS &cvss_v2) {
    m_cvss_v2 = cvss_v2;
    m_cvss_v2_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_cvss_v2_Set() const{
    return m_cvss_v2_isSet;
}

bool OAIVulnerabilityOccurrence::is_cvss_v2_Valid() const{
    return m_cvss_v2_isValid;
}

QString OAIVulnerabilityOccurrence::getCvssVersion() const {
    return m_cvss_version;
}
void OAIVulnerabilityOccurrence::setCvssVersion(const QString &cvss_version) {
    m_cvss_version = cvss_version;
    m_cvss_version_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_cvss_version_Set() const{
    return m_cvss_version_isSet;
}

bool OAIVulnerabilityOccurrence::is_cvss_version_Valid() const{
    return m_cvss_version_isValid;
}

OAICVSS OAIVulnerabilityOccurrence::getCvssv3() const {
    return m_cvssv3;
}
void OAIVulnerabilityOccurrence::setCvssv3(const OAICVSS &cvssv3) {
    m_cvssv3 = cvssv3;
    m_cvssv3_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_cvssv3_Set() const{
    return m_cvssv3_isSet;
}

bool OAIVulnerabilityOccurrence::is_cvssv3_Valid() const{
    return m_cvssv3_isValid;
}

QString OAIVulnerabilityOccurrence::getEffectiveSeverity() const {
    return m_effective_severity;
}
void OAIVulnerabilityOccurrence::setEffectiveSeverity(const QString &effective_severity) {
    m_effective_severity = effective_severity;
    m_effective_severity_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_effective_severity_Set() const{
    return m_effective_severity_isSet;
}

bool OAIVulnerabilityOccurrence::is_effective_severity_Valid() const{
    return m_effective_severity_isValid;
}

QString OAIVulnerabilityOccurrence::getExtraDetails() const {
    return m_extra_details;
}
void OAIVulnerabilityOccurrence::setExtraDetails(const QString &extra_details) {
    m_extra_details = extra_details;
    m_extra_details_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_extra_details_Set() const{
    return m_extra_details_isSet;
}

bool OAIVulnerabilityOccurrence::is_extra_details_Valid() const{
    return m_extra_details_isValid;
}

bool OAIVulnerabilityOccurrence::isFixAvailable() const {
    return m_fix_available;
}
void OAIVulnerabilityOccurrence::setFixAvailable(const bool &fix_available) {
    m_fix_available = fix_available;
    m_fix_available_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_fix_available_Set() const{
    return m_fix_available_isSet;
}

bool OAIVulnerabilityOccurrence::is_fix_available_Valid() const{
    return m_fix_available_isValid;
}

QString OAIVulnerabilityOccurrence::getLongDescription() const {
    return m_long_description;
}
void OAIVulnerabilityOccurrence::setLongDescription(const QString &long_description) {
    m_long_description = long_description;
    m_long_description_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_long_description_Set() const{
    return m_long_description_isSet;
}

bool OAIVulnerabilityOccurrence::is_long_description_Valid() const{
    return m_long_description_isValid;
}

QList<OAIPackageIssue> OAIVulnerabilityOccurrence::getPackageIssue() const {
    return m_package_issue;
}
void OAIVulnerabilityOccurrence::setPackageIssue(const QList<OAIPackageIssue> &package_issue) {
    m_package_issue = package_issue;
    m_package_issue_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_package_issue_Set() const{
    return m_package_issue_isSet;
}

bool OAIVulnerabilityOccurrence::is_package_issue_Valid() const{
    return m_package_issue_isValid;
}

QList<OAIRelatedUrl> OAIVulnerabilityOccurrence::getRelatedUrls() const {
    return m_related_urls;
}
void OAIVulnerabilityOccurrence::setRelatedUrls(const QList<OAIRelatedUrl> &related_urls) {
    m_related_urls = related_urls;
    m_related_urls_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_related_urls_Set() const{
    return m_related_urls_isSet;
}

bool OAIVulnerabilityOccurrence::is_related_urls_Valid() const{
    return m_related_urls_isValid;
}

QString OAIVulnerabilityOccurrence::getSeverity() const {
    return m_severity;
}
void OAIVulnerabilityOccurrence::setSeverity(const QString &severity) {
    m_severity = severity;
    m_severity_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_severity_Set() const{
    return m_severity_isSet;
}

bool OAIVulnerabilityOccurrence::is_severity_Valid() const{
    return m_severity_isValid;
}

QString OAIVulnerabilityOccurrence::getShortDescription() const {
    return m_short_description;
}
void OAIVulnerabilityOccurrence::setShortDescription(const QString &short_description) {
    m_short_description = short_description;
    m_short_description_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_short_description_Set() const{
    return m_short_description_isSet;
}

bool OAIVulnerabilityOccurrence::is_short_description_Valid() const{
    return m_short_description_isValid;
}

QString OAIVulnerabilityOccurrence::getType() const {
    return m_type;
}
void OAIVulnerabilityOccurrence::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_type_Set() const{
    return m_type_isSet;
}

bool OAIVulnerabilityOccurrence::is_type_Valid() const{
    return m_type_isValid;
}

OAIVexAssessment OAIVulnerabilityOccurrence::getVexAssessment() const {
    return m_vex_assessment;
}
void OAIVulnerabilityOccurrence::setVexAssessment(const OAIVexAssessment &vex_assessment) {
    m_vex_assessment = vex_assessment;
    m_vex_assessment_isSet = true;
}

bool OAIVulnerabilityOccurrence::is_vex_assessment_Set() const{
    return m_vex_assessment_isSet;
}

bool OAIVulnerabilityOccurrence::is_vex_assessment_Valid() const{
    return m_vex_assessment_isValid;
}

bool OAIVulnerabilityOccurrence::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cvss_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_v2.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvss_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cvssv3.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_effective_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_extra_details_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fix_available_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_long_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_issue.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_related_urls.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_short_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vex_assessment.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVulnerabilityOccurrence::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
