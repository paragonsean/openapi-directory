/**
 * On-Demand Scanning API
 * A service to scan container images for vulnerabilities.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import BinarySourceInfo from './BinarySourceInfo';
import FileLocation from './FileLocation';
import LanguagePackageDependency from './LanguagePackageDependency';
import Maintainer from './Maintainer';
import PackageVersion from './PackageVersion';

/**
 * The PackageData model module.
 * @module model/PackageData
 * @version v1beta1
 */
class PackageData {
    /**
     * Constructs a new <code>PackageData</code>.
     * @alias module:model/PackageData
     */
    constructor() { 
        
        PackageData.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>PackageData</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/PackageData} obj Optional instance to populate.
     * @return {module:model/PackageData} The populated <code>PackageData</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new PackageData();

            if (data.hasOwnProperty('architecture')) {
                obj['architecture'] = ApiClient.convertToType(data['architecture'], 'String');
            }
            if (data.hasOwnProperty('binarySourceInfo')) {
                obj['binarySourceInfo'] = ApiClient.convertToType(data['binarySourceInfo'], [BinarySourceInfo]);
            }
            if (data.hasOwnProperty('binaryVersion')) {
                obj['binaryVersion'] = PackageVersion.constructFromObject(data['binaryVersion']);
            }
            if (data.hasOwnProperty('cpeUri')) {
                obj['cpeUri'] = ApiClient.convertToType(data['cpeUri'], 'String');
            }
            if (data.hasOwnProperty('dependencyChain')) {
                obj['dependencyChain'] = ApiClient.convertToType(data['dependencyChain'], [LanguagePackageDependency]);
            }
            if (data.hasOwnProperty('fileLocation')) {
                obj['fileLocation'] = ApiClient.convertToType(data['fileLocation'], [FileLocation]);
            }
            if (data.hasOwnProperty('hashDigest')) {
                obj['hashDigest'] = ApiClient.convertToType(data['hashDigest'], 'String');
            }
            if (data.hasOwnProperty('licenses')) {
                obj['licenses'] = ApiClient.convertToType(data['licenses'], ['String']);
            }
            if (data.hasOwnProperty('maintainer')) {
                obj['maintainer'] = Maintainer.constructFromObject(data['maintainer']);
            }
            if (data.hasOwnProperty('os')) {
                obj['os'] = ApiClient.convertToType(data['os'], 'String');
            }
            if (data.hasOwnProperty('osVersion')) {
                obj['osVersion'] = ApiClient.convertToType(data['osVersion'], 'String');
            }
            if (data.hasOwnProperty('package')) {
                obj['package'] = ApiClient.convertToType(data['package'], 'String');
            }
            if (data.hasOwnProperty('packageType')) {
                obj['packageType'] = ApiClient.convertToType(data['packageType'], 'String');
            }
            if (data.hasOwnProperty('patchedCve')) {
                obj['patchedCve'] = ApiClient.convertToType(data['patchedCve'], ['String']);
            }
            if (data.hasOwnProperty('sourceVersion')) {
                obj['sourceVersion'] = PackageVersion.constructFromObject(data['sourceVersion']);
            }
            if (data.hasOwnProperty('unused')) {
                obj['unused'] = ApiClient.convertToType(data['unused'], 'String');
            }
            if (data.hasOwnProperty('version')) {
                obj['version'] = ApiClient.convertToType(data['version'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>PackageData</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>PackageData</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['architecture'] && !(typeof data['architecture'] === 'string' || data['architecture'] instanceof String)) {
            throw new Error("Expected the field `architecture` to be a primitive type in the JSON string but got " + data['architecture']);
        }
        if (data['binarySourceInfo']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['binarySourceInfo'])) {
                throw new Error("Expected the field `binarySourceInfo` to be an array in the JSON data but got " + data['binarySourceInfo']);
            }
            // validate the optional field `binarySourceInfo` (array)
            for (const item of data['binarySourceInfo']) {
                BinarySourceInfo.validateJSON(item);
            };
        }
        // validate the optional field `binaryVersion`
        if (data['binaryVersion']) { // data not null
          PackageVersion.validateJSON(data['binaryVersion']);
        }
        // ensure the json data is a string
        if (data['cpeUri'] && !(typeof data['cpeUri'] === 'string' || data['cpeUri'] instanceof String)) {
            throw new Error("Expected the field `cpeUri` to be a primitive type in the JSON string but got " + data['cpeUri']);
        }
        if (data['dependencyChain']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['dependencyChain'])) {
                throw new Error("Expected the field `dependencyChain` to be an array in the JSON data but got " + data['dependencyChain']);
            }
            // validate the optional field `dependencyChain` (array)
            for (const item of data['dependencyChain']) {
                LanguagePackageDependency.validateJSON(item);
            };
        }
        if (data['fileLocation']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['fileLocation'])) {
                throw new Error("Expected the field `fileLocation` to be an array in the JSON data but got " + data['fileLocation']);
            }
            // validate the optional field `fileLocation` (array)
            for (const item of data['fileLocation']) {
                FileLocation.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['hashDigest'] && !(typeof data['hashDigest'] === 'string' || data['hashDigest'] instanceof String)) {
            throw new Error("Expected the field `hashDigest` to be a primitive type in the JSON string but got " + data['hashDigest']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['licenses'])) {
            throw new Error("Expected the field `licenses` to be an array in the JSON data but got " + data['licenses']);
        }
        // validate the optional field `maintainer`
        if (data['maintainer']) { // data not null
          Maintainer.validateJSON(data['maintainer']);
        }
        // ensure the json data is a string
        if (data['os'] && !(typeof data['os'] === 'string' || data['os'] instanceof String)) {
            throw new Error("Expected the field `os` to be a primitive type in the JSON string but got " + data['os']);
        }
        // ensure the json data is a string
        if (data['osVersion'] && !(typeof data['osVersion'] === 'string' || data['osVersion'] instanceof String)) {
            throw new Error("Expected the field `osVersion` to be a primitive type in the JSON string but got " + data['osVersion']);
        }
        // ensure the json data is a string
        if (data['package'] && !(typeof data['package'] === 'string' || data['package'] instanceof String)) {
            throw new Error("Expected the field `package` to be a primitive type in the JSON string but got " + data['package']);
        }
        // ensure the json data is a string
        if (data['packageType'] && !(typeof data['packageType'] === 'string' || data['packageType'] instanceof String)) {
            throw new Error("Expected the field `packageType` to be a primitive type in the JSON string but got " + data['packageType']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['patchedCve'])) {
            throw new Error("Expected the field `patchedCve` to be an array in the JSON data but got " + data['patchedCve']);
        }
        // validate the optional field `sourceVersion`
        if (data['sourceVersion']) { // data not null
          PackageVersion.validateJSON(data['sourceVersion']);
        }
        // ensure the json data is a string
        if (data['unused'] && !(typeof data['unused'] === 'string' || data['unused'] instanceof String)) {
            throw new Error("Expected the field `unused` to be a primitive type in the JSON string but got " + data['unused']);
        }
        // ensure the json data is a string
        if (data['version'] && !(typeof data['version'] === 'string' || data['version'] instanceof String)) {
            throw new Error("Expected the field `version` to be a primitive type in the JSON string but got " + data['version']);
        }

        return true;
    }


}



/**
 * The architecture of the package.
 * @member {String} architecture
 */
PackageData.prototype['architecture'] = undefined;

/**
 * A bundle containing the binary and source information.
 * @member {Array.<module:model/BinarySourceInfo>} binarySourceInfo
 */
PackageData.prototype['binarySourceInfo'] = undefined;

/**
 * @member {module:model/PackageVersion} binaryVersion
 */
PackageData.prototype['binaryVersion'] = undefined;

/**
 * The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which the vulnerability may manifest. Examples include distro or storage location for vulnerable jar.
 * @member {String} cpeUri
 */
PackageData.prototype['cpeUri'] = undefined;

/**
 * The dependency chain between this package and the user's artifact. List in order from the customer's package under review first, to the current package last. Inclusive of the original package and the current package.
 * @member {Array.<module:model/LanguagePackageDependency>} dependencyChain
 */
PackageData.prototype['dependencyChain'] = undefined;

/**
 * The path to the jar file / go binary file.
 * @member {Array.<module:model/FileLocation>} fileLocation
 */
PackageData.prototype['fileLocation'] = undefined;

/**
 * HashDigest stores the SHA512 hash digest of the jar file if the package is of type Maven. This field will be unset for non Maven packages.
 * @member {String} hashDigest
 */
PackageData.prototype['hashDigest'] = undefined;

/**
 * The list of licenses found that are related to a given package. Note that licenses may also be stored on the BinarySourceInfo. If there is no BinarySourceInfo (because there's no concept of source vs binary), then it will be stored here, while if there are BinarySourceInfos, it will be stored there, as one source can have multiple binaries with different licenses.
 * @member {Array.<String>} licenses
 */
PackageData.prototype['licenses'] = undefined;

/**
 * @member {module:model/Maintainer} maintainer
 */
PackageData.prototype['maintainer'] = undefined;

/**
 * The OS affected by a vulnerability Used to generate the cpe_uri for OS packages
 * @member {String} os
 */
PackageData.prototype['os'] = undefined;

/**
 * The version of the OS Used to generate the cpe_uri for OS packages
 * @member {String} osVersion
 */
PackageData.prototype['osVersion'] = undefined;

/**
 * The package being analysed for vulnerabilities
 * @member {String} package
 */
PackageData.prototype['package'] = undefined;

/**
 * The type of package: os, maven, go, etc.
 * @member {module:model/PackageData.PackageTypeEnum} packageType
 */
PackageData.prototype['packageType'] = undefined;

/**
 * CVEs that this package is no longer vulnerable to go/drydock-dd-custom-binary-scanning
 * @member {Array.<String>} patchedCve
 */
PackageData.prototype['patchedCve'] = undefined;

/**
 * @member {module:model/PackageVersion} sourceVersion
 */
PackageData.prototype['sourceVersion'] = undefined;

/**
 * @member {String} unused
 */
PackageData.prototype['unused'] = undefined;

/**
 * The version of the package being analysed
 * @member {String} version
 */
PackageData.prototype['version'] = undefined;





/**
 * Allowed values for the <code>packageType</code> property.
 * @enum {String}
 * @readonly
 */
PackageData['PackageTypeEnum'] = {

    /**
     * value: "PACKAGE_TYPE_UNSPECIFIED"
     * @const
     */
    "PACKAGE_TYPE_UNSPECIFIED": "PACKAGE_TYPE_UNSPECIFIED",

    /**
     * value: "OS"
     * @const
     */
    "OS": "OS",

    /**
     * value: "MAVEN"
     * @const
     */
    "MAVEN": "MAVEN",

    /**
     * value: "GO"
     * @const
     */
    "GO": "GO",

    /**
     * value: "GO_STDLIB"
     * @const
     */
    "GO_STDLIB": "GO_STDLIB",

    /**
     * value: "PYPI"
     * @const
     */
    "PYPI": "PYPI",

    /**
     * value: "NPM"
     * @const
     */
    "NPM": "NPM",

    /**
     * value: "NUGET"
     * @const
     */
    "NUGET": "NUGET",

    /**
     * value: "RUBYGEMS"
     * @const
     */
    "RUBYGEMS": "RUBYGEMS",

    /**
     * value: "RUST"
     * @const
     */
    "RUST": "RUST",

    /**
     * value: "COMPOSER"
     * @const
     */
    "COMPOSER": "COMPOSER"
};



export default PackageData;

