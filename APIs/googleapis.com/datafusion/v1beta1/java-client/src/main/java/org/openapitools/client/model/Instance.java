/*
 * Cloud Data Fusion API
 * Cloud Data Fusion is a fully-managed, cloud native, enterprise data integration service for quickly building and managing data pipelines. It provides a graphical interface to increase time efficiency and reduce complexity, and allows business users, developers, and data scientists to easily and reliably build scalable data integration solutions to cleanse, prepare, blend, transfer and transform data without having to wrestle with infrastructure.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Accelerator;
import org.openapitools.client.model.CryptoKeyConfig;
import org.openapitools.client.model.EventPublishConfig;
import org.openapitools.client.model.NetworkConfig;
import org.openapitools.client.model.Version;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a Data Fusion instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:55.894095-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Instance {
  public static final String SERIALIZED_NAME_ACCELERATORS = "accelerators";
  @SerializedName(SERIALIZED_NAME_ACCELERATORS)
  private List<Accelerator> accelerators = new ArrayList<>();

  public static final String SERIALIZED_NAME_API_ENDPOINT = "apiEndpoint";
  @SerializedName(SERIALIZED_NAME_API_ENDPOINT)
  private String apiEndpoint;

  public static final String SERIALIZED_NAME_AVAILABLE_VERSION = "availableVersion";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_VERSION)
  private List<Version> availableVersion = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CRYPTO_KEY_CONFIG = "cryptoKeyConfig";
  @SerializedName(SERIALIZED_NAME_CRYPTO_KEY_CONFIG)
  private CryptoKeyConfig cryptoKeyConfig;

  public static final String SERIALIZED_NAME_DATAPLEX_DATA_LINEAGE_INTEGRATION_ENABLED = "dataplexDataLineageIntegrationEnabled";
  @SerializedName(SERIALIZED_NAME_DATAPLEX_DATA_LINEAGE_INTEGRATION_ENABLED)
  private Boolean dataplexDataLineageIntegrationEnabled;

  public static final String SERIALIZED_NAME_DATAPROC_SERVICE_ACCOUNT = "dataprocServiceAccount";
  @SerializedName(SERIALIZED_NAME_DATAPROC_SERVICE_ACCOUNT)
  private String dataprocServiceAccount;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  /**
   * Gets or Sets disabledReason
   */
  @JsonAdapter(DisabledReasonEnum.Adapter.class)
  public enum DisabledReasonEnum {
    DISABLED_REASON_UNSPECIFIED("DISABLED_REASON_UNSPECIFIED"),
    
    KMS_KEY_ISSUE("KMS_KEY_ISSUE");

    private String value;

    DisabledReasonEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DisabledReasonEnum fromValue(String value) {
      for (DisabledReasonEnum b : DisabledReasonEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DisabledReasonEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DisabledReasonEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DisabledReasonEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DisabledReasonEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DisabledReasonEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISABLED_REASON = "disabledReason";
  @SerializedName(SERIALIZED_NAME_DISABLED_REASON)
  private List<DisabledReasonEnum> disabledReason = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_ENABLE_RBAC = "enableRbac";
  @SerializedName(SERIALIZED_NAME_ENABLE_RBAC)
  private Boolean enableRbac;

  public static final String SERIALIZED_NAME_ENABLE_STACKDRIVER_LOGGING = "enableStackdriverLogging";
  @SerializedName(SERIALIZED_NAME_ENABLE_STACKDRIVER_LOGGING)
  private Boolean enableStackdriverLogging;

  public static final String SERIALIZED_NAME_ENABLE_STACKDRIVER_MONITORING = "enableStackdriverMonitoring";
  @SerializedName(SERIALIZED_NAME_ENABLE_STACKDRIVER_MONITORING)
  private Boolean enableStackdriverMonitoring;

  public static final String SERIALIZED_NAME_ENABLE_ZONE_SEPARATION = "enableZoneSeparation";
  @SerializedName(SERIALIZED_NAME_ENABLE_ZONE_SEPARATION)
  private Boolean enableZoneSeparation;

  public static final String SERIALIZED_NAME_EVENT_PUBLISH_CONFIG = "eventPublishConfig";
  @SerializedName(SERIALIZED_NAME_EVENT_PUBLISH_CONFIG)
  private EventPublishConfig eventPublishConfig;

  public static final String SERIALIZED_NAME_GCS_BUCKET = "gcsBucket";
  @SerializedName(SERIALIZED_NAME_GCS_BUCKET)
  private String gcsBucket;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NETWORK_CONFIG = "networkConfig";
  @SerializedName(SERIALIZED_NAME_NETWORK_CONFIG)
  private NetworkConfig networkConfig;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private Map<String, String> options = new HashMap<>();

  public static final String SERIALIZED_NAME_P4_SERVICE_ACCOUNT = "p4ServiceAccount";
  @SerializedName(SERIALIZED_NAME_P4_SERVICE_ACCOUNT)
  private String p4ServiceAccount;

  public static final String SERIALIZED_NAME_PATCH_REVISION = "patchRevision";
  @SerializedName(SERIALIZED_NAME_PATCH_REVISION)
  private String patchRevision;

  public static final String SERIALIZED_NAME_PRIVATE_INSTANCE = "privateInstance";
  @SerializedName(SERIALIZED_NAME_PRIVATE_INSTANCE)
  private Boolean privateInstance;

  public static final String SERIALIZED_NAME_SATISFIES_PZS = "satisfiesPzs";
  @SerializedName(SERIALIZED_NAME_SATISFIES_PZS)
  private Boolean satisfiesPzs;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SERVICE_ENDPOINT = "serviceEndpoint";
  @SerializedName(SERIALIZED_NAME_SERVICE_ENDPOINT)
  private String serviceEndpoint;

  /**
   * Output only. The current state of this Data Fusion instance.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    CREATING("CREATING"),
    
    RUNNING("RUNNING"),
    
    FAILED("FAILED"),
    
    DELETING("DELETING"),
    
    UPGRADING("UPGRADING"),
    
    RESTARTING("RESTARTING"),
    
    UPDATING("UPDATING"),
    
    AUTO_UPDATING("AUTO_UPDATING"),
    
    AUTO_UPGRADING("AUTO_UPGRADING"),
    
    DISABLED("DISABLED");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_STATE_MESSAGE = "stateMessage";
  @SerializedName(SERIALIZED_NAME_STATE_MESSAGE)
  private String stateMessage;

  public static final String SERIALIZED_NAME_TENANT_PROJECT_ID = "tenantProjectId";
  @SerializedName(SERIALIZED_NAME_TENANT_PROJECT_ID)
  private String tenantProjectId;

  /**
   * Required. Instance type.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TYPE_UNSPECIFIED("TYPE_UNSPECIFIED"),
    
    BASIC("BASIC"),
    
    ENTERPRISE("ENTERPRISE"),
    
    DEVELOPER("DEVELOPER");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_WORKFORCE_IDENTITY_SERVICE_ENDPOINT = "workforceIdentityServiceEndpoint";
  @SerializedName(SERIALIZED_NAME_WORKFORCE_IDENTITY_SERVICE_ENDPOINT)
  private String workforceIdentityServiceEndpoint;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public Instance() {
  }

  public Instance(
     List<Accelerator> accelerators, 
     String apiEndpoint, 
     List<Version> availableVersion, 
     String createTime, 
     List<DisabledReasonEnum> disabledReason, 
     String gcsBucket, 
     String name, 
     String p4ServiceAccount, 
     Boolean satisfiesPzs, 
     String serviceAccount, 
     String serviceEndpoint, 
     StateEnum state, 
     String stateMessage, 
     String tenantProjectId, 
     String updateTime, 
     String workforceIdentityServiceEndpoint
  ) {
    this();
    this.accelerators = accelerators;
    this.apiEndpoint = apiEndpoint;
    this.availableVersion = availableVersion;
    this.createTime = createTime;
    this.disabledReason = disabledReason;
    this.gcsBucket = gcsBucket;
    this.name = name;
    this.p4ServiceAccount = p4ServiceAccount;
    this.satisfiesPzs = satisfiesPzs;
    this.serviceAccount = serviceAccount;
    this.serviceEndpoint = serviceEndpoint;
    this.state = state;
    this.stateMessage = stateMessage;
    this.tenantProjectId = tenantProjectId;
    this.updateTime = updateTime;
    this.workforceIdentityServiceEndpoint = workforceIdentityServiceEndpoint;
  }

  /**
   * Output only. List of accelerators enabled for this CDF instance.
   * @return accelerators
   */
  @javax.annotation.Nullable
  public List<Accelerator> getAccelerators() {
    return accelerators;
  }



  /**
   * Output only. Endpoint on which the REST APIs is accessible.
   * @return apiEndpoint
   */
  @javax.annotation.Nullable
  public String getApiEndpoint() {
    return apiEndpoint;
  }



  /**
   * Output only. Available versions that the instance can be upgraded to using UpdateInstanceRequest.
   * @return availableVersion
   */
  @javax.annotation.Nullable
  public List<Version> getAvailableVersion() {
    return availableVersion;
  }



  /**
   * Output only. The time the instance was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public Instance cryptoKeyConfig(CryptoKeyConfig cryptoKeyConfig) {
    this.cryptoKeyConfig = cryptoKeyConfig;
    return this;
  }

  /**
   * Get cryptoKeyConfig
   * @return cryptoKeyConfig
   */
  @javax.annotation.Nullable
  public CryptoKeyConfig getCryptoKeyConfig() {
    return cryptoKeyConfig;
  }

  public void setCryptoKeyConfig(CryptoKeyConfig cryptoKeyConfig) {
    this.cryptoKeyConfig = cryptoKeyConfig;
  }


  public Instance dataplexDataLineageIntegrationEnabled(Boolean dataplexDataLineageIntegrationEnabled) {
    this.dataplexDataLineageIntegrationEnabled = dataplexDataLineageIntegrationEnabled;
    return this;
  }

  /**
   * Optional. Option to enable the Dataplex Lineage Integration feature.
   * @return dataplexDataLineageIntegrationEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDataplexDataLineageIntegrationEnabled() {
    return dataplexDataLineageIntegrationEnabled;
  }

  public void setDataplexDataLineageIntegrationEnabled(Boolean dataplexDataLineageIntegrationEnabled) {
    this.dataplexDataLineageIntegrationEnabled = dataplexDataLineageIntegrationEnabled;
  }


  public Instance dataprocServiceAccount(String dataprocServiceAccount) {
    this.dataprocServiceAccount = dataprocServiceAccount;
    return this;
  }

  /**
   * User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines. This allows users to have fine-grained access control on Dataproc&#39;s accesses to cloud resources.
   * @return dataprocServiceAccount
   */
  @javax.annotation.Nullable
  public String getDataprocServiceAccount() {
    return dataprocServiceAccount;
  }

  public void setDataprocServiceAccount(String dataprocServiceAccount) {
    this.dataprocServiceAccount = dataprocServiceAccount;
  }


  public Instance description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A description of this instance.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  /**
   * Output only. If the instance state is DISABLED, the reason for disabling the instance.
   * @return disabledReason
   */
  @javax.annotation.Nullable
  public List<DisabledReasonEnum> getDisabledReason() {
    return disabledReason;
  }



  public Instance displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Display name for an instance.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public Instance enableRbac(Boolean enableRbac) {
    this.enableRbac = enableRbac;
    return this;
  }

  /**
   * Option to enable granular role-based access control.
   * @return enableRbac
   */
  @javax.annotation.Nullable
  public Boolean getEnableRbac() {
    return enableRbac;
  }

  public void setEnableRbac(Boolean enableRbac) {
    this.enableRbac = enableRbac;
  }


  public Instance enableStackdriverLogging(Boolean enableStackdriverLogging) {
    this.enableStackdriverLogging = enableStackdriverLogging;
    return this;
  }

  /**
   * Option to enable Stackdriver Logging.
   * @return enableStackdriverLogging
   */
  @javax.annotation.Nullable
  public Boolean getEnableStackdriverLogging() {
    return enableStackdriverLogging;
  }

  public void setEnableStackdriverLogging(Boolean enableStackdriverLogging) {
    this.enableStackdriverLogging = enableStackdriverLogging;
  }


  public Instance enableStackdriverMonitoring(Boolean enableStackdriverMonitoring) {
    this.enableStackdriverMonitoring = enableStackdriverMonitoring;
    return this;
  }

  /**
   * Option to enable Stackdriver Monitoring.
   * @return enableStackdriverMonitoring
   */
  @javax.annotation.Nullable
  public Boolean getEnableStackdriverMonitoring() {
    return enableStackdriverMonitoring;
  }

  public void setEnableStackdriverMonitoring(Boolean enableStackdriverMonitoring) {
    this.enableStackdriverMonitoring = enableStackdriverMonitoring;
  }


  public Instance enableZoneSeparation(Boolean enableZoneSeparation) {
    this.enableZoneSeparation = enableZoneSeparation;
    return this;
  }

  /**
   * Option to enable zone separation.
   * @return enableZoneSeparation
   */
  @javax.annotation.Nullable
  public Boolean getEnableZoneSeparation() {
    return enableZoneSeparation;
  }

  public void setEnableZoneSeparation(Boolean enableZoneSeparation) {
    this.enableZoneSeparation = enableZoneSeparation;
  }


  public Instance eventPublishConfig(EventPublishConfig eventPublishConfig) {
    this.eventPublishConfig = eventPublishConfig;
    return this;
  }

  /**
   * Get eventPublishConfig
   * @return eventPublishConfig
   */
  @javax.annotation.Nullable
  public EventPublishConfig getEventPublishConfig() {
    return eventPublishConfig;
  }

  public void setEventPublishConfig(EventPublishConfig eventPublishConfig) {
    this.eventPublishConfig = eventPublishConfig;
  }


  /**
   * Output only. Cloud Storage bucket generated by Data Fusion in the customer project.
   * @return gcsBucket
   */
  @javax.annotation.Nullable
  public String getGcsBucket() {
    return gcsBucket;
  }



  public Instance labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Instance putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The resource labels for instance to use to annotate any related underlying resources such as Compute Engine VMs. The character &#39;&#x3D;&#39; is not allowed to be used within the labels.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  /**
   * Output only. The name of this instance is in the form of projects/{project}/locations/{location}/instances/{instance}.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public Instance networkConfig(NetworkConfig networkConfig) {
    this.networkConfig = networkConfig;
    return this;
  }

  /**
   * Get networkConfig
   * @return networkConfig
   */
  @javax.annotation.Nullable
  public NetworkConfig getNetworkConfig() {
    return networkConfig;
  }

  public void setNetworkConfig(NetworkConfig networkConfig) {
    this.networkConfig = networkConfig;
  }


  public Instance options(Map<String, String> options) {
    this.options = options;
    return this;
  }

  public Instance putOptionsItem(String key, String optionsItem) {
    if (this.options == null) {
      this.options = new HashMap<>();
    }
    this.options.put(key, optionsItem);
    return this;
  }

  /**
   * Map of additional options used to configure the behavior of Data Fusion instance.
   * @return options
   */
  @javax.annotation.Nullable
  public Map<String, String> getOptions() {
    return options;
  }

  public void setOptions(Map<String, String> options) {
    this.options = options;
  }


  /**
   * Output only. P4 service account for the customer project.
   * @return p4ServiceAccount
   */
  @javax.annotation.Nullable
  public String getP4ServiceAccount() {
    return p4ServiceAccount;
  }



  public Instance patchRevision(String patchRevision) {
    this.patchRevision = patchRevision;
    return this;
  }

  /**
   * Optional. Current patch revision of the Data Fusion.
   * @return patchRevision
   */
  @javax.annotation.Nullable
  public String getPatchRevision() {
    return patchRevision;
  }

  public void setPatchRevision(String patchRevision) {
    this.patchRevision = patchRevision;
  }


  public Instance privateInstance(Boolean privateInstance) {
    this.privateInstance = privateInstance;
    return this;
  }

  /**
   * Specifies whether the Data Fusion instance should be private. If set to true, all Data Fusion nodes will have private IP addresses and will not be able to access the public internet.
   * @return privateInstance
   */
  @javax.annotation.Nullable
  public Boolean getPrivateInstance() {
    return privateInstance;
  }

  public void setPrivateInstance(Boolean privateInstance) {
    this.privateInstance = privateInstance;
  }


  /**
   * Output only. Reserved for future use.
   * @return satisfiesPzs
   */
  @javax.annotation.Nullable
  public Boolean getSatisfiesPzs() {
    return satisfiesPzs;
  }



  /**
   * Output only. Deprecated. Use tenant_project_id instead to extract the tenant project ID.
   * @return serviceAccount
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }



  /**
   * Output only. Endpoint on which the Data Fusion UI is accessible.
   * @return serviceEndpoint
   */
  @javax.annotation.Nullable
  public String getServiceEndpoint() {
    return serviceEndpoint;
  }



  /**
   * Output only. The current state of this Data Fusion instance.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  /**
   * Output only. Additional information about the current state of this Data Fusion instance if available.
   * @return stateMessage
   */
  @javax.annotation.Nullable
  public String getStateMessage() {
    return stateMessage;
  }



  /**
   * Output only. The name of the tenant project.
   * @return tenantProjectId
   */
  @javax.annotation.Nullable
  public String getTenantProjectId() {
    return tenantProjectId;
  }



  public Instance type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Required. Instance type.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  /**
   * Output only. The time the instance was last updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  public Instance version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Current version of Data Fusion.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  /**
   * Output only. Endpoint on which the Data Fusion UI is accessible to third-party users.
   * @return workforceIdentityServiceEndpoint
   */
  @javax.annotation.Nullable
  public String getWorkforceIdentityServiceEndpoint() {
    return workforceIdentityServiceEndpoint;
  }



  public Instance zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Instance instance = (Instance) o;
    return Objects.equals(this.accelerators, instance.accelerators) &&
        Objects.equals(this.apiEndpoint, instance.apiEndpoint) &&
        Objects.equals(this.availableVersion, instance.availableVersion) &&
        Objects.equals(this.createTime, instance.createTime) &&
        Objects.equals(this.cryptoKeyConfig, instance.cryptoKeyConfig) &&
        Objects.equals(this.dataplexDataLineageIntegrationEnabled, instance.dataplexDataLineageIntegrationEnabled) &&
        Objects.equals(this.dataprocServiceAccount, instance.dataprocServiceAccount) &&
        Objects.equals(this.description, instance.description) &&
        Objects.equals(this.disabledReason, instance.disabledReason) &&
        Objects.equals(this.displayName, instance.displayName) &&
        Objects.equals(this.enableRbac, instance.enableRbac) &&
        Objects.equals(this.enableStackdriverLogging, instance.enableStackdriverLogging) &&
        Objects.equals(this.enableStackdriverMonitoring, instance.enableStackdriverMonitoring) &&
        Objects.equals(this.enableZoneSeparation, instance.enableZoneSeparation) &&
        Objects.equals(this.eventPublishConfig, instance.eventPublishConfig) &&
        Objects.equals(this.gcsBucket, instance.gcsBucket) &&
        Objects.equals(this.labels, instance.labels) &&
        Objects.equals(this.name, instance.name) &&
        Objects.equals(this.networkConfig, instance.networkConfig) &&
        Objects.equals(this.options, instance.options) &&
        Objects.equals(this.p4ServiceAccount, instance.p4ServiceAccount) &&
        Objects.equals(this.patchRevision, instance.patchRevision) &&
        Objects.equals(this.privateInstance, instance.privateInstance) &&
        Objects.equals(this.satisfiesPzs, instance.satisfiesPzs) &&
        Objects.equals(this.serviceAccount, instance.serviceAccount) &&
        Objects.equals(this.serviceEndpoint, instance.serviceEndpoint) &&
        Objects.equals(this.state, instance.state) &&
        Objects.equals(this.stateMessage, instance.stateMessage) &&
        Objects.equals(this.tenantProjectId, instance.tenantProjectId) &&
        Objects.equals(this.type, instance.type) &&
        Objects.equals(this.updateTime, instance.updateTime) &&
        Objects.equals(this.version, instance.version) &&
        Objects.equals(this.workforceIdentityServiceEndpoint, instance.workforceIdentityServiceEndpoint) &&
        Objects.equals(this.zone, instance.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accelerators, apiEndpoint, availableVersion, createTime, cryptoKeyConfig, dataplexDataLineageIntegrationEnabled, dataprocServiceAccount, description, disabledReason, displayName, enableRbac, enableStackdriverLogging, enableStackdriverMonitoring, enableZoneSeparation, eventPublishConfig, gcsBucket, labels, name, networkConfig, options, p4ServiceAccount, patchRevision, privateInstance, satisfiesPzs, serviceAccount, serviceEndpoint, state, stateMessage, tenantProjectId, type, updateTime, version, workforceIdentityServiceEndpoint, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Instance {\n");
    sb.append("    accelerators: ").append(toIndentedString(accelerators)).append("\n");
    sb.append("    apiEndpoint: ").append(toIndentedString(apiEndpoint)).append("\n");
    sb.append("    availableVersion: ").append(toIndentedString(availableVersion)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    cryptoKeyConfig: ").append(toIndentedString(cryptoKeyConfig)).append("\n");
    sb.append("    dataplexDataLineageIntegrationEnabled: ").append(toIndentedString(dataplexDataLineageIntegrationEnabled)).append("\n");
    sb.append("    dataprocServiceAccount: ").append(toIndentedString(dataprocServiceAccount)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    disabledReason: ").append(toIndentedString(disabledReason)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    enableRbac: ").append(toIndentedString(enableRbac)).append("\n");
    sb.append("    enableStackdriverLogging: ").append(toIndentedString(enableStackdriverLogging)).append("\n");
    sb.append("    enableStackdriverMonitoring: ").append(toIndentedString(enableStackdriverMonitoring)).append("\n");
    sb.append("    enableZoneSeparation: ").append(toIndentedString(enableZoneSeparation)).append("\n");
    sb.append("    eventPublishConfig: ").append(toIndentedString(eventPublishConfig)).append("\n");
    sb.append("    gcsBucket: ").append(toIndentedString(gcsBucket)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    networkConfig: ").append(toIndentedString(networkConfig)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    p4ServiceAccount: ").append(toIndentedString(p4ServiceAccount)).append("\n");
    sb.append("    patchRevision: ").append(toIndentedString(patchRevision)).append("\n");
    sb.append("    privateInstance: ").append(toIndentedString(privateInstance)).append("\n");
    sb.append("    satisfiesPzs: ").append(toIndentedString(satisfiesPzs)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    serviceEndpoint: ").append(toIndentedString(serviceEndpoint)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stateMessage: ").append(toIndentedString(stateMessage)).append("\n");
    sb.append("    tenantProjectId: ").append(toIndentedString(tenantProjectId)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    workforceIdentityServiceEndpoint: ").append(toIndentedString(workforceIdentityServiceEndpoint)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accelerators");
    openapiFields.add("apiEndpoint");
    openapiFields.add("availableVersion");
    openapiFields.add("createTime");
    openapiFields.add("cryptoKeyConfig");
    openapiFields.add("dataplexDataLineageIntegrationEnabled");
    openapiFields.add("dataprocServiceAccount");
    openapiFields.add("description");
    openapiFields.add("disabledReason");
    openapiFields.add("displayName");
    openapiFields.add("enableRbac");
    openapiFields.add("enableStackdriverLogging");
    openapiFields.add("enableStackdriverMonitoring");
    openapiFields.add("enableZoneSeparation");
    openapiFields.add("eventPublishConfig");
    openapiFields.add("gcsBucket");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("networkConfig");
    openapiFields.add("options");
    openapiFields.add("p4ServiceAccount");
    openapiFields.add("patchRevision");
    openapiFields.add("privateInstance");
    openapiFields.add("satisfiesPzs");
    openapiFields.add("serviceAccount");
    openapiFields.add("serviceEndpoint");
    openapiFields.add("state");
    openapiFields.add("stateMessage");
    openapiFields.add("tenantProjectId");
    openapiFields.add("type");
    openapiFields.add("updateTime");
    openapiFields.add("version");
    openapiFields.add("workforceIdentityServiceEndpoint");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Instance
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Instance.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Instance is not found in the empty JSON string", Instance.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Instance.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Instance` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("accelerators") != null && !jsonObj.get("accelerators").isJsonNull()) {
        JsonArray jsonArrayaccelerators = jsonObj.getAsJsonArray("accelerators");
        if (jsonArrayaccelerators != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accelerators").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accelerators` to be an array in the JSON string but got `%s`", jsonObj.get("accelerators").toString()));
          }

          // validate the optional field `accelerators` (array)
          for (int i = 0; i < jsonArrayaccelerators.size(); i++) {
            Accelerator.validateJsonElement(jsonArrayaccelerators.get(i));
          };
        }
      }
      if ((jsonObj.get("apiEndpoint") != null && !jsonObj.get("apiEndpoint").isJsonNull()) && !jsonObj.get("apiEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `apiEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("apiEndpoint").toString()));
      }
      if (jsonObj.get("availableVersion") != null && !jsonObj.get("availableVersion").isJsonNull()) {
        JsonArray jsonArrayavailableVersion = jsonObj.getAsJsonArray("availableVersion");
        if (jsonArrayavailableVersion != null) {
          // ensure the json data is an array
          if (!jsonObj.get("availableVersion").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `availableVersion` to be an array in the JSON string but got `%s`", jsonObj.get("availableVersion").toString()));
          }

          // validate the optional field `availableVersion` (array)
          for (int i = 0; i < jsonArrayavailableVersion.size(); i++) {
            Version.validateJsonElement(jsonArrayavailableVersion.get(i));
          };
        }
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      // validate the optional field `cryptoKeyConfig`
      if (jsonObj.get("cryptoKeyConfig") != null && !jsonObj.get("cryptoKeyConfig").isJsonNull()) {
        CryptoKeyConfig.validateJsonElement(jsonObj.get("cryptoKeyConfig"));
      }
      if ((jsonObj.get("dataprocServiceAccount") != null && !jsonObj.get("dataprocServiceAccount").isJsonNull()) && !jsonObj.get("dataprocServiceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataprocServiceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataprocServiceAccount").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("disabledReason") != null && !jsonObj.get("disabledReason").isJsonNull() && !jsonObj.get("disabledReason").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `disabledReason` to be an array in the JSON string but got `%s`", jsonObj.get("disabledReason").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // validate the optional field `eventPublishConfig`
      if (jsonObj.get("eventPublishConfig") != null && !jsonObj.get("eventPublishConfig").isJsonNull()) {
        EventPublishConfig.validateJsonElement(jsonObj.get("eventPublishConfig"));
      }
      if ((jsonObj.get("gcsBucket") != null && !jsonObj.get("gcsBucket").isJsonNull()) && !jsonObj.get("gcsBucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gcsBucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gcsBucket").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `networkConfig`
      if (jsonObj.get("networkConfig") != null && !jsonObj.get("networkConfig").isJsonNull()) {
        NetworkConfig.validateJsonElement(jsonObj.get("networkConfig"));
      }
      if ((jsonObj.get("p4ServiceAccount") != null && !jsonObj.get("p4ServiceAccount").isJsonNull()) && !jsonObj.get("p4ServiceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `p4ServiceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("p4ServiceAccount").toString()));
      }
      if ((jsonObj.get("patchRevision") != null && !jsonObj.get("patchRevision").isJsonNull()) && !jsonObj.get("patchRevision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `patchRevision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("patchRevision").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      if ((jsonObj.get("serviceEndpoint") != null && !jsonObj.get("serviceEndpoint").isJsonNull()) && !jsonObj.get("serviceEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceEndpoint").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("stateMessage") != null && !jsonObj.get("stateMessage").isJsonNull()) && !jsonObj.get("stateMessage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stateMessage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stateMessage").toString()));
      }
      if ((jsonObj.get("tenantProjectId") != null && !jsonObj.get("tenantProjectId").isJsonNull()) && !jsonObj.get("tenantProjectId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tenantProjectId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tenantProjectId").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if ((jsonObj.get("workforceIdentityServiceEndpoint") != null && !jsonObj.get("workforceIdentityServiceEndpoint").isJsonNull()) && !jsonObj.get("workforceIdentityServiceEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workforceIdentityServiceEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workforceIdentityServiceEndpoint").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Instance.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Instance' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Instance> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Instance.class));

       return (TypeAdapter<T>) new TypeAdapter<Instance>() {
           @Override
           public void write(JsonWriter out, Instance value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Instance read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Instance given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Instance
   * @throws IOException if the JSON string is invalid with respect to Instance
   */
  public static Instance fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Instance.class);
  }

  /**
   * Convert an instance of Instance to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

