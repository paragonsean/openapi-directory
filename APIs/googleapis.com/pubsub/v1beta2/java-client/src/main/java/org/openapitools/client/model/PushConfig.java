/*
 * Cloud Pub/Sub API
 * Provides reliable, many-to-many, asynchronous messaging between applications. 
 *
 * The version of the OpenAPI document: v1beta2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.OidcToken;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration for a push delivery endpoint.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:50:49.989808-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PushConfig {
  public static final String SERIALIZED_NAME_ATTRIBUTES = "attributes";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)
  private Map<String, String> attributes = new HashMap<>();

  public static final String SERIALIZED_NAME_OIDC_TOKEN = "oidcToken";
  @SerializedName(SERIALIZED_NAME_OIDC_TOKEN)
  private OidcToken oidcToken;

  public static final String SERIALIZED_NAME_PUSH_ENDPOINT = "pushEndpoint";
  @SerializedName(SERIALIZED_NAME_PUSH_ENDPOINT)
  private String pushEndpoint;

  public PushConfig() {
  }

  public PushConfig attributes(Map<String, String> attributes) {
    this.attributes = attributes;
    return this;
  }

  public PushConfig putAttributesItem(String key, String attributesItem) {
    if (this.attributes == null) {
      this.attributes = new HashMap<>();
    }
    this.attributes.put(key, attributesItem);
    return this;
  }

  /**
   * Endpoint configuration attributes. Every endpoint has a set of API supported attributes that can be used to control different aspects of the message delivery. The currently supported attribute is &#x60;x-goog-version&#x60;, which you can use to change the format of the push message. This attribute indicates the version of the data expected by the endpoint. This controls the shape of the envelope (i.e. its fields and metadata). The endpoint version is based on the version of the Pub/Sub API. If not present during the &#x60;CreateSubscription&#x60; call, it will default to the version of the API used to make such call. If not present during a &#x60;ModifyPushConfig&#x60; call, its value will not be changed. &#x60;GetSubscription&#x60; calls will always return a valid version, even if the subscription was created without this attribute. The possible values for this attribute are: * &#x60;v1beta1&#x60;: uses the push format defined in the v1beta1 Pub/Sub API. * &#x60;v1&#x60; or &#x60;v1beta2&#x60;: uses the push format defined in the v1 Pub/Sub API.
   * @return attributes
   */
  @javax.annotation.Nullable
  public Map<String, String> getAttributes() {
    return attributes;
  }

  public void setAttributes(Map<String, String> attributes) {
    this.attributes = attributes;
  }


  public PushConfig oidcToken(OidcToken oidcToken) {
    this.oidcToken = oidcToken;
    return this;
  }

  /**
   * Get oidcToken
   * @return oidcToken
   */
  @javax.annotation.Nullable
  public OidcToken getOidcToken() {
    return oidcToken;
  }

  public void setOidcToken(OidcToken oidcToken) {
    this.oidcToken = oidcToken;
  }


  public PushConfig pushEndpoint(String pushEndpoint) {
    this.pushEndpoint = pushEndpoint;
    return this;
  }

  /**
   * A URL locating the endpoint to which messages should be pushed. For example, a Webhook endpoint might use \&quot;https://example.com/push\&quot;.
   * @return pushEndpoint
   */
  @javax.annotation.Nullable
  public String getPushEndpoint() {
    return pushEndpoint;
  }

  public void setPushEndpoint(String pushEndpoint) {
    this.pushEndpoint = pushEndpoint;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PushConfig pushConfig = (PushConfig) o;
    return Objects.equals(this.attributes, pushConfig.attributes) &&
        Objects.equals(this.oidcToken, pushConfig.oidcToken) &&
        Objects.equals(this.pushEndpoint, pushConfig.pushEndpoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attributes, oidcToken, pushEndpoint);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PushConfig {\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    oidcToken: ").append(toIndentedString(oidcToken)).append("\n");
    sb.append("    pushEndpoint: ").append(toIndentedString(pushEndpoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attributes");
    openapiFields.add("oidcToken");
    openapiFields.add("pushEndpoint");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PushConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PushConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PushConfig is not found in the empty JSON string", PushConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PushConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PushConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `oidcToken`
      if (jsonObj.get("oidcToken") != null && !jsonObj.get("oidcToken").isJsonNull()) {
        OidcToken.validateJsonElement(jsonObj.get("oidcToken"));
      }
      if ((jsonObj.get("pushEndpoint") != null && !jsonObj.get("pushEndpoint").isJsonNull()) && !jsonObj.get("pushEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pushEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pushEndpoint").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PushConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PushConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PushConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PushConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<PushConfig>() {
           @Override
           public void write(JsonWriter out, PushConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PushConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PushConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PushConfig
   * @throws IOException if the JSON string is invalid with respect to PushConfig
   */
  public static PushConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PushConfig.class);
  }

  /**
   * Convert an instance of PushConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

