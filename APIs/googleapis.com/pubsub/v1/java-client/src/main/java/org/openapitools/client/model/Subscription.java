/*
 * Cloud Pub/Sub API
 * Provides reliable, many-to-many, asynchronous messaging between applications. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.BigQueryConfig;
import org.openapitools.client.model.CloudStorageConfig;
import org.openapitools.client.model.DeadLetterPolicy;
import org.openapitools.client.model.ExpirationPolicy;
import org.openapitools.client.model.PushConfig;
import org.openapitools.client.model.RetryPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A subscription resource. If none of &#x60;push_config&#x60;, &#x60;bigquery_config&#x60;, or &#x60;cloud_storage_config&#x60; is set, then the subscriber will pull and ack messages using API methods. At most one of these fields may be set.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:50:53.464766-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Subscription {
  public static final String SERIALIZED_NAME_ACK_DEADLINE_SECONDS = "ackDeadlineSeconds";
  @SerializedName(SERIALIZED_NAME_ACK_DEADLINE_SECONDS)
  private Integer ackDeadlineSeconds;

  public static final String SERIALIZED_NAME_BIGQUERY_CONFIG = "bigqueryConfig";
  @SerializedName(SERIALIZED_NAME_BIGQUERY_CONFIG)
  private BigQueryConfig bigqueryConfig;

  public static final String SERIALIZED_NAME_CLOUD_STORAGE_CONFIG = "cloudStorageConfig";
  @SerializedName(SERIALIZED_NAME_CLOUD_STORAGE_CONFIG)
  private CloudStorageConfig cloudStorageConfig;

  public static final String SERIALIZED_NAME_DEAD_LETTER_POLICY = "deadLetterPolicy";
  @SerializedName(SERIALIZED_NAME_DEAD_LETTER_POLICY)
  private DeadLetterPolicy deadLetterPolicy;

  public static final String SERIALIZED_NAME_DETACHED = "detached";
  @SerializedName(SERIALIZED_NAME_DETACHED)
  private Boolean detached;

  public static final String SERIALIZED_NAME_ENABLE_EXACTLY_ONCE_DELIVERY = "enableExactlyOnceDelivery";
  @SerializedName(SERIALIZED_NAME_ENABLE_EXACTLY_ONCE_DELIVERY)
  private Boolean enableExactlyOnceDelivery;

  public static final String SERIALIZED_NAME_ENABLE_MESSAGE_ORDERING = "enableMessageOrdering";
  @SerializedName(SERIALIZED_NAME_ENABLE_MESSAGE_ORDERING)
  private Boolean enableMessageOrdering;

  public static final String SERIALIZED_NAME_EXPIRATION_POLICY = "expirationPolicy";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_POLICY)
  private ExpirationPolicy expirationPolicy;

  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MESSAGE_RETENTION_DURATION = "messageRetentionDuration";
  @SerializedName(SERIALIZED_NAME_MESSAGE_RETENTION_DURATION)
  private String messageRetentionDuration;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PUSH_CONFIG = "pushConfig";
  @SerializedName(SERIALIZED_NAME_PUSH_CONFIG)
  private PushConfig pushConfig;

  public static final String SERIALIZED_NAME_RETAIN_ACKED_MESSAGES = "retainAckedMessages";
  @SerializedName(SERIALIZED_NAME_RETAIN_ACKED_MESSAGES)
  private Boolean retainAckedMessages;

  public static final String SERIALIZED_NAME_RETRY_POLICY = "retryPolicy";
  @SerializedName(SERIALIZED_NAME_RETRY_POLICY)
  private RetryPolicy retryPolicy;

  /**
   * Output only. An output-only field indicating whether or not the subscription can receive messages.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    ACTIVE("ACTIVE"),
    
    RESOURCE_ERROR("RESOURCE_ERROR");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_TOPIC = "topic";
  @SerializedName(SERIALIZED_NAME_TOPIC)
  private String topic;

  public static final String SERIALIZED_NAME_TOPIC_MESSAGE_RETENTION_DURATION = "topicMessageRetentionDuration";
  @SerializedName(SERIALIZED_NAME_TOPIC_MESSAGE_RETENTION_DURATION)
  private String topicMessageRetentionDuration;

  public Subscription() {
  }

  public Subscription(
     StateEnum state, 
     String topicMessageRetentionDuration
  ) {
    this();
    this.state = state;
    this.topicMessageRetentionDuration = topicMessageRetentionDuration;
  }

  public Subscription ackDeadlineSeconds(Integer ackDeadlineSeconds) {
    this.ackDeadlineSeconds = ackDeadlineSeconds;
    return this;
  }

  /**
   * Optional. The approximate amount of time (on a best-effort basis) Pub/Sub waits for the subscriber to acknowledge receipt before resending the message. In the interval after the message is delivered and before it is acknowledged, it is considered to be _outstanding_. During that time period, the message will not be redelivered (on a best-effort basis). For pull subscriptions, this value is used as the initial value for the ack deadline. To override this value for a given message, call &#x60;ModifyAckDeadline&#x60; with the corresponding &#x60;ack_id&#x60; if using non-streaming pull or send the &#x60;ack_id&#x60; in a &#x60;StreamingModifyAckDeadlineRequest&#x60; if using streaming pull. The minimum custom deadline you can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds (10 minutes). If this parameter is 0, a default value of 10 seconds is used. For push delivery, this value is also used to set the request timeout for the call to the push endpoint. If the subscriber never acknowledges the message, the Pub/Sub system will eventually redeliver the message.
   * @return ackDeadlineSeconds
   */
  @javax.annotation.Nullable
  public Integer getAckDeadlineSeconds() {
    return ackDeadlineSeconds;
  }

  public void setAckDeadlineSeconds(Integer ackDeadlineSeconds) {
    this.ackDeadlineSeconds = ackDeadlineSeconds;
  }


  public Subscription bigqueryConfig(BigQueryConfig bigqueryConfig) {
    this.bigqueryConfig = bigqueryConfig;
    return this;
  }

  /**
   * Get bigqueryConfig
   * @return bigqueryConfig
   */
  @javax.annotation.Nullable
  public BigQueryConfig getBigqueryConfig() {
    return bigqueryConfig;
  }

  public void setBigqueryConfig(BigQueryConfig bigqueryConfig) {
    this.bigqueryConfig = bigqueryConfig;
  }


  public Subscription cloudStorageConfig(CloudStorageConfig cloudStorageConfig) {
    this.cloudStorageConfig = cloudStorageConfig;
    return this;
  }

  /**
   * Get cloudStorageConfig
   * @return cloudStorageConfig
   */
  @javax.annotation.Nullable
  public CloudStorageConfig getCloudStorageConfig() {
    return cloudStorageConfig;
  }

  public void setCloudStorageConfig(CloudStorageConfig cloudStorageConfig) {
    this.cloudStorageConfig = cloudStorageConfig;
  }


  public Subscription deadLetterPolicy(DeadLetterPolicy deadLetterPolicy) {
    this.deadLetterPolicy = deadLetterPolicy;
    return this;
  }

  /**
   * Get deadLetterPolicy
   * @return deadLetterPolicy
   */
  @javax.annotation.Nullable
  public DeadLetterPolicy getDeadLetterPolicy() {
    return deadLetterPolicy;
  }

  public void setDeadLetterPolicy(DeadLetterPolicy deadLetterPolicy) {
    this.deadLetterPolicy = deadLetterPolicy;
  }


  public Subscription detached(Boolean detached) {
    this.detached = detached;
    return this;
  }

  /**
   * Optional. Indicates whether the subscription is detached from its topic. Detached subscriptions don&#39;t receive messages from their topic and don&#39;t retain any backlog. &#x60;Pull&#x60; and &#x60;StreamingPull&#x60; requests will return FAILED_PRECONDITION. If the subscription is a push subscription, pushes to the endpoint will not be made.
   * @return detached
   */
  @javax.annotation.Nullable
  public Boolean getDetached() {
    return detached;
  }

  public void setDetached(Boolean detached) {
    this.detached = detached;
  }


  public Subscription enableExactlyOnceDelivery(Boolean enableExactlyOnceDelivery) {
    this.enableExactlyOnceDelivery = enableExactlyOnceDelivery;
    return this;
  }

  /**
   * Optional. If true, Pub/Sub provides the following guarantees for the delivery of a message with a given value of &#x60;message_id&#x60; on this subscription: * The message sent to a subscriber is guaranteed not to be resent before the message&#39;s acknowledgement deadline expires. * An acknowledged message will not be resent to a subscriber. Note that subscribers may still receive multiple copies of a message when &#x60;enable_exactly_once_delivery&#x60; is true if the message was published multiple times by a publisher client. These copies are considered distinct by Pub/Sub and have distinct &#x60;message_id&#x60; values.
   * @return enableExactlyOnceDelivery
   */
  @javax.annotation.Nullable
  public Boolean getEnableExactlyOnceDelivery() {
    return enableExactlyOnceDelivery;
  }

  public void setEnableExactlyOnceDelivery(Boolean enableExactlyOnceDelivery) {
    this.enableExactlyOnceDelivery = enableExactlyOnceDelivery;
  }


  public Subscription enableMessageOrdering(Boolean enableMessageOrdering) {
    this.enableMessageOrdering = enableMessageOrdering;
    return this;
  }

  /**
   * Optional. If true, messages published with the same &#x60;ordering_key&#x60; in &#x60;PubsubMessage&#x60; will be delivered to the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they may be delivered in any order.
   * @return enableMessageOrdering
   */
  @javax.annotation.Nullable
  public Boolean getEnableMessageOrdering() {
    return enableMessageOrdering;
  }

  public void setEnableMessageOrdering(Boolean enableMessageOrdering) {
    this.enableMessageOrdering = enableMessageOrdering;
  }


  public Subscription expirationPolicy(ExpirationPolicy expirationPolicy) {
    this.expirationPolicy = expirationPolicy;
    return this;
  }

  /**
   * Get expirationPolicy
   * @return expirationPolicy
   */
  @javax.annotation.Nullable
  public ExpirationPolicy getExpirationPolicy() {
    return expirationPolicy;
  }

  public void setExpirationPolicy(ExpirationPolicy expirationPolicy) {
    this.expirationPolicy = expirationPolicy;
  }


  public Subscription filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Optional. An expression written in the Pub/Sub [filter language](https://cloud.google.com/pubsub/docs/filtering). If non-empty, then only &#x60;PubsubMessage&#x60;s whose &#x60;attributes&#x60; field matches the filter are delivered on this subscription. If empty, then no messages are filtered out.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public Subscription labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Subscription putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. See [Creating and managing labels](https://cloud.google.com/pubsub/docs/labels).
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Subscription messageRetentionDuration(String messageRetentionDuration) {
    this.messageRetentionDuration = messageRetentionDuration;
    return this;
  }

  /**
   * Optional. How long to retain unacknowledged messages in the subscription&#39;s backlog, from the moment a message is published. If &#x60;retain_acked_messages&#x60; is true, then this also configures the retention of acknowledged messages, and thus configures how far back in time a &#x60;Seek&#x60; can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10 minutes.
   * @return messageRetentionDuration
   */
  @javax.annotation.Nullable
  public String getMessageRetentionDuration() {
    return messageRetentionDuration;
  }

  public void setMessageRetentionDuration(String messageRetentionDuration) {
    this.messageRetentionDuration = messageRetentionDuration;
  }


  public Subscription name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. The name of the subscription. It must have the format &#x60;\&quot;projects/{project}/subscriptions/{subscription}\&quot;&#x60;. &#x60;{subscription}&#x60; must start with a letter, and contain only letters (&#x60;[A-Za-z]&#x60;), numbers (&#x60;[0-9]&#x60;), dashes (&#x60;-&#x60;), underscores (&#x60;_&#x60;), periods (&#x60;.&#x60;), tildes (&#x60;~&#x60;), plus (&#x60;+&#x60;) or percent signs (&#x60;%&#x60;). It must be between 3 and 255 characters in length, and it must not start with &#x60;\&quot;goog\&quot;&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Subscription pushConfig(PushConfig pushConfig) {
    this.pushConfig = pushConfig;
    return this;
  }

  /**
   * Get pushConfig
   * @return pushConfig
   */
  @javax.annotation.Nullable
  public PushConfig getPushConfig() {
    return pushConfig;
  }

  public void setPushConfig(PushConfig pushConfig) {
    this.pushConfig = pushConfig;
  }


  public Subscription retainAckedMessages(Boolean retainAckedMessages) {
    this.retainAckedMessages = retainAckedMessages;
    return this;
  }

  /**
   * Optional. Indicates whether to retain acknowledged messages. If true, then messages are not expunged from the subscription&#39;s backlog, even if they are acknowledged, until they fall out of the &#x60;message_retention_duration&#x60; window. This must be true if you would like to [&#x60;Seek&#x60; to a timestamp] (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time) in the past to replay previously-acknowledged messages.
   * @return retainAckedMessages
   */
  @javax.annotation.Nullable
  public Boolean getRetainAckedMessages() {
    return retainAckedMessages;
  }

  public void setRetainAckedMessages(Boolean retainAckedMessages) {
    this.retainAckedMessages = retainAckedMessages;
  }


  public Subscription retryPolicy(RetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
    return this;
  }

  /**
   * Get retryPolicy
   * @return retryPolicy
   */
  @javax.annotation.Nullable
  public RetryPolicy getRetryPolicy() {
    return retryPolicy;
  }

  public void setRetryPolicy(RetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
  }


  /**
   * Output only. An output-only field indicating whether or not the subscription can receive messages.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  public Subscription topic(String topic) {
    this.topic = topic;
    return this;
  }

  /**
   * Required. The name of the topic from which this subscription is receiving messages. Format is &#x60;projects/{project}/topics/{topic}&#x60;. The value of this field will be &#x60;_deleted-topic_&#x60; if the topic has been deleted.
   * @return topic
   */
  @javax.annotation.Nullable
  public String getTopic() {
    return topic;
  }

  public void setTopic(String topic) {
    this.topic = topic;
  }


  /**
   * Output only. Indicates the minimum duration for which a message is retained after it is published to the subscription&#39;s topic. If this field is set, messages published to the subscription&#39;s topic in the last &#x60;topic_message_retention_duration&#x60; are always available to subscribers. See the &#x60;message_retention_duration&#x60; field in &#x60;Topic&#x60;. This field is set only in responses from the server; it is ignored if it is set in any requests.
   * @return topicMessageRetentionDuration
   */
  @javax.annotation.Nullable
  public String getTopicMessageRetentionDuration() {
    return topicMessageRetentionDuration;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Subscription subscription = (Subscription) o;
    return Objects.equals(this.ackDeadlineSeconds, subscription.ackDeadlineSeconds) &&
        Objects.equals(this.bigqueryConfig, subscription.bigqueryConfig) &&
        Objects.equals(this.cloudStorageConfig, subscription.cloudStorageConfig) &&
        Objects.equals(this.deadLetterPolicy, subscription.deadLetterPolicy) &&
        Objects.equals(this.detached, subscription.detached) &&
        Objects.equals(this.enableExactlyOnceDelivery, subscription.enableExactlyOnceDelivery) &&
        Objects.equals(this.enableMessageOrdering, subscription.enableMessageOrdering) &&
        Objects.equals(this.expirationPolicy, subscription.expirationPolicy) &&
        Objects.equals(this.filter, subscription.filter) &&
        Objects.equals(this.labels, subscription.labels) &&
        Objects.equals(this.messageRetentionDuration, subscription.messageRetentionDuration) &&
        Objects.equals(this.name, subscription.name) &&
        Objects.equals(this.pushConfig, subscription.pushConfig) &&
        Objects.equals(this.retainAckedMessages, subscription.retainAckedMessages) &&
        Objects.equals(this.retryPolicy, subscription.retryPolicy) &&
        Objects.equals(this.state, subscription.state) &&
        Objects.equals(this.topic, subscription.topic) &&
        Objects.equals(this.topicMessageRetentionDuration, subscription.topicMessageRetentionDuration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ackDeadlineSeconds, bigqueryConfig, cloudStorageConfig, deadLetterPolicy, detached, enableExactlyOnceDelivery, enableMessageOrdering, expirationPolicy, filter, labels, messageRetentionDuration, name, pushConfig, retainAckedMessages, retryPolicy, state, topic, topicMessageRetentionDuration);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Subscription {\n");
    sb.append("    ackDeadlineSeconds: ").append(toIndentedString(ackDeadlineSeconds)).append("\n");
    sb.append("    bigqueryConfig: ").append(toIndentedString(bigqueryConfig)).append("\n");
    sb.append("    cloudStorageConfig: ").append(toIndentedString(cloudStorageConfig)).append("\n");
    sb.append("    deadLetterPolicy: ").append(toIndentedString(deadLetterPolicy)).append("\n");
    sb.append("    detached: ").append(toIndentedString(detached)).append("\n");
    sb.append("    enableExactlyOnceDelivery: ").append(toIndentedString(enableExactlyOnceDelivery)).append("\n");
    sb.append("    enableMessageOrdering: ").append(toIndentedString(enableMessageOrdering)).append("\n");
    sb.append("    expirationPolicy: ").append(toIndentedString(expirationPolicy)).append("\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    messageRetentionDuration: ").append(toIndentedString(messageRetentionDuration)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    pushConfig: ").append(toIndentedString(pushConfig)).append("\n");
    sb.append("    retainAckedMessages: ").append(toIndentedString(retainAckedMessages)).append("\n");
    sb.append("    retryPolicy: ").append(toIndentedString(retryPolicy)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    topic: ").append(toIndentedString(topic)).append("\n");
    sb.append("    topicMessageRetentionDuration: ").append(toIndentedString(topicMessageRetentionDuration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ackDeadlineSeconds");
    openapiFields.add("bigqueryConfig");
    openapiFields.add("cloudStorageConfig");
    openapiFields.add("deadLetterPolicy");
    openapiFields.add("detached");
    openapiFields.add("enableExactlyOnceDelivery");
    openapiFields.add("enableMessageOrdering");
    openapiFields.add("expirationPolicy");
    openapiFields.add("filter");
    openapiFields.add("labels");
    openapiFields.add("messageRetentionDuration");
    openapiFields.add("name");
    openapiFields.add("pushConfig");
    openapiFields.add("retainAckedMessages");
    openapiFields.add("retryPolicy");
    openapiFields.add("state");
    openapiFields.add("topic");
    openapiFields.add("topicMessageRetentionDuration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Subscription
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Subscription.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Subscription is not found in the empty JSON string", Subscription.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Subscription.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Subscription` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `bigqueryConfig`
      if (jsonObj.get("bigqueryConfig") != null && !jsonObj.get("bigqueryConfig").isJsonNull()) {
        BigQueryConfig.validateJsonElement(jsonObj.get("bigqueryConfig"));
      }
      // validate the optional field `cloudStorageConfig`
      if (jsonObj.get("cloudStorageConfig") != null && !jsonObj.get("cloudStorageConfig").isJsonNull()) {
        CloudStorageConfig.validateJsonElement(jsonObj.get("cloudStorageConfig"));
      }
      // validate the optional field `deadLetterPolicy`
      if (jsonObj.get("deadLetterPolicy") != null && !jsonObj.get("deadLetterPolicy").isJsonNull()) {
        DeadLetterPolicy.validateJsonElement(jsonObj.get("deadLetterPolicy"));
      }
      // validate the optional field `expirationPolicy`
      if (jsonObj.get("expirationPolicy") != null && !jsonObj.get("expirationPolicy").isJsonNull()) {
        ExpirationPolicy.validateJsonElement(jsonObj.get("expirationPolicy"));
      }
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("messageRetentionDuration") != null && !jsonObj.get("messageRetentionDuration").isJsonNull()) && !jsonObj.get("messageRetentionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `messageRetentionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("messageRetentionDuration").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `pushConfig`
      if (jsonObj.get("pushConfig") != null && !jsonObj.get("pushConfig").isJsonNull()) {
        PushConfig.validateJsonElement(jsonObj.get("pushConfig"));
      }
      // validate the optional field `retryPolicy`
      if (jsonObj.get("retryPolicy") != null && !jsonObj.get("retryPolicy").isJsonNull()) {
        RetryPolicy.validateJsonElement(jsonObj.get("retryPolicy"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("topic") != null && !jsonObj.get("topic").isJsonNull()) && !jsonObj.get("topic").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `topic` to be a primitive type in the JSON string but got `%s`", jsonObj.get("topic").toString()));
      }
      if ((jsonObj.get("topicMessageRetentionDuration") != null && !jsonObj.get("topicMessageRetentionDuration").isJsonNull()) && !jsonObj.get("topicMessageRetentionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `topicMessageRetentionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("topicMessageRetentionDuration").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Subscription.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Subscription' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Subscription> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Subscription.class));

       return (TypeAdapter<T>) new TypeAdapter<Subscription>() {
           @Override
           public void write(JsonWriter out, Subscription value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Subscription read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Subscription given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Subscription
   * @throws IOException if the JSON string is invalid with respect to Subscription
   */
  public static Subscription fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Subscription.class);
  }

  /**
   * Convert an instance of Subscription to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

