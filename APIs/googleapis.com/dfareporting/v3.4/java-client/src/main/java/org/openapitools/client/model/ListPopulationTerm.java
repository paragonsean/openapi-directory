/*
 * Campaign Manager 360 API
 * Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.
 *
 * The version of the OpenAPI document: v3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Remarketing List Population Rule Term.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:31:16.070314-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ListPopulationTerm {
  public static final String SERIALIZED_NAME_CONTAINS = "contains";
  @SerializedName(SERIALIZED_NAME_CONTAINS)
  private Boolean contains;

  public static final String SERIALIZED_NAME_NEGATION = "negation";
  @SerializedName(SERIALIZED_NAME_NEGATION)
  private Boolean negation;

  /**
   * Comparison operator of this term. This field is only relevant when type is left unset or set to CUSTOM_VARIABLE_TERM or REFERRER_TERM.
   */
  @JsonAdapter(OperatorEnum.Adapter.class)
  public enum OperatorEnum {
    NUM_EQUALS("NUM_EQUALS"),
    
    NUM_LESS_THAN("NUM_LESS_THAN"),
    
    NUM_LESS_THAN_EQUAL("NUM_LESS_THAN_EQUAL"),
    
    NUM_GREATER_THAN("NUM_GREATER_THAN"),
    
    NUM_GREATER_THAN_EQUAL("NUM_GREATER_THAN_EQUAL"),
    
    STRING_EQUALS("STRING_EQUALS"),
    
    STRING_CONTAINS("STRING_CONTAINS");

    private String value;

    OperatorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OperatorEnum fromValue(String value) {
      for (OperatorEnum b : OperatorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OperatorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OperatorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OperatorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OperatorEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OperatorEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OPERATOR = "operator";
  @SerializedName(SERIALIZED_NAME_OPERATOR)
  private OperatorEnum operator;

  public static final String SERIALIZED_NAME_REMARKETING_LIST_ID = "remarketingListId";
  @SerializedName(SERIALIZED_NAME_REMARKETING_LIST_ID)
  private String remarketingListId;

  /**
   * List population term type determines the applicable fields in this object. If left unset or set to CUSTOM_VARIABLE_TERM, then variableName, variableFriendlyName, operator, value, and negation are applicable. If set to LIST_MEMBERSHIP_TERM then remarketingListId and contains are applicable. If set to REFERRER_TERM then operator, value, and negation are applicable.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    CUSTOM_VARIABLE_TERM("CUSTOM_VARIABLE_TERM"),
    
    LIST_MEMBERSHIP_TERM("LIST_MEMBERSHIP_TERM"),
    
    REFERRER_TERM("REFERRER_TERM");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private String value;

  public static final String SERIALIZED_NAME_VARIABLE_FRIENDLY_NAME = "variableFriendlyName";
  @SerializedName(SERIALIZED_NAME_VARIABLE_FRIENDLY_NAME)
  private String variableFriendlyName;

  public static final String SERIALIZED_NAME_VARIABLE_NAME = "variableName";
  @SerializedName(SERIALIZED_NAME_VARIABLE_NAME)
  private String variableName;

  public ListPopulationTerm() {
  }

  public ListPopulationTerm contains(Boolean contains) {
    this.contains = contains;
    return this;
  }

  /**
   * Will be true if the term should check if the user is in the list and false if the term should check if the user is not in the list. This field is only relevant when type is set to LIST_MEMBERSHIP_TERM. False by default.
   * @return contains
   */
  @javax.annotation.Nullable
  public Boolean getContains() {
    return contains;
  }

  public void setContains(Boolean contains) {
    this.contains = contains;
  }


  public ListPopulationTerm negation(Boolean negation) {
    this.negation = negation;
    return this;
  }

  /**
   * Whether to negate the comparison result of this term during rule evaluation. This field is only relevant when type is left unset or set to CUSTOM_VARIABLE_TERM or REFERRER_TERM.
   * @return negation
   */
  @javax.annotation.Nullable
  public Boolean getNegation() {
    return negation;
  }

  public void setNegation(Boolean negation) {
    this.negation = negation;
  }


  public ListPopulationTerm operator(OperatorEnum operator) {
    this.operator = operator;
    return this;
  }

  /**
   * Comparison operator of this term. This field is only relevant when type is left unset or set to CUSTOM_VARIABLE_TERM or REFERRER_TERM.
   * @return operator
   */
  @javax.annotation.Nullable
  public OperatorEnum getOperator() {
    return operator;
  }

  public void setOperator(OperatorEnum operator) {
    this.operator = operator;
  }


  public ListPopulationTerm remarketingListId(String remarketingListId) {
    this.remarketingListId = remarketingListId;
    return this;
  }

  /**
   * ID of the list in question. This field is only relevant when type is set to LIST_MEMBERSHIP_TERM.
   * @return remarketingListId
   */
  @javax.annotation.Nullable
  public String getRemarketingListId() {
    return remarketingListId;
  }

  public void setRemarketingListId(String remarketingListId) {
    this.remarketingListId = remarketingListId;
  }


  public ListPopulationTerm type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * List population term type determines the applicable fields in this object. If left unset or set to CUSTOM_VARIABLE_TERM, then variableName, variableFriendlyName, operator, value, and negation are applicable. If set to LIST_MEMBERSHIP_TERM then remarketingListId and contains are applicable. If set to REFERRER_TERM then operator, value, and negation are applicable.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public ListPopulationTerm value(String value) {
    this.value = value;
    return this;
  }

  /**
   * Literal to compare the variable to. This field is only relevant when type is left unset or set to CUSTOM_VARIABLE_TERM or REFERRER_TERM.
   * @return value
   */
  @javax.annotation.Nullable
  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }


  public ListPopulationTerm variableFriendlyName(String variableFriendlyName) {
    this.variableFriendlyName = variableFriendlyName;
    return this;
  }

  /**
   * Friendly name of this term&#39;s variable. This is a read-only, auto-generated field. This field is only relevant when type is left unset or set to CUSTOM_VARIABLE_TERM.
   * @return variableFriendlyName
   */
  @javax.annotation.Nullable
  public String getVariableFriendlyName() {
    return variableFriendlyName;
  }

  public void setVariableFriendlyName(String variableFriendlyName) {
    this.variableFriendlyName = variableFriendlyName;
  }


  public ListPopulationTerm variableName(String variableName) {
    this.variableName = variableName;
    return this;
  }

  /**
   * Name of the variable (U1, U2, etc.) being compared in this term. This field is only relevant when type is set to null, CUSTOM_VARIABLE_TERM or REFERRER_TERM.
   * @return variableName
   */
  @javax.annotation.Nullable
  public String getVariableName() {
    return variableName;
  }

  public void setVariableName(String variableName) {
    this.variableName = variableName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ListPopulationTerm listPopulationTerm = (ListPopulationTerm) o;
    return Objects.equals(this.contains, listPopulationTerm.contains) &&
        Objects.equals(this.negation, listPopulationTerm.negation) &&
        Objects.equals(this.operator, listPopulationTerm.operator) &&
        Objects.equals(this.remarketingListId, listPopulationTerm.remarketingListId) &&
        Objects.equals(this.type, listPopulationTerm.type) &&
        Objects.equals(this.value, listPopulationTerm.value) &&
        Objects.equals(this.variableFriendlyName, listPopulationTerm.variableFriendlyName) &&
        Objects.equals(this.variableName, listPopulationTerm.variableName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(contains, negation, operator, remarketingListId, type, value, variableFriendlyName, variableName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ListPopulationTerm {\n");
    sb.append("    contains: ").append(toIndentedString(contains)).append("\n");
    sb.append("    negation: ").append(toIndentedString(negation)).append("\n");
    sb.append("    operator: ").append(toIndentedString(operator)).append("\n");
    sb.append("    remarketingListId: ").append(toIndentedString(remarketingListId)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    variableFriendlyName: ").append(toIndentedString(variableFriendlyName)).append("\n");
    sb.append("    variableName: ").append(toIndentedString(variableName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("contains");
    openapiFields.add("negation");
    openapiFields.add("operator");
    openapiFields.add("remarketingListId");
    openapiFields.add("type");
    openapiFields.add("value");
    openapiFields.add("variableFriendlyName");
    openapiFields.add("variableName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ListPopulationTerm
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ListPopulationTerm.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ListPopulationTerm is not found in the empty JSON string", ListPopulationTerm.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ListPopulationTerm.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ListPopulationTerm` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("operator") != null && !jsonObj.get("operator").isJsonNull()) && !jsonObj.get("operator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `operator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("operator").toString()));
      }
      // validate the optional field `operator`
      if (jsonObj.get("operator") != null && !jsonObj.get("operator").isJsonNull()) {
        OperatorEnum.validateJsonElement(jsonObj.get("operator"));
      }
      if ((jsonObj.get("remarketingListId") != null && !jsonObj.get("remarketingListId").isJsonNull()) && !jsonObj.get("remarketingListId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `remarketingListId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("remarketingListId").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
      if ((jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) && !jsonObj.get("value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("value").toString()));
      }
      if ((jsonObj.get("variableFriendlyName") != null && !jsonObj.get("variableFriendlyName").isJsonNull()) && !jsonObj.get("variableFriendlyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `variableFriendlyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("variableFriendlyName").toString()));
      }
      if ((jsonObj.get("variableName") != null && !jsonObj.get("variableName").isJsonNull()) && !jsonObj.get("variableName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `variableName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("variableName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ListPopulationTerm.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ListPopulationTerm' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ListPopulationTerm> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ListPopulationTerm.class));

       return (TypeAdapter<T>) new TypeAdapter<ListPopulationTerm>() {
           @Override
           public void write(JsonWriter out, ListPopulationTerm value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ListPopulationTerm read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ListPopulationTerm given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ListPopulationTerm
   * @throws IOException if the JSON string is invalid with respect to ListPopulationTerm
   */
  public static ListPopulationTerm fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ListPopulationTerm.class);
  }

  /**
   * Convert an instance of ListPopulationTerm to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

