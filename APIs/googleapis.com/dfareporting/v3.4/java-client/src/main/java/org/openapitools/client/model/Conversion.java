/*
 * Campaign Manager 360 API
 * Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.
 *
 * The version of the OpenAPI document: v3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CustomFloodlightVariable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Conversion represents when a user successfully performs a desired action after seeing an ad.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:31:16.070314-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Conversion {
  public static final String SERIALIZED_NAME_CHILD_DIRECTED_TREATMENT = "childDirectedTreatment";
  @SerializedName(SERIALIZED_NAME_CHILD_DIRECTED_TREATMENT)
  private Boolean childDirectedTreatment;

  public static final String SERIALIZED_NAME_CUSTOM_VARIABLES = "customVariables";
  @SerializedName(SERIALIZED_NAME_CUSTOM_VARIABLES)
  private List<CustomFloodlightVariable> customVariables = new ArrayList<>();

  public static final String SERIALIZED_NAME_DCLID = "dclid";
  @SerializedName(SERIALIZED_NAME_DCLID)
  private String dclid;

  public static final String SERIALIZED_NAME_ENCRYPTED_USER_ID = "encryptedUserId";
  @SerializedName(SERIALIZED_NAME_ENCRYPTED_USER_ID)
  private String encryptedUserId;

  public static final String SERIALIZED_NAME_ENCRYPTED_USER_ID_CANDIDATES = "encryptedUserIdCandidates";
  @SerializedName(SERIALIZED_NAME_ENCRYPTED_USER_ID_CANDIDATES)
  private List<String> encryptedUserIdCandidates = new ArrayList<>();

  public static final String SERIALIZED_NAME_FLOODLIGHT_ACTIVITY_ID = "floodlightActivityId";
  @SerializedName(SERIALIZED_NAME_FLOODLIGHT_ACTIVITY_ID)
  private String floodlightActivityId;

  public static final String SERIALIZED_NAME_FLOODLIGHT_CONFIGURATION_ID = "floodlightConfigurationId";
  @SerializedName(SERIALIZED_NAME_FLOODLIGHT_CONFIGURATION_ID)
  private String floodlightConfigurationId;

  public static final String SERIALIZED_NAME_GCLID = "gclid";
  @SerializedName(SERIALIZED_NAME_GCLID)
  private String gclid;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_LIMIT_AD_TRACKING = "limitAdTracking";
  @SerializedName(SERIALIZED_NAME_LIMIT_AD_TRACKING)
  private Boolean limitAdTracking;

  public static final String SERIALIZED_NAME_MATCH_ID = "matchId";
  @SerializedName(SERIALIZED_NAME_MATCH_ID)
  private String matchId;

  public static final String SERIALIZED_NAME_MOBILE_DEVICE_ID = "mobileDeviceId";
  @SerializedName(SERIALIZED_NAME_MOBILE_DEVICE_ID)
  private String mobileDeviceId;

  public static final String SERIALIZED_NAME_NON_PERSONALIZED_AD = "nonPersonalizedAd";
  @SerializedName(SERIALIZED_NAME_NON_PERSONALIZED_AD)
  private Boolean nonPersonalizedAd;

  public static final String SERIALIZED_NAME_ORDINAL = "ordinal";
  @SerializedName(SERIALIZED_NAME_ORDINAL)
  private String ordinal;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private String quantity;

  public static final String SERIALIZED_NAME_TIMESTAMP_MICROS = "timestampMicros";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_MICROS)
  private String timestampMicros;

  public static final String SERIALIZED_NAME_TREATMENT_FOR_UNDERAGE = "treatmentForUnderage";
  @SerializedName(SERIALIZED_NAME_TREATMENT_FOR_UNDERAGE)
  private Boolean treatmentForUnderage;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private Double value;

  public Conversion() {
  }

  public Conversion childDirectedTreatment(Boolean childDirectedTreatment) {
    this.childDirectedTreatment = childDirectedTreatment;
    return this;
  }

  /**
   * Whether this particular request may come from a user under the age of 13, under COPPA compliance.
   * @return childDirectedTreatment
   */
  @javax.annotation.Nullable
  public Boolean getChildDirectedTreatment() {
    return childDirectedTreatment;
  }

  public void setChildDirectedTreatment(Boolean childDirectedTreatment) {
    this.childDirectedTreatment = childDirectedTreatment;
  }


  public Conversion customVariables(List<CustomFloodlightVariable> customVariables) {
    this.customVariables = customVariables;
    return this;
  }

  public Conversion addCustomVariablesItem(CustomFloodlightVariable customVariablesItem) {
    if (this.customVariables == null) {
      this.customVariables = new ArrayList<>();
    }
    this.customVariables.add(customVariablesItem);
    return this;
  }

  /**
   * Custom floodlight variables. This field may only be used when calling batchinsert; it is not supported by batchupdate.
   * @return customVariables
   */
  @javax.annotation.Nullable
  public List<CustomFloodlightVariable> getCustomVariables() {
    return customVariables;
  }

  public void setCustomVariables(List<CustomFloodlightVariable> customVariables) {
    this.customVariables = customVariables;
  }


  public Conversion dclid(String dclid) {
    this.dclid = dclid;
    return this;
  }

  /**
   * The display click ID. This field is mutually exclusive with encryptedUserId, encryptedUserIdCandidates[], matchId, mobileDeviceId and gclid. This or encryptedUserId or encryptedUserIdCandidates[] or matchId or mobileDeviceId or gclid is a required field.
   * @return dclid
   */
  @javax.annotation.Nullable
  public String getDclid() {
    return dclid;
  }

  public void setDclid(String dclid) {
    this.dclid = dclid;
  }


  public Conversion encryptedUserId(String encryptedUserId) {
    this.encryptedUserId = encryptedUserId;
    return this;
  }

  /**
   * The alphanumeric encrypted user ID. When set, encryptionInfo should also be specified. This field is mutually exclusive with encryptedUserIdCandidates[], matchId, mobileDeviceId, gclid and dclid. This or encryptedUserIdCandidates[] or matchId or mobileDeviceId or gclid or dclid is a required field.
   * @return encryptedUserId
   */
  @javax.annotation.Nullable
  public String getEncryptedUserId() {
    return encryptedUserId;
  }

  public void setEncryptedUserId(String encryptedUserId) {
    this.encryptedUserId = encryptedUserId;
  }


  public Conversion encryptedUserIdCandidates(List<String> encryptedUserIdCandidates) {
    this.encryptedUserIdCandidates = encryptedUserIdCandidates;
    return this;
  }

  public Conversion addEncryptedUserIdCandidatesItem(String encryptedUserIdCandidatesItem) {
    if (this.encryptedUserIdCandidates == null) {
      this.encryptedUserIdCandidates = new ArrayList<>();
    }
    this.encryptedUserIdCandidates.add(encryptedUserIdCandidatesItem);
    return this;
  }

  /**
   * A list of the alphanumeric encrypted user IDs. Any user ID with exposure prior to the conversion timestamp will be used in the inserted conversion. If no such user ID is found then the conversion will be rejected with INVALID_ARGUMENT error. When set, encryptionInfo should also be specified. This field may only be used when calling batchinsert; it is not supported by batchupdate. This field is mutually exclusive with encryptedUserId, matchId, mobileDeviceId, gclid and dclid. This or encryptedUserId or matchId or mobileDeviceId or gclid or dclid is a required field.
   * @return encryptedUserIdCandidates
   */
  @javax.annotation.Nullable
  public List<String> getEncryptedUserIdCandidates() {
    return encryptedUserIdCandidates;
  }

  public void setEncryptedUserIdCandidates(List<String> encryptedUserIdCandidates) {
    this.encryptedUserIdCandidates = encryptedUserIdCandidates;
  }


  public Conversion floodlightActivityId(String floodlightActivityId) {
    this.floodlightActivityId = floodlightActivityId;
    return this;
  }

  /**
   * Floodlight Activity ID of this conversion. This is a required field.
   * @return floodlightActivityId
   */
  @javax.annotation.Nullable
  public String getFloodlightActivityId() {
    return floodlightActivityId;
  }

  public void setFloodlightActivityId(String floodlightActivityId) {
    this.floodlightActivityId = floodlightActivityId;
  }


  public Conversion floodlightConfigurationId(String floodlightConfigurationId) {
    this.floodlightConfigurationId = floodlightConfigurationId;
    return this;
  }

  /**
   * Floodlight Configuration ID of this conversion. This is a required field.
   * @return floodlightConfigurationId
   */
  @javax.annotation.Nullable
  public String getFloodlightConfigurationId() {
    return floodlightConfigurationId;
  }

  public void setFloodlightConfigurationId(String floodlightConfigurationId) {
    this.floodlightConfigurationId = floodlightConfigurationId;
  }


  public Conversion gclid(String gclid) {
    this.gclid = gclid;
    return this;
  }

  /**
   * The Google click ID. This field is mutually exclusive with encryptedUserId, encryptedUserIdCandidates[], matchId, mobileDeviceId and dclid. This or encryptedUserId or encryptedUserIdCandidates[] or matchId or mobileDeviceId or dclid is a required field.
   * @return gclid
   */
  @javax.annotation.Nullable
  public String getGclid() {
    return gclid;
  }

  public void setGclid(String gclid) {
    this.gclid = gclid;
  }


  public Conversion kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Identifies what kind of resource this is. Value: the fixed string \&quot;dfareporting#conversion\&quot;.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Conversion limitAdTracking(Boolean limitAdTracking) {
    this.limitAdTracking = limitAdTracking;
    return this;
  }

  /**
   * Whether Limit Ad Tracking is enabled. When set to true, the conversion will be used for reporting but not targeting. This will prevent remarketing.
   * @return limitAdTracking
   */
  @javax.annotation.Nullable
  public Boolean getLimitAdTracking() {
    return limitAdTracking;
  }

  public void setLimitAdTracking(Boolean limitAdTracking) {
    this.limitAdTracking = limitAdTracking;
  }


  public Conversion matchId(String matchId) {
    this.matchId = matchId;
    return this;
  }

  /**
   * The match ID field. A match ID is your own first-party identifier that has been synced with Google using the match ID feature in Floodlight. This field is mutually exclusive with encryptedUserId, encryptedUserIdCandidates[],mobileDeviceId, gclid and dclid. This or encryptedUserId or encryptedUserIdCandidates[] or mobileDeviceId or gclid or dclid is a required field.
   * @return matchId
   */
  @javax.annotation.Nullable
  public String getMatchId() {
    return matchId;
  }

  public void setMatchId(String matchId) {
    this.matchId = matchId;
  }


  public Conversion mobileDeviceId(String mobileDeviceId) {
    this.mobileDeviceId = mobileDeviceId;
    return this;
  }

  /**
   * The mobile device ID. This field is mutually exclusive with encryptedUserId, encryptedUserIdCandidates[], matchId, gclid and dclid. This or encryptedUserId or encryptedUserIdCandidates[] or matchId or gclid or dclid is a required field.
   * @return mobileDeviceId
   */
  @javax.annotation.Nullable
  public String getMobileDeviceId() {
    return mobileDeviceId;
  }

  public void setMobileDeviceId(String mobileDeviceId) {
    this.mobileDeviceId = mobileDeviceId;
  }


  public Conversion nonPersonalizedAd(Boolean nonPersonalizedAd) {
    this.nonPersonalizedAd = nonPersonalizedAd;
    return this;
  }

  /**
   * Whether the conversion was for a non personalized ad.
   * @return nonPersonalizedAd
   */
  @javax.annotation.Nullable
  public Boolean getNonPersonalizedAd() {
    return nonPersonalizedAd;
  }

  public void setNonPersonalizedAd(Boolean nonPersonalizedAd) {
    this.nonPersonalizedAd = nonPersonalizedAd;
  }


  public Conversion ordinal(String ordinal) {
    this.ordinal = ordinal;
    return this;
  }

  /**
   * The ordinal of the conversion. Use this field to control how conversions of the same user and day are de-duplicated. This is a required field.
   * @return ordinal
   */
  @javax.annotation.Nullable
  public String getOrdinal() {
    return ordinal;
  }

  public void setOrdinal(String ordinal) {
    this.ordinal = ordinal;
  }


  public Conversion quantity(String quantity) {
    this.quantity = quantity;
    return this;
  }

  /**
   * The quantity of the conversion.
   * @return quantity
   */
  @javax.annotation.Nullable
  public String getQuantity() {
    return quantity;
  }

  public void setQuantity(String quantity) {
    this.quantity = quantity;
  }


  public Conversion timestampMicros(String timestampMicros) {
    this.timestampMicros = timestampMicros;
    return this;
  }

  /**
   * The timestamp of conversion, in Unix epoch micros. This is a required field.
   * @return timestampMicros
   */
  @javax.annotation.Nullable
  public String getTimestampMicros() {
    return timestampMicros;
  }

  public void setTimestampMicros(String timestampMicros) {
    this.timestampMicros = timestampMicros;
  }


  public Conversion treatmentForUnderage(Boolean treatmentForUnderage) {
    this.treatmentForUnderage = treatmentForUnderage;
    return this;
  }

  /**
   * Whether this particular request may come from a user under the age of 16 (may differ by country), under compliance with the European Union&#39;s General Data Protection Regulation (GDPR).
   * @return treatmentForUnderage
   */
  @javax.annotation.Nullable
  public Boolean getTreatmentForUnderage() {
    return treatmentForUnderage;
  }

  public void setTreatmentForUnderage(Boolean treatmentForUnderage) {
    this.treatmentForUnderage = treatmentForUnderage;
  }


  public Conversion value(Double value) {
    this.value = value;
    return this;
  }

  /**
   * The value of the conversion.
   * @return value
   */
  @javax.annotation.Nullable
  public Double getValue() {
    return value;
  }

  public void setValue(Double value) {
    this.value = value;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Conversion conversion = (Conversion) o;
    return Objects.equals(this.childDirectedTreatment, conversion.childDirectedTreatment) &&
        Objects.equals(this.customVariables, conversion.customVariables) &&
        Objects.equals(this.dclid, conversion.dclid) &&
        Objects.equals(this.encryptedUserId, conversion.encryptedUserId) &&
        Objects.equals(this.encryptedUserIdCandidates, conversion.encryptedUserIdCandidates) &&
        Objects.equals(this.floodlightActivityId, conversion.floodlightActivityId) &&
        Objects.equals(this.floodlightConfigurationId, conversion.floodlightConfigurationId) &&
        Objects.equals(this.gclid, conversion.gclid) &&
        Objects.equals(this.kind, conversion.kind) &&
        Objects.equals(this.limitAdTracking, conversion.limitAdTracking) &&
        Objects.equals(this.matchId, conversion.matchId) &&
        Objects.equals(this.mobileDeviceId, conversion.mobileDeviceId) &&
        Objects.equals(this.nonPersonalizedAd, conversion.nonPersonalizedAd) &&
        Objects.equals(this.ordinal, conversion.ordinal) &&
        Objects.equals(this.quantity, conversion.quantity) &&
        Objects.equals(this.timestampMicros, conversion.timestampMicros) &&
        Objects.equals(this.treatmentForUnderage, conversion.treatmentForUnderage) &&
        Objects.equals(this.value, conversion.value);
  }

  @Override
  public int hashCode() {
    return Objects.hash(childDirectedTreatment, customVariables, dclid, encryptedUserId, encryptedUserIdCandidates, floodlightActivityId, floodlightConfigurationId, gclid, kind, limitAdTracking, matchId, mobileDeviceId, nonPersonalizedAd, ordinal, quantity, timestampMicros, treatmentForUnderage, value);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Conversion {\n");
    sb.append("    childDirectedTreatment: ").append(toIndentedString(childDirectedTreatment)).append("\n");
    sb.append("    customVariables: ").append(toIndentedString(customVariables)).append("\n");
    sb.append("    dclid: ").append(toIndentedString(dclid)).append("\n");
    sb.append("    encryptedUserId: ").append(toIndentedString(encryptedUserId)).append("\n");
    sb.append("    encryptedUserIdCandidates: ").append(toIndentedString(encryptedUserIdCandidates)).append("\n");
    sb.append("    floodlightActivityId: ").append(toIndentedString(floodlightActivityId)).append("\n");
    sb.append("    floodlightConfigurationId: ").append(toIndentedString(floodlightConfigurationId)).append("\n");
    sb.append("    gclid: ").append(toIndentedString(gclid)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    limitAdTracking: ").append(toIndentedString(limitAdTracking)).append("\n");
    sb.append("    matchId: ").append(toIndentedString(matchId)).append("\n");
    sb.append("    mobileDeviceId: ").append(toIndentedString(mobileDeviceId)).append("\n");
    sb.append("    nonPersonalizedAd: ").append(toIndentedString(nonPersonalizedAd)).append("\n");
    sb.append("    ordinal: ").append(toIndentedString(ordinal)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    timestampMicros: ").append(toIndentedString(timestampMicros)).append("\n");
    sb.append("    treatmentForUnderage: ").append(toIndentedString(treatmentForUnderage)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("childDirectedTreatment");
    openapiFields.add("customVariables");
    openapiFields.add("dclid");
    openapiFields.add("encryptedUserId");
    openapiFields.add("encryptedUserIdCandidates");
    openapiFields.add("floodlightActivityId");
    openapiFields.add("floodlightConfigurationId");
    openapiFields.add("gclid");
    openapiFields.add("kind");
    openapiFields.add("limitAdTracking");
    openapiFields.add("matchId");
    openapiFields.add("mobileDeviceId");
    openapiFields.add("nonPersonalizedAd");
    openapiFields.add("ordinal");
    openapiFields.add("quantity");
    openapiFields.add("timestampMicros");
    openapiFields.add("treatmentForUnderage");
    openapiFields.add("value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Conversion
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Conversion.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Conversion is not found in the empty JSON string", Conversion.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Conversion.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Conversion` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("customVariables") != null && !jsonObj.get("customVariables").isJsonNull()) {
        JsonArray jsonArraycustomVariables = jsonObj.getAsJsonArray("customVariables");
        if (jsonArraycustomVariables != null) {
          // ensure the json data is an array
          if (!jsonObj.get("customVariables").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `customVariables` to be an array in the JSON string but got `%s`", jsonObj.get("customVariables").toString()));
          }

          // validate the optional field `customVariables` (array)
          for (int i = 0; i < jsonArraycustomVariables.size(); i++) {
            CustomFloodlightVariable.validateJsonElement(jsonArraycustomVariables.get(i));
          };
        }
      }
      if ((jsonObj.get("dclid") != null && !jsonObj.get("dclid").isJsonNull()) && !jsonObj.get("dclid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dclid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dclid").toString()));
      }
      if ((jsonObj.get("encryptedUserId") != null && !jsonObj.get("encryptedUserId").isJsonNull()) && !jsonObj.get("encryptedUserId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptedUserId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encryptedUserId").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("encryptedUserIdCandidates") != null && !jsonObj.get("encryptedUserIdCandidates").isJsonNull() && !jsonObj.get("encryptedUserIdCandidates").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptedUserIdCandidates` to be an array in the JSON string but got `%s`", jsonObj.get("encryptedUserIdCandidates").toString()));
      }
      if ((jsonObj.get("floodlightActivityId") != null && !jsonObj.get("floodlightActivityId").isJsonNull()) && !jsonObj.get("floodlightActivityId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `floodlightActivityId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("floodlightActivityId").toString()));
      }
      if ((jsonObj.get("floodlightConfigurationId") != null && !jsonObj.get("floodlightConfigurationId").isJsonNull()) && !jsonObj.get("floodlightConfigurationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `floodlightConfigurationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("floodlightConfigurationId").toString()));
      }
      if ((jsonObj.get("gclid") != null && !jsonObj.get("gclid").isJsonNull()) && !jsonObj.get("gclid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gclid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gclid").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("matchId") != null && !jsonObj.get("matchId").isJsonNull()) && !jsonObj.get("matchId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchId").toString()));
      }
      if ((jsonObj.get("mobileDeviceId") != null && !jsonObj.get("mobileDeviceId").isJsonNull()) && !jsonObj.get("mobileDeviceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mobileDeviceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mobileDeviceId").toString()));
      }
      if ((jsonObj.get("ordinal") != null && !jsonObj.get("ordinal").isJsonNull()) && !jsonObj.get("ordinal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ordinal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ordinal").toString()));
      }
      if ((jsonObj.get("quantity") != null && !jsonObj.get("quantity").isJsonNull()) && !jsonObj.get("quantity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quantity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quantity").toString()));
      }
      if ((jsonObj.get("timestampMicros") != null && !jsonObj.get("timestampMicros").isJsonNull()) && !jsonObj.get("timestampMicros").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestampMicros` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestampMicros").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Conversion.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Conversion' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Conversion> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Conversion.class));

       return (TypeAdapter<T>) new TypeAdapter<Conversion>() {
           @Override
           public void write(JsonWriter out, Conversion value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Conversion read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Conversion given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Conversion
   * @throws IOException if the JSON string is invalid with respect to Conversion
   */
  public static Conversion fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Conversion.class);
  }

  /**
   * Convert an instance of Conversion to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

