/*
 * AI Platform Training & Prediction API
 * An API to enable creating and using machine learning models.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * All parameters related to scheduling of training jobs.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:13.643536-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudMlV1Scheduling {
  public static final String SERIALIZED_NAME_MAX_RUNNING_TIME = "maxRunningTime";
  @SerializedName(SERIALIZED_NAME_MAX_RUNNING_TIME)
  private String maxRunningTime;

  public static final String SERIALIZED_NAME_MAX_WAIT_TIME = "maxWaitTime";
  @SerializedName(SERIALIZED_NAME_MAX_WAIT_TIME)
  private String maxWaitTime;

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private Integer priority;

  public GoogleCloudMlV1Scheduling() {
  }

  public GoogleCloudMlV1Scheduling maxRunningTime(String maxRunningTime) {
    this.maxRunningTime = maxRunningTime;
    return this;
  }

  /**
   * Optional. The maximum job running time, expressed in seconds. The field can contain up to nine fractional digits, terminated by &#x60;s&#x60;. If not specified, this field defaults to &#x60;604800s&#x60; (seven days). If the training job is still running after this duration, AI Platform Training cancels it. The duration is measured from when the job enters the &#x60;RUNNING&#x60; state; therefore it does not overlap with the duration limited by Scheduling.max_wait_time. For example, if you want to ensure your job runs for no more than 2 hours, set this field to &#x60;7200s&#x60; (2 hours * 60 minutes / hour * 60 seconds / minute). If you submit your training job using the &#x60;gcloud&#x60; tool, you can [specify this field in a &#x60;config.yaml&#x60; file](/ai-platform/training/docs/training-jobs#formatting_your_configuration_parameters). For example: &#x60;&#x60;&#x60;yaml trainingInput: scheduling: maxRunningTime: 7200s &#x60;&#x60;&#x60;
   * @return maxRunningTime
   */
  @javax.annotation.Nullable
  public String getMaxRunningTime() {
    return maxRunningTime;
  }

  public void setMaxRunningTime(String maxRunningTime) {
    this.maxRunningTime = maxRunningTime;
  }


  public GoogleCloudMlV1Scheduling maxWaitTime(String maxWaitTime) {
    this.maxWaitTime = maxWaitTime;
    return this;
  }

  /**
   * Optional. The maximum job wait time, expressed in seconds. The field can contain up to nine fractional digits, terminated by &#x60;s&#x60;. If not specified, there is no limit to the wait time. The minimum for this field is &#x60;1800s&#x60; (30 minutes). If the training job has not entered the &#x60;RUNNING&#x60; state after this duration, AI Platform Training cancels it. After the job begins running, it can no longer be cancelled due to the maximum wait time. Therefore the duration limited by this field does not overlap with the duration limited by Scheduling.max_running_time. For example, if the job temporarily stops running and retries due to a [VM restart](/ai-platform/training/docs/overview#restarts), this cannot lead to a maximum wait time cancellation. However, independently of this constraint, AI Platform Training might stop a job if there are too many retries due to exhausted resources in a region. The following example describes how you might use this field: To cancel your job if it doesn&#39;t start running within 1 hour, set this field to &#x60;3600s&#x60; (1 hour * 60 minutes / hour * 60 seconds / minute). If the job is still in the &#x60;QUEUED&#x60; or &#x60;PREPARING&#x60; state after an hour of waiting, AI Platform Training cancels the job. If you submit your training job using the &#x60;gcloud&#x60; tool, you can [specify this field in a &#x60;config.yaml&#x60; file](/ai-platform/training/docs/training-jobs#formatting_your_configuration_parameters). For example: &#x60;&#x60;&#x60;yaml trainingInput: scheduling: maxWaitTime: 3600s &#x60;&#x60;&#x60;
   * @return maxWaitTime
   */
  @javax.annotation.Nullable
  public String getMaxWaitTime() {
    return maxWaitTime;
  }

  public void setMaxWaitTime(String maxWaitTime) {
    this.maxWaitTime = maxWaitTime;
  }


  public GoogleCloudMlV1Scheduling priority(Integer priority) {
    this.priority = priority;
    return this;
  }

  /**
   * Optional. Job scheduling will be based on this priority, which in the range [0, 1000]. The bigger the number, the higher the priority. Default to 0 if not set. If there are multiple jobs requesting same type of accelerators, the high priority job will be scheduled prior to ones with low priority.
   * @return priority
   */
  @javax.annotation.Nullable
  public Integer getPriority() {
    return priority;
  }

  public void setPriority(Integer priority) {
    this.priority = priority;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudMlV1Scheduling googleCloudMlV1Scheduling = (GoogleCloudMlV1Scheduling) o;
    return Objects.equals(this.maxRunningTime, googleCloudMlV1Scheduling.maxRunningTime) &&
        Objects.equals(this.maxWaitTime, googleCloudMlV1Scheduling.maxWaitTime) &&
        Objects.equals(this.priority, googleCloudMlV1Scheduling.priority);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxRunningTime, maxWaitTime, priority);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudMlV1Scheduling {\n");
    sb.append("    maxRunningTime: ").append(toIndentedString(maxRunningTime)).append("\n");
    sb.append("    maxWaitTime: ").append(toIndentedString(maxWaitTime)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxRunningTime");
    openapiFields.add("maxWaitTime");
    openapiFields.add("priority");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudMlV1Scheduling
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudMlV1Scheduling.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudMlV1Scheduling is not found in the empty JSON string", GoogleCloudMlV1Scheduling.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudMlV1Scheduling.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudMlV1Scheduling` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("maxRunningTime") != null && !jsonObj.get("maxRunningTime").isJsonNull()) && !jsonObj.get("maxRunningTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxRunningTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxRunningTime").toString()));
      }
      if ((jsonObj.get("maxWaitTime") != null && !jsonObj.get("maxWaitTime").isJsonNull()) && !jsonObj.get("maxWaitTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxWaitTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxWaitTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudMlV1Scheduling.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudMlV1Scheduling' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudMlV1Scheduling> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudMlV1Scheduling.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudMlV1Scheduling>() {
           @Override
           public void write(JsonWriter out, GoogleCloudMlV1Scheduling value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudMlV1Scheduling read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudMlV1Scheduling given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudMlV1Scheduling
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudMlV1Scheduling
   */
  public static GoogleCloudMlV1Scheduling fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudMlV1Scheduling.class);
  }

  /**
   * Convert an instance of GoogleCloudMlV1Scheduling to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

