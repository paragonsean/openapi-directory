/*
 * AI Platform Training & Prediction API
 * An API to enable creating and using machine learning models.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleCloudMlV1AcceleratorConfig;
import org.openapitools.client.model.GoogleCloudMlV1DiskConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the configuration for a replica in a cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:13.643536-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudMlV1ReplicaConfig {
  public static final String SERIALIZED_NAME_ACCELERATOR_CONFIG = "acceleratorConfig";
  @SerializedName(SERIALIZED_NAME_ACCELERATOR_CONFIG)
  private GoogleCloudMlV1AcceleratorConfig acceleratorConfig;

  public static final String SERIALIZED_NAME_CONTAINER_ARGS = "containerArgs";
  @SerializedName(SERIALIZED_NAME_CONTAINER_ARGS)
  private List<String> containerArgs = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTAINER_COMMAND = "containerCommand";
  @SerializedName(SERIALIZED_NAME_CONTAINER_COMMAND)
  private List<String> containerCommand = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISK_CONFIG = "diskConfig";
  @SerializedName(SERIALIZED_NAME_DISK_CONFIG)
  private GoogleCloudMlV1DiskConfig diskConfig;

  public static final String SERIALIZED_NAME_IMAGE_URI = "imageUri";
  @SerializedName(SERIALIZED_NAME_IMAGE_URI)
  private String imageUri;

  public static final String SERIALIZED_NAME_TPU_TF_VERSION = "tpuTfVersion";
  @SerializedName(SERIALIZED_NAME_TPU_TF_VERSION)
  private String tpuTfVersion;

  public GoogleCloudMlV1ReplicaConfig() {
  }

  public GoogleCloudMlV1ReplicaConfig acceleratorConfig(GoogleCloudMlV1AcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
    return this;
  }

  /**
   * Get acceleratorConfig
   * @return acceleratorConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudMlV1AcceleratorConfig getAcceleratorConfig() {
    return acceleratorConfig;
  }

  public void setAcceleratorConfig(GoogleCloudMlV1AcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
  }


  public GoogleCloudMlV1ReplicaConfig containerArgs(List<String> containerArgs) {
    this.containerArgs = containerArgs;
    return this;
  }

  public GoogleCloudMlV1ReplicaConfig addContainerArgsItem(String containerArgsItem) {
    if (this.containerArgs == null) {
      this.containerArgs = new ArrayList<>();
    }
    this.containerArgs.add(containerArgsItem);
    return this;
  }

  /**
   * Arguments to the entrypoint command. The following rules apply for container_command and container_args: - If you do not supply command or args: The defaults defined in the Docker image are used. - If you supply a command but no args: The default EntryPoint and the default Cmd defined in the Docker image are ignored. Your command is run without any arguments. - If you supply only args: The default Entrypoint defined in the Docker image is run with the args that you supplied. - If you supply a command and args: The default Entrypoint and the default Cmd defined in the Docker image are ignored. Your command is run with your args. It cannot be set if custom container image is not provided. Note that this field and [TrainingInput.args] are mutually exclusive, i.e., both cannot be set at the same time.
   * @return containerArgs
   */
  @javax.annotation.Nullable
  public List<String> getContainerArgs() {
    return containerArgs;
  }

  public void setContainerArgs(List<String> containerArgs) {
    this.containerArgs = containerArgs;
  }


  public GoogleCloudMlV1ReplicaConfig containerCommand(List<String> containerCommand) {
    this.containerCommand = containerCommand;
    return this;
  }

  public GoogleCloudMlV1ReplicaConfig addContainerCommandItem(String containerCommandItem) {
    if (this.containerCommand == null) {
      this.containerCommand = new ArrayList<>();
    }
    this.containerCommand.add(containerCommandItem);
    return this;
  }

  /**
   * The command with which the replica&#39;s custom container is run. If provided, it will override default ENTRYPOINT of the docker image. If not provided, the docker image&#39;s ENTRYPOINT is used. It cannot be set if custom container image is not provided. Note that this field and [TrainingInput.args] are mutually exclusive, i.e., both cannot be set at the same time.
   * @return containerCommand
   */
  @javax.annotation.Nullable
  public List<String> getContainerCommand() {
    return containerCommand;
  }

  public void setContainerCommand(List<String> containerCommand) {
    this.containerCommand = containerCommand;
  }


  public GoogleCloudMlV1ReplicaConfig diskConfig(GoogleCloudMlV1DiskConfig diskConfig) {
    this.diskConfig = diskConfig;
    return this;
  }

  /**
   * Get diskConfig
   * @return diskConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudMlV1DiskConfig getDiskConfig() {
    return diskConfig;
  }

  public void setDiskConfig(GoogleCloudMlV1DiskConfig diskConfig) {
    this.diskConfig = diskConfig;
  }


  public GoogleCloudMlV1ReplicaConfig imageUri(String imageUri) {
    this.imageUri = imageUri;
    return this;
  }

  /**
   * The Docker image to run on the replica. This image must be in Container Registry. Learn more about [configuring custom containers](/ai-platform/training/docs/distributed-training-containers).
   * @return imageUri
   */
  @javax.annotation.Nullable
  public String getImageUri() {
    return imageUri;
  }

  public void setImageUri(String imageUri) {
    this.imageUri = imageUri;
  }


  public GoogleCloudMlV1ReplicaConfig tpuTfVersion(String tpuTfVersion) {
    this.tpuTfVersion = tpuTfVersion;
    return this;
  }

  /**
   * The AI Platform runtime version that includes a TensorFlow version matching the one used in the custom container. This field is required if the replica is a TPU worker that uses a custom container. Otherwise, do not specify this field. This must be a [runtime version that currently supports training with TPUs](/ml-engine/docs/tensorflow/runtime-version-list#tpu-support). Note that the version of TensorFlow included in a runtime version may differ from the numbering of the runtime version itself, because it may have a different [patch version](https://www.tensorflow.org/guide/version_compat#semantic_versioning_20). In this field, you must specify the runtime version (TensorFlow minor version). For example, if your custom container runs TensorFlow &#x60;1.x.y&#x60;, specify &#x60;1.x&#x60;.
   * @return tpuTfVersion
   */
  @javax.annotation.Nullable
  public String getTpuTfVersion() {
    return tpuTfVersion;
  }

  public void setTpuTfVersion(String tpuTfVersion) {
    this.tpuTfVersion = tpuTfVersion;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudMlV1ReplicaConfig googleCloudMlV1ReplicaConfig = (GoogleCloudMlV1ReplicaConfig) o;
    return Objects.equals(this.acceleratorConfig, googleCloudMlV1ReplicaConfig.acceleratorConfig) &&
        Objects.equals(this.containerArgs, googleCloudMlV1ReplicaConfig.containerArgs) &&
        Objects.equals(this.containerCommand, googleCloudMlV1ReplicaConfig.containerCommand) &&
        Objects.equals(this.diskConfig, googleCloudMlV1ReplicaConfig.diskConfig) &&
        Objects.equals(this.imageUri, googleCloudMlV1ReplicaConfig.imageUri) &&
        Objects.equals(this.tpuTfVersion, googleCloudMlV1ReplicaConfig.tpuTfVersion);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceleratorConfig, containerArgs, containerCommand, diskConfig, imageUri, tpuTfVersion);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudMlV1ReplicaConfig {\n");
    sb.append("    acceleratorConfig: ").append(toIndentedString(acceleratorConfig)).append("\n");
    sb.append("    containerArgs: ").append(toIndentedString(containerArgs)).append("\n");
    sb.append("    containerCommand: ").append(toIndentedString(containerCommand)).append("\n");
    sb.append("    diskConfig: ").append(toIndentedString(diskConfig)).append("\n");
    sb.append("    imageUri: ").append(toIndentedString(imageUri)).append("\n");
    sb.append("    tpuTfVersion: ").append(toIndentedString(tpuTfVersion)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceleratorConfig");
    openapiFields.add("containerArgs");
    openapiFields.add("containerCommand");
    openapiFields.add("diskConfig");
    openapiFields.add("imageUri");
    openapiFields.add("tpuTfVersion");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudMlV1ReplicaConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudMlV1ReplicaConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudMlV1ReplicaConfig is not found in the empty JSON string", GoogleCloudMlV1ReplicaConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudMlV1ReplicaConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudMlV1ReplicaConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `acceleratorConfig`
      if (jsonObj.get("acceleratorConfig") != null && !jsonObj.get("acceleratorConfig").isJsonNull()) {
        GoogleCloudMlV1AcceleratorConfig.validateJsonElement(jsonObj.get("acceleratorConfig"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("containerArgs") != null && !jsonObj.get("containerArgs").isJsonNull() && !jsonObj.get("containerArgs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerArgs` to be an array in the JSON string but got `%s`", jsonObj.get("containerArgs").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("containerCommand") != null && !jsonObj.get("containerCommand").isJsonNull() && !jsonObj.get("containerCommand").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerCommand` to be an array in the JSON string but got `%s`", jsonObj.get("containerCommand").toString()));
      }
      // validate the optional field `diskConfig`
      if (jsonObj.get("diskConfig") != null && !jsonObj.get("diskConfig").isJsonNull()) {
        GoogleCloudMlV1DiskConfig.validateJsonElement(jsonObj.get("diskConfig"));
      }
      if ((jsonObj.get("imageUri") != null && !jsonObj.get("imageUri").isJsonNull()) && !jsonObj.get("imageUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageUri").toString()));
      }
      if ((jsonObj.get("tpuTfVersion") != null && !jsonObj.get("tpuTfVersion").isJsonNull()) && !jsonObj.get("tpuTfVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tpuTfVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tpuTfVersion").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudMlV1ReplicaConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudMlV1ReplicaConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudMlV1ReplicaConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudMlV1ReplicaConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudMlV1ReplicaConfig>() {
           @Override
           public void write(JsonWriter out, GoogleCloudMlV1ReplicaConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudMlV1ReplicaConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudMlV1ReplicaConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudMlV1ReplicaConfig
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudMlV1ReplicaConfig
   */
  public static GoogleCloudMlV1ReplicaConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudMlV1ReplicaConfig.class);
  }

  /**
   * Convert an instance of GoogleCloudMlV1ReplicaConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

