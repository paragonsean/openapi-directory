/*
 * AI Platform Training & Prediction API
 * An API to enable creating and using machine learning models.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GoogleCloudMlV1MetricSpec;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options for automatically scaling a model.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:13.643536-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudMlV1AutoScaling {
  public static final String SERIALIZED_NAME_MAX_NODES = "maxNodes";
  @SerializedName(SERIALIZED_NAME_MAX_NODES)
  private Integer maxNodes;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<GoogleCloudMlV1MetricSpec> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_MIN_NODES = "minNodes";
  @SerializedName(SERIALIZED_NAME_MIN_NODES)
  private Integer minNodes;

  public GoogleCloudMlV1AutoScaling() {
  }

  public GoogleCloudMlV1AutoScaling maxNodes(Integer maxNodes) {
    this.maxNodes = maxNodes;
    return this;
  }

  /**
   * The maximum number of nodes to scale this model under load. The actual value will depend on resource quota and availability.
   * @return maxNodes
   */
  @javax.annotation.Nullable
  public Integer getMaxNodes() {
    return maxNodes;
  }

  public void setMaxNodes(Integer maxNodes) {
    this.maxNodes = maxNodes;
  }


  public GoogleCloudMlV1AutoScaling metrics(List<GoogleCloudMlV1MetricSpec> metrics) {
    this.metrics = metrics;
    return this;
  }

  public GoogleCloudMlV1AutoScaling addMetricsItem(GoogleCloudMlV1MetricSpec metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

  /**
   * MetricSpec contains the specifications to use to calculate the desired nodes count.
   * @return metrics
   */
  @javax.annotation.Nullable
  public List<GoogleCloudMlV1MetricSpec> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<GoogleCloudMlV1MetricSpec> metrics) {
    this.metrics = metrics;
  }


  public GoogleCloudMlV1AutoScaling minNodes(Integer minNodes) {
    this.minNodes = minNodes;
    return this;
  }

  /**
   * Optional. The minimum number of nodes to allocate for this model. These nodes are always up, starting from the time the model is deployed. Therefore, the cost of operating this model will be at least &#x60;rate&#x60; * &#x60;min_nodes&#x60; * number of hours since last billing cycle, where &#x60;rate&#x60; is the cost per node-hour as documented in the [pricing guide](/ml-engine/docs/pricing), even if no predictions are performed. There is additional cost for each prediction performed. Unlike manual scaling, if the load gets too heavy for the nodes that are up, the service will automatically add nodes to handle the increased load as well as scale back as traffic drops, always maintaining at least &#x60;min_nodes&#x60;. You will be charged for the time in which additional nodes are used. If &#x60;min_nodes&#x60; is not specified and AutoScaling is used with a [legacy (MLS1) machine type](/ml-engine/docs/machine-types-online-prediction), &#x60;min_nodes&#x60; defaults to 0, in which case, when traffic to a model stops (and after a cool-down period), nodes will be shut down and no charges will be incurred until traffic to the model resumes. If &#x60;min_nodes&#x60; is not specified and AutoScaling is used with a [Compute Engine (N1) machine type](/ml-engine/docs/machine-types-online-prediction), &#x60;min_nodes&#x60; defaults to 1. &#x60;min_nodes&#x60; must be at least 1 for use with a Compute Engine machine type. You can set &#x60;min_nodes&#x60; when creating the model version, and you can also update &#x60;min_nodes&#x60; for an existing version: update_body.json: { &#39;autoScaling&#39;: { &#39;minNodes&#39;: 5 } } HTTP request: PATCH https://ml.googleapis.com/v1/{name&#x3D;projects/_*_/models/_*_/versions/_*}?update_mask&#x3D;autoScaling.minNodes -d @./update_body.json 
   * @return minNodes
   */
  @javax.annotation.Nullable
  public Integer getMinNodes() {
    return minNodes;
  }

  public void setMinNodes(Integer minNodes) {
    this.minNodes = minNodes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudMlV1AutoScaling googleCloudMlV1AutoScaling = (GoogleCloudMlV1AutoScaling) o;
    return Objects.equals(this.maxNodes, googleCloudMlV1AutoScaling.maxNodes) &&
        Objects.equals(this.metrics, googleCloudMlV1AutoScaling.metrics) &&
        Objects.equals(this.minNodes, googleCloudMlV1AutoScaling.minNodes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxNodes, metrics, minNodes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudMlV1AutoScaling {\n");
    sb.append("    maxNodes: ").append(toIndentedString(maxNodes)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    minNodes: ").append(toIndentedString(minNodes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxNodes");
    openapiFields.add("metrics");
    openapiFields.add("minNodes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudMlV1AutoScaling
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudMlV1AutoScaling.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudMlV1AutoScaling is not found in the empty JSON string", GoogleCloudMlV1AutoScaling.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudMlV1AutoScaling.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudMlV1AutoScaling` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("metrics") != null && !jsonObj.get("metrics").isJsonNull()) {
        JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
        if (jsonArraymetrics != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metrics").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
          }

          // validate the optional field `metrics` (array)
          for (int i = 0; i < jsonArraymetrics.size(); i++) {
            GoogleCloudMlV1MetricSpec.validateJsonElement(jsonArraymetrics.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudMlV1AutoScaling.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudMlV1AutoScaling' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudMlV1AutoScaling> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudMlV1AutoScaling.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudMlV1AutoScaling>() {
           @Override
           public void write(JsonWriter out, GoogleCloudMlV1AutoScaling value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudMlV1AutoScaling read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudMlV1AutoScaling given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudMlV1AutoScaling
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudMlV1AutoScaling
   */
  public static GoogleCloudMlV1AutoScaling fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudMlV1AutoScaling.class);
  }

  /**
   * Convert an instance of GoogleCloudMlV1AutoScaling to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

