/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import DestinyDefinitionsItemsDestinyEnergyCapacityEntry from './DestinyDefinitionsItemsDestinyEnergyCapacityEntry';
import DestinyDefinitionsItemsDestinyEnergyCostEntry from './DestinyDefinitionsItemsDestinyEnergyCostEntry';
import DestinyDefinitionsItemsDestinyParentItemOverride from './DestinyDefinitionsItemsDestinyParentItemOverride';
import DestinyDefinitionsItemsDestinyPlugRuleDefinition from './DestinyDefinitionsItemsDestinyPlugRuleDefinition';

/**
 * The DestinyDefinitionsItemsDestinyItemPlugDefinition model module.
 * @module model/DestinyDefinitionsItemsDestinyItemPlugDefinition
 * @version 2.18.0
 */
class DestinyDefinitionsItemsDestinyItemPlugDefinition {
    /**
     * Constructs a new <code>DestinyDefinitionsItemsDestinyItemPlugDefinition</code>.
     * If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.  This gives information about when it can be inserted, what the plug&#39;s category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
     * @alias module:model/DestinyDefinitionsItemsDestinyItemPlugDefinition
     */
    constructor() { 
        
        DestinyDefinitionsItemsDestinyItemPlugDefinition.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>DestinyDefinitionsItemsDestinyItemPlugDefinition</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/DestinyDefinitionsItemsDestinyItemPlugDefinition} obj Optional instance to populate.
     * @return {module:model/DestinyDefinitionsItemsDestinyItemPlugDefinition} The populated <code>DestinyDefinitionsItemsDestinyItemPlugDefinition</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new DestinyDefinitionsItemsDestinyItemPlugDefinition();

            if (data.hasOwnProperty('alternatePlugStyle')) {
                obj['alternatePlugStyle'] = ApiClient.convertToType(data['alternatePlugStyle'], 'Number');
            }
            if (data.hasOwnProperty('alternateUiPlugLabel')) {
                obj['alternateUiPlugLabel'] = ApiClient.convertToType(data['alternateUiPlugLabel'], 'String');
            }
            if (data.hasOwnProperty('enabledMaterialRequirementHash')) {
                obj['enabledMaterialRequirementHash'] = ApiClient.convertToType(data['enabledMaterialRequirementHash'], 'Number');
            }
            if (data.hasOwnProperty('enabledRules')) {
                obj['enabledRules'] = ApiClient.convertToType(data['enabledRules'], [DestinyDefinitionsItemsDestinyPlugRuleDefinition]);
            }
            if (data.hasOwnProperty('energyCapacity')) {
                obj['energyCapacity'] = ApiClient.convertToType(data['energyCapacity'], DestinyDefinitionsItemsDestinyEnergyCapacityEntry);
            }
            if (data.hasOwnProperty('energyCost')) {
                obj['energyCost'] = ApiClient.convertToType(data['energyCost'], DestinyDefinitionsItemsDestinyEnergyCostEntry);
            }
            if (data.hasOwnProperty('insertionMaterialRequirementHash')) {
                obj['insertionMaterialRequirementHash'] = ApiClient.convertToType(data['insertionMaterialRequirementHash'], 'Number');
            }
            if (data.hasOwnProperty('insertionRules')) {
                obj['insertionRules'] = ApiClient.convertToType(data['insertionRules'], [DestinyDefinitionsItemsDestinyPlugRuleDefinition]);
            }
            if (data.hasOwnProperty('isDummyPlug')) {
                obj['isDummyPlug'] = ApiClient.convertToType(data['isDummyPlug'], 'Boolean');
            }
            if (data.hasOwnProperty('onActionRecreateSelf')) {
                obj['onActionRecreateSelf'] = ApiClient.convertToType(data['onActionRecreateSelf'], 'Boolean');
            }
            if (data.hasOwnProperty('parentItemOverride')) {
                obj['parentItemOverride'] = ApiClient.convertToType(data['parentItemOverride'], DestinyDefinitionsItemsDestinyParentItemOverride);
            }
            if (data.hasOwnProperty('plugAvailability')) {
                obj['plugAvailability'] = ApiClient.convertToType(data['plugAvailability'], 'Number');
            }
            if (data.hasOwnProperty('plugCategoryHash')) {
                obj['plugCategoryHash'] = ApiClient.convertToType(data['plugCategoryHash'], 'Number');
            }
            if (data.hasOwnProperty('plugCategoryIdentifier')) {
                obj['plugCategoryIdentifier'] = ApiClient.convertToType(data['plugCategoryIdentifier'], 'String');
            }
            if (data.hasOwnProperty('plugStyle')) {
                obj['plugStyle'] = ApiClient.convertToType(data['plugStyle'], 'Number');
            }
            if (data.hasOwnProperty('previewItemOverrideHash')) {
                obj['previewItemOverrideHash'] = ApiClient.convertToType(data['previewItemOverrideHash'], 'Number');
            }
            if (data.hasOwnProperty('uiPlugLabel')) {
                obj['uiPlugLabel'] = ApiClient.convertToType(data['uiPlugLabel'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>DestinyDefinitionsItemsDestinyItemPlugDefinition</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>DestinyDefinitionsItemsDestinyItemPlugDefinition</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['alternateUiPlugLabel'] && !(typeof data['alternateUiPlugLabel'] === 'string' || data['alternateUiPlugLabel'] instanceof String)) {
            throw new Error("Expected the field `alternateUiPlugLabel` to be a primitive type in the JSON string but got " + data['alternateUiPlugLabel']);
        }
        if (data['enabledRules']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['enabledRules'])) {
                throw new Error("Expected the field `enabledRules` to be an array in the JSON data but got " + data['enabledRules']);
            }
            // validate the optional field `enabledRules` (array)
            for (const item of data['enabledRules']) {
                DestinyDefinitionsItemsDestinyPlugRuleDefinition.validateJSON(item);
            };
        }
        // validate the optional field `energyCapacity`
        if (data['energyCapacity']) { // data not null
          DestinyDefinitionsItemsDestinyEnergyCapacityEntry.validateJSON(data['energyCapacity']);
        }
        // validate the optional field `energyCost`
        if (data['energyCost']) { // data not null
          DestinyDefinitionsItemsDestinyEnergyCostEntry.validateJSON(data['energyCost']);
        }
        if (data['insertionRules']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['insertionRules'])) {
                throw new Error("Expected the field `insertionRules` to be an array in the JSON data but got " + data['insertionRules']);
            }
            // validate the optional field `insertionRules` (array)
            for (const item of data['insertionRules']) {
                DestinyDefinitionsItemsDestinyPlugRuleDefinition.validateJSON(item);
            };
        }
        // validate the optional field `parentItemOverride`
        if (data['parentItemOverride']) { // data not null
          DestinyDefinitionsItemsDestinyParentItemOverride.validateJSON(data['parentItemOverride']);
        }
        // ensure the json data is a string
        if (data['plugCategoryIdentifier'] && !(typeof data['plugCategoryIdentifier'] === 'string' || data['plugCategoryIdentifier'] instanceof String)) {
            throw new Error("Expected the field `plugCategoryIdentifier` to be a primitive type in the JSON string but got " + data['plugCategoryIdentifier']);
        }
        // ensure the json data is a string
        if (data['uiPlugLabel'] && !(typeof data['uiPlugLabel'] === 'string' || data['uiPlugLabel'] instanceof String)) {
            throw new Error("Expected the field `uiPlugLabel` to be a primitive type in the JSON string but got " + data['uiPlugLabel']);
        }

        return true;
    }


}



/**
 * The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
 * @member {Number} alternatePlugStyle
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['alternatePlugStyle'] = undefined;

/**
 * If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.
 * @member {String} alternateUiPlugLabel
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['alternateUiPlugLabel'] = undefined;

/**
 * It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
 * @member {Number} enabledMaterialRequirementHash
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['enabledMaterialRequirementHash'] = undefined;

/**
 * The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
 * @member {Array.<module:model/DestinyDefinitionsItemsDestinyPlugRuleDefinition>} enabledRules
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['enabledRules'] = undefined;

/**
 * IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0 for example, is implemented in a similar way to Masterworks, where visually it's a single area of the UI being clicked on to \"Upgrade\" to higher energy levels, but it's actually socketing new plugs.
 * @member {module:model/DestinyDefinitionsItemsDestinyEnergyCapacityEntry} energyCapacity
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['energyCapacity'] = undefined;

/**
 * IF not null, this plug has an energy cost. This contains the details of that cost.
 * @member {module:model/DestinyDefinitionsItemsDestinyEnergyCostEntry} energyCost
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['energyCost'] = undefined;

/**
 * If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
 * @member {Number} insertionMaterialRequirementHash
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['insertionMaterialRequirementHash'] = undefined;

/**
 * The rules around when this plug can be inserted into a socket, aside from the socket's individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
 * @member {Array.<module:model/DestinyDefinitionsItemsDestinyPlugRuleDefinition>} insertionRules
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['insertionRules'] = undefined;

/**
 * If TRUE, this plug is used for UI display purposes only, and doesn't have any interesting effects of its own.
 * @member {Boolean} isDummyPlug
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['isDummyPlug'] = undefined;

/**
 * If you successfully socket the item, this will determine whether or not you get \"refunded\" on the plug.
 * @member {Boolean} onActionRecreateSelf
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['onActionRecreateSelf'] = undefined;

/**
 * Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!  In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.  If this is populated, it will have the override data to be applied when this plug is applied to an item.
 * @member {module:model/DestinyDefinitionsItemsDestinyParentItemOverride} parentItemOverride
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['parentItemOverride'] = undefined;

/**
 * Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!
 * @member {Number} plugAvailability
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['plugAvailability'] = undefined;

/**
 * The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
 * @member {Number} plugCategoryHash
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['plugCategoryHash'] = undefined;

/**
 * The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
 * @member {String} plugCategoryIdentifier
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['plugCategoryIdentifier'] = undefined;

/**
 * @member {Number} plugStyle
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['plugStyle'] = undefined;

/**
 * In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
 * @member {Number} previewItemOverrideHash
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['previewItemOverrideHash'] = undefined;

/**
 * Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you'll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.
 * @member {String} uiPlugLabel
 */
DestinyDefinitionsItemsDestinyItemPlugDefinition.prototype['uiPlugLabel'] = undefined;






export default DestinyDefinitionsItemsDestinyItemPlugDefinition;

