/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import DestinyDefinitionsDestinyItemCreationEntryLevelDefinition from './DestinyDefinitionsDestinyItemCreationEntryLevelDefinition';
import DestinyDefinitionsDestinyVendorItemQuantity from './DestinyDefinitionsDestinyVendorItemQuantity';
import DestinyDefinitionsDestinyVendorItemSocketOverride from './DestinyDefinitionsDestinyVendorItemSocketOverride';
import DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition from './DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition';

/**
 * The DestinyDefinitionsDestinyVendorItemDefinition model module.
 * @module model/DestinyDefinitionsDestinyVendorItemDefinition
 * @version 2.18.0
 */
class DestinyDefinitionsDestinyVendorItemDefinition {
    /**
     * Constructs a new <code>DestinyDefinitionsDestinyVendorItemDefinition</code>.
     * This represents an item being sold by the vendor.
     * @alias module:model/DestinyDefinitionsDestinyVendorItemDefinition
     */
    constructor() { 
        
        DestinyDefinitionsDestinyVendorItemDefinition.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>DestinyDefinitionsDestinyVendorItemDefinition</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/DestinyDefinitionsDestinyVendorItemDefinition} obj Optional instance to populate.
     * @return {module:model/DestinyDefinitionsDestinyVendorItemDefinition} The populated <code>DestinyDefinitionsDestinyVendorItemDefinition</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new DestinyDefinitionsDestinyVendorItemDefinition();

            if (data.hasOwnProperty('action')) {
                obj['action'] = ApiClient.convertToType(data['action'], DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition);
            }
            if (data.hasOwnProperty('categoryIndex')) {
                obj['categoryIndex'] = ApiClient.convertToType(data['categoryIndex'], 'Number');
            }
            if (data.hasOwnProperty('creationLevels')) {
                obj['creationLevels'] = ApiClient.convertToType(data['creationLevels'], [DestinyDefinitionsDestinyItemCreationEntryLevelDefinition]);
            }
            if (data.hasOwnProperty('currencies')) {
                obj['currencies'] = ApiClient.convertToType(data['currencies'], [DestinyDefinitionsDestinyVendorItemQuantity]);
            }
            if (data.hasOwnProperty('displayCategory')) {
                obj['displayCategory'] = ApiClient.convertToType(data['displayCategory'], 'String');
            }
            if (data.hasOwnProperty('displayCategoryIndex')) {
                obj['displayCategoryIndex'] = ApiClient.convertToType(data['displayCategoryIndex'], 'Number');
            }
            if (data.hasOwnProperty('exclusivity')) {
                obj['exclusivity'] = ApiClient.convertToType(data['exclusivity'], 'Number');
            }
            if (data.hasOwnProperty('expirationTooltip')) {
                obj['expirationTooltip'] = ApiClient.convertToType(data['expirationTooltip'], 'String');
            }
            if (data.hasOwnProperty('failureIndexes')) {
                obj['failureIndexes'] = ApiClient.convertToType(data['failureIndexes'], ['Number']);
            }
            if (data.hasOwnProperty('inventoryBucketHash')) {
                obj['inventoryBucketHash'] = ApiClient.convertToType(data['inventoryBucketHash'], 'Number');
            }
            if (data.hasOwnProperty('isCrm')) {
                obj['isCrm'] = ApiClient.convertToType(data['isCrm'], 'Boolean');
            }
            if (data.hasOwnProperty('isOffer')) {
                obj['isOffer'] = ApiClient.convertToType(data['isOffer'], 'Boolean');
            }
            if (data.hasOwnProperty('itemHash')) {
                obj['itemHash'] = ApiClient.convertToType(data['itemHash'], 'Number');
            }
            if (data.hasOwnProperty('maximumLevel')) {
                obj['maximumLevel'] = ApiClient.convertToType(data['maximumLevel'], 'Number');
            }
            if (data.hasOwnProperty('minimumLevel')) {
                obj['minimumLevel'] = ApiClient.convertToType(data['minimumLevel'], 'Number');
            }
            if (data.hasOwnProperty('originalCategoryIndex')) {
                obj['originalCategoryIndex'] = ApiClient.convertToType(data['originalCategoryIndex'], 'Number');
            }
            if (data.hasOwnProperty('purchasableScope')) {
                obj['purchasableScope'] = ApiClient.convertToType(data['purchasableScope'], 'Number');
            }
            if (data.hasOwnProperty('quantity')) {
                obj['quantity'] = ApiClient.convertToType(data['quantity'], 'Number');
            }
            if (data.hasOwnProperty('redirectToSaleIndexes')) {
                obj['redirectToSaleIndexes'] = ApiClient.convertToType(data['redirectToSaleIndexes'], ['Number']);
            }
            if (data.hasOwnProperty('refundPolicy')) {
                obj['refundPolicy'] = ApiClient.convertToType(data['refundPolicy'], 'Number');
            }
            if (data.hasOwnProperty('refundTimeLimit')) {
                obj['refundTimeLimit'] = ApiClient.convertToType(data['refundTimeLimit'], 'Number');
            }
            if (data.hasOwnProperty('socketOverrides')) {
                obj['socketOverrides'] = ApiClient.convertToType(data['socketOverrides'], [DestinyDefinitionsDestinyVendorItemSocketOverride]);
            }
            if (data.hasOwnProperty('sortValue')) {
                obj['sortValue'] = ApiClient.convertToType(data['sortValue'], 'Number');
            }
            if (data.hasOwnProperty('unpurchasable')) {
                obj['unpurchasable'] = ApiClient.convertToType(data['unpurchasable'], 'Boolean');
            }
            if (data.hasOwnProperty('vendorItemIndex')) {
                obj['vendorItemIndex'] = ApiClient.convertToType(data['vendorItemIndex'], 'Number');
            }
            if (data.hasOwnProperty('visibilityScope')) {
                obj['visibilityScope'] = ApiClient.convertToType(data['visibilityScope'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>DestinyDefinitionsDestinyVendorItemDefinition</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>DestinyDefinitionsDestinyVendorItemDefinition</code>.
     */
    static validateJSON(data) {
        // validate the optional field `action`
        if (data['action']) { // data not null
          DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition.validateJSON(data['action']);
        }
        if (data['creationLevels']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['creationLevels'])) {
                throw new Error("Expected the field `creationLevels` to be an array in the JSON data but got " + data['creationLevels']);
            }
            // validate the optional field `creationLevels` (array)
            for (const item of data['creationLevels']) {
                DestinyDefinitionsDestinyItemCreationEntryLevelDefinition.validateJSON(item);
            };
        }
        if (data['currencies']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['currencies'])) {
                throw new Error("Expected the field `currencies` to be an array in the JSON data but got " + data['currencies']);
            }
            // validate the optional field `currencies` (array)
            for (const item of data['currencies']) {
                DestinyDefinitionsDestinyVendorItemQuantity.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['displayCategory'] && !(typeof data['displayCategory'] === 'string' || data['displayCategory'] instanceof String)) {
            throw new Error("Expected the field `displayCategory` to be a primitive type in the JSON string but got " + data['displayCategory']);
        }
        // ensure the json data is a string
        if (data['expirationTooltip'] && !(typeof data['expirationTooltip'] === 'string' || data['expirationTooltip'] instanceof String)) {
            throw new Error("Expected the field `expirationTooltip` to be a primitive type in the JSON string but got " + data['expirationTooltip']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['failureIndexes'])) {
            throw new Error("Expected the field `failureIndexes` to be an array in the JSON data but got " + data['failureIndexes']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['redirectToSaleIndexes'])) {
            throw new Error("Expected the field `redirectToSaleIndexes` to be an array in the JSON data but got " + data['redirectToSaleIndexes']);
        }
        if (data['socketOverrides']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['socketOverrides'])) {
                throw new Error("Expected the field `socketOverrides` to be an array in the JSON data but got " + data['socketOverrides']);
            }
            // validate the optional field `socketOverrides` (array)
            for (const item of data['socketOverrides']) {
                DestinyDefinitionsDestinyVendorItemSocketOverride.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * The action to be performed when purchasing the item, if it's not just \"buy\".
 * @member {module:model/DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition} action
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['action'] = undefined;

/**
 * The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.
 * @member {Number} categoryIndex
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['categoryIndex'] = undefined;

/**
 * The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It's a long story how this ended up as a list, but there is always either going to be 0:1 of these entities.
 * @member {Array.<module:model/DestinyDefinitionsDestinyItemCreationEntryLevelDefinition>} creationLevels
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['creationLevels'] = undefined;

/**
 * This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.  The somewhat crappy part about this is that, now that item quantity overrides have dynamic modifiers, this will not necessarily be statically true. If you were using this instead of live data, switch to using live data.
 * @member {Array.<module:model/DestinyDefinitionsDestinyVendorItemQuantity>} currencies
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['currencies'] = undefined;

/**
 * The string identifier for the category selling this item.
 * @member {String} displayCategory
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['displayCategory'] = undefined;

/**
 * This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)
 * @member {Number} displayCategoryIndex
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['displayCategoryIndex'] = undefined;

/**
 * If this item can only be purchased by a given platform, this indicates the platform to which it is restricted.
 * @member {Number} exclusivity
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['exclusivity'] = undefined;

/**
 * If this item can expire, this is the tooltip message to show with its expiration info.
 * @member {String} expirationTooltip
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['expirationTooltip'] = undefined;

/**
 * An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.
 * @member {Array.<Number>} failureIndexes
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['failureIndexes'] = undefined;

/**
 * The inventory bucket into which this item will be placed upon purchase.
 * @member {Number} inventoryBucketHash
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['inventoryBucketHash'] = undefined;

/**
 * If this sale can only be performed as the result of receiving a CRM offer, this is true.
 * @member {Boolean} isCrm
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['isCrm'] = undefined;

/**
 * If this sale can only be performed as the result of an offer check, this is true.
 * @member {Boolean} isOffer
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['isOffer'] = undefined;

/**
 * The hash identifier of the item being sold (DestinyInventoryItemDefinition).  Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity.
 * @member {Number} itemHash
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['itemHash'] = undefined;

/**
 * The maximum character level at which this item is available for sale.
 * @member {Number} maximumLevel
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['maximumLevel'] = undefined;

/**
 * The minimum character level at which this item is available for sale.
 * @member {Number} minimumLevel
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['minimumLevel'] = undefined;

/**
 * Same as above, but for the original category indexes.
 * @member {Number} originalCategoryIndex
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['originalCategoryIndex'] = undefined;

/**
 * Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.  See DestinyGatingScope's documentation for more information.
 * @member {Number} purchasableScope
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['purchasableScope'] = undefined;

/**
 * The amount you will recieve of the item described in itemHash if you make the purchase.
 * @member {Number} quantity
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['quantity'] = undefined;

/**
 * If this is populated, the purchase of this item should redirect to purchasing these other items instead.
 * @member {Array.<Number>} redirectToSaleIndexes
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['redirectToSaleIndexes'] = undefined;

/**
 * If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.
 * @member {Number} refundPolicy
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['refundPolicy'] = undefined;

/**
 * The amount of time before refundability of the newly purchased item will expire.
 * @member {Number} refundTimeLimit
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['refundTimeLimit'] = undefined;

/**
 * @member {Array.<module:model/DestinyDefinitionsDestinyVendorItemSocketOverride>} socketOverrides
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['socketOverrides'] = undefined;

/**
 * *if* the category this item is in supports non-default sorting, this value should represent the sorting value to use, pre-processed and ready to go.
 * @member {Number} sortValue
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['sortValue'] = undefined;

/**
 * If true, this item is some sort of dummy sale item that cannot actually be purchased. It may be a display only item, or some fluff left by a content designer for testing purposes, or something that got disabled because it was a terrible idea. You get the picture. We won't know *why* it can't be purchased, only that it can't be. Sorry.  This is also only whether it's unpurchasable as a static property according to game content. There are other reasons why an item may or may not be purchasable at runtime, so even if this isn't set to True you should trust the runtime value for this sale item over the static definition if this is unset.
 * @member {Boolean} unpurchasable
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['unpurchasable'] = undefined;

/**
 * The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.
 * @member {Number} vendorItemIndex
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['vendorItemIndex'] = undefined;

/**
 * The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.  This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).
 * @member {Number} visibilityScope
 */
DestinyDefinitionsDestinyVendorItemDefinition.prototype['visibilityScope'] = undefined;






export default DestinyDefinitionsDestinyVendorItemDefinition;

