/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDestiny_Milestones_DestinyPublicMilestone.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDestiny_Milestones_DestinyPublicMilestone::OAIDestiny_Milestones_DestinyPublicMilestone(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDestiny_Milestones_DestinyPublicMilestone::OAIDestiny_Milestones_DestinyPublicMilestone() {
    this->initializeModel();
}

OAIDestiny_Milestones_DestinyPublicMilestone::~OAIDestiny_Milestones_DestinyPublicMilestone() {}

void OAIDestiny_Milestones_DestinyPublicMilestone::initializeModel() {

    m_activities_isSet = false;
    m_activities_isValid = false;

    m_available_quests_isSet = false;
    m_available_quests_isValid = false;

    m_end_date_isSet = false;
    m_end_date_isValid = false;

    m_milestone_hash_isSet = false;
    m_milestone_hash_isValid = false;

    m_order_isSet = false;
    m_order_isValid = false;

    m_start_date_isSet = false;
    m_start_date_isValid = false;

    m_vendor_hashes_isSet = false;
    m_vendor_hashes_isValid = false;

    m_vendors_isSet = false;
    m_vendors_isValid = false;
}

void OAIDestiny_Milestones_DestinyPublicMilestone::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDestiny_Milestones_DestinyPublicMilestone::fromJsonObject(QJsonObject json) {

    m_activities_isValid = ::OpenAPI::fromJsonValue(m_activities, json[QString("activities")]);
    m_activities_isSet = !json[QString("activities")].isNull() && m_activities_isValid;

    m_available_quests_isValid = ::OpenAPI::fromJsonValue(m_available_quests, json[QString("availableQuests")]);
    m_available_quests_isSet = !json[QString("availableQuests")].isNull() && m_available_quests_isValid;

    m_end_date_isValid = ::OpenAPI::fromJsonValue(m_end_date, json[QString("endDate")]);
    m_end_date_isSet = !json[QString("endDate")].isNull() && m_end_date_isValid;

    m_milestone_hash_isValid = ::OpenAPI::fromJsonValue(m_milestone_hash, json[QString("milestoneHash")]);
    m_milestone_hash_isSet = !json[QString("milestoneHash")].isNull() && m_milestone_hash_isValid;

    m_order_isValid = ::OpenAPI::fromJsonValue(m_order, json[QString("order")]);
    m_order_isSet = !json[QString("order")].isNull() && m_order_isValid;

    m_start_date_isValid = ::OpenAPI::fromJsonValue(m_start_date, json[QString("startDate")]);
    m_start_date_isSet = !json[QString("startDate")].isNull() && m_start_date_isValid;

    m_vendor_hashes_isValid = ::OpenAPI::fromJsonValue(m_vendor_hashes, json[QString("vendorHashes")]);
    m_vendor_hashes_isSet = !json[QString("vendorHashes")].isNull() && m_vendor_hashes_isValid;

    m_vendors_isValid = ::OpenAPI::fromJsonValue(m_vendors, json[QString("vendors")]);
    m_vendors_isSet = !json[QString("vendors")].isNull() && m_vendors_isValid;
}

QString OAIDestiny_Milestones_DestinyPublicMilestone::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDestiny_Milestones_DestinyPublicMilestone::asJsonObject() const {
    QJsonObject obj;
    if (m_activities.size() > 0) {
        obj.insert(QString("activities"), ::OpenAPI::toJsonValue(m_activities));
    }
    if (m_available_quests.size() > 0) {
        obj.insert(QString("availableQuests"), ::OpenAPI::toJsonValue(m_available_quests));
    }
    if (m_end_date_isSet) {
        obj.insert(QString("endDate"), ::OpenAPI::toJsonValue(m_end_date));
    }
    if (m_milestone_hash_isSet) {
        obj.insert(QString("milestoneHash"), ::OpenAPI::toJsonValue(m_milestone_hash));
    }
    if (m_order_isSet) {
        obj.insert(QString("order"), ::OpenAPI::toJsonValue(m_order));
    }
    if (m_start_date_isSet) {
        obj.insert(QString("startDate"), ::OpenAPI::toJsonValue(m_start_date));
    }
    if (m_vendor_hashes.size() > 0) {
        obj.insert(QString("vendorHashes"), ::OpenAPI::toJsonValue(m_vendor_hashes));
    }
    if (m_vendors.size() > 0) {
        obj.insert(QString("vendors"), ::OpenAPI::toJsonValue(m_vendors));
    }
    return obj;
}

QList<OAIDestiny_Milestones_DestinyPublicMilestoneChallengeActivity> OAIDestiny_Milestones_DestinyPublicMilestone::getActivities() const {
    return m_activities;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setActivities(const QList<OAIDestiny_Milestones_DestinyPublicMilestoneChallengeActivity> &activities) {
    m_activities = activities;
    m_activities_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_activities_Set() const{
    return m_activities_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_activities_Valid() const{
    return m_activities_isValid;
}

QList<OAIDestiny_Milestones_DestinyPublicMilestoneQuest> OAIDestiny_Milestones_DestinyPublicMilestone::getAvailableQuests() const {
    return m_available_quests;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setAvailableQuests(const QList<OAIDestiny_Milestones_DestinyPublicMilestoneQuest> &available_quests) {
    m_available_quests = available_quests;
    m_available_quests_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_available_quests_Set() const{
    return m_available_quests_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_available_quests_Valid() const{
    return m_available_quests_isValid;
}

QDateTime OAIDestiny_Milestones_DestinyPublicMilestone::getEndDate() const {
    return m_end_date;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setEndDate(const QDateTime &end_date) {
    m_end_date = end_date;
    m_end_date_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_end_date_Set() const{
    return m_end_date_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_end_date_Valid() const{
    return m_end_date_isValid;
}

qint32 OAIDestiny_Milestones_DestinyPublicMilestone::getMilestoneHash() const {
    return m_milestone_hash;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setMilestoneHash(const qint32 &milestone_hash) {
    m_milestone_hash = milestone_hash;
    m_milestone_hash_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_milestone_hash_Set() const{
    return m_milestone_hash_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_milestone_hash_Valid() const{
    return m_milestone_hash_isValid;
}

qint32 OAIDestiny_Milestones_DestinyPublicMilestone::getOrder() const {
    return m_order;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setOrder(const qint32 &order) {
    m_order = order;
    m_order_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_order_Set() const{
    return m_order_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_order_Valid() const{
    return m_order_isValid;
}

QDateTime OAIDestiny_Milestones_DestinyPublicMilestone::getStartDate() const {
    return m_start_date;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setStartDate(const QDateTime &start_date) {
    m_start_date = start_date;
    m_start_date_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_start_date_Set() const{
    return m_start_date_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_start_date_Valid() const{
    return m_start_date_isValid;
}

QList<qint32> OAIDestiny_Milestones_DestinyPublicMilestone::getVendorHashes() const {
    return m_vendor_hashes;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setVendorHashes(const QList<qint32> &vendor_hashes) {
    m_vendor_hashes = vendor_hashes;
    m_vendor_hashes_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_vendor_hashes_Set() const{
    return m_vendor_hashes_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_vendor_hashes_Valid() const{
    return m_vendor_hashes_isValid;
}

QList<OAIDestiny_Milestones_DestinyPublicMilestoneVendor> OAIDestiny_Milestones_DestinyPublicMilestone::getVendors() const {
    return m_vendors;
}
void OAIDestiny_Milestones_DestinyPublicMilestone::setVendors(const QList<OAIDestiny_Milestones_DestinyPublicMilestoneVendor> &vendors) {
    m_vendors = vendors;
    m_vendors_isSet = true;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_vendors_Set() const{
    return m_vendors_isSet;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::is_vendors_Valid() const{
    return m_vendors_isValid;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_activities.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_quests.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_milestone_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_order_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vendor_hashes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_vendors.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDestiny_Milestones_DestinyPublicMilestone::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
