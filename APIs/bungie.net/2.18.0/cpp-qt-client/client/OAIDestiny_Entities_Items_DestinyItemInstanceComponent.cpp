/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDestiny_Entities_Items_DestinyItemInstanceComponent.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDestiny_Entities_Items_DestinyItemInstanceComponent::OAIDestiny_Entities_Items_DestinyItemInstanceComponent(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDestiny_Entities_Items_DestinyItemInstanceComponent::OAIDestiny_Entities_Items_DestinyItemInstanceComponent() {
    this->initializeModel();
}

OAIDestiny_Entities_Items_DestinyItemInstanceComponent::~OAIDestiny_Entities_Items_DestinyItemInstanceComponent() {}

void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::initializeModel() {

    m_breaker_type_isSet = false;
    m_breaker_type_isValid = false;

    m_breaker_type_hash_isSet = false;
    m_breaker_type_hash_isValid = false;

    m_can_equip_isSet = false;
    m_can_equip_isValid = false;

    m_cannot_equip_reason_isSet = false;
    m_cannot_equip_reason_isValid = false;

    m_damage_type_isSet = false;
    m_damage_type_isValid = false;

    m_damage_type_hash_isSet = false;
    m_damage_type_hash_isValid = false;

    m_energy_isSet = false;
    m_energy_isValid = false;

    m_equip_required_level_isSet = false;
    m_equip_required_level_isValid = false;

    m_is_equipped_isSet = false;
    m_is_equipped_isValid = false;

    m_item_level_isSet = false;
    m_item_level_isValid = false;

    m_primary_stat_isSet = false;
    m_primary_stat_isValid = false;

    m_quality_isSet = false;
    m_quality_isValid = false;

    m_unlock_hashes_required_to_equip_isSet = false;
    m_unlock_hashes_required_to_equip_isValid = false;
}

void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::fromJsonObject(QJsonObject json) {

    m_breaker_type_isValid = ::OpenAPI::fromJsonValue(m_breaker_type, json[QString("breakerType")]);
    m_breaker_type_isSet = !json[QString("breakerType")].isNull() && m_breaker_type_isValid;

    m_breaker_type_hash_isValid = ::OpenAPI::fromJsonValue(m_breaker_type_hash, json[QString("breakerTypeHash")]);
    m_breaker_type_hash_isSet = !json[QString("breakerTypeHash")].isNull() && m_breaker_type_hash_isValid;

    m_can_equip_isValid = ::OpenAPI::fromJsonValue(m_can_equip, json[QString("canEquip")]);
    m_can_equip_isSet = !json[QString("canEquip")].isNull() && m_can_equip_isValid;

    m_cannot_equip_reason_isValid = ::OpenAPI::fromJsonValue(m_cannot_equip_reason, json[QString("cannotEquipReason")]);
    m_cannot_equip_reason_isSet = !json[QString("cannotEquipReason")].isNull() && m_cannot_equip_reason_isValid;

    m_damage_type_isValid = ::OpenAPI::fromJsonValue(m_damage_type, json[QString("damageType")]);
    m_damage_type_isSet = !json[QString("damageType")].isNull() && m_damage_type_isValid;

    m_damage_type_hash_isValid = ::OpenAPI::fromJsonValue(m_damage_type_hash, json[QString("damageTypeHash")]);
    m_damage_type_hash_isSet = !json[QString("damageTypeHash")].isNull() && m_damage_type_hash_isValid;

    m_energy_isValid = ::OpenAPI::fromJsonValue(m_energy, json[QString("energy")]);
    m_energy_isSet = !json[QString("energy")].isNull() && m_energy_isValid;

    m_equip_required_level_isValid = ::OpenAPI::fromJsonValue(m_equip_required_level, json[QString("equipRequiredLevel")]);
    m_equip_required_level_isSet = !json[QString("equipRequiredLevel")].isNull() && m_equip_required_level_isValid;

    m_is_equipped_isValid = ::OpenAPI::fromJsonValue(m_is_equipped, json[QString("isEquipped")]);
    m_is_equipped_isSet = !json[QString("isEquipped")].isNull() && m_is_equipped_isValid;

    m_item_level_isValid = ::OpenAPI::fromJsonValue(m_item_level, json[QString("itemLevel")]);
    m_item_level_isSet = !json[QString("itemLevel")].isNull() && m_item_level_isValid;

    m_primary_stat_isValid = ::OpenAPI::fromJsonValue(m_primary_stat, json[QString("primaryStat")]);
    m_primary_stat_isSet = !json[QString("primaryStat")].isNull() && m_primary_stat_isValid;

    m_quality_isValid = ::OpenAPI::fromJsonValue(m_quality, json[QString("quality")]);
    m_quality_isSet = !json[QString("quality")].isNull() && m_quality_isValid;

    m_unlock_hashes_required_to_equip_isValid = ::OpenAPI::fromJsonValue(m_unlock_hashes_required_to_equip, json[QString("unlockHashesRequiredToEquip")]);
    m_unlock_hashes_required_to_equip_isSet = !json[QString("unlockHashesRequiredToEquip")].isNull() && m_unlock_hashes_required_to_equip_isValid;
}

QString OAIDestiny_Entities_Items_DestinyItemInstanceComponent::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDestiny_Entities_Items_DestinyItemInstanceComponent::asJsonObject() const {
    QJsonObject obj;
    if (m_breaker_type_isSet) {
        obj.insert(QString("breakerType"), ::OpenAPI::toJsonValue(m_breaker_type));
    }
    if (m_breaker_type_hash_isSet) {
        obj.insert(QString("breakerTypeHash"), ::OpenAPI::toJsonValue(m_breaker_type_hash));
    }
    if (m_can_equip_isSet) {
        obj.insert(QString("canEquip"), ::OpenAPI::toJsonValue(m_can_equip));
    }
    if (m_cannot_equip_reason_isSet) {
        obj.insert(QString("cannotEquipReason"), ::OpenAPI::toJsonValue(m_cannot_equip_reason));
    }
    if (m_damage_type_isSet) {
        obj.insert(QString("damageType"), ::OpenAPI::toJsonValue(m_damage_type));
    }
    if (m_damage_type_hash_isSet) {
        obj.insert(QString("damageTypeHash"), ::OpenAPI::toJsonValue(m_damage_type_hash));
    }
    if (m_energy.isSet()) {
        obj.insert(QString("energy"), ::OpenAPI::toJsonValue(m_energy));
    }
    if (m_equip_required_level_isSet) {
        obj.insert(QString("equipRequiredLevel"), ::OpenAPI::toJsonValue(m_equip_required_level));
    }
    if (m_is_equipped_isSet) {
        obj.insert(QString("isEquipped"), ::OpenAPI::toJsonValue(m_is_equipped));
    }
    if (m_item_level_isSet) {
        obj.insert(QString("itemLevel"), ::OpenAPI::toJsonValue(m_item_level));
    }
    if (m_primary_stat.isSet()) {
        obj.insert(QString("primaryStat"), ::OpenAPI::toJsonValue(m_primary_stat));
    }
    if (m_quality_isSet) {
        obj.insert(QString("quality"), ::OpenAPI::toJsonValue(m_quality));
    }
    if (m_unlock_hashes_required_to_equip.size() > 0) {
        obj.insert(QString("unlockHashesRequiredToEquip"), ::OpenAPI::toJsonValue(m_unlock_hashes_required_to_equip));
    }
    return obj;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getBreakerType() const {
    return m_breaker_type;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setBreakerType(const qint32 &breaker_type) {
    m_breaker_type = breaker_type;
    m_breaker_type_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_breaker_type_Set() const{
    return m_breaker_type_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_breaker_type_Valid() const{
    return m_breaker_type_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getBreakerTypeHash() const {
    return m_breaker_type_hash;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setBreakerTypeHash(const qint32 &breaker_type_hash) {
    m_breaker_type_hash = breaker_type_hash;
    m_breaker_type_hash_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_breaker_type_hash_Set() const{
    return m_breaker_type_hash_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_breaker_type_hash_Valid() const{
    return m_breaker_type_hash_isValid;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::isCanEquip() const {
    return m_can_equip;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setCanEquip(const bool &can_equip) {
    m_can_equip = can_equip;
    m_can_equip_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_can_equip_Set() const{
    return m_can_equip_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_can_equip_Valid() const{
    return m_can_equip_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getCannotEquipReason() const {
    return m_cannot_equip_reason;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setCannotEquipReason(const qint32 &cannot_equip_reason) {
    m_cannot_equip_reason = cannot_equip_reason;
    m_cannot_equip_reason_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_cannot_equip_reason_Set() const{
    return m_cannot_equip_reason_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_cannot_equip_reason_Valid() const{
    return m_cannot_equip_reason_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getDamageType() const {
    return m_damage_type;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setDamageType(const qint32 &damage_type) {
    m_damage_type = damage_type;
    m_damage_type_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_damage_type_Set() const{
    return m_damage_type_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_damage_type_Valid() const{
    return m_damage_type_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getDamageTypeHash() const {
    return m_damage_type_hash;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setDamageTypeHash(const qint32 &damage_type_hash) {
    m_damage_type_hash = damage_type_hash;
    m_damage_type_hash_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_damage_type_hash_Set() const{
    return m_damage_type_hash_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_damage_type_hash_Valid() const{
    return m_damage_type_hash_isValid;
}

OAIDestiny_Entities_Items_DestinyItemInstanceEnergy OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getEnergy() const {
    return m_energy;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setEnergy(const OAIDestiny_Entities_Items_DestinyItemInstanceEnergy &energy) {
    m_energy = energy;
    m_energy_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_energy_Set() const{
    return m_energy_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_energy_Valid() const{
    return m_energy_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getEquipRequiredLevel() const {
    return m_equip_required_level;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setEquipRequiredLevel(const qint32 &equip_required_level) {
    m_equip_required_level = equip_required_level;
    m_equip_required_level_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_equip_required_level_Set() const{
    return m_equip_required_level_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_equip_required_level_Valid() const{
    return m_equip_required_level_isValid;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::isIsEquipped() const {
    return m_is_equipped;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setIsEquipped(const bool &is_equipped) {
    m_is_equipped = is_equipped;
    m_is_equipped_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_is_equipped_Set() const{
    return m_is_equipped_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_is_equipped_Valid() const{
    return m_is_equipped_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getItemLevel() const {
    return m_item_level;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setItemLevel(const qint32 &item_level) {
    m_item_level = item_level;
    m_item_level_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_item_level_Set() const{
    return m_item_level_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_item_level_Valid() const{
    return m_item_level_isValid;
}

OAIDestiny_DestinyStat OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getPrimaryStat() const {
    return m_primary_stat;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setPrimaryStat(const OAIDestiny_DestinyStat &primary_stat) {
    m_primary_stat = primary_stat;
    m_primary_stat_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_primary_stat_Set() const{
    return m_primary_stat_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_primary_stat_Valid() const{
    return m_primary_stat_isValid;
}

qint32 OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getQuality() const {
    return m_quality;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setQuality(const qint32 &quality) {
    m_quality = quality;
    m_quality_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_quality_Set() const{
    return m_quality_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_quality_Valid() const{
    return m_quality_isValid;
}

QList<qint32> OAIDestiny_Entities_Items_DestinyItemInstanceComponent::getUnlockHashesRequiredToEquip() const {
    return m_unlock_hashes_required_to_equip;
}
void OAIDestiny_Entities_Items_DestinyItemInstanceComponent::setUnlockHashesRequiredToEquip(const QList<qint32> &unlock_hashes_required_to_equip) {
    m_unlock_hashes_required_to_equip = unlock_hashes_required_to_equip;
    m_unlock_hashes_required_to_equip_isSet = true;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_unlock_hashes_required_to_equip_Set() const{
    return m_unlock_hashes_required_to_equip_isSet;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::is_unlock_hashes_required_to_equip_Valid() const{
    return m_unlock_hashes_required_to_equip_isValid;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_breaker_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_breaker_type_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_can_equip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cannot_equip_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_damage_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_damage_type_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_energy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_equip_required_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_equipped_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_item_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_primary_stat.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_quality_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unlock_hashes_required_to_equip.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDestiny_Entities_Items_DestinyItemInstanceComponent::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
