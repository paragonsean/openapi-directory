/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition() {
    this->initializeModel();
}

OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::~OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition() {}

void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::initializeModel() {

    m_bucket_type_hash_isSet = false;
    m_bucket_type_hash_isValid = false;

    m_expiration_tooltip_isSet = false;
    m_expiration_tooltip_isValid = false;

    m_expired_in_activity_message_isSet = false;
    m_expired_in_activity_message_isValid = false;

    m_expired_in_orbit_message_isSet = false;
    m_expired_in_orbit_message_isValid = false;

    m_is_instance_item_isSet = false;
    m_is_instance_item_isValid = false;

    m_max_stack_size_isSet = false;
    m_max_stack_size_isValid = false;

    m_recipe_item_hash_isSet = false;
    m_recipe_item_hash_isValid = false;

    m_recovery_bucket_type_hash_isSet = false;
    m_recovery_bucket_type_hash_isValid = false;

    m_stack_unique_label_isSet = false;
    m_stack_unique_label_isValid = false;

    m_suppress_expiration_when_objectives_complete_isSet = false;
    m_suppress_expiration_when_objectives_complete_isValid = false;

    m_tier_type_isSet = false;
    m_tier_type_isValid = false;

    m_tier_type_hash_isSet = false;
    m_tier_type_hash_isValid = false;

    m_tier_type_name_isSet = false;
    m_tier_type_name_isValid = false;
}

void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::fromJsonObject(QJsonObject json) {

    m_bucket_type_hash_isValid = ::OpenAPI::fromJsonValue(m_bucket_type_hash, json[QString("bucketTypeHash")]);
    m_bucket_type_hash_isSet = !json[QString("bucketTypeHash")].isNull() && m_bucket_type_hash_isValid;

    m_expiration_tooltip_isValid = ::OpenAPI::fromJsonValue(m_expiration_tooltip, json[QString("expirationTooltip")]);
    m_expiration_tooltip_isSet = !json[QString("expirationTooltip")].isNull() && m_expiration_tooltip_isValid;

    m_expired_in_activity_message_isValid = ::OpenAPI::fromJsonValue(m_expired_in_activity_message, json[QString("expiredInActivityMessage")]);
    m_expired_in_activity_message_isSet = !json[QString("expiredInActivityMessage")].isNull() && m_expired_in_activity_message_isValid;

    m_expired_in_orbit_message_isValid = ::OpenAPI::fromJsonValue(m_expired_in_orbit_message, json[QString("expiredInOrbitMessage")]);
    m_expired_in_orbit_message_isSet = !json[QString("expiredInOrbitMessage")].isNull() && m_expired_in_orbit_message_isValid;

    m_is_instance_item_isValid = ::OpenAPI::fromJsonValue(m_is_instance_item, json[QString("isInstanceItem")]);
    m_is_instance_item_isSet = !json[QString("isInstanceItem")].isNull() && m_is_instance_item_isValid;

    m_max_stack_size_isValid = ::OpenAPI::fromJsonValue(m_max_stack_size, json[QString("maxStackSize")]);
    m_max_stack_size_isSet = !json[QString("maxStackSize")].isNull() && m_max_stack_size_isValid;

    m_recipe_item_hash_isValid = ::OpenAPI::fromJsonValue(m_recipe_item_hash, json[QString("recipeItemHash")]);
    m_recipe_item_hash_isSet = !json[QString("recipeItemHash")].isNull() && m_recipe_item_hash_isValid;

    m_recovery_bucket_type_hash_isValid = ::OpenAPI::fromJsonValue(m_recovery_bucket_type_hash, json[QString("recoveryBucketTypeHash")]);
    m_recovery_bucket_type_hash_isSet = !json[QString("recoveryBucketTypeHash")].isNull() && m_recovery_bucket_type_hash_isValid;

    m_stack_unique_label_isValid = ::OpenAPI::fromJsonValue(m_stack_unique_label, json[QString("stackUniqueLabel")]);
    m_stack_unique_label_isSet = !json[QString("stackUniqueLabel")].isNull() && m_stack_unique_label_isValid;

    m_suppress_expiration_when_objectives_complete_isValid = ::OpenAPI::fromJsonValue(m_suppress_expiration_when_objectives_complete, json[QString("suppressExpirationWhenObjectivesComplete")]);
    m_suppress_expiration_when_objectives_complete_isSet = !json[QString("suppressExpirationWhenObjectivesComplete")].isNull() && m_suppress_expiration_when_objectives_complete_isValid;

    m_tier_type_isValid = ::OpenAPI::fromJsonValue(m_tier_type, json[QString("tierType")]);
    m_tier_type_isSet = !json[QString("tierType")].isNull() && m_tier_type_isValid;

    m_tier_type_hash_isValid = ::OpenAPI::fromJsonValue(m_tier_type_hash, json[QString("tierTypeHash")]);
    m_tier_type_hash_isSet = !json[QString("tierTypeHash")].isNull() && m_tier_type_hash_isValid;

    m_tier_type_name_isValid = ::OpenAPI::fromJsonValue(m_tier_type_name, json[QString("tierTypeName")]);
    m_tier_type_name_isSet = !json[QString("tierTypeName")].isNull() && m_tier_type_name_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::asJsonObject() const {
    QJsonObject obj;
    if (m_bucket_type_hash_isSet) {
        obj.insert(QString("bucketTypeHash"), ::OpenAPI::toJsonValue(m_bucket_type_hash));
    }
    if (m_expiration_tooltip_isSet) {
        obj.insert(QString("expirationTooltip"), ::OpenAPI::toJsonValue(m_expiration_tooltip));
    }
    if (m_expired_in_activity_message_isSet) {
        obj.insert(QString("expiredInActivityMessage"), ::OpenAPI::toJsonValue(m_expired_in_activity_message));
    }
    if (m_expired_in_orbit_message_isSet) {
        obj.insert(QString("expiredInOrbitMessage"), ::OpenAPI::toJsonValue(m_expired_in_orbit_message));
    }
    if (m_is_instance_item_isSet) {
        obj.insert(QString("isInstanceItem"), ::OpenAPI::toJsonValue(m_is_instance_item));
    }
    if (m_max_stack_size_isSet) {
        obj.insert(QString("maxStackSize"), ::OpenAPI::toJsonValue(m_max_stack_size));
    }
    if (m_recipe_item_hash_isSet) {
        obj.insert(QString("recipeItemHash"), ::OpenAPI::toJsonValue(m_recipe_item_hash));
    }
    if (m_recovery_bucket_type_hash_isSet) {
        obj.insert(QString("recoveryBucketTypeHash"), ::OpenAPI::toJsonValue(m_recovery_bucket_type_hash));
    }
    if (m_stack_unique_label_isSet) {
        obj.insert(QString("stackUniqueLabel"), ::OpenAPI::toJsonValue(m_stack_unique_label));
    }
    if (m_suppress_expiration_when_objectives_complete_isSet) {
        obj.insert(QString("suppressExpirationWhenObjectivesComplete"), ::OpenAPI::toJsonValue(m_suppress_expiration_when_objectives_complete));
    }
    if (m_tier_type_isSet) {
        obj.insert(QString("tierType"), ::OpenAPI::toJsonValue(m_tier_type));
    }
    if (m_tier_type_hash_isSet) {
        obj.insert(QString("tierTypeHash"), ::OpenAPI::toJsonValue(m_tier_type_hash));
    }
    if (m_tier_type_name_isSet) {
        obj.insert(QString("tierTypeName"), ::OpenAPI::toJsonValue(m_tier_type_name));
    }
    return obj;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getBucketTypeHash() const {
    return m_bucket_type_hash;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setBucketTypeHash(const qint32 &bucket_type_hash) {
    m_bucket_type_hash = bucket_type_hash;
    m_bucket_type_hash_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_bucket_type_hash_Set() const{
    return m_bucket_type_hash_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_bucket_type_hash_Valid() const{
    return m_bucket_type_hash_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getExpirationTooltip() const {
    return m_expiration_tooltip;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setExpirationTooltip(const QString &expiration_tooltip) {
    m_expiration_tooltip = expiration_tooltip;
    m_expiration_tooltip_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expiration_tooltip_Set() const{
    return m_expiration_tooltip_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expiration_tooltip_Valid() const{
    return m_expiration_tooltip_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getExpiredInActivityMessage() const {
    return m_expired_in_activity_message;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setExpiredInActivityMessage(const QString &expired_in_activity_message) {
    m_expired_in_activity_message = expired_in_activity_message;
    m_expired_in_activity_message_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expired_in_activity_message_Set() const{
    return m_expired_in_activity_message_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expired_in_activity_message_Valid() const{
    return m_expired_in_activity_message_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getExpiredInOrbitMessage() const {
    return m_expired_in_orbit_message;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setExpiredInOrbitMessage(const QString &expired_in_orbit_message) {
    m_expired_in_orbit_message = expired_in_orbit_message;
    m_expired_in_orbit_message_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expired_in_orbit_message_Set() const{
    return m_expired_in_orbit_message_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_expired_in_orbit_message_Valid() const{
    return m_expired_in_orbit_message_isValid;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::isIsInstanceItem() const {
    return m_is_instance_item;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setIsInstanceItem(const bool &is_instance_item) {
    m_is_instance_item = is_instance_item;
    m_is_instance_item_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_is_instance_item_Set() const{
    return m_is_instance_item_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_is_instance_item_Valid() const{
    return m_is_instance_item_isValid;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getMaxStackSize() const {
    return m_max_stack_size;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setMaxStackSize(const qint32 &max_stack_size) {
    m_max_stack_size = max_stack_size;
    m_max_stack_size_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_max_stack_size_Set() const{
    return m_max_stack_size_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_max_stack_size_Valid() const{
    return m_max_stack_size_isValid;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getRecipeItemHash() const {
    return m_recipe_item_hash;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setRecipeItemHash(const qint32 &recipe_item_hash) {
    m_recipe_item_hash = recipe_item_hash;
    m_recipe_item_hash_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_recipe_item_hash_Set() const{
    return m_recipe_item_hash_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_recipe_item_hash_Valid() const{
    return m_recipe_item_hash_isValid;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getRecoveryBucketTypeHash() const {
    return m_recovery_bucket_type_hash;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setRecoveryBucketTypeHash(const qint32 &recovery_bucket_type_hash) {
    m_recovery_bucket_type_hash = recovery_bucket_type_hash;
    m_recovery_bucket_type_hash_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_recovery_bucket_type_hash_Set() const{
    return m_recovery_bucket_type_hash_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_recovery_bucket_type_hash_Valid() const{
    return m_recovery_bucket_type_hash_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getStackUniqueLabel() const {
    return m_stack_unique_label;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setStackUniqueLabel(const QString &stack_unique_label) {
    m_stack_unique_label = stack_unique_label;
    m_stack_unique_label_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_stack_unique_label_Set() const{
    return m_stack_unique_label_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_stack_unique_label_Valid() const{
    return m_stack_unique_label_isValid;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::isSuppressExpirationWhenObjectivesComplete() const {
    return m_suppress_expiration_when_objectives_complete;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setSuppressExpirationWhenObjectivesComplete(const bool &suppress_expiration_when_objectives_complete) {
    m_suppress_expiration_when_objectives_complete = suppress_expiration_when_objectives_complete;
    m_suppress_expiration_when_objectives_complete_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_suppress_expiration_when_objectives_complete_Set() const{
    return m_suppress_expiration_when_objectives_complete_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_suppress_expiration_when_objectives_complete_Valid() const{
    return m_suppress_expiration_when_objectives_complete_isValid;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getTierType() const {
    return m_tier_type;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setTierType(const qint32 &tier_type) {
    m_tier_type = tier_type;
    m_tier_type_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_Set() const{
    return m_tier_type_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_Valid() const{
    return m_tier_type_isValid;
}

qint32 OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getTierTypeHash() const {
    return m_tier_type_hash;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setTierTypeHash(const qint32 &tier_type_hash) {
    m_tier_type_hash = tier_type_hash;
    m_tier_type_hash_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_hash_Set() const{
    return m_tier_type_hash_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_hash_Valid() const{
    return m_tier_type_hash_isValid;
}

QString OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::getTierTypeName() const {
    return m_tier_type_name;
}
void OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::setTierTypeName(const QString &tier_type_name) {
    m_tier_type_name = tier_type_name;
    m_tier_type_name_isSet = true;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_name_Set() const{
    return m_tier_type_name_isSet;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::is_tier_type_name_Valid() const{
    return m_tier_type_name_isValid;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bucket_type_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expiration_tooltip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expired_in_activity_message_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expired_in_orbit_message_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_instance_item_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_stack_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recipe_item_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recovery_bucket_type_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stack_unique_label_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suppress_expiration_when_objectives_complete_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tier_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tier_type_hash_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tier_type_name_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDestiny_Definitions_DestinyItemInventoryBlockDefinition::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
