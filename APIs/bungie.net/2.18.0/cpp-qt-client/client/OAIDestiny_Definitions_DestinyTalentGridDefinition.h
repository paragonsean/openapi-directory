/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIDestiny_Definitions_DestinyTalentGridDefinition.h
 *
 * The time has unfortunately come to talk about Talent Grids.  Talent Grids are the most complex and unintuitive part of the Destiny Definition data. Grab a cup of coffee before we begin, I can wait.  Talent Grids were the primary way that items could be customized in Destiny 1. In Destiny 2, for now, talent grids have become exclusively used by Subclass/Build items: but the system is still in place for it to be used by items should the direction change back toward talent grids.  Talent Grids have Nodes: the visual circles on the talent grid detail screen that have icons and can be activated if you meet certain requirements and pay costs. The actual visual data and effects, however, are driven by the \&quot;Steps\&quot; on Talent Nodes. Any given node will have 1:M of these steps, and the specific step that will be considered the \&quot;current\&quot; step (and thus the dictator of all benefits, visual state, and activation requirements on the Node) will almost always not be determined until an instance of the item is created. This is how, in Destiny 1, items were able to have such a wide variety of what users saw as \&quot;Perks\&quot;: they were actually Talent Grids with nodes that had a wide variety of Steps, randomly chosen at the time of item creation.  Now that Talent Grids are used exclusively by subclasses and builds, all of the properties within still apply: but there are additional visual elements on the Subclass/Build screens that are superimposed on top of the talent nodes. Unfortunately, BNet doesn&#39;t have this data: if you want to build a subclass screen, you will have to provide your own \&quot;decorative\&quot; assets, such as the visual connectors between nodes and the fancy colored-fire-bathed character standing behind the nodes.  DestinyInventoryItem.talentGrid.talentGridHash defines an item&#39;s linked Talent Grid, which brings you to this definition that contains enough satic data about talent grids to make your head spin. These *must* be combined with instanced data - found when live data returns DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes and steps within these definitions, which you will then have to look up in the definition and combine with the instanced data to give the user the visual representation of their item&#39;s talent grid.
 */

#ifndef OAIDestiny_Definitions_DestinyTalentGridDefinition_H
#define OAIDestiny_Definitions_DestinyTalentGridDefinition_H

#include <QJsonObject>

#include "OAIDestiny_Definitions_DestinyTalentExclusiveGroup.h"
#include "OAIDestiny_Definitions_DestinyTalentNodeCategory.h"
#include "OAIDestiny_Definitions_DestinyTalentNodeDefinition.h"
#include "OAIDestiny_Definitions_DestinyTalentNodeExclusiveSetDefinition.h"
#include <QList>
#include <QMap>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {
class OAIDestiny_Definitions_DestinyTalentNodeExclusiveSetDefinition;
class OAIDestiny_Definitions_DestinyTalentExclusiveGroup;
class OAIDestiny_Definitions_DestinyTalentNodeCategory;
class OAIDestiny_Definitions_DestinyTalentNodeDefinition;

class OAIDestiny_Definitions_DestinyTalentGridDefinition : public OAIObject {
public:
    OAIDestiny_Definitions_DestinyTalentGridDefinition();
    OAIDestiny_Definitions_DestinyTalentGridDefinition(QString json);
    ~OAIDestiny_Definitions_DestinyTalentGridDefinition() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    QList<OAIDestiny_Definitions_DestinyTalentNodeExclusiveSetDefinition> getExclusiveSets() const;
    void setExclusiveSets(const QList<OAIDestiny_Definitions_DestinyTalentNodeExclusiveSetDefinition> &exclusive_sets);
    bool is_exclusive_sets_Set() const;
    bool is_exclusive_sets_Valid() const;

    qint32 getGridLevelPerColumn() const;
    void setGridLevelPerColumn(const qint32 &grid_level_per_column);
    bool is_grid_level_per_column_Set() const;
    bool is_grid_level_per_column_Valid() const;

    QMap<QString, OAIDestiny_Definitions_DestinyTalentExclusiveGroup> getGroups() const;
    void setGroups(const QMap<QString, OAIDestiny_Definitions_DestinyTalentExclusiveGroup> &groups);
    bool is_groups_Set() const;
    bool is_groups_Valid() const;

    qint32 getHash() const;
    void setHash(const qint32 &hash);
    bool is_hash_Set() const;
    bool is_hash_Valid() const;

    QList<qint32> getIndependentNodeIndexes() const;
    void setIndependentNodeIndexes(const QList<qint32> &independent_node_indexes);
    bool is_independent_node_indexes_Set() const;
    bool is_independent_node_indexes_Valid() const;

    qint32 getIndex() const;
    void setIndex(const qint32 &index);
    bool is_index_Set() const;
    bool is_index_Valid() const;

    qint32 getMaxGridLevel() const;
    void setMaxGridLevel(const qint32 &max_grid_level);
    bool is_max_grid_level_Set() const;
    bool is_max_grid_level_Valid() const;

    QList<OAIDestiny_Definitions_DestinyTalentNodeCategory> getNodeCategories() const;
    void setNodeCategories(const QList<OAIDestiny_Definitions_DestinyTalentNodeCategory> &node_categories);
    bool is_node_categories_Set() const;
    bool is_node_categories_Valid() const;

    QList<OAIDestiny_Definitions_DestinyTalentNodeDefinition> getNodes() const;
    void setNodes(const QList<OAIDestiny_Definitions_DestinyTalentNodeDefinition> &nodes);
    bool is_nodes_Set() const;
    bool is_nodes_Valid() const;

    qint32 getProgressionHash() const;
    void setProgressionHash(const qint32 &progression_hash);
    bool is_progression_hash_Set() const;
    bool is_progression_hash_Valid() const;

    bool isRedacted() const;
    void setRedacted(const bool &redacted);
    bool is_redacted_Set() const;
    bool is_redacted_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    QList<OAIDestiny_Definitions_DestinyTalentNodeExclusiveSetDefinition> m_exclusive_sets;
    bool m_exclusive_sets_isSet;
    bool m_exclusive_sets_isValid;

    qint32 m_grid_level_per_column;
    bool m_grid_level_per_column_isSet;
    bool m_grid_level_per_column_isValid;

    QMap<QString, OAIDestiny_Definitions_DestinyTalentExclusiveGroup> m_groups;
    bool m_groups_isSet;
    bool m_groups_isValid;

    qint32 m_hash;
    bool m_hash_isSet;
    bool m_hash_isValid;

    QList<qint32> m_independent_node_indexes;
    bool m_independent_node_indexes_isSet;
    bool m_independent_node_indexes_isValid;

    qint32 m_index;
    bool m_index_isSet;
    bool m_index_isValid;

    qint32 m_max_grid_level;
    bool m_max_grid_level_isSet;
    bool m_max_grid_level_isValid;

    QList<OAIDestiny_Definitions_DestinyTalentNodeCategory> m_node_categories;
    bool m_node_categories_isSet;
    bool m_node_categories_isValid;

    QList<OAIDestiny_Definitions_DestinyTalentNodeDefinition> m_nodes;
    bool m_nodes_isSet;
    bool m_nodes_isValid;

    qint32 m_progression_hash;
    bool m_progression_hash_isSet;
    bool m_progression_hash_isValid;

    bool m_redacted;
    bool m_redacted_isSet;
    bool m_redacted_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIDestiny_Definitions_DestinyTalentGridDefinition)

#endif // OAIDestiny_Definitions_DestinyTalentGridDefinition_H
