/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDestiny2Api.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIDestiny2Api::OAIDestiny2Api(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIDestiny2Api::~OAIDestiny2Api() {
}

void OAIDestiny2Api::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://www.bungie.net/Platform"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("destiny2_AwaGetActionToken", defaultConf);
    _serverIndices.insert("destiny2_AwaGetActionToken", 0);
    _serverConfigs.insert("destiny2_AwaInitializeRequest", defaultConf);
    _serverIndices.insert("destiny2_AwaInitializeRequest", 0);
    _serverConfigs.insert("destiny2_AwaProvideAuthorizationResult", defaultConf);
    _serverIndices.insert("destiny2_AwaProvideAuthorizationResult", 0);
    _serverConfigs.insert("destiny2_ClearLoadout", defaultConf);
    _serverIndices.insert("destiny2_ClearLoadout", 0);
    _serverConfigs.insert("destiny2_EquipItem", defaultConf);
    _serverIndices.insert("destiny2_EquipItem", 0);
    _serverConfigs.insert("destiny2_EquipItems", defaultConf);
    _serverIndices.insert("destiny2_EquipItems", 0);
    _serverConfigs.insert("destiny2_EquipLoadout", defaultConf);
    _serverIndices.insert("destiny2_EquipLoadout", 0);
    _serverConfigs.insert("destiny2_GetActivityHistory", defaultConf);
    _serverIndices.insert("destiny2_GetActivityHistory", 0);
    _serverConfigs.insert("destiny2_GetCharacter", defaultConf);
    _serverIndices.insert("destiny2_GetCharacter", 0);
    _serverConfigs.insert("destiny2_GetClanAggregateStats", defaultConf);
    _serverIndices.insert("destiny2_GetClanAggregateStats", 0);
    _serverConfigs.insert("destiny2_GetClanBannerSource", defaultConf);
    _serverIndices.insert("destiny2_GetClanBannerSource", 0);
    _serverConfigs.insert("destiny2_GetClanLeaderboards", defaultConf);
    _serverIndices.insert("destiny2_GetClanLeaderboards", 0);
    _serverConfigs.insert("destiny2_GetClanWeeklyRewardState", defaultConf);
    _serverIndices.insert("destiny2_GetClanWeeklyRewardState", 0);
    _serverConfigs.insert("destiny2_GetCollectibleNodeDetails", defaultConf);
    _serverIndices.insert("destiny2_GetCollectibleNodeDetails", 0);
    _serverConfigs.insert("destiny2_GetDestinyAggregateActivityStats", defaultConf);
    _serverIndices.insert("destiny2_GetDestinyAggregateActivityStats", 0);
    _serverConfigs.insert("destiny2_GetDestinyEntityDefinition", defaultConf);
    _serverIndices.insert("destiny2_GetDestinyEntityDefinition", 0);
    _serverConfigs.insert("destiny2_GetDestinyManifest", defaultConf);
    _serverIndices.insert("destiny2_GetDestinyManifest", 0);
    _serverConfigs.insert("destiny2_GetHistoricalStats", defaultConf);
    _serverIndices.insert("destiny2_GetHistoricalStats", 0);
    _serverConfigs.insert("destiny2_GetHistoricalStatsDefinition", defaultConf);
    _serverIndices.insert("destiny2_GetHistoricalStatsDefinition", 0);
    _serverConfigs.insert("destiny2_GetHistoricalStatsForAccount", defaultConf);
    _serverIndices.insert("destiny2_GetHistoricalStatsForAccount", 0);
    _serverConfigs.insert("destiny2_GetItem", defaultConf);
    _serverIndices.insert("destiny2_GetItem", 0);
    _serverConfigs.insert("destiny2_GetLeaderboards", defaultConf);
    _serverIndices.insert("destiny2_GetLeaderboards", 0);
    _serverConfigs.insert("destiny2_GetLeaderboardsForCharacter", defaultConf);
    _serverIndices.insert("destiny2_GetLeaderboardsForCharacter", 0);
    _serverConfigs.insert("destiny2_GetLinkedProfiles", defaultConf);
    _serverIndices.insert("destiny2_GetLinkedProfiles", 0);
    _serverConfigs.insert("destiny2_GetPostGameCarnageReport", defaultConf);
    _serverIndices.insert("destiny2_GetPostGameCarnageReport", 0);
    _serverConfigs.insert("destiny2_GetProfile", defaultConf);
    _serverIndices.insert("destiny2_GetProfile", 0);
    _serverConfigs.insert("destiny2_GetPublicMilestoneContent", defaultConf);
    _serverIndices.insert("destiny2_GetPublicMilestoneContent", 0);
    _serverConfigs.insert("destiny2_GetPublicMilestones", defaultConf);
    _serverIndices.insert("destiny2_GetPublicMilestones", 0);
    _serverConfigs.insert("destiny2_GetPublicVendors", defaultConf);
    _serverIndices.insert("destiny2_GetPublicVendors", 0);
    _serverConfigs.insert("destiny2_GetUniqueWeaponHistory", defaultConf);
    _serverIndices.insert("destiny2_GetUniqueWeaponHistory", 0);
    _serverConfigs.insert("destiny2_GetVendor", defaultConf);
    _serverIndices.insert("destiny2_GetVendor", 0);
    _serverConfigs.insert("destiny2_GetVendors", defaultConf);
    _serverIndices.insert("destiny2_GetVendors", 0);
    _serverConfigs.insert("destiny2_InsertSocketPlug", defaultConf);
    _serverIndices.insert("destiny2_InsertSocketPlug", 0);
    _serverConfigs.insert("destiny2_InsertSocketPlugFree", defaultConf);
    _serverIndices.insert("destiny2_InsertSocketPlugFree", 0);
    _serverConfigs.insert("destiny2_PullFromPostmaster", defaultConf);
    _serverIndices.insert("destiny2_PullFromPostmaster", 0);
    _serverConfigs.insert("destiny2_ReportOffensivePostGameCarnageReportPlayer", defaultConf);
    _serverIndices.insert("destiny2_ReportOffensivePostGameCarnageReportPlayer", 0);
    _serverConfigs.insert("destiny2_SearchDestinyEntities", defaultConf);
    _serverIndices.insert("destiny2_SearchDestinyEntities", 0);
    _serverConfigs.insert("destiny2_SearchDestinyPlayerByBungieName", defaultConf);
    _serverIndices.insert("destiny2_SearchDestinyPlayerByBungieName", 0);
    _serverConfigs.insert("destiny2_SetItemLockState", defaultConf);
    _serverIndices.insert("destiny2_SetItemLockState", 0);
    _serverConfigs.insert("destiny2_SetQuestTrackedState", defaultConf);
    _serverIndices.insert("destiny2_SetQuestTrackedState", 0);
    _serverConfigs.insert("destiny2_SnapshotLoadout", defaultConf);
    _serverIndices.insert("destiny2_SnapshotLoadout", 0);
    _serverConfigs.insert("destiny2_TransferItem", defaultConf);
    _serverIndices.insert("destiny2_TransferItem", 0);
    _serverConfigs.insert("destiny2_UpdateLoadoutIdentifiers", defaultConf);
    _serverIndices.insert("destiny2_UpdateLoadoutIdentifiers", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIDestiny2Api::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIDestiny2Api::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIDestiny2Api::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIDestiny2Api::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIDestiny2Api::setUsername(const QString &username) {
    _username = username;
}

void OAIDestiny2Api::setPassword(const QString &password) {
    _password = password;
}


void OAIDestiny2Api::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIDestiny2Api::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIDestiny2Api::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIDestiny2Api::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDestiny2Api::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDestiny2Api::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIDestiny2Api::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIDestiny2Api::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIDestiny2Api::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIDestiny2Api::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIDestiny2Api::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIDestiny2Api::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIDestiny2Api::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIDestiny2Api::destiny2_AwaGetActionToken(const QString &correlation_id) {
    QString fullPath = QString(_serverConfigs["destiny2_AwaGetActionToken"][_serverIndices.value("destiny2_AwaGetActionToken")].URL()+"/Destiny2/Awa/GetActionToken/{correlationId}/");
    
    
    {
        QString correlation_idPathParam("{");
        correlation_idPathParam.append("correlationId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "correlationId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"correlationId"+pathSuffix : pathPrefix;
        fullPath.replace(correlation_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(correlation_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_AwaGetActionTokenCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("AdvancedWriteActions");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_AwaGetActionTokenCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_AwaGetActionTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_AwaGetActionToken_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_AwaGetActionTokenSignal(output);
        Q_EMIT destiny2_AwaGetActionTokenSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("AdvancedWriteActions");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_AwaGetActionTokenSignalE(output, error_type, error_str);
        Q_EMIT destiny2_AwaGetActionTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_AwaGetActionTokenSignalError(output, error_type, error_str);
        Q_EMIT destiny2_AwaGetActionTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_AwaInitializeRequest() {
    QString fullPath = QString(_serverConfigs["destiny2_AwaInitializeRequest"][_serverIndices.value("destiny2_AwaInitializeRequest")].URL()+"/Destiny2/Awa/Initialize/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_AwaInitializeRequestCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("AdvancedWriteActions");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_AwaInitializeRequestCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_AwaInitializeRequestCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_AwaInitializeRequest_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_AwaInitializeRequestSignal(output);
        Q_EMIT destiny2_AwaInitializeRequestSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("AdvancedWriteActions");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_AwaInitializeRequestSignalE(output, error_type, error_str);
        Q_EMIT destiny2_AwaInitializeRequestSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_AwaInitializeRequestSignalError(output, error_type, error_str);
        Q_EMIT destiny2_AwaInitializeRequestSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_AwaProvideAuthorizationResult() {
    QString fullPath = QString(_serverConfigs["destiny2_AwaProvideAuthorizationResult"][_serverIndices.value("destiny2_AwaProvideAuthorizationResult")].URL()+"/Destiny2/Awa/AwaProvideAuthorizationResult/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_AwaProvideAuthorizationResultCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_AwaProvideAuthorizationResultCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_AwaProvideAuthorizationResultSignal(output);
        Q_EMIT destiny2_AwaProvideAuthorizationResultSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_AwaProvideAuthorizationResultSignalE(output, error_type, error_str);
        Q_EMIT destiny2_AwaProvideAuthorizationResultSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_AwaProvideAuthorizationResultSignalError(output, error_type, error_str);
        Q_EMIT destiny2_AwaProvideAuthorizationResultSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_ClearLoadout() {
    QString fullPath = QString(_serverConfigs["destiny2_ClearLoadout"][_serverIndices.value("destiny2_ClearLoadout")].URL()+"/Destiny2/Actions/Loadouts/ClearLoadout/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_ClearLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_ClearLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_ClearLoadoutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_ClearLoadoutSignal(output);
        Q_EMIT destiny2_ClearLoadoutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_ClearLoadoutSignalE(output, error_type, error_str);
        Q_EMIT destiny2_ClearLoadoutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_ClearLoadoutSignalError(output, error_type, error_str);
        Q_EMIT destiny2_ClearLoadoutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_EquipItem() {
    QString fullPath = QString(_serverConfigs["destiny2_EquipItem"][_serverIndices.value("destiny2_EquipItem")].URL()+"/Destiny2/Actions/Items/EquipItem/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipItemCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipItemCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_EquipItemCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_EquipItemSignal(output);
        Q_EMIT destiny2_EquipItemSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_EquipItemSignalE(output, error_type, error_str);
        Q_EMIT destiny2_EquipItemSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_EquipItemSignalError(output, error_type, error_str);
        Q_EMIT destiny2_EquipItemSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_EquipItems() {
    QString fullPath = QString(_serverConfigs["destiny2_EquipItems"][_serverIndices.value("destiny2_EquipItems")].URL()+"/Destiny2/Actions/Items/EquipItems/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipItemsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipItemsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_EquipItemsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItems_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_EquipItemsSignal(output);
        Q_EMIT destiny2_EquipItemsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_EquipItemsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_EquipItemsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_EquipItemsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_EquipItemsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_EquipLoadout() {
    QString fullPath = QString(_serverConfigs["destiny2_EquipLoadout"][_serverIndices.value("destiny2_EquipLoadout")].URL()+"/Destiny2/Actions/Loadouts/EquipLoadout/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_EquipLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_EquipLoadoutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_EquipLoadoutSignal(output);
        Q_EMIT destiny2_EquipLoadoutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_EquipLoadoutSignalE(output, error_type, error_str);
        Q_EMIT destiny2_EquipLoadoutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_EquipLoadoutSignalError(output, error_type, error_str);
        Q_EMIT destiny2_EquipLoadoutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetActivityHistory(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<qint32> &count, const ::OpenAPI::OptionalParam<qint32> &mode, const ::OpenAPI::OptionalParam<qint32> &page) {
    QString fullPath = QString(_serverConfigs["destiny2_GetActivityHistory"][_serverIndices.value("destiny2_GetActivityHistory")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (count.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "count", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("count")).append(querySuffix).append(QUrl::toPercentEncoding(count.stringValue()));
    }
    if (mode.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "mode", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("mode")).append(querySuffix).append(QUrl::toPercentEncoding(mode.stringValue()));
    }
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetActivityHistoryCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetActivityHistoryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetActivityHistory_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetActivityHistorySignal(output);
        Q_EMIT destiny2_GetActivityHistorySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetActivityHistorySignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetActivityHistorySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetActivityHistorySignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetActivityHistorySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetCharacter(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetCharacter"][_serverIndices.value("destiny2_GetCharacter")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetCharacterCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetCharacterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetCharacter_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetCharacterSignal(output);
        Q_EMIT destiny2_GetCharacterSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetCharacterSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetCharacterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetCharacterSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetCharacterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetClanAggregateStats(const qint64 &group_id, const ::OpenAPI::OptionalParam<QString> &modes) {
    QString fullPath = QString(_serverConfigs["destiny2_GetClanAggregateStats"][_serverIndices.value("destiny2_GetClanAggregateStats")].URL()+"/Destiny2/Stats/AggregateClanStats/{groupId}/");
    
    
    {
        QString group_idPathParam("{");
        group_idPathParam.append("groupId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "groupId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"groupId"+pathSuffix : pathPrefix;
        fullPath.replace(group_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(group_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (modes.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "modes", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("modes")).append(querySuffix).append(QUrl::toPercentEncoding(modes.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetClanAggregateStatsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetClanAggregateStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanAggregateStats_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetClanAggregateStatsSignal(output);
        Q_EMIT destiny2_GetClanAggregateStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetClanAggregateStatsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetClanAggregateStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetClanAggregateStatsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetClanAggregateStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetClanBannerSource() {
    QString fullPath = QString(_serverConfigs["destiny2_GetClanBannerSource"][_serverIndices.value("destiny2_GetClanBannerSource")].URL()+"/Destiny2/Clan/ClanBannerDictionary/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetClanBannerSourceCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetClanBannerSourceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanBannerSource_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetClanBannerSourceSignal(output);
        Q_EMIT destiny2_GetClanBannerSourceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetClanBannerSourceSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetClanBannerSourceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetClanBannerSourceSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetClanBannerSourceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetClanLeaderboards(const qint64 &group_id, const ::OpenAPI::OptionalParam<qint32> &maxtop, const ::OpenAPI::OptionalParam<QString> &modes, const ::OpenAPI::OptionalParam<QString> &statid) {
    QString fullPath = QString(_serverConfigs["destiny2_GetClanLeaderboards"][_serverIndices.value("destiny2_GetClanLeaderboards")].URL()+"/Destiny2/Stats/Leaderboards/Clans/{groupId}/");
    
    
    {
        QString group_idPathParam("{");
        group_idPathParam.append("groupId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "groupId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"groupId"+pathSuffix : pathPrefix;
        fullPath.replace(group_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(group_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (maxtop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "maxtop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("maxtop")).append(querySuffix).append(QUrl::toPercentEncoding(maxtop.stringValue()));
    }
    if (modes.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "modes", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("modes")).append(querySuffix).append(QUrl::toPercentEncoding(modes.stringValue()));
    }
    if (statid.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "statid", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("statid")).append(querySuffix).append(QUrl::toPercentEncoding(statid.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetClanLeaderboardsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetClanLeaderboardsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanLeaderboards_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetClanLeaderboardsSignal(output);
        Q_EMIT destiny2_GetClanLeaderboardsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetClanLeaderboardsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetClanLeaderboardsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetClanLeaderboardsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetClanLeaderboardsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetClanWeeklyRewardState(const qint64 &group_id) {
    QString fullPath = QString(_serverConfigs["destiny2_GetClanWeeklyRewardState"][_serverIndices.value("destiny2_GetClanWeeklyRewardState")].URL()+"/Destiny2/Clan/{groupId}/WeeklyRewardState/");
    
    
    {
        QString group_idPathParam("{");
        group_idPathParam.append("groupId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "groupId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"groupId"+pathSuffix : pathPrefix;
        fullPath.replace(group_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(group_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetClanWeeklyRewardStateCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetClanWeeklyRewardStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanWeeklyRewardState_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetClanWeeklyRewardStateSignal(output);
        Q_EMIT destiny2_GetClanWeeklyRewardStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetClanWeeklyRewardStateSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetClanWeeklyRewardStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetClanWeeklyRewardStateSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetClanWeeklyRewardStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetCollectibleNodeDetails(const qint64 &character_id, const qint32 &collectible_presentation_node_hash, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetCollectibleNodeDetails"][_serverIndices.value("destiny2_GetCollectibleNodeDetails")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString collectible_presentation_node_hashPathParam("{");
        collectible_presentation_node_hashPathParam.append("collectiblePresentationNodeHash").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "collectiblePresentationNodeHash", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"collectiblePresentationNodeHash"+pathSuffix : pathPrefix;
        fullPath.replace(collectible_presentation_node_hashPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(collectible_presentation_node_hash)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetCollectibleNodeDetailsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetCollectibleNodeDetailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetCollectibleNodeDetails_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetCollectibleNodeDetailsSignal(output);
        Q_EMIT destiny2_GetCollectibleNodeDetailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetCollectibleNodeDetailsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetCollectibleNodeDetailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetCollectibleNodeDetailsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetCollectibleNodeDetailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetDestinyAggregateActivityStats(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type) {
    QString fullPath = QString(_serverConfigs["destiny2_GetDestinyAggregateActivityStats"][_serverIndices.value("destiny2_GetDestinyAggregateActivityStats")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetDestinyAggregateActivityStatsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetDestinyAggregateActivityStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetDestinyAggregateActivityStats_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignal(output);
        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyAggregateActivityStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetDestinyEntityDefinition(const QString &entity_type, const qint32 &hash_identifier) {
    QString fullPath = QString(_serverConfigs["destiny2_GetDestinyEntityDefinition"][_serverIndices.value("destiny2_GetDestinyEntityDefinition")].URL()+"/Destiny2/Manifest/{entityType}/{hashIdentifier}/");
    
    
    {
        QString entity_typePathParam("{");
        entity_typePathParam.append("entityType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entityType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entityType"+pathSuffix : pathPrefix;
        fullPath.replace(entity_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(entity_type)));
    }
    
    {
        QString hash_identifierPathParam("{");
        hash_identifierPathParam.append("hashIdentifier").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "hashIdentifier", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"hashIdentifier"+pathSuffix : pathPrefix;
        fullPath.replace(hash_identifierPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(hash_identifier)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetDestinyEntityDefinitionCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetDestinyEntityDefinitionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetDestinyEntityDefinition_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetDestinyEntityDefinitionSignal(output);
        Q_EMIT destiny2_GetDestinyEntityDefinitionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetDestinyEntityDefinitionSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyEntityDefinitionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetDestinyEntityDefinitionSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyEntityDefinitionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetDestinyManifest() {
    QString fullPath = QString(_serverConfigs["destiny2_GetDestinyManifest"][_serverIndices.value("destiny2_GetDestinyManifest")].URL()+"/Destiny2/Manifest/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetDestinyManifestCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetDestinyManifestCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetDestinyManifest_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetDestinyManifestSignal(output);
        Q_EMIT destiny2_GetDestinyManifestSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetDestinyManifestSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyManifestSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetDestinyManifestSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetDestinyManifestSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetHistoricalStats(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QDateTime> &dayend, const ::OpenAPI::OptionalParam<QDateTime> &daystart, const ::OpenAPI::OptionalParam<QList<qint32>> &groups, const ::OpenAPI::OptionalParam<QList<qint32>> &modes, const ::OpenAPI::OptionalParam<qint32> &period_type) {
    QString fullPath = QString(_serverConfigs["destiny2_GetHistoricalStats"][_serverIndices.value("destiny2_GetHistoricalStats")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (dayend.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dayend", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dayend")).append(querySuffix).append(QUrl::toPercentEncoding(dayend.stringValue()));
    }
    if (daystart.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "daystart", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("daystart")).append(querySuffix).append(QUrl::toPercentEncoding(daystart.stringValue()));
    }
    if (groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "groups", false);
        if (groups.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (modes.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "modes", false);
        if (modes.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : modes.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("modes=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("modes").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : modes.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("modes").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : modes.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("modes").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : modes.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("modes").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : modes.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("modes").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : modes.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (period_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "periodType", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("periodType")).append(querySuffix).append(QUrl::toPercentEncoding(period_type.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetHistoricalStatsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetHistoricalStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetHistoricalStats_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetHistoricalStatsSignal(output);
        Q_EMIT destiny2_GetHistoricalStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetHistoricalStatsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetHistoricalStatsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetHistoricalStatsDefinition() {
    QString fullPath = QString(_serverConfigs["destiny2_GetHistoricalStatsDefinition"][_serverIndices.value("destiny2_GetHistoricalStatsDefinition")].URL()+"/Destiny2/Stats/Definition/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetHistoricalStatsDefinitionCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetHistoricalStatsDefinitionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetHistoricalStatsDefinition_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignal(output);
        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsDefinitionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetHistoricalStatsForAccount(const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &groups) {
    QString fullPath = QString(_serverConfigs["destiny2_GetHistoricalStatsForAccount"][_serverIndices.value("destiny2_GetHistoricalStatsForAccount")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/");
    
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (groups.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "groups", false);
        if (groups.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : groups.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("groups=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("groups").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : groups.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetHistoricalStatsForAccountCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetHistoricalStatsForAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetHistoricalStatsForAccount_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetHistoricalStatsForAccountSignal(output);
        Q_EMIT destiny2_GetHistoricalStatsForAccountSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetHistoricalStatsForAccountSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsForAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetHistoricalStatsForAccountSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetHistoricalStatsForAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetItem(const qint64 &destiny_membership_id, const qint64 &item_instance_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetItem"][_serverIndices.value("destiny2_GetItem")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/");
    
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString item_instance_idPathParam("{");
        item_instance_idPathParam.append("itemInstanceId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "itemInstanceId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"itemInstanceId"+pathSuffix : pathPrefix;
        fullPath.replace(item_instance_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(item_instance_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetItemCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetItemCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetItemSignal(output);
        Q_EMIT destiny2_GetItemSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetItemSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetItemSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetItemSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetItemSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetLeaderboards(const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<qint32> &maxtop, const ::OpenAPI::OptionalParam<QString> &modes, const ::OpenAPI::OptionalParam<QString> &statid) {
    QString fullPath = QString(_serverConfigs["destiny2_GetLeaderboards"][_serverIndices.value("destiny2_GetLeaderboards")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/");
    
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (maxtop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "maxtop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("maxtop")).append(querySuffix).append(QUrl::toPercentEncoding(maxtop.stringValue()));
    }
    if (modes.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "modes", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("modes")).append(querySuffix).append(QUrl::toPercentEncoding(modes.stringValue()));
    }
    if (statid.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "statid", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("statid")).append(querySuffix).append(QUrl::toPercentEncoding(statid.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetLeaderboardsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetLeaderboardsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanLeaderboards_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetLeaderboardsSignal(output);
        Q_EMIT destiny2_GetLeaderboardsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetLeaderboardsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetLeaderboardsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetLeaderboardsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetLeaderboardsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetLeaderboardsForCharacter(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<qint32> &maxtop, const ::OpenAPI::OptionalParam<QString> &modes, const ::OpenAPI::OptionalParam<QString> &statid) {
    QString fullPath = QString(_serverConfigs["destiny2_GetLeaderboardsForCharacter"][_serverIndices.value("destiny2_GetLeaderboardsForCharacter")].URL()+"/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (maxtop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "maxtop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("maxtop")).append(querySuffix).append(QUrl::toPercentEncoding(maxtop.stringValue()));
    }
    if (modes.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "modes", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("modes")).append(querySuffix).append(QUrl::toPercentEncoding(modes.stringValue()));
    }
    if (statid.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "statid", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("statid")).append(querySuffix).append(QUrl::toPercentEncoding(statid.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetLeaderboardsForCharacterCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetLeaderboardsForCharacterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetClanLeaderboards_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetLeaderboardsForCharacterSignal(output);
        Q_EMIT destiny2_GetLeaderboardsForCharacterSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetLeaderboardsForCharacterSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetLeaderboardsForCharacterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetLeaderboardsForCharacterSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetLeaderboardsForCharacterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetLinkedProfiles(const qint64 &membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<bool> &get_all_memberships) {
    QString fullPath = QString(_serverConfigs["destiny2_GetLinkedProfiles"][_serverIndices.value("destiny2_GetLinkedProfiles")].URL()+"/Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/");
    
    
    {
        QString membership_idPathParam("{");
        membership_idPathParam.append("membershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipId"+pathSuffix : pathPrefix;
        fullPath.replace(membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (get_all_memberships.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "getAllMemberships", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("getAllMemberships")).append(querySuffix).append(QUrl::toPercentEncoding(get_all_memberships.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetLinkedProfilesCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetLinkedProfilesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetLinkedProfiles_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetLinkedProfilesSignal(output);
        Q_EMIT destiny2_GetLinkedProfilesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetLinkedProfilesSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetLinkedProfilesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetLinkedProfilesSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetLinkedProfilesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetPostGameCarnageReport(const qint64 &activity_id) {
    QString fullPath = QString(_serverConfigs["destiny2_GetPostGameCarnageReport"][_serverIndices.value("destiny2_GetPostGameCarnageReport")].URL()+"/Destiny2/Stats/PostGameCarnageReport/{activityId}/");
    
    
    {
        QString activity_idPathParam("{");
        activity_idPathParam.append("activityId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "activityId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"activityId"+pathSuffix : pathPrefix;
        fullPath.replace(activity_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(activity_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetPostGameCarnageReportCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetPostGameCarnageReportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetPostGameCarnageReport_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetPostGameCarnageReportSignal(output);
        Q_EMIT destiny2_GetPostGameCarnageReportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetPostGameCarnageReportSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetPostGameCarnageReportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetPostGameCarnageReportSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetPostGameCarnageReportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetProfile(const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetProfile"][_serverIndices.value("destiny2_GetProfile")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/");
    
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetProfileCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetProfileCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetProfile_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetProfileSignal(output);
        Q_EMIT destiny2_GetProfileSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetProfileSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetProfileSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetProfileSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetProfileSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetPublicMilestoneContent(const qint32 &milestone_hash) {
    QString fullPath = QString(_serverConfigs["destiny2_GetPublicMilestoneContent"][_serverIndices.value("destiny2_GetPublicMilestoneContent")].URL()+"/Destiny2/Milestones/{milestoneHash}/Content/");
    
    
    {
        QString milestone_hashPathParam("{");
        milestone_hashPathParam.append("milestoneHash").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "milestoneHash", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"milestoneHash"+pathSuffix : pathPrefix;
        fullPath.replace(milestone_hashPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(milestone_hash)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetPublicMilestoneContentCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetPublicMilestoneContentCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetPublicMilestoneContent_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetPublicMilestoneContentSignal(output);
        Q_EMIT destiny2_GetPublicMilestoneContentSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetPublicMilestoneContentSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicMilestoneContentSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetPublicMilestoneContentSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicMilestoneContentSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetPublicMilestones() {
    QString fullPath = QString(_serverConfigs["destiny2_GetPublicMilestones"][_serverIndices.value("destiny2_GetPublicMilestones")].URL()+"/Destiny2/Milestones/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetPublicMilestonesCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetPublicMilestonesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetPublicMilestones_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetPublicMilestonesSignal(output);
        Q_EMIT destiny2_GetPublicMilestonesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetPublicMilestonesSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicMilestonesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetPublicMilestonesSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicMilestonesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetPublicVendors(const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetPublicVendors"][_serverIndices.value("destiny2_GetPublicVendors")].URL()+"/Destiny2/Vendors/");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetPublicVendorsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetPublicVendorsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetPublicVendors_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetPublicVendorsSignal(output);
        Q_EMIT destiny2_GetPublicVendorsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetPublicVendorsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicVendorsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetPublicVendorsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetPublicVendorsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetUniqueWeaponHistory(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type) {
    QString fullPath = QString(_serverConfigs["destiny2_GetUniqueWeaponHistory"][_serverIndices.value("destiny2_GetUniqueWeaponHistory")].URL()+"/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetUniqueWeaponHistoryCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetUniqueWeaponHistoryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetUniqueWeaponHistory_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetUniqueWeaponHistorySignal(output);
        Q_EMIT destiny2_GetUniqueWeaponHistorySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetUniqueWeaponHistorySignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetUniqueWeaponHistorySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetUniqueWeaponHistorySignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetUniqueWeaponHistorySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetVendor(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const qint32 &vendor_hash, const ::OpenAPI::OptionalParam<QList<qint32>> &components) {
    QString fullPath = QString(_serverConfigs["destiny2_GetVendor"][_serverIndices.value("destiny2_GetVendor")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    
    {
        QString vendor_hashPathParam("{");
        vendor_hashPathParam.append("vendorHash").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "vendorHash", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"vendorHash"+pathSuffix : pathPrefix;
        fullPath.replace(vendor_hashPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(vendor_hash)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetVendorCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetVendorCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetVendor_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetVendorSignal(output);
        Q_EMIT destiny2_GetVendorSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetVendorSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetVendorSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetVendorSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetVendorSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_GetVendors(const qint64 &character_id, const qint64 &destiny_membership_id, const qint32 &membership_type, const ::OpenAPI::OptionalParam<QList<qint32>> &components, const ::OpenAPI::OptionalParam<qint32> &filter) {
    QString fullPath = QString(_serverConfigs["destiny2_GetVendors"][_serverIndices.value("destiny2_GetVendors")].URL()+"/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/");
    
    
    {
        QString character_idPathParam("{");
        character_idPathParam.append("characterId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "characterId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"characterId"+pathSuffix : pathPrefix;
        fullPath.replace(character_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(character_id)));
    }
    
    {
        QString destiny_membership_idPathParam("{");
        destiny_membership_idPathParam.append("destinyMembershipId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "destinyMembershipId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"destinyMembershipId"+pathSuffix : pathPrefix;
        fullPath.replace(destiny_membership_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(destiny_membership_id)));
    }
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "components", false);
        if (components.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (qint32 t : components.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("components=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("components").append(querySuffix);
                qint32 count = 0;
                for (qint32 t : components.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (filter.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("filter")).append(querySuffix).append(QUrl::toPercentEncoding(filter.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_GetVendorsCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_GetVendorsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_GetVendors_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_GetVendorsSignal(output);
        Q_EMIT destiny2_GetVendorsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_GetVendorsSignalE(output, error_type, error_str);
        Q_EMIT destiny2_GetVendorsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_GetVendorsSignalError(output, error_type, error_str);
        Q_EMIT destiny2_GetVendorsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_InsertSocketPlug() {
    QString fullPath = QString(_serverConfigs["destiny2_InsertSocketPlug"][_serverIndices.value("destiny2_InsertSocketPlug")].URL()+"/Destiny2/Actions/Items/InsertSocketPlug/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_InsertSocketPlugCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("AdvancedWriteActions");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_InsertSocketPlugCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_InsertSocketPlugCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_InsertSocketPlug_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_InsertSocketPlugSignal(output);
        Q_EMIT destiny2_InsertSocketPlugSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("AdvancedWriteActions");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_InsertSocketPlugSignalE(output, error_type, error_str);
        Q_EMIT destiny2_InsertSocketPlugSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_InsertSocketPlugSignalError(output, error_type, error_str);
        Q_EMIT destiny2_InsertSocketPlugSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_InsertSocketPlugFree() {
    QString fullPath = QString(_serverConfigs["destiny2_InsertSocketPlugFree"][_serverIndices.value("destiny2_InsertSocketPlugFree")].URL()+"/Destiny2/Actions/Items/InsertSocketPlugFree/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_InsertSocketPlugFreeCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_InsertSocketPlugFreeCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_InsertSocketPlugFreeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_InsertSocketPlug_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_InsertSocketPlugFreeSignal(output);
        Q_EMIT destiny2_InsertSocketPlugFreeSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_InsertSocketPlugFreeSignalE(output, error_type, error_str);
        Q_EMIT destiny2_InsertSocketPlugFreeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_InsertSocketPlugFreeSignalError(output, error_type, error_str);
        Q_EMIT destiny2_InsertSocketPlugFreeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_PullFromPostmaster() {
    QString fullPath = QString(_serverConfigs["destiny2_PullFromPostmaster"][_serverIndices.value("destiny2_PullFromPostmaster")].URL()+"/Destiny2/Actions/Items/PullFromPostmaster/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_PullFromPostmasterCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_PullFromPostmasterCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_PullFromPostmasterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_PullFromPostmasterSignal(output);
        Q_EMIT destiny2_PullFromPostmasterSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_PullFromPostmasterSignalE(output, error_type, error_str);
        Q_EMIT destiny2_PullFromPostmasterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_PullFromPostmasterSignalError(output, error_type, error_str);
        Q_EMIT destiny2_PullFromPostmasterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_ReportOffensivePostGameCarnageReportPlayer(const qint64 &activity_id) {
    QString fullPath = QString(_serverConfigs["destiny2_ReportOffensivePostGameCarnageReportPlayer"][_serverIndices.value("destiny2_ReportOffensivePostGameCarnageReportPlayer")].URL()+"/Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/");
    
    
    {
        QString activity_idPathParam("{");
        activity_idPathParam.append("activityId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "activityId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"activityId"+pathSuffix : pathPrefix;
        fullPath.replace(activity_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(activity_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_ReportOffensivePostGameCarnageReportPlayerCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("BnetWrite");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_ReportOffensivePostGameCarnageReportPlayerCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_ReportOffensivePostGameCarnageReportPlayerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignal(output);
        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("BnetWrite");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignalE(output, error_type, error_str);
        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignalError(output, error_type, error_str);
        Q_EMIT destiny2_ReportOffensivePostGameCarnageReportPlayerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_SearchDestinyEntities(const QString &search_term, const QString &type, const ::OpenAPI::OptionalParam<qint32> &page) {
    QString fullPath = QString(_serverConfigs["destiny2_SearchDestinyEntities"][_serverIndices.value("destiny2_SearchDestinyEntities")].URL()+"/Destiny2/Armory/Search/{type}/{searchTerm}/");
    
    
    {
        QString search_termPathParam("{");
        search_termPathParam.append("searchTerm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "searchTerm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"searchTerm"+pathSuffix : pathPrefix;
        fullPath.replace(search_termPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(search_term)));
    }
    
    {
        QString typePathParam("{");
        typePathParam.append("type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"type"+pathSuffix : pathPrefix;
        fullPath.replace(typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(type)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SearchDestinyEntitiesCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_SearchDestinyEntitiesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_SearchDestinyEntities_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_SearchDestinyEntitiesSignal(output);
        Q_EMIT destiny2_SearchDestinyEntitiesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_SearchDestinyEntitiesSignalE(output, error_type, error_str);
        Q_EMIT destiny2_SearchDestinyEntitiesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_SearchDestinyEntitiesSignalError(output, error_type, error_str);
        Q_EMIT destiny2_SearchDestinyEntitiesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_SearchDestinyPlayerByBungieName(const qint32 &membership_type) {
    QString fullPath = QString(_serverConfigs["destiny2_SearchDestinyPlayerByBungieName"][_serverIndices.value("destiny2_SearchDestinyPlayerByBungieName")].URL()+"/Destiny2/SearchDestinyPlayerByBungieName/{membershipType}/");
    
    
    {
        QString membership_typePathParam("{");
        membership_typePathParam.append("membershipType").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "membershipType", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"membershipType"+pathSuffix : pathPrefix;
        fullPath.replace(membership_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(membership_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SearchDestinyPlayerByBungieNameCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_SearchDestinyPlayerByBungieNameCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_SearchDestinyPlayerByBungieName_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignal(output);
        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignalE(output, error_type, error_str);
        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignalError(output, error_type, error_str);
        Q_EMIT destiny2_SearchDestinyPlayerByBungieNameSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_SetItemLockState() {
    QString fullPath = QString(_serverConfigs["destiny2_SetItemLockState"][_serverIndices.value("destiny2_SetItemLockState")].URL()+"/Destiny2/Actions/Items/SetLockState/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SetItemLockStateCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SetItemLockStateCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_SetItemLockStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_SetItemLockStateSignal(output);
        Q_EMIT destiny2_SetItemLockStateSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_SetItemLockStateSignalE(output, error_type, error_str);
        Q_EMIT destiny2_SetItemLockStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_SetItemLockStateSignalError(output, error_type, error_str);
        Q_EMIT destiny2_SetItemLockStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_SetQuestTrackedState() {
    QString fullPath = QString(_serverConfigs["destiny2_SetQuestTrackedState"][_serverIndices.value("destiny2_SetQuestTrackedState")].URL()+"/Destiny2/Actions/Items/SetTrackedState/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SetQuestTrackedStateCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SetQuestTrackedStateCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_SetQuestTrackedStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_SetQuestTrackedStateSignal(output);
        Q_EMIT destiny2_SetQuestTrackedStateSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_SetQuestTrackedStateSignalE(output, error_type, error_str);
        Q_EMIT destiny2_SetQuestTrackedStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_SetQuestTrackedStateSignalError(output, error_type, error_str);
        Q_EMIT destiny2_SetQuestTrackedStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_SnapshotLoadout() {
    QString fullPath = QString(_serverConfigs["destiny2_SnapshotLoadout"][_serverIndices.value("destiny2_SnapshotLoadout")].URL()+"/Destiny2/Actions/Loadouts/SnapshotLoadout/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SnapshotLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_SnapshotLoadoutCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_SnapshotLoadoutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_SnapshotLoadoutSignal(output);
        Q_EMIT destiny2_SnapshotLoadoutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_SnapshotLoadoutSignalE(output, error_type, error_str);
        Q_EMIT destiny2_SnapshotLoadoutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_SnapshotLoadoutSignalError(output, error_type, error_str);
        Q_EMIT destiny2_SnapshotLoadoutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_TransferItem() {
    QString fullPath = QString(_serverConfigs["destiny2_TransferItem"][_serverIndices.value("destiny2_TransferItem")].URL()+"/Destiny2/Actions/Items/TransferItem/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_TransferItemCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_TransferItemCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_TransferItemCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_TransferItemSignal(output);
        Q_EMIT destiny2_TransferItemSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_TransferItemSignalE(output, error_type, error_str);
        Q_EMIT destiny2_TransferItemSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_TransferItemSignalError(output, error_type, error_str);
        Q_EMIT destiny2_TransferItemSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::destiny2_UpdateLoadoutIdentifiers() {
    QString fullPath = QString(_serverConfigs["destiny2_UpdateLoadoutIdentifiers"][_serverIndices.value("destiny2_UpdateLoadoutIdentifiers")].URL()+"/Destiny2/Actions/Loadouts/UpdateLoadoutIdentifiers/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_UpdateLoadoutIdentifiersCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("MoveEquipDestinyItems");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDestiny2Api::destiny2_UpdateLoadoutIdentifiersCallback);
    connect(this, &OAIDestiny2Api::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDestiny2Api::destiny2_UpdateLoadoutIdentifiersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDestiny2_EquipItem_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignal(output);
        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("MoveEquipDestinyItems");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://www.bungie.net/en/OAuth/Authorize");
        QString tokenUrl("https://www.bungie.net/Platform/App/OAuth/token/");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignalE(output, error_type, error_str);
        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignalError(output, error_type, error_str);
        Q_EMIT destiny2_UpdateLoadoutIdentifiersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDestiny2Api::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
