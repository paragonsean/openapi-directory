/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.DestinyDefinitionsDestinyInventoryItemStatDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information about the item&#39;s calculated stats, with as much data as we can find for the stats without having an actual instance of the item.  Note that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.  It is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyItemStatBlockDefinition {
  public static final String SERIALIZED_NAME_DISABLE_PRIMARY_STAT_DISPLAY = "disablePrimaryStatDisplay";
  @SerializedName(SERIALIZED_NAME_DISABLE_PRIMARY_STAT_DISPLAY)
  private Boolean disablePrimaryStatDisplay;

  public static final String SERIALIZED_NAME_HAS_DISPLAYABLE_STATS = "hasDisplayableStats";
  @SerializedName(SERIALIZED_NAME_HAS_DISPLAYABLE_STATS)
  private Boolean hasDisplayableStats;

  public static final String SERIALIZED_NAME_PRIMARY_BASE_STAT_HASH = "primaryBaseStatHash";
  @SerializedName(SERIALIZED_NAME_PRIMARY_BASE_STAT_HASH)
  private Integer primaryBaseStatHash;

  public static final String SERIALIZED_NAME_STAT_GROUP_HASH = "statGroupHash";
  @SerializedName(SERIALIZED_NAME_STAT_GROUP_HASH)
  private Integer statGroupHash;

  public static final String SERIALIZED_NAME_STATS = "stats";
  @SerializedName(SERIALIZED_NAME_STATS)
  private Map<String, DestinyDefinitionsDestinyInventoryItemStatDefinition> stats = new HashMap<>();

  public DestinyDefinitionsDestinyItemStatBlockDefinition() {
  }

  public DestinyDefinitionsDestinyItemStatBlockDefinition disablePrimaryStatDisplay(Boolean disablePrimaryStatDisplay) {
    this.disablePrimaryStatDisplay = disablePrimaryStatDisplay;
    return this;
  }

  /**
   * If true, the game won&#39;t show the \&quot;primary\&quot; stat on this item when you inspect it.  NOTE: This is being manually mapped, because I happen to want it in a block that isn&#39;t going to directly create this derivative block.
   * @return disablePrimaryStatDisplay
   */
  @javax.annotation.Nullable
  public Boolean getDisablePrimaryStatDisplay() {
    return disablePrimaryStatDisplay;
  }

  public void setDisablePrimaryStatDisplay(Boolean disablePrimaryStatDisplay) {
    this.disablePrimaryStatDisplay = disablePrimaryStatDisplay;
  }


  public DestinyDefinitionsDestinyItemStatBlockDefinition hasDisplayableStats(Boolean hasDisplayableStats) {
    this.hasDisplayableStats = hasDisplayableStats;
    return this;
  }

  /**
   * A quick and lazy way to determine whether any stat other than the \&quot;primary\&quot; stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they&#39;re not part of the \&quot;Stat Group\&quot; and thus we wouldn&#39;t display them in our UI. If this is False, then we&#39;re not going to display any of these stats other than the primary one.
   * @return hasDisplayableStats
   */
  @javax.annotation.Nullable
  public Boolean getHasDisplayableStats() {
    return hasDisplayableStats;
  }

  public void setHasDisplayableStats(Boolean hasDisplayableStats) {
    this.hasDisplayableStats = hasDisplayableStats;
  }


  public DestinyDefinitionsDestinyItemStatBlockDefinition primaryBaseStatHash(Integer primaryBaseStatHash) {
    this.primaryBaseStatHash = primaryBaseStatHash;
    return this;
  }

  /**
   * This stat is determined to be the \&quot;primary\&quot; stat, and can be looked up in the stats or any other stat collection related to the item.  Use this hash to look up the stat&#39;s value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.
   * @return primaryBaseStatHash
   */
  @javax.annotation.Nullable
  public Integer getPrimaryBaseStatHash() {
    return primaryBaseStatHash;
  }

  public void setPrimaryBaseStatHash(Integer primaryBaseStatHash) {
    this.primaryBaseStatHash = primaryBaseStatHash;
  }


  public DestinyDefinitionsDestinyItemStatBlockDefinition statGroupHash(Integer statGroupHash) {
    this.statGroupHash = statGroupHash;
    return this;
  }

  /**
   * If the item&#39;s stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.  If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don&#39;t have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.
   * @return statGroupHash
   */
  @javax.annotation.Nullable
  public Integer getStatGroupHash() {
    return statGroupHash;
  }

  public void setStatGroupHash(Integer statGroupHash) {
    this.statGroupHash = statGroupHash;
  }


  public DestinyDefinitionsDestinyItemStatBlockDefinition stats(Map<String, DestinyDefinitionsDestinyInventoryItemStatDefinition> stats) {
    this.stats = stats;
    return this;
  }

  public DestinyDefinitionsDestinyItemStatBlockDefinition putStatsItem(String key, DestinyDefinitionsDestinyInventoryItemStatDefinition statsItem) {
    if (this.stats == null) {
      this.stats = new HashMap<>();
    }
    this.stats.put(key, statsItem);
    return this;
  }

  /**
   * If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \&quot;Display\&quot; stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it&#39;s a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.  These stats are keyed by the DestinyStatDefinition&#39;s hash identifier for the stat that&#39;s found on the item.
   * @return stats
   */
  @javax.annotation.Nullable
  public Map<String, DestinyDefinitionsDestinyInventoryItemStatDefinition> getStats() {
    return stats;
  }

  public void setStats(Map<String, DestinyDefinitionsDestinyInventoryItemStatDefinition> stats) {
    this.stats = stats;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyItemStatBlockDefinition destinyDefinitionsDestinyItemStatBlockDefinition = (DestinyDefinitionsDestinyItemStatBlockDefinition) o;
    return Objects.equals(this.disablePrimaryStatDisplay, destinyDefinitionsDestinyItemStatBlockDefinition.disablePrimaryStatDisplay) &&
        Objects.equals(this.hasDisplayableStats, destinyDefinitionsDestinyItemStatBlockDefinition.hasDisplayableStats) &&
        Objects.equals(this.primaryBaseStatHash, destinyDefinitionsDestinyItemStatBlockDefinition.primaryBaseStatHash) &&
        Objects.equals(this.statGroupHash, destinyDefinitionsDestinyItemStatBlockDefinition.statGroupHash) &&
        Objects.equals(this.stats, destinyDefinitionsDestinyItemStatBlockDefinition.stats);
  }

  @Override
  public int hashCode() {
    return Objects.hash(disablePrimaryStatDisplay, hasDisplayableStats, primaryBaseStatHash, statGroupHash, stats);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyItemStatBlockDefinition {\n");
    sb.append("    disablePrimaryStatDisplay: ").append(toIndentedString(disablePrimaryStatDisplay)).append("\n");
    sb.append("    hasDisplayableStats: ").append(toIndentedString(hasDisplayableStats)).append("\n");
    sb.append("    primaryBaseStatHash: ").append(toIndentedString(primaryBaseStatHash)).append("\n");
    sb.append("    statGroupHash: ").append(toIndentedString(statGroupHash)).append("\n");
    sb.append("    stats: ").append(toIndentedString(stats)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("disablePrimaryStatDisplay");
    openapiFields.add("hasDisplayableStats");
    openapiFields.add("primaryBaseStatHash");
    openapiFields.add("statGroupHash");
    openapiFields.add("stats");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyItemStatBlockDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyItemStatBlockDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyItemStatBlockDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyItemStatBlockDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyItemStatBlockDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyItemStatBlockDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyItemStatBlockDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyItemStatBlockDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyItemStatBlockDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyItemStatBlockDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyItemStatBlockDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyItemStatBlockDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyItemStatBlockDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyItemStatBlockDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyItemStatBlockDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyItemStatBlockDefinition
   */
  public static DestinyDefinitionsDestinyItemStatBlockDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyItemStatBlockDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyItemStatBlockDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

