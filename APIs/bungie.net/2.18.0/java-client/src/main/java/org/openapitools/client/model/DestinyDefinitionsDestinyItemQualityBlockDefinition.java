/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemVersionDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An item&#39;s \&quot;Quality\&quot; determines its calculated stats. The Level at which the item spawns is combined with its \&quot;qualityLevel\&quot; along with some additional calculations to determine the value of those stats.  In Destiny 2, most items don&#39;t have default item levels and quality, making this property less useful: these apparently are almost always determined by the complex mechanisms of the Reward system rather than statically. They are still provided here in case they are still useful for people. This also contains some information about Infusion.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyItemQualityBlockDefinition {
  public static final String SERIALIZED_NAME_CURRENT_VERSION = "currentVersion";
  @SerializedName(SERIALIZED_NAME_CURRENT_VERSION)
  private Integer currentVersion;

  public static final String SERIALIZED_NAME_DISPLAY_VERSION_WATERMARK_ICONS = "displayVersionWatermarkIcons";
  @SerializedName(SERIALIZED_NAME_DISPLAY_VERSION_WATERMARK_ICONS)
  private List<String> displayVersionWatermarkIcons = new ArrayList<>();

  public static final String SERIALIZED_NAME_INFUSION_CATEGORY_HASH = "infusionCategoryHash";
  @SerializedName(SERIALIZED_NAME_INFUSION_CATEGORY_HASH)
  private Integer infusionCategoryHash;

  public static final String SERIALIZED_NAME_INFUSION_CATEGORY_HASHES = "infusionCategoryHashes";
  @SerializedName(SERIALIZED_NAME_INFUSION_CATEGORY_HASHES)
  private List<Integer> infusionCategoryHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INFUSION_CATEGORY_NAME = "infusionCategoryName";
  @SerializedName(SERIALIZED_NAME_INFUSION_CATEGORY_NAME)
  private String infusionCategoryName;

  public static final String SERIALIZED_NAME_ITEM_LEVELS = "itemLevels";
  @SerializedName(SERIALIZED_NAME_ITEM_LEVELS)
  private List<Integer> itemLevels = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROGRESSION_LEVEL_REQUIREMENT_HASH = "progressionLevelRequirementHash";
  @SerializedName(SERIALIZED_NAME_PROGRESSION_LEVEL_REQUIREMENT_HASH)
  private Integer progressionLevelRequirementHash;

  public static final String SERIALIZED_NAME_QUALITY_LEVEL = "qualityLevel";
  @SerializedName(SERIALIZED_NAME_QUALITY_LEVEL)
  private Integer qualityLevel;

  public static final String SERIALIZED_NAME_VERSIONS = "versions";
  @SerializedName(SERIALIZED_NAME_VERSIONS)
  private List<DestinyDefinitionsDestinyItemVersionDefinition> versions = new ArrayList<>();

  public DestinyDefinitionsDestinyItemQualityBlockDefinition() {
  }

  public DestinyDefinitionsDestinyItemQualityBlockDefinition currentVersion(Integer currentVersion) {
    this.currentVersion = currentVersion;
    return this;
  }

  /**
   * The latest version available for this item.
   * @return currentVersion
   */
  @javax.annotation.Nullable
  public Integer getCurrentVersion() {
    return currentVersion;
  }

  public void setCurrentVersion(Integer currentVersion) {
    this.currentVersion = currentVersion;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition displayVersionWatermarkIcons(List<String> displayVersionWatermarkIcons) {
    this.displayVersionWatermarkIcons = displayVersionWatermarkIcons;
    return this;
  }

  public DestinyDefinitionsDestinyItemQualityBlockDefinition addDisplayVersionWatermarkIconsItem(String displayVersionWatermarkIconsItem) {
    if (this.displayVersionWatermarkIcons == null) {
      this.displayVersionWatermarkIcons = new ArrayList<>();
    }
    this.displayVersionWatermarkIcons.add(displayVersionWatermarkIconsItem);
    return this;
  }

  /**
   * Icon overlays to denote the item version and power cap status.
   * @return displayVersionWatermarkIcons
   */
  @javax.annotation.Nullable
  public List<String> getDisplayVersionWatermarkIcons() {
    return displayVersionWatermarkIcons;
  }

  public void setDisplayVersionWatermarkIcons(List<String> displayVersionWatermarkIcons) {
    this.displayVersionWatermarkIcons = displayVersionWatermarkIcons;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition infusionCategoryHash(Integer infusionCategoryHash) {
    this.infusionCategoryHash = infusionCategoryHash;
    return this;
  }

  /**
   * The hash identifier for the infusion. It does not map to a Definition entity.  DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.
   * @return infusionCategoryHash
   */
  @javax.annotation.Nullable
  public Integer getInfusionCategoryHash() {
    return infusionCategoryHash;
  }

  public void setInfusionCategoryHash(Integer infusionCategoryHash) {
    this.infusionCategoryHash = infusionCategoryHash;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition infusionCategoryHashes(List<Integer> infusionCategoryHashes) {
    this.infusionCategoryHashes = infusionCategoryHashes;
    return this;
  }

  public DestinyDefinitionsDestinyItemQualityBlockDefinition addInfusionCategoryHashesItem(Integer infusionCategoryHashesItem) {
    if (this.infusionCategoryHashes == null) {
      this.infusionCategoryHashes = new ArrayList<>();
    }
    this.infusionCategoryHashes.add(infusionCategoryHashesItem);
    return this;
  }

  /**
   * If any one of these hashes matches any value in another item&#39;s infusionCategoryHashes, the two can infuse with each other.
   * @return infusionCategoryHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getInfusionCategoryHashes() {
    return infusionCategoryHashes;
  }

  public void setInfusionCategoryHashes(List<Integer> infusionCategoryHashes) {
    this.infusionCategoryHashes = infusionCategoryHashes;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition infusionCategoryName(String infusionCategoryName) {
    this.infusionCategoryName = infusionCategoryName;
    return this;
  }

  /**
   * The string identifier for this item&#39;s \&quot;infusability\&quot;, if any.   Items that match the same infusionCategoryName are allowed to infuse with each other.  DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.
   * @return infusionCategoryName
   */
  @javax.annotation.Nullable
  public String getInfusionCategoryName() {
    return infusionCategoryName;
  }

  public void setInfusionCategoryName(String infusionCategoryName) {
    this.infusionCategoryName = infusionCategoryName;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition itemLevels(List<Integer> itemLevels) {
    this.itemLevels = itemLevels;
    return this;
  }

  public DestinyDefinitionsDestinyItemQualityBlockDefinition addItemLevelsItem(Integer itemLevelsItem) {
    if (this.itemLevels == null) {
      this.itemLevels = new ArrayList<>();
    }
    this.itemLevels.add(itemLevelsItem);
    return this;
  }

  /**
   * The \&quot;base\&quot; defined level of an item. This is a list because, in theory, each Expansion could define its own base level for an item.  In practice, not only was that never done in Destiny 1, but now this isn&#39;t even populated at all. When it&#39;s not populated, the level at which it spawns has to be inferred by Reward information, of which BNet receives an imperfect view and will only be reliable on instanced data as a result.
   * @return itemLevels
   */
  @javax.annotation.Nullable
  public List<Integer> getItemLevels() {
    return itemLevels;
  }

  public void setItemLevels(List<Integer> itemLevels) {
    this.itemLevels = itemLevels;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition progressionLevelRequirementHash(Integer progressionLevelRequirementHash) {
    this.progressionLevelRequirementHash = progressionLevelRequirementHash;
    return this;
  }

  /**
   * An item can refer to pre-set level requirements. They are defined in DestinyProgressionLevelRequirementDefinition, and you can use this hash to find the appropriate definition.
   * @return progressionLevelRequirementHash
   */
  @javax.annotation.Nullable
  public Integer getProgressionLevelRequirementHash() {
    return progressionLevelRequirementHash;
  }

  public void setProgressionLevelRequirementHash(Integer progressionLevelRequirementHash) {
    this.progressionLevelRequirementHash = progressionLevelRequirementHash;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition qualityLevel(Integer qualityLevel) {
    this.qualityLevel = qualityLevel;
    return this;
  }

  /**
   * qualityLevel is used in combination with the item&#39;s level to calculate stats like Attack and Defense. It plays a role in that calculation, but not nearly as large as itemLevel does.
   * @return qualityLevel
   */
  @javax.annotation.Nullable
  public Integer getQualityLevel() {
    return qualityLevel;
  }

  public void setQualityLevel(Integer qualityLevel) {
    this.qualityLevel = qualityLevel;
  }


  public DestinyDefinitionsDestinyItemQualityBlockDefinition versions(List<DestinyDefinitionsDestinyItemVersionDefinition> versions) {
    this.versions = versions;
    return this;
  }

  public DestinyDefinitionsDestinyItemQualityBlockDefinition addVersionsItem(DestinyDefinitionsDestinyItemVersionDefinition versionsItem) {
    if (this.versions == null) {
      this.versions = new ArrayList<>();
    }
    this.versions.add(versionsItem);
    return this;
  }

  /**
   * The list of versions available for this item.
   * @return versions
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemVersionDefinition> getVersions() {
    return versions;
  }

  public void setVersions(List<DestinyDefinitionsDestinyItemVersionDefinition> versions) {
    this.versions = versions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyItemQualityBlockDefinition destinyDefinitionsDestinyItemQualityBlockDefinition = (DestinyDefinitionsDestinyItemQualityBlockDefinition) o;
    return Objects.equals(this.currentVersion, destinyDefinitionsDestinyItemQualityBlockDefinition.currentVersion) &&
        Objects.equals(this.displayVersionWatermarkIcons, destinyDefinitionsDestinyItemQualityBlockDefinition.displayVersionWatermarkIcons) &&
        Objects.equals(this.infusionCategoryHash, destinyDefinitionsDestinyItemQualityBlockDefinition.infusionCategoryHash) &&
        Objects.equals(this.infusionCategoryHashes, destinyDefinitionsDestinyItemQualityBlockDefinition.infusionCategoryHashes) &&
        Objects.equals(this.infusionCategoryName, destinyDefinitionsDestinyItemQualityBlockDefinition.infusionCategoryName) &&
        Objects.equals(this.itemLevels, destinyDefinitionsDestinyItemQualityBlockDefinition.itemLevels) &&
        Objects.equals(this.progressionLevelRequirementHash, destinyDefinitionsDestinyItemQualityBlockDefinition.progressionLevelRequirementHash) &&
        Objects.equals(this.qualityLevel, destinyDefinitionsDestinyItemQualityBlockDefinition.qualityLevel) &&
        Objects.equals(this.versions, destinyDefinitionsDestinyItemQualityBlockDefinition.versions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currentVersion, displayVersionWatermarkIcons, infusionCategoryHash, infusionCategoryHashes, infusionCategoryName, itemLevels, progressionLevelRequirementHash, qualityLevel, versions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyItemQualityBlockDefinition {\n");
    sb.append("    currentVersion: ").append(toIndentedString(currentVersion)).append("\n");
    sb.append("    displayVersionWatermarkIcons: ").append(toIndentedString(displayVersionWatermarkIcons)).append("\n");
    sb.append("    infusionCategoryHash: ").append(toIndentedString(infusionCategoryHash)).append("\n");
    sb.append("    infusionCategoryHashes: ").append(toIndentedString(infusionCategoryHashes)).append("\n");
    sb.append("    infusionCategoryName: ").append(toIndentedString(infusionCategoryName)).append("\n");
    sb.append("    itemLevels: ").append(toIndentedString(itemLevels)).append("\n");
    sb.append("    progressionLevelRequirementHash: ").append(toIndentedString(progressionLevelRequirementHash)).append("\n");
    sb.append("    qualityLevel: ").append(toIndentedString(qualityLevel)).append("\n");
    sb.append("    versions: ").append(toIndentedString(versions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("currentVersion");
    openapiFields.add("displayVersionWatermarkIcons");
    openapiFields.add("infusionCategoryHash");
    openapiFields.add("infusionCategoryHashes");
    openapiFields.add("infusionCategoryName");
    openapiFields.add("itemLevels");
    openapiFields.add("progressionLevelRequirementHash");
    openapiFields.add("qualityLevel");
    openapiFields.add("versions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyItemQualityBlockDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyItemQualityBlockDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyItemQualityBlockDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyItemQualityBlockDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyItemQualityBlockDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyItemQualityBlockDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("displayVersionWatermarkIcons") != null && !jsonObj.get("displayVersionWatermarkIcons").isJsonNull() && !jsonObj.get("displayVersionWatermarkIcons").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayVersionWatermarkIcons` to be an array in the JSON string but got `%s`", jsonObj.get("displayVersionWatermarkIcons").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("infusionCategoryHashes") != null && !jsonObj.get("infusionCategoryHashes").isJsonNull() && !jsonObj.get("infusionCategoryHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `infusionCategoryHashes` to be an array in the JSON string but got `%s`", jsonObj.get("infusionCategoryHashes").toString()));
      }
      if ((jsonObj.get("infusionCategoryName") != null && !jsonObj.get("infusionCategoryName").isJsonNull()) && !jsonObj.get("infusionCategoryName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `infusionCategoryName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("infusionCategoryName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("itemLevels") != null && !jsonObj.get("itemLevels").isJsonNull() && !jsonObj.get("itemLevels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemLevels` to be an array in the JSON string but got `%s`", jsonObj.get("itemLevels").toString()));
      }
      if (jsonObj.get("versions") != null && !jsonObj.get("versions").isJsonNull()) {
        JsonArray jsonArrayversions = jsonObj.getAsJsonArray("versions");
        if (jsonArrayversions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("versions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `versions` to be an array in the JSON string but got `%s`", jsonObj.get("versions").toString()));
          }

          // validate the optional field `versions` (array)
          for (int i = 0; i < jsonArrayversions.size(); i++) {
            DestinyDefinitionsDestinyItemVersionDefinition.validateJsonElement(jsonArrayversions.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyItemQualityBlockDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyItemQualityBlockDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyItemQualityBlockDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyItemQualityBlockDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyItemQualityBlockDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyItemQualityBlockDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyItemQualityBlockDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyItemQualityBlockDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyItemQualityBlockDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyItemQualityBlockDefinition
   */
  public static DestinyDefinitionsDestinyItemQualityBlockDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyItemQualityBlockDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyItemQualityBlockDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

