/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DestinyChallengesDestinyChallengeStatus;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the \&quot;Live\&quot; data that we can obtain about a Character&#39;s status with a specific Activity. This will tell you whether the character can participate in the activity, as well as some other basic mutable information.   Meant to be combined with static DestinyActivityDefinition data for a full picture of the Activity.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDestinyActivity {
  public static final String SERIALIZED_NAME_ACTIVITY_HASH = "activityHash";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_HASH)
  private Integer activityHash;

  public static final String SERIALIZED_NAME_BOOLEAN_ACTIVITY_OPTIONS = "booleanActivityOptions";
  @SerializedName(SERIALIZED_NAME_BOOLEAN_ACTIVITY_OPTIONS)
  private Map<String, Boolean> booleanActivityOptions = new HashMap<>();

  public static final String SERIALIZED_NAME_CAN_JOIN = "canJoin";
  @SerializedName(SERIALIZED_NAME_CAN_JOIN)
  private Boolean canJoin;

  public static final String SERIALIZED_NAME_CAN_LEAD = "canLead";
  @SerializedName(SERIALIZED_NAME_CAN_LEAD)
  private Boolean canLead;

  public static final String SERIALIZED_NAME_CHALLENGES = "challenges";
  @SerializedName(SERIALIZED_NAME_CHALLENGES)
  private List<DestinyChallengesDestinyChallengeStatus> challenges = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIFFICULTY_TIER = "difficultyTier";
  @SerializedName(SERIALIZED_NAME_DIFFICULTY_TIER)
  private Integer difficultyTier;

  public static final String SERIALIZED_NAME_DISPLAY_LEVEL = "displayLevel";
  @SerializedName(SERIALIZED_NAME_DISPLAY_LEVEL)
  private Integer displayLevel;

  public static final String SERIALIZED_NAME_IS_COMPLETED = "isCompleted";
  @SerializedName(SERIALIZED_NAME_IS_COMPLETED)
  private Boolean isCompleted;

  public static final String SERIALIZED_NAME_IS_NEW = "isNew";
  @SerializedName(SERIALIZED_NAME_IS_NEW)
  private Boolean isNew;

  public static final String SERIALIZED_NAME_IS_VISIBLE = "isVisible";
  @SerializedName(SERIALIZED_NAME_IS_VISIBLE)
  private Boolean isVisible;

  public static final String SERIALIZED_NAME_LOADOUT_REQUIREMENT_INDEX = "loadoutRequirementIndex";
  @SerializedName(SERIALIZED_NAME_LOADOUT_REQUIREMENT_INDEX)
  private Integer loadoutRequirementIndex;

  public static final String SERIALIZED_NAME_MODIFIER_HASHES = "modifierHashes";
  @SerializedName(SERIALIZED_NAME_MODIFIER_HASHES)
  private List<Integer> modifierHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECOMMENDED_LIGHT = "recommendedLight";
  @SerializedName(SERIALIZED_NAME_RECOMMENDED_LIGHT)
  private Integer recommendedLight;

  public DestinyDestinyActivity() {
  }

  public DestinyDestinyActivity activityHash(Integer activityHash) {
    this.activityHash = activityHash;
    return this;
  }

  /**
   * The hash identifier of the Activity. Use this to look up the DestinyActivityDefinition of the activity.
   * @return activityHash
   */
  @javax.annotation.Nullable
  public Integer getActivityHash() {
    return activityHash;
  }

  public void setActivityHash(Integer activityHash) {
    this.activityHash = activityHash;
  }


  public DestinyDestinyActivity booleanActivityOptions(Map<String, Boolean> booleanActivityOptions) {
    this.booleanActivityOptions = booleanActivityOptions;
    return this;
  }

  public DestinyDestinyActivity putBooleanActivityOptionsItem(String key, Boolean booleanActivityOptionsItem) {
    if (this.booleanActivityOptions == null) {
      this.booleanActivityOptions = new HashMap<>();
    }
    this.booleanActivityOptions.put(key, booleanActivityOptionsItem);
    return this;
  }

  /**
   * The set of activity options for this activity, keyed by an identifier that&#39;s unique for this activity (not guaranteed to be unique between or across all activities, though should be unique for every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many variant DestinyActivityDefinitions. While other activities could potentially have the same option hashes, for any given D2 base Raid variant the hash will be unique).  As a concrete example of this data, the hashes you get for Raids will correspond to the currently active \&quot;Challenge Mode\&quot;.  We don&#39;t have any human readable information for these, but saavy 3rd party app users could manually associate the key (a hash identifier for the \&quot;option\&quot; that is enabled/disabled) and the value (whether it&#39;s enabled or disabled presently)  On our side, we don&#39;t necessarily even know what these are used for (the game designers know, but we don&#39;t), and we have no human readable data for them. In order to use them, you will have to do some experimentation.
   * @return booleanActivityOptions
   */
  @javax.annotation.Nullable
  public Map<String, Boolean> getBooleanActivityOptions() {
    return booleanActivityOptions;
  }

  public void setBooleanActivityOptions(Map<String, Boolean> booleanActivityOptions) {
    this.booleanActivityOptions = booleanActivityOptions;
  }


  public DestinyDestinyActivity canJoin(Boolean canJoin) {
    this.canJoin = canJoin;
    return this;
  }

  /**
   * If true, the user is allowed to join with another Fireteam in this activity.
   * @return canJoin
   */
  @javax.annotation.Nullable
  public Boolean getCanJoin() {
    return canJoin;
  }

  public void setCanJoin(Boolean canJoin) {
    this.canJoin = canJoin;
  }


  public DestinyDestinyActivity canLead(Boolean canLead) {
    this.canLead = canLead;
    return this;
  }

  /**
   * If true, the user is allowed to lead a Fireteam into this activity.
   * @return canLead
   */
  @javax.annotation.Nullable
  public Boolean getCanLead() {
    return canLead;
  }

  public void setCanLead(Boolean canLead) {
    this.canLead = canLead;
  }


  public DestinyDestinyActivity challenges(List<DestinyChallengesDestinyChallengeStatus> challenges) {
    this.challenges = challenges;
    return this;
  }

  public DestinyDestinyActivity addChallengesItem(DestinyChallengesDestinyChallengeStatus challengesItem) {
    if (this.challenges == null) {
      this.challenges = new ArrayList<>();
    }
    this.challenges.add(challengesItem);
    return this;
  }

  /**
   * Get challenges
   * @return challenges
   */
  @javax.annotation.Nullable
  public List<DestinyChallengesDestinyChallengeStatus> getChallenges() {
    return challenges;
  }

  public void setChallenges(List<DestinyChallengesDestinyChallengeStatus> challenges) {
    this.challenges = challenges;
  }


  public DestinyDestinyActivity difficultyTier(Integer difficultyTier) {
    this.difficultyTier = difficultyTier;
    return this;
  }

  /**
   * A DestinyActivityDifficultyTier enum value indicating the difficulty of the activity.
   * @return difficultyTier
   */
  @javax.annotation.Nullable
  public Integer getDifficultyTier() {
    return difficultyTier;
  }

  public void setDifficultyTier(Integer difficultyTier) {
    this.difficultyTier = difficultyTier;
  }


  public DestinyDestinyActivity displayLevel(Integer displayLevel) {
    this.displayLevel = displayLevel;
    return this;
  }

  /**
   * The difficulty level of the activity, if applicable.
   * @return displayLevel
   */
  @javax.annotation.Nullable
  public Integer getDisplayLevel() {
    return displayLevel;
  }

  public void setDisplayLevel(Integer displayLevel) {
    this.displayLevel = displayLevel;
  }


  public DestinyDestinyActivity isCompleted(Boolean isCompleted) {
    this.isCompleted = isCompleted;
    return this;
  }

  /**
   * If true, we both have the ability to know that the user has completed this activity and they have completed it. Unfortunately, we can&#39;t necessarily know this for all activities. As such, this should probably only be used if you already know in advance which specific activities you wish to check.
   * @return isCompleted
   */
  @javax.annotation.Nullable
  public Boolean getIsCompleted() {
    return isCompleted;
  }

  public void setIsCompleted(Boolean isCompleted) {
    this.isCompleted = isCompleted;
  }


  public DestinyDestinyActivity isNew(Boolean isNew) {
    this.isNew = isNew;
    return this;
  }

  /**
   * If true, then the activity should have a \&quot;new\&quot; indicator in the Director UI.
   * @return isNew
   */
  @javax.annotation.Nullable
  public Boolean getIsNew() {
    return isNew;
  }

  public void setIsNew(Boolean isNew) {
    this.isNew = isNew;
  }


  public DestinyDestinyActivity isVisible(Boolean isVisible) {
    this.isVisible = isVisible;
    return this;
  }

  /**
   * If true, the user should be able to see this activity.
   * @return isVisible
   */
  @javax.annotation.Nullable
  public Boolean getIsVisible() {
    return isVisible;
  }

  public void setIsVisible(Boolean isVisible) {
    this.isVisible = isVisible;
  }


  public DestinyDestinyActivity loadoutRequirementIndex(Integer loadoutRequirementIndex) {
    this.loadoutRequirementIndex = loadoutRequirementIndex;
    return this;
  }

  /**
   * If returned, this is the index into the DestinyActivityDefinition&#39;s \&quot;loadouts\&quot; property, indicating the currently active loadout requirements.
   * @return loadoutRequirementIndex
   */
  @javax.annotation.Nullable
  public Integer getLoadoutRequirementIndex() {
    return loadoutRequirementIndex;
  }

  public void setLoadoutRequirementIndex(Integer loadoutRequirementIndex) {
    this.loadoutRequirementIndex = loadoutRequirementIndex;
  }


  public DestinyDestinyActivity modifierHashes(List<Integer> modifierHashes) {
    this.modifierHashes = modifierHashes;
    return this;
  }

  public DestinyDestinyActivity addModifierHashesItem(Integer modifierHashesItem) {
    if (this.modifierHashes == null) {
      this.modifierHashes = new ArrayList<>();
    }
    this.modifierHashes.add(modifierHashesItem);
    return this;
  }

  /**
   * If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data.  Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what&#39;s really live.
   * @return modifierHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getModifierHashes() {
    return modifierHashes;
  }

  public void setModifierHashes(List<Integer> modifierHashes) {
    this.modifierHashes = modifierHashes;
  }


  public DestinyDestinyActivity recommendedLight(Integer recommendedLight) {
    this.recommendedLight = recommendedLight;
    return this;
  }

  /**
   * The recommended light level for the activity, if applicable.
   * @return recommendedLight
   */
  @javax.annotation.Nullable
  public Integer getRecommendedLight() {
    return recommendedLight;
  }

  public void setRecommendedLight(Integer recommendedLight) {
    this.recommendedLight = recommendedLight;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDestinyActivity destinyDestinyActivity = (DestinyDestinyActivity) o;
    return Objects.equals(this.activityHash, destinyDestinyActivity.activityHash) &&
        Objects.equals(this.booleanActivityOptions, destinyDestinyActivity.booleanActivityOptions) &&
        Objects.equals(this.canJoin, destinyDestinyActivity.canJoin) &&
        Objects.equals(this.canLead, destinyDestinyActivity.canLead) &&
        Objects.equals(this.challenges, destinyDestinyActivity.challenges) &&
        Objects.equals(this.difficultyTier, destinyDestinyActivity.difficultyTier) &&
        Objects.equals(this.displayLevel, destinyDestinyActivity.displayLevel) &&
        Objects.equals(this.isCompleted, destinyDestinyActivity.isCompleted) &&
        Objects.equals(this.isNew, destinyDestinyActivity.isNew) &&
        Objects.equals(this.isVisible, destinyDestinyActivity.isVisible) &&
        Objects.equals(this.loadoutRequirementIndex, destinyDestinyActivity.loadoutRequirementIndex) &&
        Objects.equals(this.modifierHashes, destinyDestinyActivity.modifierHashes) &&
        Objects.equals(this.recommendedLight, destinyDestinyActivity.recommendedLight);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activityHash, booleanActivityOptions, canJoin, canLead, challenges, difficultyTier, displayLevel, isCompleted, isNew, isVisible, loadoutRequirementIndex, modifierHashes, recommendedLight);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDestinyActivity {\n");
    sb.append("    activityHash: ").append(toIndentedString(activityHash)).append("\n");
    sb.append("    booleanActivityOptions: ").append(toIndentedString(booleanActivityOptions)).append("\n");
    sb.append("    canJoin: ").append(toIndentedString(canJoin)).append("\n");
    sb.append("    canLead: ").append(toIndentedString(canLead)).append("\n");
    sb.append("    challenges: ").append(toIndentedString(challenges)).append("\n");
    sb.append("    difficultyTier: ").append(toIndentedString(difficultyTier)).append("\n");
    sb.append("    displayLevel: ").append(toIndentedString(displayLevel)).append("\n");
    sb.append("    isCompleted: ").append(toIndentedString(isCompleted)).append("\n");
    sb.append("    isNew: ").append(toIndentedString(isNew)).append("\n");
    sb.append("    isVisible: ").append(toIndentedString(isVisible)).append("\n");
    sb.append("    loadoutRequirementIndex: ").append(toIndentedString(loadoutRequirementIndex)).append("\n");
    sb.append("    modifierHashes: ").append(toIndentedString(modifierHashes)).append("\n");
    sb.append("    recommendedLight: ").append(toIndentedString(recommendedLight)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activityHash");
    openapiFields.add("booleanActivityOptions");
    openapiFields.add("canJoin");
    openapiFields.add("canLead");
    openapiFields.add("challenges");
    openapiFields.add("difficultyTier");
    openapiFields.add("displayLevel");
    openapiFields.add("isCompleted");
    openapiFields.add("isNew");
    openapiFields.add("isVisible");
    openapiFields.add("loadoutRequirementIndex");
    openapiFields.add("modifierHashes");
    openapiFields.add("recommendedLight");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDestinyActivity
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDestinyActivity.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDestinyActivity is not found in the empty JSON string", DestinyDestinyActivity.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDestinyActivity.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDestinyActivity` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("challenges") != null && !jsonObj.get("challenges").isJsonNull()) {
        JsonArray jsonArraychallenges = jsonObj.getAsJsonArray("challenges");
        if (jsonArraychallenges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("challenges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `challenges` to be an array in the JSON string but got `%s`", jsonObj.get("challenges").toString()));
          }

          // validate the optional field `challenges` (array)
          for (int i = 0; i < jsonArraychallenges.size(); i++) {
            DestinyChallengesDestinyChallengeStatus.validateJsonElement(jsonArraychallenges.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("modifierHashes") != null && !jsonObj.get("modifierHashes").isJsonNull() && !jsonObj.get("modifierHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifierHashes` to be an array in the JSON string but got `%s`", jsonObj.get("modifierHashes").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDestinyActivity.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDestinyActivity' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDestinyActivity> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDestinyActivity.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDestinyActivity>() {
           @Override
           public void write(JsonWriter out, DestinyDestinyActivity value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDestinyActivity read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDestinyActivity given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDestinyActivity
   * @throws IOException if the JSON string is invalid with respect to DestinyDestinyActivity
   */
  public static DestinyDestinyActivity fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDestinyActivity.class);
  }

  /**
   * Convert an instance of DestinyDestinyActivity to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

