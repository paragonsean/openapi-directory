/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The definition information for a specific socket on an item. This will determine how the socket behaves in-game.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyItemSocketEntryDefinition {
  public static final String SERIALIZED_NAME_DEFAULT_VISIBLE = "defaultVisible";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VISIBLE)
  private Boolean defaultVisible;

  public static final String SERIALIZED_NAME_HIDE_PERKS_IN_ITEM_TOOLTIP = "hidePerksInItemTooltip";
  @SerializedName(SERIALIZED_NAME_HIDE_PERKS_IN_ITEM_TOOLTIP)
  private Boolean hidePerksInItemTooltip;

  public static final String SERIALIZED_NAME_PLUG_SOURCES = "plugSources";
  @SerializedName(SERIALIZED_NAME_PLUG_SOURCES)
  private Integer plugSources;

  public static final String SERIALIZED_NAME_PREVENT_INITIALIZATION_ON_VENDOR_PURCHASE = "preventInitializationOnVendorPurchase";
  @SerializedName(SERIALIZED_NAME_PREVENT_INITIALIZATION_ON_VENDOR_PURCHASE)
  private Boolean preventInitializationOnVendorPurchase;

  public static final String SERIALIZED_NAME_RANDOMIZED_PLUG_SET_HASH = "randomizedPlugSetHash";
  @SerializedName(SERIALIZED_NAME_RANDOMIZED_PLUG_SET_HASH)
  private Integer randomizedPlugSetHash;

  public static final String SERIALIZED_NAME_REUSABLE_PLUG_ITEMS = "reusablePlugItems";
  @SerializedName(SERIALIZED_NAME_REUSABLE_PLUG_ITEMS)
  private List<DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition> reusablePlugItems = new ArrayList<>();

  public static final String SERIALIZED_NAME_REUSABLE_PLUG_SET_HASH = "reusablePlugSetHash";
  @SerializedName(SERIALIZED_NAME_REUSABLE_PLUG_SET_HASH)
  private Integer reusablePlugSetHash;

  public static final String SERIALIZED_NAME_SINGLE_INITIAL_ITEM_HASH = "singleInitialItemHash";
  @SerializedName(SERIALIZED_NAME_SINGLE_INITIAL_ITEM_HASH)
  private Integer singleInitialItemHash;

  public static final String SERIALIZED_NAME_SOCKET_TYPE_HASH = "socketTypeHash";
  @SerializedName(SERIALIZED_NAME_SOCKET_TYPE_HASH)
  private Integer socketTypeHash;

  public DestinyDefinitionsDestinyItemSocketEntryDefinition() {
  }

  public DestinyDefinitionsDestinyItemSocketEntryDefinition defaultVisible(Boolean defaultVisible) {
    this.defaultVisible = defaultVisible;
    return this;
  }

  /**
   * If true, then this socket is visible in the item&#39;s \&quot;default\&quot; state. If you have an instance, you should always check the runtime state, as that can override this visibility setting: but if you&#39;re looking at the item on a conceptual level, this property can be useful for hiding data such as legacy sockets - which remain defined on items for infrastructure purposes, but can be confusing for users to see.
   * @return defaultVisible
   */
  @javax.annotation.Nullable
  public Boolean getDefaultVisible() {
    return defaultVisible;
  }

  public void setDefaultVisible(Boolean defaultVisible) {
    this.defaultVisible = defaultVisible;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition hidePerksInItemTooltip(Boolean hidePerksInItemTooltip) {
    this.hidePerksInItemTooltip = hidePerksInItemTooltip;
    return this;
  }

  /**
   * If this is true, the perks provided by this socket shouldn&#39;t be shown in the item&#39;s tooltip. This might be useful if it&#39;s providing a hidden bonus, or if the bonus is less important than other benefits on the item.
   * @return hidePerksInItemTooltip
   */
  @javax.annotation.Nullable
  public Boolean getHidePerksInItemTooltip() {
    return hidePerksInItemTooltip;
  }

  public void setHidePerksInItemTooltip(Boolean hidePerksInItemTooltip) {
    this.hidePerksInItemTooltip = hidePerksInItemTooltip;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition plugSources(Integer plugSources) {
    this.plugSources = plugSources;
    return this;
  }

  /**
   * Indicates where you should go to get plugs for this socket. This will affect how you populate your UI, as well as what plugs are valid for this socket. It&#39;s an alternative to having to check for the existence of certain properties (reusablePlugItems for example) to infer where plugs should come from.
   * @return plugSources
   */
  @javax.annotation.Nullable
  public Integer getPlugSources() {
    return plugSources;
  }

  public void setPlugSources(Integer plugSources) {
    this.plugSources = plugSources;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition preventInitializationOnVendorPurchase(Boolean preventInitializationOnVendorPurchase) {
    this.preventInitializationOnVendorPurchase = preventInitializationOnVendorPurchase;
    return this;
  }

  /**
   * If this is true, then the socket will not be initialized with a plug if the item is purchased from a Vendor.  Remember that Vendors are much more than conceptual vendors: they include \&quot;Collection Kiosks\&quot; and other entities. See DestinyVendorDefinition for more information.
   * @return preventInitializationOnVendorPurchase
   */
  @javax.annotation.Nullable
  public Boolean getPreventInitializationOnVendorPurchase() {
    return preventInitializationOnVendorPurchase;
  }

  public void setPreventInitializationOnVendorPurchase(Boolean preventInitializationOnVendorPurchase) {
    this.preventInitializationOnVendorPurchase = preventInitializationOnVendorPurchase;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition randomizedPlugSetHash(Integer randomizedPlugSetHash) {
    this.randomizedPlugSetHash = randomizedPlugSetHash;
    return this;
  }

  /**
   * This field replaces \&quot;randomizedPlugItems\&quot; as of Shadowkeep launch. If a socket has randomized plugs, this is a pointer to the set of plugs that could be used, as defined in DestinyPlugSetDefinition.   If null, the item has no randomized plugs.
   * @return randomizedPlugSetHash
   */
  @javax.annotation.Nullable
  public Integer getRandomizedPlugSetHash() {
    return randomizedPlugSetHash;
  }

  public void setRandomizedPlugSetHash(Integer randomizedPlugSetHash) {
    this.randomizedPlugSetHash = randomizedPlugSetHash;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition reusablePlugItems(List<DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition> reusablePlugItems) {
    this.reusablePlugItems = reusablePlugItems;
    return this;
  }

  public DestinyDefinitionsDestinyItemSocketEntryDefinition addReusablePlugItemsItem(DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition reusablePlugItemsItem) {
    if (this.reusablePlugItems == null) {
      this.reusablePlugItems = new ArrayList<>();
    }
    this.reusablePlugItems.add(reusablePlugItemsItem);
    return this;
  }

  /**
   * This is a list of pre-determined plugs that can *always* be plugged into this socket, without the character having the plug in their inventory.  If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.
   * @return reusablePlugItems
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition> getReusablePlugItems() {
    return reusablePlugItems;
  }

  public void setReusablePlugItems(List<DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition> reusablePlugItems) {
    this.reusablePlugItems = reusablePlugItems;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition reusablePlugSetHash(Integer reusablePlugSetHash) {
    this.reusablePlugSetHash = reusablePlugSetHash;
    return this;
  }

  /**
   * If this socket&#39;s plugs come from a reusable DestinyPlugSetDefinition, this is the identifier for that set. We added this concept to reduce some major duplication that&#39;s going to come from sockets as replacements for what was once implemented as large sets of items and kiosks (like Emotes).   As of Shadowkeep, these will come up much more frequently and be driven by game content rather than custom curation.
   * @return reusablePlugSetHash
   */
  @javax.annotation.Nullable
  public Integer getReusablePlugSetHash() {
    return reusablePlugSetHash;
  }

  public void setReusablePlugSetHash(Integer reusablePlugSetHash) {
    this.reusablePlugSetHash = reusablePlugSetHash;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition singleInitialItemHash(Integer singleInitialItemHash) {
    this.singleInitialItemHash = singleInitialItemHash;
    return this;
  }

  /**
   * If a valid hash, this is the hash identifier for the DestinyInventoryItemDefinition representing the Plug that will be initially inserted into the item on item creation. Otherwise, this Socket will either start without a plug inserted, or will have one randomly inserted.
   * @return singleInitialItemHash
   */
  @javax.annotation.Nullable
  public Integer getSingleInitialItemHash() {
    return singleInitialItemHash;
  }

  public void setSingleInitialItemHash(Integer singleInitialItemHash) {
    this.singleInitialItemHash = singleInitialItemHash;
  }


  public DestinyDefinitionsDestinyItemSocketEntryDefinition socketTypeHash(Integer socketTypeHash) {
    this.socketTypeHash = socketTypeHash;
    return this;
  }

  /**
   * All sockets have a type, and this is the hash identifier for this particular type. Use it to look up the DestinySocketTypeDefinition: read there for more information on how socket types affect the behavior of the socket.
   * @return socketTypeHash
   */
  @javax.annotation.Nullable
  public Integer getSocketTypeHash() {
    return socketTypeHash;
  }

  public void setSocketTypeHash(Integer socketTypeHash) {
    this.socketTypeHash = socketTypeHash;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyItemSocketEntryDefinition destinyDefinitionsDestinyItemSocketEntryDefinition = (DestinyDefinitionsDestinyItemSocketEntryDefinition) o;
    return Objects.equals(this.defaultVisible, destinyDefinitionsDestinyItemSocketEntryDefinition.defaultVisible) &&
        Objects.equals(this.hidePerksInItemTooltip, destinyDefinitionsDestinyItemSocketEntryDefinition.hidePerksInItemTooltip) &&
        Objects.equals(this.plugSources, destinyDefinitionsDestinyItemSocketEntryDefinition.plugSources) &&
        Objects.equals(this.preventInitializationOnVendorPurchase, destinyDefinitionsDestinyItemSocketEntryDefinition.preventInitializationOnVendorPurchase) &&
        Objects.equals(this.randomizedPlugSetHash, destinyDefinitionsDestinyItemSocketEntryDefinition.randomizedPlugSetHash) &&
        Objects.equals(this.reusablePlugItems, destinyDefinitionsDestinyItemSocketEntryDefinition.reusablePlugItems) &&
        Objects.equals(this.reusablePlugSetHash, destinyDefinitionsDestinyItemSocketEntryDefinition.reusablePlugSetHash) &&
        Objects.equals(this.singleInitialItemHash, destinyDefinitionsDestinyItemSocketEntryDefinition.singleInitialItemHash) &&
        Objects.equals(this.socketTypeHash, destinyDefinitionsDestinyItemSocketEntryDefinition.socketTypeHash);
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultVisible, hidePerksInItemTooltip, plugSources, preventInitializationOnVendorPurchase, randomizedPlugSetHash, reusablePlugItems, reusablePlugSetHash, singleInitialItemHash, socketTypeHash);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyItemSocketEntryDefinition {\n");
    sb.append("    defaultVisible: ").append(toIndentedString(defaultVisible)).append("\n");
    sb.append("    hidePerksInItemTooltip: ").append(toIndentedString(hidePerksInItemTooltip)).append("\n");
    sb.append("    plugSources: ").append(toIndentedString(plugSources)).append("\n");
    sb.append("    preventInitializationOnVendorPurchase: ").append(toIndentedString(preventInitializationOnVendorPurchase)).append("\n");
    sb.append("    randomizedPlugSetHash: ").append(toIndentedString(randomizedPlugSetHash)).append("\n");
    sb.append("    reusablePlugItems: ").append(toIndentedString(reusablePlugItems)).append("\n");
    sb.append("    reusablePlugSetHash: ").append(toIndentedString(reusablePlugSetHash)).append("\n");
    sb.append("    singleInitialItemHash: ").append(toIndentedString(singleInitialItemHash)).append("\n");
    sb.append("    socketTypeHash: ").append(toIndentedString(socketTypeHash)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("defaultVisible");
    openapiFields.add("hidePerksInItemTooltip");
    openapiFields.add("plugSources");
    openapiFields.add("preventInitializationOnVendorPurchase");
    openapiFields.add("randomizedPlugSetHash");
    openapiFields.add("reusablePlugItems");
    openapiFields.add("reusablePlugSetHash");
    openapiFields.add("singleInitialItemHash");
    openapiFields.add("socketTypeHash");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyItemSocketEntryDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyItemSocketEntryDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyItemSocketEntryDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyItemSocketEntryDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyItemSocketEntryDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyItemSocketEntryDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("reusablePlugItems") != null && !jsonObj.get("reusablePlugItems").isJsonNull()) {
        JsonArray jsonArrayreusablePlugItems = jsonObj.getAsJsonArray("reusablePlugItems");
        if (jsonArrayreusablePlugItems != null) {
          // ensure the json data is an array
          if (!jsonObj.get("reusablePlugItems").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `reusablePlugItems` to be an array in the JSON string but got `%s`", jsonObj.get("reusablePlugItems").toString()));
          }

          // validate the optional field `reusablePlugItems` (array)
          for (int i = 0; i < jsonArrayreusablePlugItems.size(); i++) {
            DestinyDefinitionsDestinyItemSocketEntryPlugItemDefinition.validateJsonElement(jsonArrayreusablePlugItems.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyItemSocketEntryDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyItemSocketEntryDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyItemSocketEntryDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyItemSocketEntryDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyItemSocketEntryDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyItemSocketEntryDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyItemSocketEntryDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyItemSocketEntryDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyItemSocketEntryDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyItemSocketEntryDefinition
   */
  public static DestinyDefinitionsDestinyItemSocketEntryDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyItemSocketEntryDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyItemSocketEntryDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

