/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DestinyDefinitionsDestinyTalentExclusiveGroup;
import org.openapitools.client.model.DestinyDefinitionsDestinyTalentNodeCategory;
import org.openapitools.client.model.DestinyDefinitionsDestinyTalentNodeDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The time has unfortunately come to talk about Talent Grids.  Talent Grids are the most complex and unintuitive part of the Destiny Definition data. Grab a cup of coffee before we begin, I can wait.  Talent Grids were the primary way that items could be customized in Destiny 1. In Destiny 2, for now, talent grids have become exclusively used by Subclass/Build items: but the system is still in place for it to be used by items should the direction change back toward talent grids.  Talent Grids have Nodes: the visual circles on the talent grid detail screen that have icons and can be activated if you meet certain requirements and pay costs. The actual visual data and effects, however, are driven by the \&quot;Steps\&quot; on Talent Nodes. Any given node will have 1:M of these steps, and the specific step that will be considered the \&quot;current\&quot; step (and thus the dictator of all benefits, visual state, and activation requirements on the Node) will almost always not be determined until an instance of the item is created. This is how, in Destiny 1, items were able to have such a wide variety of what users saw as \&quot;Perks\&quot;: they were actually Talent Grids with nodes that had a wide variety of Steps, randomly chosen at the time of item creation.  Now that Talent Grids are used exclusively by subclasses and builds, all of the properties within still apply: but there are additional visual elements on the Subclass/Build screens that are superimposed on top of the talent nodes. Unfortunately, BNet doesn&#39;t have this data: if you want to build a subclass screen, you will have to provide your own \&quot;decorative\&quot; assets, such as the visual connectors between nodes and the fancy colored-fire-bathed character standing behind the nodes.  DestinyInventoryItem.talentGrid.talentGridHash defines an item&#39;s linked Talent Grid, which brings you to this definition that contains enough satic data about talent grids to make your head spin. These *must* be combined with instanced data - found when live data returns DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes and steps within these definitions, which you will then have to look up in the definition and combine with the instanced data to give the user the visual representation of their item&#39;s talent grid.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyTalentGridDefinition {
  public static final String SERIALIZED_NAME_EXCLUSIVE_SETS = "exclusiveSets";
  @SerializedName(SERIALIZED_NAME_EXCLUSIVE_SETS)
  private List<DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition> exclusiveSets = new ArrayList<>();

  public static final String SERIALIZED_NAME_GRID_LEVEL_PER_COLUMN = "gridLevelPerColumn";
  @SerializedName(SERIALIZED_NAME_GRID_LEVEL_PER_COLUMN)
  private Integer gridLevelPerColumn;

  public static final String SERIALIZED_NAME_GROUPS = "groups";
  @SerializedName(SERIALIZED_NAME_GROUPS)
  private Map<String, DestinyDefinitionsDestinyTalentExclusiveGroup> groups = new HashMap<>();

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_INDEPENDENT_NODE_INDEXES = "independentNodeIndexes";
  @SerializedName(SERIALIZED_NAME_INDEPENDENT_NODE_INDEXES)
  private List<Integer> independentNodeIndexes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_MAX_GRID_LEVEL = "maxGridLevel";
  @SerializedName(SERIALIZED_NAME_MAX_GRID_LEVEL)
  private Integer maxGridLevel;

  public static final String SERIALIZED_NAME_NODE_CATEGORIES = "nodeCategories";
  @SerializedName(SERIALIZED_NAME_NODE_CATEGORIES)
  private List<DestinyDefinitionsDestinyTalentNodeCategory> nodeCategories = new ArrayList<>();

  public static final String SERIALIZED_NAME_NODES = "nodes";
  @SerializedName(SERIALIZED_NAME_NODES)
  private List<DestinyDefinitionsDestinyTalentNodeDefinition> nodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROGRESSION_HASH = "progressionHash";
  @SerializedName(SERIALIZED_NAME_PROGRESSION_HASH)
  private Integer progressionHash;

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public DestinyDefinitionsDestinyTalentGridDefinition() {
  }

  public DestinyDefinitionsDestinyTalentGridDefinition exclusiveSets(List<DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition> exclusiveSets) {
    this.exclusiveSets = exclusiveSets;
    return this;
  }

  public DestinyDefinitionsDestinyTalentGridDefinition addExclusiveSetsItem(DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition exclusiveSetsItem) {
    if (this.exclusiveSets == null) {
      this.exclusiveSets = new ArrayList<>();
    }
    this.exclusiveSets.add(exclusiveSetsItem);
    return this;
  }

  /**
   * Talent Nodes can exist in \&quot;exclusive sets\&quot;: these are sets of nodes in which only a single node in the set can be activated at any given time. Activating a node in this set will automatically deactivate the other nodes in the set (referred to as a \&quot;Swap\&quot;).  If a node in the exclusive set has already been activated, the game will not charge you materials to activate another node in the set, even if you have never activated it before, because you already paid the cost to activate one node in the set.  Not to be confused with Exclusive Groups. (how the heck do we NOT get confused by that? Jeez) See the groups property for information about that only-tangentially-related concept.
   * @return exclusiveSets
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition> getExclusiveSets() {
    return exclusiveSets;
  }

  public void setExclusiveSets(List<DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition> exclusiveSets) {
    this.exclusiveSets = exclusiveSets;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition gridLevelPerColumn(Integer gridLevelPerColumn) {
    this.gridLevelPerColumn = gridLevelPerColumn;
    return this;
  }

  /**
   * The meaning of this has been lost in the sands of time: it still exists as a property, but appears to be unused in the modern UI of talent grids. It used to imply that each visual \&quot;column\&quot; of talent nodes required identical progression levels in order to be activated. Returning this value in case it is still useful to someone? Perhaps it&#39;s just a bit of interesting history.
   * @return gridLevelPerColumn
   */
  @javax.annotation.Nullable
  public Integer getGridLevelPerColumn() {
    return gridLevelPerColumn;
  }

  public void setGridLevelPerColumn(Integer gridLevelPerColumn) {
    this.gridLevelPerColumn = gridLevelPerColumn;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition groups(Map<String, DestinyDefinitionsDestinyTalentExclusiveGroup> groups) {
    this.groups = groups;
    return this;
  }

  public DestinyDefinitionsDestinyTalentGridDefinition putGroupsItem(String key, DestinyDefinitionsDestinyTalentExclusiveGroup groupsItem) {
    if (this.groups == null) {
      this.groups = new HashMap<>();
    }
    this.groups.put(key, groupsItem);
    return this;
  }

  /**
   * Talent Nodes can have \&quot;Exclusive Groups\&quot;. These are not to be confused with Exclusive Sets (see exclusiveSets property).  Look at the definition of DestinyTalentExclusiveGroup for more information and how they work. These groups are keyed by the \&quot;groupHash\&quot; from DestinyTalentExclusiveGroup.
   * @return groups
   */
  @javax.annotation.Nullable
  public Map<String, DestinyDefinitionsDestinyTalentExclusiveGroup> getGroups() {
    return groups;
  }

  public void setGroups(Map<String, DestinyDefinitionsDestinyTalentExclusiveGroup> groups) {
    this.groups = groups;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition independentNodeIndexes(List<Integer> independentNodeIndexes) {
    this.independentNodeIndexes = independentNodeIndexes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentGridDefinition addIndependentNodeIndexesItem(Integer independentNodeIndexesItem) {
    if (this.independentNodeIndexes == null) {
      this.independentNodeIndexes = new ArrayList<>();
    }
    this.independentNodeIndexes.add(independentNodeIndexesItem);
    return this;
  }

  /**
   * This is a quick reference to the indexes of nodes that are not part of exclusive sets. Handy for knowing which talent nodes can only be activated directly, rather than via swapping.
   * @return independentNodeIndexes
   */
  @javax.annotation.Nullable
  public List<Integer> getIndependentNodeIndexes() {
    return independentNodeIndexes;
  }

  public void setIndependentNodeIndexes(List<Integer> independentNodeIndexes) {
    this.independentNodeIndexes = independentNodeIndexes;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition maxGridLevel(Integer maxGridLevel) {
    this.maxGridLevel = maxGridLevel;
    return this;
  }

  /**
   * The maximum possible level of the Talent Grid: at this level, any nodes are allowed to be activated.
   * @return maxGridLevel
   */
  @javax.annotation.Nullable
  public Integer getMaxGridLevel() {
    return maxGridLevel;
  }

  public void setMaxGridLevel(Integer maxGridLevel) {
    this.maxGridLevel = maxGridLevel;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition nodeCategories(List<DestinyDefinitionsDestinyTalentNodeCategory> nodeCategories) {
    this.nodeCategories = nodeCategories;
    return this;
  }

  public DestinyDefinitionsDestinyTalentGridDefinition addNodeCategoriesItem(DestinyDefinitionsDestinyTalentNodeCategory nodeCategoriesItem) {
    if (this.nodeCategories == null) {
      this.nodeCategories = new ArrayList<>();
    }
    this.nodeCategories.add(nodeCategoriesItem);
    return this;
  }

  /**
   * BNet wants to show talent nodes grouped by similar purpose with localized titles. This is the ordered list of those categories: if you want to show nodes by category, you can iterate over this list, render the displayProperties for the category as the title, and then iterate over the talent nodes referenced by the category to show the related nodes.  Note that this is different from Exclusive Groups or Sets, because these categories also incorporate \&quot;Independent\&quot; nodes that belong to neither sets nor groups. These are purely for visual grouping of nodes rather than functional grouping.
   * @return nodeCategories
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyTalentNodeCategory> getNodeCategories() {
    return nodeCategories;
  }

  public void setNodeCategories(List<DestinyDefinitionsDestinyTalentNodeCategory> nodeCategories) {
    this.nodeCategories = nodeCategories;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition nodes(List<DestinyDefinitionsDestinyTalentNodeDefinition> nodes) {
    this.nodes = nodes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentGridDefinition addNodesItem(DestinyDefinitionsDestinyTalentNodeDefinition nodesItem) {
    if (this.nodes == null) {
      this.nodes = new ArrayList<>();
    }
    this.nodes.add(nodesItem);
    return this;
  }

  /**
   * The list of Talent Nodes on the Grid (recall that Nodes themselves are really just locations in the UI to show whatever their current Step is. You will only know the current step for a node by retrieving instanced data through platform calls to the API that return DestinyItemTalentGridComponent).
   * @return nodes
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyTalentNodeDefinition> getNodes() {
    return nodes;
  }

  public void setNodes(List<DestinyDefinitionsDestinyTalentNodeDefinition> nodes) {
    this.nodes = nodes;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition progressionHash(Integer progressionHash) {
    this.progressionHash = progressionHash;
    return this;
  }

  /**
   * The hash identifier of the Progression (DestinyProgressionDefinition) that drives whether and when Talent Nodes can be activated on the Grid. Items will have instances of this Progression, and will gain experience that will eventually cause the grid to increase in level. As the grid&#39;s level increases, it will cross the threshold where nodes can be activated. See DestinyTalentGridStepDefinition&#39;s activation requirements for more information.
   * @return progressionHash
   */
  @javax.annotation.Nullable
  public Integer getProgressionHash() {
    return progressionHash;
  }

  public void setProgressionHash(Integer progressionHash) {
    this.progressionHash = progressionHash;
  }


  public DestinyDefinitionsDestinyTalentGridDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyTalentGridDefinition destinyDefinitionsDestinyTalentGridDefinition = (DestinyDefinitionsDestinyTalentGridDefinition) o;
    return Objects.equals(this.exclusiveSets, destinyDefinitionsDestinyTalentGridDefinition.exclusiveSets) &&
        Objects.equals(this.gridLevelPerColumn, destinyDefinitionsDestinyTalentGridDefinition.gridLevelPerColumn) &&
        Objects.equals(this.groups, destinyDefinitionsDestinyTalentGridDefinition.groups) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyTalentGridDefinition.hash) &&
        Objects.equals(this.independentNodeIndexes, destinyDefinitionsDestinyTalentGridDefinition.independentNodeIndexes) &&
        Objects.equals(this.index, destinyDefinitionsDestinyTalentGridDefinition.index) &&
        Objects.equals(this.maxGridLevel, destinyDefinitionsDestinyTalentGridDefinition.maxGridLevel) &&
        Objects.equals(this.nodeCategories, destinyDefinitionsDestinyTalentGridDefinition.nodeCategories) &&
        Objects.equals(this.nodes, destinyDefinitionsDestinyTalentGridDefinition.nodes) &&
        Objects.equals(this.progressionHash, destinyDefinitionsDestinyTalentGridDefinition.progressionHash) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyTalentGridDefinition.redacted);
  }

  @Override
  public int hashCode() {
    return Objects.hash(exclusiveSets, gridLevelPerColumn, groups, hash, independentNodeIndexes, index, maxGridLevel, nodeCategories, nodes, progressionHash, redacted);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyTalentGridDefinition {\n");
    sb.append("    exclusiveSets: ").append(toIndentedString(exclusiveSets)).append("\n");
    sb.append("    gridLevelPerColumn: ").append(toIndentedString(gridLevelPerColumn)).append("\n");
    sb.append("    groups: ").append(toIndentedString(groups)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    independentNodeIndexes: ").append(toIndentedString(independentNodeIndexes)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    maxGridLevel: ").append(toIndentedString(maxGridLevel)).append("\n");
    sb.append("    nodeCategories: ").append(toIndentedString(nodeCategories)).append("\n");
    sb.append("    nodes: ").append(toIndentedString(nodes)).append("\n");
    sb.append("    progressionHash: ").append(toIndentedString(progressionHash)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("exclusiveSets");
    openapiFields.add("gridLevelPerColumn");
    openapiFields.add("groups");
    openapiFields.add("hash");
    openapiFields.add("independentNodeIndexes");
    openapiFields.add("index");
    openapiFields.add("maxGridLevel");
    openapiFields.add("nodeCategories");
    openapiFields.add("nodes");
    openapiFields.add("progressionHash");
    openapiFields.add("redacted");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyTalentGridDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyTalentGridDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyTalentGridDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyTalentGridDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyTalentGridDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyTalentGridDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("exclusiveSets") != null && !jsonObj.get("exclusiveSets").isJsonNull()) {
        JsonArray jsonArrayexclusiveSets = jsonObj.getAsJsonArray("exclusiveSets");
        if (jsonArrayexclusiveSets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("exclusiveSets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `exclusiveSets` to be an array in the JSON string but got `%s`", jsonObj.get("exclusiveSets").toString()));
          }

          // validate the optional field `exclusiveSets` (array)
          for (int i = 0; i < jsonArrayexclusiveSets.size(); i++) {
            DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition.validateJsonElement(jsonArrayexclusiveSets.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("independentNodeIndexes") != null && !jsonObj.get("independentNodeIndexes").isJsonNull() && !jsonObj.get("independentNodeIndexes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `independentNodeIndexes` to be an array in the JSON string but got `%s`", jsonObj.get("independentNodeIndexes").toString()));
      }
      if (jsonObj.get("nodeCategories") != null && !jsonObj.get("nodeCategories").isJsonNull()) {
        JsonArray jsonArraynodeCategories = jsonObj.getAsJsonArray("nodeCategories");
        if (jsonArraynodeCategories != null) {
          // ensure the json data is an array
          if (!jsonObj.get("nodeCategories").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `nodeCategories` to be an array in the JSON string but got `%s`", jsonObj.get("nodeCategories").toString()));
          }

          // validate the optional field `nodeCategories` (array)
          for (int i = 0; i < jsonArraynodeCategories.size(); i++) {
            DestinyDefinitionsDestinyTalentNodeCategory.validateJsonElement(jsonArraynodeCategories.get(i));
          };
        }
      }
      if (jsonObj.get("nodes") != null && !jsonObj.get("nodes").isJsonNull()) {
        JsonArray jsonArraynodes = jsonObj.getAsJsonArray("nodes");
        if (jsonArraynodes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("nodes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `nodes` to be an array in the JSON string but got `%s`", jsonObj.get("nodes").toString()));
          }

          // validate the optional field `nodes` (array)
          for (int i = 0; i < jsonArraynodes.size(); i++) {
            DestinyDefinitionsDestinyTalentNodeDefinition.validateJsonElement(jsonArraynodes.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyTalentGridDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyTalentGridDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyTalentGridDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyTalentGridDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyTalentGridDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyTalentGridDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyTalentGridDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyTalentGridDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyTalentGridDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyTalentGridDefinition
   */
  public static DestinyDefinitionsDestinyTalentGridDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyTalentGridDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyTalentGridDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

