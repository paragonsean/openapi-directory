/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An Inventory (be it Character or Profile level) is comprised of many Buckets. An example of a bucket is \&quot;Primary Weapons\&quot;, where all of the primary weapons on a character are gathered together into a single visual element in the UI: a subset of the inventory that has a limited number of slots, and in this case also has an associated Equipment Slot for equipping an item in the bucket.  Item definitions declare what their \&quot;default\&quot; bucket is (DestinyInventoryItemDefinition.inventory.bucketTypeHash), and Item instances will tell you which bucket they are currently residing in (DestinyItemComponent.bucketHash). You can use this information along with the DestinyInventoryBucketDefinition to show these items grouped by bucket.  You cannot transfer an item to a bucket that is not its Default without going through a Vendor&#39;s \&quot;accepted items\&quot; (DestinyVendorDefinition.acceptedItems). This is how transfer functionality like the Vault is implemented, as a feature of a Vendor. See the vendor&#39;s acceptedItems property for more details.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyInventoryBucketDefinition {
  public static final String SERIALIZED_NAME_BUCKET_ORDER = "bucketOrder";
  @SerializedName(SERIALIZED_NAME_BUCKET_ORDER)
  private Integer bucketOrder;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private Integer category;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_FIFO = "fifo";
  @SerializedName(SERIALIZED_NAME_FIFO)
  private Boolean fifo;

  public static final String SERIALIZED_NAME_HAS_TRANSFER_DESTINATION = "hasTransferDestination";
  @SerializedName(SERIALIZED_NAME_HAS_TRANSFER_DESTINATION)
  private Boolean hasTransferDestination;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_ITEM_COUNT = "itemCount";
  @SerializedName(SERIALIZED_NAME_ITEM_COUNT)
  private Integer itemCount;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private Integer location;

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private Integer scope;

  public DestinyDefinitionsDestinyInventoryBucketDefinition() {
  }

  public DestinyDefinitionsDestinyInventoryBucketDefinition bucketOrder(Integer bucketOrder) {
    this.bucketOrder = bucketOrder;
    return this;
  }

  /**
   * Use this property to provide a quick-and-dirty recommended ordering for buckets in the UI. Most UIs will likely want to forsake this for something more custom and manual.
   * @return bucketOrder
   */
  @javax.annotation.Nullable
  public Integer getBucketOrder() {
    return bucketOrder;
  }

  public void setBucketOrder(Integer bucketOrder) {
    this.bucketOrder = bucketOrder;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition category(Integer category) {
    this.category = category;
    return this;
  }

  /**
   * An enum value for what items can be found in the bucket. See the BucketCategory enum for more details.
   * @return category
   */
  @javax.annotation.Nullable
  public Integer getCategory() {
    return category;
  }

  public void setCategory(Integer category) {
    this.category = category;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * Get displayProperties
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * If True, this bucket is enabled. Disabled buckets may include buckets that were included for test purposes, or that were going to be used but then were abandoned but never removed from content *cough*.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition fifo(Boolean fifo) {
    this.fifo = fifo;
    return this;
  }

  /**
   * if a FIFO bucket fills up, it will delete the oldest item from said bucket when a new item tries to be added to it. If this is FALSE, the bucket will not allow new items to be placed in it until room is made by the user manually deleting items from it. You can see an example of this with the Postmaster&#39;s bucket.
   * @return fifo
   */
  @javax.annotation.Nullable
  public Boolean getFifo() {
    return fifo;
  }

  public void setFifo(Boolean fifo) {
    this.fifo = fifo;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition hasTransferDestination(Boolean hasTransferDestination) {
    this.hasTransferDestination = hasTransferDestination;
    return this;
  }

  /**
   * If TRUE, there is at least one Vendor that can transfer items to/from this bucket. See the DestinyVendorDefinition&#39;s acceptedItems property for more information on how transferring works.
   * @return hasTransferDestination
   */
  @javax.annotation.Nullable
  public Boolean getHasTransferDestination() {
    return hasTransferDestination;
  }

  public void setHasTransferDestination(Boolean hasTransferDestination) {
    this.hasTransferDestination = hasTransferDestination;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition itemCount(Integer itemCount) {
    this.itemCount = itemCount;
    return this;
  }

  /**
   * The maximum # of item \&quot;slots\&quot; in a bucket. A slot is a given combination of item + quantity.  For instance, a Weapon will always take up a single slot, and always have a quantity of 1. But a material could take up only a single slot with hundreds of quantity.
   * @return itemCount
   */
  @javax.annotation.Nullable
  public Integer getItemCount() {
    return itemCount;
  }

  public void setItemCount(Integer itemCount) {
    this.itemCount = itemCount;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition location(Integer location) {
    this.location = location;
    return this;
  }

  /**
   * Sometimes, inventory buckets represent conceptual \&quot;locations\&quot; in the game that might not be expected. This value indicates the conceptual location of the bucket, regardless of where it is actually contained on the character/account.   See ItemLocation for details.   Note that location includes the Vault and the Postmaster (both of whom being just inventory buckets with additional actions that can be performed on them through a Vendor)
   * @return location
   */
  @javax.annotation.Nullable
  public Integer getLocation() {
    return location;
  }

  public void setLocation(Integer location) {
    this.location = location;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  public DestinyDefinitionsDestinyInventoryBucketDefinition scope(Integer scope) {
    this.scope = scope;
    return this;
  }

  /**
   * Where the bucket is found. 0 &#x3D; Character, 1 &#x3D; Account
   * @return scope
   */
  @javax.annotation.Nullable
  public Integer getScope() {
    return scope;
  }

  public void setScope(Integer scope) {
    this.scope = scope;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyInventoryBucketDefinition destinyDefinitionsDestinyInventoryBucketDefinition = (DestinyDefinitionsDestinyInventoryBucketDefinition) o;
    return Objects.equals(this.bucketOrder, destinyDefinitionsDestinyInventoryBucketDefinition.bucketOrder) &&
        Objects.equals(this.category, destinyDefinitionsDestinyInventoryBucketDefinition.category) &&
        Objects.equals(this.displayProperties, destinyDefinitionsDestinyInventoryBucketDefinition.displayProperties) &&
        Objects.equals(this.enabled, destinyDefinitionsDestinyInventoryBucketDefinition.enabled) &&
        Objects.equals(this.fifo, destinyDefinitionsDestinyInventoryBucketDefinition.fifo) &&
        Objects.equals(this.hasTransferDestination, destinyDefinitionsDestinyInventoryBucketDefinition.hasTransferDestination) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyInventoryBucketDefinition.hash) &&
        Objects.equals(this.index, destinyDefinitionsDestinyInventoryBucketDefinition.index) &&
        Objects.equals(this.itemCount, destinyDefinitionsDestinyInventoryBucketDefinition.itemCount) &&
        Objects.equals(this.location, destinyDefinitionsDestinyInventoryBucketDefinition.location) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyInventoryBucketDefinition.redacted) &&
        Objects.equals(this.scope, destinyDefinitionsDestinyInventoryBucketDefinition.scope);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucketOrder, category, displayProperties, enabled, fifo, hasTransferDestination, hash, index, itemCount, location, redacted, scope);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyInventoryBucketDefinition {\n");
    sb.append("    bucketOrder: ").append(toIndentedString(bucketOrder)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    fifo: ").append(toIndentedString(fifo)).append("\n");
    sb.append("    hasTransferDestination: ").append(toIndentedString(hasTransferDestination)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    itemCount: ").append(toIndentedString(itemCount)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bucketOrder");
    openapiFields.add("category");
    openapiFields.add("displayProperties");
    openapiFields.add("enabled");
    openapiFields.add("fifo");
    openapiFields.add("hasTransferDestination");
    openapiFields.add("hash");
    openapiFields.add("index");
    openapiFields.add("itemCount");
    openapiFields.add("location");
    openapiFields.add("redacted");
    openapiFields.add("scope");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyInventoryBucketDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyInventoryBucketDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyInventoryBucketDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyInventoryBucketDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyInventoryBucketDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyInventoryBucketDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyInventoryBucketDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyInventoryBucketDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyInventoryBucketDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyInventoryBucketDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyInventoryBucketDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyInventoryBucketDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyInventoryBucketDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyInventoryBucketDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyInventoryBucketDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyInventoryBucketDefinition
   */
  public static DestinyDefinitionsDestinyInventoryBucketDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyInventoryBucketDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyInventoryBucketDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

