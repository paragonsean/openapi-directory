/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition;
import org.openapitools.client.model.DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition;
import org.openapitools.client.model.DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * All Sockets have a \&quot;Type\&quot;: a set of common properties that determine when the socket allows Plugs to be inserted, what Categories of Plugs can be inserted, and whether the socket is even visible at all given the current game/character/account state.  See DestinyInventoryItemDefinition for more information about Socketed items and Plugs.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsSocketsDestinySocketTypeDefinition {
  public static final String SERIALIZED_NAME_ALWAYS_RANDOMIZE_SOCKETS = "alwaysRandomizeSockets";
  @SerializedName(SERIALIZED_NAME_ALWAYS_RANDOMIZE_SOCKETS)
  private Boolean alwaysRandomizeSockets;

  public static final String SERIALIZED_NAME_AVOID_DUPLICATES_ON_INITIALIZATION = "avoidDuplicatesOnInitialization";
  @SerializedName(SERIALIZED_NAME_AVOID_DUPLICATES_ON_INITIALIZATION)
  private Boolean avoidDuplicatesOnInitialization;

  public static final String SERIALIZED_NAME_CURRENCY_SCALARS = "currencyScalars";
  @SerializedName(SERIALIZED_NAME_CURRENCY_SCALARS)
  private List<DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry> currencyScalars = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_HIDE_DUPLICATE_REUSABLE_PLUGS = "hideDuplicateReusablePlugs";
  @SerializedName(SERIALIZED_NAME_HIDE_DUPLICATE_REUSABLE_PLUGS)
  private Boolean hideDuplicateReusablePlugs;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_INSERT_ACTION = "insertAction";
  @SerializedName(SERIALIZED_NAME_INSERT_ACTION)
  private DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition insertAction;

  public static final String SERIALIZED_NAME_IS_PREVIEW_ENABLED = "isPreviewEnabled";
  @SerializedName(SERIALIZED_NAME_IS_PREVIEW_ENABLED)
  private Boolean isPreviewEnabled;

  public static final String SERIALIZED_NAME_OVERRIDES_UI_APPEARANCE = "overridesUiAppearance";
  @SerializedName(SERIALIZED_NAME_OVERRIDES_UI_APPEARANCE)
  private Boolean overridesUiAppearance;

  public static final String SERIALIZED_NAME_PLUG_WHITELIST = "plugWhitelist";
  @SerializedName(SERIALIZED_NAME_PLUG_WHITELIST)
  private List<DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition> plugWhitelist = new ArrayList<>();

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public static final String SERIALIZED_NAME_SOCKET_CATEGORY_HASH = "socketCategoryHash";
  @SerializedName(SERIALIZED_NAME_SOCKET_CATEGORY_HASH)
  private Integer socketCategoryHash;

  public static final String SERIALIZED_NAME_VISIBILITY = "visibility";
  @SerializedName(SERIALIZED_NAME_VISIBILITY)
  private Integer visibility;

  public DestinyDefinitionsSocketsDestinySocketTypeDefinition() {
  }

  public DestinyDefinitionsSocketsDestinySocketTypeDefinition alwaysRandomizeSockets(Boolean alwaysRandomizeSockets) {
    this.alwaysRandomizeSockets = alwaysRandomizeSockets;
    return this;
  }

  /**
   * Get alwaysRandomizeSockets
   * @return alwaysRandomizeSockets
   */
  @javax.annotation.Nullable
  public Boolean getAlwaysRandomizeSockets() {
    return alwaysRandomizeSockets;
  }

  public void setAlwaysRandomizeSockets(Boolean alwaysRandomizeSockets) {
    this.alwaysRandomizeSockets = alwaysRandomizeSockets;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition avoidDuplicatesOnInitialization(Boolean avoidDuplicatesOnInitialization) {
    this.avoidDuplicatesOnInitialization = avoidDuplicatesOnInitialization;
    return this;
  }

  /**
   * Get avoidDuplicatesOnInitialization
   * @return avoidDuplicatesOnInitialization
   */
  @javax.annotation.Nullable
  public Boolean getAvoidDuplicatesOnInitialization() {
    return avoidDuplicatesOnInitialization;
  }

  public void setAvoidDuplicatesOnInitialization(Boolean avoidDuplicatesOnInitialization) {
    this.avoidDuplicatesOnInitialization = avoidDuplicatesOnInitialization;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition currencyScalars(List<DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry> currencyScalars) {
    this.currencyScalars = currencyScalars;
    return this;
  }

  public DestinyDefinitionsSocketsDestinySocketTypeDefinition addCurrencyScalarsItem(DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry currencyScalarsItem) {
    if (this.currencyScalars == null) {
      this.currencyScalars = new ArrayList<>();
    }
    this.currencyScalars.add(currencyScalarsItem);
    return this;
  }

  /**
   * Get currencyScalars
   * @return currencyScalars
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry> getCurrencyScalars() {
    return currencyScalars;
  }

  public void setCurrencyScalars(List<DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry> currencyScalars) {
    this.currencyScalars = currencyScalars;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * There are fields for this display data, but they appear to be unpopulated as of now. I am not sure where in the UI these would show if they even were populated, but I will continue to return this data in case it becomes useful.
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition hideDuplicateReusablePlugs(Boolean hideDuplicateReusablePlugs) {
    this.hideDuplicateReusablePlugs = hideDuplicateReusablePlugs;
    return this;
  }

  /**
   * Get hideDuplicateReusablePlugs
   * @return hideDuplicateReusablePlugs
   */
  @javax.annotation.Nullable
  public Boolean getHideDuplicateReusablePlugs() {
    return hideDuplicateReusablePlugs;
  }

  public void setHideDuplicateReusablePlugs(Boolean hideDuplicateReusablePlugs) {
    this.hideDuplicateReusablePlugs = hideDuplicateReusablePlugs;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition insertAction(DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition insertAction) {
    this.insertAction = insertAction;
    return this;
  }

  /**
   * Defines what happens when a plug is inserted into sockets of this type.
   * @return insertAction
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition getInsertAction() {
    return insertAction;
  }

  public void setInsertAction(DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition insertAction) {
    this.insertAction = insertAction;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition isPreviewEnabled(Boolean isPreviewEnabled) {
    this.isPreviewEnabled = isPreviewEnabled;
    return this;
  }

  /**
   * Get isPreviewEnabled
   * @return isPreviewEnabled
   */
  @javax.annotation.Nullable
  public Boolean getIsPreviewEnabled() {
    return isPreviewEnabled;
  }

  public void setIsPreviewEnabled(Boolean isPreviewEnabled) {
    this.isPreviewEnabled = isPreviewEnabled;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition overridesUiAppearance(Boolean overridesUiAppearance) {
    this.overridesUiAppearance = overridesUiAppearance;
    return this;
  }

  /**
   * This property indicates if the socket type determines whether Emblem icons and nameplates should be overridden by the inserted plug item&#39;s icon and nameplate.
   * @return overridesUiAppearance
   */
  @javax.annotation.Nullable
  public Boolean getOverridesUiAppearance() {
    return overridesUiAppearance;
  }

  public void setOverridesUiAppearance(Boolean overridesUiAppearance) {
    this.overridesUiAppearance = overridesUiAppearance;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition plugWhitelist(List<DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition> plugWhitelist) {
    this.plugWhitelist = plugWhitelist;
    return this;
  }

  public DestinyDefinitionsSocketsDestinySocketTypeDefinition addPlugWhitelistItem(DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition plugWhitelistItem) {
    if (this.plugWhitelist == null) {
      this.plugWhitelist = new ArrayList<>();
    }
    this.plugWhitelist.add(plugWhitelistItem);
    return this;
  }

  /**
   * A list of Plug \&quot;Categories\&quot; that are allowed to be plugged into sockets of this type.  These should be compared against a given plug item&#39;s DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item&#39;s category.  If the plug&#39;s category matches any whitelisted plug, or if the whitelist is empty, it is allowed to be inserted.
   * @return plugWhitelist
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition> getPlugWhitelist() {
    return plugWhitelist;
  }

  public void setPlugWhitelist(List<DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition> plugWhitelist) {
    this.plugWhitelist = plugWhitelist;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition socketCategoryHash(Integer socketCategoryHash) {
    this.socketCategoryHash = socketCategoryHash;
    return this;
  }

  /**
   * Get socketCategoryHash
   * @return socketCategoryHash
   */
  @javax.annotation.Nullable
  public Integer getSocketCategoryHash() {
    return socketCategoryHash;
  }

  public void setSocketCategoryHash(Integer socketCategoryHash) {
    this.socketCategoryHash = socketCategoryHash;
  }


  public DestinyDefinitionsSocketsDestinySocketTypeDefinition visibility(Integer visibility) {
    this.visibility = visibility;
    return this;
  }

  /**
   * Sometimes a socket isn&#39;t visible. These are some of the conditions under which sockets of this type are not visible. Unfortunately, the truth of visibility is much, much more complex. Best to rely on the live data for whether the socket is visible and enabled.
   * @return visibility
   */
  @javax.annotation.Nullable
  public Integer getVisibility() {
    return visibility;
  }

  public void setVisibility(Integer visibility) {
    this.visibility = visibility;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsSocketsDestinySocketTypeDefinition destinyDefinitionsSocketsDestinySocketTypeDefinition = (DestinyDefinitionsSocketsDestinySocketTypeDefinition) o;
    return Objects.equals(this.alwaysRandomizeSockets, destinyDefinitionsSocketsDestinySocketTypeDefinition.alwaysRandomizeSockets) &&
        Objects.equals(this.avoidDuplicatesOnInitialization, destinyDefinitionsSocketsDestinySocketTypeDefinition.avoidDuplicatesOnInitialization) &&
        Objects.equals(this.currencyScalars, destinyDefinitionsSocketsDestinySocketTypeDefinition.currencyScalars) &&
        Objects.equals(this.displayProperties, destinyDefinitionsSocketsDestinySocketTypeDefinition.displayProperties) &&
        Objects.equals(this.hash, destinyDefinitionsSocketsDestinySocketTypeDefinition.hash) &&
        Objects.equals(this.hideDuplicateReusablePlugs, destinyDefinitionsSocketsDestinySocketTypeDefinition.hideDuplicateReusablePlugs) &&
        Objects.equals(this.index, destinyDefinitionsSocketsDestinySocketTypeDefinition.index) &&
        Objects.equals(this.insertAction, destinyDefinitionsSocketsDestinySocketTypeDefinition.insertAction) &&
        Objects.equals(this.isPreviewEnabled, destinyDefinitionsSocketsDestinySocketTypeDefinition.isPreviewEnabled) &&
        Objects.equals(this.overridesUiAppearance, destinyDefinitionsSocketsDestinySocketTypeDefinition.overridesUiAppearance) &&
        Objects.equals(this.plugWhitelist, destinyDefinitionsSocketsDestinySocketTypeDefinition.plugWhitelist) &&
        Objects.equals(this.redacted, destinyDefinitionsSocketsDestinySocketTypeDefinition.redacted) &&
        Objects.equals(this.socketCategoryHash, destinyDefinitionsSocketsDestinySocketTypeDefinition.socketCategoryHash) &&
        Objects.equals(this.visibility, destinyDefinitionsSocketsDestinySocketTypeDefinition.visibility);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alwaysRandomizeSockets, avoidDuplicatesOnInitialization, currencyScalars, displayProperties, hash, hideDuplicateReusablePlugs, index, insertAction, isPreviewEnabled, overridesUiAppearance, plugWhitelist, redacted, socketCategoryHash, visibility);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsSocketsDestinySocketTypeDefinition {\n");
    sb.append("    alwaysRandomizeSockets: ").append(toIndentedString(alwaysRandomizeSockets)).append("\n");
    sb.append("    avoidDuplicatesOnInitialization: ").append(toIndentedString(avoidDuplicatesOnInitialization)).append("\n");
    sb.append("    currencyScalars: ").append(toIndentedString(currencyScalars)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    hideDuplicateReusablePlugs: ").append(toIndentedString(hideDuplicateReusablePlugs)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    insertAction: ").append(toIndentedString(insertAction)).append("\n");
    sb.append("    isPreviewEnabled: ").append(toIndentedString(isPreviewEnabled)).append("\n");
    sb.append("    overridesUiAppearance: ").append(toIndentedString(overridesUiAppearance)).append("\n");
    sb.append("    plugWhitelist: ").append(toIndentedString(plugWhitelist)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("    socketCategoryHash: ").append(toIndentedString(socketCategoryHash)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alwaysRandomizeSockets");
    openapiFields.add("avoidDuplicatesOnInitialization");
    openapiFields.add("currencyScalars");
    openapiFields.add("displayProperties");
    openapiFields.add("hash");
    openapiFields.add("hideDuplicateReusablePlugs");
    openapiFields.add("index");
    openapiFields.add("insertAction");
    openapiFields.add("isPreviewEnabled");
    openapiFields.add("overridesUiAppearance");
    openapiFields.add("plugWhitelist");
    openapiFields.add("redacted");
    openapiFields.add("socketCategoryHash");
    openapiFields.add("visibility");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsSocketsDestinySocketTypeDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsSocketsDestinySocketTypeDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsSocketsDestinySocketTypeDefinition is not found in the empty JSON string", DestinyDefinitionsSocketsDestinySocketTypeDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsSocketsDestinySocketTypeDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsSocketsDestinySocketTypeDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("currencyScalars") != null && !jsonObj.get("currencyScalars").isJsonNull()) {
        JsonArray jsonArraycurrencyScalars = jsonObj.getAsJsonArray("currencyScalars");
        if (jsonArraycurrencyScalars != null) {
          // ensure the json data is an array
          if (!jsonObj.get("currencyScalars").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `currencyScalars` to be an array in the JSON string but got `%s`", jsonObj.get("currencyScalars").toString()));
          }

          // validate the optional field `currencyScalars` (array)
          for (int i = 0; i < jsonArraycurrencyScalars.size(); i++) {
            DestinyDefinitionsSocketsDestinySocketTypeScalarMaterialRequirementEntry.validateJsonElement(jsonArraycurrencyScalars.get(i));
          };
        }
      }
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      // validate the optional field `insertAction`
      if (jsonObj.get("insertAction") != null && !jsonObj.get("insertAction").isJsonNull()) {
        DestinyDefinitionsSocketsDestinyInsertPlugActionDefinition.validateJsonElement(jsonObj.get("insertAction"));
      }
      if (jsonObj.get("plugWhitelist") != null && !jsonObj.get("plugWhitelist").isJsonNull()) {
        JsonArray jsonArrayplugWhitelist = jsonObj.getAsJsonArray("plugWhitelist");
        if (jsonArrayplugWhitelist != null) {
          // ensure the json data is an array
          if (!jsonObj.get("plugWhitelist").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `plugWhitelist` to be an array in the JSON string but got `%s`", jsonObj.get("plugWhitelist").toString()));
          }

          // validate the optional field `plugWhitelist` (array)
          for (int i = 0; i < jsonArrayplugWhitelist.size(); i++) {
            DestinyDefinitionsSocketsDestinyPlugWhitelistEntryDefinition.validateJsonElement(jsonArrayplugWhitelist.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsSocketsDestinySocketTypeDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsSocketsDestinySocketTypeDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsSocketsDestinySocketTypeDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsSocketsDestinySocketTypeDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsSocketsDestinySocketTypeDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsSocketsDestinySocketTypeDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsSocketsDestinySocketTypeDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsSocketsDestinySocketTypeDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsSocketsDestinySocketTypeDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsSocketsDestinySocketTypeDefinition
   */
  public static DestinyDefinitionsSocketsDestinySocketTypeDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsSocketsDestinySocketTypeDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsSocketsDestinySocketTypeDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

