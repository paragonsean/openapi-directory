/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyPositionDefinition;
import org.openapitools.client.model.DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition;
import org.openapitools.client.model.DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition;
import org.openapitools.client.model.DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This is the position and other data related to nodes in the activity graph that you can click to launch activities. An Activity Graph node will only have one active Activity at a time, which will determine the activity to be launched (and, unless overrideDisplay information is provided, will also determine the tooltip and other UI related to the node)
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition {
  public static final String SERIALIZED_NAME_ACTIVITIES = "activities";
  @SerializedName(SERIALIZED_NAME_ACTIVITIES)
  private List<DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition> activities = new ArrayList<>();

  public static final String SERIALIZED_NAME_FEATURING_STATES = "featuringStates";
  @SerializedName(SERIALIZED_NAME_FEATURING_STATES)
  private List<DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition> featuringStates = new ArrayList<>();

  public static final String SERIALIZED_NAME_NODE_ID = "nodeId";
  @SerializedName(SERIALIZED_NAME_NODE_ID)
  private Integer nodeId;

  public static final String SERIALIZED_NAME_OVERRIDE_DISPLAY = "overrideDisplay";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_DISPLAY)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition overrideDisplay;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  private DestinyDefinitionsCommonDestinyPositionDefinition position;

  public static final String SERIALIZED_NAME_STATES = "states";
  @SerializedName(SERIALIZED_NAME_STATES)
  private List<DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry> states = new ArrayList<>();

  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition() {
  }

  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition activities(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition> activities) {
    this.activities = activities;
    return this;
  }

  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition addActivitiesItem(DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition activitiesItem) {
    if (this.activities == null) {
      this.activities = new ArrayList<>();
    }
    this.activities.add(activitiesItem);
    return this;
  }

  /**
   * The node may have various possible activities that could be active for it, however only one may be active at a time. See the DestinyActivityGraphNodeActivityDefinition for details.
   * @return activities
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition> getActivities() {
    return activities;
  }

  public void setActivities(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition> activities) {
    this.activities = activities;
  }


  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition featuringStates(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition> featuringStates) {
    this.featuringStates = featuringStates;
    return this;
  }

  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition addFeaturingStatesItem(DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition featuringStatesItem) {
    if (this.featuringStates == null) {
      this.featuringStates = new ArrayList<>();
    }
    this.featuringStates.add(featuringStatesItem);
    return this;
  }

  /**
   * The node may have various visual accents placed on it, or styles applied. These are the list of possible styles that the Node can have. The game iterates through each, looking for the first one that passes a check of the required game/character/account state in order to show that style, and then renders the node in that style.
   * @return featuringStates
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition> getFeaturingStates() {
    return featuringStates;
  }

  public void setFeaturingStates(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition> featuringStates) {
    this.featuringStates = featuringStates;
  }


  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition nodeId(Integer nodeId) {
    this.nodeId = nodeId;
    return this;
  }

  /**
   * An identifier for the Activity Graph Node, only guaranteed to be unique within its parent Activity Graph.
   * @return nodeId
   */
  @javax.annotation.Nullable
  public Integer getNodeId() {
    return nodeId;
  }

  public void setNodeId(Integer nodeId) {
    this.nodeId = nodeId;
  }


  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition overrideDisplay(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition overrideDisplay) {
    this.overrideDisplay = overrideDisplay;
    return this;
  }

  /**
   * The node *may* have display properties that override the active Activity&#39;s display properties.
   * @return overrideDisplay
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getOverrideDisplay() {
    return overrideDisplay;
  }

  public void setOverrideDisplay(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition overrideDisplay) {
    this.overrideDisplay = overrideDisplay;
  }


  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition position(DestinyDefinitionsCommonDestinyPositionDefinition position) {
    this.position = position;
    return this;
  }

  /**
   * The position on the map for this node.
   * @return position
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyPositionDefinition getPosition() {
    return position;
  }

  public void setPosition(DestinyDefinitionsCommonDestinyPositionDefinition position) {
    this.position = position;
  }


  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition states(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry> states) {
    this.states = states;
    return this;
  }

  public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition addStatesItem(DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry statesItem) {
    if (this.states == null) {
      this.states = new ArrayList<>();
    }
    this.states.add(statesItem);
    return this;
  }

  /**
   * Represents possible states that the graph node can be in. These are combined with some checking that happens in the game client and server to determine which state is actually active at any given time.
   * @return states
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry> getStates() {
    return states;
  }

  public void setStates(List<DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry> states) {
    this.states = states;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition = (DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition) o;
    return Objects.equals(this.activities, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.activities) &&
        Objects.equals(this.featuringStates, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.featuringStates) &&
        Objects.equals(this.nodeId, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.nodeId) &&
        Objects.equals(this.overrideDisplay, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.overrideDisplay) &&
        Objects.equals(this.position, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.position) &&
        Objects.equals(this.states, destinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.states);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activities, featuringStates, nodeId, overrideDisplay, position, states);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition {\n");
    sb.append("    activities: ").append(toIndentedString(activities)).append("\n");
    sb.append("    featuringStates: ").append(toIndentedString(featuringStates)).append("\n");
    sb.append("    nodeId: ").append(toIndentedString(nodeId)).append("\n");
    sb.append("    overrideDisplay: ").append(toIndentedString(overrideDisplay)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    states: ").append(toIndentedString(states)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activities");
    openapiFields.add("featuringStates");
    openapiFields.add("nodeId");
    openapiFields.add("overrideDisplay");
    openapiFields.add("position");
    openapiFields.add("states");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition is not found in the empty JSON string", DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("activities") != null && !jsonObj.get("activities").isJsonNull()) {
        JsonArray jsonArrayactivities = jsonObj.getAsJsonArray("activities");
        if (jsonArrayactivities != null) {
          // ensure the json data is an array
          if (!jsonObj.get("activities").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `activities` to be an array in the JSON string but got `%s`", jsonObj.get("activities").toString()));
          }

          // validate the optional field `activities` (array)
          for (int i = 0; i < jsonArrayactivities.size(); i++) {
            DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition.validateJsonElement(jsonArrayactivities.get(i));
          };
        }
      }
      if (jsonObj.get("featuringStates") != null && !jsonObj.get("featuringStates").isJsonNull()) {
        JsonArray jsonArrayfeaturingStates = jsonObj.getAsJsonArray("featuringStates");
        if (jsonArrayfeaturingStates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("featuringStates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `featuringStates` to be an array in the JSON string but got `%s`", jsonObj.get("featuringStates").toString()));
          }

          // validate the optional field `featuringStates` (array)
          for (int i = 0; i < jsonArrayfeaturingStates.size(); i++) {
            DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition.validateJsonElement(jsonArrayfeaturingStates.get(i));
          };
        }
      }
      // validate the optional field `overrideDisplay`
      if (jsonObj.get("overrideDisplay") != null && !jsonObj.get("overrideDisplay").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("overrideDisplay"));
      }
      // validate the optional field `position`
      if (jsonObj.get("position") != null && !jsonObj.get("position").isJsonNull()) {
        DestinyDefinitionsCommonDestinyPositionDefinition.validateJsonElement(jsonObj.get("position"));
      }
      if (jsonObj.get("states") != null && !jsonObj.get("states").isJsonNull()) {
        JsonArray jsonArraystates = jsonObj.getAsJsonArray("states");
        if (jsonArraystates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("states").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `states` to be an array in the JSON string but got `%s`", jsonObj.get("states").toString()));
          }

          // validate the optional field `states` (array)
          for (int i = 0; i < jsonArraystates.size(); i++) {
            DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry.validateJsonElement(jsonArraystates.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition
   */
  public static DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

