/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DestinyMilestonesDestinyMilestoneChallengeActivity;
import org.openapitools.client.model.DestinyMilestonesDestinyMilestoneQuest;
import org.openapitools.client.model.DestinyMilestonesDestinyMilestoneRewardCategory;
import org.openapitools.client.model.DestinyMilestonesDestinyMilestoneVendor;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a runtime instance of a user&#39;s milestone status. Live Milestone data should be combined with DestinyMilestoneDefinition data to show the user a picture of what is available for them to do in the game, and their status in regards to said \&quot;things to do.\&quot; Consider it a big, wonky to-do list, or Advisors 3.0 for those who remember the Destiny 1 API.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyMilestonesDestinyMilestone {
  public static final String SERIALIZED_NAME_ACTIVITIES = "activities";
  @SerializedName(SERIALIZED_NAME_ACTIVITIES)
  private List<DestinyMilestonesDestinyMilestoneChallengeActivity> activities = new ArrayList<>();

  public static final String SERIALIZED_NAME_AVAILABLE_QUESTS = "availableQuests";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_QUESTS)
  private List<DestinyMilestonesDestinyMilestoneQuest> availableQuests = new ArrayList<>();

  public static final String SERIALIZED_NAME_END_DATE = "endDate";
  @SerializedName(SERIALIZED_NAME_END_DATE)
  private OffsetDateTime endDate;

  public static final String SERIALIZED_NAME_MILESTONE_HASH = "milestoneHash";
  @SerializedName(SERIALIZED_NAME_MILESTONE_HASH)
  private Integer milestoneHash;

  public static final String SERIALIZED_NAME_ORDER = "order";
  @SerializedName(SERIALIZED_NAME_ORDER)
  private Integer order;

  public static final String SERIALIZED_NAME_REWARDS = "rewards";
  @SerializedName(SERIALIZED_NAME_REWARDS)
  private List<DestinyMilestonesDestinyMilestoneRewardCategory> rewards = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_VALUES = "values";
  @SerializedName(SERIALIZED_NAME_VALUES)
  private Map<String, Float> values = new HashMap<>();

  public static final String SERIALIZED_NAME_VENDOR_HASHES = "vendorHashes";
  @SerializedName(SERIALIZED_NAME_VENDOR_HASHES)
  private List<Integer> vendorHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_VENDORS = "vendors";
  @SerializedName(SERIALIZED_NAME_VENDORS)
  private List<DestinyMilestonesDestinyMilestoneVendor> vendors = new ArrayList<>();

  public DestinyMilestonesDestinyMilestone() {
  }

  public DestinyMilestonesDestinyMilestone activities(List<DestinyMilestonesDestinyMilestoneChallengeActivity> activities) {
    this.activities = activities;
    return this;
  }

  public DestinyMilestonesDestinyMilestone addActivitiesItem(DestinyMilestonesDestinyMilestoneChallengeActivity activitiesItem) {
    if (this.activities == null) {
      this.activities = new ArrayList<>();
    }
    this.activities.add(activitiesItem);
    return this;
  }

  /**
   * The currently active Activities in this milestone, when the Milestone is driven by Challenges.  Not all Milestones have Challenges, but when they do this will indicate the Activities and Challenges under those Activities related to this Milestone.
   * @return activities
   */
  @javax.annotation.Nullable
  public List<DestinyMilestonesDestinyMilestoneChallengeActivity> getActivities() {
    return activities;
  }

  public void setActivities(List<DestinyMilestonesDestinyMilestoneChallengeActivity> activities) {
    this.activities = activities;
  }


  public DestinyMilestonesDestinyMilestone availableQuests(List<DestinyMilestonesDestinyMilestoneQuest> availableQuests) {
    this.availableQuests = availableQuests;
    return this;
  }

  public DestinyMilestonesDestinyMilestone addAvailableQuestsItem(DestinyMilestonesDestinyMilestoneQuest availableQuestsItem) {
    if (this.availableQuests == null) {
      this.availableQuests = new ArrayList<>();
    }
    this.availableQuests.add(availableQuestsItem);
    return this;
  }

  /**
   * Indicates what quests are available for this Milestone. Usually this will be only a single Quest, but some quests have multiple available that you can choose from at any given time. All possible quests for a milestone can be found in the DestinyMilestoneDefinition, but they must be combined with this Live data to determine which one(s) are actually active right now. It is possible for Milestones to not have any quests.
   * @return availableQuests
   */
  @javax.annotation.Nullable
  public List<DestinyMilestonesDestinyMilestoneQuest> getAvailableQuests() {
    return availableQuests;
  }

  public void setAvailableQuests(List<DestinyMilestonesDestinyMilestoneQuest> availableQuests) {
    this.availableQuests = availableQuests;
  }


  public DestinyMilestonesDestinyMilestone endDate(OffsetDateTime endDate) {
    this.endDate = endDate;
    return this;
  }

  /**
   * If known, this is the date when the event will next end or repeat. It will only be populated for events with fixed and repeating start and end dates.
   * @return endDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndDate() {
    return endDate;
  }

  public void setEndDate(OffsetDateTime endDate) {
    this.endDate = endDate;
  }


  public DestinyMilestonesDestinyMilestone milestoneHash(Integer milestoneHash) {
    this.milestoneHash = milestoneHash;
    return this;
  }

  /**
   * The unique identifier for the Milestone. Use it to look up the DestinyMilestoneDefinition, so you can combine the other data in this contract with static definition data.
   * @return milestoneHash
   */
  @javax.annotation.Nullable
  public Integer getMilestoneHash() {
    return milestoneHash;
  }

  public void setMilestoneHash(Integer milestoneHash) {
    this.milestoneHash = milestoneHash;
  }


  public DestinyMilestonesDestinyMilestone order(Integer order) {
    this.order = order;
    return this;
  }

  /**
   * Used for ordering milestones in a display to match how we order them in BNet. May pull from static data, or possibly in the future from dynamic information.
   * @return order
   */
  @javax.annotation.Nullable
  public Integer getOrder() {
    return order;
  }

  public void setOrder(Integer order) {
    this.order = order;
  }


  public DestinyMilestonesDestinyMilestone rewards(List<DestinyMilestonesDestinyMilestoneRewardCategory> rewards) {
    this.rewards = rewards;
    return this;
  }

  public DestinyMilestonesDestinyMilestone addRewardsItem(DestinyMilestonesDestinyMilestoneRewardCategory rewardsItem) {
    if (this.rewards == null) {
      this.rewards = new ArrayList<>();
    }
    this.rewards.add(rewardsItem);
    return this;
  }

  /**
   * If the entity to which this component is attached has known active Rewards for the player, this will detail information about those rewards, keyed by the RewardEntry Hash. (See DestinyMilestoneDefinition for more information about Reward Entries) Note that these rewards are not for the Quests related to the Milestone. Think of these as \&quot;overview/checklist\&quot; rewards that may be provided for Milestones that may provide rewards for performing a variety of tasks that aren&#39;t under a specific Quest.
   * @return rewards
   */
  @javax.annotation.Nullable
  public List<DestinyMilestonesDestinyMilestoneRewardCategory> getRewards() {
    return rewards;
  }

  public void setRewards(List<DestinyMilestonesDestinyMilestoneRewardCategory> rewards) {
    this.rewards = rewards;
  }


  public DestinyMilestonesDestinyMilestone startDate(OffsetDateTime startDate) {
    this.startDate = startDate;
    return this;
  }

  /**
   * If known, this is the date when the event last began or refreshed. It will only be populated for events with fixed and repeating start and end dates.
   * @return startDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartDate() {
    return startDate;
  }

  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public DestinyMilestonesDestinyMilestone values(Map<String, Float> values) {
    this.values = values;
    return this;
  }

  public DestinyMilestonesDestinyMilestone putValuesItem(String key, Float valuesItem) {
    if (this.values == null) {
      this.values = new HashMap<>();
    }
    this.values.put(key, valuesItem);
    return this;
  }

  /**
   * Milestones may have arbitrary key/value pairs associated with them, for data that users will want to know about but that doesn&#39;t fit neatly into any of the common components such as Quests. A good example of this would be - if this existed in Destiny 1 - the number of wins you currently have on your Trials of Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string identifier of this dictionary to look up more info about the value, including localized string content for displaying the value. The value in the dictionary is the floating point number. The definition will tell you how to format this number.
   * @return values
   */
  @javax.annotation.Nullable
  public Map<String, Float> getValues() {
    return values;
  }

  public void setValues(Map<String, Float> values) {
    this.values = values;
  }


  public DestinyMilestonesDestinyMilestone vendorHashes(List<Integer> vendorHashes) {
    this.vendorHashes = vendorHashes;
    return this;
  }

  public DestinyMilestonesDestinyMilestone addVendorHashesItem(Integer vendorHashesItem) {
    if (this.vendorHashes == null) {
      this.vendorHashes = new ArrayList<>();
    }
    this.vendorHashes.add(vendorHashesItem);
    return this;
  }

  /**
   * A milestone may have one or more active vendors that are \&quot;related\&quot; to it (that provide rewards, or that are the initiators of the Milestone). I already regret this, even as I&#39;m typing it. [I told you I&#39;d regret this] You see, sometimes a milestone may be directly correlated with a set of vendors that provide varying tiers of rewards. The player may not be able to interact with one or more of those vendors. This will return the hashes of the Vendors that the player *can* interact with, allowing you to show their current inventory as rewards or related items to the Milestone or its activities.  Before we even use it, it&#39;s already deprecated! How much of a bummer is that? We need more data.
   * @return vendorHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getVendorHashes() {
    return vendorHashes;
  }

  public void setVendorHashes(List<Integer> vendorHashes) {
    this.vendorHashes = vendorHashes;
  }


  public DestinyMilestonesDestinyMilestone vendors(List<DestinyMilestonesDestinyMilestoneVendor> vendors) {
    this.vendors = vendors;
    return this;
  }

  public DestinyMilestonesDestinyMilestone addVendorsItem(DestinyMilestonesDestinyMilestoneVendor vendorsItem) {
    if (this.vendors == null) {
      this.vendors = new ArrayList<>();
    }
    this.vendors.add(vendorsItem);
    return this;
  }

  /**
   * Replaces vendorHashes, which I knew was going to be trouble the day it walked in the door. This will return not only what Vendors are active and relevant to the activity (in an implied order that you can choose to ignore), but also other data - for example, if the Vendor is featuring a specific item relevant to this event that you should show with them.
   * @return vendors
   */
  @javax.annotation.Nullable
  public List<DestinyMilestonesDestinyMilestoneVendor> getVendors() {
    return vendors;
  }

  public void setVendors(List<DestinyMilestonesDestinyMilestoneVendor> vendors) {
    this.vendors = vendors;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyMilestonesDestinyMilestone destinyMilestonesDestinyMilestone = (DestinyMilestonesDestinyMilestone) o;
    return Objects.equals(this.activities, destinyMilestonesDestinyMilestone.activities) &&
        Objects.equals(this.availableQuests, destinyMilestonesDestinyMilestone.availableQuests) &&
        Objects.equals(this.endDate, destinyMilestonesDestinyMilestone.endDate) &&
        Objects.equals(this.milestoneHash, destinyMilestonesDestinyMilestone.milestoneHash) &&
        Objects.equals(this.order, destinyMilestonesDestinyMilestone.order) &&
        Objects.equals(this.rewards, destinyMilestonesDestinyMilestone.rewards) &&
        Objects.equals(this.startDate, destinyMilestonesDestinyMilestone.startDate) &&
        Objects.equals(this.values, destinyMilestonesDestinyMilestone.values) &&
        Objects.equals(this.vendorHashes, destinyMilestonesDestinyMilestone.vendorHashes) &&
        Objects.equals(this.vendors, destinyMilestonesDestinyMilestone.vendors);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activities, availableQuests, endDate, milestoneHash, order, rewards, startDate, values, vendorHashes, vendors);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyMilestonesDestinyMilestone {\n");
    sb.append("    activities: ").append(toIndentedString(activities)).append("\n");
    sb.append("    availableQuests: ").append(toIndentedString(availableQuests)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    milestoneHash: ").append(toIndentedString(milestoneHash)).append("\n");
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("    rewards: ").append(toIndentedString(rewards)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    values: ").append(toIndentedString(values)).append("\n");
    sb.append("    vendorHashes: ").append(toIndentedString(vendorHashes)).append("\n");
    sb.append("    vendors: ").append(toIndentedString(vendors)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activities");
    openapiFields.add("availableQuests");
    openapiFields.add("endDate");
    openapiFields.add("milestoneHash");
    openapiFields.add("order");
    openapiFields.add("rewards");
    openapiFields.add("startDate");
    openapiFields.add("values");
    openapiFields.add("vendorHashes");
    openapiFields.add("vendors");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyMilestonesDestinyMilestone
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyMilestonesDestinyMilestone.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyMilestonesDestinyMilestone is not found in the empty JSON string", DestinyMilestonesDestinyMilestone.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyMilestonesDestinyMilestone.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyMilestonesDestinyMilestone` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("activities") != null && !jsonObj.get("activities").isJsonNull()) {
        JsonArray jsonArrayactivities = jsonObj.getAsJsonArray("activities");
        if (jsonArrayactivities != null) {
          // ensure the json data is an array
          if (!jsonObj.get("activities").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `activities` to be an array in the JSON string but got `%s`", jsonObj.get("activities").toString()));
          }

          // validate the optional field `activities` (array)
          for (int i = 0; i < jsonArrayactivities.size(); i++) {
            DestinyMilestonesDestinyMilestoneChallengeActivity.validateJsonElement(jsonArrayactivities.get(i));
          };
        }
      }
      if (jsonObj.get("availableQuests") != null && !jsonObj.get("availableQuests").isJsonNull()) {
        JsonArray jsonArrayavailableQuests = jsonObj.getAsJsonArray("availableQuests");
        if (jsonArrayavailableQuests != null) {
          // ensure the json data is an array
          if (!jsonObj.get("availableQuests").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `availableQuests` to be an array in the JSON string but got `%s`", jsonObj.get("availableQuests").toString()));
          }

          // validate the optional field `availableQuests` (array)
          for (int i = 0; i < jsonArrayavailableQuests.size(); i++) {
            DestinyMilestonesDestinyMilestoneQuest.validateJsonElement(jsonArrayavailableQuests.get(i));
          };
        }
      }
      if (jsonObj.get("rewards") != null && !jsonObj.get("rewards").isJsonNull()) {
        JsonArray jsonArrayrewards = jsonObj.getAsJsonArray("rewards");
        if (jsonArrayrewards != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rewards").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rewards` to be an array in the JSON string but got `%s`", jsonObj.get("rewards").toString()));
          }

          // validate the optional field `rewards` (array)
          for (int i = 0; i < jsonArrayrewards.size(); i++) {
            DestinyMilestonesDestinyMilestoneRewardCategory.validateJsonElement(jsonArrayrewards.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("vendorHashes") != null && !jsonObj.get("vendorHashes").isJsonNull() && !jsonObj.get("vendorHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `vendorHashes` to be an array in the JSON string but got `%s`", jsonObj.get("vendorHashes").toString()));
      }
      if (jsonObj.get("vendors") != null && !jsonObj.get("vendors").isJsonNull()) {
        JsonArray jsonArrayvendors = jsonObj.getAsJsonArray("vendors");
        if (jsonArrayvendors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("vendors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `vendors` to be an array in the JSON string but got `%s`", jsonObj.get("vendors").toString()));
          }

          // validate the optional field `vendors` (array)
          for (int i = 0; i < jsonArrayvendors.size(); i++) {
            DestinyMilestonesDestinyMilestoneVendor.validateJsonElement(jsonArrayvendors.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyMilestonesDestinyMilestone.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyMilestonesDestinyMilestone' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyMilestonesDestinyMilestone> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyMilestonesDestinyMilestone.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyMilestonesDestinyMilestone>() {
           @Override
           public void write(JsonWriter out, DestinyMilestonesDestinyMilestone value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyMilestonesDestinyMilestone read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyMilestonesDestinyMilestone given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyMilestonesDestinyMilestone
   * @throws IOException if the JSON string is invalid with respect to DestinyMilestonesDestinyMilestone
   */
  public static DestinyMilestonesDestinyMilestone fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyMilestonesDestinyMilestone.class);
  }

  /**
   * Convert an instance of DestinyMilestonesDestinyMilestone to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

