/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyNodeActivationRequirement;
import org.openapitools.client.model.DestinyDefinitionsDestinyNodeSocketReplaceResponse;
import org.openapitools.client.model.DestinyDefinitionsDestinyTalentNodeStepGroups;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This defines the properties of a \&quot;Talent Node Step\&quot;. When you see a talent node in game, the actual visible properties that you see (its icon, description, the perks and stats it provides) are not provided by the Node itself, but rather by the currently active Step on the node.  When a Talent Node is activated, the currently active step&#39;s benefits are conferred upon the item and character.  The currently active step on talent nodes are determined when an item is first instantiated. Sometimes it is random, sometimes it is more deterministic (particularly when a node has only a single step).  Note that, when dealing with Talent Node Steps, you must ensure that you have the latest version of content. stepIndex and nodeStepHash - two ways of identifying the step within a node - are both content version dependent, and thus are subject to change between content updates.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyNodeStepDefinition {
  public static final String SERIALIZED_NAME_ACTIVATION_REQUIREMENT = "activationRequirement";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_REQUIREMENT)
  private DestinyDefinitionsDestinyNodeActivationRequirement activationRequirement;

  public static final String SERIALIZED_NAME_AFFECTS_LEVEL = "affectsLevel";
  @SerializedName(SERIALIZED_NAME_AFFECTS_LEVEL)
  private Boolean affectsLevel;

  public static final String SERIALIZED_NAME_AFFECTS_QUALITY = "affectsQuality";
  @SerializedName(SERIALIZED_NAME_AFFECTS_QUALITY)
  private Boolean affectsQuality;

  public static final String SERIALIZED_NAME_CAN_ACTIVATE_NEXT_STEP = "canActivateNextStep";
  @SerializedName(SERIALIZED_NAME_CAN_ACTIVATE_NEXT_STEP)
  private Boolean canActivateNextStep;

  public static final String SERIALIZED_NAME_DAMAGE_TYPE = "damageType";
  @SerializedName(SERIALIZED_NAME_DAMAGE_TYPE)
  private Integer damageType;

  public static final String SERIALIZED_NAME_DAMAGE_TYPE_HASH = "damageTypeHash";
  @SerializedName(SERIALIZED_NAME_DAMAGE_TYPE_HASH)
  private Integer damageTypeHash;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_INTERACTION_DESCRIPTION = "interactionDescription";
  @SerializedName(SERIALIZED_NAME_INTERACTION_DESCRIPTION)
  private String interactionDescription;

  public static final String SERIALIZED_NAME_IS_NEXT_STEP_RANDOM = "isNextStepRandom";
  @SerializedName(SERIALIZED_NAME_IS_NEXT_STEP_RANDOM)
  private Boolean isNextStepRandom;

  public static final String SERIALIZED_NAME_NEXT_STEP_INDEX = "nextStepIndex";
  @SerializedName(SERIALIZED_NAME_NEXT_STEP_INDEX)
  private Integer nextStepIndex;

  public static final String SERIALIZED_NAME_NODE_STEP_HASH = "nodeStepHash";
  @SerializedName(SERIALIZED_NAME_NODE_STEP_HASH)
  private Integer nodeStepHash;

  public static final String SERIALIZED_NAME_PERK_HASHES = "perkHashes";
  @SerializedName(SERIALIZED_NAME_PERK_HASHES)
  private List<Integer> perkHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SOCKET_REPLACEMENTS = "socketReplacements";
  @SerializedName(SERIALIZED_NAME_SOCKET_REPLACEMENTS)
  private List<DestinyDefinitionsDestinyNodeSocketReplaceResponse> socketReplacements = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_PROGRESSION_BAR_AT_PROGRESS = "startProgressionBarAtProgress";
  @SerializedName(SERIALIZED_NAME_START_PROGRESSION_BAR_AT_PROGRESS)
  private Integer startProgressionBarAtProgress;

  public static final String SERIALIZED_NAME_STAT_HASHES = "statHashes";
  @SerializedName(SERIALIZED_NAME_STAT_HASHES)
  private List<Integer> statHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_STEP_GROUPS = "stepGroups";
  @SerializedName(SERIALIZED_NAME_STEP_GROUPS)
  private DestinyDefinitionsDestinyTalentNodeStepGroups stepGroups;

  public static final String SERIALIZED_NAME_STEP_INDEX = "stepIndex";
  @SerializedName(SERIALIZED_NAME_STEP_INDEX)
  private Integer stepIndex;

  public DestinyDefinitionsDestinyNodeStepDefinition() {
  }

  public DestinyDefinitionsDestinyNodeStepDefinition activationRequirement(DestinyDefinitionsDestinyNodeActivationRequirement activationRequirement) {
    this.activationRequirement = activationRequirement;
    return this;
  }

  /**
   * If the step has requirements for activation (they almost always do, if nothing else than for the Talent Grid&#39;s Progression to have reached a certain level), they will be defined here.
   * @return activationRequirement
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyNodeActivationRequirement getActivationRequirement() {
    return activationRequirement;
  }

  public void setActivationRequirement(DestinyDefinitionsDestinyNodeActivationRequirement activationRequirement) {
    this.activationRequirement = activationRequirement;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition affectsLevel(Boolean affectsLevel) {
    this.affectsLevel = affectsLevel;
    return this;
  }

  /**
   * If true, this step can affect the level of the item. See DestinyInventoryItemDefintion for more information about item levels and their effect on stats.
   * @return affectsLevel
   */
  @javax.annotation.Nullable
  public Boolean getAffectsLevel() {
    return affectsLevel;
  }

  public void setAffectsLevel(Boolean affectsLevel) {
    this.affectsLevel = affectsLevel;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition affectsQuality(Boolean affectsQuality) {
    this.affectsQuality = affectsQuality;
    return this;
  }

  /**
   * If this is true, the step affects the item&#39;s Quality in some way. See DestinyInventoryItemDefinition for more information about the meaning of Quality. I already made a joke about Zen and the Art of Motorcycle Maintenance elsewhere in the documentation, so I will avoid doing it again. Oops too late
   * @return affectsQuality
   */
  @javax.annotation.Nullable
  public Boolean getAffectsQuality() {
    return affectsQuality;
  }

  public void setAffectsQuality(Boolean affectsQuality) {
    this.affectsQuality = affectsQuality;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition canActivateNextStep(Boolean canActivateNextStep) {
    this.canActivateNextStep = canActivateNextStep;
    return this;
  }

  /**
   * There was a time when talent nodes could be activated multiple times, and the effects of subsequent Steps would be compounded on each other, essentially \&quot;upgrading\&quot; the node. We have moved away from this, but theoretically the capability still exists.  I continue to return this in case it is used in the future: if true and this step is the current step in the node, you are allowed to activate the node a second time to receive the benefits of the next step in the node, which will then become the active step.
   * @return canActivateNextStep
   */
  @javax.annotation.Nullable
  public Boolean getCanActivateNextStep() {
    return canActivateNextStep;
  }

  public void setCanActivateNextStep(Boolean canActivateNextStep) {
    this.canActivateNextStep = canActivateNextStep;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition damageType(Integer damageType) {
    this.damageType = damageType;
    return this;
  }

  /**
   * An enum representing a damage type granted by activating this step, if any.
   * @return damageType
   */
  @javax.annotation.Nullable
  public Integer getDamageType() {
    return damageType;
  }

  public void setDamageType(Integer damageType) {
    this.damageType = damageType;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition damageTypeHash(Integer damageTypeHash) {
    this.damageTypeHash = damageTypeHash;
    return this;
  }

  /**
   * If the step provides a damage type, this will be the hash identifier used to look up the damage type&#39;s DestinyDamageTypeDefinition.
   * @return damageTypeHash
   */
  @javax.annotation.Nullable
  public Integer getDamageTypeHash() {
    return damageTypeHash;
  }

  public void setDamageTypeHash(Integer damageTypeHash) {
    this.damageTypeHash = damageTypeHash;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * These are the display properties actually used to render the Talent Node. The currently active step&#39;s displayProperties are shown.
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition interactionDescription(String interactionDescription) {
    this.interactionDescription = interactionDescription;
    return this;
  }

  /**
   * If you can interact with this node in some way, this is the localized description of that interaction.
   * @return interactionDescription
   */
  @javax.annotation.Nullable
  public String getInteractionDescription() {
    return interactionDescription;
  }

  public void setInteractionDescription(String interactionDescription) {
    this.interactionDescription = interactionDescription;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition isNextStepRandom(Boolean isNextStepRandom) {
    this.isNextStepRandom = isNextStepRandom;
    return this;
  }

  /**
   * If true, the next step to be chosen is random, and if you&#39;re allowed to activate the next step. (if canActivateNextStep &#x3D; true)
   * @return isNextStepRandom
   */
  @javax.annotation.Nullable
  public Boolean getIsNextStepRandom() {
    return isNextStepRandom;
  }

  public void setIsNextStepRandom(Boolean isNextStepRandom) {
    this.isNextStepRandom = isNextStepRandom;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition nextStepIndex(Integer nextStepIndex) {
    this.nextStepIndex = nextStepIndex;
    return this;
  }

  /**
   * The stepIndex of the next step in the talent node, or -1 if this is the last step or if the next step to be chosen is random.  This doesn&#39;t really matter anymore unless canActivateNextStep begins to be used again.
   * @return nextStepIndex
   */
  @javax.annotation.Nullable
  public Integer getNextStepIndex() {
    return nextStepIndex;
  }

  public void setNextStepIndex(Integer nextStepIndex) {
    this.nextStepIndex = nextStepIndex;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition nodeStepHash(Integer nodeStepHash) {
    this.nodeStepHash = nodeStepHash;
    return this;
  }

  /**
   * The hash of this node step. Unfortunately, while it can be used to uniquely identify the step within a node, it is also content version dependent and should not be relied on without ensuring you have the latest vesion of content.
   * @return nodeStepHash
   */
  @javax.annotation.Nullable
  public Integer getNodeStepHash() {
    return nodeStepHash;
  }

  public void setNodeStepHash(Integer nodeStepHash) {
    this.nodeStepHash = nodeStepHash;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition perkHashes(List<Integer> perkHashes) {
    this.perkHashes = perkHashes;
    return this;
  }

  public DestinyDefinitionsDestinyNodeStepDefinition addPerkHashesItem(Integer perkHashesItem) {
    if (this.perkHashes == null) {
      this.perkHashes = new ArrayList<>();
    }
    this.perkHashes.add(perkHashesItem);
    return this;
  }

  /**
   * The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are applied when this step is active. Perks provide a variety of benefits and modifications - examine DestinySandboxPerkDefinition to learn more.
   * @return perkHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getPerkHashes() {
    return perkHashes;
  }

  public void setPerkHashes(List<Integer> perkHashes) {
    this.perkHashes = perkHashes;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition socketReplacements(List<DestinyDefinitionsDestinyNodeSocketReplaceResponse> socketReplacements) {
    this.socketReplacements = socketReplacements;
    return this;
  }

  public DestinyDefinitionsDestinyNodeStepDefinition addSocketReplacementsItem(DestinyDefinitionsDestinyNodeSocketReplaceResponse socketReplacementsItem) {
    if (this.socketReplacements == null) {
      this.socketReplacements = new ArrayList<>();
    }
    this.socketReplacements.add(socketReplacementsItem);
    return this;
  }

  /**
   * If this step is activated, this will be a list of information used to replace socket items with new Plugs. See DestinyInventoryItemDefinition for more information about sockets and plugs.
   * @return socketReplacements
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyNodeSocketReplaceResponse> getSocketReplacements() {
    return socketReplacements;
  }

  public void setSocketReplacements(List<DestinyDefinitionsDestinyNodeSocketReplaceResponse> socketReplacements) {
    this.socketReplacements = socketReplacements;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition startProgressionBarAtProgress(Integer startProgressionBarAtProgress) {
    this.startProgressionBarAtProgress = startProgressionBarAtProgress;
    return this;
  }

  /**
   * When the Talent Grid&#39;s progression reaches this value, the circular \&quot;progress bar\&quot; that surrounds the talent node should be shown.  This also indicates the lower bound of said progress bar, with the upper bound being the progress required to reach activationRequirement.gridLevel. (at some point I should precalculate the upper bound and put it in the definition to save people time)
   * @return startProgressionBarAtProgress
   */
  @javax.annotation.Nullable
  public Integer getStartProgressionBarAtProgress() {
    return startProgressionBarAtProgress;
  }

  public void setStartProgressionBarAtProgress(Integer startProgressionBarAtProgress) {
    this.startProgressionBarAtProgress = startProgressionBarAtProgress;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition statHashes(List<Integer> statHashes) {
    this.statHashes = statHashes;
    return this;
  }

  public DestinyDefinitionsDestinyNodeStepDefinition addStatHashesItem(Integer statHashesItem) {
    if (this.statHashes == null) {
      this.statHashes = new ArrayList<>();
    }
    this.statHashes.add(statHashesItem);
    return this;
  }

  /**
   * When the step provides stat benefits on the item or character, this is the list of hash identifiers for stats (DestinyStatDefinition) that are provided.
   * @return statHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getStatHashes() {
    return statHashes;
  }

  public void setStatHashes(List<Integer> statHashes) {
    this.statHashes = statHashes;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition stepGroups(DestinyDefinitionsDestinyTalentNodeStepGroups stepGroups) {
    this.stepGroups = stepGroups;
    return this;
  }

  /**
   * In Destiny 1, the Armory&#39;s Perk Filtering was driven by a concept of TalentNodeStepGroups: categorizations of talent nodes based on their functionality. While the Armory isn&#39;t a BNet-facing thing for now, and the new Armory will need to account for Sockets rather than Talent Nodes, this categorization capability feels useful enough to still keep around.
   * @return stepGroups
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyTalentNodeStepGroups getStepGroups() {
    return stepGroups;
  }

  public void setStepGroups(DestinyDefinitionsDestinyTalentNodeStepGroups stepGroups) {
    this.stepGroups = stepGroups;
  }


  public DestinyDefinitionsDestinyNodeStepDefinition stepIndex(Integer stepIndex) {
    this.stepIndex = stepIndex;
    return this;
  }

  /**
   * The index of this step in the list of Steps on the Talent Node.  Unfortunately, this is the closest thing we have to an identifier for the Step: steps are not provided a content version agnostic identifier. This means that, when you are dealing with talent nodes, you will need to first ensure that you have the latest version of content.
   * @return stepIndex
   */
  @javax.annotation.Nullable
  public Integer getStepIndex() {
    return stepIndex;
  }

  public void setStepIndex(Integer stepIndex) {
    this.stepIndex = stepIndex;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyNodeStepDefinition destinyDefinitionsDestinyNodeStepDefinition = (DestinyDefinitionsDestinyNodeStepDefinition) o;
    return Objects.equals(this.activationRequirement, destinyDefinitionsDestinyNodeStepDefinition.activationRequirement) &&
        Objects.equals(this.affectsLevel, destinyDefinitionsDestinyNodeStepDefinition.affectsLevel) &&
        Objects.equals(this.affectsQuality, destinyDefinitionsDestinyNodeStepDefinition.affectsQuality) &&
        Objects.equals(this.canActivateNextStep, destinyDefinitionsDestinyNodeStepDefinition.canActivateNextStep) &&
        Objects.equals(this.damageType, destinyDefinitionsDestinyNodeStepDefinition.damageType) &&
        Objects.equals(this.damageTypeHash, destinyDefinitionsDestinyNodeStepDefinition.damageTypeHash) &&
        Objects.equals(this.displayProperties, destinyDefinitionsDestinyNodeStepDefinition.displayProperties) &&
        Objects.equals(this.interactionDescription, destinyDefinitionsDestinyNodeStepDefinition.interactionDescription) &&
        Objects.equals(this.isNextStepRandom, destinyDefinitionsDestinyNodeStepDefinition.isNextStepRandom) &&
        Objects.equals(this.nextStepIndex, destinyDefinitionsDestinyNodeStepDefinition.nextStepIndex) &&
        Objects.equals(this.nodeStepHash, destinyDefinitionsDestinyNodeStepDefinition.nodeStepHash) &&
        Objects.equals(this.perkHashes, destinyDefinitionsDestinyNodeStepDefinition.perkHashes) &&
        Objects.equals(this.socketReplacements, destinyDefinitionsDestinyNodeStepDefinition.socketReplacements) &&
        Objects.equals(this.startProgressionBarAtProgress, destinyDefinitionsDestinyNodeStepDefinition.startProgressionBarAtProgress) &&
        Objects.equals(this.statHashes, destinyDefinitionsDestinyNodeStepDefinition.statHashes) &&
        Objects.equals(this.stepGroups, destinyDefinitionsDestinyNodeStepDefinition.stepGroups) &&
        Objects.equals(this.stepIndex, destinyDefinitionsDestinyNodeStepDefinition.stepIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationRequirement, affectsLevel, affectsQuality, canActivateNextStep, damageType, damageTypeHash, displayProperties, interactionDescription, isNextStepRandom, nextStepIndex, nodeStepHash, perkHashes, socketReplacements, startProgressionBarAtProgress, statHashes, stepGroups, stepIndex);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyNodeStepDefinition {\n");
    sb.append("    activationRequirement: ").append(toIndentedString(activationRequirement)).append("\n");
    sb.append("    affectsLevel: ").append(toIndentedString(affectsLevel)).append("\n");
    sb.append("    affectsQuality: ").append(toIndentedString(affectsQuality)).append("\n");
    sb.append("    canActivateNextStep: ").append(toIndentedString(canActivateNextStep)).append("\n");
    sb.append("    damageType: ").append(toIndentedString(damageType)).append("\n");
    sb.append("    damageTypeHash: ").append(toIndentedString(damageTypeHash)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    interactionDescription: ").append(toIndentedString(interactionDescription)).append("\n");
    sb.append("    isNextStepRandom: ").append(toIndentedString(isNextStepRandom)).append("\n");
    sb.append("    nextStepIndex: ").append(toIndentedString(nextStepIndex)).append("\n");
    sb.append("    nodeStepHash: ").append(toIndentedString(nodeStepHash)).append("\n");
    sb.append("    perkHashes: ").append(toIndentedString(perkHashes)).append("\n");
    sb.append("    socketReplacements: ").append(toIndentedString(socketReplacements)).append("\n");
    sb.append("    startProgressionBarAtProgress: ").append(toIndentedString(startProgressionBarAtProgress)).append("\n");
    sb.append("    statHashes: ").append(toIndentedString(statHashes)).append("\n");
    sb.append("    stepGroups: ").append(toIndentedString(stepGroups)).append("\n");
    sb.append("    stepIndex: ").append(toIndentedString(stepIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationRequirement");
    openapiFields.add("affectsLevel");
    openapiFields.add("affectsQuality");
    openapiFields.add("canActivateNextStep");
    openapiFields.add("damageType");
    openapiFields.add("damageTypeHash");
    openapiFields.add("displayProperties");
    openapiFields.add("interactionDescription");
    openapiFields.add("isNextStepRandom");
    openapiFields.add("nextStepIndex");
    openapiFields.add("nodeStepHash");
    openapiFields.add("perkHashes");
    openapiFields.add("socketReplacements");
    openapiFields.add("startProgressionBarAtProgress");
    openapiFields.add("statHashes");
    openapiFields.add("stepGroups");
    openapiFields.add("stepIndex");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyNodeStepDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyNodeStepDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyNodeStepDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyNodeStepDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyNodeStepDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyNodeStepDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `activationRequirement`
      if (jsonObj.get("activationRequirement") != null && !jsonObj.get("activationRequirement").isJsonNull()) {
        DestinyDefinitionsDestinyNodeActivationRequirement.validateJsonElement(jsonObj.get("activationRequirement"));
      }
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      if ((jsonObj.get("interactionDescription") != null && !jsonObj.get("interactionDescription").isJsonNull()) && !jsonObj.get("interactionDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interactionDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interactionDescription").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("perkHashes") != null && !jsonObj.get("perkHashes").isJsonNull() && !jsonObj.get("perkHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `perkHashes` to be an array in the JSON string but got `%s`", jsonObj.get("perkHashes").toString()));
      }
      if (jsonObj.get("socketReplacements") != null && !jsonObj.get("socketReplacements").isJsonNull()) {
        JsonArray jsonArraysocketReplacements = jsonObj.getAsJsonArray("socketReplacements");
        if (jsonArraysocketReplacements != null) {
          // ensure the json data is an array
          if (!jsonObj.get("socketReplacements").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `socketReplacements` to be an array in the JSON string but got `%s`", jsonObj.get("socketReplacements").toString()));
          }

          // validate the optional field `socketReplacements` (array)
          for (int i = 0; i < jsonArraysocketReplacements.size(); i++) {
            DestinyDefinitionsDestinyNodeSocketReplaceResponse.validateJsonElement(jsonArraysocketReplacements.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("statHashes") != null && !jsonObj.get("statHashes").isJsonNull() && !jsonObj.get("statHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `statHashes` to be an array in the JSON string but got `%s`", jsonObj.get("statHashes").toString()));
      }
      // validate the optional field `stepGroups`
      if (jsonObj.get("stepGroups") != null && !jsonObj.get("stepGroups").isJsonNull()) {
        DestinyDefinitionsDestinyTalentNodeStepGroups.validateJsonElement(jsonObj.get("stepGroups"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyNodeStepDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyNodeStepDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyNodeStepDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyNodeStepDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyNodeStepDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyNodeStepDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyNodeStepDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyNodeStepDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyNodeStepDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyNodeStepDefinition
   */
  public static DestinyDefinitionsDestinyNodeStepDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyNodeStepDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyNodeStepDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

