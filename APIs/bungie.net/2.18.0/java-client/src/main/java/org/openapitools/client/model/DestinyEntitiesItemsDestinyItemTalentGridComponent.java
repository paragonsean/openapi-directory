/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDestinyProgression;
import org.openapitools.client.model.DestinyDestinyTalentNode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Well, we&#39;re here in Destiny 2, and Talent Grids are unfortunately still around.  The good news is that they&#39;re pretty much only being used for certain base information on items and for Builds/Subclasses. The bad news is that they still suck. If you really want this information, grab this component.  An important note is that talent grids are defined as such:  A Grid has 1:M Nodes, which has 1:M Steps.  Any given node can only have a single step active at one time, which represents the actual visual contents and effects of the Node (for instance, if you see a \&quot;Super Cool Bonus\&quot; node, the actual icon and text for the node is coming from the current Step of that node).  Nodes can be grouped into exclusivity sets *and* as of D2, exclusivity groups (which are collections of exclusivity sets that affect each other).  See DestinyTalentGridDefinition for more information. Brace yourself, the water&#39;s cold out there in the deep end.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyEntitiesItemsDestinyItemTalentGridComponent {
  public static final String SERIALIZED_NAME_GRID_PROGRESSION = "gridProgression";
  @SerializedName(SERIALIZED_NAME_GRID_PROGRESSION)
  private DestinyDestinyProgression gridProgression;

  public static final String SERIALIZED_NAME_IS_GRID_COMPLETE = "isGridComplete";
  @SerializedName(SERIALIZED_NAME_IS_GRID_COMPLETE)
  private Boolean isGridComplete;

  public static final String SERIALIZED_NAME_NODES = "nodes";
  @SerializedName(SERIALIZED_NAME_NODES)
  private List<DestinyDestinyTalentNode> nodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_TALENT_GRID_HASH = "talentGridHash";
  @SerializedName(SERIALIZED_NAME_TALENT_GRID_HASH)
  private Integer talentGridHash;

  public DestinyEntitiesItemsDestinyItemTalentGridComponent() {
  }

  public DestinyEntitiesItemsDestinyItemTalentGridComponent gridProgression(DestinyDestinyProgression gridProgression) {
    this.gridProgression = gridProgression;
    return this;
  }

  /**
   * If the item has a progression, it will be detailed here. A progression means that the item can gain experience. Thresholds of experience are what determines whether and when a talent node can be activated.
   * @return gridProgression
   */
  @javax.annotation.Nullable
  public DestinyDestinyProgression getGridProgression() {
    return gridProgression;
  }

  public void setGridProgression(DestinyDestinyProgression gridProgression) {
    this.gridProgression = gridProgression;
  }


  public DestinyEntitiesItemsDestinyItemTalentGridComponent isGridComplete(Boolean isGridComplete) {
    this.isGridComplete = isGridComplete;
    return this;
  }

  /**
   * Indicates whether the talent grid on this item is completed, and thus whether it should have a gold border around it.  Only will be true if the item actually *has* a talent grid, and only then if it is completed (i.e. every exclusive set has an activated node, and every non-exclusive set node has been activated)
   * @return isGridComplete
   */
  @javax.annotation.Nullable
  public Boolean getIsGridComplete() {
    return isGridComplete;
  }

  public void setIsGridComplete(Boolean isGridComplete) {
    this.isGridComplete = isGridComplete;
  }


  public DestinyEntitiesItemsDestinyItemTalentGridComponent nodes(List<DestinyDestinyTalentNode> nodes) {
    this.nodes = nodes;
    return this;
  }

  public DestinyEntitiesItemsDestinyItemTalentGridComponent addNodesItem(DestinyDestinyTalentNode nodesItem) {
    if (this.nodes == null) {
      this.nodes = new ArrayList<>();
    }
    this.nodes.add(nodesItem);
    return this;
  }

  /**
   * Detailed information about the individual nodes in the talent grid.  A node represents a single visual \&quot;pip\&quot; in the talent grid or Build detail view, though each node may have multiple \&quot;steps\&quot; which indicate the actual bonuses and visual representation of that node.
   * @return nodes
   */
  @javax.annotation.Nullable
  public List<DestinyDestinyTalentNode> getNodes() {
    return nodes;
  }

  public void setNodes(List<DestinyDestinyTalentNode> nodes) {
    this.nodes = nodes;
  }


  public DestinyEntitiesItemsDestinyItemTalentGridComponent talentGridHash(Integer talentGridHash) {
    this.talentGridHash = talentGridHash;
    return this;
  }

  /**
   * Most items don&#39;t have useful talent grids anymore, but Builds in particular still do.  You can use this hash to lookup the DestinyTalentGridDefinition attached to this item, which will be crucial for understanding the node values on the item.
   * @return talentGridHash
   */
  @javax.annotation.Nullable
  public Integer getTalentGridHash() {
    return talentGridHash;
  }

  public void setTalentGridHash(Integer talentGridHash) {
    this.talentGridHash = talentGridHash;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyEntitiesItemsDestinyItemTalentGridComponent destinyEntitiesItemsDestinyItemTalentGridComponent = (DestinyEntitiesItemsDestinyItemTalentGridComponent) o;
    return Objects.equals(this.gridProgression, destinyEntitiesItemsDestinyItemTalentGridComponent.gridProgression) &&
        Objects.equals(this.isGridComplete, destinyEntitiesItemsDestinyItemTalentGridComponent.isGridComplete) &&
        Objects.equals(this.nodes, destinyEntitiesItemsDestinyItemTalentGridComponent.nodes) &&
        Objects.equals(this.talentGridHash, destinyEntitiesItemsDestinyItemTalentGridComponent.talentGridHash);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gridProgression, isGridComplete, nodes, talentGridHash);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyEntitiesItemsDestinyItemTalentGridComponent {\n");
    sb.append("    gridProgression: ").append(toIndentedString(gridProgression)).append("\n");
    sb.append("    isGridComplete: ").append(toIndentedString(isGridComplete)).append("\n");
    sb.append("    nodes: ").append(toIndentedString(nodes)).append("\n");
    sb.append("    talentGridHash: ").append(toIndentedString(talentGridHash)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("gridProgression");
    openapiFields.add("isGridComplete");
    openapiFields.add("nodes");
    openapiFields.add("talentGridHash");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyEntitiesItemsDestinyItemTalentGridComponent
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyEntitiesItemsDestinyItemTalentGridComponent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyEntitiesItemsDestinyItemTalentGridComponent is not found in the empty JSON string", DestinyEntitiesItemsDestinyItemTalentGridComponent.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyEntitiesItemsDestinyItemTalentGridComponent.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyEntitiesItemsDestinyItemTalentGridComponent` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `gridProgression`
      if (jsonObj.get("gridProgression") != null && !jsonObj.get("gridProgression").isJsonNull()) {
        DestinyDestinyProgression.validateJsonElement(jsonObj.get("gridProgression"));
      }
      if (jsonObj.get("nodes") != null && !jsonObj.get("nodes").isJsonNull()) {
        JsonArray jsonArraynodes = jsonObj.getAsJsonArray("nodes");
        if (jsonArraynodes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("nodes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `nodes` to be an array in the JSON string but got `%s`", jsonObj.get("nodes").toString()));
          }

          // validate the optional field `nodes` (array)
          for (int i = 0; i < jsonArraynodes.size(); i++) {
            DestinyDestinyTalentNode.validateJsonElement(jsonArraynodes.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyEntitiesItemsDestinyItemTalentGridComponent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyEntitiesItemsDestinyItemTalentGridComponent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyEntitiesItemsDestinyItemTalentGridComponent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyEntitiesItemsDestinyItemTalentGridComponent.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyEntitiesItemsDestinyItemTalentGridComponent>() {
           @Override
           public void write(JsonWriter out, DestinyEntitiesItemsDestinyItemTalentGridComponent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyEntitiesItemsDestinyItemTalentGridComponent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyEntitiesItemsDestinyItemTalentGridComponent given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyEntitiesItemsDestinyItemTalentGridComponent
   * @throws IOException if the JSON string is invalid with respect to DestinyEntitiesItemsDestinyItemTalentGridComponent
   */
  public static DestinyEntitiesItemsDestinyItemTalentGridComponent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyEntitiesItemsDestinyItemTalentGridComponent.class);
  }

  /**
   * Convert an instance of DestinyEntitiesItemsDestinyItemTalentGridComponent to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

