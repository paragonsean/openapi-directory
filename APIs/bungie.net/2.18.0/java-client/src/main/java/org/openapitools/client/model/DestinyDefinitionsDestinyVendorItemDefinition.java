/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemCreationEntryLevelDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyVendorItemQuantity;
import org.openapitools.client.model.DestinyDefinitionsDestinyVendorItemSocketOverride;
import org.openapitools.client.model.DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This represents an item being sold by the vendor.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyVendorItemDefinition {
  public static final String SERIALIZED_NAME_ACTION = "action";
  @SerializedName(SERIALIZED_NAME_ACTION)
  private DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition action;

  public static final String SERIALIZED_NAME_CATEGORY_INDEX = "categoryIndex";
  @SerializedName(SERIALIZED_NAME_CATEGORY_INDEX)
  private Integer categoryIndex;

  public static final String SERIALIZED_NAME_CREATION_LEVELS = "creationLevels";
  @SerializedName(SERIALIZED_NAME_CREATION_LEVELS)
  private List<DestinyDefinitionsDestinyItemCreationEntryLevelDefinition> creationLevels = new ArrayList<>();

  public static final String SERIALIZED_NAME_CURRENCIES = "currencies";
  @SerializedName(SERIALIZED_NAME_CURRENCIES)
  private List<DestinyDefinitionsDestinyVendorItemQuantity> currencies = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAY_CATEGORY = "displayCategory";
  @SerializedName(SERIALIZED_NAME_DISPLAY_CATEGORY)
  private String displayCategory;

  public static final String SERIALIZED_NAME_DISPLAY_CATEGORY_INDEX = "displayCategoryIndex";
  @SerializedName(SERIALIZED_NAME_DISPLAY_CATEGORY_INDEX)
  private Integer displayCategoryIndex;

  public static final String SERIALIZED_NAME_EXCLUSIVITY = "exclusivity";
  @SerializedName(SERIALIZED_NAME_EXCLUSIVITY)
  private Integer exclusivity;

  public static final String SERIALIZED_NAME_EXPIRATION_TOOLTIP = "expirationTooltip";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_TOOLTIP)
  private String expirationTooltip;

  public static final String SERIALIZED_NAME_FAILURE_INDEXES = "failureIndexes";
  @SerializedName(SERIALIZED_NAME_FAILURE_INDEXES)
  private List<Integer> failureIndexes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVENTORY_BUCKET_HASH = "inventoryBucketHash";
  @SerializedName(SERIALIZED_NAME_INVENTORY_BUCKET_HASH)
  private Integer inventoryBucketHash;

  public static final String SERIALIZED_NAME_IS_CRM = "isCrm";
  @SerializedName(SERIALIZED_NAME_IS_CRM)
  private Boolean isCrm;

  public static final String SERIALIZED_NAME_IS_OFFER = "isOffer";
  @SerializedName(SERIALIZED_NAME_IS_OFFER)
  private Boolean isOffer;

  public static final String SERIALIZED_NAME_ITEM_HASH = "itemHash";
  @SerializedName(SERIALIZED_NAME_ITEM_HASH)
  private Integer itemHash;

  public static final String SERIALIZED_NAME_MAXIMUM_LEVEL = "maximumLevel";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_LEVEL)
  private Integer maximumLevel;

  public static final String SERIALIZED_NAME_MINIMUM_LEVEL = "minimumLevel";
  @SerializedName(SERIALIZED_NAME_MINIMUM_LEVEL)
  private Integer minimumLevel;

  public static final String SERIALIZED_NAME_ORIGINAL_CATEGORY_INDEX = "originalCategoryIndex";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_CATEGORY_INDEX)
  private Integer originalCategoryIndex;

  public static final String SERIALIZED_NAME_PURCHASABLE_SCOPE = "purchasableScope";
  @SerializedName(SERIALIZED_NAME_PURCHASABLE_SCOPE)
  private Integer purchasableScope;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private Integer quantity;

  public static final String SERIALIZED_NAME_REDIRECT_TO_SALE_INDEXES = "redirectToSaleIndexes";
  @SerializedName(SERIALIZED_NAME_REDIRECT_TO_SALE_INDEXES)
  private List<Integer> redirectToSaleIndexes = new ArrayList<>();

  public static final String SERIALIZED_NAME_REFUND_POLICY = "refundPolicy";
  @SerializedName(SERIALIZED_NAME_REFUND_POLICY)
  private Integer refundPolicy;

  public static final String SERIALIZED_NAME_REFUND_TIME_LIMIT = "refundTimeLimit";
  @SerializedName(SERIALIZED_NAME_REFUND_TIME_LIMIT)
  private Integer refundTimeLimit;

  public static final String SERIALIZED_NAME_SOCKET_OVERRIDES = "socketOverrides";
  @SerializedName(SERIALIZED_NAME_SOCKET_OVERRIDES)
  private List<DestinyDefinitionsDestinyVendorItemSocketOverride> socketOverrides = new ArrayList<>();

  public static final String SERIALIZED_NAME_SORT_VALUE = "sortValue";
  @SerializedName(SERIALIZED_NAME_SORT_VALUE)
  private Integer sortValue;

  public static final String SERIALIZED_NAME_UNPURCHASABLE = "unpurchasable";
  @SerializedName(SERIALIZED_NAME_UNPURCHASABLE)
  private Boolean unpurchasable;

  public static final String SERIALIZED_NAME_VENDOR_ITEM_INDEX = "vendorItemIndex";
  @SerializedName(SERIALIZED_NAME_VENDOR_ITEM_INDEX)
  private Integer vendorItemIndex;

  public static final String SERIALIZED_NAME_VISIBILITY_SCOPE = "visibilityScope";
  @SerializedName(SERIALIZED_NAME_VISIBILITY_SCOPE)
  private Integer visibilityScope;

  public DestinyDefinitionsDestinyVendorItemDefinition() {
  }

  public DestinyDefinitionsDestinyVendorItemDefinition action(DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition action) {
    this.action = action;
    return this;
  }

  /**
   * The action to be performed when purchasing the item, if it&#39;s not just \&quot;buy\&quot;.
   * @return action
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition getAction() {
    return action;
  }

  public void setAction(DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition action) {
    this.action = action;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition categoryIndex(Integer categoryIndex) {
    this.categoryIndex = categoryIndex;
    return this;
  }

  /**
   * The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.
   * @return categoryIndex
   */
  @javax.annotation.Nullable
  public Integer getCategoryIndex() {
    return categoryIndex;
  }

  public void setCategoryIndex(Integer categoryIndex) {
    this.categoryIndex = categoryIndex;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition creationLevels(List<DestinyDefinitionsDestinyItemCreationEntryLevelDefinition> creationLevels) {
    this.creationLevels = creationLevels;
    return this;
  }

  public DestinyDefinitionsDestinyVendorItemDefinition addCreationLevelsItem(DestinyDefinitionsDestinyItemCreationEntryLevelDefinition creationLevelsItem) {
    if (this.creationLevels == null) {
      this.creationLevels = new ArrayList<>();
    }
    this.creationLevels.add(creationLevelsItem);
    return this;
  }

  /**
   * The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It&#39;s a long story how this ended up as a list, but there is always either going to be 0:1 of these entities.
   * @return creationLevels
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemCreationEntryLevelDefinition> getCreationLevels() {
    return creationLevels;
  }

  public void setCreationLevels(List<DestinyDefinitionsDestinyItemCreationEntryLevelDefinition> creationLevels) {
    this.creationLevels = creationLevels;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition currencies(List<DestinyDefinitionsDestinyVendorItemQuantity> currencies) {
    this.currencies = currencies;
    return this;
  }

  public DestinyDefinitionsDestinyVendorItemDefinition addCurrenciesItem(DestinyDefinitionsDestinyVendorItemQuantity currenciesItem) {
    if (this.currencies == null) {
      this.currencies = new ArrayList<>();
    }
    this.currencies.add(currenciesItem);
    return this;
  }

  /**
   * This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.  The somewhat crappy part about this is that, now that item quantity overrides have dynamic modifiers, this will not necessarily be statically true. If you were using this instead of live data, switch to using live data.
   * @return currencies
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyVendorItemQuantity> getCurrencies() {
    return currencies;
  }

  public void setCurrencies(List<DestinyDefinitionsDestinyVendorItemQuantity> currencies) {
    this.currencies = currencies;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition displayCategory(String displayCategory) {
    this.displayCategory = displayCategory;
    return this;
  }

  /**
   * The string identifier for the category selling this item.
   * @return displayCategory
   */
  @javax.annotation.Nullable
  public String getDisplayCategory() {
    return displayCategory;
  }

  public void setDisplayCategory(String displayCategory) {
    this.displayCategory = displayCategory;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition displayCategoryIndex(Integer displayCategoryIndex) {
    this.displayCategoryIndex = displayCategoryIndex;
    return this;
  }

  /**
   * This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)
   * @return displayCategoryIndex
   */
  @javax.annotation.Nullable
  public Integer getDisplayCategoryIndex() {
    return displayCategoryIndex;
  }

  public void setDisplayCategoryIndex(Integer displayCategoryIndex) {
    this.displayCategoryIndex = displayCategoryIndex;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition exclusivity(Integer exclusivity) {
    this.exclusivity = exclusivity;
    return this;
  }

  /**
   * If this item can only be purchased by a given platform, this indicates the platform to which it is restricted.
   * @return exclusivity
   */
  @javax.annotation.Nullable
  public Integer getExclusivity() {
    return exclusivity;
  }

  public void setExclusivity(Integer exclusivity) {
    this.exclusivity = exclusivity;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition expirationTooltip(String expirationTooltip) {
    this.expirationTooltip = expirationTooltip;
    return this;
  }

  /**
   * If this item can expire, this is the tooltip message to show with its expiration info.
   * @return expirationTooltip
   */
  @javax.annotation.Nullable
  public String getExpirationTooltip() {
    return expirationTooltip;
  }

  public void setExpirationTooltip(String expirationTooltip) {
    this.expirationTooltip = expirationTooltip;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition failureIndexes(List<Integer> failureIndexes) {
    this.failureIndexes = failureIndexes;
    return this;
  }

  public DestinyDefinitionsDestinyVendorItemDefinition addFailureIndexesItem(Integer failureIndexesItem) {
    if (this.failureIndexes == null) {
      this.failureIndexes = new ArrayList<>();
    }
    this.failureIndexes.add(failureIndexesItem);
    return this;
  }

  /**
   * An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.
   * @return failureIndexes
   */
  @javax.annotation.Nullable
  public List<Integer> getFailureIndexes() {
    return failureIndexes;
  }

  public void setFailureIndexes(List<Integer> failureIndexes) {
    this.failureIndexes = failureIndexes;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition inventoryBucketHash(Integer inventoryBucketHash) {
    this.inventoryBucketHash = inventoryBucketHash;
    return this;
  }

  /**
   * The inventory bucket into which this item will be placed upon purchase.
   * @return inventoryBucketHash
   */
  @javax.annotation.Nullable
  public Integer getInventoryBucketHash() {
    return inventoryBucketHash;
  }

  public void setInventoryBucketHash(Integer inventoryBucketHash) {
    this.inventoryBucketHash = inventoryBucketHash;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition isCrm(Boolean isCrm) {
    this.isCrm = isCrm;
    return this;
  }

  /**
   * If this sale can only be performed as the result of receiving a CRM offer, this is true.
   * @return isCrm
   */
  @javax.annotation.Nullable
  public Boolean getIsCrm() {
    return isCrm;
  }

  public void setIsCrm(Boolean isCrm) {
    this.isCrm = isCrm;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition isOffer(Boolean isOffer) {
    this.isOffer = isOffer;
    return this;
  }

  /**
   * If this sale can only be performed as the result of an offer check, this is true.
   * @return isOffer
   */
  @javax.annotation.Nullable
  public Boolean getIsOffer() {
    return isOffer;
  }

  public void setIsOffer(Boolean isOffer) {
    this.isOffer = isOffer;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition itemHash(Integer itemHash) {
    this.itemHash = itemHash;
    return this;
  }

  /**
   * The hash identifier of the item being sold (DestinyInventoryItemDefinition).  Note that a vendor can sell the same item in multiple ways, so don&#39;t assume that itemHash is a unique identifier for this entity.
   * @return itemHash
   */
  @javax.annotation.Nullable
  public Integer getItemHash() {
    return itemHash;
  }

  public void setItemHash(Integer itemHash) {
    this.itemHash = itemHash;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition maximumLevel(Integer maximumLevel) {
    this.maximumLevel = maximumLevel;
    return this;
  }

  /**
   * The maximum character level at which this item is available for sale.
   * @return maximumLevel
   */
  @javax.annotation.Nullable
  public Integer getMaximumLevel() {
    return maximumLevel;
  }

  public void setMaximumLevel(Integer maximumLevel) {
    this.maximumLevel = maximumLevel;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition minimumLevel(Integer minimumLevel) {
    this.minimumLevel = minimumLevel;
    return this;
  }

  /**
   * The minimum character level at which this item is available for sale.
   * @return minimumLevel
   */
  @javax.annotation.Nullable
  public Integer getMinimumLevel() {
    return minimumLevel;
  }

  public void setMinimumLevel(Integer minimumLevel) {
    this.minimumLevel = minimumLevel;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition originalCategoryIndex(Integer originalCategoryIndex) {
    this.originalCategoryIndex = originalCategoryIndex;
    return this;
  }

  /**
   * Same as above, but for the original category indexes.
   * @return originalCategoryIndex
   */
  @javax.annotation.Nullable
  public Integer getOriginalCategoryIndex() {
    return originalCategoryIndex;
  }

  public void setOriginalCategoryIndex(Integer originalCategoryIndex) {
    this.originalCategoryIndex = originalCategoryIndex;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition purchasableScope(Integer purchasableScope) {
    this.purchasableScope = purchasableScope;
    return this;
  }

  /**
   * Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.  See DestinyGatingScope&#39;s documentation for more information.
   * @return purchasableScope
   */
  @javax.annotation.Nullable
  public Integer getPurchasableScope() {
    return purchasableScope;
  }

  public void setPurchasableScope(Integer purchasableScope) {
    this.purchasableScope = purchasableScope;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition quantity(Integer quantity) {
    this.quantity = quantity;
    return this;
  }

  /**
   * The amount you will recieve of the item described in itemHash if you make the purchase.
   * @return quantity
   */
  @javax.annotation.Nullable
  public Integer getQuantity() {
    return quantity;
  }

  public void setQuantity(Integer quantity) {
    this.quantity = quantity;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition redirectToSaleIndexes(List<Integer> redirectToSaleIndexes) {
    this.redirectToSaleIndexes = redirectToSaleIndexes;
    return this;
  }

  public DestinyDefinitionsDestinyVendorItemDefinition addRedirectToSaleIndexesItem(Integer redirectToSaleIndexesItem) {
    if (this.redirectToSaleIndexes == null) {
      this.redirectToSaleIndexes = new ArrayList<>();
    }
    this.redirectToSaleIndexes.add(redirectToSaleIndexesItem);
    return this;
  }

  /**
   * If this is populated, the purchase of this item should redirect to purchasing these other items instead.
   * @return redirectToSaleIndexes
   */
  @javax.annotation.Nullable
  public List<Integer> getRedirectToSaleIndexes() {
    return redirectToSaleIndexes;
  }

  public void setRedirectToSaleIndexes(List<Integer> redirectToSaleIndexes) {
    this.redirectToSaleIndexes = redirectToSaleIndexes;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition refundPolicy(Integer refundPolicy) {
    this.refundPolicy = refundPolicy;
    return this;
  }

  /**
   * If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.
   * @return refundPolicy
   */
  @javax.annotation.Nullable
  public Integer getRefundPolicy() {
    return refundPolicy;
  }

  public void setRefundPolicy(Integer refundPolicy) {
    this.refundPolicy = refundPolicy;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition refundTimeLimit(Integer refundTimeLimit) {
    this.refundTimeLimit = refundTimeLimit;
    return this;
  }

  /**
   * The amount of time before refundability of the newly purchased item will expire.
   * @return refundTimeLimit
   */
  @javax.annotation.Nullable
  public Integer getRefundTimeLimit() {
    return refundTimeLimit;
  }

  public void setRefundTimeLimit(Integer refundTimeLimit) {
    this.refundTimeLimit = refundTimeLimit;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition socketOverrides(List<DestinyDefinitionsDestinyVendorItemSocketOverride> socketOverrides) {
    this.socketOverrides = socketOverrides;
    return this;
  }

  public DestinyDefinitionsDestinyVendorItemDefinition addSocketOverridesItem(DestinyDefinitionsDestinyVendorItemSocketOverride socketOverridesItem) {
    if (this.socketOverrides == null) {
      this.socketOverrides = new ArrayList<>();
    }
    this.socketOverrides.add(socketOverridesItem);
    return this;
  }

  /**
   * Get socketOverrides
   * @return socketOverrides
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyVendorItemSocketOverride> getSocketOverrides() {
    return socketOverrides;
  }

  public void setSocketOverrides(List<DestinyDefinitionsDestinyVendorItemSocketOverride> socketOverrides) {
    this.socketOverrides = socketOverrides;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition sortValue(Integer sortValue) {
    this.sortValue = sortValue;
    return this;
  }

  /**
   * *if* the category this item is in supports non-default sorting, this value should represent the sorting value to use, pre-processed and ready to go.
   * @return sortValue
   */
  @javax.annotation.Nullable
  public Integer getSortValue() {
    return sortValue;
  }

  public void setSortValue(Integer sortValue) {
    this.sortValue = sortValue;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition unpurchasable(Boolean unpurchasable) {
    this.unpurchasable = unpurchasable;
    return this;
  }

  /**
   * If true, this item is some sort of dummy sale item that cannot actually be purchased. It may be a display only item, or some fluff left by a content designer for testing purposes, or something that got disabled because it was a terrible idea. You get the picture. We won&#39;t know *why* it can&#39;t be purchased, only that it can&#39;t be. Sorry.  This is also only whether it&#39;s unpurchasable as a static property according to game content. There are other reasons why an item may or may not be purchasable at runtime, so even if this isn&#39;t set to True you should trust the runtime value for this sale item over the static definition if this is unset.
   * @return unpurchasable
   */
  @javax.annotation.Nullable
  public Boolean getUnpurchasable() {
    return unpurchasable;
  }

  public void setUnpurchasable(Boolean unpurchasable) {
    this.unpurchasable = unpurchasable;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition vendorItemIndex(Integer vendorItemIndex) {
    this.vendorItemIndex = vendorItemIndex;
    return this;
  }

  /**
   * The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.
   * @return vendorItemIndex
   */
  @javax.annotation.Nullable
  public Integer getVendorItemIndex() {
    return vendorItemIndex;
  }

  public void setVendorItemIndex(Integer vendorItemIndex) {
    this.vendorItemIndex = vendorItemIndex;
  }


  public DestinyDefinitionsDestinyVendorItemDefinition visibilityScope(Integer visibilityScope) {
    this.visibilityScope = visibilityScope;
    return this;
  }

  /**
   * The most restrictive scope that determines whether the item is available in the Vendor&#39;s inventory. See DestinyGatingScope&#39;s documentation for more information.  This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).
   * @return visibilityScope
   */
  @javax.annotation.Nullable
  public Integer getVisibilityScope() {
    return visibilityScope;
  }

  public void setVisibilityScope(Integer visibilityScope) {
    this.visibilityScope = visibilityScope;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyVendorItemDefinition destinyDefinitionsDestinyVendorItemDefinition = (DestinyDefinitionsDestinyVendorItemDefinition) o;
    return Objects.equals(this.action, destinyDefinitionsDestinyVendorItemDefinition.action) &&
        Objects.equals(this.categoryIndex, destinyDefinitionsDestinyVendorItemDefinition.categoryIndex) &&
        Objects.equals(this.creationLevels, destinyDefinitionsDestinyVendorItemDefinition.creationLevels) &&
        Objects.equals(this.currencies, destinyDefinitionsDestinyVendorItemDefinition.currencies) &&
        Objects.equals(this.displayCategory, destinyDefinitionsDestinyVendorItemDefinition.displayCategory) &&
        Objects.equals(this.displayCategoryIndex, destinyDefinitionsDestinyVendorItemDefinition.displayCategoryIndex) &&
        Objects.equals(this.exclusivity, destinyDefinitionsDestinyVendorItemDefinition.exclusivity) &&
        Objects.equals(this.expirationTooltip, destinyDefinitionsDestinyVendorItemDefinition.expirationTooltip) &&
        Objects.equals(this.failureIndexes, destinyDefinitionsDestinyVendorItemDefinition.failureIndexes) &&
        Objects.equals(this.inventoryBucketHash, destinyDefinitionsDestinyVendorItemDefinition.inventoryBucketHash) &&
        Objects.equals(this.isCrm, destinyDefinitionsDestinyVendorItemDefinition.isCrm) &&
        Objects.equals(this.isOffer, destinyDefinitionsDestinyVendorItemDefinition.isOffer) &&
        Objects.equals(this.itemHash, destinyDefinitionsDestinyVendorItemDefinition.itemHash) &&
        Objects.equals(this.maximumLevel, destinyDefinitionsDestinyVendorItemDefinition.maximumLevel) &&
        Objects.equals(this.minimumLevel, destinyDefinitionsDestinyVendorItemDefinition.minimumLevel) &&
        Objects.equals(this.originalCategoryIndex, destinyDefinitionsDestinyVendorItemDefinition.originalCategoryIndex) &&
        Objects.equals(this.purchasableScope, destinyDefinitionsDestinyVendorItemDefinition.purchasableScope) &&
        Objects.equals(this.quantity, destinyDefinitionsDestinyVendorItemDefinition.quantity) &&
        Objects.equals(this.redirectToSaleIndexes, destinyDefinitionsDestinyVendorItemDefinition.redirectToSaleIndexes) &&
        Objects.equals(this.refundPolicy, destinyDefinitionsDestinyVendorItemDefinition.refundPolicy) &&
        Objects.equals(this.refundTimeLimit, destinyDefinitionsDestinyVendorItemDefinition.refundTimeLimit) &&
        Objects.equals(this.socketOverrides, destinyDefinitionsDestinyVendorItemDefinition.socketOverrides) &&
        Objects.equals(this.sortValue, destinyDefinitionsDestinyVendorItemDefinition.sortValue) &&
        Objects.equals(this.unpurchasable, destinyDefinitionsDestinyVendorItemDefinition.unpurchasable) &&
        Objects.equals(this.vendorItemIndex, destinyDefinitionsDestinyVendorItemDefinition.vendorItemIndex) &&
        Objects.equals(this.visibilityScope, destinyDefinitionsDestinyVendorItemDefinition.visibilityScope);
  }

  @Override
  public int hashCode() {
    return Objects.hash(action, categoryIndex, creationLevels, currencies, displayCategory, displayCategoryIndex, exclusivity, expirationTooltip, failureIndexes, inventoryBucketHash, isCrm, isOffer, itemHash, maximumLevel, minimumLevel, originalCategoryIndex, purchasableScope, quantity, redirectToSaleIndexes, refundPolicy, refundTimeLimit, socketOverrides, sortValue, unpurchasable, vendorItemIndex, visibilityScope);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyVendorItemDefinition {\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    categoryIndex: ").append(toIndentedString(categoryIndex)).append("\n");
    sb.append("    creationLevels: ").append(toIndentedString(creationLevels)).append("\n");
    sb.append("    currencies: ").append(toIndentedString(currencies)).append("\n");
    sb.append("    displayCategory: ").append(toIndentedString(displayCategory)).append("\n");
    sb.append("    displayCategoryIndex: ").append(toIndentedString(displayCategoryIndex)).append("\n");
    sb.append("    exclusivity: ").append(toIndentedString(exclusivity)).append("\n");
    sb.append("    expirationTooltip: ").append(toIndentedString(expirationTooltip)).append("\n");
    sb.append("    failureIndexes: ").append(toIndentedString(failureIndexes)).append("\n");
    sb.append("    inventoryBucketHash: ").append(toIndentedString(inventoryBucketHash)).append("\n");
    sb.append("    isCrm: ").append(toIndentedString(isCrm)).append("\n");
    sb.append("    isOffer: ").append(toIndentedString(isOffer)).append("\n");
    sb.append("    itemHash: ").append(toIndentedString(itemHash)).append("\n");
    sb.append("    maximumLevel: ").append(toIndentedString(maximumLevel)).append("\n");
    sb.append("    minimumLevel: ").append(toIndentedString(minimumLevel)).append("\n");
    sb.append("    originalCategoryIndex: ").append(toIndentedString(originalCategoryIndex)).append("\n");
    sb.append("    purchasableScope: ").append(toIndentedString(purchasableScope)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    redirectToSaleIndexes: ").append(toIndentedString(redirectToSaleIndexes)).append("\n");
    sb.append("    refundPolicy: ").append(toIndentedString(refundPolicy)).append("\n");
    sb.append("    refundTimeLimit: ").append(toIndentedString(refundTimeLimit)).append("\n");
    sb.append("    socketOverrides: ").append(toIndentedString(socketOverrides)).append("\n");
    sb.append("    sortValue: ").append(toIndentedString(sortValue)).append("\n");
    sb.append("    unpurchasable: ").append(toIndentedString(unpurchasable)).append("\n");
    sb.append("    vendorItemIndex: ").append(toIndentedString(vendorItemIndex)).append("\n");
    sb.append("    visibilityScope: ").append(toIndentedString(visibilityScope)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("action");
    openapiFields.add("categoryIndex");
    openapiFields.add("creationLevels");
    openapiFields.add("currencies");
    openapiFields.add("displayCategory");
    openapiFields.add("displayCategoryIndex");
    openapiFields.add("exclusivity");
    openapiFields.add("expirationTooltip");
    openapiFields.add("failureIndexes");
    openapiFields.add("inventoryBucketHash");
    openapiFields.add("isCrm");
    openapiFields.add("isOffer");
    openapiFields.add("itemHash");
    openapiFields.add("maximumLevel");
    openapiFields.add("minimumLevel");
    openapiFields.add("originalCategoryIndex");
    openapiFields.add("purchasableScope");
    openapiFields.add("quantity");
    openapiFields.add("redirectToSaleIndexes");
    openapiFields.add("refundPolicy");
    openapiFields.add("refundTimeLimit");
    openapiFields.add("socketOverrides");
    openapiFields.add("sortValue");
    openapiFields.add("unpurchasable");
    openapiFields.add("vendorItemIndex");
    openapiFields.add("visibilityScope");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyVendorItemDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyVendorItemDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyVendorItemDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyVendorItemDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyVendorItemDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyVendorItemDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `action`
      if (jsonObj.get("action") != null && !jsonObj.get("action").isJsonNull()) {
        DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition.validateJsonElement(jsonObj.get("action"));
      }
      if (jsonObj.get("creationLevels") != null && !jsonObj.get("creationLevels").isJsonNull()) {
        JsonArray jsonArraycreationLevels = jsonObj.getAsJsonArray("creationLevels");
        if (jsonArraycreationLevels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("creationLevels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `creationLevels` to be an array in the JSON string but got `%s`", jsonObj.get("creationLevels").toString()));
          }

          // validate the optional field `creationLevels` (array)
          for (int i = 0; i < jsonArraycreationLevels.size(); i++) {
            DestinyDefinitionsDestinyItemCreationEntryLevelDefinition.validateJsonElement(jsonArraycreationLevels.get(i));
          };
        }
      }
      if (jsonObj.get("currencies") != null && !jsonObj.get("currencies").isJsonNull()) {
        JsonArray jsonArraycurrencies = jsonObj.getAsJsonArray("currencies");
        if (jsonArraycurrencies != null) {
          // ensure the json data is an array
          if (!jsonObj.get("currencies").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `currencies` to be an array in the JSON string but got `%s`", jsonObj.get("currencies").toString()));
          }

          // validate the optional field `currencies` (array)
          for (int i = 0; i < jsonArraycurrencies.size(); i++) {
            DestinyDefinitionsDestinyVendorItemQuantity.validateJsonElement(jsonArraycurrencies.get(i));
          };
        }
      }
      if ((jsonObj.get("displayCategory") != null && !jsonObj.get("displayCategory").isJsonNull()) && !jsonObj.get("displayCategory").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayCategory` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayCategory").toString()));
      }
      if ((jsonObj.get("expirationTooltip") != null && !jsonObj.get("expirationTooltip").isJsonNull()) && !jsonObj.get("expirationTooltip").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expirationTooltip` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expirationTooltip").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("failureIndexes") != null && !jsonObj.get("failureIndexes").isJsonNull() && !jsonObj.get("failureIndexes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `failureIndexes` to be an array in the JSON string but got `%s`", jsonObj.get("failureIndexes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("redirectToSaleIndexes") != null && !jsonObj.get("redirectToSaleIndexes").isJsonNull() && !jsonObj.get("redirectToSaleIndexes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `redirectToSaleIndexes` to be an array in the JSON string but got `%s`", jsonObj.get("redirectToSaleIndexes").toString()));
      }
      if (jsonObj.get("socketOverrides") != null && !jsonObj.get("socketOverrides").isJsonNull()) {
        JsonArray jsonArraysocketOverrides = jsonObj.getAsJsonArray("socketOverrides");
        if (jsonArraysocketOverrides != null) {
          // ensure the json data is an array
          if (!jsonObj.get("socketOverrides").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `socketOverrides` to be an array in the JSON string but got `%s`", jsonObj.get("socketOverrides").toString()));
          }

          // validate the optional field `socketOverrides` (array)
          for (int i = 0; i < jsonArraysocketOverrides.size(); i++) {
            DestinyDefinitionsDestinyVendorItemSocketOverride.validateJsonElement(jsonArraysocketOverrides.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyVendorItemDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyVendorItemDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyVendorItemDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyVendorItemDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyVendorItemDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyVendorItemDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyVendorItemDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyVendorItemDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyVendorItemDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyVendorItemDefinition
   */
  public static DestinyDefinitionsDestinyVendorItemDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyVendorItemDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyVendorItemDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

