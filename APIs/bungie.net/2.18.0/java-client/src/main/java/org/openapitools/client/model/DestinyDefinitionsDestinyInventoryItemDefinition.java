/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsAnimationsDestinyAnimationReference;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyEquippingBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemActionBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemCraftingBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemGearsetBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemInventoryBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemInvestmentStatDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemMetricBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemObjectiveBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemPerkEntryDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemPreviewBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemQualityBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSackBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSetBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSocketBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSourceBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemStatBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemSummaryBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemTalentGridBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemTooltipNotification;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemTranslationBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyItemValueBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsItemsDestinyItemPlugDefinition;
import org.openapitools.client.model.DestinyMiscDestinyColor;
import org.openapitools.client.model.LinksHyperlinkReference;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.  In practice, you will want to associate this data with \&quot;live\&quot; item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyInventoryItemDefinition {
  public static final String SERIALIZED_NAME_ACTION = "action";
  @SerializedName(SERIALIZED_NAME_ACTION)
  private DestinyDefinitionsDestinyItemActionBlockDefinition action;

  public static final String SERIALIZED_NAME_ALLOW_ACTIONS = "allowActions";
  @SerializedName(SERIALIZED_NAME_ALLOW_ACTIONS)
  private Boolean allowActions;

  public static final String SERIALIZED_NAME_ANIMATIONS = "animations";
  @SerializedName(SERIALIZED_NAME_ANIMATIONS)
  private List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations = new ArrayList<>();

  public static final String SERIALIZED_NAME_BACKGROUND_COLOR = "backgroundColor";
  @SerializedName(SERIALIZED_NAME_BACKGROUND_COLOR)
  private DestinyMiscDestinyColor backgroundColor;

  public static final String SERIALIZED_NAME_BREAKER_TYPE = "breakerType";
  @SerializedName(SERIALIZED_NAME_BREAKER_TYPE)
  private Integer breakerType;

  public static final String SERIALIZED_NAME_BREAKER_TYPE_HASH = "breakerTypeHash";
  @SerializedName(SERIALIZED_NAME_BREAKER_TYPE_HASH)
  private Integer breakerTypeHash;

  public static final String SERIALIZED_NAME_CLASS_TYPE = "classType";
  @SerializedName(SERIALIZED_NAME_CLASS_TYPE)
  private Integer classType;

  public static final String SERIALIZED_NAME_COLLECTIBLE_HASH = "collectibleHash";
  @SerializedName(SERIALIZED_NAME_COLLECTIBLE_HASH)
  private Integer collectibleHash;

  public static final String SERIALIZED_NAME_CRAFTING = "crafting";
  @SerializedName(SERIALIZED_NAME_CRAFTING)
  private DestinyDefinitionsDestinyItemCraftingBlockDefinition crafting;

  public static final String SERIALIZED_NAME_DAMAGE_TYPE_HASHES = "damageTypeHashes";
  @SerializedName(SERIALIZED_NAME_DAMAGE_TYPE_HASHES)
  private List<Integer> damageTypeHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_DAMAGE_TYPES = "damageTypes";
  @SerializedName(SERIALIZED_NAME_DAMAGE_TYPES)
  private List<Integer> damageTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEFAULT_DAMAGE_TYPE = "defaultDamageType";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DAMAGE_TYPE)
  private Integer defaultDamageType;

  public static final String SERIALIZED_NAME_DEFAULT_DAMAGE_TYPE_HASH = "defaultDamageTypeHash";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DAMAGE_TYPE_HASH)
  private Integer defaultDamageTypeHash;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_DISPLAY_SOURCE = "displaySource";
  @SerializedName(SERIALIZED_NAME_DISPLAY_SOURCE)
  private String displaySource;

  public static final String SERIALIZED_NAME_DOES_POSTMASTER_PULL_HAVE_SIDE_EFFECTS = "doesPostmasterPullHaveSideEffects";
  @SerializedName(SERIALIZED_NAME_DOES_POSTMASTER_PULL_HAVE_SIDE_EFFECTS)
  private Boolean doesPostmasterPullHaveSideEffects;

  public static final String SERIALIZED_NAME_EMBLEM_OBJECTIVE_HASH = "emblemObjectiveHash";
  @SerializedName(SERIALIZED_NAME_EMBLEM_OBJECTIVE_HASH)
  private Integer emblemObjectiveHash;

  public static final String SERIALIZED_NAME_EQUIPPABLE = "equippable";
  @SerializedName(SERIALIZED_NAME_EQUIPPABLE)
  private Boolean equippable;

  public static final String SERIALIZED_NAME_EQUIPPING_BLOCK = "equippingBlock";
  @SerializedName(SERIALIZED_NAME_EQUIPPING_BLOCK)
  private DestinyDefinitionsDestinyEquippingBlockDefinition equippingBlock;

  public static final String SERIALIZED_NAME_FLAVOR_TEXT = "flavorText";
  @SerializedName(SERIALIZED_NAME_FLAVOR_TEXT)
  private String flavorText;

  public static final String SERIALIZED_NAME_GEARSET = "gearset";
  @SerializedName(SERIALIZED_NAME_GEARSET)
  private DestinyDefinitionsDestinyItemGearsetBlockDefinition gearset;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_ICON_WATERMARK = "iconWatermark";
  @SerializedName(SERIALIZED_NAME_ICON_WATERMARK)
  private String iconWatermark;

  public static final String SERIALIZED_NAME_ICON_WATERMARK_SHELVED = "iconWatermarkShelved";
  @SerializedName(SERIALIZED_NAME_ICON_WATERMARK_SHELVED)
  private String iconWatermarkShelved;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_INVENTORY = "inventory";
  @SerializedName(SERIALIZED_NAME_INVENTORY)
  private DestinyDefinitionsDestinyItemInventoryBlockDefinition inventory;

  public static final String SERIALIZED_NAME_INVESTMENT_STATS = "investmentStats";
  @SerializedName(SERIALIZED_NAME_INVESTMENT_STATS)
  private List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_WRAPPER = "isWrapper";
  @SerializedName(SERIALIZED_NAME_IS_WRAPPER)
  private Boolean isWrapper;

  public static final String SERIALIZED_NAME_ITEM_CATEGORY_HASHES = "itemCategoryHashes";
  @SerializedName(SERIALIZED_NAME_ITEM_CATEGORY_HASHES)
  private List<Integer> itemCategoryHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_ITEM_SUB_TYPE = "itemSubType";
  @SerializedName(SERIALIZED_NAME_ITEM_SUB_TYPE)
  private Integer itemSubType;

  public static final String SERIALIZED_NAME_ITEM_TYPE = "itemType";
  @SerializedName(SERIALIZED_NAME_ITEM_TYPE)
  private Integer itemType;

  public static final String SERIALIZED_NAME_ITEM_TYPE_AND_TIER_DISPLAY_NAME = "itemTypeAndTierDisplayName";
  @SerializedName(SERIALIZED_NAME_ITEM_TYPE_AND_TIER_DISPLAY_NAME)
  private String itemTypeAndTierDisplayName;

  public static final String SERIALIZED_NAME_ITEM_TYPE_DISPLAY_NAME = "itemTypeDisplayName";
  @SerializedName(SERIALIZED_NAME_ITEM_TYPE_DISPLAY_NAME)
  private String itemTypeDisplayName;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<LinksHyperlinkReference> links = new ArrayList<>();

  public static final String SERIALIZED_NAME_LORE_HASH = "loreHash";
  @SerializedName(SERIALIZED_NAME_LORE_HASH)
  private Integer loreHash;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private DestinyDefinitionsDestinyItemMetricBlockDefinition metrics;

  public static final String SERIALIZED_NAME_NON_TRANSFERRABLE = "nonTransferrable";
  @SerializedName(SERIALIZED_NAME_NON_TRANSFERRABLE)
  private Boolean nonTransferrable;

  public static final String SERIALIZED_NAME_OBJECTIVES = "objectives";
  @SerializedName(SERIALIZED_NAME_OBJECTIVES)
  private DestinyDefinitionsDestinyItemObjectiveBlockDefinition objectives;

  public static final String SERIALIZED_NAME_PERKS = "perks";
  @SerializedName(SERIALIZED_NAME_PERKS)
  private List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks = new ArrayList<>();

  public static final String SERIALIZED_NAME_PLUG = "plug";
  @SerializedName(SERIALIZED_NAME_PLUG)
  private DestinyDefinitionsItemsDestinyItemPlugDefinition plug;

  public static final String SERIALIZED_NAME_PREVIEW = "preview";
  @SerializedName(SERIALIZED_NAME_PREVIEW)
  private DestinyDefinitionsDestinyItemPreviewBlockDefinition preview;

  public static final String SERIALIZED_NAME_QUALITY = "quality";
  @SerializedName(SERIALIZED_NAME_QUALITY)
  private DestinyDefinitionsDestinyItemQualityBlockDefinition quality;

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public static final String SERIALIZED_NAME_SACK = "sack";
  @SerializedName(SERIALIZED_NAME_SACK)
  private DestinyDefinitionsDestinyItemSackBlockDefinition sack;

  public static final String SERIALIZED_NAME_SCREENSHOT = "screenshot";
  @SerializedName(SERIALIZED_NAME_SCREENSHOT)
  private String screenshot;

  public static final String SERIALIZED_NAME_SEASON_HASH = "seasonHash";
  @SerializedName(SERIALIZED_NAME_SEASON_HASH)
  private Integer seasonHash;

  public static final String SERIALIZED_NAME_SECONDARY_ICON = "secondaryIcon";
  @SerializedName(SERIALIZED_NAME_SECONDARY_ICON)
  private String secondaryIcon;

  public static final String SERIALIZED_NAME_SECONDARY_OVERLAY = "secondaryOverlay";
  @SerializedName(SERIALIZED_NAME_SECONDARY_OVERLAY)
  private String secondaryOverlay;

  public static final String SERIALIZED_NAME_SECONDARY_SPECIAL = "secondarySpecial";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SPECIAL)
  private String secondarySpecial;

  public static final String SERIALIZED_NAME_SET_DATA = "setData";
  @SerializedName(SERIALIZED_NAME_SET_DATA)
  private DestinyDefinitionsDestinyItemSetBlockDefinition setData;

  public static final String SERIALIZED_NAME_SOCKETS = "sockets";
  @SerializedName(SERIALIZED_NAME_SOCKETS)
  private DestinyDefinitionsDestinyItemSocketBlockDefinition sockets;

  public static final String SERIALIZED_NAME_SOURCE_DATA = "sourceData";
  @SerializedName(SERIALIZED_NAME_SOURCE_DATA)
  private DestinyDefinitionsDestinyItemSourceBlockDefinition sourceData;

  public static final String SERIALIZED_NAME_SPECIAL_ITEM_TYPE = "specialItemType";
  @SerializedName(SERIALIZED_NAME_SPECIAL_ITEM_TYPE)
  private Integer specialItemType;

  public static final String SERIALIZED_NAME_STATS = "stats";
  @SerializedName(SERIALIZED_NAME_STATS)
  private DestinyDefinitionsDestinyItemStatBlockDefinition stats;

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private DestinyDefinitionsDestinyItemSummaryBlockDefinition summary;

  public static final String SERIALIZED_NAME_SUMMARY_ITEM_HASH = "summaryItemHash";
  @SerializedName(SERIALIZED_NAME_SUMMARY_ITEM_HASH)
  private Integer summaryItemHash;

  public static final String SERIALIZED_NAME_TALENT_GRID = "talentGrid";
  @SerializedName(SERIALIZED_NAME_TALENT_GRID)
  private DestinyDefinitionsDestinyItemTalentGridBlockDefinition talentGrid;

  public static final String SERIALIZED_NAME_TOOLTIP_NOTIFICATIONS = "tooltipNotifications";
  @SerializedName(SERIALIZED_NAME_TOOLTIP_NOTIFICATIONS)
  private List<DestinyDefinitionsDestinyItemTooltipNotification> tooltipNotifications = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOOLTIP_STYLE = "tooltipStyle";
  @SerializedName(SERIALIZED_NAME_TOOLTIP_STYLE)
  private String tooltipStyle;

  public static final String SERIALIZED_NAME_TRAIT_HASHES = "traitHashes";
  @SerializedName(SERIALIZED_NAME_TRAIT_HASHES)
  private List<Integer> traitHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRAIT_IDS = "traitIds";
  @SerializedName(SERIALIZED_NAME_TRAIT_IDS)
  private List<String> traitIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSLATION_BLOCK = "translationBlock";
  @SerializedName(SERIALIZED_NAME_TRANSLATION_BLOCK)
  private DestinyDefinitionsDestinyItemTranslationBlockDefinition translationBlock;

  public static final String SERIALIZED_NAME_UI_ITEM_DISPLAY_STYLE = "uiItemDisplayStyle";
  @SerializedName(SERIALIZED_NAME_UI_ITEM_DISPLAY_STYLE)
  private String uiItemDisplayStyle;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private DestinyDefinitionsDestinyItemValueBlockDefinition value;

  public DestinyDefinitionsDestinyInventoryItemDefinition() {
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition action(DestinyDefinitionsDestinyItemActionBlockDefinition action) {
    this.action = action;
    return this;
  }

  /**
   * If the item can be \&quot;used\&quot;, this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is \&quot;dismantle\&quot;. Shocker)
   * @return action
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemActionBlockDefinition getAction() {
    return action;
  }

  public void setAction(DestinyDefinitionsDestinyItemActionBlockDefinition action) {
    this.action = action;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition allowActions(Boolean allowActions) {
    this.allowActions = allowActions;
    return this;
  }

  /**
   * BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
   * @return allowActions
   */
  @javax.annotation.Nullable
  public Boolean getAllowActions() {
    return allowActions;
  }

  public void setAllowActions(Boolean allowActions) {
    this.allowActions = allowActions;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition animations(List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations) {
    this.animations = animations;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addAnimationsItem(DestinyDefinitionsAnimationsDestinyAnimationReference animationsItem) {
    if (this.animations == null) {
      this.animations = new ArrayList<>();
    }
    this.animations.add(animationsItem);
    return this;
  }

  /**
   * If any animations were extracted from game content for this item, these will be the definitions of those animations.
   * @return animations
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsAnimationsDestinyAnimationReference> getAnimations() {
    return animations;
  }

  public void setAnimations(List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations) {
    this.animations = animations;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition backgroundColor(DestinyMiscDestinyColor backgroundColor) {
    this.backgroundColor = backgroundColor;
    return this;
  }

  /**
   * Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the \&quot;friends\&quot; view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.
   * @return backgroundColor
   */
  @javax.annotation.Nullable
  public DestinyMiscDestinyColor getBackgroundColor() {
    return backgroundColor;
  }

  public void setBackgroundColor(DestinyMiscDestinyColor backgroundColor) {
    this.backgroundColor = backgroundColor;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition breakerType(Integer breakerType) {
    this.breakerType = breakerType;
    return this;
  }

  /**
   * Some weapons and plugs can have a \&quot;Breaker Type\&quot;: a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.
   * @return breakerType
   */
  @javax.annotation.Nullable
  public Integer getBreakerType() {
    return breakerType;
  }

  public void setBreakerType(Integer breakerType) {
    this.breakerType = breakerType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition breakerTypeHash(Integer breakerTypeHash) {
    this.breakerTypeHash = breakerTypeHash;
    return this;
  }

  /**
   * Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what&#39;s cleanest for your code.
   * @return breakerTypeHash
   */
  @javax.annotation.Nullable
  public Integer getBreakerTypeHash() {
    return breakerTypeHash;
  }

  public void setBreakerTypeHash(Integer breakerTypeHash) {
    this.breakerTypeHash = breakerTypeHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition classType(Integer classType) {
    this.classType = classType;
    return this;
  }

  /**
   * We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class&#39; enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.
   * @return classType
   */
  @javax.annotation.Nullable
  public Integer getClassType() {
    return classType;
  }

  public void setClassType(Integer classType) {
    this.classType = classType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition collectibleHash(Integer collectibleHash) {
    this.collectibleHash = collectibleHash;
    return this;
  }

  /**
   * If this item has a collectible related to it, this is the hash identifier of that collectible entry.
   * @return collectibleHash
   */
  @javax.annotation.Nullable
  public Integer getCollectibleHash() {
    return collectibleHash;
  }

  public void setCollectibleHash(Integer collectibleHash) {
    this.collectibleHash = collectibleHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition crafting(DestinyDefinitionsDestinyItemCraftingBlockDefinition crafting) {
    this.crafting = crafting;
    return this;
  }

  /**
   * Recipe items will have relevant crafting information available here.
   * @return crafting
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemCraftingBlockDefinition getCrafting() {
    return crafting;
  }

  public void setCrafting(DestinyDefinitionsDestinyItemCraftingBlockDefinition crafting) {
    this.crafting = crafting;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition damageTypeHashes(List<Integer> damageTypeHashes) {
    this.damageTypeHashes = damageTypeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addDamageTypeHashesItem(Integer damageTypeHashesItem) {
    if (this.damageTypeHashes == null) {
      this.damageTypeHashes = new ArrayList<>();
    }
    this.damageTypeHashes.add(damageTypeHashesItem);
    return this;
  }

  /**
   * Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
   * @return damageTypeHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getDamageTypeHashes() {
    return damageTypeHashes;
  }

  public void setDamageTypeHashes(List<Integer> damageTypeHashes) {
    this.damageTypeHashes = damageTypeHashes;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition damageTypes(List<Integer> damageTypes) {
    this.damageTypes = damageTypes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addDamageTypesItem(Integer damageTypesItem) {
    if (this.damageTypes == null) {
      this.damageTypes = new ArrayList<>();
    }
    this.damageTypes.add(damageTypesItem);
    return this;
  }

  /**
   * This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets
   * @return damageTypes
   */
  @javax.annotation.Nullable
  public List<Integer> getDamageTypes() {
    return damageTypes;
  }

  public void setDamageTypes(List<Integer> damageTypes) {
    this.damageTypes = damageTypes;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition defaultDamageType(Integer defaultDamageType) {
    this.defaultDamageType = defaultDamageType;
    return this;
  }

  /**
   * If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it&#39;s surprisingly cumbersome to figure this out. I hope you&#39;re happy.
   * @return defaultDamageType
   */
  @javax.annotation.Nullable
  public Integer getDefaultDamageType() {
    return defaultDamageType;
  }

  public void setDefaultDamageType(Integer defaultDamageType) {
    this.defaultDamageType = defaultDamageType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition defaultDamageTypeHash(Integer defaultDamageTypeHash) {
    this.defaultDamageTypeHash = defaultDamageTypeHash;
    return this;
  }

  /**
   * Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they&#39;re very convenient.
   * @return defaultDamageTypeHash
   */
  @javax.annotation.Nullable
  public Integer getDefaultDamageTypeHash() {
    return defaultDamageTypeHash;
  }

  public void setDefaultDamageTypeHash(Integer defaultDamageTypeHash) {
    this.defaultDamageTypeHash = defaultDamageTypeHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * Get displayProperties
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition displaySource(String displaySource) {
    this.displaySource = displaySource;
    return this;
  }

  /**
   * In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it&#39;s instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
   * @return displaySource
   */
  @javax.annotation.Nullable
  public String getDisplaySource() {
    return displaySource;
  }

  public void setDisplaySource(String displaySource) {
    this.displaySource = displaySource;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition doesPostmasterPullHaveSideEffects(Boolean doesPostmasterPullHaveSideEffects) {
    this.doesPostmasterPullHaveSideEffects = doesPostmasterPullHaveSideEffects;
    return this;
  }

  /**
   * The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \&quot;destructive\&quot; action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you&#39;ll end up receiving an error.
   * @return doesPostmasterPullHaveSideEffects
   */
  @javax.annotation.Nullable
  public Boolean getDoesPostmasterPullHaveSideEffects() {
    return doesPostmasterPullHaveSideEffects;
  }

  public void setDoesPostmasterPullHaveSideEffects(Boolean doesPostmasterPullHaveSideEffects) {
    this.doesPostmasterPullHaveSideEffects = doesPostmasterPullHaveSideEffects;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition emblemObjectiveHash(Integer emblemObjectiveHash) {
    this.emblemObjectiveHash = emblemObjectiveHash;
    return this;
  }

  /**
   * If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \&quot;art channel\&quot;. When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they&#39;re being used for and how they are wired up, but for now here&#39;s the raw data.
   * @return emblemObjectiveHash
   */
  @javax.annotation.Nullable
  public Integer getEmblemObjectiveHash() {
    return emblemObjectiveHash;
  }

  public void setEmblemObjectiveHash(Integer emblemObjectiveHash) {
    this.emblemObjectiveHash = emblemObjectiveHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition equippable(Boolean equippable) {
    this.equippable = equippable;
    return this;
  }

  /**
   * If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.
   * @return equippable
   */
  @javax.annotation.Nullable
  public Boolean getEquippable() {
    return equippable;
  }

  public void setEquippable(Boolean equippable) {
    this.equippable = equippable;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition equippingBlock(DestinyDefinitionsDestinyEquippingBlockDefinition equippingBlock) {
    this.equippingBlock = equippingBlock;
    return this;
  }

  /**
   * If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.
   * @return equippingBlock
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyEquippingBlockDefinition getEquippingBlock() {
    return equippingBlock;
  }

  public void setEquippingBlock(DestinyDefinitionsDestinyEquippingBlockDefinition equippingBlock) {
    this.equippingBlock = equippingBlock;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition flavorText(String flavorText) {
    this.flavorText = flavorText;
    return this;
  }

  /**
   * Get flavorText
   * @return flavorText
   */
  @javax.annotation.Nullable
  public String getFlavorText() {
    return flavorText;
  }

  public void setFlavorText(String flavorText) {
    this.flavorText = flavorText;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition gearset(DestinyDefinitionsDestinyItemGearsetBlockDefinition gearset) {
    this.gearset = gearset;
    return this;
  }

  /**
   * If this item has related items in a \&quot;Gear Set\&quot;, this will be non-null and the relationships defined herein.
   * @return gearset
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemGearsetBlockDefinition getGearset() {
    return gearset;
  }

  public void setGearset(DestinyDefinitionsDestinyItemGearsetBlockDefinition gearset) {
    this.gearset = gearset;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition iconWatermark(String iconWatermark) {
    this.iconWatermark = iconWatermark;
    return this;
  }

  /**
   * If available, this is the original &#39;active&#39; release watermark overlay for the icon. If the item has different versions, this can be overridden by the &#39;display version watermark icon&#39; from the &#39;quality&#39; block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.
   * @return iconWatermark
   */
  @javax.annotation.Nullable
  public String getIconWatermark() {
    return iconWatermark;
  }

  public void setIconWatermark(String iconWatermark) {
    this.iconWatermark = iconWatermark;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition iconWatermarkShelved(String iconWatermarkShelved) {
    this.iconWatermarkShelved = iconWatermarkShelved;
    return this;
  }

  /**
   * If available, this is the &#39;shelved&#39; release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as &#39;shelved&#39;, and should be shown with this &#39;shelved&#39; watermark overlay.
   * @return iconWatermarkShelved
   */
  @javax.annotation.Nullable
  public String getIconWatermarkShelved() {
    return iconWatermarkShelved;
  }

  public void setIconWatermarkShelved(String iconWatermarkShelved) {
    this.iconWatermarkShelved = iconWatermarkShelved;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition inventory(DestinyDefinitionsDestinyItemInventoryBlockDefinition inventory) {
    this.inventory = inventory;
    return this;
  }

  /**
   * If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
   * @return inventory
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemInventoryBlockDefinition getInventory() {
    return inventory;
  }

  public void setInventory(DestinyDefinitionsDestinyItemInventoryBlockDefinition inventory) {
    this.inventory = inventory;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition investmentStats(List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats) {
    this.investmentStats = investmentStats;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addInvestmentStatsItem(DestinyDefinitionsDestinyItemInvestmentStatDefinition investmentStatsItem) {
    if (this.investmentStats == null) {
      this.investmentStats = new ArrayList<>();
    }
    this.investmentStats.add(investmentStatsItem);
    return this;
  }

  /**
   * If the item has stats, this block will be defined. It has the \&quot;raw\&quot; investment stats for the item. These investment stats don&#39;t take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
   * @return investmentStats
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> getInvestmentStats() {
    return investmentStats;
  }

  public void setInvestmentStats(List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats) {
    this.investmentStats = investmentStats;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition isWrapper(Boolean isWrapper) {
    this.isWrapper = isWrapper;
    return this;
  }

  /**
   * If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \&quot;wrapped\&quot; by one of these items so that we can safely provide refund capabilities before the item is \&quot;unwrapped\&quot;.
   * @return isWrapper
   */
  @javax.annotation.Nullable
  public Boolean getIsWrapper() {
    return isWrapper;
  }

  public void setIsWrapper(Boolean isWrapper) {
    this.isWrapper = isWrapper;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition itemCategoryHashes(List<Integer> itemCategoryHashes) {
    this.itemCategoryHashes = itemCategoryHashes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addItemCategoryHashesItem(Integer itemCategoryHashesItem) {
    if (this.itemCategoryHashes == null) {
      this.itemCategoryHashes = new ArrayList<>();
    }
    this.itemCategoryHashes.add(itemCategoryHashesItem);
    return this;
  }

  /**
   * BNet attempts to make a more formal definition of item \&quot;Categories\&quot;, as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it&#39;s a \&quot;Weapon\&quot;, that it&#39;s an \&quot;Auto Rifle\&quot;, etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
   * @return itemCategoryHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getItemCategoryHashes() {
    return itemCategoryHashes;
  }

  public void setItemCategoryHashes(List<Integer> itemCategoryHashes) {
    this.itemCategoryHashes = itemCategoryHashes;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition itemSubType(Integer itemSubType) {
    this.itemSubType = itemSubType;
    return this;
  }

  /**
   * A value indicating the \&quot;sub-type\&quot; of the item. For instance, where an item might have an itemType value \&quot;Weapon\&quot;, this will be something more specific like \&quot;Auto Rifle\&quot;.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return itemSubType
   */
  @javax.annotation.Nullable
  public Integer getItemSubType() {
    return itemSubType;
  }

  public void setItemSubType(Integer itemSubType) {
    this.itemSubType = itemSubType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition itemType(Integer itemType) {
    this.itemType = itemType;
    return this;
  }

  /**
   * A value indicating the \&quot;base\&quot; the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \&quot;Type\&quot;. Still, it&#39;s handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return itemType
   */
  @javax.annotation.Nullable
  public Integer getItemType() {
    return itemType;
  }

  public void setItemType(Integer itemType) {
    this.itemType = itemType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition itemTypeAndTierDisplayName(String itemTypeAndTierDisplayName) {
    this.itemTypeAndTierDisplayName = itemTypeAndTierDisplayName;
    return this;
  }

  /**
   * It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I&#39;m just going to go ahead and start pre-creating these for items.
   * @return itemTypeAndTierDisplayName
   */
  @javax.annotation.Nullable
  public String getItemTypeAndTierDisplayName() {
    return itemTypeAndTierDisplayName;
  }

  public void setItemTypeAndTierDisplayName(String itemTypeAndTierDisplayName) {
    this.itemTypeAndTierDisplayName = itemTypeAndTierDisplayName;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition itemTypeDisplayName(String itemTypeDisplayName) {
    this.itemTypeDisplayName = itemTypeDisplayName;
    return this;
  }

  /**
   * The localized title/name of the item&#39;s type. This can be whatever the designers want, and has no guarantee of consistency between items.
   * @return itemTypeDisplayName
   */
  @javax.annotation.Nullable
  public String getItemTypeDisplayName() {
    return itemTypeDisplayName;
  }

  public void setItemTypeDisplayName(String itemTypeDisplayName) {
    this.itemTypeDisplayName = itemTypeDisplayName;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition links(List<LinksHyperlinkReference> links) {
    this.links = links;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addLinksItem(LinksHyperlinkReference linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

  /**
   * If we added any help or informational URLs about this item, these will be those links.
   * @return links
   */
  @javax.annotation.Nullable
  public List<LinksHyperlinkReference> getLinks() {
    return links;
  }

  public void setLinks(List<LinksHyperlinkReference> links) {
    this.links = links;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition loreHash(Integer loreHash) {
    this.loreHash = loreHash;
    return this;
  }

  /**
   * If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
   * @return loreHash
   */
  @javax.annotation.Nullable
  public Integer getLoreHash() {
    return loreHash;
  }

  public void setLoreHash(Integer loreHash) {
    this.loreHash = loreHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition metrics(DestinyDefinitionsDestinyItemMetricBlockDefinition metrics) {
    this.metrics = metrics;
    return this;
  }

  /**
   * If this item has available metrics to be shown, this block will be non-null have the appropriate hashes defined.
   * @return metrics
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemMetricBlockDefinition getMetrics() {
    return metrics;
  }

  public void setMetrics(DestinyDefinitionsDestinyItemMetricBlockDefinition metrics) {
    this.metrics = metrics;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition nonTransferrable(Boolean nonTransferrable) {
    this.nonTransferrable = nonTransferrable;
    return this;
  }

  /**
   * The intrinsic transferability of an item.  I hate that this boolean is negative - but there&#39;s a reason.  Just because an item is intrinsically transferrable doesn&#39;t mean that it can be transferred, and we don&#39;t want to imply that this is the only source of that transferability.
   * @return nonTransferrable
   */
  @javax.annotation.Nullable
  public Boolean getNonTransferrable() {
    return nonTransferrable;
  }

  public void setNonTransferrable(Boolean nonTransferrable) {
    this.nonTransferrable = nonTransferrable;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition objectives(DestinyDefinitionsDestinyItemObjectiveBlockDefinition objectives) {
    this.objectives = objectives;
    return this;
  }

  /**
   * If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.
   * @return objectives
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemObjectiveBlockDefinition getObjectives() {
    return objectives;
  }

  public void setObjectives(DestinyDefinitionsDestinyItemObjectiveBlockDefinition objectives) {
    this.objectives = objectives;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition perks(List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks) {
    this.perks = perks;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addPerksItem(DestinyDefinitionsDestinyItemPerkEntryDefinition perksItem) {
    if (this.perks == null) {
      this.perks = new ArrayList<>();
    }
    this.perks.add(perksItem);
    return this;
  }

  /**
   * If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
   * @return perks
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemPerkEntryDefinition> getPerks() {
    return perks;
  }

  public void setPerks(List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks) {
    this.perks = perks;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition plug(DestinyDefinitionsItemsDestinyItemPlugDefinition plug) {
    this.plug = plug;
    return this;
  }

  /**
   * If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.
   * @return plug
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsItemsDestinyItemPlugDefinition getPlug() {
    return plug;
  }

  public void setPlug(DestinyDefinitionsItemsDestinyItemPlugDefinition plug) {
    this.plug = plug;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition preview(DestinyDefinitionsDestinyItemPreviewBlockDefinition preview) {
    this.preview = preview;
    return this;
  }

  /**
   * If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.
   * @return preview
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemPreviewBlockDefinition getPreview() {
    return preview;
  }

  public void setPreview(DestinyDefinitionsDestinyItemPreviewBlockDefinition preview) {
    this.preview = preview;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition quality(DestinyDefinitionsDestinyItemQualityBlockDefinition quality) {
    this.quality = quality;
    return this;
  }

  /**
   * If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, \&quot;quality\&quot;, and infusion) data. See the block for more details, there&#39;s often less upfront information in D2 so you&#39;ll want to be aware of how you use quality and item level on the definition level now.
   * @return quality
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemQualityBlockDefinition getQuality() {
    return quality;
  }

  public void setQuality(DestinyDefinitionsDestinyItemQualityBlockDefinition quality) {
    this.quality = quality;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition sack(DestinyDefinitionsDestinyItemSackBlockDefinition sack) {
    this.sack = sack;
    return this;
  }

  /**
   * If this item is a \&quot;reward sack\&quot; that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.
   * @return sack
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemSackBlockDefinition getSack() {
    return sack;
  }

  public void setSack(DestinyDefinitionsDestinyItemSackBlockDefinition sack) {
    this.sack = sack;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition screenshot(String screenshot) {
    this.screenshot = screenshot;
    return this;
  }

  /**
   * If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
   * @return screenshot
   */
  @javax.annotation.Nullable
  public String getScreenshot() {
    return screenshot;
  }

  public void setScreenshot(String screenshot) {
    this.screenshot = screenshot;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition seasonHash(Integer seasonHash) {
    this.seasonHash = seasonHash;
    return this;
  }

  /**
   * If this item is related directly to a Season of Destiny, this is the hash identifier for that season.
   * @return seasonHash
   */
  @javax.annotation.Nullable
  public Integer getSeasonHash() {
    return seasonHash;
  }

  public void setSeasonHash(Integer seasonHash) {
    this.seasonHash = seasonHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition secondaryIcon(String secondaryIcon) {
    this.secondaryIcon = secondaryIcon;
    return this;
  }

  /**
   * A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
   * @return secondaryIcon
   */
  @javax.annotation.Nullable
  public String getSecondaryIcon() {
    return secondaryIcon;
  }

  public void setSecondaryIcon(String secondaryIcon) {
    this.secondaryIcon = secondaryIcon;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition secondaryOverlay(String secondaryOverlay) {
    this.secondaryOverlay = secondaryOverlay;
    return this;
  }

  /**
   * Pulled from the secondary icon, this is the \&quot;secondary background\&quot; of the secondary icon. Confusing? Sure, that&#39;s why I call it \&quot;overlay\&quot; here: because as far as it&#39;s been used thus far, it has been for an optional overlay image. We&#39;ll see if that holds up, but at least for now it explains what this image is a bit better.
   * @return secondaryOverlay
   */
  @javax.annotation.Nullable
  public String getSecondaryOverlay() {
    return secondaryOverlay;
  }

  public void setSecondaryOverlay(String secondaryOverlay) {
    this.secondaryOverlay = secondaryOverlay;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition secondarySpecial(String secondarySpecial) {
    this.secondarySpecial = secondarySpecial;
    return this;
  }

  /**
   * Pulled from the Secondary Icon, this is the \&quot;special\&quot; background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
   * @return secondarySpecial
   */
  @javax.annotation.Nullable
  public String getSecondarySpecial() {
    return secondarySpecial;
  }

  public void setSecondarySpecial(String secondarySpecial) {
    this.secondarySpecial = secondarySpecial;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition setData(DestinyDefinitionsDestinyItemSetBlockDefinition setData) {
    this.setData = setData;
    return this;
  }

  /**
   * If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn&#39;t clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.
   * @return setData
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemSetBlockDefinition getSetData() {
    return setData;
  }

  public void setSetData(DestinyDefinitionsDestinyItemSetBlockDefinition setData) {
    this.setData = setData;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition sockets(DestinyDefinitionsDestinyItemSocketBlockDefinition sockets) {
    this.sockets = sockets;
    return this;
  }

  /**
   * If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.
   * @return sockets
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemSocketBlockDefinition getSockets() {
    return sockets;
  }

  public void setSockets(DestinyDefinitionsDestinyItemSocketBlockDefinition sockets) {
    this.sockets = sockets;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition sourceData(DestinyDefinitionsDestinyItemSourceBlockDefinition sourceData) {
    this.sourceData = sourceData;
    return this;
  }

  /**
   * If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn&#39;t have time for, and I&#39;m hoping to get back to at some point in the future.
   * @return sourceData
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemSourceBlockDefinition getSourceData() {
    return sourceData;
  }

  public void setSourceData(DestinyDefinitionsDestinyItemSourceBlockDefinition sourceData) {
    this.sourceData = sourceData;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition specialItemType(Integer specialItemType) {
    this.specialItemType = specialItemType;
    return this;
  }

  /**
   * In Destiny 1, we identified some items as having particular categories that we&#39;d like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return specialItemType
   */
  @javax.annotation.Nullable
  public Integer getSpecialItemType() {
    return specialItemType;
  }

  public void setSpecialItemType(Integer specialItemType) {
    this.specialItemType = specialItemType;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition stats(DestinyDefinitionsDestinyItemStatBlockDefinition stats) {
    this.stats = stats;
    return this;
  }

  /**
   * If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.
   * @return stats
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemStatBlockDefinition getStats() {
    return stats;
  }

  public void setStats(DestinyDefinitionsDestinyItemStatBlockDefinition stats) {
    this.stats = stats;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition summary(DestinyDefinitionsDestinyItemSummaryBlockDefinition summary) {
    this.summary = summary;
    return this;
  }

  /**
   * Summary data about the item.
   * @return summary
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemSummaryBlockDefinition getSummary() {
    return summary;
  }

  public void setSummary(DestinyDefinitionsDestinyItemSummaryBlockDefinition summary) {
    this.summary = summary;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition summaryItemHash(Integer summaryItemHash) {
    this.summaryItemHash = summaryItemHash;
    return this;
  }

  /**
   * There are times when the game will show you a \&quot;summary/vague\&quot; version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
   * @return summaryItemHash
   */
  @javax.annotation.Nullable
  public Integer getSummaryItemHash() {
    return summaryItemHash;
  }

  public void setSummaryItemHash(Integer summaryItemHash) {
    this.summaryItemHash = summaryItemHash;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition talentGrid(DestinyDefinitionsDestinyItemTalentGridBlockDefinition talentGrid) {
    this.talentGrid = talentGrid;
    return this;
  }

  /**
   * If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/\&quot;Build\&quot; items.
   * @return talentGrid
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemTalentGridBlockDefinition getTalentGrid() {
    return talentGrid;
  }

  public void setTalentGrid(DestinyDefinitionsDestinyItemTalentGridBlockDefinition talentGrid) {
    this.talentGrid = talentGrid;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition tooltipNotifications(List<DestinyDefinitionsDestinyItemTooltipNotification> tooltipNotifications) {
    this.tooltipNotifications = tooltipNotifications;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addTooltipNotificationsItem(DestinyDefinitionsDestinyItemTooltipNotification tooltipNotificationsItem) {
    if (this.tooltipNotifications == null) {
      this.tooltipNotifications = new ArrayList<>();
    }
    this.tooltipNotifications.add(tooltipNotificationsItem);
    return this;
  }

  /**
   * Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.
   * @return tooltipNotifications
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyItemTooltipNotification> getTooltipNotifications() {
    return tooltipNotifications;
  }

  public void setTooltipNotifications(List<DestinyDefinitionsDestinyItemTooltipNotification> tooltipNotifications) {
    this.tooltipNotifications = tooltipNotifications;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition tooltipStyle(String tooltipStyle) {
    this.tooltipStyle = tooltipStyle;
    return this;
  }

  /**
   * An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it&#39;ll be up to you to interpret and display your UI differently according to these styles (or ignore it).
   * @return tooltipStyle
   */
  @javax.annotation.Nullable
  public String getTooltipStyle() {
    return tooltipStyle;
  }

  public void setTooltipStyle(String tooltipStyle) {
    this.tooltipStyle = tooltipStyle;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition traitHashes(List<Integer> traitHashes) {
    this.traitHashes = traitHashes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addTraitHashesItem(Integer traitHashesItem) {
    if (this.traitHashes == null) {
      this.traitHashes = new ArrayList<>();
    }
    this.traitHashes.add(traitHashesItem);
    return this;
  }

  /**
   * These are the corresponding trait definition hashes for the entries in traitIds.
   * @return traitHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getTraitHashes() {
    return traitHashes;
  }

  public void setTraitHashes(List<Integer> traitHashes) {
    this.traitHashes = traitHashes;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition traitIds(List<String> traitIds) {
    this.traitIds = traitIds;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addTraitIdsItem(String traitIdsItem) {
    if (this.traitIds == null) {
      this.traitIds = new ArrayList<>();
    }
    this.traitIds.add(traitIdsItem);
    return this;
  }

  /**
   * Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don&#39;t map to any content, but should still be useful.
   * @return traitIds
   */
  @javax.annotation.Nullable
  public List<String> getTraitIds() {
    return traitIds;
  }

  public void setTraitIds(List<String> traitIds) {
    this.traitIds = traitIds;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition translationBlock(DestinyDefinitionsDestinyItemTranslationBlockDefinition translationBlock) {
    this.translationBlock = translationBlock;
    return this;
  }

  /**
   * If this item can be rendered, this block will be non-null and will be populated with rendering information.
   * @return translationBlock
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemTranslationBlockDefinition getTranslationBlock() {
    return translationBlock;
  }

  public void setTranslationBlock(DestinyDefinitionsDestinyItemTranslationBlockDefinition translationBlock) {
    this.translationBlock = translationBlock;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition uiItemDisplayStyle(String uiItemDisplayStyle) {
    this.uiItemDisplayStyle = uiItemDisplayStyle;
    return this;
  }

  /**
   * A string identifier that the game&#39;s UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don&#39;t have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!
   * @return uiItemDisplayStyle
   */
  @javax.annotation.Nullable
  public String getUiItemDisplayStyle() {
    return uiItemDisplayStyle;
  }

  public void setUiItemDisplayStyle(String uiItemDisplayStyle) {
    this.uiItemDisplayStyle = uiItemDisplayStyle;
  }


  public DestinyDefinitionsDestinyInventoryItemDefinition value(DestinyDefinitionsDestinyItemValueBlockDefinition value) {
    this.value = value;
    return this;
  }

  /**
   * The conceptual \&quot;Value\&quot; of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.
   * @return value
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyItemValueBlockDefinition getValue() {
    return value;
  }

  public void setValue(DestinyDefinitionsDestinyItemValueBlockDefinition value) {
    this.value = value;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyInventoryItemDefinition destinyDefinitionsDestinyInventoryItemDefinition = (DestinyDefinitionsDestinyInventoryItemDefinition) o;
    return Objects.equals(this.action, destinyDefinitionsDestinyInventoryItemDefinition.action) &&
        Objects.equals(this.allowActions, destinyDefinitionsDestinyInventoryItemDefinition.allowActions) &&
        Objects.equals(this.animations, destinyDefinitionsDestinyInventoryItemDefinition.animations) &&
        Objects.equals(this.backgroundColor, destinyDefinitionsDestinyInventoryItemDefinition.backgroundColor) &&
        Objects.equals(this.breakerType, destinyDefinitionsDestinyInventoryItemDefinition.breakerType) &&
        Objects.equals(this.breakerTypeHash, destinyDefinitionsDestinyInventoryItemDefinition.breakerTypeHash) &&
        Objects.equals(this.classType, destinyDefinitionsDestinyInventoryItemDefinition.classType) &&
        Objects.equals(this.collectibleHash, destinyDefinitionsDestinyInventoryItemDefinition.collectibleHash) &&
        Objects.equals(this.crafting, destinyDefinitionsDestinyInventoryItemDefinition.crafting) &&
        Objects.equals(this.damageTypeHashes, destinyDefinitionsDestinyInventoryItemDefinition.damageTypeHashes) &&
        Objects.equals(this.damageTypes, destinyDefinitionsDestinyInventoryItemDefinition.damageTypes) &&
        Objects.equals(this.defaultDamageType, destinyDefinitionsDestinyInventoryItemDefinition.defaultDamageType) &&
        Objects.equals(this.defaultDamageTypeHash, destinyDefinitionsDestinyInventoryItemDefinition.defaultDamageTypeHash) &&
        Objects.equals(this.displayProperties, destinyDefinitionsDestinyInventoryItemDefinition.displayProperties) &&
        Objects.equals(this.displaySource, destinyDefinitionsDestinyInventoryItemDefinition.displaySource) &&
        Objects.equals(this.doesPostmasterPullHaveSideEffects, destinyDefinitionsDestinyInventoryItemDefinition.doesPostmasterPullHaveSideEffects) &&
        Objects.equals(this.emblemObjectiveHash, destinyDefinitionsDestinyInventoryItemDefinition.emblemObjectiveHash) &&
        Objects.equals(this.equippable, destinyDefinitionsDestinyInventoryItemDefinition.equippable) &&
        Objects.equals(this.equippingBlock, destinyDefinitionsDestinyInventoryItemDefinition.equippingBlock) &&
        Objects.equals(this.flavorText, destinyDefinitionsDestinyInventoryItemDefinition.flavorText) &&
        Objects.equals(this.gearset, destinyDefinitionsDestinyInventoryItemDefinition.gearset) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyInventoryItemDefinition.hash) &&
        Objects.equals(this.iconWatermark, destinyDefinitionsDestinyInventoryItemDefinition.iconWatermark) &&
        Objects.equals(this.iconWatermarkShelved, destinyDefinitionsDestinyInventoryItemDefinition.iconWatermarkShelved) &&
        Objects.equals(this.index, destinyDefinitionsDestinyInventoryItemDefinition.index) &&
        Objects.equals(this.inventory, destinyDefinitionsDestinyInventoryItemDefinition.inventory) &&
        Objects.equals(this.investmentStats, destinyDefinitionsDestinyInventoryItemDefinition.investmentStats) &&
        Objects.equals(this.isWrapper, destinyDefinitionsDestinyInventoryItemDefinition.isWrapper) &&
        Objects.equals(this.itemCategoryHashes, destinyDefinitionsDestinyInventoryItemDefinition.itemCategoryHashes) &&
        Objects.equals(this.itemSubType, destinyDefinitionsDestinyInventoryItemDefinition.itemSubType) &&
        Objects.equals(this.itemType, destinyDefinitionsDestinyInventoryItemDefinition.itemType) &&
        Objects.equals(this.itemTypeAndTierDisplayName, destinyDefinitionsDestinyInventoryItemDefinition.itemTypeAndTierDisplayName) &&
        Objects.equals(this.itemTypeDisplayName, destinyDefinitionsDestinyInventoryItemDefinition.itemTypeDisplayName) &&
        Objects.equals(this.links, destinyDefinitionsDestinyInventoryItemDefinition.links) &&
        Objects.equals(this.loreHash, destinyDefinitionsDestinyInventoryItemDefinition.loreHash) &&
        Objects.equals(this.metrics, destinyDefinitionsDestinyInventoryItemDefinition.metrics) &&
        Objects.equals(this.nonTransferrable, destinyDefinitionsDestinyInventoryItemDefinition.nonTransferrable) &&
        Objects.equals(this.objectives, destinyDefinitionsDestinyInventoryItemDefinition.objectives) &&
        Objects.equals(this.perks, destinyDefinitionsDestinyInventoryItemDefinition.perks) &&
        Objects.equals(this.plug, destinyDefinitionsDestinyInventoryItemDefinition.plug) &&
        Objects.equals(this.preview, destinyDefinitionsDestinyInventoryItemDefinition.preview) &&
        Objects.equals(this.quality, destinyDefinitionsDestinyInventoryItemDefinition.quality) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyInventoryItemDefinition.redacted) &&
        Objects.equals(this.sack, destinyDefinitionsDestinyInventoryItemDefinition.sack) &&
        Objects.equals(this.screenshot, destinyDefinitionsDestinyInventoryItemDefinition.screenshot) &&
        Objects.equals(this.seasonHash, destinyDefinitionsDestinyInventoryItemDefinition.seasonHash) &&
        Objects.equals(this.secondaryIcon, destinyDefinitionsDestinyInventoryItemDefinition.secondaryIcon) &&
        Objects.equals(this.secondaryOverlay, destinyDefinitionsDestinyInventoryItemDefinition.secondaryOverlay) &&
        Objects.equals(this.secondarySpecial, destinyDefinitionsDestinyInventoryItemDefinition.secondarySpecial) &&
        Objects.equals(this.setData, destinyDefinitionsDestinyInventoryItemDefinition.setData) &&
        Objects.equals(this.sockets, destinyDefinitionsDestinyInventoryItemDefinition.sockets) &&
        Objects.equals(this.sourceData, destinyDefinitionsDestinyInventoryItemDefinition.sourceData) &&
        Objects.equals(this.specialItemType, destinyDefinitionsDestinyInventoryItemDefinition.specialItemType) &&
        Objects.equals(this.stats, destinyDefinitionsDestinyInventoryItemDefinition.stats) &&
        Objects.equals(this.summary, destinyDefinitionsDestinyInventoryItemDefinition.summary) &&
        Objects.equals(this.summaryItemHash, destinyDefinitionsDestinyInventoryItemDefinition.summaryItemHash) &&
        Objects.equals(this.talentGrid, destinyDefinitionsDestinyInventoryItemDefinition.talentGrid) &&
        Objects.equals(this.tooltipNotifications, destinyDefinitionsDestinyInventoryItemDefinition.tooltipNotifications) &&
        Objects.equals(this.tooltipStyle, destinyDefinitionsDestinyInventoryItemDefinition.tooltipStyle) &&
        Objects.equals(this.traitHashes, destinyDefinitionsDestinyInventoryItemDefinition.traitHashes) &&
        Objects.equals(this.traitIds, destinyDefinitionsDestinyInventoryItemDefinition.traitIds) &&
        Objects.equals(this.translationBlock, destinyDefinitionsDestinyInventoryItemDefinition.translationBlock) &&
        Objects.equals(this.uiItemDisplayStyle, destinyDefinitionsDestinyInventoryItemDefinition.uiItemDisplayStyle) &&
        Objects.equals(this.value, destinyDefinitionsDestinyInventoryItemDefinition.value);
  }

  @Override
  public int hashCode() {
    return Objects.hash(action, allowActions, animations, backgroundColor, breakerType, breakerTypeHash, classType, collectibleHash, crafting, damageTypeHashes, damageTypes, defaultDamageType, defaultDamageTypeHash, displayProperties, displaySource, doesPostmasterPullHaveSideEffects, emblemObjectiveHash, equippable, equippingBlock, flavorText, gearset, hash, iconWatermark, iconWatermarkShelved, index, inventory, investmentStats, isWrapper, itemCategoryHashes, itemSubType, itemType, itemTypeAndTierDisplayName, itemTypeDisplayName, links, loreHash, metrics, nonTransferrable, objectives, perks, plug, preview, quality, redacted, sack, screenshot, seasonHash, secondaryIcon, secondaryOverlay, secondarySpecial, setData, sockets, sourceData, specialItemType, stats, summary, summaryItemHash, talentGrid, tooltipNotifications, tooltipStyle, traitHashes, traitIds, translationBlock, uiItemDisplayStyle, value);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyInventoryItemDefinition {\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    allowActions: ").append(toIndentedString(allowActions)).append("\n");
    sb.append("    animations: ").append(toIndentedString(animations)).append("\n");
    sb.append("    backgroundColor: ").append(toIndentedString(backgroundColor)).append("\n");
    sb.append("    breakerType: ").append(toIndentedString(breakerType)).append("\n");
    sb.append("    breakerTypeHash: ").append(toIndentedString(breakerTypeHash)).append("\n");
    sb.append("    classType: ").append(toIndentedString(classType)).append("\n");
    sb.append("    collectibleHash: ").append(toIndentedString(collectibleHash)).append("\n");
    sb.append("    crafting: ").append(toIndentedString(crafting)).append("\n");
    sb.append("    damageTypeHashes: ").append(toIndentedString(damageTypeHashes)).append("\n");
    sb.append("    damageTypes: ").append(toIndentedString(damageTypes)).append("\n");
    sb.append("    defaultDamageType: ").append(toIndentedString(defaultDamageType)).append("\n");
    sb.append("    defaultDamageTypeHash: ").append(toIndentedString(defaultDamageTypeHash)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    displaySource: ").append(toIndentedString(displaySource)).append("\n");
    sb.append("    doesPostmasterPullHaveSideEffects: ").append(toIndentedString(doesPostmasterPullHaveSideEffects)).append("\n");
    sb.append("    emblemObjectiveHash: ").append(toIndentedString(emblemObjectiveHash)).append("\n");
    sb.append("    equippable: ").append(toIndentedString(equippable)).append("\n");
    sb.append("    equippingBlock: ").append(toIndentedString(equippingBlock)).append("\n");
    sb.append("    flavorText: ").append(toIndentedString(flavorText)).append("\n");
    sb.append("    gearset: ").append(toIndentedString(gearset)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    iconWatermark: ").append(toIndentedString(iconWatermark)).append("\n");
    sb.append("    iconWatermarkShelved: ").append(toIndentedString(iconWatermarkShelved)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    inventory: ").append(toIndentedString(inventory)).append("\n");
    sb.append("    investmentStats: ").append(toIndentedString(investmentStats)).append("\n");
    sb.append("    isWrapper: ").append(toIndentedString(isWrapper)).append("\n");
    sb.append("    itemCategoryHashes: ").append(toIndentedString(itemCategoryHashes)).append("\n");
    sb.append("    itemSubType: ").append(toIndentedString(itemSubType)).append("\n");
    sb.append("    itemType: ").append(toIndentedString(itemType)).append("\n");
    sb.append("    itemTypeAndTierDisplayName: ").append(toIndentedString(itemTypeAndTierDisplayName)).append("\n");
    sb.append("    itemTypeDisplayName: ").append(toIndentedString(itemTypeDisplayName)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    loreHash: ").append(toIndentedString(loreHash)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    nonTransferrable: ").append(toIndentedString(nonTransferrable)).append("\n");
    sb.append("    objectives: ").append(toIndentedString(objectives)).append("\n");
    sb.append("    perks: ").append(toIndentedString(perks)).append("\n");
    sb.append("    plug: ").append(toIndentedString(plug)).append("\n");
    sb.append("    preview: ").append(toIndentedString(preview)).append("\n");
    sb.append("    quality: ").append(toIndentedString(quality)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("    sack: ").append(toIndentedString(sack)).append("\n");
    sb.append("    screenshot: ").append(toIndentedString(screenshot)).append("\n");
    sb.append("    seasonHash: ").append(toIndentedString(seasonHash)).append("\n");
    sb.append("    secondaryIcon: ").append(toIndentedString(secondaryIcon)).append("\n");
    sb.append("    secondaryOverlay: ").append(toIndentedString(secondaryOverlay)).append("\n");
    sb.append("    secondarySpecial: ").append(toIndentedString(secondarySpecial)).append("\n");
    sb.append("    setData: ").append(toIndentedString(setData)).append("\n");
    sb.append("    sockets: ").append(toIndentedString(sockets)).append("\n");
    sb.append("    sourceData: ").append(toIndentedString(sourceData)).append("\n");
    sb.append("    specialItemType: ").append(toIndentedString(specialItemType)).append("\n");
    sb.append("    stats: ").append(toIndentedString(stats)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    summaryItemHash: ").append(toIndentedString(summaryItemHash)).append("\n");
    sb.append("    talentGrid: ").append(toIndentedString(talentGrid)).append("\n");
    sb.append("    tooltipNotifications: ").append(toIndentedString(tooltipNotifications)).append("\n");
    sb.append("    tooltipStyle: ").append(toIndentedString(tooltipStyle)).append("\n");
    sb.append("    traitHashes: ").append(toIndentedString(traitHashes)).append("\n");
    sb.append("    traitIds: ").append(toIndentedString(traitIds)).append("\n");
    sb.append("    translationBlock: ").append(toIndentedString(translationBlock)).append("\n");
    sb.append("    uiItemDisplayStyle: ").append(toIndentedString(uiItemDisplayStyle)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("action");
    openapiFields.add("allowActions");
    openapiFields.add("animations");
    openapiFields.add("backgroundColor");
    openapiFields.add("breakerType");
    openapiFields.add("breakerTypeHash");
    openapiFields.add("classType");
    openapiFields.add("collectibleHash");
    openapiFields.add("crafting");
    openapiFields.add("damageTypeHashes");
    openapiFields.add("damageTypes");
    openapiFields.add("defaultDamageType");
    openapiFields.add("defaultDamageTypeHash");
    openapiFields.add("displayProperties");
    openapiFields.add("displaySource");
    openapiFields.add("doesPostmasterPullHaveSideEffects");
    openapiFields.add("emblemObjectiveHash");
    openapiFields.add("equippable");
    openapiFields.add("equippingBlock");
    openapiFields.add("flavorText");
    openapiFields.add("gearset");
    openapiFields.add("hash");
    openapiFields.add("iconWatermark");
    openapiFields.add("iconWatermarkShelved");
    openapiFields.add("index");
    openapiFields.add("inventory");
    openapiFields.add("investmentStats");
    openapiFields.add("isWrapper");
    openapiFields.add("itemCategoryHashes");
    openapiFields.add("itemSubType");
    openapiFields.add("itemType");
    openapiFields.add("itemTypeAndTierDisplayName");
    openapiFields.add("itemTypeDisplayName");
    openapiFields.add("links");
    openapiFields.add("loreHash");
    openapiFields.add("metrics");
    openapiFields.add("nonTransferrable");
    openapiFields.add("objectives");
    openapiFields.add("perks");
    openapiFields.add("plug");
    openapiFields.add("preview");
    openapiFields.add("quality");
    openapiFields.add("redacted");
    openapiFields.add("sack");
    openapiFields.add("screenshot");
    openapiFields.add("seasonHash");
    openapiFields.add("secondaryIcon");
    openapiFields.add("secondaryOverlay");
    openapiFields.add("secondarySpecial");
    openapiFields.add("setData");
    openapiFields.add("sockets");
    openapiFields.add("sourceData");
    openapiFields.add("specialItemType");
    openapiFields.add("stats");
    openapiFields.add("summary");
    openapiFields.add("summaryItemHash");
    openapiFields.add("talentGrid");
    openapiFields.add("tooltipNotifications");
    openapiFields.add("tooltipStyle");
    openapiFields.add("traitHashes");
    openapiFields.add("traitIds");
    openapiFields.add("translationBlock");
    openapiFields.add("uiItemDisplayStyle");
    openapiFields.add("value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyInventoryItemDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyInventoryItemDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyInventoryItemDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyInventoryItemDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyInventoryItemDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyInventoryItemDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `action`
      if (jsonObj.get("action") != null && !jsonObj.get("action").isJsonNull()) {
        DestinyDefinitionsDestinyItemActionBlockDefinition.validateJsonElement(jsonObj.get("action"));
      }
      if (jsonObj.get("animations") != null && !jsonObj.get("animations").isJsonNull()) {
        JsonArray jsonArrayanimations = jsonObj.getAsJsonArray("animations");
        if (jsonArrayanimations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("animations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `animations` to be an array in the JSON string but got `%s`", jsonObj.get("animations").toString()));
          }

          // validate the optional field `animations` (array)
          for (int i = 0; i < jsonArrayanimations.size(); i++) {
            DestinyDefinitionsAnimationsDestinyAnimationReference.validateJsonElement(jsonArrayanimations.get(i));
          };
        }
      }
      // validate the optional field `backgroundColor`
      if (jsonObj.get("backgroundColor") != null && !jsonObj.get("backgroundColor").isJsonNull()) {
        DestinyMiscDestinyColor.validateJsonElement(jsonObj.get("backgroundColor"));
      }
      // validate the optional field `crafting`
      if (jsonObj.get("crafting") != null && !jsonObj.get("crafting").isJsonNull()) {
        DestinyDefinitionsDestinyItemCraftingBlockDefinition.validateJsonElement(jsonObj.get("crafting"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("damageTypeHashes") != null && !jsonObj.get("damageTypeHashes").isJsonNull() && !jsonObj.get("damageTypeHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `damageTypeHashes` to be an array in the JSON string but got `%s`", jsonObj.get("damageTypeHashes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("damageTypes") != null && !jsonObj.get("damageTypes").isJsonNull() && !jsonObj.get("damageTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `damageTypes` to be an array in the JSON string but got `%s`", jsonObj.get("damageTypes").toString()));
      }
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      if ((jsonObj.get("displaySource") != null && !jsonObj.get("displaySource").isJsonNull()) && !jsonObj.get("displaySource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displaySource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displaySource").toString()));
      }
      // validate the optional field `equippingBlock`
      if (jsonObj.get("equippingBlock") != null && !jsonObj.get("equippingBlock").isJsonNull()) {
        DestinyDefinitionsDestinyEquippingBlockDefinition.validateJsonElement(jsonObj.get("equippingBlock"));
      }
      if ((jsonObj.get("flavorText") != null && !jsonObj.get("flavorText").isJsonNull()) && !jsonObj.get("flavorText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flavorText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flavorText").toString()));
      }
      // validate the optional field `gearset`
      if (jsonObj.get("gearset") != null && !jsonObj.get("gearset").isJsonNull()) {
        DestinyDefinitionsDestinyItemGearsetBlockDefinition.validateJsonElement(jsonObj.get("gearset"));
      }
      if ((jsonObj.get("iconWatermark") != null && !jsonObj.get("iconWatermark").isJsonNull()) && !jsonObj.get("iconWatermark").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iconWatermark` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iconWatermark").toString()));
      }
      if ((jsonObj.get("iconWatermarkShelved") != null && !jsonObj.get("iconWatermarkShelved").isJsonNull()) && !jsonObj.get("iconWatermarkShelved").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iconWatermarkShelved` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iconWatermarkShelved").toString()));
      }
      // validate the optional field `inventory`
      if (jsonObj.get("inventory") != null && !jsonObj.get("inventory").isJsonNull()) {
        DestinyDefinitionsDestinyItemInventoryBlockDefinition.validateJsonElement(jsonObj.get("inventory"));
      }
      if (jsonObj.get("investmentStats") != null && !jsonObj.get("investmentStats").isJsonNull()) {
        JsonArray jsonArrayinvestmentStats = jsonObj.getAsJsonArray("investmentStats");
        if (jsonArrayinvestmentStats != null) {
          // ensure the json data is an array
          if (!jsonObj.get("investmentStats").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `investmentStats` to be an array in the JSON string but got `%s`", jsonObj.get("investmentStats").toString()));
          }

          // validate the optional field `investmentStats` (array)
          for (int i = 0; i < jsonArrayinvestmentStats.size(); i++) {
            DestinyDefinitionsDestinyItemInvestmentStatDefinition.validateJsonElement(jsonArrayinvestmentStats.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("itemCategoryHashes") != null && !jsonObj.get("itemCategoryHashes").isJsonNull() && !jsonObj.get("itemCategoryHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemCategoryHashes` to be an array in the JSON string but got `%s`", jsonObj.get("itemCategoryHashes").toString()));
      }
      if ((jsonObj.get("itemTypeAndTierDisplayName") != null && !jsonObj.get("itemTypeAndTierDisplayName").isJsonNull()) && !jsonObj.get("itemTypeAndTierDisplayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemTypeAndTierDisplayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("itemTypeAndTierDisplayName").toString()));
      }
      if ((jsonObj.get("itemTypeDisplayName") != null && !jsonObj.get("itemTypeDisplayName").isJsonNull()) && !jsonObj.get("itemTypeDisplayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemTypeDisplayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("itemTypeDisplayName").toString()));
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            LinksHyperlinkReference.validateJsonElement(jsonArraylinks.get(i));
          };
        }
      }
      // validate the optional field `metrics`
      if (jsonObj.get("metrics") != null && !jsonObj.get("metrics").isJsonNull()) {
        DestinyDefinitionsDestinyItemMetricBlockDefinition.validateJsonElement(jsonObj.get("metrics"));
      }
      // validate the optional field `objectives`
      if (jsonObj.get("objectives") != null && !jsonObj.get("objectives").isJsonNull()) {
        DestinyDefinitionsDestinyItemObjectiveBlockDefinition.validateJsonElement(jsonObj.get("objectives"));
      }
      if (jsonObj.get("perks") != null && !jsonObj.get("perks").isJsonNull()) {
        JsonArray jsonArrayperks = jsonObj.getAsJsonArray("perks");
        if (jsonArrayperks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("perks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `perks` to be an array in the JSON string but got `%s`", jsonObj.get("perks").toString()));
          }

          // validate the optional field `perks` (array)
          for (int i = 0; i < jsonArrayperks.size(); i++) {
            DestinyDefinitionsDestinyItemPerkEntryDefinition.validateJsonElement(jsonArrayperks.get(i));
          };
        }
      }
      // validate the optional field `plug`
      if (jsonObj.get("plug") != null && !jsonObj.get("plug").isJsonNull()) {
        DestinyDefinitionsItemsDestinyItemPlugDefinition.validateJsonElement(jsonObj.get("plug"));
      }
      // validate the optional field `preview`
      if (jsonObj.get("preview") != null && !jsonObj.get("preview").isJsonNull()) {
        DestinyDefinitionsDestinyItemPreviewBlockDefinition.validateJsonElement(jsonObj.get("preview"));
      }
      // validate the optional field `quality`
      if (jsonObj.get("quality") != null && !jsonObj.get("quality").isJsonNull()) {
        DestinyDefinitionsDestinyItemQualityBlockDefinition.validateJsonElement(jsonObj.get("quality"));
      }
      // validate the optional field `sack`
      if (jsonObj.get("sack") != null && !jsonObj.get("sack").isJsonNull()) {
        DestinyDefinitionsDestinyItemSackBlockDefinition.validateJsonElement(jsonObj.get("sack"));
      }
      if ((jsonObj.get("screenshot") != null && !jsonObj.get("screenshot").isJsonNull()) && !jsonObj.get("screenshot").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `screenshot` to be a primitive type in the JSON string but got `%s`", jsonObj.get("screenshot").toString()));
      }
      if ((jsonObj.get("secondaryIcon") != null && !jsonObj.get("secondaryIcon").isJsonNull()) && !jsonObj.get("secondaryIcon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondaryIcon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondaryIcon").toString()));
      }
      if ((jsonObj.get("secondaryOverlay") != null && !jsonObj.get("secondaryOverlay").isJsonNull()) && !jsonObj.get("secondaryOverlay").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondaryOverlay` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondaryOverlay").toString()));
      }
      if ((jsonObj.get("secondarySpecial") != null && !jsonObj.get("secondarySpecial").isJsonNull()) && !jsonObj.get("secondarySpecial").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondarySpecial` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondarySpecial").toString()));
      }
      // validate the optional field `setData`
      if (jsonObj.get("setData") != null && !jsonObj.get("setData").isJsonNull()) {
        DestinyDefinitionsDestinyItemSetBlockDefinition.validateJsonElement(jsonObj.get("setData"));
      }
      // validate the optional field `sockets`
      if (jsonObj.get("sockets") != null && !jsonObj.get("sockets").isJsonNull()) {
        DestinyDefinitionsDestinyItemSocketBlockDefinition.validateJsonElement(jsonObj.get("sockets"));
      }
      // validate the optional field `sourceData`
      if (jsonObj.get("sourceData") != null && !jsonObj.get("sourceData").isJsonNull()) {
        DestinyDefinitionsDestinyItemSourceBlockDefinition.validateJsonElement(jsonObj.get("sourceData"));
      }
      // validate the optional field `stats`
      if (jsonObj.get("stats") != null && !jsonObj.get("stats").isJsonNull()) {
        DestinyDefinitionsDestinyItemStatBlockDefinition.validateJsonElement(jsonObj.get("stats"));
      }
      // validate the optional field `summary`
      if (jsonObj.get("summary") != null && !jsonObj.get("summary").isJsonNull()) {
        DestinyDefinitionsDestinyItemSummaryBlockDefinition.validateJsonElement(jsonObj.get("summary"));
      }
      // validate the optional field `talentGrid`
      if (jsonObj.get("talentGrid") != null && !jsonObj.get("talentGrid").isJsonNull()) {
        DestinyDefinitionsDestinyItemTalentGridBlockDefinition.validateJsonElement(jsonObj.get("talentGrid"));
      }
      if (jsonObj.get("tooltipNotifications") != null && !jsonObj.get("tooltipNotifications").isJsonNull()) {
        JsonArray jsonArraytooltipNotifications = jsonObj.getAsJsonArray("tooltipNotifications");
        if (jsonArraytooltipNotifications != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tooltipNotifications").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tooltipNotifications` to be an array in the JSON string but got `%s`", jsonObj.get("tooltipNotifications").toString()));
          }

          // validate the optional field `tooltipNotifications` (array)
          for (int i = 0; i < jsonArraytooltipNotifications.size(); i++) {
            DestinyDefinitionsDestinyItemTooltipNotification.validateJsonElement(jsonArraytooltipNotifications.get(i));
          };
        }
      }
      if ((jsonObj.get("tooltipStyle") != null && !jsonObj.get("tooltipStyle").isJsonNull()) && !jsonObj.get("tooltipStyle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tooltipStyle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tooltipStyle").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("traitHashes") != null && !jsonObj.get("traitHashes").isJsonNull() && !jsonObj.get("traitHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `traitHashes` to be an array in the JSON string but got `%s`", jsonObj.get("traitHashes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("traitIds") != null && !jsonObj.get("traitIds").isJsonNull() && !jsonObj.get("traitIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `traitIds` to be an array in the JSON string but got `%s`", jsonObj.get("traitIds").toString()));
      }
      // validate the optional field `translationBlock`
      if (jsonObj.get("translationBlock") != null && !jsonObj.get("translationBlock").isJsonNull()) {
        DestinyDefinitionsDestinyItemTranslationBlockDefinition.validateJsonElement(jsonObj.get("translationBlock"));
      }
      if ((jsonObj.get("uiItemDisplayStyle") != null && !jsonObj.get("uiItemDisplayStyle").isJsonNull()) && !jsonObj.get("uiItemDisplayStyle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uiItemDisplayStyle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uiItemDisplayStyle").toString()));
      }
      // validate the optional field `value`
      if (jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) {
        DestinyDefinitionsDestinyItemValueBlockDefinition.validateJsonElement(jsonObj.get("value"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyInventoryItemDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyInventoryItemDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyInventoryItemDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyInventoryItemDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyInventoryItemDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyInventoryItemDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyInventoryItemDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyInventoryItemDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyInventoryItemDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyInventoryItemDefinition
   */
  public static DestinyDefinitionsDestinyInventoryItemDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyInventoryItemDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyInventoryItemDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

