/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsDestinyNodeActivationRequirement;
import org.openapitools.client.model.DestinyDefinitionsDestinyNodeStepDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Talent Grids on items have Nodes. These nodes have positions in the talent grid&#39;s UI, and contain \&quot;Steps\&quot; (DestinyTalentNodeStepDefinition), one of whom will be the \&quot;Current\&quot; step.  The Current Step determines the visual properties of the node, as well as what the node grants when it is activated.  See DestinyTalentGridDefinition for a more complete overview of how Talent Grids work, and how they are used in Destiny 2 (and how they were used in Destiny 1).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyTalentNodeDefinition {
  public static final String SERIALIZED_NAME_AUTO_UNLOCKS = "autoUnlocks";
  @SerializedName(SERIALIZED_NAME_AUTO_UNLOCKS)
  private Boolean autoUnlocks;

  public static final String SERIALIZED_NAME_BINARY_PAIR_NODE_INDEX = "binaryPairNodeIndex";
  @SerializedName(SERIALIZED_NAME_BINARY_PAIR_NODE_INDEX)
  private Integer binaryPairNodeIndex;

  public static final String SERIALIZED_NAME_COLUMN = "column";
  @SerializedName(SERIALIZED_NAME_COLUMN)
  private Integer column;

  public static final String SERIALIZED_NAME_EXCLUSIVE_WITH_NODE_HASHES = "exclusiveWithNodeHashes";
  @SerializedName(SERIALIZED_NAME_EXCLUSIVE_WITH_NODE_HASHES)
  private List<Integer> exclusiveWithNodeHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_HASH = "groupHash";
  @SerializedName(SERIALIZED_NAME_GROUP_HASH)
  private Integer groupHash;

  public static final String SERIALIZED_NAME_IGNORE_FOR_COMPLETION = "ignoreForCompletion";
  @SerializedName(SERIALIZED_NAME_IGNORE_FOR_COMPLETION)
  private Boolean ignoreForCompletion;

  public static final String SERIALIZED_NAME_IS_RANDOM = "isRandom";
  @SerializedName(SERIALIZED_NAME_IS_RANDOM)
  private Boolean isRandom;

  public static final String SERIALIZED_NAME_IS_RANDOM_REPURCHASABLE = "isRandomRepurchasable";
  @SerializedName(SERIALIZED_NAME_IS_RANDOM_REPURCHASABLE)
  private Boolean isRandomRepurchasable;

  public static final String SERIALIZED_NAME_LAST_STEP_REPEATS = "lastStepRepeats";
  @SerializedName(SERIALIZED_NAME_LAST_STEP_REPEATS)
  private Boolean lastStepRepeats;

  public static final String SERIALIZED_NAME_LAYOUT_IDENTIFIER = "layoutIdentifier";
  @SerializedName(SERIALIZED_NAME_LAYOUT_IDENTIFIER)
  private String layoutIdentifier;

  public static final String SERIALIZED_NAME_LORE_HASH = "loreHash";
  @SerializedName(SERIALIZED_NAME_LORE_HASH)
  private Integer loreHash;

  public static final String SERIALIZED_NAME_NODE_HASH = "nodeHash";
  @SerializedName(SERIALIZED_NAME_NODE_HASH)
  private Integer nodeHash;

  public static final String SERIALIZED_NAME_NODE_INDEX = "nodeIndex";
  @SerializedName(SERIALIZED_NAME_NODE_INDEX)
  private Integer nodeIndex;

  public static final String SERIALIZED_NAME_NODE_STYLE_IDENTIFIER = "nodeStyleIdentifier";
  @SerializedName(SERIALIZED_NAME_NODE_STYLE_IDENTIFIER)
  private String nodeStyleIdentifier;

  public static final String SERIALIZED_NAME_PREREQUISITE_NODE_INDEXES = "prerequisiteNodeIndexes";
  @SerializedName(SERIALIZED_NAME_PREREQUISITE_NODE_INDEXES)
  private List<Integer> prerequisiteNodeIndexes = new ArrayList<>();

  public static final String SERIALIZED_NAME_RANDOM_ACTIVATION_REQUIREMENT = "randomActivationRequirement";
  @SerializedName(SERIALIZED_NAME_RANDOM_ACTIVATION_REQUIREMENT)
  private DestinyDefinitionsDestinyNodeActivationRequirement randomActivationRequirement;

  public static final String SERIALIZED_NAME_RANDOM_START_PROGRESSION_BAR_AT_PROGRESSION = "randomStartProgressionBarAtProgression";
  @SerializedName(SERIALIZED_NAME_RANDOM_START_PROGRESSION_BAR_AT_PROGRESSION)
  private Integer randomStartProgressionBarAtProgression;

  public static final String SERIALIZED_NAME_ROW = "row";
  @SerializedName(SERIALIZED_NAME_ROW)
  private Integer row;

  public static final String SERIALIZED_NAME_STEPS = "steps";
  @SerializedName(SERIALIZED_NAME_STEPS)
  private List<DestinyDefinitionsDestinyNodeStepDefinition> steps = new ArrayList<>();

  public DestinyDefinitionsDestinyTalentNodeDefinition() {
  }

  public DestinyDefinitionsDestinyTalentNodeDefinition autoUnlocks(Boolean autoUnlocks) {
    this.autoUnlocks = autoUnlocks;
    return this;
  }

  /**
   * If true, this node will automatically unlock when the Talent Grid&#39;s level reaches the required level of the current step of this node.
   * @return autoUnlocks
   */
  @javax.annotation.Nullable
  public Boolean getAutoUnlocks() {
    return autoUnlocks;
  }

  public void setAutoUnlocks(Boolean autoUnlocks) {
    this.autoUnlocks = autoUnlocks;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition binaryPairNodeIndex(Integer binaryPairNodeIndex) {
    this.binaryPairNodeIndex = binaryPairNodeIndex;
    return this;
  }

  /**
   * At one point, Talent Nodes supported the idea of \&quot;Binary Pairs\&quot;: nodes that overlapped each other visually, and where activating one deactivated the other. They ended up not being used, mostly because Exclusive Sets are *almost* a superset of this concept, but the potential for it to be used still exists in theory.  If this is ever used, this will be the index into the DestinyTalentGridDefinition.nodes property for the node that is the binary pair match to this node. Activating one deactivates the other.
   * @return binaryPairNodeIndex
   */
  @javax.annotation.Nullable
  public Integer getBinaryPairNodeIndex() {
    return binaryPairNodeIndex;
  }

  public void setBinaryPairNodeIndex(Integer binaryPairNodeIndex) {
    this.binaryPairNodeIndex = binaryPairNodeIndex;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition column(Integer column) {
    this.column = column;
    return this;
  }

  /**
   * The visual \&quot;column\&quot; where the node should be shown in the UI. If negative, the node is hidden.
   * @return column
   */
  @javax.annotation.Nullable
  public Integer getColumn() {
    return column;
  }

  public void setColumn(Integer column) {
    this.column = column;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition exclusiveWithNodeHashes(List<Integer> exclusiveWithNodeHashes) {
    this.exclusiveWithNodeHashes = exclusiveWithNodeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentNodeDefinition addExclusiveWithNodeHashesItem(Integer exclusiveWithNodeHashesItem) {
    if (this.exclusiveWithNodeHashes == null) {
      this.exclusiveWithNodeHashes = new ArrayList<>();
    }
    this.exclusiveWithNodeHashes.add(exclusiveWithNodeHashesItem);
    return this;
  }

  /**
   * The nodeHash values for nodes that are in an Exclusive Set with this node.  See DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.  Again, note that these are nodeHashes and *not* nodeIndexes.
   * @return exclusiveWithNodeHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getExclusiveWithNodeHashes() {
    return exclusiveWithNodeHashes;
  }

  public void setExclusiveWithNodeHashes(List<Integer> exclusiveWithNodeHashes) {
    this.exclusiveWithNodeHashes = exclusiveWithNodeHashes;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition groupHash(Integer groupHash) {
    this.groupHash = groupHash;
    return this;
  }

  /**
   * As of Destiny 2, nodes can exist as part of \&quot;Exclusive Groups\&quot;. These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \&quot;opposing\&quot; nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.  See DestinyTalentExclusiveGroup for more information on the details. This is an identifier for this node&#39;s group, if it is part of one.
   * @return groupHash
   */
  @javax.annotation.Nullable
  public Integer getGroupHash() {
    return groupHash;
  }

  public void setGroupHash(Integer groupHash) {
    this.groupHash = groupHash;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition ignoreForCompletion(Boolean ignoreForCompletion) {
    this.ignoreForCompletion = ignoreForCompletion;
    return this;
  }

  /**
   * Comes from the talent grid node style: if true, then this node should be ignored for determining whether the grid is complete.
   * @return ignoreForCompletion
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreForCompletion() {
    return ignoreForCompletion;
  }

  public void setIgnoreForCompletion(Boolean ignoreForCompletion) {
    this.ignoreForCompletion = ignoreForCompletion;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition isRandom(Boolean isRandom) {
    this.isRandom = isRandom;
    return this;
  }

  /**
   * If this is true, the node&#39;s step is determined randomly rather than the first step being chosen.
   * @return isRandom
   */
  @javax.annotation.Nullable
  public Boolean getIsRandom() {
    return isRandom;
  }

  public void setIsRandom(Boolean isRandom) {
    this.isRandom = isRandom;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition isRandomRepurchasable(Boolean isRandomRepurchasable) {
    this.isRandomRepurchasable = isRandomRepurchasable;
    return this;
  }

  /**
   * If this is true, the node can be \&quot;re-rolled\&quot; to acquire a different random current step. This is not used, but still exists for a theoretical future of talent grids.
   * @return isRandomRepurchasable
   */
  @javax.annotation.Nullable
  public Boolean getIsRandomRepurchasable() {
    return isRandomRepurchasable;
  }

  public void setIsRandomRepurchasable(Boolean isRandomRepurchasable) {
    this.isRandomRepurchasable = isRandomRepurchasable;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition lastStepRepeats(Boolean lastStepRepeats) {
    this.lastStepRepeats = lastStepRepeats;
    return this;
  }

  /**
   * At one point, Nodes were going to be able to be activated multiple times, changing the current step and potentially piling on multiple effects from the previously activated steps. This property would indicate if the last step could be activated multiple times.   This is not currently used, but it isn&#39;t out of the question that this could end up being used again in a theoretical future.
   * @return lastStepRepeats
   */
  @javax.annotation.Nullable
  public Boolean getLastStepRepeats() {
    return lastStepRepeats;
  }

  public void setLastStepRepeats(Boolean lastStepRepeats) {
    this.lastStepRepeats = lastStepRepeats;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition layoutIdentifier(String layoutIdentifier) {
    this.layoutIdentifier = layoutIdentifier;
    return this;
  }

  /**
   * A string identifier for a custom visual layout to apply to this talent node. Unfortunately, we do not have any data for rendering these custom layouts. It will be up to you to interpret these strings and change your UI if you want to have custom UI matching these layouts.
   * @return layoutIdentifier
   */
  @javax.annotation.Nullable
  public String getLayoutIdentifier() {
    return layoutIdentifier;
  }

  public void setLayoutIdentifier(String layoutIdentifier) {
    this.layoutIdentifier = layoutIdentifier;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition loreHash(Integer loreHash) {
    this.loreHash = loreHash;
    return this;
  }

  /**
   * Talent nodes can be associated with a piece of Lore, generally rendered in a tooltip. This is the hash identifier of the lore element to show, if there is one to be show.
   * @return loreHash
   */
  @javax.annotation.Nullable
  public Integer getLoreHash() {
    return loreHash;
  }

  public void setLoreHash(Integer loreHash) {
    this.loreHash = loreHash;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition nodeHash(Integer nodeHash) {
    this.nodeHash = nodeHash;
    return this;
  }

  /**
   * The hash identifier for the node, which unfortunately is also content version dependent but can be (and ideally, should be) used instead of the nodeIndex to uniquely identify the node.  The two exist side-by-side for backcompat reasons due to the Great Talent Node Restructuring of Destiny 1, and I ran out of time to remove one of them and standardize on the other. Sorry!
   * @return nodeHash
   */
  @javax.annotation.Nullable
  public Integer getNodeHash() {
    return nodeHash;
  }

  public void setNodeHash(Integer nodeHash) {
    this.nodeHash = nodeHash;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition nodeIndex(Integer nodeIndex) {
    this.nodeIndex = nodeIndex;
    return this;
  }

  /**
   * The index into the DestinyTalentGridDefinition&#39;s \&quot;nodes\&quot; property where this node is located. Used to uniquely identify the node within the Talent Grid. Note that this is content version dependent: make sure you have the latest version of content before trying to use these properties.
   * @return nodeIndex
   */
  @javax.annotation.Nullable
  public Integer getNodeIndex() {
    return nodeIndex;
  }

  public void setNodeIndex(Integer nodeIndex) {
    this.nodeIndex = nodeIndex;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition nodeStyleIdentifier(String nodeStyleIdentifier) {
    this.nodeStyleIdentifier = nodeStyleIdentifier;
    return this;
  }

  /**
   * Comes from the talent grid node style: this identifier should be used to determine how to render the node in the UI.
   * @return nodeStyleIdentifier
   */
  @javax.annotation.Nullable
  public String getNodeStyleIdentifier() {
    return nodeStyleIdentifier;
  }

  public void setNodeStyleIdentifier(String nodeStyleIdentifier) {
    this.nodeStyleIdentifier = nodeStyleIdentifier;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition prerequisiteNodeIndexes(List<Integer> prerequisiteNodeIndexes) {
    this.prerequisiteNodeIndexes = prerequisiteNodeIndexes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentNodeDefinition addPrerequisiteNodeIndexesItem(Integer prerequisiteNodeIndexesItem) {
    if (this.prerequisiteNodeIndexes == null) {
      this.prerequisiteNodeIndexes = new ArrayList<>();
    }
    this.prerequisiteNodeIndexes.add(prerequisiteNodeIndexesItem);
    return this;
  }

  /**
   * Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that must be activated before this one is allowed to be activated.  I would have liked to change this to hashes for Destiny 2, but we have run out of time.
   * @return prerequisiteNodeIndexes
   */
  @javax.annotation.Nullable
  public List<Integer> getPrerequisiteNodeIndexes() {
    return prerequisiteNodeIndexes;
  }

  public void setPrerequisiteNodeIndexes(List<Integer> prerequisiteNodeIndexes) {
    this.prerequisiteNodeIndexes = prerequisiteNodeIndexes;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition randomActivationRequirement(DestinyDefinitionsDestinyNodeActivationRequirement randomActivationRequirement) {
    this.randomActivationRequirement = randomActivationRequirement;
    return this;
  }

  /**
   * At one point, you were going to be able to repurchase talent nodes that had random steps, to \&quot;re-roll\&quot; the current step of the node (and thus change the properties of your item). This was to be the activation requirement for performing that re-roll.  The system still exists to do this, as far as I know, so it may yet come back around!
   * @return randomActivationRequirement
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyNodeActivationRequirement getRandomActivationRequirement() {
    return randomActivationRequirement;
  }

  public void setRandomActivationRequirement(DestinyDefinitionsDestinyNodeActivationRequirement randomActivationRequirement) {
    this.randomActivationRequirement = randomActivationRequirement;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition randomStartProgressionBarAtProgression(Integer randomStartProgressionBarAtProgression) {
    this.randomStartProgressionBarAtProgression = randomStartProgressionBarAtProgression;
    return this;
  }

  /**
   * If the node&#39;s step is randomly selected, this is the amount of the Talent Grid&#39;s progression experience at which the progression bar for the node should be shown.
   * @return randomStartProgressionBarAtProgression
   */
  @javax.annotation.Nullable
  public Integer getRandomStartProgressionBarAtProgression() {
    return randomStartProgressionBarAtProgression;
  }

  public void setRandomStartProgressionBarAtProgression(Integer randomStartProgressionBarAtProgression) {
    this.randomStartProgressionBarAtProgression = randomStartProgressionBarAtProgression;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition row(Integer row) {
    this.row = row;
    return this;
  }

  /**
   * The visual \&quot;row\&quot; where the node should be shown in the UI. If negative, then the node is hidden.
   * @return row
   */
  @javax.annotation.Nullable
  public Integer getRow() {
    return row;
  }

  public void setRow(Integer row) {
    this.row = row;
  }


  public DestinyDefinitionsDestinyTalentNodeDefinition steps(List<DestinyDefinitionsDestinyNodeStepDefinition> steps) {
    this.steps = steps;
    return this;
  }

  public DestinyDefinitionsDestinyTalentNodeDefinition addStepsItem(DestinyDefinitionsDestinyNodeStepDefinition stepsItem) {
    if (this.steps == null) {
      this.steps = new ArrayList<>();
    }
    this.steps.add(stepsItem);
    return this;
  }

  /**
   * At this point, \&quot;steps\&quot; have been obfuscated into conceptual entities, aggregating the underlying notions of \&quot;properties\&quot; and \&quot;true steps\&quot;.  If you need to know a step as it truly exists - such as when recreating Node logic when processing Vendor data - you&#39;ll have to use the \&quot;realSteps\&quot; property below.
   * @return steps
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyNodeStepDefinition> getSteps() {
    return steps;
  }

  public void setSteps(List<DestinyDefinitionsDestinyNodeStepDefinition> steps) {
    this.steps = steps;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyTalentNodeDefinition destinyDefinitionsDestinyTalentNodeDefinition = (DestinyDefinitionsDestinyTalentNodeDefinition) o;
    return Objects.equals(this.autoUnlocks, destinyDefinitionsDestinyTalentNodeDefinition.autoUnlocks) &&
        Objects.equals(this.binaryPairNodeIndex, destinyDefinitionsDestinyTalentNodeDefinition.binaryPairNodeIndex) &&
        Objects.equals(this.column, destinyDefinitionsDestinyTalentNodeDefinition.column) &&
        Objects.equals(this.exclusiveWithNodeHashes, destinyDefinitionsDestinyTalentNodeDefinition.exclusiveWithNodeHashes) &&
        Objects.equals(this.groupHash, destinyDefinitionsDestinyTalentNodeDefinition.groupHash) &&
        Objects.equals(this.ignoreForCompletion, destinyDefinitionsDestinyTalentNodeDefinition.ignoreForCompletion) &&
        Objects.equals(this.isRandom, destinyDefinitionsDestinyTalentNodeDefinition.isRandom) &&
        Objects.equals(this.isRandomRepurchasable, destinyDefinitionsDestinyTalentNodeDefinition.isRandomRepurchasable) &&
        Objects.equals(this.lastStepRepeats, destinyDefinitionsDestinyTalentNodeDefinition.lastStepRepeats) &&
        Objects.equals(this.layoutIdentifier, destinyDefinitionsDestinyTalentNodeDefinition.layoutIdentifier) &&
        Objects.equals(this.loreHash, destinyDefinitionsDestinyTalentNodeDefinition.loreHash) &&
        Objects.equals(this.nodeHash, destinyDefinitionsDestinyTalentNodeDefinition.nodeHash) &&
        Objects.equals(this.nodeIndex, destinyDefinitionsDestinyTalentNodeDefinition.nodeIndex) &&
        Objects.equals(this.nodeStyleIdentifier, destinyDefinitionsDestinyTalentNodeDefinition.nodeStyleIdentifier) &&
        Objects.equals(this.prerequisiteNodeIndexes, destinyDefinitionsDestinyTalentNodeDefinition.prerequisiteNodeIndexes) &&
        Objects.equals(this.randomActivationRequirement, destinyDefinitionsDestinyTalentNodeDefinition.randomActivationRequirement) &&
        Objects.equals(this.randomStartProgressionBarAtProgression, destinyDefinitionsDestinyTalentNodeDefinition.randomStartProgressionBarAtProgression) &&
        Objects.equals(this.row, destinyDefinitionsDestinyTalentNodeDefinition.row) &&
        Objects.equals(this.steps, destinyDefinitionsDestinyTalentNodeDefinition.steps);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoUnlocks, binaryPairNodeIndex, column, exclusiveWithNodeHashes, groupHash, ignoreForCompletion, isRandom, isRandomRepurchasable, lastStepRepeats, layoutIdentifier, loreHash, nodeHash, nodeIndex, nodeStyleIdentifier, prerequisiteNodeIndexes, randomActivationRequirement, randomStartProgressionBarAtProgression, row, steps);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyTalentNodeDefinition {\n");
    sb.append("    autoUnlocks: ").append(toIndentedString(autoUnlocks)).append("\n");
    sb.append("    binaryPairNodeIndex: ").append(toIndentedString(binaryPairNodeIndex)).append("\n");
    sb.append("    column: ").append(toIndentedString(column)).append("\n");
    sb.append("    exclusiveWithNodeHashes: ").append(toIndentedString(exclusiveWithNodeHashes)).append("\n");
    sb.append("    groupHash: ").append(toIndentedString(groupHash)).append("\n");
    sb.append("    ignoreForCompletion: ").append(toIndentedString(ignoreForCompletion)).append("\n");
    sb.append("    isRandom: ").append(toIndentedString(isRandom)).append("\n");
    sb.append("    isRandomRepurchasable: ").append(toIndentedString(isRandomRepurchasable)).append("\n");
    sb.append("    lastStepRepeats: ").append(toIndentedString(lastStepRepeats)).append("\n");
    sb.append("    layoutIdentifier: ").append(toIndentedString(layoutIdentifier)).append("\n");
    sb.append("    loreHash: ").append(toIndentedString(loreHash)).append("\n");
    sb.append("    nodeHash: ").append(toIndentedString(nodeHash)).append("\n");
    sb.append("    nodeIndex: ").append(toIndentedString(nodeIndex)).append("\n");
    sb.append("    nodeStyleIdentifier: ").append(toIndentedString(nodeStyleIdentifier)).append("\n");
    sb.append("    prerequisiteNodeIndexes: ").append(toIndentedString(prerequisiteNodeIndexes)).append("\n");
    sb.append("    randomActivationRequirement: ").append(toIndentedString(randomActivationRequirement)).append("\n");
    sb.append("    randomStartProgressionBarAtProgression: ").append(toIndentedString(randomStartProgressionBarAtProgression)).append("\n");
    sb.append("    row: ").append(toIndentedString(row)).append("\n");
    sb.append("    steps: ").append(toIndentedString(steps)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoUnlocks");
    openapiFields.add("binaryPairNodeIndex");
    openapiFields.add("column");
    openapiFields.add("exclusiveWithNodeHashes");
    openapiFields.add("groupHash");
    openapiFields.add("ignoreForCompletion");
    openapiFields.add("isRandom");
    openapiFields.add("isRandomRepurchasable");
    openapiFields.add("lastStepRepeats");
    openapiFields.add("layoutIdentifier");
    openapiFields.add("loreHash");
    openapiFields.add("nodeHash");
    openapiFields.add("nodeIndex");
    openapiFields.add("nodeStyleIdentifier");
    openapiFields.add("prerequisiteNodeIndexes");
    openapiFields.add("randomActivationRequirement");
    openapiFields.add("randomStartProgressionBarAtProgression");
    openapiFields.add("row");
    openapiFields.add("steps");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyTalentNodeDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyTalentNodeDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyTalentNodeDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyTalentNodeDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyTalentNodeDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyTalentNodeDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("exclusiveWithNodeHashes") != null && !jsonObj.get("exclusiveWithNodeHashes").isJsonNull() && !jsonObj.get("exclusiveWithNodeHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `exclusiveWithNodeHashes` to be an array in the JSON string but got `%s`", jsonObj.get("exclusiveWithNodeHashes").toString()));
      }
      if ((jsonObj.get("layoutIdentifier") != null && !jsonObj.get("layoutIdentifier").isJsonNull()) && !jsonObj.get("layoutIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `layoutIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("layoutIdentifier").toString()));
      }
      if ((jsonObj.get("nodeStyleIdentifier") != null && !jsonObj.get("nodeStyleIdentifier").isJsonNull()) && !jsonObj.get("nodeStyleIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeStyleIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeStyleIdentifier").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("prerequisiteNodeIndexes") != null && !jsonObj.get("prerequisiteNodeIndexes").isJsonNull() && !jsonObj.get("prerequisiteNodeIndexes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `prerequisiteNodeIndexes` to be an array in the JSON string but got `%s`", jsonObj.get("prerequisiteNodeIndexes").toString()));
      }
      // validate the optional field `randomActivationRequirement`
      if (jsonObj.get("randomActivationRequirement") != null && !jsonObj.get("randomActivationRequirement").isJsonNull()) {
        DestinyDefinitionsDestinyNodeActivationRequirement.validateJsonElement(jsonObj.get("randomActivationRequirement"));
      }
      if (jsonObj.get("steps") != null && !jsonObj.get("steps").isJsonNull()) {
        JsonArray jsonArraysteps = jsonObj.getAsJsonArray("steps");
        if (jsonArraysteps != null) {
          // ensure the json data is an array
          if (!jsonObj.get("steps").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `steps` to be an array in the JSON string but got `%s`", jsonObj.get("steps").toString()));
          }

          // validate the optional field `steps` (array)
          for (int i = 0; i < jsonArraysteps.size(); i++) {
            DestinyDefinitionsDestinyNodeStepDefinition.validateJsonElement(jsonArraysteps.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyTalentNodeDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyTalentNodeDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyTalentNodeDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyTalentNodeDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyTalentNodeDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyTalentNodeDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyTalentNodeDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyTalentNodeDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyTalentNodeDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyTalentNodeDefinition
   */
  public static DestinyDefinitionsDestinyTalentNodeDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyTalentNodeDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyTalentNodeDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

