/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsDestinyMaterialRequirement;
import org.openapitools.client.model.DestinyDestinyTalentNodeStatBlock;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * I see you&#39;ve come to find out more about Talent Nodes. I&#39;m so sorry. Talent Nodes are the conceptual, visual nodes that appear on Talent Grids. Talent Grids, in Destiny 1, were found on almost every instanced item: they had Nodes that could be activated to change the properties of the item. In Destiny 2, Talent Grids only exist for Builds/Subclasses, and while the basic concept is the same (Nodes can be activated once you&#39;ve gained sufficient Experience on the Item, and provide effects), there are some new concepts from Destiny 1. Examine DestinyTalentGridDefinition and its subordinates for more information. This is the \&quot;Live\&quot; information for the current status of a Talent Node on a specific item. Talent Nodes have many Steps, but only one can be active at any one time: and it is the Step that determines both the visual and the game state-changing properties that the Node provides. Examine this and DestinyTalentNodeStepDefinition carefully. *IMPORTANT NOTE* Talent Nodes are, unfortunately, Content Version DEPENDENT. Though they refer to hashes for Nodes and Steps, those hashes are not guaranteed to be immutable across content versions. This is a source of great exasperation for me, but as a result anyone using Talent Grid data must ensure that the content version of their static content matches that of the server responses before showing or making decisions based on talent grid data.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDestinyTalentNode {
  public static final String SERIALIZED_NAME_ACTIVATION_GRID_LEVEL = "activationGridLevel";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_GRID_LEVEL)
  private Integer activationGridLevel;

  public static final String SERIALIZED_NAME_HIDDEN = "hidden";
  @SerializedName(SERIALIZED_NAME_HIDDEN)
  private Boolean hidden;

  public static final String SERIALIZED_NAME_IS_ACTIVATED = "isActivated";
  @SerializedName(SERIALIZED_NAME_IS_ACTIVATED)
  private Boolean isActivated;

  public static final String SERIALIZED_NAME_MATERIALS_TO_UPGRADE = "materialsToUpgrade";
  @SerializedName(SERIALIZED_NAME_MATERIALS_TO_UPGRADE)
  private List<DestinyDefinitionsDestinyMaterialRequirement> materialsToUpgrade = new ArrayList<>();

  public static final String SERIALIZED_NAME_NODE_HASH = "nodeHash";
  @SerializedName(SERIALIZED_NAME_NODE_HASH)
  private Integer nodeHash;

  public static final String SERIALIZED_NAME_NODE_INDEX = "nodeIndex";
  @SerializedName(SERIALIZED_NAME_NODE_INDEX)
  private Integer nodeIndex;

  public static final String SERIALIZED_NAME_NODE_STATS_BLOCK = "nodeStatsBlock";
  @SerializedName(SERIALIZED_NAME_NODE_STATS_BLOCK)
  private DestinyDestinyTalentNodeStatBlock nodeStatsBlock;

  public static final String SERIALIZED_NAME_PROGRESS_PERCENT = "progressPercent";
  @SerializedName(SERIALIZED_NAME_PROGRESS_PERCENT)
  private Float progressPercent;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private Integer state;

  public static final String SERIALIZED_NAME_STEP_INDEX = "stepIndex";
  @SerializedName(SERIALIZED_NAME_STEP_INDEX)
  private Integer stepIndex;

  public DestinyDestinyTalentNode() {
  }

  public DestinyDestinyTalentNode activationGridLevel(Integer activationGridLevel) {
    this.activationGridLevel = activationGridLevel;
    return this;
  }

  /**
   * The progression level required on the Talent Grid in order to be able to activate this talent node. Talent Grids have their own Progression - similar to Character Level, but in this case it is experience related to the item itself.
   * @return activationGridLevel
   */
  @javax.annotation.Nullable
  public Integer getActivationGridLevel() {
    return activationGridLevel;
  }

  public void setActivationGridLevel(Integer activationGridLevel) {
    this.activationGridLevel = activationGridLevel;
  }


  public DestinyDestinyTalentNode hidden(Boolean hidden) {
    this.hidden = hidden;
    return this;
  }

  /**
   * Whether or not the talent node is actually visible in the game&#39;s UI. Whether you want to show it in your own UI is up to you! I&#39;m not gonna tell you who to sock it to.
   * @return hidden
   */
  @javax.annotation.Nullable
  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }


  public DestinyDestinyTalentNode isActivated(Boolean isActivated) {
    this.isActivated = isActivated;
    return this;
  }

  /**
   * If true, the node is activated: it&#39;s current step then provides its benefits.
   * @return isActivated
   */
  @javax.annotation.Nullable
  public Boolean getIsActivated() {
    return isActivated;
  }

  public void setIsActivated(Boolean isActivated) {
    this.isActivated = isActivated;
  }


  public DestinyDestinyTalentNode materialsToUpgrade(List<DestinyDefinitionsDestinyMaterialRequirement> materialsToUpgrade) {
    this.materialsToUpgrade = materialsToUpgrade;
    return this;
  }

  public DestinyDestinyTalentNode addMaterialsToUpgradeItem(DestinyDefinitionsDestinyMaterialRequirement materialsToUpgradeItem) {
    if (this.materialsToUpgrade == null) {
      this.materialsToUpgrade = new ArrayList<>();
    }
    this.materialsToUpgrade.add(materialsToUpgradeItem);
    return this;
  }

  /**
   * If the node has material requirements to be activated, this is the list of those requirements.
   * @return materialsToUpgrade
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyMaterialRequirement> getMaterialsToUpgrade() {
    return materialsToUpgrade;
  }

  public void setMaterialsToUpgrade(List<DestinyDefinitionsDestinyMaterialRequirement> materialsToUpgrade) {
    this.materialsToUpgrade = materialsToUpgrade;
  }


  public DestinyDestinyTalentNode nodeHash(Integer nodeHash) {
    this.nodeHash = nodeHash;
    return this;
  }

  /**
   * The hash of the Talent Node being referred to (in DestinyTalentGridDefinition.nodes). Deceptively CONTENT VERSION DEPENDENT. We have no guarantee of the hash&#39;s immutability between content versions.
   * @return nodeHash
   */
  @javax.annotation.Nullable
  public Integer getNodeHash() {
    return nodeHash;
  }

  public void setNodeHash(Integer nodeHash) {
    this.nodeHash = nodeHash;
  }


  public DestinyDestinyTalentNode nodeIndex(Integer nodeIndex) {
    this.nodeIndex = nodeIndex;
    return this;
  }

  /**
   * The index of the Talent Node being referred to (an index into DestinyTalentGridDefinition.nodes[]). CONTENT VERSION DEPENDENT.
   * @return nodeIndex
   */
  @javax.annotation.Nullable
  public Integer getNodeIndex() {
    return nodeIndex;
  }

  public void setNodeIndex(Integer nodeIndex) {
    this.nodeIndex = nodeIndex;
  }


  public DestinyDestinyTalentNode nodeStatsBlock(DestinyDestinyTalentNodeStatBlock nodeStatsBlock) {
    this.nodeStatsBlock = nodeStatsBlock;
    return this;
  }

  /**
   * This property has some history. A talent grid can provide stats on both the item it&#39;s related to and the character equipping the item. This returns data about those stat bonuses.
   * @return nodeStatsBlock
   */
  @javax.annotation.Nullable
  public DestinyDestinyTalentNodeStatBlock getNodeStatsBlock() {
    return nodeStatsBlock;
  }

  public void setNodeStatsBlock(DestinyDestinyTalentNodeStatBlock nodeStatsBlock) {
    this.nodeStatsBlock = nodeStatsBlock;
  }


  public DestinyDestinyTalentNode progressPercent(Float progressPercent) {
    this.progressPercent = progressPercent;
    return this;
  }

  /**
   * If you want to show a progress bar or circle for how close this talent node is to being activate-able, this is the percentage to show. It follows the node&#39;s underlying rules about when the progress bar should first show up, and when it should be filled.
   * @return progressPercent
   */
  @javax.annotation.Nullable
  public Float getProgressPercent() {
    return progressPercent;
  }

  public void setProgressPercent(Float progressPercent) {
    this.progressPercent = progressPercent;
  }


  public DestinyDestinyTalentNode state(Integer state) {
    this.state = state;
    return this;
  }

  /**
   * An DestinyTalentNodeState enum value indicating the node&#39;s state: whether it can be activated or swapped, and why not if neither can be performed.
   * @return state
   */
  @javax.annotation.Nullable
  public Integer getState() {
    return state;
  }

  public void setState(Integer state) {
    this.state = state;
  }


  public DestinyDestinyTalentNode stepIndex(Integer stepIndex) {
    this.stepIndex = stepIndex;
    return this;
  }

  /**
   * The currently relevant Step for the node. It is this step that has rendering data for the node and the benefits that are provided if the node is activated. (the actual rules for benefits provided are extremely complicated in theory, but with how Talent Grids are being used in Destiny 2 you don&#39;t have to worry about a lot of those old Destiny 1 rules.) This is an index into: DestinyTalentGridDefinition.nodes[nodeIndex].steps[stepIndex]
   * @return stepIndex
   */
  @javax.annotation.Nullable
  public Integer getStepIndex() {
    return stepIndex;
  }

  public void setStepIndex(Integer stepIndex) {
    this.stepIndex = stepIndex;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDestinyTalentNode destinyDestinyTalentNode = (DestinyDestinyTalentNode) o;
    return Objects.equals(this.activationGridLevel, destinyDestinyTalentNode.activationGridLevel) &&
        Objects.equals(this.hidden, destinyDestinyTalentNode.hidden) &&
        Objects.equals(this.isActivated, destinyDestinyTalentNode.isActivated) &&
        Objects.equals(this.materialsToUpgrade, destinyDestinyTalentNode.materialsToUpgrade) &&
        Objects.equals(this.nodeHash, destinyDestinyTalentNode.nodeHash) &&
        Objects.equals(this.nodeIndex, destinyDestinyTalentNode.nodeIndex) &&
        Objects.equals(this.nodeStatsBlock, destinyDestinyTalentNode.nodeStatsBlock) &&
        Objects.equals(this.progressPercent, destinyDestinyTalentNode.progressPercent) &&
        Objects.equals(this.state, destinyDestinyTalentNode.state) &&
        Objects.equals(this.stepIndex, destinyDestinyTalentNode.stepIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationGridLevel, hidden, isActivated, materialsToUpgrade, nodeHash, nodeIndex, nodeStatsBlock, progressPercent, state, stepIndex);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDestinyTalentNode {\n");
    sb.append("    activationGridLevel: ").append(toIndentedString(activationGridLevel)).append("\n");
    sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
    sb.append("    isActivated: ").append(toIndentedString(isActivated)).append("\n");
    sb.append("    materialsToUpgrade: ").append(toIndentedString(materialsToUpgrade)).append("\n");
    sb.append("    nodeHash: ").append(toIndentedString(nodeHash)).append("\n");
    sb.append("    nodeIndex: ").append(toIndentedString(nodeIndex)).append("\n");
    sb.append("    nodeStatsBlock: ").append(toIndentedString(nodeStatsBlock)).append("\n");
    sb.append("    progressPercent: ").append(toIndentedString(progressPercent)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stepIndex: ").append(toIndentedString(stepIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationGridLevel");
    openapiFields.add("hidden");
    openapiFields.add("isActivated");
    openapiFields.add("materialsToUpgrade");
    openapiFields.add("nodeHash");
    openapiFields.add("nodeIndex");
    openapiFields.add("nodeStatsBlock");
    openapiFields.add("progressPercent");
    openapiFields.add("state");
    openapiFields.add("stepIndex");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDestinyTalentNode
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDestinyTalentNode.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDestinyTalentNode is not found in the empty JSON string", DestinyDestinyTalentNode.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDestinyTalentNode.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDestinyTalentNode` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("materialsToUpgrade") != null && !jsonObj.get("materialsToUpgrade").isJsonNull()) {
        JsonArray jsonArraymaterialsToUpgrade = jsonObj.getAsJsonArray("materialsToUpgrade");
        if (jsonArraymaterialsToUpgrade != null) {
          // ensure the json data is an array
          if (!jsonObj.get("materialsToUpgrade").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `materialsToUpgrade` to be an array in the JSON string but got `%s`", jsonObj.get("materialsToUpgrade").toString()));
          }

          // validate the optional field `materialsToUpgrade` (array)
          for (int i = 0; i < jsonArraymaterialsToUpgrade.size(); i++) {
            DestinyDefinitionsDestinyMaterialRequirement.validateJsonElement(jsonArraymaterialsToUpgrade.get(i));
          };
        }
      }
      // validate the optional field `nodeStatsBlock`
      if (jsonObj.get("nodeStatsBlock") != null && !jsonObj.get("nodeStatsBlock").isJsonNull()) {
        DestinyDestinyTalentNodeStatBlock.validateJsonElement(jsonObj.get("nodeStatsBlock"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDestinyTalentNode.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDestinyTalentNode' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDestinyTalentNode> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDestinyTalentNode.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDestinyTalentNode>() {
           @Override
           public void write(JsonWriter out, DestinyDestinyTalentNode value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDestinyTalentNode read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDestinyTalentNode given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDestinyTalentNode
   * @throws IOException if the JSON string is invalid with respect to DestinyDestinyTalentNode
   */
  public static DestinyDestinyTalentNode fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDestinyTalentNode.class);
  }

  /**
   * Convert an instance of DestinyDestinyTalentNode to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

