/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyConstantsDestinyEnvironmentLocationMapping;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityChallengeDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityGraphListEntryDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityGuidedBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityInsertionPointDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityLoadoutRequirementSet;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityModifierReferenceDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityPlaylistItemDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityRewardDefinition;
import org.openapitools.client.model.DestinyDefinitionsDestinyActivityUnlockStringDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The static data about Activities in Destiny 2.  Note that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective - what the user is \&quot;Playing\&quot;.  In most PvE activities, this is fairly straightforward. A Story Activity can only be played in the Story Activity Mode.  However, in PvP activities, the Activity alone only tells you the map being played, or the Playlist that the user chose to enter. You&#39;ll need to know the Activity Mode they&#39;re playing to know that they&#39;re playing Mode X on Map Y.  Activity Definitions tell a great deal of information about what *could* be relevant to a user: what rewards they can earn, what challenges could be performed, what modifiers could be applied. To figure out which of these properties is actually live, you&#39;ll need to combine the definition with \&quot;Live\&quot; data from one of the Destiny endpoints.  Activities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of a source of information than they were in Destiny 1. I will be looking into ways to provide more reliable sources for type information as time goes on, but for now we&#39;re going to have to deal with the limitations. See DestinyActivityTypeDefinition for more information.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyActivityDefinition {
  public static final String SERIALIZED_NAME_ACTIVITY_GRAPH_LIST = "activityGraphList";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_GRAPH_LIST)
  private List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> activityGraphList = new ArrayList<>();

  public static final String SERIALIZED_NAME_ACTIVITY_LIGHT_LEVEL = "activityLightLevel";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_LIGHT_LEVEL)
  private Integer activityLightLevel;

  public static final String SERIALIZED_NAME_ACTIVITY_LOCATION_MAPPINGS = "activityLocationMappings";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_LOCATION_MAPPINGS)
  private List<DestinyConstantsDestinyEnvironmentLocationMapping> activityLocationMappings = new ArrayList<>();

  public static final String SERIALIZED_NAME_ACTIVITY_MODE_HASHES = "activityModeHashes";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_MODE_HASHES)
  private List<Integer> activityModeHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_ACTIVITY_MODE_TYPES = "activityModeTypes";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_MODE_TYPES)
  private List<Integer> activityModeTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_ACTIVITY_TYPE_HASH = "activityTypeHash";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_TYPE_HASH)
  private Integer activityTypeHash;

  public static final String SERIALIZED_NAME_CHALLENGES = "challenges";
  @SerializedName(SERIALIZED_NAME_CHALLENGES)
  private List<DestinyDefinitionsDestinyActivityChallengeDefinition> challenges = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESTINATION_HASH = "destinationHash";
  @SerializedName(SERIALIZED_NAME_DESTINATION_HASH)
  private Integer destinationHash;

  public static final String SERIALIZED_NAME_DIRECT_ACTIVITY_MODE_HASH = "directActivityModeHash";
  @SerializedName(SERIALIZED_NAME_DIRECT_ACTIVITY_MODE_HASH)
  private Integer directActivityModeHash;

  /**
   * If the activity had an activity mode directly defined on it, this will be the enum value of that mode.
   */
  @JsonAdapter(DirectActivityModeTypeEnum.Adapter.class)
  public enum DirectActivityModeTypeEnum {
    NUMBER_0(0),
    
    NUMBER_2(2),
    
    NUMBER_3(3),
    
    NUMBER_4(4),
    
    NUMBER_5(5),
    
    NUMBER_6(6),
    
    NUMBER_7(7),
    
    NUMBER_9(9),
    
    NUMBER_10(10),
    
    NUMBER_11(11),
    
    NUMBER_12(12),
    
    NUMBER_13(13),
    
    NUMBER_15(15),
    
    NUMBER_16(16),
    
    NUMBER_17(17),
    
    NUMBER_18(18),
    
    NUMBER_19(19),
    
    NUMBER_20(20),
    
    NUMBER_21(21),
    
    NUMBER_22(22),
    
    NUMBER_24(24),
    
    NUMBER_25(25),
    
    NUMBER_26(26),
    
    NUMBER_27(27),
    
    NUMBER_28(28),
    
    NUMBER_29(29),
    
    NUMBER_30(30),
    
    NUMBER_31(31),
    
    NUMBER_32(32),
    
    NUMBER_37(37),
    
    NUMBER_38(38),
    
    NUMBER_39(39),
    
    NUMBER_40(40),
    
    NUMBER_41(41),
    
    NUMBER_42(42),
    
    NUMBER_43(43),
    
    NUMBER_44(44),
    
    NUMBER_45(45),
    
    NUMBER_46(46),
    
    NUMBER_47(47),
    
    NUMBER_48(48),
    
    NUMBER_49(49),
    
    NUMBER_50(50),
    
    NUMBER_51(51),
    
    NUMBER_52(52),
    
    NUMBER_53(53),
    
    NUMBER_54(54),
    
    NUMBER_55(55),
    
    NUMBER_56(56),
    
    NUMBER_57(57),
    
    NUMBER_58(58),
    
    NUMBER_59(59),
    
    NUMBER_60(60),
    
    NUMBER_61(61),
    
    NUMBER_62(62),
    
    NUMBER_63(63),
    
    NUMBER_64(64),
    
    NUMBER_65(65),
    
    NUMBER_66(66),
    
    NUMBER_67(67),
    
    NUMBER_68(68),
    
    NUMBER_69(69),
    
    NUMBER_70(70),
    
    NUMBER_71(71),
    
    NUMBER_72(72),
    
    NUMBER_73(73),
    
    NUMBER_74(74),
    
    NUMBER_75(75),
    
    NUMBER_76(76),
    
    NUMBER_77(77),
    
    NUMBER_78(78),
    
    NUMBER_79(79),
    
    NUMBER_80(80),
    
    NUMBER_81(81),
    
    NUMBER_82(82),
    
    NUMBER_83(83),
    
    NUMBER_84(84),
    
    NUMBER_85(85),
    
    NUMBER_86(86),
    
    NUMBER_87(87),
    
    NUMBER_88(88),
    
    NUMBER_89(89),
    
    NUMBER_90(90),
    
    NUMBER_91(91);

    private Integer value;

    DirectActivityModeTypeEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DirectActivityModeTypeEnum fromValue(Integer value) {
      for (DirectActivityModeTypeEnum b : DirectActivityModeTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DirectActivityModeTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DirectActivityModeTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DirectActivityModeTypeEnum read(final JsonReader jsonReader) throws IOException {
        Integer value =  jsonReader.nextInt();
        return DirectActivityModeTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      Integer value = jsonElement.getAsInt();
      DirectActivityModeTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DIRECT_ACTIVITY_MODE_TYPE = "directActivityModeType";
  @SerializedName(SERIALIZED_NAME_DIRECT_ACTIVITY_MODE_TYPE)
  private DirectActivityModeTypeEnum directActivityModeType;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_GUIDED_GAME = "guidedGame";
  @SerializedName(SERIALIZED_NAME_GUIDED_GAME)
  private DestinyDefinitionsDestinyActivityGuidedBlockDefinition guidedGame;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_INSERTION_POINTS = "insertionPoints";
  @SerializedName(SERIALIZED_NAME_INSERTION_POINTS)
  private List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> insertionPoints = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_PLAYLIST = "isPlaylist";
  @SerializedName(SERIALIZED_NAME_IS_PLAYLIST)
  private Boolean isPlaylist;

  public static final String SERIALIZED_NAME_IS_PV_P = "isPvP";
  @SerializedName(SERIALIZED_NAME_IS_PV_P)
  private Boolean isPvP;

  public static final String SERIALIZED_NAME_LOADOUTS = "loadouts";
  @SerializedName(SERIALIZED_NAME_LOADOUTS)
  private List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> loadouts = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCHMAKING = "matchmaking";
  @SerializedName(SERIALIZED_NAME_MATCHMAKING)
  private DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition matchmaking;

  public static final String SERIALIZED_NAME_MODIFIERS = "modifiers";
  @SerializedName(SERIALIZED_NAME_MODIFIERS)
  private List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> modifiers = new ArrayList<>();

  public static final String SERIALIZED_NAME_OPTIONAL_UNLOCK_STRINGS = "optionalUnlockStrings";
  @SerializedName(SERIALIZED_NAME_OPTIONAL_UNLOCK_STRINGS)
  private List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> optionalUnlockStrings = new ArrayList<>();

  public static final String SERIALIZED_NAME_ORIGINAL_DISPLAY_PROPERTIES = "originalDisplayProperties";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition originalDisplayProperties;

  public static final String SERIALIZED_NAME_PGCR_IMAGE = "pgcrImage";
  @SerializedName(SERIALIZED_NAME_PGCR_IMAGE)
  private String pgcrImage;

  public static final String SERIALIZED_NAME_PLACE_HASH = "placeHash";
  @SerializedName(SERIALIZED_NAME_PLACE_HASH)
  private Integer placeHash;

  public static final String SERIALIZED_NAME_PLAYLIST_ITEMS = "playlistItems";
  @SerializedName(SERIALIZED_NAME_PLAYLIST_ITEMS)
  private List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> playlistItems = new ArrayList<>();

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public static final String SERIALIZED_NAME_RELEASE_ICON = "releaseIcon";
  @SerializedName(SERIALIZED_NAME_RELEASE_ICON)
  private String releaseIcon;

  public static final String SERIALIZED_NAME_RELEASE_TIME = "releaseTime";
  @SerializedName(SERIALIZED_NAME_RELEASE_TIME)
  private Integer releaseTime;

  public static final String SERIALIZED_NAME_REWARDS = "rewards";
  @SerializedName(SERIALIZED_NAME_REWARDS)
  private List<DestinyDefinitionsDestinyActivityRewardDefinition> rewards = new ArrayList<>();

  public static final String SERIALIZED_NAME_SELECTION_SCREEN_DISPLAY_PROPERTIES = "selectionScreenDisplayProperties";
  @SerializedName(SERIALIZED_NAME_SELECTION_SCREEN_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition selectionScreenDisplayProperties;

  public static final String SERIALIZED_NAME_TIER = "tier";
  @SerializedName(SERIALIZED_NAME_TIER)
  private Integer tier;

  public DestinyDefinitionsDestinyActivityDefinition() {
  }

  public DestinyDefinitionsDestinyActivityDefinition activityGraphList(List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> activityGraphList) {
    this.activityGraphList = activityGraphList;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addActivityGraphListItem(DestinyDefinitionsDestinyActivityGraphListEntryDefinition activityGraphListItem) {
    if (this.activityGraphList == null) {
      this.activityGraphList = new ArrayList<>();
    }
    this.activityGraphList.add(activityGraphListItem);
    return this;
  }

  /**
   * Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.
   * @return activityGraphList
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> getActivityGraphList() {
    return activityGraphList;
  }

  public void setActivityGraphList(List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> activityGraphList) {
    this.activityGraphList = activityGraphList;
  }


  public DestinyDefinitionsDestinyActivityDefinition activityLightLevel(Integer activityLightLevel) {
    this.activityLightLevel = activityLightLevel;
    return this;
  }

  /**
   * The recommended light level for this activity.
   * @return activityLightLevel
   */
  @javax.annotation.Nullable
  public Integer getActivityLightLevel() {
    return activityLightLevel;
  }

  public void setActivityLightLevel(Integer activityLightLevel) {
    this.activityLightLevel = activityLightLevel;
  }


  public DestinyDefinitionsDestinyActivityDefinition activityLocationMappings(List<DestinyConstantsDestinyEnvironmentLocationMapping> activityLocationMappings) {
    this.activityLocationMappings = activityLocationMappings;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addActivityLocationMappingsItem(DestinyConstantsDestinyEnvironmentLocationMapping activityLocationMappingsItem) {
    if (this.activityLocationMappings == null) {
      this.activityLocationMappings = new ArrayList<>();
    }
    this.activityLocationMappings.add(activityLocationMappingsItem);
    return this;
  }

  /**
   * A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience.
   * @return activityLocationMappings
   */
  @javax.annotation.Nullable
  public List<DestinyConstantsDestinyEnvironmentLocationMapping> getActivityLocationMappings() {
    return activityLocationMappings;
  }

  public void setActivityLocationMappings(List<DestinyConstantsDestinyEnvironmentLocationMapping> activityLocationMappings) {
    this.activityLocationMappings = activityLocationMappings;
  }


  public DestinyDefinitionsDestinyActivityDefinition activityModeHashes(List<Integer> activityModeHashes) {
    this.activityModeHashes = activityModeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addActivityModeHashesItem(Integer activityModeHashesItem) {
    if (this.activityModeHashes == null) {
      this.activityModeHashes = new ArrayList<>();
    }
    this.activityModeHashes.add(activityModeHashesItem);
    return this;
  }

  /**
   * The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant.
   * @return activityModeHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getActivityModeHashes() {
    return activityModeHashes;
  }

  public void setActivityModeHashes(List<Integer> activityModeHashes) {
    this.activityModeHashes = activityModeHashes;
  }


  public DestinyDefinitionsDestinyActivityDefinition activityModeTypes(List<Integer> activityModeTypes) {
    this.activityModeTypes = activityModeTypes;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addActivityModeTypesItem(Integer activityModeTypesItem) {
    if (this.activityModeTypes == null) {
      this.activityModeTypes = new ArrayList<>();
    }
    this.activityModeTypes.add(activityModeTypesItem);
    return this;
  }

  /**
   * The activity modes - if any - in enum form. Because we can&#39;t seem to escape the enums.
   * @return activityModeTypes
   */
  @javax.annotation.Nullable
  public List<Integer> getActivityModeTypes() {
    return activityModeTypes;
  }

  public void setActivityModeTypes(List<Integer> activityModeTypes) {
    this.activityModeTypes = activityModeTypes;
  }


  public DestinyDefinitionsDestinyActivityDefinition activityTypeHash(Integer activityTypeHash) {
    this.activityTypeHash = activityTypeHash;
    return this;
  }

  /**
   * The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You&#39;ll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.
   * @return activityTypeHash
   */
  @javax.annotation.Nullable
  public Integer getActivityTypeHash() {
    return activityTypeHash;
  }

  public void setActivityTypeHash(Integer activityTypeHash) {
    this.activityTypeHash = activityTypeHash;
  }


  public DestinyDefinitionsDestinyActivityDefinition challenges(List<DestinyDefinitionsDestinyActivityChallengeDefinition> challenges) {
    this.challenges = challenges;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addChallengesItem(DestinyDefinitionsDestinyActivityChallengeDefinition challengesItem) {
    if (this.challenges == null) {
      this.challenges = new ArrayList<>();
    }
    this.challenges.add(challengesItem);
    return this;
  }

  /**
   * An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they&#39;re active and what rewards they provide. Sadly, at the moment there&#39;s no central definition for challenges: much like \&quot;Skulls\&quot; were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.
   * @return challenges
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityChallengeDefinition> getChallenges() {
    return challenges;
  }

  public void setChallenges(List<DestinyDefinitionsDestinyActivityChallengeDefinition> challenges) {
    this.challenges = challenges;
  }


  public DestinyDefinitionsDestinyActivityDefinition destinationHash(Integer destinationHash) {
    this.destinationHash = destinationHash;
    return this;
  }

  /**
   * The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \&quot;Place\&quot;. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.
   * @return destinationHash
   */
  @javax.annotation.Nullable
  public Integer getDestinationHash() {
    return destinationHash;
  }

  public void setDestinationHash(Integer destinationHash) {
    this.destinationHash = destinationHash;
  }


  public DestinyDefinitionsDestinyActivityDefinition directActivityModeHash(Integer directActivityModeHash) {
    this.directActivityModeHash = directActivityModeHash;
    return this;
  }

  /**
   * If this activity had an activity mode directly defined on it, this will be the hash of that mode.
   * @return directActivityModeHash
   */
  @javax.annotation.Nullable
  public Integer getDirectActivityModeHash() {
    return directActivityModeHash;
  }

  public void setDirectActivityModeHash(Integer directActivityModeHash) {
    this.directActivityModeHash = directActivityModeHash;
  }


  public DestinyDefinitionsDestinyActivityDefinition directActivityModeType(DirectActivityModeTypeEnum directActivityModeType) {
    this.directActivityModeType = directActivityModeType;
    return this;
  }

  /**
   * If the activity had an activity mode directly defined on it, this will be the enum value of that mode.
   * @return directActivityModeType
   */
  @javax.annotation.Nullable
  public DirectActivityModeTypeEnum getDirectActivityModeType() {
    return directActivityModeType;
  }

  public void setDirectActivityModeType(DirectActivityModeTypeEnum directActivityModeType) {
    this.directActivityModeType = directActivityModeType;
  }


  public DestinyDefinitionsDestinyActivityDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played.
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsDestinyActivityDefinition guidedGame(DestinyDefinitionsDestinyActivityGuidedBlockDefinition guidedGame) {
    this.guidedGame = guidedGame;
    return this;
  }

  /**
   * This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn&#39;t exist, the game is not able to be played as a guided game.
   * @return guidedGame
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyActivityGuidedBlockDefinition getGuidedGame() {
    return guidedGame;
  }

  public void setGuidedGame(DestinyDefinitionsDestinyActivityGuidedBlockDefinition guidedGame) {
    this.guidedGame = guidedGame;
  }


  public DestinyDefinitionsDestinyActivityDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsDestinyActivityDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsDestinyActivityDefinition insertionPoints(List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> insertionPoints) {
    this.insertionPoints = insertionPoints;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addInsertionPointsItem(DestinyDefinitionsDestinyActivityInsertionPointDefinition insertionPointsItem) {
    if (this.insertionPoints == null) {
      this.insertionPoints = new ArrayList<>();
    }
    this.insertionPoints.add(insertionPointsItem);
    return this;
  }

  /**
   * The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability.
   * @return insertionPoints
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> getInsertionPoints() {
    return insertionPoints;
  }

  public void setInsertionPoints(List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> insertionPoints) {
    this.insertionPoints = insertionPoints;
  }


  public DestinyDefinitionsDestinyActivityDefinition isPlaylist(Boolean isPlaylist) {
    this.isPlaylist = isPlaylist;
    return this;
  }

  /**
   * If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.
   * @return isPlaylist
   */
  @javax.annotation.Nullable
  public Boolean getIsPlaylist() {
    return isPlaylist;
  }

  public void setIsPlaylist(Boolean isPlaylist) {
    this.isPlaylist = isPlaylist;
  }


  public DestinyDefinitionsDestinyActivityDefinition isPvP(Boolean isPvP) {
    this.isPvP = isPvP;
    return this;
  }

  /**
   * If true, this activity is a PVP activity or playlist.
   * @return isPvP
   */
  @javax.annotation.Nullable
  public Boolean getIsPvP() {
    return isPvP;
  }

  public void setIsPvP(Boolean isPvP) {
    this.isPvP = isPvP;
  }


  public DestinyDefinitionsDestinyActivityDefinition loadouts(List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> loadouts) {
    this.loadouts = loadouts;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addLoadoutsItem(DestinyDefinitionsDestinyActivityLoadoutRequirementSet loadoutsItem) {
    if (this.loadouts == null) {
      this.loadouts = new ArrayList<>();
    }
    this.loadouts.add(loadoutsItem);
    return this;
  }

  /**
   * The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them.
   * @return loadouts
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> getLoadouts() {
    return loadouts;
  }

  public void setLoadouts(List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> loadouts) {
    this.loadouts = loadouts;
  }


  public DestinyDefinitionsDestinyActivityDefinition matchmaking(DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition matchmaking) {
    this.matchmaking = matchmaking;
    return this;
  }

  /**
   * This block of data provides information about the Activity&#39;s matchmaking attributes: how many people can join and such.
   * @return matchmaking
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition getMatchmaking() {
    return matchmaking;
  }

  public void setMatchmaking(DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition matchmaking) {
    this.matchmaking = matchmaking;
  }


  public DestinyDefinitionsDestinyActivityDefinition modifiers(List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> modifiers) {
    this.modifiers = modifiers;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addModifiersItem(DestinyDefinitionsDestinyActivityModifierReferenceDefinition modifiersItem) {
    if (this.modifiers == null) {
      this.modifiers = new ArrayList<>();
    }
    this.modifiers.add(modifiersItem);
    return this;
  }

  /**
   * Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.
   * @return modifiers
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> getModifiers() {
    return modifiers;
  }

  public void setModifiers(List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> modifiers) {
    this.modifiers = modifiers;
  }


  public DestinyDefinitionsDestinyActivityDefinition optionalUnlockStrings(List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> optionalUnlockStrings) {
    this.optionalUnlockStrings = optionalUnlockStrings;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addOptionalUnlockStringsItem(DestinyDefinitionsDestinyActivityUnlockStringDefinition optionalUnlockStringsItem) {
    if (this.optionalUnlockStrings == null) {
      this.optionalUnlockStrings = new ArrayList<>();
    }
    this.optionalUnlockStrings.add(optionalUnlockStringsItem);
    return this;
  }

  /**
   * If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.
   * @return optionalUnlockStrings
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> getOptionalUnlockStrings() {
    return optionalUnlockStrings;
  }

  public void setOptionalUnlockStrings(List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> optionalUnlockStrings) {
    this.optionalUnlockStrings = optionalUnlockStrings;
  }


  public DestinyDefinitionsDestinyActivityDefinition originalDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition originalDisplayProperties) {
    this.originalDisplayProperties = originalDisplayProperties;
    return this;
  }

  /**
   * The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director).
   * @return originalDisplayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getOriginalDisplayProperties() {
    return originalDisplayProperties;
  }

  public void setOriginalDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition originalDisplayProperties) {
    this.originalDisplayProperties = originalDisplayProperties;
  }


  public DestinyDefinitionsDestinyActivityDefinition pgcrImage(String pgcrImage) {
    this.pgcrImage = pgcrImage;
    return this;
  }

  /**
   * When Activities are completed, we generate a \&quot;Post-Game Carnage Report\&quot;, or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.
   * @return pgcrImage
   */
  @javax.annotation.Nullable
  public String getPgcrImage() {
    return pgcrImage;
  }

  public void setPgcrImage(String pgcrImage) {
    this.pgcrImage = pgcrImage;
  }


  public DestinyDefinitionsDestinyActivityDefinition placeHash(Integer placeHash) {
    this.placeHash = placeHash;
    return this;
  }

  /**
   * The hash identifier for the \&quot;Place\&quot; on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.
   * @return placeHash
   */
  @javax.annotation.Nullable
  public Integer getPlaceHash() {
    return placeHash;
  }

  public void setPlaceHash(Integer placeHash) {
    this.placeHash = placeHash;
  }


  public DestinyDefinitionsDestinyActivityDefinition playlistItems(List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> playlistItems) {
    this.playlistItems = playlistItems;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addPlaylistItemsItem(DestinyDefinitionsDestinyActivityPlaylistItemDefinition playlistItemsItem) {
    if (this.playlistItems == null) {
      this.playlistItems = new ArrayList<>();
    }
    this.playlistItems.add(playlistItemsItem);
    return this;
  }

  /**
   * Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.
   * @return playlistItems
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> getPlaylistItems() {
    return playlistItems;
  }

  public void setPlaylistItems(List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> playlistItems) {
    this.playlistItems = playlistItems;
  }


  public DestinyDefinitionsDestinyActivityDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  public DestinyDefinitionsDestinyActivityDefinition releaseIcon(String releaseIcon) {
    this.releaseIcon = releaseIcon;
    return this;
  }

  /**
   * If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release&#39;s icon.
   * @return releaseIcon
   */
  @javax.annotation.Nullable
  public String getReleaseIcon() {
    return releaseIcon;
  }

  public void setReleaseIcon(String releaseIcon) {
    this.releaseIcon = releaseIcon;
  }


  public DestinyDefinitionsDestinyActivityDefinition releaseTime(Integer releaseTime) {
    this.releaseTime = releaseTime;
    return this;
  }

  /**
   * If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.
   * @return releaseTime
   */
  @javax.annotation.Nullable
  public Integer getReleaseTime() {
    return releaseTime;
  }

  public void setReleaseTime(Integer releaseTime) {
    this.releaseTime = releaseTime;
  }


  public DestinyDefinitionsDestinyActivityDefinition rewards(List<DestinyDefinitionsDestinyActivityRewardDefinition> rewards) {
    this.rewards = rewards;
    return this;
  }

  public DestinyDefinitionsDestinyActivityDefinition addRewardsItem(DestinyDefinitionsDestinyActivityRewardDefinition rewardsItem) {
    if (this.rewards == null) {
      this.rewards = new ArrayList<>();
    }
    this.rewards.add(rewardsItem);
    return this;
  }

  /**
   * The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game&#39;s state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \&quot;Dummy\&quot; items: items that tell you what you can earn in vague terms rather than what you&#39;ll specifically be earning (partly because the game doesn&#39;t even know what you&#39;ll earn specifically until you roll for it at the end)
   * @return rewards
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsDestinyActivityRewardDefinition> getRewards() {
    return rewards;
  }

  public void setRewards(List<DestinyDefinitionsDestinyActivityRewardDefinition> rewards) {
    this.rewards = rewards;
  }


  public DestinyDefinitionsDestinyActivityDefinition selectionScreenDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition selectionScreenDisplayProperties) {
    this.selectionScreenDisplayProperties = selectionScreenDisplayProperties;
    return this;
  }

  /**
   * The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won&#39;t be data in this field if the activity is never shown in a selection/options screen.
   * @return selectionScreenDisplayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getSelectionScreenDisplayProperties() {
    return selectionScreenDisplayProperties;
  }

  public void setSelectionScreenDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition selectionScreenDisplayProperties) {
    this.selectionScreenDisplayProperties = selectionScreenDisplayProperties;
  }


  public DestinyDefinitionsDestinyActivityDefinition tier(Integer tier) {
    this.tier = tier;
    return this;
  }

  /**
   * The difficulty tier of the activity.
   * @return tier
   */
  @javax.annotation.Nullable
  public Integer getTier() {
    return tier;
  }

  public void setTier(Integer tier) {
    this.tier = tier;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyActivityDefinition destinyDefinitionsDestinyActivityDefinition = (DestinyDefinitionsDestinyActivityDefinition) o;
    return Objects.equals(this.activityGraphList, destinyDefinitionsDestinyActivityDefinition.activityGraphList) &&
        Objects.equals(this.activityLightLevel, destinyDefinitionsDestinyActivityDefinition.activityLightLevel) &&
        Objects.equals(this.activityLocationMappings, destinyDefinitionsDestinyActivityDefinition.activityLocationMappings) &&
        Objects.equals(this.activityModeHashes, destinyDefinitionsDestinyActivityDefinition.activityModeHashes) &&
        Objects.equals(this.activityModeTypes, destinyDefinitionsDestinyActivityDefinition.activityModeTypes) &&
        Objects.equals(this.activityTypeHash, destinyDefinitionsDestinyActivityDefinition.activityTypeHash) &&
        Objects.equals(this.challenges, destinyDefinitionsDestinyActivityDefinition.challenges) &&
        Objects.equals(this.destinationHash, destinyDefinitionsDestinyActivityDefinition.destinationHash) &&
        Objects.equals(this.directActivityModeHash, destinyDefinitionsDestinyActivityDefinition.directActivityModeHash) &&
        Objects.equals(this.directActivityModeType, destinyDefinitionsDestinyActivityDefinition.directActivityModeType) &&
        Objects.equals(this.displayProperties, destinyDefinitionsDestinyActivityDefinition.displayProperties) &&
        Objects.equals(this.guidedGame, destinyDefinitionsDestinyActivityDefinition.guidedGame) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyActivityDefinition.hash) &&
        Objects.equals(this.index, destinyDefinitionsDestinyActivityDefinition.index) &&
        Objects.equals(this.insertionPoints, destinyDefinitionsDestinyActivityDefinition.insertionPoints) &&
        Objects.equals(this.isPlaylist, destinyDefinitionsDestinyActivityDefinition.isPlaylist) &&
        Objects.equals(this.isPvP, destinyDefinitionsDestinyActivityDefinition.isPvP) &&
        Objects.equals(this.loadouts, destinyDefinitionsDestinyActivityDefinition.loadouts) &&
        Objects.equals(this.matchmaking, destinyDefinitionsDestinyActivityDefinition.matchmaking) &&
        Objects.equals(this.modifiers, destinyDefinitionsDestinyActivityDefinition.modifiers) &&
        Objects.equals(this.optionalUnlockStrings, destinyDefinitionsDestinyActivityDefinition.optionalUnlockStrings) &&
        Objects.equals(this.originalDisplayProperties, destinyDefinitionsDestinyActivityDefinition.originalDisplayProperties) &&
        Objects.equals(this.pgcrImage, destinyDefinitionsDestinyActivityDefinition.pgcrImage) &&
        Objects.equals(this.placeHash, destinyDefinitionsDestinyActivityDefinition.placeHash) &&
        Objects.equals(this.playlistItems, destinyDefinitionsDestinyActivityDefinition.playlistItems) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyActivityDefinition.redacted) &&
        Objects.equals(this.releaseIcon, destinyDefinitionsDestinyActivityDefinition.releaseIcon) &&
        Objects.equals(this.releaseTime, destinyDefinitionsDestinyActivityDefinition.releaseTime) &&
        Objects.equals(this.rewards, destinyDefinitionsDestinyActivityDefinition.rewards) &&
        Objects.equals(this.selectionScreenDisplayProperties, destinyDefinitionsDestinyActivityDefinition.selectionScreenDisplayProperties) &&
        Objects.equals(this.tier, destinyDefinitionsDestinyActivityDefinition.tier);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activityGraphList, activityLightLevel, activityLocationMappings, activityModeHashes, activityModeTypes, activityTypeHash, challenges, destinationHash, directActivityModeHash, directActivityModeType, displayProperties, guidedGame, hash, index, insertionPoints, isPlaylist, isPvP, loadouts, matchmaking, modifiers, optionalUnlockStrings, originalDisplayProperties, pgcrImage, placeHash, playlistItems, redacted, releaseIcon, releaseTime, rewards, selectionScreenDisplayProperties, tier);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyActivityDefinition {\n");
    sb.append("    activityGraphList: ").append(toIndentedString(activityGraphList)).append("\n");
    sb.append("    activityLightLevel: ").append(toIndentedString(activityLightLevel)).append("\n");
    sb.append("    activityLocationMappings: ").append(toIndentedString(activityLocationMappings)).append("\n");
    sb.append("    activityModeHashes: ").append(toIndentedString(activityModeHashes)).append("\n");
    sb.append("    activityModeTypes: ").append(toIndentedString(activityModeTypes)).append("\n");
    sb.append("    activityTypeHash: ").append(toIndentedString(activityTypeHash)).append("\n");
    sb.append("    challenges: ").append(toIndentedString(challenges)).append("\n");
    sb.append("    destinationHash: ").append(toIndentedString(destinationHash)).append("\n");
    sb.append("    directActivityModeHash: ").append(toIndentedString(directActivityModeHash)).append("\n");
    sb.append("    directActivityModeType: ").append(toIndentedString(directActivityModeType)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    guidedGame: ").append(toIndentedString(guidedGame)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    insertionPoints: ").append(toIndentedString(insertionPoints)).append("\n");
    sb.append("    isPlaylist: ").append(toIndentedString(isPlaylist)).append("\n");
    sb.append("    isPvP: ").append(toIndentedString(isPvP)).append("\n");
    sb.append("    loadouts: ").append(toIndentedString(loadouts)).append("\n");
    sb.append("    matchmaking: ").append(toIndentedString(matchmaking)).append("\n");
    sb.append("    modifiers: ").append(toIndentedString(modifiers)).append("\n");
    sb.append("    optionalUnlockStrings: ").append(toIndentedString(optionalUnlockStrings)).append("\n");
    sb.append("    originalDisplayProperties: ").append(toIndentedString(originalDisplayProperties)).append("\n");
    sb.append("    pgcrImage: ").append(toIndentedString(pgcrImage)).append("\n");
    sb.append("    placeHash: ").append(toIndentedString(placeHash)).append("\n");
    sb.append("    playlistItems: ").append(toIndentedString(playlistItems)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("    releaseIcon: ").append(toIndentedString(releaseIcon)).append("\n");
    sb.append("    releaseTime: ").append(toIndentedString(releaseTime)).append("\n");
    sb.append("    rewards: ").append(toIndentedString(rewards)).append("\n");
    sb.append("    selectionScreenDisplayProperties: ").append(toIndentedString(selectionScreenDisplayProperties)).append("\n");
    sb.append("    tier: ").append(toIndentedString(tier)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activityGraphList");
    openapiFields.add("activityLightLevel");
    openapiFields.add("activityLocationMappings");
    openapiFields.add("activityModeHashes");
    openapiFields.add("activityModeTypes");
    openapiFields.add("activityTypeHash");
    openapiFields.add("challenges");
    openapiFields.add("destinationHash");
    openapiFields.add("directActivityModeHash");
    openapiFields.add("directActivityModeType");
    openapiFields.add("displayProperties");
    openapiFields.add("guidedGame");
    openapiFields.add("hash");
    openapiFields.add("index");
    openapiFields.add("insertionPoints");
    openapiFields.add("isPlaylist");
    openapiFields.add("isPvP");
    openapiFields.add("loadouts");
    openapiFields.add("matchmaking");
    openapiFields.add("modifiers");
    openapiFields.add("optionalUnlockStrings");
    openapiFields.add("originalDisplayProperties");
    openapiFields.add("pgcrImage");
    openapiFields.add("placeHash");
    openapiFields.add("playlistItems");
    openapiFields.add("redacted");
    openapiFields.add("releaseIcon");
    openapiFields.add("releaseTime");
    openapiFields.add("rewards");
    openapiFields.add("selectionScreenDisplayProperties");
    openapiFields.add("tier");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyActivityDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyActivityDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyActivityDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyActivityDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyActivityDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyActivityDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("activityGraphList") != null && !jsonObj.get("activityGraphList").isJsonNull()) {
        JsonArray jsonArrayactivityGraphList = jsonObj.getAsJsonArray("activityGraphList");
        if (jsonArrayactivityGraphList != null) {
          // ensure the json data is an array
          if (!jsonObj.get("activityGraphList").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `activityGraphList` to be an array in the JSON string but got `%s`", jsonObj.get("activityGraphList").toString()));
          }

          // validate the optional field `activityGraphList` (array)
          for (int i = 0; i < jsonArrayactivityGraphList.size(); i++) {
            DestinyDefinitionsDestinyActivityGraphListEntryDefinition.validateJsonElement(jsonArrayactivityGraphList.get(i));
          };
        }
      }
      if (jsonObj.get("activityLocationMappings") != null && !jsonObj.get("activityLocationMappings").isJsonNull()) {
        JsonArray jsonArrayactivityLocationMappings = jsonObj.getAsJsonArray("activityLocationMappings");
        if (jsonArrayactivityLocationMappings != null) {
          // ensure the json data is an array
          if (!jsonObj.get("activityLocationMappings").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `activityLocationMappings` to be an array in the JSON string but got `%s`", jsonObj.get("activityLocationMappings").toString()));
          }

          // validate the optional field `activityLocationMappings` (array)
          for (int i = 0; i < jsonArrayactivityLocationMappings.size(); i++) {
            DestinyConstantsDestinyEnvironmentLocationMapping.validateJsonElement(jsonArrayactivityLocationMappings.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("activityModeHashes") != null && !jsonObj.get("activityModeHashes").isJsonNull() && !jsonObj.get("activityModeHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `activityModeHashes` to be an array in the JSON string but got `%s`", jsonObj.get("activityModeHashes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("activityModeTypes") != null && !jsonObj.get("activityModeTypes").isJsonNull() && !jsonObj.get("activityModeTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `activityModeTypes` to be an array in the JSON string but got `%s`", jsonObj.get("activityModeTypes").toString()));
      }
      if (jsonObj.get("challenges") != null && !jsonObj.get("challenges").isJsonNull()) {
        JsonArray jsonArraychallenges = jsonObj.getAsJsonArray("challenges");
        if (jsonArraychallenges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("challenges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `challenges` to be an array in the JSON string but got `%s`", jsonObj.get("challenges").toString()));
          }

          // validate the optional field `challenges` (array)
          for (int i = 0; i < jsonArraychallenges.size(); i++) {
            DestinyDefinitionsDestinyActivityChallengeDefinition.validateJsonElement(jsonArraychallenges.get(i));
          };
        }
      }
      // validate the optional field `directActivityModeType`
      if (jsonObj.get("directActivityModeType") != null && !jsonObj.get("directActivityModeType").isJsonNull()) {
        DirectActivityModeTypeEnum.validateJsonElement(jsonObj.get("directActivityModeType"));
      }
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      // validate the optional field `guidedGame`
      if (jsonObj.get("guidedGame") != null && !jsonObj.get("guidedGame").isJsonNull()) {
        DestinyDefinitionsDestinyActivityGuidedBlockDefinition.validateJsonElement(jsonObj.get("guidedGame"));
      }
      if (jsonObj.get("insertionPoints") != null && !jsonObj.get("insertionPoints").isJsonNull()) {
        JsonArray jsonArrayinsertionPoints = jsonObj.getAsJsonArray("insertionPoints");
        if (jsonArrayinsertionPoints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("insertionPoints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `insertionPoints` to be an array in the JSON string but got `%s`", jsonObj.get("insertionPoints").toString()));
          }

          // validate the optional field `insertionPoints` (array)
          for (int i = 0; i < jsonArrayinsertionPoints.size(); i++) {
            DestinyDefinitionsDestinyActivityInsertionPointDefinition.validateJsonElement(jsonArrayinsertionPoints.get(i));
          };
        }
      }
      if (jsonObj.get("loadouts") != null && !jsonObj.get("loadouts").isJsonNull()) {
        JsonArray jsonArrayloadouts = jsonObj.getAsJsonArray("loadouts");
        if (jsonArrayloadouts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("loadouts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `loadouts` to be an array in the JSON string but got `%s`", jsonObj.get("loadouts").toString()));
          }

          // validate the optional field `loadouts` (array)
          for (int i = 0; i < jsonArrayloadouts.size(); i++) {
            DestinyDefinitionsDestinyActivityLoadoutRequirementSet.validateJsonElement(jsonArrayloadouts.get(i));
          };
        }
      }
      // validate the optional field `matchmaking`
      if (jsonObj.get("matchmaking") != null && !jsonObj.get("matchmaking").isJsonNull()) {
        DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition.validateJsonElement(jsonObj.get("matchmaking"));
      }
      if (jsonObj.get("modifiers") != null && !jsonObj.get("modifiers").isJsonNull()) {
        JsonArray jsonArraymodifiers = jsonObj.getAsJsonArray("modifiers");
        if (jsonArraymodifiers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("modifiers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `modifiers` to be an array in the JSON string but got `%s`", jsonObj.get("modifiers").toString()));
          }

          // validate the optional field `modifiers` (array)
          for (int i = 0; i < jsonArraymodifiers.size(); i++) {
            DestinyDefinitionsDestinyActivityModifierReferenceDefinition.validateJsonElement(jsonArraymodifiers.get(i));
          };
        }
      }
      if (jsonObj.get("optionalUnlockStrings") != null && !jsonObj.get("optionalUnlockStrings").isJsonNull()) {
        JsonArray jsonArrayoptionalUnlockStrings = jsonObj.getAsJsonArray("optionalUnlockStrings");
        if (jsonArrayoptionalUnlockStrings != null) {
          // ensure the json data is an array
          if (!jsonObj.get("optionalUnlockStrings").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `optionalUnlockStrings` to be an array in the JSON string but got `%s`", jsonObj.get("optionalUnlockStrings").toString()));
          }

          // validate the optional field `optionalUnlockStrings` (array)
          for (int i = 0; i < jsonArrayoptionalUnlockStrings.size(); i++) {
            DestinyDefinitionsDestinyActivityUnlockStringDefinition.validateJsonElement(jsonArrayoptionalUnlockStrings.get(i));
          };
        }
      }
      // validate the optional field `originalDisplayProperties`
      if (jsonObj.get("originalDisplayProperties") != null && !jsonObj.get("originalDisplayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("originalDisplayProperties"));
      }
      if ((jsonObj.get("pgcrImage") != null && !jsonObj.get("pgcrImage").isJsonNull()) && !jsonObj.get("pgcrImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pgcrImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pgcrImage").toString()));
      }
      if (jsonObj.get("playlistItems") != null && !jsonObj.get("playlistItems").isJsonNull()) {
        JsonArray jsonArrayplaylistItems = jsonObj.getAsJsonArray("playlistItems");
        if (jsonArrayplaylistItems != null) {
          // ensure the json data is an array
          if (!jsonObj.get("playlistItems").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `playlistItems` to be an array in the JSON string but got `%s`", jsonObj.get("playlistItems").toString()));
          }

          // validate the optional field `playlistItems` (array)
          for (int i = 0; i < jsonArrayplaylistItems.size(); i++) {
            DestinyDefinitionsDestinyActivityPlaylistItemDefinition.validateJsonElement(jsonArrayplaylistItems.get(i));
          };
        }
      }
      if ((jsonObj.get("releaseIcon") != null && !jsonObj.get("releaseIcon").isJsonNull()) && !jsonObj.get("releaseIcon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `releaseIcon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("releaseIcon").toString()));
      }
      if (jsonObj.get("rewards") != null && !jsonObj.get("rewards").isJsonNull()) {
        JsonArray jsonArrayrewards = jsonObj.getAsJsonArray("rewards");
        if (jsonArrayrewards != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rewards").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rewards` to be an array in the JSON string but got `%s`", jsonObj.get("rewards").toString()));
          }

          // validate the optional field `rewards` (array)
          for (int i = 0; i < jsonArrayrewards.size(); i++) {
            DestinyDefinitionsDestinyActivityRewardDefinition.validateJsonElement(jsonArrayrewards.get(i));
          };
        }
      }
      // validate the optional field `selectionScreenDisplayProperties`
      if (jsonObj.get("selectionScreenDisplayProperties") != null && !jsonObj.get("selectionScreenDisplayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("selectionScreenDisplayProperties"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyActivityDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyActivityDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyActivityDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyActivityDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyActivityDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyActivityDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyActivityDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyActivityDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyActivityDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyActivityDefinition
   */
  public static DestinyDefinitionsDestinyActivityDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyActivityDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyActivityDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

