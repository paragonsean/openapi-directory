/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This definition represents an \&quot;Activity Mode\&quot; as it exists in the Historical Stats endpoints. An individual Activity Mode represents a collection of activities that are played in a certain way. For example, Nightfall Strikes are part of a \&quot;Nightfall\&quot; activity mode, and any activities played as the PVP mode \&quot;Clash\&quot; are part of the \&quot;Clash activity mode.  Activity modes are nested under each other in a hierarchy, so that if you ask for - for example - \&quot;AllPvP\&quot;, you will get any PVP activities that the user has played, regardless of what specific PVP mode was being played.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsDestinyActivityModeDefinition {
  public static final String SERIALIZED_NAME_ACTIVITY_MODE_CATEGORY = "activityModeCategory";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_MODE_CATEGORY)
  private Integer activityModeCategory;

  public static final String SERIALIZED_NAME_ACTIVITY_MODE_MAPPINGS = "activityModeMappings";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_MODE_MAPPINGS)
  private Map<String, Integer> activityModeMappings = new HashMap<>();

  public static final String SERIALIZED_NAME_DISPLAY = "display";
  @SerializedName(SERIALIZED_NAME_DISPLAY)
  private Boolean display;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_FRIENDLY_NAME = "friendlyName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_NAME)
  private String friendlyName;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_IS_AGGREGATE_MODE = "isAggregateMode";
  @SerializedName(SERIALIZED_NAME_IS_AGGREGATE_MODE)
  private Boolean isAggregateMode;

  public static final String SERIALIZED_NAME_IS_TEAM_BASED = "isTeamBased";
  @SerializedName(SERIALIZED_NAME_IS_TEAM_BASED)
  private Boolean isTeamBased;

  public static final String SERIALIZED_NAME_MODE_TYPE = "modeType";
  @SerializedName(SERIALIZED_NAME_MODE_TYPE)
  private Integer modeType;

  public static final String SERIALIZED_NAME_ORDER = "order";
  @SerializedName(SERIALIZED_NAME_ORDER)
  private Integer order;

  public static final String SERIALIZED_NAME_PARENT_HASHES = "parentHashes";
  @SerializedName(SERIALIZED_NAME_PARENT_HASHES)
  private List<Integer> parentHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PGCR_IMAGE = "pgcrImage";
  @SerializedName(SERIALIZED_NAME_PGCR_IMAGE)
  private String pgcrImage;

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public DestinyDefinitionsDestinyActivityModeDefinition() {
  }

  public DestinyDefinitionsDestinyActivityModeDefinition activityModeCategory(Integer activityModeCategory) {
    this.activityModeCategory = activityModeCategory;
    return this;
  }

  /**
   * The type of play being performed in broad terms (PVP, PVE)
   * @return activityModeCategory
   */
  @javax.annotation.Nullable
  public Integer getActivityModeCategory() {
    return activityModeCategory;
  }

  public void setActivityModeCategory(Integer activityModeCategory) {
    this.activityModeCategory = activityModeCategory;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition activityModeMappings(Map<String, Integer> activityModeMappings) {
    this.activityModeMappings = activityModeMappings;
    return this;
  }

  public DestinyDefinitionsDestinyActivityModeDefinition putActivityModeMappingsItem(String key, Integer activityModeMappingsItem) {
    if (this.activityModeMappings == null) {
      this.activityModeMappings = new HashMap<>();
    }
    this.activityModeMappings.put(key, activityModeMappingsItem);
    return this;
  }

  /**
   * If this exists, the mode has specific Activities (referred to by the Key) that should instead map to other Activity Modes when they are played. This was useful in D1 for Private Matches, where we wanted to have Private Matches as an activity mode while still referring to the specific mode being played.
   * @return activityModeMappings
   */
  @javax.annotation.Nullable
  public Map<String, Integer> getActivityModeMappings() {
    return activityModeMappings;
  }

  public void setActivityModeMappings(Map<String, Integer> activityModeMappings) {
    this.activityModeMappings = activityModeMappings;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition display(Boolean display) {
    this.display = display;
    return this;
  }

  /**
   * If FALSE, we want to ignore this type when we&#39;re showing activity modes in BNet UI. It will still be returned in case 3rd parties want to use it for any purpose.
   * @return display
   */
  @javax.annotation.Nullable
  public Boolean getDisplay() {
    return display;
  }

  public void setDisplay(Boolean display) {
    this.display = display;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * Get displayProperties
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition friendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
    return this;
  }

  /**
   * A Friendly identifier you can use for referring to this Activity Mode. We really only used this in our URLs, so... you know, take that for whatever it&#39;s worth.
   * @return friendlyName
   */
  @javax.annotation.Nullable
  public String getFriendlyName() {
    return friendlyName;
  }

  public void setFriendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition isAggregateMode(Boolean isAggregateMode) {
    this.isAggregateMode = isAggregateMode;
    return this;
  }

  /**
   * If true, this mode is an aggregation of other, more specific modes rather than being a mode in itself. This includes modes that group Features/Events rather than Gameplay, such as Trials of The Nine: Trials of the Nine being an Event that is interesting to see aggregate data for, but when you play the activities within Trials of the Nine they are more specific activity modes such as Clash.
   * @return isAggregateMode
   */
  @javax.annotation.Nullable
  public Boolean getIsAggregateMode() {
    return isAggregateMode;
  }

  public void setIsAggregateMode(Boolean isAggregateMode) {
    this.isAggregateMode = isAggregateMode;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition isTeamBased(Boolean isTeamBased) {
    this.isTeamBased = isTeamBased;
    return this;
  }

  /**
   * If True, this mode has oppositional teams fighting against each other rather than \&quot;Free-For-All\&quot; or Co-operative modes of play.  Note that Aggregate modes are never marked as team based, even if they happen to be team based at the moment. At any time, an aggregate whose subordinates are only team based could be changed so that one or more aren&#39;t team based, and then this boolean won&#39;t make much sense (the aggregation would become \&quot;sometimes team based\&quot;). Let&#39;s not deal with that right now.
   * @return isTeamBased
   */
  @javax.annotation.Nullable
  public Boolean getIsTeamBased() {
    return isTeamBased;
  }

  public void setIsTeamBased(Boolean isTeamBased) {
    this.isTeamBased = isTeamBased;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition modeType(Integer modeType) {
    this.modeType = modeType;
    return this;
  }

  /**
   * The Enumeration value for this Activity Mode. Pass this identifier into Stats endpoints to get aggregate stats for this mode.
   * @return modeType
   */
  @javax.annotation.Nullable
  public Integer getModeType() {
    return modeType;
  }

  public void setModeType(Integer modeType) {
    this.modeType = modeType;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition order(Integer order) {
    this.order = order;
    return this;
  }

  /**
   * The relative ordering of activity modes.
   * @return order
   */
  @javax.annotation.Nullable
  public Integer getOrder() {
    return order;
  }

  public void setOrder(Integer order) {
    this.order = order;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition parentHashes(List<Integer> parentHashes) {
    this.parentHashes = parentHashes;
    return this;
  }

  public DestinyDefinitionsDestinyActivityModeDefinition addParentHashesItem(Integer parentHashesItem) {
    if (this.parentHashes == null) {
      this.parentHashes = new ArrayList<>();
    }
    this.parentHashes.add(parentHashesItem);
    return this;
  }

  /**
   * The hash identifiers of the DestinyActivityModeDefinitions that represent all of the \&quot;parent\&quot; modes for this mode. For instance, the Nightfall Mode is also a member of AllStrikes and AllPvE.
   * @return parentHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getParentHashes() {
    return parentHashes;
  }

  public void setParentHashes(List<Integer> parentHashes) {
    this.parentHashes = parentHashes;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition pgcrImage(String pgcrImage) {
    this.pgcrImage = pgcrImage;
    return this;
  }

  /**
   * If this activity mode has a related PGCR image, this will be the path to said image.
   * @return pgcrImage
   */
  @javax.annotation.Nullable
  public String getPgcrImage() {
    return pgcrImage;
  }

  public void setPgcrImage(String pgcrImage) {
    this.pgcrImage = pgcrImage;
  }


  public DestinyDefinitionsDestinyActivityModeDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyActivityModeDefinition destinyDefinitionsDestinyActivityModeDefinition = (DestinyDefinitionsDestinyActivityModeDefinition) o;
    return Objects.equals(this.activityModeCategory, destinyDefinitionsDestinyActivityModeDefinition.activityModeCategory) &&
        Objects.equals(this.activityModeMappings, destinyDefinitionsDestinyActivityModeDefinition.activityModeMappings) &&
        Objects.equals(this.display, destinyDefinitionsDestinyActivityModeDefinition.display) &&
        Objects.equals(this.displayProperties, destinyDefinitionsDestinyActivityModeDefinition.displayProperties) &&
        Objects.equals(this.friendlyName, destinyDefinitionsDestinyActivityModeDefinition.friendlyName) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyActivityModeDefinition.hash) &&
        Objects.equals(this.index, destinyDefinitionsDestinyActivityModeDefinition.index) &&
        Objects.equals(this.isAggregateMode, destinyDefinitionsDestinyActivityModeDefinition.isAggregateMode) &&
        Objects.equals(this.isTeamBased, destinyDefinitionsDestinyActivityModeDefinition.isTeamBased) &&
        Objects.equals(this.modeType, destinyDefinitionsDestinyActivityModeDefinition.modeType) &&
        Objects.equals(this.order, destinyDefinitionsDestinyActivityModeDefinition.order) &&
        Objects.equals(this.parentHashes, destinyDefinitionsDestinyActivityModeDefinition.parentHashes) &&
        Objects.equals(this.pgcrImage, destinyDefinitionsDestinyActivityModeDefinition.pgcrImage) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyActivityModeDefinition.redacted);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activityModeCategory, activityModeMappings, display, displayProperties, friendlyName, hash, index, isAggregateMode, isTeamBased, modeType, order, parentHashes, pgcrImage, redacted);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyActivityModeDefinition {\n");
    sb.append("    activityModeCategory: ").append(toIndentedString(activityModeCategory)).append("\n");
    sb.append("    activityModeMappings: ").append(toIndentedString(activityModeMappings)).append("\n");
    sb.append("    display: ").append(toIndentedString(display)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    friendlyName: ").append(toIndentedString(friendlyName)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    isAggregateMode: ").append(toIndentedString(isAggregateMode)).append("\n");
    sb.append("    isTeamBased: ").append(toIndentedString(isTeamBased)).append("\n");
    sb.append("    modeType: ").append(toIndentedString(modeType)).append("\n");
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("    parentHashes: ").append(toIndentedString(parentHashes)).append("\n");
    sb.append("    pgcrImage: ").append(toIndentedString(pgcrImage)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activityModeCategory");
    openapiFields.add("activityModeMappings");
    openapiFields.add("display");
    openapiFields.add("displayProperties");
    openapiFields.add("friendlyName");
    openapiFields.add("hash");
    openapiFields.add("index");
    openapiFields.add("isAggregateMode");
    openapiFields.add("isTeamBased");
    openapiFields.add("modeType");
    openapiFields.add("order");
    openapiFields.add("parentHashes");
    openapiFields.add("pgcrImage");
    openapiFields.add("redacted");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsDestinyActivityModeDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsDestinyActivityModeDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsDestinyActivityModeDefinition is not found in the empty JSON string", DestinyDefinitionsDestinyActivityModeDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsDestinyActivityModeDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsDestinyActivityModeDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      if ((jsonObj.get("friendlyName") != null && !jsonObj.get("friendlyName").isJsonNull()) && !jsonObj.get("friendlyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlyName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("parentHashes") != null && !jsonObj.get("parentHashes").isJsonNull() && !jsonObj.get("parentHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentHashes` to be an array in the JSON string but got `%s`", jsonObj.get("parentHashes").toString()));
      }
      if ((jsonObj.get("pgcrImage") != null && !jsonObj.get("pgcrImage").isJsonNull()) && !jsonObj.get("pgcrImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pgcrImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pgcrImage").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsDestinyActivityModeDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsDestinyActivityModeDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsDestinyActivityModeDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsDestinyActivityModeDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsDestinyActivityModeDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsDestinyActivityModeDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsDestinyActivityModeDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsDestinyActivityModeDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsDestinyActivityModeDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsDestinyActivityModeDefinition
   */
  public static DestinyDefinitionsDestinyActivityModeDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsDestinyActivityModeDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsDestinyActivityModeDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

