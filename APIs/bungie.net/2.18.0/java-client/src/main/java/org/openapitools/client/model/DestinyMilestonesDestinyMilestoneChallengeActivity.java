/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DestinyChallengesDestinyChallengeStatus;
import org.openapitools.client.model.DestinyMilestonesDestinyMilestoneActivityPhase;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DestinyMilestonesDestinyMilestoneChallengeActivity
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyMilestonesDestinyMilestoneChallengeActivity {
  public static final String SERIALIZED_NAME_ACTIVITY_HASH = "activityHash";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_HASH)
  private Integer activityHash;

  public static final String SERIALIZED_NAME_BOOLEAN_ACTIVITY_OPTIONS = "booleanActivityOptions";
  @SerializedName(SERIALIZED_NAME_BOOLEAN_ACTIVITY_OPTIONS)
  private Map<String, Boolean> booleanActivityOptions = new HashMap<>();

  public static final String SERIALIZED_NAME_CHALLENGES = "challenges";
  @SerializedName(SERIALIZED_NAME_CHALLENGES)
  private List<DestinyChallengesDestinyChallengeStatus> challenges = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOADOUT_REQUIREMENT_INDEX = "loadoutRequirementIndex";
  @SerializedName(SERIALIZED_NAME_LOADOUT_REQUIREMENT_INDEX)
  private Integer loadoutRequirementIndex;

  public static final String SERIALIZED_NAME_MODIFIER_HASHES = "modifierHashes";
  @SerializedName(SERIALIZED_NAME_MODIFIER_HASHES)
  private List<Integer> modifierHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PHASES = "phases";
  @SerializedName(SERIALIZED_NAME_PHASES)
  private List<DestinyMilestonesDestinyMilestoneActivityPhase> phases = new ArrayList<>();

  public DestinyMilestonesDestinyMilestoneChallengeActivity() {
  }

  public DestinyMilestonesDestinyMilestoneChallengeActivity activityHash(Integer activityHash) {
    this.activityHash = activityHash;
    return this;
  }

  /**
   * Get activityHash
   * @return activityHash
   */
  @javax.annotation.Nullable
  public Integer getActivityHash() {
    return activityHash;
  }

  public void setActivityHash(Integer activityHash) {
    this.activityHash = activityHash;
  }


  public DestinyMilestonesDestinyMilestoneChallengeActivity booleanActivityOptions(Map<String, Boolean> booleanActivityOptions) {
    this.booleanActivityOptions = booleanActivityOptions;
    return this;
  }

  public DestinyMilestonesDestinyMilestoneChallengeActivity putBooleanActivityOptionsItem(String key, Boolean booleanActivityOptionsItem) {
    if (this.booleanActivityOptions == null) {
      this.booleanActivityOptions = new HashMap<>();
    }
    this.booleanActivityOptions.put(key, booleanActivityOptionsItem);
    return this;
  }

  /**
   * The set of activity options for this activity, keyed by an identifier that&#39;s unique for this activity (not guaranteed to be unique between or across all activities, though should be unique for every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many variant DestinyActivityDefinitions. While other activities could potentially have the same option hashes, for any given D2 base Raid variant the hash will be unique).  As a concrete example of this data, the hashes you get for Raids will correspond to the currently active \&quot;Challenge Mode\&quot;.  We don&#39;t have any human readable information for these, but saavy 3rd party app users could manually associate the key (a hash identifier for the \&quot;option\&quot; that is enabled/disabled) and the value (whether it&#39;s enabled or disabled presently)  On our side, we don&#39;t necessarily even know what these are used for (the game designers know, but we don&#39;t), and we have no human readable data for them. In order to use them, you will have to do some experimentation.
   * @return booleanActivityOptions
   */
  @javax.annotation.Nullable
  public Map<String, Boolean> getBooleanActivityOptions() {
    return booleanActivityOptions;
  }

  public void setBooleanActivityOptions(Map<String, Boolean> booleanActivityOptions) {
    this.booleanActivityOptions = booleanActivityOptions;
  }


  public DestinyMilestonesDestinyMilestoneChallengeActivity challenges(List<DestinyChallengesDestinyChallengeStatus> challenges) {
    this.challenges = challenges;
    return this;
  }

  public DestinyMilestonesDestinyMilestoneChallengeActivity addChallengesItem(DestinyChallengesDestinyChallengeStatus challengesItem) {
    if (this.challenges == null) {
      this.challenges = new ArrayList<>();
    }
    this.challenges.add(challengesItem);
    return this;
  }

  /**
   * Get challenges
   * @return challenges
   */
  @javax.annotation.Nullable
  public List<DestinyChallengesDestinyChallengeStatus> getChallenges() {
    return challenges;
  }

  public void setChallenges(List<DestinyChallengesDestinyChallengeStatus> challenges) {
    this.challenges = challenges;
  }


  public DestinyMilestonesDestinyMilestoneChallengeActivity loadoutRequirementIndex(Integer loadoutRequirementIndex) {
    this.loadoutRequirementIndex = loadoutRequirementIndex;
    return this;
  }

  /**
   * If returned, this is the index into the DestinyActivityDefinition&#39;s \&quot;loadouts\&quot; property, indicating the currently active loadout requirements.
   * @return loadoutRequirementIndex
   */
  @javax.annotation.Nullable
  public Integer getLoadoutRequirementIndex() {
    return loadoutRequirementIndex;
  }

  public void setLoadoutRequirementIndex(Integer loadoutRequirementIndex) {
    this.loadoutRequirementIndex = loadoutRequirementIndex;
  }


  public DestinyMilestonesDestinyMilestoneChallengeActivity modifierHashes(List<Integer> modifierHashes) {
    this.modifierHashes = modifierHashes;
    return this;
  }

  public DestinyMilestonesDestinyMilestoneChallengeActivity addModifierHashesItem(Integer modifierHashesItem) {
    if (this.modifierHashes == null) {
      this.modifierHashes = new ArrayList<>();
    }
    this.modifierHashes.add(modifierHashesItem);
    return this;
  }

  /**
   * If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data.  Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what&#39;s really live.
   * @return modifierHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getModifierHashes() {
    return modifierHashes;
  }

  public void setModifierHashes(List<Integer> modifierHashes) {
    this.modifierHashes = modifierHashes;
  }


  public DestinyMilestonesDestinyMilestoneChallengeActivity phases(List<DestinyMilestonesDestinyMilestoneActivityPhase> phases) {
    this.phases = phases;
    return this;
  }

  public DestinyMilestonesDestinyMilestoneChallengeActivity addPhasesItem(DestinyMilestonesDestinyMilestoneActivityPhase phasesItem) {
    if (this.phases == null) {
      this.phases = new ArrayList<>();
    }
    this.phases.add(phasesItem);
    return this;
  }

  /**
   * If the Activity has discrete \&quot;phases\&quot; that we can track, that info will be here. Otherwise, this value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending order of phases or progression in this activity.
   * @return phases
   */
  @javax.annotation.Nullable
  public List<DestinyMilestonesDestinyMilestoneActivityPhase> getPhases() {
    return phases;
  }

  public void setPhases(List<DestinyMilestonesDestinyMilestoneActivityPhase> phases) {
    this.phases = phases;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyMilestonesDestinyMilestoneChallengeActivity destinyMilestonesDestinyMilestoneChallengeActivity = (DestinyMilestonesDestinyMilestoneChallengeActivity) o;
    return Objects.equals(this.activityHash, destinyMilestonesDestinyMilestoneChallengeActivity.activityHash) &&
        Objects.equals(this.booleanActivityOptions, destinyMilestonesDestinyMilestoneChallengeActivity.booleanActivityOptions) &&
        Objects.equals(this.challenges, destinyMilestonesDestinyMilestoneChallengeActivity.challenges) &&
        Objects.equals(this.loadoutRequirementIndex, destinyMilestonesDestinyMilestoneChallengeActivity.loadoutRequirementIndex) &&
        Objects.equals(this.modifierHashes, destinyMilestonesDestinyMilestoneChallengeActivity.modifierHashes) &&
        Objects.equals(this.phases, destinyMilestonesDestinyMilestoneChallengeActivity.phases);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activityHash, booleanActivityOptions, challenges, loadoutRequirementIndex, modifierHashes, phases);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyMilestonesDestinyMilestoneChallengeActivity {\n");
    sb.append("    activityHash: ").append(toIndentedString(activityHash)).append("\n");
    sb.append("    booleanActivityOptions: ").append(toIndentedString(booleanActivityOptions)).append("\n");
    sb.append("    challenges: ").append(toIndentedString(challenges)).append("\n");
    sb.append("    loadoutRequirementIndex: ").append(toIndentedString(loadoutRequirementIndex)).append("\n");
    sb.append("    modifierHashes: ").append(toIndentedString(modifierHashes)).append("\n");
    sb.append("    phases: ").append(toIndentedString(phases)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activityHash");
    openapiFields.add("booleanActivityOptions");
    openapiFields.add("challenges");
    openapiFields.add("loadoutRequirementIndex");
    openapiFields.add("modifierHashes");
    openapiFields.add("phases");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyMilestonesDestinyMilestoneChallengeActivity
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyMilestonesDestinyMilestoneChallengeActivity.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyMilestonesDestinyMilestoneChallengeActivity is not found in the empty JSON string", DestinyMilestonesDestinyMilestoneChallengeActivity.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyMilestonesDestinyMilestoneChallengeActivity.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyMilestonesDestinyMilestoneChallengeActivity` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("challenges") != null && !jsonObj.get("challenges").isJsonNull()) {
        JsonArray jsonArraychallenges = jsonObj.getAsJsonArray("challenges");
        if (jsonArraychallenges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("challenges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `challenges` to be an array in the JSON string but got `%s`", jsonObj.get("challenges").toString()));
          }

          // validate the optional field `challenges` (array)
          for (int i = 0; i < jsonArraychallenges.size(); i++) {
            DestinyChallengesDestinyChallengeStatus.validateJsonElement(jsonArraychallenges.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("modifierHashes") != null && !jsonObj.get("modifierHashes").isJsonNull() && !jsonObj.get("modifierHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifierHashes` to be an array in the JSON string but got `%s`", jsonObj.get("modifierHashes").toString()));
      }
      if (jsonObj.get("phases") != null && !jsonObj.get("phases").isJsonNull()) {
        JsonArray jsonArrayphases = jsonObj.getAsJsonArray("phases");
        if (jsonArrayphases != null) {
          // ensure the json data is an array
          if (!jsonObj.get("phases").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `phases` to be an array in the JSON string but got `%s`", jsonObj.get("phases").toString()));
          }

          // validate the optional field `phases` (array)
          for (int i = 0; i < jsonArrayphases.size(); i++) {
            DestinyMilestonesDestinyMilestoneActivityPhase.validateJsonElement(jsonArrayphases.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyMilestonesDestinyMilestoneChallengeActivity.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyMilestonesDestinyMilestoneChallengeActivity' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyMilestonesDestinyMilestoneChallengeActivity> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyMilestonesDestinyMilestoneChallengeActivity.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyMilestonesDestinyMilestoneChallengeActivity>() {
           @Override
           public void write(JsonWriter out, DestinyMilestonesDestinyMilestoneChallengeActivity value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyMilestonesDestinyMilestoneChallengeActivity read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyMilestonesDestinyMilestoneChallengeActivity given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyMilestonesDestinyMilestoneChallengeActivity
   * @throws IOException if the JSON string is invalid with respect to DestinyMilestonesDestinyMilestoneChallengeActivity
   */
  public static DestinyMilestonesDestinyMilestoneChallengeActivity fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyMilestonesDestinyMilestoneChallengeActivity.class);
  }

  /**
   * Convert an instance of DestinyMilestonesDestinyMilestoneChallengeActivity to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

