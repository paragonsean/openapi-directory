/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsItemsDestinyEnergyCapacityEntry;
import org.openapitools.client.model.DestinyDefinitionsItemsDestinyEnergyCostEntry;
import org.openapitools.client.model.DestinyDefinitionsItemsDestinyParentItemOverride;
import org.openapitools.client.model.DestinyDefinitionsItemsDestinyPlugRuleDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.  This gives information about when it can be inserted, what the plug&#39;s category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsItemsDestinyItemPlugDefinition {
  public static final String SERIALIZED_NAME_ALTERNATE_PLUG_STYLE = "alternatePlugStyle";
  @SerializedName(SERIALIZED_NAME_ALTERNATE_PLUG_STYLE)
  private Integer alternatePlugStyle;

  public static final String SERIALIZED_NAME_ALTERNATE_UI_PLUG_LABEL = "alternateUiPlugLabel";
  @SerializedName(SERIALIZED_NAME_ALTERNATE_UI_PLUG_LABEL)
  private String alternateUiPlugLabel;

  public static final String SERIALIZED_NAME_ENABLED_MATERIAL_REQUIREMENT_HASH = "enabledMaterialRequirementHash";
  @SerializedName(SERIALIZED_NAME_ENABLED_MATERIAL_REQUIREMENT_HASH)
  private Integer enabledMaterialRequirementHash;

  public static final String SERIALIZED_NAME_ENABLED_RULES = "enabledRules";
  @SerializedName(SERIALIZED_NAME_ENABLED_RULES)
  private List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> enabledRules = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENERGY_CAPACITY = "energyCapacity";
  @SerializedName(SERIALIZED_NAME_ENERGY_CAPACITY)
  private DestinyDefinitionsItemsDestinyEnergyCapacityEntry energyCapacity;

  public static final String SERIALIZED_NAME_ENERGY_COST = "energyCost";
  @SerializedName(SERIALIZED_NAME_ENERGY_COST)
  private DestinyDefinitionsItemsDestinyEnergyCostEntry energyCost;

  public static final String SERIALIZED_NAME_INSERTION_MATERIAL_REQUIREMENT_HASH = "insertionMaterialRequirementHash";
  @SerializedName(SERIALIZED_NAME_INSERTION_MATERIAL_REQUIREMENT_HASH)
  private Integer insertionMaterialRequirementHash;

  public static final String SERIALIZED_NAME_INSERTION_RULES = "insertionRules";
  @SerializedName(SERIALIZED_NAME_INSERTION_RULES)
  private List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> insertionRules = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_DUMMY_PLUG = "isDummyPlug";
  @SerializedName(SERIALIZED_NAME_IS_DUMMY_PLUG)
  private Boolean isDummyPlug;

  public static final String SERIALIZED_NAME_ON_ACTION_RECREATE_SELF = "onActionRecreateSelf";
  @SerializedName(SERIALIZED_NAME_ON_ACTION_RECREATE_SELF)
  private Boolean onActionRecreateSelf;

  public static final String SERIALIZED_NAME_PARENT_ITEM_OVERRIDE = "parentItemOverride";
  @SerializedName(SERIALIZED_NAME_PARENT_ITEM_OVERRIDE)
  private DestinyDefinitionsItemsDestinyParentItemOverride parentItemOverride;

  public static final String SERIALIZED_NAME_PLUG_AVAILABILITY = "plugAvailability";
  @SerializedName(SERIALIZED_NAME_PLUG_AVAILABILITY)
  private Integer plugAvailability;

  public static final String SERIALIZED_NAME_PLUG_CATEGORY_HASH = "plugCategoryHash";
  @SerializedName(SERIALIZED_NAME_PLUG_CATEGORY_HASH)
  private Integer plugCategoryHash;

  public static final String SERIALIZED_NAME_PLUG_CATEGORY_IDENTIFIER = "plugCategoryIdentifier";
  @SerializedName(SERIALIZED_NAME_PLUG_CATEGORY_IDENTIFIER)
  private String plugCategoryIdentifier;

  public static final String SERIALIZED_NAME_PLUG_STYLE = "plugStyle";
  @SerializedName(SERIALIZED_NAME_PLUG_STYLE)
  private Integer plugStyle;

  public static final String SERIALIZED_NAME_PREVIEW_ITEM_OVERRIDE_HASH = "previewItemOverrideHash";
  @SerializedName(SERIALIZED_NAME_PREVIEW_ITEM_OVERRIDE_HASH)
  private Integer previewItemOverrideHash;

  public static final String SERIALIZED_NAME_UI_PLUG_LABEL = "uiPlugLabel";
  @SerializedName(SERIALIZED_NAME_UI_PLUG_LABEL)
  private String uiPlugLabel;

  public DestinyDefinitionsItemsDestinyItemPlugDefinition() {
  }

  public DestinyDefinitionsItemsDestinyItemPlugDefinition alternatePlugStyle(Integer alternatePlugStyle) {
    this.alternatePlugStyle = alternatePlugStyle;
    return this;
  }

  /**
   * The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
   * @return alternatePlugStyle
   */
  @javax.annotation.Nullable
  public Integer getAlternatePlugStyle() {
    return alternatePlugStyle;
  }

  public void setAlternatePlugStyle(Integer alternatePlugStyle) {
    this.alternatePlugStyle = alternatePlugStyle;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition alternateUiPlugLabel(String alternateUiPlugLabel) {
    this.alternateUiPlugLabel = alternateUiPlugLabel;
    return this;
  }

  /**
   * If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.
   * @return alternateUiPlugLabel
   */
  @javax.annotation.Nullable
  public String getAlternateUiPlugLabel() {
    return alternateUiPlugLabel;
  }

  public void setAlternateUiPlugLabel(String alternateUiPlugLabel) {
    this.alternateUiPlugLabel = alternateUiPlugLabel;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition enabledMaterialRequirementHash(Integer enabledMaterialRequirementHash) {
    this.enabledMaterialRequirementHash = enabledMaterialRequirementHash;
    return this;
  }

  /**
   * It&#39;s not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
   * @return enabledMaterialRequirementHash
   */
  @javax.annotation.Nullable
  public Integer getEnabledMaterialRequirementHash() {
    return enabledMaterialRequirementHash;
  }

  public void setEnabledMaterialRequirementHash(Integer enabledMaterialRequirementHash) {
    this.enabledMaterialRequirementHash = enabledMaterialRequirementHash;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition enabledRules(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> enabledRules) {
    this.enabledRules = enabledRules;
    return this;
  }

  public DestinyDefinitionsItemsDestinyItemPlugDefinition addEnabledRulesItem(DestinyDefinitionsItemsDestinyPlugRuleDefinition enabledRulesItem) {
    if (this.enabledRules == null) {
      this.enabledRules = new ArrayList<>();
    }
    this.enabledRules.add(enabledRulesItem);
    return this;
  }

  /**
   * The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
   * @return enabledRules
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> getEnabledRules() {
    return enabledRules;
  }

  public void setEnabledRules(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> enabledRules) {
    this.enabledRules = enabledRules;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition energyCapacity(DestinyDefinitionsItemsDestinyEnergyCapacityEntry energyCapacity) {
    this.energyCapacity = energyCapacity;
    return this;
  }

  /**
   * IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0 for example, is implemented in a similar way to Masterworks, where visually it&#39;s a single area of the UI being clicked on to \&quot;Upgrade\&quot; to higher energy levels, but it&#39;s actually socketing new plugs.
   * @return energyCapacity
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsItemsDestinyEnergyCapacityEntry getEnergyCapacity() {
    return energyCapacity;
  }

  public void setEnergyCapacity(DestinyDefinitionsItemsDestinyEnergyCapacityEntry energyCapacity) {
    this.energyCapacity = energyCapacity;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition energyCost(DestinyDefinitionsItemsDestinyEnergyCostEntry energyCost) {
    this.energyCost = energyCost;
    return this;
  }

  /**
   * IF not null, this plug has an energy cost. This contains the details of that cost.
   * @return energyCost
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsItemsDestinyEnergyCostEntry getEnergyCost() {
    return energyCost;
  }

  public void setEnergyCost(DestinyDefinitionsItemsDestinyEnergyCostEntry energyCost) {
    this.energyCost = energyCost;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition insertionMaterialRequirementHash(Integer insertionMaterialRequirementHash) {
    this.insertionMaterialRequirementHash = insertionMaterialRequirementHash;
    return this;
  }

  /**
   * If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
   * @return insertionMaterialRequirementHash
   */
  @javax.annotation.Nullable
  public Integer getInsertionMaterialRequirementHash() {
    return insertionMaterialRequirementHash;
  }

  public void setInsertionMaterialRequirementHash(Integer insertionMaterialRequirementHash) {
    this.insertionMaterialRequirementHash = insertionMaterialRequirementHash;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition insertionRules(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> insertionRules) {
    this.insertionRules = insertionRules;
    return this;
  }

  public DestinyDefinitionsItemsDestinyItemPlugDefinition addInsertionRulesItem(DestinyDefinitionsItemsDestinyPlugRuleDefinition insertionRulesItem) {
    if (this.insertionRules == null) {
      this.insertionRules = new ArrayList<>();
    }
    this.insertionRules.add(insertionRulesItem);
    return this;
  }

  /**
   * The rules around when this plug can be inserted into a socket, aside from the socket&#39;s individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
   * @return insertionRules
   */
  @javax.annotation.Nullable
  public List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> getInsertionRules() {
    return insertionRules;
  }

  public void setInsertionRules(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> insertionRules) {
    this.insertionRules = insertionRules;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition isDummyPlug(Boolean isDummyPlug) {
    this.isDummyPlug = isDummyPlug;
    return this;
  }

  /**
   * If TRUE, this plug is used for UI display purposes only, and doesn&#39;t have any interesting effects of its own.
   * @return isDummyPlug
   */
  @javax.annotation.Nullable
  public Boolean getIsDummyPlug() {
    return isDummyPlug;
  }

  public void setIsDummyPlug(Boolean isDummyPlug) {
    this.isDummyPlug = isDummyPlug;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition onActionRecreateSelf(Boolean onActionRecreateSelf) {
    this.onActionRecreateSelf = onActionRecreateSelf;
    return this;
  }

  /**
   * If you successfully socket the item, this will determine whether or not you get \&quot;refunded\&quot; on the plug.
   * @return onActionRecreateSelf
   */
  @javax.annotation.Nullable
  public Boolean getOnActionRecreateSelf() {
    return onActionRecreateSelf;
  }

  public void setOnActionRecreateSelf(Boolean onActionRecreateSelf) {
    this.onActionRecreateSelf = onActionRecreateSelf;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition parentItemOverride(DestinyDefinitionsItemsDestinyParentItemOverride parentItemOverride) {
    this.parentItemOverride = parentItemOverride;
    return this;
  }

  /**
   * Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!  In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.  If this is populated, it will have the override data to be applied when this plug is applied to an item.
   * @return parentItemOverride
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsItemsDestinyParentItemOverride getParentItemOverride() {
    return parentItemOverride;
  }

  public void setParentItemOverride(DestinyDefinitionsItemsDestinyParentItemOverride parentItemOverride) {
    this.parentItemOverride = parentItemOverride;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition plugAvailability(Integer plugAvailability) {
    this.plugAvailability = plugAvailability;
    return this;
  }

  /**
   * Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!
   * @return plugAvailability
   */
  @javax.annotation.Nullable
  public Integer getPlugAvailability() {
    return plugAvailability;
  }

  public void setPlugAvailability(Integer plugAvailability) {
    this.plugAvailability = plugAvailability;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition plugCategoryHash(Integer plugCategoryHash) {
    this.plugCategoryHash = plugCategoryHash;
    return this;
  }

  /**
   * The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
   * @return plugCategoryHash
   */
  @javax.annotation.Nullable
  public Integer getPlugCategoryHash() {
    return plugCategoryHash;
  }

  public void setPlugCategoryHash(Integer plugCategoryHash) {
    this.plugCategoryHash = plugCategoryHash;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition plugCategoryIdentifier(String plugCategoryIdentifier) {
    this.plugCategoryIdentifier = plugCategoryIdentifier;
    return this;
  }

  /**
   * The string identifier for the plug&#39;s category. Use the socket&#39;s DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
   * @return plugCategoryIdentifier
   */
  @javax.annotation.Nullable
  public String getPlugCategoryIdentifier() {
    return plugCategoryIdentifier;
  }

  public void setPlugCategoryIdentifier(String plugCategoryIdentifier) {
    this.plugCategoryIdentifier = plugCategoryIdentifier;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition plugStyle(Integer plugStyle) {
    this.plugStyle = plugStyle;
    return this;
  }

  /**
   * Get plugStyle
   * @return plugStyle
   */
  @javax.annotation.Nullable
  public Integer getPlugStyle() {
    return plugStyle;
  }

  public void setPlugStyle(Integer plugStyle) {
    this.plugStyle = plugStyle;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition previewItemOverrideHash(Integer previewItemOverrideHash) {
    this.previewItemOverrideHash = previewItemOverrideHash;
    return this;
  }

  /**
   * In the game, if you&#39;re inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
   * @return previewItemOverrideHash
   */
  @javax.annotation.Nullable
  public Integer getPreviewItemOverrideHash() {
    return previewItemOverrideHash;
  }

  public void setPreviewItemOverrideHash(Integer previewItemOverrideHash) {
    this.previewItemOverrideHash = previewItemOverrideHash;
  }


  public DestinyDefinitionsItemsDestinyItemPlugDefinition uiPlugLabel(String uiPlugLabel) {
    this.uiPlugLabel = uiPlugLabel;
    return this;
  }

  /**
   * Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you&#39;ll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.
   * @return uiPlugLabel
   */
  @javax.annotation.Nullable
  public String getUiPlugLabel() {
    return uiPlugLabel;
  }

  public void setUiPlugLabel(String uiPlugLabel) {
    this.uiPlugLabel = uiPlugLabel;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsItemsDestinyItemPlugDefinition destinyDefinitionsItemsDestinyItemPlugDefinition = (DestinyDefinitionsItemsDestinyItemPlugDefinition) o;
    return Objects.equals(this.alternatePlugStyle, destinyDefinitionsItemsDestinyItemPlugDefinition.alternatePlugStyle) &&
        Objects.equals(this.alternateUiPlugLabel, destinyDefinitionsItemsDestinyItemPlugDefinition.alternateUiPlugLabel) &&
        Objects.equals(this.enabledMaterialRequirementHash, destinyDefinitionsItemsDestinyItemPlugDefinition.enabledMaterialRequirementHash) &&
        Objects.equals(this.enabledRules, destinyDefinitionsItemsDestinyItemPlugDefinition.enabledRules) &&
        Objects.equals(this.energyCapacity, destinyDefinitionsItemsDestinyItemPlugDefinition.energyCapacity) &&
        Objects.equals(this.energyCost, destinyDefinitionsItemsDestinyItemPlugDefinition.energyCost) &&
        Objects.equals(this.insertionMaterialRequirementHash, destinyDefinitionsItemsDestinyItemPlugDefinition.insertionMaterialRequirementHash) &&
        Objects.equals(this.insertionRules, destinyDefinitionsItemsDestinyItemPlugDefinition.insertionRules) &&
        Objects.equals(this.isDummyPlug, destinyDefinitionsItemsDestinyItemPlugDefinition.isDummyPlug) &&
        Objects.equals(this.onActionRecreateSelf, destinyDefinitionsItemsDestinyItemPlugDefinition.onActionRecreateSelf) &&
        Objects.equals(this.parentItemOverride, destinyDefinitionsItemsDestinyItemPlugDefinition.parentItemOverride) &&
        Objects.equals(this.plugAvailability, destinyDefinitionsItemsDestinyItemPlugDefinition.plugAvailability) &&
        Objects.equals(this.plugCategoryHash, destinyDefinitionsItemsDestinyItemPlugDefinition.plugCategoryHash) &&
        Objects.equals(this.plugCategoryIdentifier, destinyDefinitionsItemsDestinyItemPlugDefinition.plugCategoryIdentifier) &&
        Objects.equals(this.plugStyle, destinyDefinitionsItemsDestinyItemPlugDefinition.plugStyle) &&
        Objects.equals(this.previewItemOverrideHash, destinyDefinitionsItemsDestinyItemPlugDefinition.previewItemOverrideHash) &&
        Objects.equals(this.uiPlugLabel, destinyDefinitionsItemsDestinyItemPlugDefinition.uiPlugLabel);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alternatePlugStyle, alternateUiPlugLabel, enabledMaterialRequirementHash, enabledRules, energyCapacity, energyCost, insertionMaterialRequirementHash, insertionRules, isDummyPlug, onActionRecreateSelf, parentItemOverride, plugAvailability, plugCategoryHash, plugCategoryIdentifier, plugStyle, previewItemOverrideHash, uiPlugLabel);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsItemsDestinyItemPlugDefinition {\n");
    sb.append("    alternatePlugStyle: ").append(toIndentedString(alternatePlugStyle)).append("\n");
    sb.append("    alternateUiPlugLabel: ").append(toIndentedString(alternateUiPlugLabel)).append("\n");
    sb.append("    enabledMaterialRequirementHash: ").append(toIndentedString(enabledMaterialRequirementHash)).append("\n");
    sb.append("    enabledRules: ").append(toIndentedString(enabledRules)).append("\n");
    sb.append("    energyCapacity: ").append(toIndentedString(energyCapacity)).append("\n");
    sb.append("    energyCost: ").append(toIndentedString(energyCost)).append("\n");
    sb.append("    insertionMaterialRequirementHash: ").append(toIndentedString(insertionMaterialRequirementHash)).append("\n");
    sb.append("    insertionRules: ").append(toIndentedString(insertionRules)).append("\n");
    sb.append("    isDummyPlug: ").append(toIndentedString(isDummyPlug)).append("\n");
    sb.append("    onActionRecreateSelf: ").append(toIndentedString(onActionRecreateSelf)).append("\n");
    sb.append("    parentItemOverride: ").append(toIndentedString(parentItemOverride)).append("\n");
    sb.append("    plugAvailability: ").append(toIndentedString(plugAvailability)).append("\n");
    sb.append("    plugCategoryHash: ").append(toIndentedString(plugCategoryHash)).append("\n");
    sb.append("    plugCategoryIdentifier: ").append(toIndentedString(plugCategoryIdentifier)).append("\n");
    sb.append("    plugStyle: ").append(toIndentedString(plugStyle)).append("\n");
    sb.append("    previewItemOverrideHash: ").append(toIndentedString(previewItemOverrideHash)).append("\n");
    sb.append("    uiPlugLabel: ").append(toIndentedString(uiPlugLabel)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alternatePlugStyle");
    openapiFields.add("alternateUiPlugLabel");
    openapiFields.add("enabledMaterialRequirementHash");
    openapiFields.add("enabledRules");
    openapiFields.add("energyCapacity");
    openapiFields.add("energyCost");
    openapiFields.add("insertionMaterialRequirementHash");
    openapiFields.add("insertionRules");
    openapiFields.add("isDummyPlug");
    openapiFields.add("onActionRecreateSelf");
    openapiFields.add("parentItemOverride");
    openapiFields.add("plugAvailability");
    openapiFields.add("plugCategoryHash");
    openapiFields.add("plugCategoryIdentifier");
    openapiFields.add("plugStyle");
    openapiFields.add("previewItemOverrideHash");
    openapiFields.add("uiPlugLabel");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsItemsDestinyItemPlugDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsItemsDestinyItemPlugDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsItemsDestinyItemPlugDefinition is not found in the empty JSON string", DestinyDefinitionsItemsDestinyItemPlugDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsItemsDestinyItemPlugDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsItemsDestinyItemPlugDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alternateUiPlugLabel") != null && !jsonObj.get("alternateUiPlugLabel").isJsonNull()) && !jsonObj.get("alternateUiPlugLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alternateUiPlugLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alternateUiPlugLabel").toString()));
      }
      if (jsonObj.get("enabledRules") != null && !jsonObj.get("enabledRules").isJsonNull()) {
        JsonArray jsonArrayenabledRules = jsonObj.getAsJsonArray("enabledRules");
        if (jsonArrayenabledRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("enabledRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `enabledRules` to be an array in the JSON string but got `%s`", jsonObj.get("enabledRules").toString()));
          }

          // validate the optional field `enabledRules` (array)
          for (int i = 0; i < jsonArrayenabledRules.size(); i++) {
            DestinyDefinitionsItemsDestinyPlugRuleDefinition.validateJsonElement(jsonArrayenabledRules.get(i));
          };
        }
      }
      // validate the optional field `energyCapacity`
      if (jsonObj.get("energyCapacity") != null && !jsonObj.get("energyCapacity").isJsonNull()) {
        DestinyDefinitionsItemsDestinyEnergyCapacityEntry.validateJsonElement(jsonObj.get("energyCapacity"));
      }
      // validate the optional field `energyCost`
      if (jsonObj.get("energyCost") != null && !jsonObj.get("energyCost").isJsonNull()) {
        DestinyDefinitionsItemsDestinyEnergyCostEntry.validateJsonElement(jsonObj.get("energyCost"));
      }
      if (jsonObj.get("insertionRules") != null && !jsonObj.get("insertionRules").isJsonNull()) {
        JsonArray jsonArrayinsertionRules = jsonObj.getAsJsonArray("insertionRules");
        if (jsonArrayinsertionRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("insertionRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `insertionRules` to be an array in the JSON string but got `%s`", jsonObj.get("insertionRules").toString()));
          }

          // validate the optional field `insertionRules` (array)
          for (int i = 0; i < jsonArrayinsertionRules.size(); i++) {
            DestinyDefinitionsItemsDestinyPlugRuleDefinition.validateJsonElement(jsonArrayinsertionRules.get(i));
          };
        }
      }
      // validate the optional field `parentItemOverride`
      if (jsonObj.get("parentItemOverride") != null && !jsonObj.get("parentItemOverride").isJsonNull()) {
        DestinyDefinitionsItemsDestinyParentItemOverride.validateJsonElement(jsonObj.get("parentItemOverride"));
      }
      if ((jsonObj.get("plugCategoryIdentifier") != null && !jsonObj.get("plugCategoryIdentifier").isJsonNull()) && !jsonObj.get("plugCategoryIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `plugCategoryIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("plugCategoryIdentifier").toString()));
      }
      if ((jsonObj.get("uiPlugLabel") != null && !jsonObj.get("uiPlugLabel").isJsonNull()) && !jsonObj.get("uiPlugLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uiPlugLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uiPlugLabel").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsItemsDestinyItemPlugDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsItemsDestinyItemPlugDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsItemsDestinyItemPlugDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsItemsDestinyItemPlugDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsItemsDestinyItemPlugDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsItemsDestinyItemPlugDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsItemsDestinyItemPlugDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsItemsDestinyItemPlugDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsItemsDestinyItemPlugDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsItemsDestinyItemPlugDefinition
   */
  public static DestinyDefinitionsItemsDestinyItemPlugDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsItemsDestinyItemPlugDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsItemsDestinyItemPlugDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

