/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import org.openapitools.client.model.DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock;
import org.openapitools.client.model.DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A PresentationNode is an entity that represents a logical grouping of other entities visually/organizationally.  For now, Presentation Nodes may contain the following... but it may be used for more in the future:  - Collectibles - Records (Or, as the public will call them, \&quot;Triumphs.\&quot; Don&#39;t ask me why we&#39;re overloading the term \&quot;Triumph\&quot;, it still hurts me to think about it) - Metrics (aka Stat Trackers) - Other Presentation Nodes, allowing a tree of Presentation Nodes to be created  Part of me wants to break these into conceptual definitions per entity being collected, but the possibility of these different types being mixed in the same UI and the possibility that it could actually be more useful to return the \&quot;bare metal\&quot; presentation node concept has resulted in me deciding against that for the time being.  We&#39;ll see if I come to regret this as well.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.650260-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DestinyDefinitionsPresentationDestinyPresentationNodeDefinition {
  public static final String SERIALIZED_NAME_CHILDREN = "children";
  @SerializedName(SERIALIZED_NAME_CHILDREN)
  private DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock children;

  public static final String SERIALIZED_NAME_COMPLETION_RECORD_HASH = "completionRecordHash";
  @SerializedName(SERIALIZED_NAME_COMPLETION_RECORD_HASH)
  private Integer completionRecordHash;

  public static final String SERIALIZED_NAME_DISABLE_CHILD_SUBSCREEN_NAVIGATION = "disableChildSubscreenNavigation";
  @SerializedName(SERIALIZED_NAME_DISABLE_CHILD_SUBSCREEN_NAVIGATION)
  private Boolean disableChildSubscreenNavigation;

  public static final String SERIALIZED_NAME_DISPLAY_PROPERTIES = "displayProperties";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PROPERTIES)
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties;

  public static final String SERIALIZED_NAME_DISPLAY_STYLE = "displayStyle";
  @SerializedName(SERIALIZED_NAME_DISPLAY_STYLE)
  private Integer displayStyle;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private Integer hash;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_MAX_CATEGORY_RECORD_SCORE = "maxCategoryRecordScore";
  @SerializedName(SERIALIZED_NAME_MAX_CATEGORY_RECORD_SCORE)
  private Integer maxCategoryRecordScore;

  public static final String SERIALIZED_NAME_NODE_TYPE = "nodeType";
  @SerializedName(SERIALIZED_NAME_NODE_TYPE)
  private Integer nodeType;

  public static final String SERIALIZED_NAME_OBJECTIVE_HASH = "objectiveHash";
  @SerializedName(SERIALIZED_NAME_OBJECTIVE_HASH)
  private Integer objectiveHash;

  public static final String SERIALIZED_NAME_ORIGINAL_ICON = "originalIcon";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_ICON)
  private String originalIcon;

  public static final String SERIALIZED_NAME_PARENT_NODE_HASHES = "parentNodeHashes";
  @SerializedName(SERIALIZED_NAME_PARENT_NODE_HASHES)
  private List<Integer> parentNodeHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PRESENTATION_NODE_TYPE = "presentationNodeType";
  @SerializedName(SERIALIZED_NAME_PRESENTATION_NODE_TYPE)
  private Integer presentationNodeType;

  public static final String SERIALIZED_NAME_REDACTED = "redacted";
  @SerializedName(SERIALIZED_NAME_REDACTED)
  private Boolean redacted;

  public static final String SERIALIZED_NAME_REQUIREMENTS = "requirements";
  @SerializedName(SERIALIZED_NAME_REQUIREMENTS)
  private DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock requirements;

  public static final String SERIALIZED_NAME_ROOT_VIEW_ICON = "rootViewIcon";
  @SerializedName(SERIALIZED_NAME_ROOT_VIEW_ICON)
  private String rootViewIcon;

  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private Integer scope;

  public static final String SERIALIZED_NAME_SCREEN_STYLE = "screenStyle";
  @SerializedName(SERIALIZED_NAME_SCREEN_STYLE)
  private Integer screenStyle;

  public static final String SERIALIZED_NAME_TRAIT_HASHES = "traitHashes";
  @SerializedName(SERIALIZED_NAME_TRAIT_HASHES)
  private List<Integer> traitHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRAIT_IDS = "traitIds";
  @SerializedName(SERIALIZED_NAME_TRAIT_IDS)
  private List<String> traitIds = new ArrayList<>();

  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition() {
  }

  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition children(DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock children) {
    this.children = children;
    return this;
  }

  /**
   * The child entities contained by this presentation node.
   * @return children
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock getChildren() {
    return children;
  }

  public void setChildren(DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock children) {
    this.children = children;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition completionRecordHash(Integer completionRecordHash) {
    this.completionRecordHash = completionRecordHash;
    return this;
  }

  /**
   * If this presentation node has an associated \&quot;Record\&quot; that you can accomplish for completing its children, this is the identifier of that Record.
   * @return completionRecordHash
   */
  @javax.annotation.Nullable
  public Integer getCompletionRecordHash() {
    return completionRecordHash;
  }

  public void setCompletionRecordHash(Integer completionRecordHash) {
    this.completionRecordHash = completionRecordHash;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition disableChildSubscreenNavigation(Boolean disableChildSubscreenNavigation) {
    this.disableChildSubscreenNavigation = disableChildSubscreenNavigation;
    return this;
  }

  /**
   * If this presentation node has children, but the game doesn&#39;t let you inspect the details of those children, that is indicated here.
   * @return disableChildSubscreenNavigation
   */
  @javax.annotation.Nullable
  public Boolean getDisableChildSubscreenNavigation() {
    return disableChildSubscreenNavigation;
  }

  public void setDisableChildSubscreenNavigation(Boolean disableChildSubscreenNavigation) {
    this.disableChildSubscreenNavigation = disableChildSubscreenNavigation;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

  /**
   * Get displayProperties
   * @return displayProperties
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition displayStyle(Integer displayStyle) {
    this.displayStyle = displayStyle;
    return this;
  }

  /**
   * A hint for how to display this presentation node when it&#39;s shown in a list.
   * @return displayStyle
   */
  @javax.annotation.Nullable
  public Integer getDisplayStyle() {
    return displayStyle;
  }

  public void setDisplayStyle(Integer displayStyle) {
    this.displayStyle = displayStyle;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition hash(Integer hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
   */
  @javax.annotation.Nullable
  public Integer getHash() {
    return hash;
  }

  public void setHash(Integer hash) {
    this.hash = hash;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition index(Integer index) {
    this.index = index;
    return this;
  }

  /**
   * The index of the entity as it was found in the investment tables.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition maxCategoryRecordScore(Integer maxCategoryRecordScore) {
    this.maxCategoryRecordScore = maxCategoryRecordScore;
    return this;
  }

  /**
   * Get maxCategoryRecordScore
   * @return maxCategoryRecordScore
   */
  @javax.annotation.Nullable
  public Integer getMaxCategoryRecordScore() {
    return maxCategoryRecordScore;
  }

  public void setMaxCategoryRecordScore(Integer maxCategoryRecordScore) {
    this.maxCategoryRecordScore = maxCategoryRecordScore;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition nodeType(Integer nodeType) {
    this.nodeType = nodeType;
    return this;
  }

  /**
   * Get nodeType
   * @return nodeType
   */
  @javax.annotation.Nullable
  public Integer getNodeType() {
    return nodeType;
  }

  public void setNodeType(Integer nodeType) {
    this.nodeType = nodeType;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition objectiveHash(Integer objectiveHash) {
    this.objectiveHash = objectiveHash;
    return this;
  }

  /**
   * If this presentation node shows a related objective (for instance, if it tracks the progress of its children), the objective being tracked is indicated here.
   * @return objectiveHash
   */
  @javax.annotation.Nullable
  public Integer getObjectiveHash() {
    return objectiveHash;
  }

  public void setObjectiveHash(Integer objectiveHash) {
    this.objectiveHash = objectiveHash;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition originalIcon(String originalIcon) {
    this.originalIcon = originalIcon;
    return this;
  }

  /**
   * The original icon for this presentation node, before we futzed with it.
   * @return originalIcon
   */
  @javax.annotation.Nullable
  public String getOriginalIcon() {
    return originalIcon;
  }

  public void setOriginalIcon(String originalIcon) {
    this.originalIcon = originalIcon;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition parentNodeHashes(List<Integer> parentNodeHashes) {
    this.parentNodeHashes = parentNodeHashes;
    return this;
  }

  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition addParentNodeHashesItem(Integer parentNodeHashesItem) {
    if (this.parentNodeHashes == null) {
      this.parentNodeHashes = new ArrayList<>();
    }
    this.parentNodeHashes.add(parentNodeHashesItem);
    return this;
  }

  /**
   * A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.
   * @return parentNodeHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getParentNodeHashes() {
    return parentNodeHashes;
  }

  public void setParentNodeHashes(List<Integer> parentNodeHashes) {
    this.parentNodeHashes = parentNodeHashes;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition presentationNodeType(Integer presentationNodeType) {
    this.presentationNodeType = presentationNodeType;
    return this;
  }

  /**
   * Get presentationNodeType
   * @return presentationNodeType
   */
  @javax.annotation.Nullable
  public Integer getPresentationNodeType() {
    return presentationNodeType;
  }

  public void setPresentationNodeType(Integer presentationNodeType) {
    this.presentationNodeType = presentationNodeType;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
   */
  @javax.annotation.Nullable
  public Boolean getRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition requirements(DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock requirements) {
    this.requirements = requirements;
    return this;
  }

  /**
   * The requirements for being able to interact with this presentation node and its children.
   * @return requirements
   */
  @javax.annotation.Nullable
  public DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock getRequirements() {
    return requirements;
  }

  public void setRequirements(DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock requirements) {
    this.requirements = requirements;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition rootViewIcon(String rootViewIcon) {
    this.rootViewIcon = rootViewIcon;
    return this;
  }

  /**
   * Some presentation nodes are meant to be explicitly shown on the \&quot;root\&quot; or \&quot;entry\&quot; screens for the feature to which they are related. You should use this icon when showing them on such a view, if you have a similar \&quot;entry point\&quot; view in your UI. If you don&#39;t have a UI, then I guess it doesn&#39;t matter either way does it?
   * @return rootViewIcon
   */
  @javax.annotation.Nullable
  public String getRootViewIcon() {
    return rootViewIcon;
  }

  public void setRootViewIcon(String rootViewIcon) {
    this.rootViewIcon = rootViewIcon;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition scope(Integer scope) {
    this.scope = scope;
    return this;
  }

  /**
   * Indicates whether this presentation node&#39;s state is determined on a per-character or on an account-wide basis.
   * @return scope
   */
  @javax.annotation.Nullable
  public Integer getScope() {
    return scope;
  }

  public void setScope(Integer scope) {
    this.scope = scope;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition screenStyle(Integer screenStyle) {
    this.screenStyle = screenStyle;
    return this;
  }

  /**
   * A hint for how to display this presentation node when it&#39;s shown in its own detail screen.
   * @return screenStyle
   */
  @javax.annotation.Nullable
  public Integer getScreenStyle() {
    return screenStyle;
  }

  public void setScreenStyle(Integer screenStyle) {
    this.screenStyle = screenStyle;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition traitHashes(List<Integer> traitHashes) {
    this.traitHashes = traitHashes;
    return this;
  }

  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition addTraitHashesItem(Integer traitHashesItem) {
    if (this.traitHashes == null) {
      this.traitHashes = new ArrayList<>();
    }
    this.traitHashes.add(traitHashesItem);
    return this;
  }

  /**
   * Get traitHashes
   * @return traitHashes
   */
  @javax.annotation.Nullable
  public List<Integer> getTraitHashes() {
    return traitHashes;
  }

  public void setTraitHashes(List<Integer> traitHashes) {
    this.traitHashes = traitHashes;
  }


  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition traitIds(List<String> traitIds) {
    this.traitIds = traitIds;
    return this;
  }

  public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition addTraitIdsItem(String traitIdsItem) {
    if (this.traitIds == null) {
      this.traitIds = new ArrayList<>();
    }
    this.traitIds.add(traitIdsItem);
    return this;
  }

  /**
   * Get traitIds
   * @return traitIds
   */
  @javax.annotation.Nullable
  public List<String> getTraitIds() {
    return traitIds;
  }

  public void setTraitIds(List<String> traitIds) {
    this.traitIds = traitIds;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsPresentationDestinyPresentationNodeDefinition destinyDefinitionsPresentationDestinyPresentationNodeDefinition = (DestinyDefinitionsPresentationDestinyPresentationNodeDefinition) o;
    return Objects.equals(this.children, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.children) &&
        Objects.equals(this.completionRecordHash, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.completionRecordHash) &&
        Objects.equals(this.disableChildSubscreenNavigation, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.disableChildSubscreenNavigation) &&
        Objects.equals(this.displayProperties, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.displayProperties) &&
        Objects.equals(this.displayStyle, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.displayStyle) &&
        Objects.equals(this.hash, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.hash) &&
        Objects.equals(this.index, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.index) &&
        Objects.equals(this.maxCategoryRecordScore, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.maxCategoryRecordScore) &&
        Objects.equals(this.nodeType, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.nodeType) &&
        Objects.equals(this.objectiveHash, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.objectiveHash) &&
        Objects.equals(this.originalIcon, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.originalIcon) &&
        Objects.equals(this.parentNodeHashes, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.parentNodeHashes) &&
        Objects.equals(this.presentationNodeType, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.presentationNodeType) &&
        Objects.equals(this.redacted, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.redacted) &&
        Objects.equals(this.requirements, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.requirements) &&
        Objects.equals(this.rootViewIcon, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.rootViewIcon) &&
        Objects.equals(this.scope, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.scope) &&
        Objects.equals(this.screenStyle, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.screenStyle) &&
        Objects.equals(this.traitHashes, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.traitHashes) &&
        Objects.equals(this.traitIds, destinyDefinitionsPresentationDestinyPresentationNodeDefinition.traitIds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(children, completionRecordHash, disableChildSubscreenNavigation, displayProperties, displayStyle, hash, index, maxCategoryRecordScore, nodeType, objectiveHash, originalIcon, parentNodeHashes, presentationNodeType, redacted, requirements, rootViewIcon, scope, screenStyle, traitHashes, traitIds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsPresentationDestinyPresentationNodeDefinition {\n");
    sb.append("    children: ").append(toIndentedString(children)).append("\n");
    sb.append("    completionRecordHash: ").append(toIndentedString(completionRecordHash)).append("\n");
    sb.append("    disableChildSubscreenNavigation: ").append(toIndentedString(disableChildSubscreenNavigation)).append("\n");
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    displayStyle: ").append(toIndentedString(displayStyle)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    maxCategoryRecordScore: ").append(toIndentedString(maxCategoryRecordScore)).append("\n");
    sb.append("    nodeType: ").append(toIndentedString(nodeType)).append("\n");
    sb.append("    objectiveHash: ").append(toIndentedString(objectiveHash)).append("\n");
    sb.append("    originalIcon: ").append(toIndentedString(originalIcon)).append("\n");
    sb.append("    parentNodeHashes: ").append(toIndentedString(parentNodeHashes)).append("\n");
    sb.append("    presentationNodeType: ").append(toIndentedString(presentationNodeType)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("    requirements: ").append(toIndentedString(requirements)).append("\n");
    sb.append("    rootViewIcon: ").append(toIndentedString(rootViewIcon)).append("\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    screenStyle: ").append(toIndentedString(screenStyle)).append("\n");
    sb.append("    traitHashes: ").append(toIndentedString(traitHashes)).append("\n");
    sb.append("    traitIds: ").append(toIndentedString(traitIds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("children");
    openapiFields.add("completionRecordHash");
    openapiFields.add("disableChildSubscreenNavigation");
    openapiFields.add("displayProperties");
    openapiFields.add("displayStyle");
    openapiFields.add("hash");
    openapiFields.add("index");
    openapiFields.add("maxCategoryRecordScore");
    openapiFields.add("nodeType");
    openapiFields.add("objectiveHash");
    openapiFields.add("originalIcon");
    openapiFields.add("parentNodeHashes");
    openapiFields.add("presentationNodeType");
    openapiFields.add("redacted");
    openapiFields.add("requirements");
    openapiFields.add("rootViewIcon");
    openapiFields.add("scope");
    openapiFields.add("screenStyle");
    openapiFields.add("traitHashes");
    openapiFields.add("traitIds");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DestinyDefinitionsPresentationDestinyPresentationNodeDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DestinyDefinitionsPresentationDestinyPresentationNodeDefinition is not found in the empty JSON string", DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DestinyDefinitionsPresentationDestinyPresentationNodeDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `children`
      if (jsonObj.get("children") != null && !jsonObj.get("children").isJsonNull()) {
        DestinyDefinitionsPresentationDestinyPresentationNodeChildrenBlock.validateJsonElement(jsonObj.get("children"));
      }
      // validate the optional field `displayProperties`
      if (jsonObj.get("displayProperties") != null && !jsonObj.get("displayProperties").isJsonNull()) {
        DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition.validateJsonElement(jsonObj.get("displayProperties"));
      }
      if ((jsonObj.get("originalIcon") != null && !jsonObj.get("originalIcon").isJsonNull()) && !jsonObj.get("originalIcon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalIcon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalIcon").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("parentNodeHashes") != null && !jsonObj.get("parentNodeHashes").isJsonNull() && !jsonObj.get("parentNodeHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentNodeHashes` to be an array in the JSON string but got `%s`", jsonObj.get("parentNodeHashes").toString()));
      }
      // validate the optional field `requirements`
      if (jsonObj.get("requirements") != null && !jsonObj.get("requirements").isJsonNull()) {
        DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock.validateJsonElement(jsonObj.get("requirements"));
      }
      if ((jsonObj.get("rootViewIcon") != null && !jsonObj.get("rootViewIcon").isJsonNull()) && !jsonObj.get("rootViewIcon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rootViewIcon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rootViewIcon").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("traitHashes") != null && !jsonObj.get("traitHashes").isJsonNull() && !jsonObj.get("traitHashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `traitHashes` to be an array in the JSON string but got `%s`", jsonObj.get("traitHashes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("traitIds") != null && !jsonObj.get("traitIds").isJsonNull() && !jsonObj.get("traitIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `traitIds` to be an array in the JSON string but got `%s`", jsonObj.get("traitIds").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DestinyDefinitionsPresentationDestinyPresentationNodeDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DestinyDefinitionsPresentationDestinyPresentationNodeDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<DestinyDefinitionsPresentationDestinyPresentationNodeDefinition>() {
           @Override
           public void write(JsonWriter out, DestinyDefinitionsPresentationDestinyPresentationNodeDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DestinyDefinitionsPresentationDestinyPresentationNodeDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DestinyDefinitionsPresentationDestinyPresentationNodeDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DestinyDefinitionsPresentationDestinyPresentationNodeDefinition
   * @throws IOException if the JSON string is invalid with respect to DestinyDefinitionsPresentationDestinyPresentationNodeDefinition
   */
  public static DestinyDefinitionsPresentationDestinyPresentationNodeDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DestinyDefinitionsPresentationDestinyPresentationNodeDefinition.class);
  }

  /**
   * Convert an instance of DestinyDefinitionsPresentationDestinyPresentationNodeDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

