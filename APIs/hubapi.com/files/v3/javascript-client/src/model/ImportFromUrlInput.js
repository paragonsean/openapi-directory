/**
 * Files Files
 * Upload and manage files.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The ImportFromUrlInput model module.
 * @module model/ImportFromUrlInput
 * @version v3
 */
class ImportFromUrlInput {
    /**
     * Constructs a new <code>ImportFromUrlInput</code>.
     * @alias module:model/ImportFromUrlInput
     * @param access {module:model/ImportFromUrlInput.AccessEnum} PUBLIC_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines can index the file. PUBLIC_NOT_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines *can't* index the file. PRIVATE: File is NOT publicly accessible. Requires a signed URL to see content. Search engines *can't* index the file. 
     * @param url {String} URL to download the new file from.
     */
    constructor(access, url) { 
        
        ImportFromUrlInput.initialize(this, access, url);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, access, url) { 
        obj['access'] = access;
        obj['url'] = url;
    }

    /**
     * Constructs a <code>ImportFromUrlInput</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ImportFromUrlInput} obj Optional instance to populate.
     * @return {module:model/ImportFromUrlInput} The populated <code>ImportFromUrlInput</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ImportFromUrlInput();

            if (data.hasOwnProperty('access')) {
                obj['access'] = ApiClient.convertToType(data['access'], 'String');
            }
            if (data.hasOwnProperty('duplicateValidationScope')) {
                obj['duplicateValidationScope'] = ApiClient.convertToType(data['duplicateValidationScope'], 'String');
            }
            if (data.hasOwnProperty('duplicateValidationStrategy')) {
                obj['duplicateValidationStrategy'] = ApiClient.convertToType(data['duplicateValidationStrategy'], 'String');
            }
            if (data.hasOwnProperty('folderId')) {
                obj['folderId'] = ApiClient.convertToType(data['folderId'], 'String');
            }
            if (data.hasOwnProperty('folderPath')) {
                obj['folderPath'] = ApiClient.convertToType(data['folderPath'], 'String');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('overwrite')) {
                obj['overwrite'] = ApiClient.convertToType(data['overwrite'], 'Boolean');
            }
            if (data.hasOwnProperty('ttl')) {
                obj['ttl'] = ApiClient.convertToType(data['ttl'], 'String');
            }
            if (data.hasOwnProperty('url')) {
                obj['url'] = ApiClient.convertToType(data['url'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ImportFromUrlInput</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ImportFromUrlInput</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of ImportFromUrlInput.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['access'] && !(typeof data['access'] === 'string' || data['access'] instanceof String)) {
            throw new Error("Expected the field `access` to be a primitive type in the JSON string but got " + data['access']);
        }
        // ensure the json data is a string
        if (data['duplicateValidationScope'] && !(typeof data['duplicateValidationScope'] === 'string' || data['duplicateValidationScope'] instanceof String)) {
            throw new Error("Expected the field `duplicateValidationScope` to be a primitive type in the JSON string but got " + data['duplicateValidationScope']);
        }
        // ensure the json data is a string
        if (data['duplicateValidationStrategy'] && !(typeof data['duplicateValidationStrategy'] === 'string' || data['duplicateValidationStrategy'] instanceof String)) {
            throw new Error("Expected the field `duplicateValidationStrategy` to be a primitive type in the JSON string but got " + data['duplicateValidationStrategy']);
        }
        // ensure the json data is a string
        if (data['folderId'] && !(typeof data['folderId'] === 'string' || data['folderId'] instanceof String)) {
            throw new Error("Expected the field `folderId` to be a primitive type in the JSON string but got " + data['folderId']);
        }
        // ensure the json data is a string
        if (data['folderPath'] && !(typeof data['folderPath'] === 'string' || data['folderPath'] instanceof String)) {
            throw new Error("Expected the field `folderPath` to be a primitive type in the JSON string but got " + data['folderPath']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['ttl'] && !(typeof data['ttl'] === 'string' || data['ttl'] instanceof String)) {
            throw new Error("Expected the field `ttl` to be a primitive type in the JSON string but got " + data['ttl']);
        }
        // ensure the json data is a string
        if (data['url'] && !(typeof data['url'] === 'string' || data['url'] instanceof String)) {
            throw new Error("Expected the field `url` to be a primitive type in the JSON string but got " + data['url']);
        }

        return true;
    }


}

ImportFromUrlInput.RequiredProperties = ["access", "url"];

/**
 * PUBLIC_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines can index the file. PUBLIC_NOT_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines *can't* index the file. PRIVATE: File is NOT publicly accessible. Requires a signed URL to see content. Search engines *can't* index the file. 
 * @member {module:model/ImportFromUrlInput.AccessEnum} access
 */
ImportFromUrlInput.prototype['access'] = undefined;

/**
 * ENTIRE_PORTAL: Look for a duplicate file in the entire account. EXACT_FOLDER: Look for a duplicate file in the provided folder. 
 * @member {module:model/ImportFromUrlInput.DuplicateValidationScopeEnum} duplicateValidationScope
 */
ImportFromUrlInput.prototype['duplicateValidationScope'] = undefined;

/**
 * NONE: Do not run any duplicate validation. REJECT: Reject the upload if a duplicate is found. RETURN_EXISTING: If a duplicate file is found, do not upload a new file and return the found duplicate instead. 
 * @member {module:model/ImportFromUrlInput.DuplicateValidationStrategyEnum} duplicateValidationStrategy
 */
ImportFromUrlInput.prototype['duplicateValidationStrategy'] = undefined;

/**
 * One of folderId or folderPath is required. Destination folderId for the uploaded file.
 * @member {String} folderId
 */
ImportFromUrlInput.prototype['folderId'] = undefined;

/**
 * One of folderPath or folderId is required. Destination folder path for the uploaded file. If the folder path does not exist, there will be an attempt to create the folder path.
 * @member {String} folderPath
 */
ImportFromUrlInput.prototype['folderPath'] = undefined;

/**
 * Name to give the resulting file in the file manager.
 * @member {String} name
 */
ImportFromUrlInput.prototype['name'] = undefined;

/**
 * If true, will overwrite existing file if one with the same name and extension exists in the given folder. The overwritten file will be deleted and the uploaded file will take its place with a new ID. If unset or set as false, the new file's name will be updated to prevent colliding with existing file if one exists with the same path, name, and extension
 * @member {Boolean} overwrite
 */
ImportFromUrlInput.prototype['overwrite'] = undefined;

/**
 * Time to live. If specified the file will be deleted after the given time frame. If left unset, the file will exist indefinitely
 * @member {String} ttl
 */
ImportFromUrlInput.prototype['ttl'] = undefined;

/**
 * URL to download the new file from.
 * @member {String} url
 */
ImportFromUrlInput.prototype['url'] = undefined;





/**
 * Allowed values for the <code>access</code> property.
 * @enum {String}
 * @readonly
 */
ImportFromUrlInput['AccessEnum'] = {

    /**
     * value: "PUBLIC_INDEXABLE"
     * @const
     */
    "PUBLIC_INDEXABLE": "PUBLIC_INDEXABLE",

    /**
     * value: "PUBLIC_NOT_INDEXABLE"
     * @const
     */
    "PUBLIC_NOT_INDEXABLE": "PUBLIC_NOT_INDEXABLE",

    /**
     * value: "HIDDEN_INDEXABLE"
     * @const
     */
    "HIDDEN_INDEXABLE": "HIDDEN_INDEXABLE",

    /**
     * value: "HIDDEN_NOT_INDEXABLE"
     * @const
     */
    "HIDDEN_NOT_INDEXABLE": "HIDDEN_NOT_INDEXABLE",

    /**
     * value: "HIDDEN_PRIVATE"
     * @const
     */
    "HIDDEN_PRIVATE": "HIDDEN_PRIVATE",

    /**
     * value: "PRIVATE"
     * @const
     */
    "PRIVATE": "PRIVATE"
};


/**
 * Allowed values for the <code>duplicateValidationScope</code> property.
 * @enum {String}
 * @readonly
 */
ImportFromUrlInput['DuplicateValidationScopeEnum'] = {

    /**
     * value: "ENTIRE_PORTAL"
     * @const
     */
    "ENTIRE_PORTAL": "ENTIRE_PORTAL",

    /**
     * value: "EXACT_FOLDER"
     * @const
     */
    "EXACT_FOLDER": "EXACT_FOLDER"
};


/**
 * Allowed values for the <code>duplicateValidationStrategy</code> property.
 * @enum {String}
 * @readonly
 */
ImportFromUrlInput['DuplicateValidationStrategyEnum'] = {

    /**
     * value: "NONE"
     * @const
     */
    "NONE": "NONE",

    /**
     * value: "REJECT"
     * @const
     */
    "REJECT": "REJECT",

    /**
     * value: "RETURN_EXISTING"
     * @const
     */
    "RETURN_EXISTING": "RETURN_EXISTING"
};



export default ImportFromUrlInput;

