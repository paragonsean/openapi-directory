/*
 * Seldon External API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.TensorflowDataType;
import org.openapitools.client.model.TensorflowResourceHandleProto;
import org.openapitools.client.model.TensorflowTensorShapeProto;
import org.openapitools.client.model.TensorflowVariantTensorDataProto;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Protocol buffer representing a tensor.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:54:38.360844-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TensorflowTensorProto {
  public static final String SERIALIZED_NAME_BOOL_VAL = "bool_val";
  @SerializedName(SERIALIZED_NAME_BOOL_VAL)
  private List<Boolean> boolVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_DCOMPLEX_VAL = "dcomplex_val";
  @SerializedName(SERIALIZED_NAME_DCOMPLEX_VAL)
  private List<Double> dcomplexVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_DOUBLE_VAL = "double_val";
  @SerializedName(SERIALIZED_NAME_DOUBLE_VAL)
  private List<Double> doubleVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_DTYPE = "dtype";
  @SerializedName(SERIALIZED_NAME_DTYPE)
  private TensorflowDataType dtype = TensorflowDataType.INVALID;

  public static final String SERIALIZED_NAME_FLOAT_VAL = "float_val";
  @SerializedName(SERIALIZED_NAME_FLOAT_VAL)
  private List<Float> floatVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_HALF_VAL = "half_val";
  @SerializedName(SERIALIZED_NAME_HALF_VAL)
  private List<Integer> halfVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_INT64_VAL = "int64_val";
  @SerializedName(SERIALIZED_NAME_INT64_VAL)
  private List<String> int64Val = new ArrayList<>();

  public static final String SERIALIZED_NAME_INT_VAL = "int_val";
  @SerializedName(SERIALIZED_NAME_INT_VAL)
  private List<Integer> intVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_RESOURCE_HANDLE_VAL = "resource_handle_val";
  @SerializedName(SERIALIZED_NAME_RESOURCE_HANDLE_VAL)
  private List<TensorflowResourceHandleProto> resourceHandleVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_SCOMPLEX_VAL = "scomplex_val";
  @SerializedName(SERIALIZED_NAME_SCOMPLEX_VAL)
  private List<Float> scomplexVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_STRING_VAL = "string_val";
  @SerializedName(SERIALIZED_NAME_STRING_VAL)
  private List<byte[]> stringVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_TENSOR_CONTENT = "tensor_content";
  @SerializedName(SERIALIZED_NAME_TENSOR_CONTENT)
  private byte[] tensorContent;

  public static final String SERIALIZED_NAME_TENSOR_SHAPE = "tensor_shape";
  @SerializedName(SERIALIZED_NAME_TENSOR_SHAPE)
  private TensorflowTensorShapeProto tensorShape;

  public static final String SERIALIZED_NAME_UINT32_VAL = "uint32_val";
  @SerializedName(SERIALIZED_NAME_UINT32_VAL)
  private List<Long> uint32Val = new ArrayList<>();

  public static final String SERIALIZED_NAME_UINT64_VAL = "uint64_val";
  @SerializedName(SERIALIZED_NAME_UINT64_VAL)
  private List<String> uint64Val = new ArrayList<>();

  public static final String SERIALIZED_NAME_VARIANT_VAL = "variant_val";
  @SerializedName(SERIALIZED_NAME_VARIANT_VAL)
  private List<TensorflowVariantTensorDataProto> variantVal = new ArrayList<>();

  public static final String SERIALIZED_NAME_VERSION_NUMBER = "version_number";
  @SerializedName(SERIALIZED_NAME_VERSION_NUMBER)
  private Integer versionNumber;

  public TensorflowTensorProto() {
  }

  public TensorflowTensorProto boolVal(List<Boolean> boolVal) {
    this.boolVal = boolVal;
    return this;
  }

  public TensorflowTensorProto addBoolValItem(Boolean boolValItem) {
    if (this.boolVal == null) {
      this.boolVal = new ArrayList<>();
    }
    this.boolVal.add(boolValItem);
    return this;
  }

  /**
   * Get boolVal
   * @return boolVal
   */
  @javax.annotation.Nullable
  public List<Boolean> getBoolVal() {
    return boolVal;
  }

  public void setBoolVal(List<Boolean> boolVal) {
    this.boolVal = boolVal;
  }


  public TensorflowTensorProto dcomplexVal(List<Double> dcomplexVal) {
    this.dcomplexVal = dcomplexVal;
    return this;
  }

  public TensorflowTensorProto addDcomplexValItem(Double dcomplexValItem) {
    if (this.dcomplexVal == null) {
      this.dcomplexVal = new ArrayList<>();
    }
    this.dcomplexVal.add(dcomplexValItem);
    return this;
  }

  /**
   * DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real and imaginary parts of i-th double precision complex.
   * @return dcomplexVal
   */
  @javax.annotation.Nullable
  public List<Double> getDcomplexVal() {
    return dcomplexVal;
  }

  public void setDcomplexVal(List<Double> dcomplexVal) {
    this.dcomplexVal = dcomplexVal;
  }


  public TensorflowTensorProto doubleVal(List<Double> doubleVal) {
    this.doubleVal = doubleVal;
    return this;
  }

  public TensorflowTensorProto addDoubleValItem(Double doubleValItem) {
    if (this.doubleVal == null) {
      this.doubleVal = new ArrayList<>();
    }
    this.doubleVal.add(doubleValItem);
    return this;
  }

  /**
   * DT_DOUBLE.
   * @return doubleVal
   */
  @javax.annotation.Nullable
  public List<Double> getDoubleVal() {
    return doubleVal;
  }

  public void setDoubleVal(List<Double> doubleVal) {
    this.doubleVal = doubleVal;
  }


  public TensorflowTensorProto dtype(TensorflowDataType dtype) {
    this.dtype = dtype;
    return this;
  }

  /**
   * Get dtype
   * @return dtype
   */
  @javax.annotation.Nullable
  public TensorflowDataType getDtype() {
    return dtype;
  }

  public void setDtype(TensorflowDataType dtype) {
    this.dtype = dtype;
  }


  public TensorflowTensorProto floatVal(List<Float> floatVal) {
    this.floatVal = floatVal;
    return this;
  }

  public TensorflowTensorProto addFloatValItem(Float floatValItem) {
    if (this.floatVal == null) {
      this.floatVal = new ArrayList<>();
    }
    this.floatVal.add(floatValItem);
    return this;
  }

  /**
   * DT_FLOAT.
   * @return floatVal
   */
  @javax.annotation.Nullable
  public List<Float> getFloatVal() {
    return floatVal;
  }

  public void setFloatVal(List<Float> floatVal) {
    this.floatVal = floatVal;
  }


  public TensorflowTensorProto halfVal(List<Integer> halfVal) {
    this.halfVal = halfVal;
    return this;
  }

  public TensorflowTensorProto addHalfValItem(Integer halfValItem) {
    if (this.halfVal == null) {
      this.halfVal = new ArrayList<>();
    }
    this.halfVal.add(halfValItem);
    return this;
  }

  /**
   * DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we&#39;ll have some pointless zero padding for each value here.
   * @return halfVal
   */
  @javax.annotation.Nullable
  public List<Integer> getHalfVal() {
    return halfVal;
  }

  public void setHalfVal(List<Integer> halfVal) {
    this.halfVal = halfVal;
  }


  public TensorflowTensorProto int64Val(List<String> int64Val) {
    this.int64Val = int64Val;
    return this;
  }

  public TensorflowTensorProto addInt64ValItem(String int64ValItem) {
    if (this.int64Val == null) {
      this.int64Val = new ArrayList<>();
    }
    this.int64Val.add(int64ValItem);
    return this;
  }

  /**
   * Get int64Val
   * @return int64Val
   */
  @javax.annotation.Nullable
  public List<String> getInt64Val() {
    return int64Val;
  }

  public void setInt64Val(List<String> int64Val) {
    this.int64Val = int64Val;
  }


  public TensorflowTensorProto intVal(List<Integer> intVal) {
    this.intVal = intVal;
    return this;
  }

  public TensorflowTensorProto addIntValItem(Integer intValItem) {
    if (this.intVal == null) {
      this.intVal = new ArrayList<>();
    }
    this.intVal.add(intValItem);
    return this;
  }

  /**
   * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
   * @return intVal
   */
  @javax.annotation.Nullable
  public List<Integer> getIntVal() {
    return intVal;
  }

  public void setIntVal(List<Integer> intVal) {
    this.intVal = intVal;
  }


  public TensorflowTensorProto resourceHandleVal(List<TensorflowResourceHandleProto> resourceHandleVal) {
    this.resourceHandleVal = resourceHandleVal;
    return this;
  }

  public TensorflowTensorProto addResourceHandleValItem(TensorflowResourceHandleProto resourceHandleValItem) {
    if (this.resourceHandleVal == null) {
      this.resourceHandleVal = new ArrayList<>();
    }
    this.resourceHandleVal.add(resourceHandleValItem);
    return this;
  }

  /**
   * Get resourceHandleVal
   * @return resourceHandleVal
   */
  @javax.annotation.Nullable
  public List<TensorflowResourceHandleProto> getResourceHandleVal() {
    return resourceHandleVal;
  }

  public void setResourceHandleVal(List<TensorflowResourceHandleProto> resourceHandleVal) {
    this.resourceHandleVal = resourceHandleVal;
  }


  public TensorflowTensorProto scomplexVal(List<Float> scomplexVal) {
    this.scomplexVal = scomplexVal;
    return this;
  }

  public TensorflowTensorProto addScomplexValItem(Float scomplexValItem) {
    if (this.scomplexVal == null) {
      this.scomplexVal = new ArrayList<>();
    }
    this.scomplexVal.add(scomplexValItem);
    return this;
  }

  /**
   * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real and imaginary parts of i-th single precision complex.
   * @return scomplexVal
   */
  @javax.annotation.Nullable
  public List<Float> getScomplexVal() {
    return scomplexVal;
  }

  public void setScomplexVal(List<Float> scomplexVal) {
    this.scomplexVal = scomplexVal;
  }


  public TensorflowTensorProto stringVal(List<byte[]> stringVal) {
    this.stringVal = stringVal;
    return this;
  }

  public TensorflowTensorProto addStringValItem(byte[] stringValItem) {
    if (this.stringVal == null) {
      this.stringVal = new ArrayList<>();
    }
    this.stringVal.add(stringValItem);
    return this;
  }

  /**
   * Get stringVal
   * @return stringVal
   */
  @javax.annotation.Nullable
  public List<byte[]> getStringVal() {
    return stringVal;
  }

  public void setStringVal(List<byte[]> stringVal) {
    this.stringVal = stringVal;
  }


  public TensorflowTensorProto tensorContent(byte[] tensorContent) {
    this.tensorContent = tensorContent;
    return this;
  }

  /**
   * Serialized raw tensor content from either Tensor::AsProtoTensorContent or memcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation can be used for all tensor types. The purpose of this representation is to reduce serialization overhead during RPC call by avoiding serialization of many repeated small items.
   * @return tensorContent
   */
  @javax.annotation.Nullable
  public byte[] getTensorContent() {
    return tensorContent;
  }

  public void setTensorContent(byte[] tensorContent) {
    this.tensorContent = tensorContent;
  }


  public TensorflowTensorProto tensorShape(TensorflowTensorShapeProto tensorShape) {
    this.tensorShape = tensorShape;
    return this;
  }

  /**
   * Get tensorShape
   * @return tensorShape
   */
  @javax.annotation.Nullable
  public TensorflowTensorShapeProto getTensorShape() {
    return tensorShape;
  }

  public void setTensorShape(TensorflowTensorShapeProto tensorShape) {
    this.tensorShape = tensorShape;
  }


  public TensorflowTensorProto uint32Val(List<Long> uint32Val) {
    this.uint32Val = uint32Val;
    return this;
  }

  public TensorflowTensorProto addUint32ValItem(Long uint32ValItem) {
    if (this.uint32Val == null) {
      this.uint32Val = new ArrayList<>();
    }
    this.uint32Val.add(uint32ValItem);
    return this;
  }

  /**
   * Get uint32Val
   * @return uint32Val
   */
  @javax.annotation.Nullable
  public List<Long> getUint32Val() {
    return uint32Val;
  }

  public void setUint32Val(List<Long> uint32Val) {
    this.uint32Val = uint32Val;
  }


  public TensorflowTensorProto uint64Val(List<String> uint64Val) {
    this.uint64Val = uint64Val;
    return this;
  }

  public TensorflowTensorProto addUint64ValItem(String uint64ValItem) {
    if (this.uint64Val == null) {
      this.uint64Val = new ArrayList<>();
    }
    this.uint64Val.add(uint64ValItem);
    return this;
  }

  /**
   * Get uint64Val
   * @return uint64Val
   */
  @javax.annotation.Nullable
  public List<String> getUint64Val() {
    return uint64Val;
  }

  public void setUint64Val(List<String> uint64Val) {
    this.uint64Val = uint64Val;
  }


  public TensorflowTensorProto variantVal(List<TensorflowVariantTensorDataProto> variantVal) {
    this.variantVal = variantVal;
    return this;
  }

  public TensorflowTensorProto addVariantValItem(TensorflowVariantTensorDataProto variantValItem) {
    if (this.variantVal == null) {
      this.variantVal = new ArrayList<>();
    }
    this.variantVal.add(variantValItem);
    return this;
  }

  /**
   * Get variantVal
   * @return variantVal
   */
  @javax.annotation.Nullable
  public List<TensorflowVariantTensorDataProto> getVariantVal() {
    return variantVal;
  }

  public void setVariantVal(List<TensorflowVariantTensorDataProto> variantVal) {
    this.variantVal = variantVal;
  }


  public TensorflowTensorProto versionNumber(Integer versionNumber) {
    this.versionNumber = versionNumber;
    return this;
  }

  /**
   * Version number. In version 0, if the \&quot;repeated xxx\&quot; representations contain only one element, that element is repeated to fill the shape.  This makes it easy to represent a constant Tensor with a single value.
   * @return versionNumber
   */
  @javax.annotation.Nullable
  public Integer getVersionNumber() {
    return versionNumber;
  }

  public void setVersionNumber(Integer versionNumber) {
    this.versionNumber = versionNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TensorflowTensorProto tensorflowTensorProto = (TensorflowTensorProto) o;
    return Objects.equals(this.boolVal, tensorflowTensorProto.boolVal) &&
        Objects.equals(this.dcomplexVal, tensorflowTensorProto.dcomplexVal) &&
        Objects.equals(this.doubleVal, tensorflowTensorProto.doubleVal) &&
        Objects.equals(this.dtype, tensorflowTensorProto.dtype) &&
        Objects.equals(this.floatVal, tensorflowTensorProto.floatVal) &&
        Objects.equals(this.halfVal, tensorflowTensorProto.halfVal) &&
        Objects.equals(this.int64Val, tensorflowTensorProto.int64Val) &&
        Objects.equals(this.intVal, tensorflowTensorProto.intVal) &&
        Objects.equals(this.resourceHandleVal, tensorflowTensorProto.resourceHandleVal) &&
        Objects.equals(this.scomplexVal, tensorflowTensorProto.scomplexVal) &&
        Objects.equals(this.stringVal, tensorflowTensorProto.stringVal) &&
        Arrays.equals(this.tensorContent, tensorflowTensorProto.tensorContent) &&
        Objects.equals(this.tensorShape, tensorflowTensorProto.tensorShape) &&
        Objects.equals(this.uint32Val, tensorflowTensorProto.uint32Val) &&
        Objects.equals(this.uint64Val, tensorflowTensorProto.uint64Val) &&
        Objects.equals(this.variantVal, tensorflowTensorProto.variantVal) &&
        Objects.equals(this.versionNumber, tensorflowTensorProto.versionNumber);
  }

  @Override
  public int hashCode() {
    return Objects.hash(boolVal, dcomplexVal, doubleVal, dtype, floatVal, halfVal, int64Val, intVal, resourceHandleVal, scomplexVal, stringVal, Arrays.hashCode(tensorContent), tensorShape, uint32Val, uint64Val, variantVal, versionNumber);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TensorflowTensorProto {\n");
    sb.append("    boolVal: ").append(toIndentedString(boolVal)).append("\n");
    sb.append("    dcomplexVal: ").append(toIndentedString(dcomplexVal)).append("\n");
    sb.append("    doubleVal: ").append(toIndentedString(doubleVal)).append("\n");
    sb.append("    dtype: ").append(toIndentedString(dtype)).append("\n");
    sb.append("    floatVal: ").append(toIndentedString(floatVal)).append("\n");
    sb.append("    halfVal: ").append(toIndentedString(halfVal)).append("\n");
    sb.append("    int64Val: ").append(toIndentedString(int64Val)).append("\n");
    sb.append("    intVal: ").append(toIndentedString(intVal)).append("\n");
    sb.append("    resourceHandleVal: ").append(toIndentedString(resourceHandleVal)).append("\n");
    sb.append("    scomplexVal: ").append(toIndentedString(scomplexVal)).append("\n");
    sb.append("    stringVal: ").append(toIndentedString(stringVal)).append("\n");
    sb.append("    tensorContent: ").append(toIndentedString(tensorContent)).append("\n");
    sb.append("    tensorShape: ").append(toIndentedString(tensorShape)).append("\n");
    sb.append("    uint32Val: ").append(toIndentedString(uint32Val)).append("\n");
    sb.append("    uint64Val: ").append(toIndentedString(uint64Val)).append("\n");
    sb.append("    variantVal: ").append(toIndentedString(variantVal)).append("\n");
    sb.append("    versionNumber: ").append(toIndentedString(versionNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bool_val");
    openapiFields.add("dcomplex_val");
    openapiFields.add("double_val");
    openapiFields.add("dtype");
    openapiFields.add("float_val");
    openapiFields.add("half_val");
    openapiFields.add("int64_val");
    openapiFields.add("int_val");
    openapiFields.add("resource_handle_val");
    openapiFields.add("scomplex_val");
    openapiFields.add("string_val");
    openapiFields.add("tensor_content");
    openapiFields.add("tensor_shape");
    openapiFields.add("uint32_val");
    openapiFields.add("uint64_val");
    openapiFields.add("variant_val");
    openapiFields.add("version_number");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TensorflowTensorProto
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TensorflowTensorProto.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TensorflowTensorProto is not found in the empty JSON string", TensorflowTensorProto.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TensorflowTensorProto.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TensorflowTensorProto` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("bool_val") != null && !jsonObj.get("bool_val").isJsonNull() && !jsonObj.get("bool_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bool_val` to be an array in the JSON string but got `%s`", jsonObj.get("bool_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("dcomplex_val") != null && !jsonObj.get("dcomplex_val").isJsonNull() && !jsonObj.get("dcomplex_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `dcomplex_val` to be an array in the JSON string but got `%s`", jsonObj.get("dcomplex_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("double_val") != null && !jsonObj.get("double_val").isJsonNull() && !jsonObj.get("double_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `double_val` to be an array in the JSON string but got `%s`", jsonObj.get("double_val").toString()));
      }
      // validate the optional field `dtype`
      if (jsonObj.get("dtype") != null && !jsonObj.get("dtype").isJsonNull()) {
        TensorflowDataType.validateJsonElement(jsonObj.get("dtype"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("float_val") != null && !jsonObj.get("float_val").isJsonNull() && !jsonObj.get("float_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `float_val` to be an array in the JSON string but got `%s`", jsonObj.get("float_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("half_val") != null && !jsonObj.get("half_val").isJsonNull() && !jsonObj.get("half_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `half_val` to be an array in the JSON string but got `%s`", jsonObj.get("half_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("int64_val") != null && !jsonObj.get("int64_val").isJsonNull() && !jsonObj.get("int64_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `int64_val` to be an array in the JSON string but got `%s`", jsonObj.get("int64_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("int_val") != null && !jsonObj.get("int_val").isJsonNull() && !jsonObj.get("int_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `int_val` to be an array in the JSON string but got `%s`", jsonObj.get("int_val").toString()));
      }
      if (jsonObj.get("resource_handle_val") != null && !jsonObj.get("resource_handle_val").isJsonNull()) {
        JsonArray jsonArrayresourceHandleVal = jsonObj.getAsJsonArray("resource_handle_val");
        if (jsonArrayresourceHandleVal != null) {
          // ensure the json data is an array
          if (!jsonObj.get("resource_handle_val").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `resource_handle_val` to be an array in the JSON string but got `%s`", jsonObj.get("resource_handle_val").toString()));
          }

          // validate the optional field `resource_handle_val` (array)
          for (int i = 0; i < jsonArrayresourceHandleVal.size(); i++) {
            TensorflowResourceHandleProto.validateJsonElement(jsonArrayresourceHandleVal.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("scomplex_val") != null && !jsonObj.get("scomplex_val").isJsonNull() && !jsonObj.get("scomplex_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `scomplex_val` to be an array in the JSON string but got `%s`", jsonObj.get("scomplex_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("string_val") != null && !jsonObj.get("string_val").isJsonNull() && !jsonObj.get("string_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `string_val` to be an array in the JSON string but got `%s`", jsonObj.get("string_val").toString()));
      }
      // validate the optional field `tensor_shape`
      if (jsonObj.get("tensor_shape") != null && !jsonObj.get("tensor_shape").isJsonNull()) {
        TensorflowTensorShapeProto.validateJsonElement(jsonObj.get("tensor_shape"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("uint32_val") != null && !jsonObj.get("uint32_val").isJsonNull() && !jsonObj.get("uint32_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `uint32_val` to be an array in the JSON string but got `%s`", jsonObj.get("uint32_val").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("uint64_val") != null && !jsonObj.get("uint64_val").isJsonNull() && !jsonObj.get("uint64_val").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `uint64_val` to be an array in the JSON string but got `%s`", jsonObj.get("uint64_val").toString()));
      }
      if (jsonObj.get("variant_val") != null && !jsonObj.get("variant_val").isJsonNull()) {
        JsonArray jsonArrayvariantVal = jsonObj.getAsJsonArray("variant_val");
        if (jsonArrayvariantVal != null) {
          // ensure the json data is an array
          if (!jsonObj.get("variant_val").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `variant_val` to be an array in the JSON string but got `%s`", jsonObj.get("variant_val").toString()));
          }

          // validate the optional field `variant_val` (array)
          for (int i = 0; i < jsonArrayvariantVal.size(); i++) {
            TensorflowVariantTensorDataProto.validateJsonElement(jsonArrayvariantVal.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TensorflowTensorProto.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TensorflowTensorProto' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TensorflowTensorProto> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TensorflowTensorProto.class));

       return (TypeAdapter<T>) new TypeAdapter<TensorflowTensorProto>() {
           @Override
           public void write(JsonWriter out, TensorflowTensorProto value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TensorflowTensorProto read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TensorflowTensorProto given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TensorflowTensorProto
   * @throws IOException if the JSON string is invalid with respect to TensorflowTensorProto
   */
  public static TensorflowTensorProto fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TensorflowTensorProto.class);
  }

  /**
   * Convert an instance of TensorflowTensorProto to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

