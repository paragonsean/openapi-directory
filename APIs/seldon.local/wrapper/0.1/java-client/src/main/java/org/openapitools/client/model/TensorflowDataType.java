/*
 * Seldon External API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.annotations.SerializedName;

import java.io.IOException;
import com.google.gson.TypeAdapter;
import com.google.gson.JsonElement;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

/**
 * - DT_INVALID: Not a legal value for DataType.  Used to indicate a DataType field has not been set.  - DT_FLOAT: Data types that all computation devices are expected to be capable to support.  - DT_FLOAT_REF: Do not use!  These are only for parameters.  Every enum above should have a corresponding value below (verified by types_test).
 */
@JsonAdapter(TensorflowDataType.Adapter.class)
public enum TensorflowDataType {
  
  INVALID("DT_INVALID"),
  
  FLOAT("DT_FLOAT"),
  
  DOUBLE("DT_DOUBLE"),
  
  INT32("DT_INT32"),
  
  UINT8("DT_UINT8"),
  
  INT16("DT_INT16"),
  
  INT8("DT_INT8"),
  
  STRING("DT_STRING"),
  
  COMPLEX64("DT_COMPLEX64"),
  
  INT64("DT_INT64"),
  
  BOOL("DT_BOOL"),
  
  QINT8("DT_QINT8"),
  
  QUINT8("DT_QUINT8"),
  
  QINT32("DT_QINT32"),
  
  BFLOAT16("DT_BFLOAT16"),
  
  QINT16("DT_QINT16"),
  
  QUINT16("DT_QUINT16"),
  
  UINT16("DT_UINT16"),
  
  COMPLEX128("DT_COMPLEX128"),
  
  HALF("DT_HALF"),
  
  RESOURCE("DT_RESOURCE"),
  
  VARIANT("DT_VARIANT"),
  
  UINT32("DT_UINT32"),
  
  UINT64("DT_UINT64"),
  
  FLOAT_REF("DT_FLOAT_REF"),
  
  DOUBLE_REF("DT_DOUBLE_REF"),
  
  INT32_REF("DT_INT32_REF"),
  
  UINT8_REF("DT_UINT8_REF"),
  
  INT16_REF("DT_INT16_REF"),
  
  INT8_REF("DT_INT8_REF"),
  
  STRING_REF("DT_STRING_REF"),
  
  COMPLEX64_REF("DT_COMPLEX64_REF"),
  
  INT64_REF("DT_INT64_REF"),
  
  BOOL_REF("DT_BOOL_REF"),
  
  QINT8_REF("DT_QINT8_REF"),
  
  QUINT8_REF("DT_QUINT8_REF"),
  
  QINT32_REF("DT_QINT32_REF"),
  
  BFLOAT16_REF("DT_BFLOAT16_REF"),
  
  QINT16_REF("DT_QINT16_REF"),
  
  QUINT16_REF("DT_QUINT16_REF"),
  
  UINT16_REF("DT_UINT16_REF"),
  
  COMPLEX128_REF("DT_COMPLEX128_REF"),
  
  HALF_REF("DT_HALF_REF"),
  
  RESOURCE_REF("DT_RESOURCE_REF"),
  
  VARIANT_REF("DT_VARIANT_REF"),
  
  UINT32_REF("DT_UINT32_REF"),
  
  UINT64_REF("DT_UINT64_REF");

  private String value;

  TensorflowDataType(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static TensorflowDataType fromValue(String value) {
    for (TensorflowDataType b : TensorflowDataType.values()) {
      if (b.value.equals(value)) {
        return b;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }

  public static class Adapter extends TypeAdapter<TensorflowDataType> {
    @Override
    public void write(final JsonWriter jsonWriter, final TensorflowDataType enumeration) throws IOException {
      jsonWriter.value(enumeration.getValue());
    }

    @Override
    public TensorflowDataType read(final JsonReader jsonReader) throws IOException {
      String value = jsonReader.nextString();
      return TensorflowDataType.fromValue(value);
    }
  }

  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    String value = jsonElement.getAsString();
    TensorflowDataType.fromValue(value);
  }
}

