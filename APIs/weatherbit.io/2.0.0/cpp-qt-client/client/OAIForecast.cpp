/**
 * Weatherbit - Interactive Swagger UI Documentation
 * This an interactive version of the documentation for the Weatherbit API.  The base URL for the API is [http://api.weatherbit.io/v2.0/](http://api.weatherbit.io/v2.0/) or [https://api.weatherbit.io/v2.0/](http://api.weatherbit.io/v2.0/). Below is the Swagger UI documentation for the API. All API requests require the `key` parameter.        An Example for a 48 hour forecast for London, UK would be `http://api.weatherbit.io/v2.0/forecast/hourly?lat=51.5072`&`lon=-0.1276`. See our [Weather API description page](https://www.weatherbit.io/api) for the full documentation.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIForecast.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIForecast::OAIForecast(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIForecast::OAIForecast() {
    this->initializeModel();
}

OAIForecast::~OAIForecast() {}

void OAIForecast::initializeModel() {

    m_app_max_temp_isSet = false;
    m_app_max_temp_isValid = false;

    m_app_min_temp_isSet = false;
    m_app_min_temp_isValid = false;

    m_clouds_isSet = false;
    m_clouds_isValid = false;

    m_datetime_isSet = false;
    m_datetime_isValid = false;

    m_dewpt_isSet = false;
    m_dewpt_isValid = false;

    m_max_dhi_isSet = false;
    m_max_dhi_isValid = false;

    m_max_temp_isSet = false;
    m_max_temp_isValid = false;

    m_min_temp_isSet = false;
    m_min_temp_isValid = false;

    m_moon_phase_isSet = false;
    m_moon_phase_isValid = false;

    m_moonrise_ts_isSet = false;
    m_moonrise_ts_isValid = false;

    m_moonset_ts_isSet = false;
    m_moonset_ts_isValid = false;

    m_pod_isSet = false;
    m_pod_isValid = false;

    m_pop_isSet = false;
    m_pop_isValid = false;

    m_precip_isSet = false;
    m_precip_isValid = false;

    m_pres_isSet = false;
    m_pres_isValid = false;

    m_rh_isSet = false;
    m_rh_isValid = false;

    m_slp_isSet = false;
    m_slp_isValid = false;

    m_snow_isSet = false;
    m_snow_isValid = false;

    m_snow_depth_isSet = false;
    m_snow_depth_isValid = false;

    m_sunrise_ts_isSet = false;
    m_sunrise_ts_isValid = false;

    m_sunset_ts_isSet = false;
    m_sunset_ts_isValid = false;

    m_temp_isSet = false;
    m_temp_isValid = false;

    m_timestamp_local_isSet = false;
    m_timestamp_local_isValid = false;

    m_timestamp_utc_isSet = false;
    m_timestamp_utc_isValid = false;

    m_ts_isSet = false;
    m_ts_isValid = false;

    m_uv_isSet = false;
    m_uv_isValid = false;

    m_vis_isSet = false;
    m_vis_isValid = false;

    m_weather_isSet = false;
    m_weather_isValid = false;

    m_wind_cdir_isSet = false;
    m_wind_cdir_isValid = false;

    m_wind_cdir_full_isSet = false;
    m_wind_cdir_full_isValid = false;

    m_wind_dir_isSet = false;
    m_wind_dir_isValid = false;

    m_wind_spd_isSet = false;
    m_wind_spd_isValid = false;
}

void OAIForecast::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIForecast::fromJsonObject(QJsonObject json) {

    m_app_max_temp_isValid = ::OpenAPI::fromJsonValue(m_app_max_temp, json[QString("app_max_temp")]);
    m_app_max_temp_isSet = !json[QString("app_max_temp")].isNull() && m_app_max_temp_isValid;

    m_app_min_temp_isValid = ::OpenAPI::fromJsonValue(m_app_min_temp, json[QString("app_min_temp")]);
    m_app_min_temp_isSet = !json[QString("app_min_temp")].isNull() && m_app_min_temp_isValid;

    m_clouds_isValid = ::OpenAPI::fromJsonValue(m_clouds, json[QString("clouds")]);
    m_clouds_isSet = !json[QString("clouds")].isNull() && m_clouds_isValid;

    m_datetime_isValid = ::OpenAPI::fromJsonValue(m_datetime, json[QString("datetime")]);
    m_datetime_isSet = !json[QString("datetime")].isNull() && m_datetime_isValid;

    m_dewpt_isValid = ::OpenAPI::fromJsonValue(m_dewpt, json[QString("dewpt")]);
    m_dewpt_isSet = !json[QString("dewpt")].isNull() && m_dewpt_isValid;

    m_max_dhi_isValid = ::OpenAPI::fromJsonValue(m_max_dhi, json[QString("max_dhi")]);
    m_max_dhi_isSet = !json[QString("max_dhi")].isNull() && m_max_dhi_isValid;

    m_max_temp_isValid = ::OpenAPI::fromJsonValue(m_max_temp, json[QString("max_temp")]);
    m_max_temp_isSet = !json[QString("max_temp")].isNull() && m_max_temp_isValid;

    m_min_temp_isValid = ::OpenAPI::fromJsonValue(m_min_temp, json[QString("min_temp")]);
    m_min_temp_isSet = !json[QString("min_temp")].isNull() && m_min_temp_isValid;

    m_moon_phase_isValid = ::OpenAPI::fromJsonValue(m_moon_phase, json[QString("moon_phase")]);
    m_moon_phase_isSet = !json[QString("moon_phase")].isNull() && m_moon_phase_isValid;

    m_moonrise_ts_isValid = ::OpenAPI::fromJsonValue(m_moonrise_ts, json[QString("moonrise_ts")]);
    m_moonrise_ts_isSet = !json[QString("moonrise_ts")].isNull() && m_moonrise_ts_isValid;

    m_moonset_ts_isValid = ::OpenAPI::fromJsonValue(m_moonset_ts, json[QString("moonset_ts")]);
    m_moonset_ts_isSet = !json[QString("moonset_ts")].isNull() && m_moonset_ts_isValid;

    m_pod_isValid = ::OpenAPI::fromJsonValue(m_pod, json[QString("pod")]);
    m_pod_isSet = !json[QString("pod")].isNull() && m_pod_isValid;

    m_pop_isValid = ::OpenAPI::fromJsonValue(m_pop, json[QString("pop")]);
    m_pop_isSet = !json[QString("pop")].isNull() && m_pop_isValid;

    m_precip_isValid = ::OpenAPI::fromJsonValue(m_precip, json[QString("precip")]);
    m_precip_isSet = !json[QString("precip")].isNull() && m_precip_isValid;

    m_pres_isValid = ::OpenAPI::fromJsonValue(m_pres, json[QString("pres")]);
    m_pres_isSet = !json[QString("pres")].isNull() && m_pres_isValid;

    m_rh_isValid = ::OpenAPI::fromJsonValue(m_rh, json[QString("rh")]);
    m_rh_isSet = !json[QString("rh")].isNull() && m_rh_isValid;

    m_slp_isValid = ::OpenAPI::fromJsonValue(m_slp, json[QString("slp")]);
    m_slp_isSet = !json[QString("slp")].isNull() && m_slp_isValid;

    m_snow_isValid = ::OpenAPI::fromJsonValue(m_snow, json[QString("snow")]);
    m_snow_isSet = !json[QString("snow")].isNull() && m_snow_isValid;

    m_snow_depth_isValid = ::OpenAPI::fromJsonValue(m_snow_depth, json[QString("snow_depth")]);
    m_snow_depth_isSet = !json[QString("snow_depth")].isNull() && m_snow_depth_isValid;

    m_sunrise_ts_isValid = ::OpenAPI::fromJsonValue(m_sunrise_ts, json[QString("sunrise_ts")]);
    m_sunrise_ts_isSet = !json[QString("sunrise_ts")].isNull() && m_sunrise_ts_isValid;

    m_sunset_ts_isValid = ::OpenAPI::fromJsonValue(m_sunset_ts, json[QString("sunset_ts")]);
    m_sunset_ts_isSet = !json[QString("sunset_ts")].isNull() && m_sunset_ts_isValid;

    m_temp_isValid = ::OpenAPI::fromJsonValue(m_temp, json[QString("temp")]);
    m_temp_isSet = !json[QString("temp")].isNull() && m_temp_isValid;

    m_timestamp_local_isValid = ::OpenAPI::fromJsonValue(m_timestamp_local, json[QString("timestamp_local")]);
    m_timestamp_local_isSet = !json[QString("timestamp_local")].isNull() && m_timestamp_local_isValid;

    m_timestamp_utc_isValid = ::OpenAPI::fromJsonValue(m_timestamp_utc, json[QString("timestamp_utc")]);
    m_timestamp_utc_isSet = !json[QString("timestamp_utc")].isNull() && m_timestamp_utc_isValid;

    m_ts_isValid = ::OpenAPI::fromJsonValue(m_ts, json[QString("ts")]);
    m_ts_isSet = !json[QString("ts")].isNull() && m_ts_isValid;

    m_uv_isValid = ::OpenAPI::fromJsonValue(m_uv, json[QString("uv")]);
    m_uv_isSet = !json[QString("uv")].isNull() && m_uv_isValid;

    m_vis_isValid = ::OpenAPI::fromJsonValue(m_vis, json[QString("vis")]);
    m_vis_isSet = !json[QString("vis")].isNull() && m_vis_isValid;

    m_weather_isValid = ::OpenAPI::fromJsonValue(m_weather, json[QString("weather")]);
    m_weather_isSet = !json[QString("weather")].isNull() && m_weather_isValid;

    m_wind_cdir_isValid = ::OpenAPI::fromJsonValue(m_wind_cdir, json[QString("wind_cdir")]);
    m_wind_cdir_isSet = !json[QString("wind_cdir")].isNull() && m_wind_cdir_isValid;

    m_wind_cdir_full_isValid = ::OpenAPI::fromJsonValue(m_wind_cdir_full, json[QString("wind_cdir_full")]);
    m_wind_cdir_full_isSet = !json[QString("wind_cdir_full")].isNull() && m_wind_cdir_full_isValid;

    m_wind_dir_isValid = ::OpenAPI::fromJsonValue(m_wind_dir, json[QString("wind_dir")]);
    m_wind_dir_isSet = !json[QString("wind_dir")].isNull() && m_wind_dir_isValid;

    m_wind_spd_isValid = ::OpenAPI::fromJsonValue(m_wind_spd, json[QString("wind_spd")]);
    m_wind_spd_isSet = !json[QString("wind_spd")].isNull() && m_wind_spd_isValid;
}

QString OAIForecast::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIForecast::asJsonObject() const {
    QJsonObject obj;
    if (m_app_max_temp_isSet) {
        obj.insert(QString("app_max_temp"), ::OpenAPI::toJsonValue(m_app_max_temp));
    }
    if (m_app_min_temp_isSet) {
        obj.insert(QString("app_min_temp"), ::OpenAPI::toJsonValue(m_app_min_temp));
    }
    if (m_clouds_isSet) {
        obj.insert(QString("clouds"), ::OpenAPI::toJsonValue(m_clouds));
    }
    if (m_datetime_isSet) {
        obj.insert(QString("datetime"), ::OpenAPI::toJsonValue(m_datetime));
    }
    if (m_dewpt_isSet) {
        obj.insert(QString("dewpt"), ::OpenAPI::toJsonValue(m_dewpt));
    }
    if (m_max_dhi_isSet) {
        obj.insert(QString("max_dhi"), ::OpenAPI::toJsonValue(m_max_dhi));
    }
    if (m_max_temp_isSet) {
        obj.insert(QString("max_temp"), ::OpenAPI::toJsonValue(m_max_temp));
    }
    if (m_min_temp_isSet) {
        obj.insert(QString("min_temp"), ::OpenAPI::toJsonValue(m_min_temp));
    }
    if (m_moon_phase_isSet) {
        obj.insert(QString("moon_phase"), ::OpenAPI::toJsonValue(m_moon_phase));
    }
    if (m_moonrise_ts_isSet) {
        obj.insert(QString("moonrise_ts"), ::OpenAPI::toJsonValue(m_moonrise_ts));
    }
    if (m_moonset_ts_isSet) {
        obj.insert(QString("moonset_ts"), ::OpenAPI::toJsonValue(m_moonset_ts));
    }
    if (m_pod_isSet) {
        obj.insert(QString("pod"), ::OpenAPI::toJsonValue(m_pod));
    }
    if (m_pop_isSet) {
        obj.insert(QString("pop"), ::OpenAPI::toJsonValue(m_pop));
    }
    if (m_precip_isSet) {
        obj.insert(QString("precip"), ::OpenAPI::toJsonValue(m_precip));
    }
    if (m_pres_isSet) {
        obj.insert(QString("pres"), ::OpenAPI::toJsonValue(m_pres));
    }
    if (m_rh_isSet) {
        obj.insert(QString("rh"), ::OpenAPI::toJsonValue(m_rh));
    }
    if (m_slp_isSet) {
        obj.insert(QString("slp"), ::OpenAPI::toJsonValue(m_slp));
    }
    if (m_snow_isSet) {
        obj.insert(QString("snow"), ::OpenAPI::toJsonValue(m_snow));
    }
    if (m_snow_depth_isSet) {
        obj.insert(QString("snow_depth"), ::OpenAPI::toJsonValue(m_snow_depth));
    }
    if (m_sunrise_ts_isSet) {
        obj.insert(QString("sunrise_ts"), ::OpenAPI::toJsonValue(m_sunrise_ts));
    }
    if (m_sunset_ts_isSet) {
        obj.insert(QString("sunset_ts"), ::OpenAPI::toJsonValue(m_sunset_ts));
    }
    if (m_temp_isSet) {
        obj.insert(QString("temp"), ::OpenAPI::toJsonValue(m_temp));
    }
    if (m_timestamp_local_isSet) {
        obj.insert(QString("timestamp_local"), ::OpenAPI::toJsonValue(m_timestamp_local));
    }
    if (m_timestamp_utc_isSet) {
        obj.insert(QString("timestamp_utc"), ::OpenAPI::toJsonValue(m_timestamp_utc));
    }
    if (m_ts_isSet) {
        obj.insert(QString("ts"), ::OpenAPI::toJsonValue(m_ts));
    }
    if (m_uv_isSet) {
        obj.insert(QString("uv"), ::OpenAPI::toJsonValue(m_uv));
    }
    if (m_vis_isSet) {
        obj.insert(QString("vis"), ::OpenAPI::toJsonValue(m_vis));
    }
    if (m_weather.isSet()) {
        obj.insert(QString("weather"), ::OpenAPI::toJsonValue(m_weather));
    }
    if (m_wind_cdir_isSet) {
        obj.insert(QString("wind_cdir"), ::OpenAPI::toJsonValue(m_wind_cdir));
    }
    if (m_wind_cdir_full_isSet) {
        obj.insert(QString("wind_cdir_full"), ::OpenAPI::toJsonValue(m_wind_cdir_full));
    }
    if (m_wind_dir_isSet) {
        obj.insert(QString("wind_dir"), ::OpenAPI::toJsonValue(m_wind_dir));
    }
    if (m_wind_spd_isSet) {
        obj.insert(QString("wind_spd"), ::OpenAPI::toJsonValue(m_wind_spd));
    }
    return obj;
}

double OAIForecast::getAppMaxTemp() const {
    return m_app_max_temp;
}
void OAIForecast::setAppMaxTemp(const double &app_max_temp) {
    m_app_max_temp = app_max_temp;
    m_app_max_temp_isSet = true;
}

bool OAIForecast::is_app_max_temp_Set() const{
    return m_app_max_temp_isSet;
}

bool OAIForecast::is_app_max_temp_Valid() const{
    return m_app_max_temp_isValid;
}

double OAIForecast::getAppMinTemp() const {
    return m_app_min_temp;
}
void OAIForecast::setAppMinTemp(const double &app_min_temp) {
    m_app_min_temp = app_min_temp;
    m_app_min_temp_isSet = true;
}

bool OAIForecast::is_app_min_temp_Set() const{
    return m_app_min_temp_isSet;
}

bool OAIForecast::is_app_min_temp_Valid() const{
    return m_app_min_temp_isValid;
}

qint32 OAIForecast::getClouds() const {
    return m_clouds;
}
void OAIForecast::setClouds(const qint32 &clouds) {
    m_clouds = clouds;
    m_clouds_isSet = true;
}

bool OAIForecast::is_clouds_Set() const{
    return m_clouds_isSet;
}

bool OAIForecast::is_clouds_Valid() const{
    return m_clouds_isValid;
}

QString OAIForecast::getDatetime() const {
    return m_datetime;
}
void OAIForecast::setDatetime(const QString &datetime) {
    m_datetime = datetime;
    m_datetime_isSet = true;
}

bool OAIForecast::is_datetime_Set() const{
    return m_datetime_isSet;
}

bool OAIForecast::is_datetime_Valid() const{
    return m_datetime_isValid;
}

double OAIForecast::getDewpt() const {
    return m_dewpt;
}
void OAIForecast::setDewpt(const double &dewpt) {
    m_dewpt = dewpt;
    m_dewpt_isSet = true;
}

bool OAIForecast::is_dewpt_Set() const{
    return m_dewpt_isSet;
}

bool OAIForecast::is_dewpt_Valid() const{
    return m_dewpt_isValid;
}

double OAIForecast::getMaxDhi() const {
    return m_max_dhi;
}
void OAIForecast::setMaxDhi(const double &max_dhi) {
    m_max_dhi = max_dhi;
    m_max_dhi_isSet = true;
}

bool OAIForecast::is_max_dhi_Set() const{
    return m_max_dhi_isSet;
}

bool OAIForecast::is_max_dhi_Valid() const{
    return m_max_dhi_isValid;
}

double OAIForecast::getMaxTemp() const {
    return m_max_temp;
}
void OAIForecast::setMaxTemp(const double &max_temp) {
    m_max_temp = max_temp;
    m_max_temp_isSet = true;
}

bool OAIForecast::is_max_temp_Set() const{
    return m_max_temp_isSet;
}

bool OAIForecast::is_max_temp_Valid() const{
    return m_max_temp_isValid;
}

double OAIForecast::getMinTemp() const {
    return m_min_temp;
}
void OAIForecast::setMinTemp(const double &min_temp) {
    m_min_temp = min_temp;
    m_min_temp_isSet = true;
}

bool OAIForecast::is_min_temp_Set() const{
    return m_min_temp_isSet;
}

bool OAIForecast::is_min_temp_Valid() const{
    return m_min_temp_isValid;
}

double OAIForecast::getMoonPhase() const {
    return m_moon_phase;
}
void OAIForecast::setMoonPhase(const double &moon_phase) {
    m_moon_phase = moon_phase;
    m_moon_phase_isSet = true;
}

bool OAIForecast::is_moon_phase_Set() const{
    return m_moon_phase_isSet;
}

bool OAIForecast::is_moon_phase_Valid() const{
    return m_moon_phase_isValid;
}

qint32 OAIForecast::getMoonriseTs() const {
    return m_moonrise_ts;
}
void OAIForecast::setMoonriseTs(const qint32 &moonrise_ts) {
    m_moonrise_ts = moonrise_ts;
    m_moonrise_ts_isSet = true;
}

bool OAIForecast::is_moonrise_ts_Set() const{
    return m_moonrise_ts_isSet;
}

bool OAIForecast::is_moonrise_ts_Valid() const{
    return m_moonrise_ts_isValid;
}

qint32 OAIForecast::getMoonsetTs() const {
    return m_moonset_ts;
}
void OAIForecast::setMoonsetTs(const qint32 &moonset_ts) {
    m_moonset_ts = moonset_ts;
    m_moonset_ts_isSet = true;
}

bool OAIForecast::is_moonset_ts_Set() const{
    return m_moonset_ts_isSet;
}

bool OAIForecast::is_moonset_ts_Valid() const{
    return m_moonset_ts_isValid;
}

QString OAIForecast::getPod() const {
    return m_pod;
}
void OAIForecast::setPod(const QString &pod) {
    m_pod = pod;
    m_pod_isSet = true;
}

bool OAIForecast::is_pod_Set() const{
    return m_pod_isSet;
}

bool OAIForecast::is_pod_Valid() const{
    return m_pod_isValid;
}

double OAIForecast::getPop() const {
    return m_pop;
}
void OAIForecast::setPop(const double &pop) {
    m_pop = pop;
    m_pop_isSet = true;
}

bool OAIForecast::is_pop_Set() const{
    return m_pop_isSet;
}

bool OAIForecast::is_pop_Valid() const{
    return m_pop_isValid;
}

double OAIForecast::getPrecip() const {
    return m_precip;
}
void OAIForecast::setPrecip(const double &precip) {
    m_precip = precip;
    m_precip_isSet = true;
}

bool OAIForecast::is_precip_Set() const{
    return m_precip_isSet;
}

bool OAIForecast::is_precip_Valid() const{
    return m_precip_isValid;
}

double OAIForecast::getPres() const {
    return m_pres;
}
void OAIForecast::setPres(const double &pres) {
    m_pres = pres;
    m_pres_isSet = true;
}

bool OAIForecast::is_pres_Set() const{
    return m_pres_isSet;
}

bool OAIForecast::is_pres_Valid() const{
    return m_pres_isValid;
}

qint32 OAIForecast::getRh() const {
    return m_rh;
}
void OAIForecast::setRh(const qint32 &rh) {
    m_rh = rh;
    m_rh_isSet = true;
}

bool OAIForecast::is_rh_Set() const{
    return m_rh_isSet;
}

bool OAIForecast::is_rh_Valid() const{
    return m_rh_isValid;
}

double OAIForecast::getSlp() const {
    return m_slp;
}
void OAIForecast::setSlp(const double &slp) {
    m_slp = slp;
    m_slp_isSet = true;
}

bool OAIForecast::is_slp_Set() const{
    return m_slp_isSet;
}

bool OAIForecast::is_slp_Valid() const{
    return m_slp_isValid;
}

double OAIForecast::getSnow() const {
    return m_snow;
}
void OAIForecast::setSnow(const double &snow) {
    m_snow = snow;
    m_snow_isSet = true;
}

bool OAIForecast::is_snow_Set() const{
    return m_snow_isSet;
}

bool OAIForecast::is_snow_Valid() const{
    return m_snow_isValid;
}

double OAIForecast::getSnowDepth() const {
    return m_snow_depth;
}
void OAIForecast::setSnowDepth(const double &snow_depth) {
    m_snow_depth = snow_depth;
    m_snow_depth_isSet = true;
}

bool OAIForecast::is_snow_depth_Set() const{
    return m_snow_depth_isSet;
}

bool OAIForecast::is_snow_depth_Valid() const{
    return m_snow_depth_isValid;
}

qint32 OAIForecast::getSunriseTs() const {
    return m_sunrise_ts;
}
void OAIForecast::setSunriseTs(const qint32 &sunrise_ts) {
    m_sunrise_ts = sunrise_ts;
    m_sunrise_ts_isSet = true;
}

bool OAIForecast::is_sunrise_ts_Set() const{
    return m_sunrise_ts_isSet;
}

bool OAIForecast::is_sunrise_ts_Valid() const{
    return m_sunrise_ts_isValid;
}

qint32 OAIForecast::getSunsetTs() const {
    return m_sunset_ts;
}
void OAIForecast::setSunsetTs(const qint32 &sunset_ts) {
    m_sunset_ts = sunset_ts;
    m_sunset_ts_isSet = true;
}

bool OAIForecast::is_sunset_ts_Set() const{
    return m_sunset_ts_isSet;
}

bool OAIForecast::is_sunset_ts_Valid() const{
    return m_sunset_ts_isValid;
}

double OAIForecast::getTemp() const {
    return m_temp;
}
void OAIForecast::setTemp(const double &temp) {
    m_temp = temp;
    m_temp_isSet = true;
}

bool OAIForecast::is_temp_Set() const{
    return m_temp_isSet;
}

bool OAIForecast::is_temp_Valid() const{
    return m_temp_isValid;
}

QString OAIForecast::getTimestampLocal() const {
    return m_timestamp_local;
}
void OAIForecast::setTimestampLocal(const QString &timestamp_local) {
    m_timestamp_local = timestamp_local;
    m_timestamp_local_isSet = true;
}

bool OAIForecast::is_timestamp_local_Set() const{
    return m_timestamp_local_isSet;
}

bool OAIForecast::is_timestamp_local_Valid() const{
    return m_timestamp_local_isValid;
}

QString OAIForecast::getTimestampUtc() const {
    return m_timestamp_utc;
}
void OAIForecast::setTimestampUtc(const QString &timestamp_utc) {
    m_timestamp_utc = timestamp_utc;
    m_timestamp_utc_isSet = true;
}

bool OAIForecast::is_timestamp_utc_Set() const{
    return m_timestamp_utc_isSet;
}

bool OAIForecast::is_timestamp_utc_Valid() const{
    return m_timestamp_utc_isValid;
}

double OAIForecast::getTs() const {
    return m_ts;
}
void OAIForecast::setTs(const double &ts) {
    m_ts = ts;
    m_ts_isSet = true;
}

bool OAIForecast::is_ts_Set() const{
    return m_ts_isSet;
}

bool OAIForecast::is_ts_Valid() const{
    return m_ts_isValid;
}

double OAIForecast::getUv() const {
    return m_uv;
}
void OAIForecast::setUv(const double &uv) {
    m_uv = uv;
    m_uv_isSet = true;
}

bool OAIForecast::is_uv_Set() const{
    return m_uv_isSet;
}

bool OAIForecast::is_uv_Valid() const{
    return m_uv_isValid;
}

double OAIForecast::getVis() const {
    return m_vis;
}
void OAIForecast::setVis(const double &vis) {
    m_vis = vis;
    m_vis_isSet = true;
}

bool OAIForecast::is_vis_Set() const{
    return m_vis_isSet;
}

bool OAIForecast::is_vis_Valid() const{
    return m_vis_isValid;
}

OAIForecast_weather OAIForecast::getWeather() const {
    return m_weather;
}
void OAIForecast::setWeather(const OAIForecast_weather &weather) {
    m_weather = weather;
    m_weather_isSet = true;
}

bool OAIForecast::is_weather_Set() const{
    return m_weather_isSet;
}

bool OAIForecast::is_weather_Valid() const{
    return m_weather_isValid;
}

QString OAIForecast::getWindCdir() const {
    return m_wind_cdir;
}
void OAIForecast::setWindCdir(const QString &wind_cdir) {
    m_wind_cdir = wind_cdir;
    m_wind_cdir_isSet = true;
}

bool OAIForecast::is_wind_cdir_Set() const{
    return m_wind_cdir_isSet;
}

bool OAIForecast::is_wind_cdir_Valid() const{
    return m_wind_cdir_isValid;
}

QString OAIForecast::getWindCdirFull() const {
    return m_wind_cdir_full;
}
void OAIForecast::setWindCdirFull(const QString &wind_cdir_full) {
    m_wind_cdir_full = wind_cdir_full;
    m_wind_cdir_full_isSet = true;
}

bool OAIForecast::is_wind_cdir_full_Set() const{
    return m_wind_cdir_full_isSet;
}

bool OAIForecast::is_wind_cdir_full_Valid() const{
    return m_wind_cdir_full_isValid;
}

qint32 OAIForecast::getWindDir() const {
    return m_wind_dir;
}
void OAIForecast::setWindDir(const qint32 &wind_dir) {
    m_wind_dir = wind_dir;
    m_wind_dir_isSet = true;
}

bool OAIForecast::is_wind_dir_Set() const{
    return m_wind_dir_isSet;
}

bool OAIForecast::is_wind_dir_Valid() const{
    return m_wind_dir_isValid;
}

double OAIForecast::getWindSpd() const {
    return m_wind_spd;
}
void OAIForecast::setWindSpd(const double &wind_spd) {
    m_wind_spd = wind_spd;
    m_wind_spd_isSet = true;
}

bool OAIForecast::is_wind_spd_Set() const{
    return m_wind_spd_isSet;
}

bool OAIForecast::is_wind_spd_Valid() const{
    return m_wind_spd_isValid;
}

bool OAIForecast::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_app_max_temp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_app_min_temp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_clouds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_datetime_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dewpt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_dhi_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_temp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_temp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_moon_phase_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_moonrise_ts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_moonset_ts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pod_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pop_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_precip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pres_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rh_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_slp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_snow_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_snow_depth_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sunrise_ts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sunset_ts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_temp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_local_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_utc_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uv_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vis_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_weather.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_cdir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_cdir_full_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_dir_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_spd_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIForecast::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
