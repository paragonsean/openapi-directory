/*
 * Weatherbit - Interactive Swagger UI Documentation
 * This an interactive version of the documentation for the Weatherbit API.  The base URL for the API is [http://api.weatherbit.io/v2.0/](http://api.weatherbit.io/v2.0/) or [https://api.weatherbit.io/v2.0/](http://api.weatherbit.io/v2.0/). Below is the Swagger UI documentation for the API. All API requests require the `key` parameter.        An Example for a 48 hour forecast for London, UK would be `http://api.weatherbit.io/v2.0/forecast/hourly?lat=51.5072`&`lon=-0.1276`. See our [Weather API description page](https://www.weatherbit.io/api) for the full documentation.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import org.openapitools.client.model.ForecastWeather;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Forecast
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:53:54.635462-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Forecast {
  public static final String SERIALIZED_NAME_APP_MAX_TEMP = "app_max_temp";
  @SerializedName(SERIALIZED_NAME_APP_MAX_TEMP)
  private BigDecimal appMaxTemp;

  public static final String SERIALIZED_NAME_APP_MIN_TEMP = "app_min_temp";
  @SerializedName(SERIALIZED_NAME_APP_MIN_TEMP)
  private BigDecimal appMinTemp;

  public static final String SERIALIZED_NAME_CLOUDS = "clouds";
  @SerializedName(SERIALIZED_NAME_CLOUDS)
  private Integer clouds;

  public static final String SERIALIZED_NAME_DATETIME = "datetime";
  @SerializedName(SERIALIZED_NAME_DATETIME)
  private String datetime;

  public static final String SERIALIZED_NAME_DEWPT = "dewpt";
  @SerializedName(SERIALIZED_NAME_DEWPT)
  private BigDecimal dewpt;

  public static final String SERIALIZED_NAME_MAX_DHI = "max_dhi";
  @SerializedName(SERIALIZED_NAME_MAX_DHI)
  private BigDecimal maxDhi;

  public static final String SERIALIZED_NAME_MAX_TEMP = "max_temp";
  @SerializedName(SERIALIZED_NAME_MAX_TEMP)
  private BigDecimal maxTemp;

  public static final String SERIALIZED_NAME_MIN_TEMP = "min_temp";
  @SerializedName(SERIALIZED_NAME_MIN_TEMP)
  private BigDecimal minTemp;

  public static final String SERIALIZED_NAME_MOON_PHASE = "moon_phase";
  @SerializedName(SERIALIZED_NAME_MOON_PHASE)
  private BigDecimal moonPhase;

  public static final String SERIALIZED_NAME_MOONRISE_TS = "moonrise_ts";
  @SerializedName(SERIALIZED_NAME_MOONRISE_TS)
  private Integer moonriseTs;

  public static final String SERIALIZED_NAME_MOONSET_TS = "moonset_ts";
  @SerializedName(SERIALIZED_NAME_MOONSET_TS)
  private Integer moonsetTs;

  public static final String SERIALIZED_NAME_POD = "pod";
  @SerializedName(SERIALIZED_NAME_POD)
  private String pod;

  public static final String SERIALIZED_NAME_POP = "pop";
  @SerializedName(SERIALIZED_NAME_POP)
  private BigDecimal pop;

  public static final String SERIALIZED_NAME_PRECIP = "precip";
  @SerializedName(SERIALIZED_NAME_PRECIP)
  private BigDecimal precip;

  public static final String SERIALIZED_NAME_PRES = "pres";
  @SerializedName(SERIALIZED_NAME_PRES)
  private BigDecimal pres;

  public static final String SERIALIZED_NAME_RH = "rh";
  @SerializedName(SERIALIZED_NAME_RH)
  private Integer rh;

  public static final String SERIALIZED_NAME_SLP = "slp";
  @SerializedName(SERIALIZED_NAME_SLP)
  private BigDecimal slp;

  public static final String SERIALIZED_NAME_SNOW = "snow";
  @SerializedName(SERIALIZED_NAME_SNOW)
  private BigDecimal snow;

  public static final String SERIALIZED_NAME_SNOW_DEPTH = "snow_depth";
  @SerializedName(SERIALIZED_NAME_SNOW_DEPTH)
  private BigDecimal snowDepth;

  public static final String SERIALIZED_NAME_SUNRISE_TS = "sunrise_ts";
  @SerializedName(SERIALIZED_NAME_SUNRISE_TS)
  private Integer sunriseTs;

  public static final String SERIALIZED_NAME_SUNSET_TS = "sunset_ts";
  @SerializedName(SERIALIZED_NAME_SUNSET_TS)
  private Integer sunsetTs;

  public static final String SERIALIZED_NAME_TEMP = "temp";
  @SerializedName(SERIALIZED_NAME_TEMP)
  private BigDecimal temp;

  public static final String SERIALIZED_NAME_TIMESTAMP_LOCAL = "timestamp_local";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_LOCAL)
  private String timestampLocal;

  public static final String SERIALIZED_NAME_TIMESTAMP_UTC = "timestamp_utc";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_UTC)
  private String timestampUtc;

  public static final String SERIALIZED_NAME_TS = "ts";
  @SerializedName(SERIALIZED_NAME_TS)
  private BigDecimal ts;

  public static final String SERIALIZED_NAME_UV = "uv";
  @SerializedName(SERIALIZED_NAME_UV)
  private BigDecimal uv;

  public static final String SERIALIZED_NAME_VIS = "vis";
  @SerializedName(SERIALIZED_NAME_VIS)
  private BigDecimal vis;

  public static final String SERIALIZED_NAME_WEATHER = "weather";
  @SerializedName(SERIALIZED_NAME_WEATHER)
  private ForecastWeather weather;

  public static final String SERIALIZED_NAME_WIND_CDIR = "wind_cdir";
  @SerializedName(SERIALIZED_NAME_WIND_CDIR)
  private String windCdir;

  public static final String SERIALIZED_NAME_WIND_CDIR_FULL = "wind_cdir_full";
  @SerializedName(SERIALIZED_NAME_WIND_CDIR_FULL)
  private String windCdirFull;

  public static final String SERIALIZED_NAME_WIND_DIR = "wind_dir";
  @SerializedName(SERIALIZED_NAME_WIND_DIR)
  private Integer windDir;

  public static final String SERIALIZED_NAME_WIND_SPD = "wind_spd";
  @SerializedName(SERIALIZED_NAME_WIND_SPD)
  private BigDecimal windSpd;

  public Forecast() {
  }

  public Forecast appMaxTemp(BigDecimal appMaxTemp) {
    this.appMaxTemp = appMaxTemp;
    return this;
  }

  /**
   * Apparent Maximum daily Temperature - default (C)
   * @return appMaxTemp
   */
  @javax.annotation.Nullable
  public BigDecimal getAppMaxTemp() {
    return appMaxTemp;
  }

  public void setAppMaxTemp(BigDecimal appMaxTemp) {
    this.appMaxTemp = appMaxTemp;
  }


  public Forecast appMinTemp(BigDecimal appMinTemp) {
    this.appMinTemp = appMinTemp;
    return this;
  }

  /**
   * Apparent Minimum daily Temperature - default (C)
   * @return appMinTemp
   */
  @javax.annotation.Nullable
  public BigDecimal getAppMinTemp() {
    return appMinTemp;
  }

  public void setAppMinTemp(BigDecimal appMinTemp) {
    this.appMinTemp = appMinTemp;
  }


  public Forecast clouds(Integer clouds) {
    this.clouds = clouds;
    return this;
  }

  /**
   * Cloud cover as a percentage (%)
   * @return clouds
   */
  @javax.annotation.Nullable
  public Integer getClouds() {
    return clouds;
  }

  public void setClouds(Integer clouds) {
    this.clouds = clouds;
  }


  public Forecast datetime(String datetime) {
    this.datetime = datetime;
    return this;
  }

  /**
   * Date in format \&quot;YYYY-MM-DD:HH\&quot;. All datetime is in (UTC)
   * @return datetime
   */
  @javax.annotation.Nullable
  public String getDatetime() {
    return datetime;
  }

  public void setDatetime(String datetime) {
    this.datetime = datetime;
  }


  public Forecast dewpt(BigDecimal dewpt) {
    this.dewpt = dewpt;
    return this;
  }

  /**
   * Dewpoint (Average) - default (C)
   * @return dewpt
   */
  @javax.annotation.Nullable
  public BigDecimal getDewpt() {
    return dewpt;
  }

  public void setDewpt(BigDecimal dewpt) {
    this.dewpt = dewpt;
  }


  public Forecast maxDhi(BigDecimal maxDhi) {
    this.maxDhi = maxDhi;
    return this;
  }

  /**
   * [Deprecated] Max direct component of solar insolation (W/m^2)
   * @return maxDhi
   */
  @javax.annotation.Nullable
  public BigDecimal getMaxDhi() {
    return maxDhi;
  }

  public void setMaxDhi(BigDecimal maxDhi) {
    this.maxDhi = maxDhi;
  }


  public Forecast maxTemp(BigDecimal maxTemp) {
    this.maxTemp = maxTemp;
    return this;
  }

  /**
   * Maximum daily Temperature - default (C)
   * @return maxTemp
   */
  @javax.annotation.Nullable
  public BigDecimal getMaxTemp() {
    return maxTemp;
  }

  public void setMaxTemp(BigDecimal maxTemp) {
    this.maxTemp = maxTemp;
  }


  public Forecast minTemp(BigDecimal minTemp) {
    this.minTemp = minTemp;
    return this;
  }

  /**
   * Minimum daily Temperature - default (C)
   * @return minTemp
   */
  @javax.annotation.Nullable
  public BigDecimal getMinTemp() {
    return minTemp;
  }

  public void setMinTemp(BigDecimal minTemp) {
    this.minTemp = minTemp;
  }


  public Forecast moonPhase(BigDecimal moonPhase) {
    this.moonPhase = moonPhase;
    return this;
  }

  /**
   * Moon phase
   * @return moonPhase
   */
  @javax.annotation.Nullable
  public BigDecimal getMoonPhase() {
    return moonPhase;
  }

  public void setMoonPhase(BigDecimal moonPhase) {
    this.moonPhase = moonPhase;
  }


  public Forecast moonriseTs(Integer moonriseTs) {
    this.moonriseTs = moonriseTs;
    return this;
  }

  /**
   * Moonrise unix timestamp
   * @return moonriseTs
   */
  @javax.annotation.Nullable
  public Integer getMoonriseTs() {
    return moonriseTs;
  }

  public void setMoonriseTs(Integer moonriseTs) {
    this.moonriseTs = moonriseTs;
  }


  public Forecast moonsetTs(Integer moonsetTs) {
    this.moonsetTs = moonsetTs;
    return this;
  }

  /**
   * Moonset unix timestamp
   * @return moonsetTs
   */
  @javax.annotation.Nullable
  public Integer getMoonsetTs() {
    return moonsetTs;
  }

  public void setMoonsetTs(Integer moonsetTs) {
    this.moonsetTs = moonsetTs;
  }


  public Forecast pod(String pod) {
    this.pod = pod;
    return this;
  }

  /**
   * Part of the day (d &#x3D; day, n &#x3D; night)
   * @return pod
   */
  @javax.annotation.Nullable
  public String getPod() {
    return pod;
  }

  public void setPod(String pod) {
    this.pod = pod;
  }


  public Forecast pop(BigDecimal pop) {
    this.pop = pop;
    return this;
  }

  /**
   * Chance of Precipitation as a percentage (%)
   * @return pop
   */
  @javax.annotation.Nullable
  public BigDecimal getPop() {
    return pop;
  }

  public void setPop(BigDecimal pop) {
    this.pop = pop;
  }


  public Forecast precip(BigDecimal precip) {
    this.precip = precip;
    return this;
  }

  /**
   * Accumulated precipitation since last forecast point - default (mm)
   * @return precip
   */
  @javax.annotation.Nullable
  public BigDecimal getPrecip() {
    return precip;
  }

  public void setPrecip(BigDecimal precip) {
    this.precip = precip;
  }


  public Forecast pres(BigDecimal pres) {
    this.pres = pres;
    return this;
  }

  /**
   * Pressure (mb)
   * @return pres
   */
  @javax.annotation.Nullable
  public BigDecimal getPres() {
    return pres;
  }

  public void setPres(BigDecimal pres) {
    this.pres = pres;
  }


  public Forecast rh(Integer rh) {
    this.rh = rh;
    return this;
  }

  /**
   * Relative Humidity as a percentage (%)
   * @return rh
   */
  @javax.annotation.Nullable
  public Integer getRh() {
    return rh;
  }

  public void setRh(Integer rh) {
    this.rh = rh;
  }


  public Forecast slp(BigDecimal slp) {
    this.slp = slp;
    return this;
  }

  /**
   * Mean Sea level pressure (mb)
   * @return slp
   */
  @javax.annotation.Nullable
  public BigDecimal getSlp() {
    return slp;
  }

  public void setSlp(BigDecimal slp) {
    this.slp = slp;
  }


  public Forecast snow(BigDecimal snow) {
    this.snow = snow;
    return this;
  }

  /**
   * Accumulated snowfall since last forecast point - default (mm)
   * @return snow
   */
  @javax.annotation.Nullable
  public BigDecimal getSnow() {
    return snow;
  }

  public void setSnow(BigDecimal snow) {
    this.snow = snow;
  }


  public Forecast snowDepth(BigDecimal snowDepth) {
    this.snowDepth = snowDepth;
    return this;
  }

  /**
   * Snow Depth - default (mm)
   * @return snowDepth
   */
  @javax.annotation.Nullable
  public BigDecimal getSnowDepth() {
    return snowDepth;
  }

  public void setSnowDepth(BigDecimal snowDepth) {
    this.snowDepth = snowDepth;
  }


  public Forecast sunriseTs(Integer sunriseTs) {
    this.sunriseTs = sunriseTs;
    return this;
  }

  /**
   * Sunrise unix timestamp
   * @return sunriseTs
   */
  @javax.annotation.Nullable
  public Integer getSunriseTs() {
    return sunriseTs;
  }

  public void setSunriseTs(Integer sunriseTs) {
    this.sunriseTs = sunriseTs;
  }


  public Forecast sunsetTs(Integer sunsetTs) {
    this.sunsetTs = sunsetTs;
    return this;
  }

  /**
   * Sunset unix timestamp
   * @return sunsetTs
   */
  @javax.annotation.Nullable
  public Integer getSunsetTs() {
    return sunsetTs;
  }

  public void setSunsetTs(Integer sunsetTs) {
    this.sunsetTs = sunsetTs;
  }


  public Forecast temp(BigDecimal temp) {
    this.temp = temp;
    return this;
  }

  /**
   * Temperature (Average) - default (C)
   * @return temp
   */
  @javax.annotation.Nullable
  public BigDecimal getTemp() {
    return temp;
  }

  public void setTemp(BigDecimal temp) {
    this.temp = temp;
  }


  public Forecast timestampLocal(String timestampLocal) {
    this.timestampLocal = timestampLocal;
    return this;
  }

  /**
   * Timestamp in local time
   * @return timestampLocal
   */
  @javax.annotation.Nullable
  public String getTimestampLocal() {
    return timestampLocal;
  }

  public void setTimestampLocal(String timestampLocal) {
    this.timestampLocal = timestampLocal;
  }


  public Forecast timestampUtc(String timestampUtc) {
    this.timestampUtc = timestampUtc;
    return this;
  }

  /**
   * Timestamp UTC
   * @return timestampUtc
   */
  @javax.annotation.Nullable
  public String getTimestampUtc() {
    return timestampUtc;
  }

  public void setTimestampUtc(String timestampUtc) {
    this.timestampUtc = timestampUtc;
  }


  public Forecast ts(BigDecimal ts) {
    this.ts = ts;
    return this;
  }

  /**
   * Unix Timestamp
   * @return ts
   */
  @javax.annotation.Nullable
  public BigDecimal getTs() {
    return ts;
  }

  public void setTs(BigDecimal ts) {
    this.ts = ts;
  }


  public Forecast uv(BigDecimal uv) {
    this.uv = uv;
    return this;
  }

  /**
   * UV Index
   * @return uv
   */
  @javax.annotation.Nullable
  public BigDecimal getUv() {
    return uv;
  }

  public void setUv(BigDecimal uv) {
    this.uv = uv;
  }


  public Forecast vis(BigDecimal vis) {
    this.vis = vis;
    return this;
  }

  /**
   * Average Visibility default (KM)
   * @return vis
   */
  @javax.annotation.Nullable
  public BigDecimal getVis() {
    return vis;
  }

  public void setVis(BigDecimal vis) {
    this.vis = vis;
  }


  public Forecast weather(ForecastWeather weather) {
    this.weather = weather;
    return this;
  }

  /**
   * Get weather
   * @return weather
   */
  @javax.annotation.Nullable
  public ForecastWeather getWeather() {
    return weather;
  }

  public void setWeather(ForecastWeather weather) {
    this.weather = weather;
  }


  public Forecast windCdir(String windCdir) {
    this.windCdir = windCdir;
    return this;
  }

  /**
   * Cardinal wind direction
   * @return windCdir
   */
  @javax.annotation.Nullable
  public String getWindCdir() {
    return windCdir;
  }

  public void setWindCdir(String windCdir) {
    this.windCdir = windCdir;
  }


  public Forecast windCdirFull(String windCdirFull) {
    this.windCdirFull = windCdirFull;
    return this;
  }

  /**
   * Cardinal wind direction (text)
   * @return windCdirFull
   */
  @javax.annotation.Nullable
  public String getWindCdirFull() {
    return windCdirFull;
  }

  public void setWindCdirFull(String windCdirFull) {
    this.windCdirFull = windCdirFull;
  }


  public Forecast windDir(Integer windDir) {
    this.windDir = windDir;
    return this;
  }

  /**
   * Wind direction
   * @return windDir
   */
  @javax.annotation.Nullable
  public Integer getWindDir() {
    return windDir;
  }

  public void setWindDir(Integer windDir) {
    this.windDir = windDir;
  }


  public Forecast windSpd(BigDecimal windSpd) {
    this.windSpd = windSpd;
    return this;
  }

  /**
   * Wind Speed (default m/s)
   * @return windSpd
   */
  @javax.annotation.Nullable
  public BigDecimal getWindSpd() {
    return windSpd;
  }

  public void setWindSpd(BigDecimal windSpd) {
    this.windSpd = windSpd;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Forecast forecast = (Forecast) o;
    return Objects.equals(this.appMaxTemp, forecast.appMaxTemp) &&
        Objects.equals(this.appMinTemp, forecast.appMinTemp) &&
        Objects.equals(this.clouds, forecast.clouds) &&
        Objects.equals(this.datetime, forecast.datetime) &&
        Objects.equals(this.dewpt, forecast.dewpt) &&
        Objects.equals(this.maxDhi, forecast.maxDhi) &&
        Objects.equals(this.maxTemp, forecast.maxTemp) &&
        Objects.equals(this.minTemp, forecast.minTemp) &&
        Objects.equals(this.moonPhase, forecast.moonPhase) &&
        Objects.equals(this.moonriseTs, forecast.moonriseTs) &&
        Objects.equals(this.moonsetTs, forecast.moonsetTs) &&
        Objects.equals(this.pod, forecast.pod) &&
        Objects.equals(this.pop, forecast.pop) &&
        Objects.equals(this.precip, forecast.precip) &&
        Objects.equals(this.pres, forecast.pres) &&
        Objects.equals(this.rh, forecast.rh) &&
        Objects.equals(this.slp, forecast.slp) &&
        Objects.equals(this.snow, forecast.snow) &&
        Objects.equals(this.snowDepth, forecast.snowDepth) &&
        Objects.equals(this.sunriseTs, forecast.sunriseTs) &&
        Objects.equals(this.sunsetTs, forecast.sunsetTs) &&
        Objects.equals(this.temp, forecast.temp) &&
        Objects.equals(this.timestampLocal, forecast.timestampLocal) &&
        Objects.equals(this.timestampUtc, forecast.timestampUtc) &&
        Objects.equals(this.ts, forecast.ts) &&
        Objects.equals(this.uv, forecast.uv) &&
        Objects.equals(this.vis, forecast.vis) &&
        Objects.equals(this.weather, forecast.weather) &&
        Objects.equals(this.windCdir, forecast.windCdir) &&
        Objects.equals(this.windCdirFull, forecast.windCdirFull) &&
        Objects.equals(this.windDir, forecast.windDir) &&
        Objects.equals(this.windSpd, forecast.windSpd);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appMaxTemp, appMinTemp, clouds, datetime, dewpt, maxDhi, maxTemp, minTemp, moonPhase, moonriseTs, moonsetTs, pod, pop, precip, pres, rh, slp, snow, snowDepth, sunriseTs, sunsetTs, temp, timestampLocal, timestampUtc, ts, uv, vis, weather, windCdir, windCdirFull, windDir, windSpd);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Forecast {\n");
    sb.append("    appMaxTemp: ").append(toIndentedString(appMaxTemp)).append("\n");
    sb.append("    appMinTemp: ").append(toIndentedString(appMinTemp)).append("\n");
    sb.append("    clouds: ").append(toIndentedString(clouds)).append("\n");
    sb.append("    datetime: ").append(toIndentedString(datetime)).append("\n");
    sb.append("    dewpt: ").append(toIndentedString(dewpt)).append("\n");
    sb.append("    maxDhi: ").append(toIndentedString(maxDhi)).append("\n");
    sb.append("    maxTemp: ").append(toIndentedString(maxTemp)).append("\n");
    sb.append("    minTemp: ").append(toIndentedString(minTemp)).append("\n");
    sb.append("    moonPhase: ").append(toIndentedString(moonPhase)).append("\n");
    sb.append("    moonriseTs: ").append(toIndentedString(moonriseTs)).append("\n");
    sb.append("    moonsetTs: ").append(toIndentedString(moonsetTs)).append("\n");
    sb.append("    pod: ").append(toIndentedString(pod)).append("\n");
    sb.append("    pop: ").append(toIndentedString(pop)).append("\n");
    sb.append("    precip: ").append(toIndentedString(precip)).append("\n");
    sb.append("    pres: ").append(toIndentedString(pres)).append("\n");
    sb.append("    rh: ").append(toIndentedString(rh)).append("\n");
    sb.append("    slp: ").append(toIndentedString(slp)).append("\n");
    sb.append("    snow: ").append(toIndentedString(snow)).append("\n");
    sb.append("    snowDepth: ").append(toIndentedString(snowDepth)).append("\n");
    sb.append("    sunriseTs: ").append(toIndentedString(sunriseTs)).append("\n");
    sb.append("    sunsetTs: ").append(toIndentedString(sunsetTs)).append("\n");
    sb.append("    temp: ").append(toIndentedString(temp)).append("\n");
    sb.append("    timestampLocal: ").append(toIndentedString(timestampLocal)).append("\n");
    sb.append("    timestampUtc: ").append(toIndentedString(timestampUtc)).append("\n");
    sb.append("    ts: ").append(toIndentedString(ts)).append("\n");
    sb.append("    uv: ").append(toIndentedString(uv)).append("\n");
    sb.append("    vis: ").append(toIndentedString(vis)).append("\n");
    sb.append("    weather: ").append(toIndentedString(weather)).append("\n");
    sb.append("    windCdir: ").append(toIndentedString(windCdir)).append("\n");
    sb.append("    windCdirFull: ").append(toIndentedString(windCdirFull)).append("\n");
    sb.append("    windDir: ").append(toIndentedString(windDir)).append("\n");
    sb.append("    windSpd: ").append(toIndentedString(windSpd)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("app_max_temp");
    openapiFields.add("app_min_temp");
    openapiFields.add("clouds");
    openapiFields.add("datetime");
    openapiFields.add("dewpt");
    openapiFields.add("max_dhi");
    openapiFields.add("max_temp");
    openapiFields.add("min_temp");
    openapiFields.add("moon_phase");
    openapiFields.add("moonrise_ts");
    openapiFields.add("moonset_ts");
    openapiFields.add("pod");
    openapiFields.add("pop");
    openapiFields.add("precip");
    openapiFields.add("pres");
    openapiFields.add("rh");
    openapiFields.add("slp");
    openapiFields.add("snow");
    openapiFields.add("snow_depth");
    openapiFields.add("sunrise_ts");
    openapiFields.add("sunset_ts");
    openapiFields.add("temp");
    openapiFields.add("timestamp_local");
    openapiFields.add("timestamp_utc");
    openapiFields.add("ts");
    openapiFields.add("uv");
    openapiFields.add("vis");
    openapiFields.add("weather");
    openapiFields.add("wind_cdir");
    openapiFields.add("wind_cdir_full");
    openapiFields.add("wind_dir");
    openapiFields.add("wind_spd");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Forecast
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Forecast.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Forecast is not found in the empty JSON string", Forecast.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Forecast.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Forecast` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("datetime") != null && !jsonObj.get("datetime").isJsonNull()) && !jsonObj.get("datetime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `datetime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("datetime").toString()));
      }
      if ((jsonObj.get("pod") != null && !jsonObj.get("pod").isJsonNull()) && !jsonObj.get("pod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pod").toString()));
      }
      if ((jsonObj.get("timestamp_local") != null && !jsonObj.get("timestamp_local").isJsonNull()) && !jsonObj.get("timestamp_local").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestamp_local` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestamp_local").toString()));
      }
      if ((jsonObj.get("timestamp_utc") != null && !jsonObj.get("timestamp_utc").isJsonNull()) && !jsonObj.get("timestamp_utc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestamp_utc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestamp_utc").toString()));
      }
      // validate the optional field `weather`
      if (jsonObj.get("weather") != null && !jsonObj.get("weather").isJsonNull()) {
        ForecastWeather.validateJsonElement(jsonObj.get("weather"));
      }
      if ((jsonObj.get("wind_cdir") != null && !jsonObj.get("wind_cdir").isJsonNull()) && !jsonObj.get("wind_cdir").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wind_cdir` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wind_cdir").toString()));
      }
      if ((jsonObj.get("wind_cdir_full") != null && !jsonObj.get("wind_cdir_full").isJsonNull()) && !jsonObj.get("wind_cdir_full").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wind_cdir_full` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wind_cdir_full").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Forecast.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Forecast' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Forecast> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Forecast.class));

       return (TypeAdapter<T>) new TypeAdapter<Forecast>() {
           @Override
           public void write(JsonWriter out, Forecast value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Forecast read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Forecast given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Forecast
   * @throws IOException if the JSON string is invalid with respect to Forecast
   */
  public static Forecast fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Forecast.class);
  }

  /**
   * Convert an instance of Forecast to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

