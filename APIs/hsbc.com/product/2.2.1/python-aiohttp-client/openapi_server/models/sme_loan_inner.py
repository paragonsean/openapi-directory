# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.sme_loan_marketing_state_inner import SMELoanMarketingStateInner
from openapi_server import util


class SMELoanInner(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, identification: str=None, name: str=None, other_segment: object=None, sme_loan_marketing_state: List[SMELoanMarketingStateInner]=None, segment: List[str]=None):
        """SMELoanInner - a model defined in OpenAPI

        :param identification: The identification of this SMELoanInner.
        :param name: The name of this SMELoanInner.
        :param other_segment: The other_segment of this SMELoanInner.
        :param sme_loan_marketing_state: The sme_loan_marketing_state of this SMELoanInner.
        :param segment: The segment of this SMELoanInner.
        """
        self.openapi_types = {
            'identification': str,
            'name': str,
            'other_segment': object,
            'sme_loan_marketing_state': List[SMELoanMarketingStateInner],
            'segment': List[str]
        }

        self.attribute_map = {
            'identification': 'Identification',
            'name': 'Name',
            'other_segment': 'OtherSegment',
            'sme_loan_marketing_state': 'SMELoanMarketingState',
            'segment': 'Segment'
        }

        self._identification = identification
        self._name = name
        self._other_segment = other_segment
        self._sme_loan_marketing_state = sme_loan_marketing_state
        self._segment = segment

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SMELoanInner':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SMELoan_inner of this SMELoanInner.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def identification(self):
        """Gets the identification of this SMELoanInner.

        The unique ID that has been internally assigned by the financial institution to each of the current account banking products they market to their retail and/or small to medium enterprise (SME) customers.

        :return: The identification of this SMELoanInner.
        :rtype: str
        """
        return self._identification

    @identification.setter
    def identification(self, identification):
        """Sets the identification of this SMELoanInner.

        The unique ID that has been internally assigned by the financial institution to each of the current account banking products they market to their retail and/or small to medium enterprise (SME) customers.

        :param identification: The identification of this SMELoanInner.
        :type identification: str
        """
        if identification is None:
            raise ValueError("Invalid value for `identification`, must not be `None`")
        if identification is not None and len(identification) > 35:
            raise ValueError("Invalid value for `identification`, length must be less than or equal to `35`")
        if identification is not None and len(identification) < 1:
            raise ValueError("Invalid value for `identification`, length must be greater than or equal to `1`")

        self._identification = identification

    @property
    def name(self):
        """Gets the name of this SMELoanInner.

        The name of the SME Loan product used for marketing purposes from a customer perspective. I.e. what the customer would recognise.

        :return: The name of this SMELoanInner.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this SMELoanInner.

        The name of the SME Loan product used for marketing purposes from a customer perspective. I.e. what the customer would recognise.

        :param name: The name of this SMELoanInner.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        if name is not None and len(name) > 350:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `350`")
        if name is not None and len(name) < 1:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")

        self._name = name

    @property
    def other_segment(self):
        """Gets the other_segment of this SMELoanInner.

        Other segment code which is not available in the standard code set

        :return: The other_segment of this SMELoanInner.
        :rtype: object
        """
        return self._other_segment

    @other_segment.setter
    def other_segment(self, other_segment):
        """Sets the other_segment of this SMELoanInner.

        Other segment code which is not available in the standard code set

        :param other_segment: The other_segment of this SMELoanInner.
        :type other_segment: object
        """

        self._other_segment = other_segment

    @property
    def sme_loan_marketing_state(self):
        """Gets the sme_loan_marketing_state of this SMELoanInner.

        The marketing state (promotional or regular) of the SME Loan Product.

        :return: The sme_loan_marketing_state of this SMELoanInner.
        :rtype: List[SMELoanMarketingStateInner]
        """
        return self._sme_loan_marketing_state

    @sme_loan_marketing_state.setter
    def sme_loan_marketing_state(self, sme_loan_marketing_state):
        """Sets the sme_loan_marketing_state of this SMELoanInner.

        The marketing state (promotional or regular) of the SME Loan Product.

        :param sme_loan_marketing_state: The sme_loan_marketing_state of this SMELoanInner.
        :type sme_loan_marketing_state: List[SMELoanMarketingStateInner]
        """
        if sme_loan_marketing_state is None:
            raise ValueError("Invalid value for `sme_loan_marketing_state`, must not be `None`")
        if sme_loan_marketing_state is not None and len(sme_loan_marketing_state) < 1:
            raise ValueError("Invalid value for `sme_loan_marketing_state`, number of items must be greater than or equal to `1`")

        self._sme_loan_marketing_state = sme_loan_marketing_state

    @property
    def segment(self):
        """Gets the segment of this SMELoanInner.

        Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.  Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd  Follow us: Investopedia on Facebook  With respect to SME Loan products, they are segmented in relation to different markets that they wish to focus on.

        :return: The segment of this SMELoanInner.
        :rtype: List[str]
        """
        return self._segment

    @segment.setter
    def segment(self, segment):
        """Sets the segment of this SMELoanInner.

        Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.  Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd  Follow us: Investopedia on Facebook  With respect to SME Loan products, they are segmented in relation to different markets that they wish to focus on.

        :param segment: The segment of this SMELoanInner.
        :type segment: List[str]
        """
        allowed_values = ["AgricultureSector", "Business", "FlexibleBusinessLoan", "FixedGroup", "GovernmentScheme", "Other", "SectorSpecific"]  # noqa: E501
        if not set(segment).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `segment` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(segment) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._segment = segment
