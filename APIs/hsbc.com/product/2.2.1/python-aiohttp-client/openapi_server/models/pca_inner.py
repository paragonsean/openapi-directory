# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.pca_marketing_state_inner import PCAMarketingStateInner
from openapi_server import util


class PCAInner(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, identification: str=None, name: str=None, notes: List[str]=None, on_sale_indicator: bool=None, pca_marketing_state: List[PCAMarketingStateInner]=None, segment: List[str]=None):
        """PCAInner - a model defined in OpenAPI

        :param identification: The identification of this PCAInner.
        :param name: The name of this PCAInner.
        :param notes: The notes of this PCAInner.
        :param on_sale_indicator: The on_sale_indicator of this PCAInner.
        :param pca_marketing_state: The pca_marketing_state of this PCAInner.
        :param segment: The segment of this PCAInner.
        """
        self.openapi_types = {
            'identification': str,
            'name': str,
            'notes': List[str],
            'on_sale_indicator': bool,
            'pca_marketing_state': List[PCAMarketingStateInner],
            'segment': List[str]
        }

        self.attribute_map = {
            'identification': 'Identification',
            'name': 'Name',
            'notes': 'Notes',
            'on_sale_indicator': 'OnSaleIndicator',
            'pca_marketing_state': 'PCAMarketingState',
            'segment': 'Segment'
        }

        self._identification = identification
        self._name = name
        self._notes = notes
        self._on_sale_indicator = on_sale_indicator
        self._pca_marketing_state = pca_marketing_state
        self._segment = segment

    @classmethod
    def from_dict(cls, dikt: dict) -> 'PCAInner':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The PCA_inner of this PCAInner.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def identification(self):
        """Gets the identification of this PCAInner.

        The unique ID that has been internally assigned by the financial institution to each of the current account banking products they market to their retail and/or small to medium enterprise (SME) customers.

        :return: The identification of this PCAInner.
        :rtype: str
        """
        return self._identification

    @identification.setter
    def identification(self, identification):
        """Sets the identification of this PCAInner.

        The unique ID that has been internally assigned by the financial institution to each of the current account banking products they market to their retail and/or small to medium enterprise (SME) customers.

        :param identification: The identification of this PCAInner.
        :type identification: str
        """
        if identification is None:
            raise ValueError("Invalid value for `identification`, must not be `None`")
        if identification is not None and len(identification) > 35:
            raise ValueError("Invalid value for `identification`, length must be less than or equal to `35`")
        if identification is not None and len(identification) < 1:
            raise ValueError("Invalid value for `identification`, length must be greater than or equal to `1`")

        self._identification = identification

    @property
    def name(self):
        """Gets the name of this PCAInner.

        The name of the PCA product used for marketing purposes from a customer perspective. I.e. what the customer would recognise.

        :return: The name of this PCAInner.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this PCAInner.

        The name of the PCA product used for marketing purposes from a customer perspective. I.e. what the customer would recognise.

        :param name: The name of this PCAInner.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        if name is not None and len(name) > 350:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `350`")
        if name is not None and len(name) < 1:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")

        self._name = name

    @property
    def notes(self):
        """Gets the notes of this PCAInner.

        Optional additional notes to supplement the product details

        :return: The notes of this PCAInner.
        :rtype: List[str]
        """
        return self._notes

    @notes.setter
    def notes(self, notes):
        """Sets the notes of this PCAInner.

        Optional additional notes to supplement the product details

        :param notes: The notes of this PCAInner.
        :type notes: List[str]
        """

        self._notes = notes

    @property
    def on_sale_indicator(self):
        """Gets the on_sale_indicator of this PCAInner.

        Indicates that the published product is OnSale(value 1) or Back Book (value 0) 

        :return: The on_sale_indicator of this PCAInner.
        :rtype: bool
        """
        return self._on_sale_indicator

    @on_sale_indicator.setter
    def on_sale_indicator(self, on_sale_indicator):
        """Sets the on_sale_indicator of this PCAInner.

        Indicates that the published product is OnSale(value 1) or Back Book (value 0) 

        :param on_sale_indicator: The on_sale_indicator of this PCAInner.
        :type on_sale_indicator: bool
        """

        self._on_sale_indicator = on_sale_indicator

    @property
    def pca_marketing_state(self):
        """Gets the pca_marketing_state of this PCAInner.

        Describes the type of the known state (regular, promotional )  of the product.

        :return: The pca_marketing_state of this PCAInner.
        :rtype: List[PCAMarketingStateInner]
        """
        return self._pca_marketing_state

    @pca_marketing_state.setter
    def pca_marketing_state(self, pca_marketing_state):
        """Sets the pca_marketing_state of this PCAInner.

        Describes the type of the known state (regular, promotional )  of the product.

        :param pca_marketing_state: The pca_marketing_state of this PCAInner.
        :type pca_marketing_state: List[PCAMarketingStateInner]
        """
        if pca_marketing_state is None:
            raise ValueError("Invalid value for `pca_marketing_state`, must not be `None`")
        if pca_marketing_state is not None and len(pca_marketing_state) < 1:
            raise ValueError("Invalid value for `pca_marketing_state`, number of items must be greater than or equal to `1`")

        self._pca_marketing_state = pca_marketing_state

    @property
    def segment(self):
        """Gets the segment of this PCAInner.

        Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.  Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd  Follow us: Investopedia on Facebook  With respect to PCA products, they are segmented in relation to different markets that they wish to focus on. For example, Basic PCA products target consumers with poor credit history, Reward PCA products target consumers who spend a lot, and Premium products target High Net Worth individuals.

        :return: The segment of this PCAInner.
        :rtype: List[str]
        """
        return self._segment

    @segment.setter
    def segment(self, segment):
        """Sets the segment of this PCAInner.

        Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.  Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd  Follow us: Investopedia on Facebook  With respect to PCA products, they are segmented in relation to different markets that they wish to focus on. For example, Basic PCA products target consumers with poor credit history, Reward PCA products target consumers who spend a lot, and Premium products target High Net Worth individuals.

        :param segment: The segment of this PCAInner.
        :type segment: List[str]
        """
        allowed_values = ["Basic", "BenefitAndReward", "CreditInterest", "Cashback", "General", "Graduate", "Other", "Overdraft", "Packaged", "Premium", "Reward", "Student", "YoungAdult", "Youth"]  # noqa: E501
        if not set(segment).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `segment` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(segment) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._segment = segment
