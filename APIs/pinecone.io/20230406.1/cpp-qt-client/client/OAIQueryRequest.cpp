/**
 * Pinecone API
 * Pinecone is a vector database. This is an unofficial, community-managed OpenAPI spec that (should) accurately model the Pinecone API. This project was developed independent of and is unaffiliated with Pinecone Systems. Users should switch to the official API spec, if and when Pinecone releases it.
 *
 * The version of the OpenAPI document: 20230406.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIQueryRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIQueryRequest::OAIQueryRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIQueryRequest::OAIQueryRequest() {
    this->initializeModel();
}

OAIQueryRequest::~OAIQueryRequest() {}

void OAIQueryRequest::initializeModel() {

    m_filter_isSet = false;
    m_filter_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_include_metadata_isSet = false;
    m_include_metadata_isValid = false;

    m_include_values_isSet = false;
    m_include_values_isValid = false;

    m_r_namespace_isSet = false;
    m_r_namespace_isValid = false;

    m_sparse_vector_isSet = false;
    m_sparse_vector_isValid = false;

    m_top_k_isSet = false;
    m_top_k_isValid = false;

    m_vector_isSet = false;
    m_vector_isValid = false;
}

void OAIQueryRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIQueryRequest::fromJsonObject(QJsonObject json) {

    m_filter_isValid = ::OpenAPI::fromJsonValue(m_filter, json[QString("filter")]);
    m_filter_isSet = !json[QString("filter")].isNull() && m_filter_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_include_metadata_isValid = ::OpenAPI::fromJsonValue(m_include_metadata, json[QString("includeMetadata")]);
    m_include_metadata_isSet = !json[QString("includeMetadata")].isNull() && m_include_metadata_isValid;

    m_include_values_isValid = ::OpenAPI::fromJsonValue(m_include_values, json[QString("includeValues")]);
    m_include_values_isSet = !json[QString("includeValues")].isNull() && m_include_values_isValid;

    m_r_namespace_isValid = ::OpenAPI::fromJsonValue(m_r_namespace, json[QString("namespace")]);
    m_r_namespace_isSet = !json[QString("namespace")].isNull() && m_r_namespace_isValid;

    m_sparse_vector_isValid = ::OpenAPI::fromJsonValue(m_sparse_vector, json[QString("sparseVector")]);
    m_sparse_vector_isSet = !json[QString("sparseVector")].isNull() && m_sparse_vector_isValid;

    m_top_k_isValid = ::OpenAPI::fromJsonValue(m_top_k, json[QString("topK")]);
    m_top_k_isSet = !json[QString("topK")].isNull() && m_top_k_isValid;

    m_vector_isValid = ::OpenAPI::fromJsonValue(m_vector, json[QString("vector")]);
    m_vector_isSet = !json[QString("vector")].isNull() && m_vector_isValid;
}

QString OAIQueryRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIQueryRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_filter.size() > 0) {
        obj.insert(QString("filter"), ::OpenAPI::toJsonValue(m_filter));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_include_metadata_isSet) {
        obj.insert(QString("includeMetadata"), ::OpenAPI::toJsonValue(m_include_metadata));
    }
    if (m_include_values_isSet) {
        obj.insert(QString("includeValues"), ::OpenAPI::toJsonValue(m_include_values));
    }
    if (m_r_namespace_isSet) {
        obj.insert(QString("namespace"), ::OpenAPI::toJsonValue(m_r_namespace));
    }
    if (m_sparse_vector.isSet()) {
        obj.insert(QString("sparseVector"), ::OpenAPI::toJsonValue(m_sparse_vector));
    }
    if (m_top_k_isSet) {
        obj.insert(QString("topK"), ::OpenAPI::toJsonValue(m_top_k));
    }
    if (m_vector.size() > 0) {
        obj.insert(QString("vector"), ::OpenAPI::toJsonValue(m_vector));
    }
    return obj;
}

QMap<QString, QJsonValue> OAIQueryRequest::getFilter() const {
    return m_filter;
}
void OAIQueryRequest::setFilter(const QMap<QString, QJsonValue> &filter) {
    m_filter = filter;
    m_filter_isSet = true;
}

bool OAIQueryRequest::is_filter_Set() const{
    return m_filter_isSet;
}

bool OAIQueryRequest::is_filter_Valid() const{
    return m_filter_isValid;
}

QString OAIQueryRequest::getId() const {
    return m_id;
}
void OAIQueryRequest::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIQueryRequest::is_id_Set() const{
    return m_id_isSet;
}

bool OAIQueryRequest::is_id_Valid() const{
    return m_id_isValid;
}

bool OAIQueryRequest::isIncludeMetadata() const {
    return m_include_metadata;
}
void OAIQueryRequest::setIncludeMetadata(const bool &include_metadata) {
    m_include_metadata = include_metadata;
    m_include_metadata_isSet = true;
}

bool OAIQueryRequest::is_include_metadata_Set() const{
    return m_include_metadata_isSet;
}

bool OAIQueryRequest::is_include_metadata_Valid() const{
    return m_include_metadata_isValid;
}

bool OAIQueryRequest::isIncludeValues() const {
    return m_include_values;
}
void OAIQueryRequest::setIncludeValues(const bool &include_values) {
    m_include_values = include_values;
    m_include_values_isSet = true;
}

bool OAIQueryRequest::is_include_values_Set() const{
    return m_include_values_isSet;
}

bool OAIQueryRequest::is_include_values_Valid() const{
    return m_include_values_isValid;
}

QString OAIQueryRequest::getRNamespace() const {
    return m_r_namespace;
}
void OAIQueryRequest::setRNamespace(const QString &r_namespace) {
    m_r_namespace = r_namespace;
    m_r_namespace_isSet = true;
}

bool OAIQueryRequest::is_r_namespace_Set() const{
    return m_r_namespace_isSet;
}

bool OAIQueryRequest::is_r_namespace_Valid() const{
    return m_r_namespace_isValid;
}

OAISparseVectorData OAIQueryRequest::getSparseVector() const {
    return m_sparse_vector;
}
void OAIQueryRequest::setSparseVector(const OAISparseVectorData &sparse_vector) {
    m_sparse_vector = sparse_vector;
    m_sparse_vector_isSet = true;
}

bool OAIQueryRequest::is_sparse_vector_Set() const{
    return m_sparse_vector_isSet;
}

bool OAIQueryRequest::is_sparse_vector_Valid() const{
    return m_sparse_vector_isValid;
}

qint64 OAIQueryRequest::getTopK() const {
    return m_top_k;
}
void OAIQueryRequest::setTopK(const qint64 &top_k) {
    m_top_k = top_k;
    m_top_k_isSet = true;
}

bool OAIQueryRequest::is_top_k_Set() const{
    return m_top_k_isSet;
}

bool OAIQueryRequest::is_top_k_Valid() const{
    return m_top_k_isValid;
}

QList<float> OAIQueryRequest::getVector() const {
    return m_vector;
}
void OAIQueryRequest::setVector(const QList<float> &vector) {
    m_vector = vector;
    m_vector_isSet = true;
}

bool OAIQueryRequest::is_vector_Set() const{
    return m_vector_isSet;
}

bool OAIQueryRequest::is_vector_Valid() const{
    return m_vector_isValid;
}

bool OAIQueryRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_filter.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_metadata_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_values_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_namespace_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sparse_vector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_top_k_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vector.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIQueryRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_top_k_isValid && true;
}

} // namespace OpenAPI
