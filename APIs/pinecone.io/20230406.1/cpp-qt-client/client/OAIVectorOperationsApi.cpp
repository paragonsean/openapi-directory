/**
 * Pinecone API
 * Pinecone is a vector database. This is an unofficial, community-managed OpenAPI spec that (should) accurately model the Pinecone API. This project was developed independent of and is unaffiliated with Pinecone Systems. Users should switch to the official API spec, if and when Pinecone releases it.
 *
 * The version of the OpenAPI document: 20230406.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVectorOperationsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIVectorOperationsApi::OAIVectorOperationsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIVectorOperationsApi::~OAIVectorOperationsApi() {
}

void OAIVectorOperationsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://controller.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The regional deployment to use. Must match API key.","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, }));
    
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("describeIndexStats", serverConf);
    _serverIndices.insert("describeIndexStats", 0);
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("fetch", serverConf);
    _serverIndices.insert("fetch", 0);
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("query", serverConf);
    _serverIndices.insert("query", 0);
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("r_delete", serverConf);
    _serverIndices.insert("r_delete", 0);
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("update", serverConf);
    _serverIndices.insert("update", 0);
    serverConf.append(OAIServerConfiguration(
    QUrl("https://{index_name}-{project_id}.svc.{environment}.pinecone.io"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"environment", OAIServerVariable("The cloud environment","us-east1-gcp",
    QSet<QString>{ {"us-west1-gcp"},{"us-west4-gcp"},{"us-central1-gcp"},{"us-east1-gcp"},{"us-east4-gcp"},{"eu-west1-gcp"},{"us-east1-aws"} })}, 
    
    {"index_name", OAIServerVariable("The name of the index being manipulated","example",
    QSet<QString>{ {"example"} })},
    
    {"project_id", OAIServerVariable("The project being manipulated","abcd1234",
    QSet<QString>{ {"abcd1234"} })}, }));
    
    _serverConfigs.insert("upsert", serverConf);
    _serverIndices.insert("upsert", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIVectorOperationsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIVectorOperationsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIVectorOperationsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIVectorOperationsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIVectorOperationsApi::setUsername(const QString &username) {
    _username = username;
}

void OAIVectorOperationsApi::setPassword(const QString &password) {
    _password = password;
}


void OAIVectorOperationsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIVectorOperationsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIVectorOperationsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIVectorOperationsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIVectorOperationsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIVectorOperationsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIVectorOperationsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIVectorOperationsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIVectorOperationsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIVectorOperationsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIVectorOperationsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIVectorOperationsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIVectorOperationsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIVectorOperationsApi::describeIndexStats(const OAIDescribeIndexStatsRequest &oai_describe_index_stats_request) {
    QString fullPath = QString(_serverConfigs["describeIndexStats"][_serverIndices.value("describeIndexStats")].URL()+"/describe_index_stats");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_describe_index_stats_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::describeIndexStatsCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::describeIndexStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDescribeIndexStatsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT describeIndexStatsSignal(output);
        Q_EMIT describeIndexStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT describeIndexStatsSignalE(output, error_type, error_str);
        Q_EMIT describeIndexStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT describeIndexStatsSignalError(output, error_type, error_str);
        Q_EMIT describeIndexStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::fetch(const OAIFetchRequest &oai_fetch_request) {
    QString fullPath = QString(_serverConfigs["fetch"][_serverIndices.value("fetch")].URL()+"/vectors/fetch");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_fetch_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::fetchCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::fetchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFetchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT fetchSignal(output);
        Q_EMIT fetchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT fetchSignalE(output, error_type, error_str);
        Q_EMIT fetchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT fetchSignalError(output, error_type, error_str);
        Q_EMIT fetchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::query(const OAIQueryRequest &oai_query_request) {
    QString fullPath = QString(_serverConfigs["query"][_serverIndices.value("query")].URL()+"/query");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_query_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::queryCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::queryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIQueryResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT querySignal(output);
        Q_EMIT querySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT querySignalE(output, error_type, error_str);
        Q_EMIT querySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT querySignalError(output, error_type, error_str);
        Q_EMIT querySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::r_delete(const OAIDeleteRequest &oai_delete_request) {
    QString fullPath = QString(_serverConfigs["r_delete"][_serverIndices.value("r_delete")].URL()+"/vectors/delete");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_delete_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::r_deleteCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::r_deleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT r_deleteSignal(output);
        Q_EMIT r_deleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT r_deleteSignalE(output, error_type, error_str);
        Q_EMIT r_deleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT r_deleteSignalError(output, error_type, error_str);
        Q_EMIT r_deleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::update(const OAIUpdateRequest &oai_update_request) {
    QString fullPath = QString(_serverConfigs["update"][_serverIndices.value("update")].URL()+"/vectors/update");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::updateCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::updateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateSignal(output);
        Q_EMIT updateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateSignalE(output, error_type, error_str);
        Q_EMIT updateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateSignalError(output, error_type, error_str);
        Q_EMIT updateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::upsert(const OAIUpsertRequest &oai_upsert_request) {
    QString fullPath = QString(_serverConfigs["upsert"][_serverIndices.value("upsert")].URL()+"/vectors/upsert");
    
    if (_apiKeys.contains("ApiKey")) {
        addHeaders("ApiKey",_apiKeys.find("ApiKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_upsert_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVectorOperationsApi::upsertCallback);
    connect(this, &OAIVectorOperationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVectorOperationsApi::upsertCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUpsertResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT upsertSignal(output);
        Q_EMIT upsertSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT upsertSignalE(output, error_type, error_str);
        Q_EMIT upsertSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT upsertSignalError(output, error_type, error_str);
        Q_EMIT upsertSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVectorOperationsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
