/*
 * Betfair: Exchange Streaming API
 * API to receive streamed updates. This is an ssl socket connection of CRLF delimited json messages (see RequestMessage & ResponseMessage)
 *
 * The version of the OpenAPI document: 1.0.1423
 * Contact: bdp@betfair.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.KeyLineDefinition;
import org.openapitools.client.model.PriceLadderDefinition;
import org.openapitools.client.model.RunnerDefinition;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * MarketDefinition
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:42:11.866632-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MarketDefinition {
  public static final String SERIALIZED_NAME_BET_DELAY = "betDelay";
  @SerializedName(SERIALIZED_NAME_BET_DELAY)
  private Integer betDelay;

  /**
   * Gets or Sets bettingType
   */
  @JsonAdapter(BettingTypeEnum.Adapter.class)
  public enum BettingTypeEnum {
    ODDS("ODDS"),
    
    LINE("LINE"),
    
    RANGE("RANGE"),
    
    ASIAN_HANDICAP_DOUBLE_LINE("ASIAN_HANDICAP_DOUBLE_LINE"),
    
    ASIAN_HANDICAP_SINGLE_LINE("ASIAN_HANDICAP_SINGLE_LINE");

    private String value;

    BettingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BettingTypeEnum fromValue(String value) {
      for (BettingTypeEnum b : BettingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BettingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BettingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BettingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BettingTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BettingTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BETTING_TYPE = "bettingType";
  @SerializedName(SERIALIZED_NAME_BETTING_TYPE)
  private BettingTypeEnum bettingType;

  public static final String SERIALIZED_NAME_BSP_MARKET = "bspMarket";
  @SerializedName(SERIALIZED_NAME_BSP_MARKET)
  private Boolean bspMarket;

  public static final String SERIALIZED_NAME_BSP_RECONCILED = "bspReconciled";
  @SerializedName(SERIALIZED_NAME_BSP_RECONCILED)
  private Boolean bspReconciled;

  public static final String SERIALIZED_NAME_COMPLETE = "complete";
  @SerializedName(SERIALIZED_NAME_COMPLETE)
  private Boolean complete;

  public static final String SERIALIZED_NAME_COUNTRY_CODE = "countryCode";
  @SerializedName(SERIALIZED_NAME_COUNTRY_CODE)
  private String countryCode;

  public static final String SERIALIZED_NAME_CROSS_MATCHING = "crossMatching";
  @SerializedName(SERIALIZED_NAME_CROSS_MATCHING)
  private Boolean crossMatching;

  public static final String SERIALIZED_NAME_DISCOUNT_ALLOWED = "discountAllowed";
  @SerializedName(SERIALIZED_NAME_DISCOUNT_ALLOWED)
  private Boolean discountAllowed;

  public static final String SERIALIZED_NAME_EACH_WAY_DIVISOR = "eachWayDivisor";
  @SerializedName(SERIALIZED_NAME_EACH_WAY_DIVISOR)
  private Double eachWayDivisor;

  public static final String SERIALIZED_NAME_EVENT_ID = "eventId";
  @SerializedName(SERIALIZED_NAME_EVENT_ID)
  private String eventId;

  public static final String SERIALIZED_NAME_EVENT_TYPE_ID = "eventTypeId";
  @SerializedName(SERIALIZED_NAME_EVENT_TYPE_ID)
  private String eventTypeId;

  public static final String SERIALIZED_NAME_IN_PLAY = "inPlay";
  @SerializedName(SERIALIZED_NAME_IN_PLAY)
  private Boolean inPlay;

  public static final String SERIALIZED_NAME_KEY_LINE_DEFINITION = "keyLineDefinition";
  @SerializedName(SERIALIZED_NAME_KEY_LINE_DEFINITION)
  private KeyLineDefinition keyLineDefinition;

  public static final String SERIALIZED_NAME_LINE_INTERVAL = "lineInterval";
  @SerializedName(SERIALIZED_NAME_LINE_INTERVAL)
  private Double lineInterval;

  public static final String SERIALIZED_NAME_LINE_MAX_UNIT = "lineMaxUnit";
  @SerializedName(SERIALIZED_NAME_LINE_MAX_UNIT)
  private Double lineMaxUnit;

  public static final String SERIALIZED_NAME_LINE_MIN_UNIT = "lineMinUnit";
  @SerializedName(SERIALIZED_NAME_LINE_MIN_UNIT)
  private Double lineMinUnit;

  public static final String SERIALIZED_NAME_MARKET_BASE_RATE = "marketBaseRate";
  @SerializedName(SERIALIZED_NAME_MARKET_BASE_RATE)
  private Double marketBaseRate;

  public static final String SERIALIZED_NAME_MARKET_TIME = "marketTime";
  @SerializedName(SERIALIZED_NAME_MARKET_TIME)
  private OffsetDateTime marketTime;

  public static final String SERIALIZED_NAME_MARKET_TYPE = "marketType";
  @SerializedName(SERIALIZED_NAME_MARKET_TYPE)
  private String marketType;

  public static final String SERIALIZED_NAME_NUMBER_OF_ACTIVE_RUNNERS = "numberOfActiveRunners";
  @SerializedName(SERIALIZED_NAME_NUMBER_OF_ACTIVE_RUNNERS)
  private Integer numberOfActiveRunners;

  public static final String SERIALIZED_NAME_NUMBER_OF_WINNERS = "numberOfWinners";
  @SerializedName(SERIALIZED_NAME_NUMBER_OF_WINNERS)
  private Integer numberOfWinners;

  public static final String SERIALIZED_NAME_OPEN_DATE = "openDate";
  @SerializedName(SERIALIZED_NAME_OPEN_DATE)
  private OffsetDateTime openDate;

  public static final String SERIALIZED_NAME_PERSISTENCE_ENABLED = "persistenceEnabled";
  @SerializedName(SERIALIZED_NAME_PERSISTENCE_ENABLED)
  private Boolean persistenceEnabled;

  public static final String SERIALIZED_NAME_PRICE_LADDER_DEFINITION = "priceLadderDefinition";
  @SerializedName(SERIALIZED_NAME_PRICE_LADDER_DEFINITION)
  private PriceLadderDefinition priceLadderDefinition;

  public static final String SERIALIZED_NAME_RACE_TYPE = "raceType";
  @SerializedName(SERIALIZED_NAME_RACE_TYPE)
  private String raceType;

  public static final String SERIALIZED_NAME_REGULATORS = "regulators";
  @SerializedName(SERIALIZED_NAME_REGULATORS)
  private List<String> regulators = new ArrayList<>();

  public static final String SERIALIZED_NAME_RUNNERS = "runners";
  @SerializedName(SERIALIZED_NAME_RUNNERS)
  private List<RunnerDefinition> runners = new ArrayList<>();

  public static final String SERIALIZED_NAME_RUNNERS_VOIDABLE = "runnersVoidable";
  @SerializedName(SERIALIZED_NAME_RUNNERS_VOIDABLE)
  private Boolean runnersVoidable;

  public static final String SERIALIZED_NAME_SETTLED_TIME = "settledTime";
  @SerializedName(SERIALIZED_NAME_SETTLED_TIME)
  private OffsetDateTime settledTime;

  /**
   * Gets or Sets status
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    INACTIVE("INACTIVE"),
    
    OPEN("OPEN"),
    
    SUSPENDED("SUSPENDED"),
    
    CLOSED("CLOSED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_SUSPEND_TIME = "suspendTime";
  @SerializedName(SERIALIZED_NAME_SUSPEND_TIME)
  private OffsetDateTime suspendTime;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  private String timezone;

  public static final String SERIALIZED_NAME_TURN_IN_PLAY_ENABLED = "turnInPlayEnabled";
  @SerializedName(SERIALIZED_NAME_TURN_IN_PLAY_ENABLED)
  private Boolean turnInPlayEnabled;

  public static final String SERIALIZED_NAME_VENUE = "venue";
  @SerializedName(SERIALIZED_NAME_VENUE)
  private String venue;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private Long version;

  public MarketDefinition() {
  }

  public MarketDefinition betDelay(Integer betDelay) {
    this.betDelay = betDelay;
    return this;
  }

  /**
   * Get betDelay
   * @return betDelay
   */
  @javax.annotation.Nullable
  public Integer getBetDelay() {
    return betDelay;
  }

  public void setBetDelay(Integer betDelay) {
    this.betDelay = betDelay;
  }


  public MarketDefinition bettingType(BettingTypeEnum bettingType) {
    this.bettingType = bettingType;
    return this;
  }

  /**
   * Get bettingType
   * @return bettingType
   */
  @javax.annotation.Nullable
  public BettingTypeEnum getBettingType() {
    return bettingType;
  }

  public void setBettingType(BettingTypeEnum bettingType) {
    this.bettingType = bettingType;
  }


  public MarketDefinition bspMarket(Boolean bspMarket) {
    this.bspMarket = bspMarket;
    return this;
  }

  /**
   * Get bspMarket
   * @return bspMarket
   */
  @javax.annotation.Nullable
  public Boolean getBspMarket() {
    return bspMarket;
  }

  public void setBspMarket(Boolean bspMarket) {
    this.bspMarket = bspMarket;
  }


  public MarketDefinition bspReconciled(Boolean bspReconciled) {
    this.bspReconciled = bspReconciled;
    return this;
  }

  /**
   * Get bspReconciled
   * @return bspReconciled
   */
  @javax.annotation.Nullable
  public Boolean getBspReconciled() {
    return bspReconciled;
  }

  public void setBspReconciled(Boolean bspReconciled) {
    this.bspReconciled = bspReconciled;
  }


  public MarketDefinition complete(Boolean complete) {
    this.complete = complete;
    return this;
  }

  /**
   * Get complete
   * @return complete
   */
  @javax.annotation.Nullable
  public Boolean getComplete() {
    return complete;
  }

  public void setComplete(Boolean complete) {
    this.complete = complete;
  }


  public MarketDefinition countryCode(String countryCode) {
    this.countryCode = countryCode;
    return this;
  }

  /**
   * Get countryCode
   * @return countryCode
   */
  @javax.annotation.Nullable
  public String getCountryCode() {
    return countryCode;
  }

  public void setCountryCode(String countryCode) {
    this.countryCode = countryCode;
  }


  public MarketDefinition crossMatching(Boolean crossMatching) {
    this.crossMatching = crossMatching;
    return this;
  }

  /**
   * Get crossMatching
   * @return crossMatching
   */
  @javax.annotation.Nullable
  public Boolean getCrossMatching() {
    return crossMatching;
  }

  public void setCrossMatching(Boolean crossMatching) {
    this.crossMatching = crossMatching;
  }


  public MarketDefinition discountAllowed(Boolean discountAllowed) {
    this.discountAllowed = discountAllowed;
    return this;
  }

  /**
   * Get discountAllowed
   * @return discountAllowed
   */
  @javax.annotation.Nullable
  public Boolean getDiscountAllowed() {
    return discountAllowed;
  }

  public void setDiscountAllowed(Boolean discountAllowed) {
    this.discountAllowed = discountAllowed;
  }


  public MarketDefinition eachWayDivisor(Double eachWayDivisor) {
    this.eachWayDivisor = eachWayDivisor;
    return this;
  }

  /**
   * Get eachWayDivisor
   * @return eachWayDivisor
   */
  @javax.annotation.Nullable
  public Double getEachWayDivisor() {
    return eachWayDivisor;
  }

  public void setEachWayDivisor(Double eachWayDivisor) {
    this.eachWayDivisor = eachWayDivisor;
  }


  public MarketDefinition eventId(String eventId) {
    this.eventId = eventId;
    return this;
  }

  /**
   * Get eventId
   * @return eventId
   */
  @javax.annotation.Nullable
  public String getEventId() {
    return eventId;
  }

  public void setEventId(String eventId) {
    this.eventId = eventId;
  }


  public MarketDefinition eventTypeId(String eventTypeId) {
    this.eventTypeId = eventTypeId;
    return this;
  }

  /**
   * The Event Type the market is contained within.
   * @return eventTypeId
   */
  @javax.annotation.Nullable
  public String getEventTypeId() {
    return eventTypeId;
  }

  public void setEventTypeId(String eventTypeId) {
    this.eventTypeId = eventTypeId;
  }


  public MarketDefinition inPlay(Boolean inPlay) {
    this.inPlay = inPlay;
    return this;
  }

  /**
   * Get inPlay
   * @return inPlay
   */
  @javax.annotation.Nullable
  public Boolean getInPlay() {
    return inPlay;
  }

  public void setInPlay(Boolean inPlay) {
    this.inPlay = inPlay;
  }


  public MarketDefinition keyLineDefinition(KeyLineDefinition keyLineDefinition) {
    this.keyLineDefinition = keyLineDefinition;
    return this;
  }

  /**
   * Get keyLineDefinition
   * @return keyLineDefinition
   */
  @javax.annotation.Nullable
  public KeyLineDefinition getKeyLineDefinition() {
    return keyLineDefinition;
  }

  public void setKeyLineDefinition(KeyLineDefinition keyLineDefinition) {
    this.keyLineDefinition = keyLineDefinition;
  }


  public MarketDefinition lineInterval(Double lineInterval) {
    this.lineInterval = lineInterval;
    return this;
  }

  /**
   * For Handicap and Line markets, the lines available on this market will be between the range of lineMinUnit and lineMaxUnit, in increments of the lineInterval value. e.g. If unit is runs, lineMinUnit&#x3D;10, lineMaxUnit&#x3D;20 and lineInterval&#x3D;0.5, then valid lines include 10, 10.5, 11, 11.5 up to 20 runs.
   * @return lineInterval
   */
  @javax.annotation.Nullable
  public Double getLineInterval() {
    return lineInterval;
  }

  public void setLineInterval(Double lineInterval) {
    this.lineInterval = lineInterval;
  }


  public MarketDefinition lineMaxUnit(Double lineMaxUnit) {
    this.lineMaxUnit = lineMaxUnit;
    return this;
  }

  /**
   * For Handicap and Line markets, the maximum value for the outcome, in market units for this market (eg 100 runs).
   * @return lineMaxUnit
   */
  @javax.annotation.Nullable
  public Double getLineMaxUnit() {
    return lineMaxUnit;
  }

  public void setLineMaxUnit(Double lineMaxUnit) {
    this.lineMaxUnit = lineMaxUnit;
  }


  public MarketDefinition lineMinUnit(Double lineMinUnit) {
    this.lineMinUnit = lineMinUnit;
    return this;
  }

  /**
   * For Handicap and Line markets, the minimum value for the outcome, in market units for this market (eg 0 runs).
   * @return lineMinUnit
   */
  @javax.annotation.Nullable
  public Double getLineMinUnit() {
    return lineMinUnit;
  }

  public void setLineMinUnit(Double lineMinUnit) {
    this.lineMinUnit = lineMinUnit;
  }


  public MarketDefinition marketBaseRate(Double marketBaseRate) {
    this.marketBaseRate = marketBaseRate;
    return this;
  }

  /**
   * Get marketBaseRate
   * @return marketBaseRate
   */
  @javax.annotation.Nullable
  public Double getMarketBaseRate() {
    return marketBaseRate;
  }

  public void setMarketBaseRate(Double marketBaseRate) {
    this.marketBaseRate = marketBaseRate;
  }


  public MarketDefinition marketTime(OffsetDateTime marketTime) {
    this.marketTime = marketTime;
    return this;
  }

  /**
   * Get marketTime
   * @return marketTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getMarketTime() {
    return marketTime;
  }

  public void setMarketTime(OffsetDateTime marketTime) {
    this.marketTime = marketTime;
  }


  public MarketDefinition marketType(String marketType) {
    this.marketType = marketType;
    return this;
  }

  /**
   * Get marketType
   * @return marketType
   */
  @javax.annotation.Nullable
  public String getMarketType() {
    return marketType;
  }

  public void setMarketType(String marketType) {
    this.marketType = marketType;
  }


  public MarketDefinition numberOfActiveRunners(Integer numberOfActiveRunners) {
    this.numberOfActiveRunners = numberOfActiveRunners;
    return this;
  }

  /**
   * Get numberOfActiveRunners
   * @return numberOfActiveRunners
   */
  @javax.annotation.Nullable
  public Integer getNumberOfActiveRunners() {
    return numberOfActiveRunners;
  }

  public void setNumberOfActiveRunners(Integer numberOfActiveRunners) {
    this.numberOfActiveRunners = numberOfActiveRunners;
  }


  public MarketDefinition numberOfWinners(Integer numberOfWinners) {
    this.numberOfWinners = numberOfWinners;
    return this;
  }

  /**
   * Get numberOfWinners
   * @return numberOfWinners
   */
  @javax.annotation.Nullable
  public Integer getNumberOfWinners() {
    return numberOfWinners;
  }

  public void setNumberOfWinners(Integer numberOfWinners) {
    this.numberOfWinners = numberOfWinners;
  }


  public MarketDefinition openDate(OffsetDateTime openDate) {
    this.openDate = openDate;
    return this;
  }

  /**
   * Get openDate
   * @return openDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getOpenDate() {
    return openDate;
  }

  public void setOpenDate(OffsetDateTime openDate) {
    this.openDate = openDate;
  }


  public MarketDefinition persistenceEnabled(Boolean persistenceEnabled) {
    this.persistenceEnabled = persistenceEnabled;
    return this;
  }

  /**
   * Get persistenceEnabled
   * @return persistenceEnabled
   */
  @javax.annotation.Nullable
  public Boolean getPersistenceEnabled() {
    return persistenceEnabled;
  }

  public void setPersistenceEnabled(Boolean persistenceEnabled) {
    this.persistenceEnabled = persistenceEnabled;
  }


  public MarketDefinition priceLadderDefinition(PriceLadderDefinition priceLadderDefinition) {
    this.priceLadderDefinition = priceLadderDefinition;
    return this;
  }

  /**
   * Get priceLadderDefinition
   * @return priceLadderDefinition
   */
  @javax.annotation.Nullable
  public PriceLadderDefinition getPriceLadderDefinition() {
    return priceLadderDefinition;
  }

  public void setPriceLadderDefinition(PriceLadderDefinition priceLadderDefinition) {
    this.priceLadderDefinition = priceLadderDefinition;
  }


  public MarketDefinition raceType(String raceType) {
    this.raceType = raceType;
    return this;
  }

  /**
   * Get raceType
   * @return raceType
   */
  @javax.annotation.Nullable
  public String getRaceType() {
    return raceType;
  }

  public void setRaceType(String raceType) {
    this.raceType = raceType;
  }


  public MarketDefinition regulators(List<String> regulators) {
    this.regulators = regulators;
    return this;
  }

  public MarketDefinition addRegulatorsItem(String regulatorsItem) {
    if (this.regulators == null) {
      this.regulators = new ArrayList<>();
    }
    this.regulators.add(regulatorsItem);
    return this;
  }

  /**
   * The market regulators.
   * @return regulators
   */
  @javax.annotation.Nullable
  public List<String> getRegulators() {
    return regulators;
  }

  public void setRegulators(List<String> regulators) {
    this.regulators = regulators;
  }


  public MarketDefinition runners(List<RunnerDefinition> runners) {
    this.runners = runners;
    return this;
  }

  public MarketDefinition addRunnersItem(RunnerDefinition runnersItem) {
    if (this.runners == null) {
      this.runners = new ArrayList<>();
    }
    this.runners.add(runnersItem);
    return this;
  }

  /**
   * Get runners
   * @return runners
   */
  @javax.annotation.Nullable
  public List<RunnerDefinition> getRunners() {
    return runners;
  }

  public void setRunners(List<RunnerDefinition> runners) {
    this.runners = runners;
  }


  public MarketDefinition runnersVoidable(Boolean runnersVoidable) {
    this.runnersVoidable = runnersVoidable;
    return this;
  }

  /**
   * Get runnersVoidable
   * @return runnersVoidable
   */
  @javax.annotation.Nullable
  public Boolean getRunnersVoidable() {
    return runnersVoidable;
  }

  public void setRunnersVoidable(Boolean runnersVoidable) {
    this.runnersVoidable = runnersVoidable;
  }


  public MarketDefinition settledTime(OffsetDateTime settledTime) {
    this.settledTime = settledTime;
    return this;
  }

  /**
   * Get settledTime
   * @return settledTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSettledTime() {
    return settledTime;
  }

  public void setSettledTime(OffsetDateTime settledTime) {
    this.settledTime = settledTime;
  }


  public MarketDefinition status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  public MarketDefinition suspendTime(OffsetDateTime suspendTime) {
    this.suspendTime = suspendTime;
    return this;
  }

  /**
   * Get suspendTime
   * @return suspendTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSuspendTime() {
    return suspendTime;
  }

  public void setSuspendTime(OffsetDateTime suspendTime) {
    this.suspendTime = suspendTime;
  }


  public MarketDefinition timezone(String timezone) {
    this.timezone = timezone;
    return this;
  }

  /**
   * Get timezone
   * @return timezone
   */
  @javax.annotation.Nullable
  public String getTimezone() {
    return timezone;
  }

  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public MarketDefinition turnInPlayEnabled(Boolean turnInPlayEnabled) {
    this.turnInPlayEnabled = turnInPlayEnabled;
    return this;
  }

  /**
   * Get turnInPlayEnabled
   * @return turnInPlayEnabled
   */
  @javax.annotation.Nullable
  public Boolean getTurnInPlayEnabled() {
    return turnInPlayEnabled;
  }

  public void setTurnInPlayEnabled(Boolean turnInPlayEnabled) {
    this.turnInPlayEnabled = turnInPlayEnabled;
  }


  public MarketDefinition venue(String venue) {
    this.venue = venue;
    return this;
  }

  /**
   * Get venue
   * @return venue
   */
  @javax.annotation.Nullable
  public String getVenue() {
    return venue;
  }

  public void setVenue(String venue) {
    this.venue = venue;
  }


  public MarketDefinition version(Long version) {
    this.version = version;
    return this;
  }

  /**
   * Get version
   * @return version
   */
  @javax.annotation.Nullable
  public Long getVersion() {
    return version;
  }

  public void setVersion(Long version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MarketDefinition marketDefinition = (MarketDefinition) o;
    return Objects.equals(this.betDelay, marketDefinition.betDelay) &&
        Objects.equals(this.bettingType, marketDefinition.bettingType) &&
        Objects.equals(this.bspMarket, marketDefinition.bspMarket) &&
        Objects.equals(this.bspReconciled, marketDefinition.bspReconciled) &&
        Objects.equals(this.complete, marketDefinition.complete) &&
        Objects.equals(this.countryCode, marketDefinition.countryCode) &&
        Objects.equals(this.crossMatching, marketDefinition.crossMatching) &&
        Objects.equals(this.discountAllowed, marketDefinition.discountAllowed) &&
        Objects.equals(this.eachWayDivisor, marketDefinition.eachWayDivisor) &&
        Objects.equals(this.eventId, marketDefinition.eventId) &&
        Objects.equals(this.eventTypeId, marketDefinition.eventTypeId) &&
        Objects.equals(this.inPlay, marketDefinition.inPlay) &&
        Objects.equals(this.keyLineDefinition, marketDefinition.keyLineDefinition) &&
        Objects.equals(this.lineInterval, marketDefinition.lineInterval) &&
        Objects.equals(this.lineMaxUnit, marketDefinition.lineMaxUnit) &&
        Objects.equals(this.lineMinUnit, marketDefinition.lineMinUnit) &&
        Objects.equals(this.marketBaseRate, marketDefinition.marketBaseRate) &&
        Objects.equals(this.marketTime, marketDefinition.marketTime) &&
        Objects.equals(this.marketType, marketDefinition.marketType) &&
        Objects.equals(this.numberOfActiveRunners, marketDefinition.numberOfActiveRunners) &&
        Objects.equals(this.numberOfWinners, marketDefinition.numberOfWinners) &&
        Objects.equals(this.openDate, marketDefinition.openDate) &&
        Objects.equals(this.persistenceEnabled, marketDefinition.persistenceEnabled) &&
        Objects.equals(this.priceLadderDefinition, marketDefinition.priceLadderDefinition) &&
        Objects.equals(this.raceType, marketDefinition.raceType) &&
        Objects.equals(this.regulators, marketDefinition.regulators) &&
        Objects.equals(this.runners, marketDefinition.runners) &&
        Objects.equals(this.runnersVoidable, marketDefinition.runnersVoidable) &&
        Objects.equals(this.settledTime, marketDefinition.settledTime) &&
        Objects.equals(this.status, marketDefinition.status) &&
        Objects.equals(this.suspendTime, marketDefinition.suspendTime) &&
        Objects.equals(this.timezone, marketDefinition.timezone) &&
        Objects.equals(this.turnInPlayEnabled, marketDefinition.turnInPlayEnabled) &&
        Objects.equals(this.venue, marketDefinition.venue) &&
        Objects.equals(this.version, marketDefinition.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(betDelay, bettingType, bspMarket, bspReconciled, complete, countryCode, crossMatching, discountAllowed, eachWayDivisor, eventId, eventTypeId, inPlay, keyLineDefinition, lineInterval, lineMaxUnit, lineMinUnit, marketBaseRate, marketTime, marketType, numberOfActiveRunners, numberOfWinners, openDate, persistenceEnabled, priceLadderDefinition, raceType, regulators, runners, runnersVoidable, settledTime, status, suspendTime, timezone, turnInPlayEnabled, venue, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MarketDefinition {\n");
    sb.append("    betDelay: ").append(toIndentedString(betDelay)).append("\n");
    sb.append("    bettingType: ").append(toIndentedString(bettingType)).append("\n");
    sb.append("    bspMarket: ").append(toIndentedString(bspMarket)).append("\n");
    sb.append("    bspReconciled: ").append(toIndentedString(bspReconciled)).append("\n");
    sb.append("    complete: ").append(toIndentedString(complete)).append("\n");
    sb.append("    countryCode: ").append(toIndentedString(countryCode)).append("\n");
    sb.append("    crossMatching: ").append(toIndentedString(crossMatching)).append("\n");
    sb.append("    discountAllowed: ").append(toIndentedString(discountAllowed)).append("\n");
    sb.append("    eachWayDivisor: ").append(toIndentedString(eachWayDivisor)).append("\n");
    sb.append("    eventId: ").append(toIndentedString(eventId)).append("\n");
    sb.append("    eventTypeId: ").append(toIndentedString(eventTypeId)).append("\n");
    sb.append("    inPlay: ").append(toIndentedString(inPlay)).append("\n");
    sb.append("    keyLineDefinition: ").append(toIndentedString(keyLineDefinition)).append("\n");
    sb.append("    lineInterval: ").append(toIndentedString(lineInterval)).append("\n");
    sb.append("    lineMaxUnit: ").append(toIndentedString(lineMaxUnit)).append("\n");
    sb.append("    lineMinUnit: ").append(toIndentedString(lineMinUnit)).append("\n");
    sb.append("    marketBaseRate: ").append(toIndentedString(marketBaseRate)).append("\n");
    sb.append("    marketTime: ").append(toIndentedString(marketTime)).append("\n");
    sb.append("    marketType: ").append(toIndentedString(marketType)).append("\n");
    sb.append("    numberOfActiveRunners: ").append(toIndentedString(numberOfActiveRunners)).append("\n");
    sb.append("    numberOfWinners: ").append(toIndentedString(numberOfWinners)).append("\n");
    sb.append("    openDate: ").append(toIndentedString(openDate)).append("\n");
    sb.append("    persistenceEnabled: ").append(toIndentedString(persistenceEnabled)).append("\n");
    sb.append("    priceLadderDefinition: ").append(toIndentedString(priceLadderDefinition)).append("\n");
    sb.append("    raceType: ").append(toIndentedString(raceType)).append("\n");
    sb.append("    regulators: ").append(toIndentedString(regulators)).append("\n");
    sb.append("    runners: ").append(toIndentedString(runners)).append("\n");
    sb.append("    runnersVoidable: ").append(toIndentedString(runnersVoidable)).append("\n");
    sb.append("    settledTime: ").append(toIndentedString(settledTime)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    suspendTime: ").append(toIndentedString(suspendTime)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    turnInPlayEnabled: ").append(toIndentedString(turnInPlayEnabled)).append("\n");
    sb.append("    venue: ").append(toIndentedString(venue)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("betDelay");
    openapiFields.add("bettingType");
    openapiFields.add("bspMarket");
    openapiFields.add("bspReconciled");
    openapiFields.add("complete");
    openapiFields.add("countryCode");
    openapiFields.add("crossMatching");
    openapiFields.add("discountAllowed");
    openapiFields.add("eachWayDivisor");
    openapiFields.add("eventId");
    openapiFields.add("eventTypeId");
    openapiFields.add("inPlay");
    openapiFields.add("keyLineDefinition");
    openapiFields.add("lineInterval");
    openapiFields.add("lineMaxUnit");
    openapiFields.add("lineMinUnit");
    openapiFields.add("marketBaseRate");
    openapiFields.add("marketTime");
    openapiFields.add("marketType");
    openapiFields.add("numberOfActiveRunners");
    openapiFields.add("numberOfWinners");
    openapiFields.add("openDate");
    openapiFields.add("persistenceEnabled");
    openapiFields.add("priceLadderDefinition");
    openapiFields.add("raceType");
    openapiFields.add("regulators");
    openapiFields.add("runners");
    openapiFields.add("runnersVoidable");
    openapiFields.add("settledTime");
    openapiFields.add("status");
    openapiFields.add("suspendTime");
    openapiFields.add("timezone");
    openapiFields.add("turnInPlayEnabled");
    openapiFields.add("venue");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MarketDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MarketDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MarketDefinition is not found in the empty JSON string", MarketDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MarketDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MarketDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bettingType") != null && !jsonObj.get("bettingType").isJsonNull()) && !jsonObj.get("bettingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bettingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bettingType").toString()));
      }
      // validate the optional field `bettingType`
      if (jsonObj.get("bettingType") != null && !jsonObj.get("bettingType").isJsonNull()) {
        BettingTypeEnum.validateJsonElement(jsonObj.get("bettingType"));
      }
      if ((jsonObj.get("countryCode") != null && !jsonObj.get("countryCode").isJsonNull()) && !jsonObj.get("countryCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryCode").toString()));
      }
      if ((jsonObj.get("eventId") != null && !jsonObj.get("eventId").isJsonNull()) && !jsonObj.get("eventId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eventId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eventId").toString()));
      }
      if ((jsonObj.get("eventTypeId") != null && !jsonObj.get("eventTypeId").isJsonNull()) && !jsonObj.get("eventTypeId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eventTypeId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eventTypeId").toString()));
      }
      // validate the optional field `keyLineDefinition`
      if (jsonObj.get("keyLineDefinition") != null && !jsonObj.get("keyLineDefinition").isJsonNull()) {
        KeyLineDefinition.validateJsonElement(jsonObj.get("keyLineDefinition"));
      }
      if ((jsonObj.get("marketType") != null && !jsonObj.get("marketType").isJsonNull()) && !jsonObj.get("marketType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketType").toString()));
      }
      // validate the optional field `priceLadderDefinition`
      if (jsonObj.get("priceLadderDefinition") != null && !jsonObj.get("priceLadderDefinition").isJsonNull()) {
        PriceLadderDefinition.validateJsonElement(jsonObj.get("priceLadderDefinition"));
      }
      if ((jsonObj.get("raceType") != null && !jsonObj.get("raceType").isJsonNull()) && !jsonObj.get("raceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `raceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("raceType").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("regulators") != null && !jsonObj.get("regulators").isJsonNull() && !jsonObj.get("regulators").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `regulators` to be an array in the JSON string but got `%s`", jsonObj.get("regulators").toString()));
      }
      if (jsonObj.get("runners") != null && !jsonObj.get("runners").isJsonNull()) {
        JsonArray jsonArrayrunners = jsonObj.getAsJsonArray("runners");
        if (jsonArrayrunners != null) {
          // ensure the json data is an array
          if (!jsonObj.get("runners").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `runners` to be an array in the JSON string but got `%s`", jsonObj.get("runners").toString()));
          }

          // validate the optional field `runners` (array)
          for (int i = 0; i < jsonArrayrunners.size(); i++) {
            RunnerDefinition.validateJsonElement(jsonArrayrunners.get(i));
          };
        }
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("timezone") != null && !jsonObj.get("timezone").isJsonNull()) && !jsonObj.get("timezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezone").toString()));
      }
      if ((jsonObj.get("venue") != null && !jsonObj.get("venue").isJsonNull()) && !jsonObj.get("venue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `venue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("venue").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MarketDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MarketDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MarketDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MarketDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<MarketDefinition>() {
           @Override
           public void write(JsonWriter out, MarketDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MarketDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MarketDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MarketDefinition
   * @throws IOException if the JSON string is invalid with respect to MarketDefinition
   */
  public static MarketDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MarketDefinition.class);
  }

  /**
   * Convert an instance of MarketDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

