/*
 * Betfair: Exchange Streaming API
 * API to receive streamed updates. This is an ssl socket connection of CRLF delimited json messages (see RequestMessage & ResponseMessage)
 *
 * The version of the OpenAPI document: 1.0.1423
 * Contact: bdp@betfair.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Order
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:42:11.866632-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Order {
  public static final String SERIALIZED_NAME_AVP = "avp";
  @SerializedName(SERIALIZED_NAME_AVP)
  private Double avp;

  public static final String SERIALIZED_NAME_BSP = "bsp";
  @SerializedName(SERIALIZED_NAME_BSP)
  private Double bsp;

  public static final String SERIALIZED_NAME_CD = "cd";
  @SerializedName(SERIALIZED_NAME_CD)
  private Long cd;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_LD = "ld";
  @SerializedName(SERIALIZED_NAME_LD)
  private Long ld;

  public static final String SERIALIZED_NAME_LSRC = "lsrc";
  @SerializedName(SERIALIZED_NAME_LSRC)
  private String lsrc;

  public static final String SERIALIZED_NAME_MD = "md";
  @SerializedName(SERIALIZED_NAME_MD)
  private Long md;

  /**
   * Order Type - the type of the order (L &#x3D; LIMIT, MOC &#x3D; MARKET_ON_CLOSE, LOC &#x3D; LIMIT_ON_CLOSE)
   */
  @JsonAdapter(OtEnum.Adapter.class)
  public enum OtEnum {
    L("L"),
    
    LOC("LOC"),
    
    MOC("MOC");

    private String value;

    OtEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OtEnum fromValue(String value) {
      for (OtEnum b : OtEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OtEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OtEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OtEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OtEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OtEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OT = "ot";
  @SerializedName(SERIALIZED_NAME_OT)
  private OtEnum ot;

  public static final String SERIALIZED_NAME_P = "p";
  @SerializedName(SERIALIZED_NAME_P)
  private Double p;

  public static final String SERIALIZED_NAME_PD = "pd";
  @SerializedName(SERIALIZED_NAME_PD)
  private Long pd;

  /**
   * Persistence Type - whether the order will persist at in play or not (L &#x3D; LAPSE, P &#x3D; PERSIST, MOC &#x3D; Market On Close)
   */
  @JsonAdapter(PtEnum.Adapter.class)
  public enum PtEnum {
    L("L"),
    
    P("P"),
    
    MOC("MOC");

    private String value;

    PtEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PtEnum fromValue(String value) {
      for (PtEnum b : PtEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PtEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PtEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PtEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PtEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PtEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PT = "pt";
  @SerializedName(SERIALIZED_NAME_PT)
  private PtEnum pt;

  public static final String SERIALIZED_NAME_RAC = "rac";
  @SerializedName(SERIALIZED_NAME_RAC)
  private String rac;

  public static final String SERIALIZED_NAME_RC = "rc";
  @SerializedName(SERIALIZED_NAME_RC)
  private String rc;

  public static final String SERIALIZED_NAME_RFO = "rfo";
  @SerializedName(SERIALIZED_NAME_RFO)
  private String rfo;

  public static final String SERIALIZED_NAME_RFS = "rfs";
  @SerializedName(SERIALIZED_NAME_RFS)
  private String rfs;

  public static final String SERIALIZED_NAME_S = "s";
  @SerializedName(SERIALIZED_NAME_S)
  private Double s;

  public static final String SERIALIZED_NAME_SC = "sc";
  @SerializedName(SERIALIZED_NAME_SC)
  private Double sc;

  /**
   * Side - the side of the order. For Line markets a &#39;B&#39; bet refers to a SELL line and an &#39;L&#39; bet refers to a BUY line.
   */
  @JsonAdapter(SideEnum.Adapter.class)
  public enum SideEnum {
    B("B"),
    
    L("L");

    private String value;

    SideEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SideEnum fromValue(String value) {
      for (SideEnum b : SideEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SideEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SideEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SideEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SideEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SideEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SIDE = "side";
  @SerializedName(SERIALIZED_NAME_SIDE)
  private SideEnum side;

  public static final String SERIALIZED_NAME_SL = "sl";
  @SerializedName(SERIALIZED_NAME_SL)
  private Double sl;

  public static final String SERIALIZED_NAME_SM = "sm";
  @SerializedName(SERIALIZED_NAME_SM)
  private Double sm;

  public static final String SERIALIZED_NAME_SR = "sr";
  @SerializedName(SERIALIZED_NAME_SR)
  private Double sr;

  /**
   * Status - the status of the order (E &#x3D; EXECUTABLE, EC &#x3D; EXECUTION_COMPLETE)
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    E("E"),
    
    EC("EC");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_SV = "sv";
  @SerializedName(SERIALIZED_NAME_SV)
  private Double sv;

  public Order() {
  }

  public Order avp(Double avp) {
    this.avp = avp;
    return this;
  }

  /**
   * Average Price Matched - the average price the order was matched at (null if the order is not matched). This value is not meaningful for activity on Line markets and is not guaranteed to be returned or maintained for these markets.
   * @return avp
   */
  @javax.annotation.Nullable
  public Double getAvp() {
    return avp;
  }

  public void setAvp(Double avp) {
    this.avp = avp;
  }


  public Order bsp(Double bsp) {
    this.bsp = bsp;
    return this;
  }

  /**
   * BSP Liability - the BSP liability of the order (null if the order is not a BSP order)
   * @return bsp
   */
  @javax.annotation.Nullable
  public Double getBsp() {
    return bsp;
  }

  public void setBsp(Double bsp) {
    this.bsp = bsp;
  }


  public Order cd(Long cd) {
    this.cd = cd;
    return this;
  }

  /**
   * Cancelled Date - the date the order was cancelled (null if the order is not cancelled)
   * @return cd
   */
  @javax.annotation.Nullable
  public Long getCd() {
    return cd;
  }

  public void setCd(Long cd) {
    this.cd = cd;
  }


  public Order id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Bet Id - the id of the order
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Order ld(Long ld) {
    this.ld = ld;
    return this;
  }

  /**
   * Lapsed Date - the date the order was lapsed (null if the order is not lapsed)
   * @return ld
   */
  @javax.annotation.Nullable
  public Long getLd() {
    return ld;
  }

  public void setLd(Long ld) {
    this.ld = ld;
  }


  public Order lsrc(String lsrc) {
    this.lsrc = lsrc;
    return this;
  }

  /**
   * Lapse Status Reason Code - the reason that some or all of this order has been lapsed (null if no portion of the order is lapsed
   * @return lsrc
   */
  @javax.annotation.Nullable
  public String getLsrc() {
    return lsrc;
  }

  public void setLsrc(String lsrc) {
    this.lsrc = lsrc;
  }


  public Order md(Long md) {
    this.md = md;
    return this;
  }

  /**
   * Matched Date - the date the order was matched (null if the order is not matched)
   * @return md
   */
  @javax.annotation.Nullable
  public Long getMd() {
    return md;
  }

  public void setMd(Long md) {
    this.md = md;
  }


  public Order ot(OtEnum ot) {
    this.ot = ot;
    return this;
  }

  /**
   * Order Type - the type of the order (L &#x3D; LIMIT, MOC &#x3D; MARKET_ON_CLOSE, LOC &#x3D; LIMIT_ON_CLOSE)
   * @return ot
   */
  @javax.annotation.Nullable
  public OtEnum getOt() {
    return ot;
  }

  public void setOt(OtEnum ot) {
    this.ot = ot;
  }


  public Order p(Double p) {
    this.p = p;
    return this;
  }

  /**
   * Price - the original placed price of the order. Line markets operate at even-money odds of 2.0. However, price for these markets refers to the line positions available as defined by the markets min-max range and interval steps
   * @return p
   */
  @javax.annotation.Nullable
  public Double getP() {
    return p;
  }

  public void setP(Double p) {
    this.p = p;
  }


  public Order pd(Long pd) {
    this.pd = pd;
    return this;
  }

  /**
   * Placed Date - the date the order was placed
   * @return pd
   */
  @javax.annotation.Nullable
  public Long getPd() {
    return pd;
  }

  public void setPd(Long pd) {
    this.pd = pd;
  }


  public Order pt(PtEnum pt) {
    this.pt = pt;
    return this;
  }

  /**
   * Persistence Type - whether the order will persist at in play or not (L &#x3D; LAPSE, P &#x3D; PERSIST, MOC &#x3D; Market On Close)
   * @return pt
   */
  @javax.annotation.Nullable
  public PtEnum getPt() {
    return pt;
  }

  public void setPt(PtEnum pt) {
    this.pt = pt;
  }


  public Order rac(String rac) {
    this.rac = rac;
    return this;
  }

  /**
   * Regulator Auth Code - the auth code returned by the regulator
   * @return rac
   */
  @javax.annotation.Nullable
  public String getRac() {
    return rac;
  }

  public void setRac(String rac) {
    this.rac = rac;
  }


  public Order rc(String rc) {
    this.rc = rc;
    return this;
  }

  /**
   * Regulator Code - the regulator of the order
   * @return rc
   */
  @javax.annotation.Nullable
  public String getRc() {
    return rc;
  }

  public void setRc(String rc) {
    this.rc = rc;
  }


  public Order rfo(String rfo) {
    this.rfo = rfo;
    return this;
  }

  /**
   * Order Reference - the customer&#39;s order reference for this order (empty string if one was not set)
   * @return rfo
   */
  @javax.annotation.Nullable
  public String getRfo() {
    return rfo;
  }

  public void setRfo(String rfo) {
    this.rfo = rfo;
  }


  public Order rfs(String rfs) {
    this.rfs = rfs;
    return this;
  }

  /**
   * Strategy Reference - the customer&#39;s strategy reference for this order (empty string if one was not set)
   * @return rfs
   */
  @javax.annotation.Nullable
  public String getRfs() {
    return rfs;
  }

  public void setRfs(String rfs) {
    this.rfs = rfs;
  }


  public Order s(Double s) {
    this.s = s;
    return this;
  }

  /**
   * Size - the original placed size of the order
   * @return s
   */
  @javax.annotation.Nullable
  public Double getS() {
    return s;
  }

  public void setS(Double s) {
    this.s = s;
  }


  public Order sc(Double sc) {
    this.sc = sc;
    return this;
  }

  /**
   * Size Cancelled - the amount of the order that has been cancelled
   * @return sc
   */
  @javax.annotation.Nullable
  public Double getSc() {
    return sc;
  }

  public void setSc(Double sc) {
    this.sc = sc;
  }


  public Order side(SideEnum side) {
    this.side = side;
    return this;
  }

  /**
   * Side - the side of the order. For Line markets a &#39;B&#39; bet refers to a SELL line and an &#39;L&#39; bet refers to a BUY line.
   * @return side
   */
  @javax.annotation.Nullable
  public SideEnum getSide() {
    return side;
  }

  public void setSide(SideEnum side) {
    this.side = side;
  }


  public Order sl(Double sl) {
    this.sl = sl;
    return this;
  }

  /**
   * Size Lapsed - the amount of the order that has been lapsed
   * @return sl
   */
  @javax.annotation.Nullable
  public Double getSl() {
    return sl;
  }

  public void setSl(Double sl) {
    this.sl = sl;
  }


  public Order sm(Double sm) {
    this.sm = sm;
    return this;
  }

  /**
   * Size Matched - the amount of the order that has been matched
   * @return sm
   */
  @javax.annotation.Nullable
  public Double getSm() {
    return sm;
  }

  public void setSm(Double sm) {
    this.sm = sm;
  }


  public Order sr(Double sr) {
    this.sr = sr;
    return this;
  }

  /**
   * Size Remaining - the amount of the order that is remaining unmatched
   * @return sr
   */
  @javax.annotation.Nullable
  public Double getSr() {
    return sr;
  }

  public void setSr(Double sr) {
    this.sr = sr;
  }


  public Order status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * Status - the status of the order (E &#x3D; EXECUTABLE, EC &#x3D; EXECUTION_COMPLETE)
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  public Order sv(Double sv) {
    this.sv = sv;
    return this;
  }

  /**
   * Size Voided - the amount of the order that has been voided
   * @return sv
   */
  @javax.annotation.Nullable
  public Double getSv() {
    return sv;
  }

  public void setSv(Double sv) {
    this.sv = sv;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Order order = (Order) o;
    return Objects.equals(this.avp, order.avp) &&
        Objects.equals(this.bsp, order.bsp) &&
        Objects.equals(this.cd, order.cd) &&
        Objects.equals(this.id, order.id) &&
        Objects.equals(this.ld, order.ld) &&
        Objects.equals(this.lsrc, order.lsrc) &&
        Objects.equals(this.md, order.md) &&
        Objects.equals(this.ot, order.ot) &&
        Objects.equals(this.p, order.p) &&
        Objects.equals(this.pd, order.pd) &&
        Objects.equals(this.pt, order.pt) &&
        Objects.equals(this.rac, order.rac) &&
        Objects.equals(this.rc, order.rc) &&
        Objects.equals(this.rfo, order.rfo) &&
        Objects.equals(this.rfs, order.rfs) &&
        Objects.equals(this.s, order.s) &&
        Objects.equals(this.sc, order.sc) &&
        Objects.equals(this.side, order.side) &&
        Objects.equals(this.sl, order.sl) &&
        Objects.equals(this.sm, order.sm) &&
        Objects.equals(this.sr, order.sr) &&
        Objects.equals(this.status, order.status) &&
        Objects.equals(this.sv, order.sv);
  }

  @Override
  public int hashCode() {
    return Objects.hash(avp, bsp, cd, id, ld, lsrc, md, ot, p, pd, pt, rac, rc, rfo, rfs, s, sc, side, sl, sm, sr, status, sv);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Order {\n");
    sb.append("    avp: ").append(toIndentedString(avp)).append("\n");
    sb.append("    bsp: ").append(toIndentedString(bsp)).append("\n");
    sb.append("    cd: ").append(toIndentedString(cd)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    ld: ").append(toIndentedString(ld)).append("\n");
    sb.append("    lsrc: ").append(toIndentedString(lsrc)).append("\n");
    sb.append("    md: ").append(toIndentedString(md)).append("\n");
    sb.append("    ot: ").append(toIndentedString(ot)).append("\n");
    sb.append("    p: ").append(toIndentedString(p)).append("\n");
    sb.append("    pd: ").append(toIndentedString(pd)).append("\n");
    sb.append("    pt: ").append(toIndentedString(pt)).append("\n");
    sb.append("    rac: ").append(toIndentedString(rac)).append("\n");
    sb.append("    rc: ").append(toIndentedString(rc)).append("\n");
    sb.append("    rfo: ").append(toIndentedString(rfo)).append("\n");
    sb.append("    rfs: ").append(toIndentedString(rfs)).append("\n");
    sb.append("    s: ").append(toIndentedString(s)).append("\n");
    sb.append("    sc: ").append(toIndentedString(sc)).append("\n");
    sb.append("    side: ").append(toIndentedString(side)).append("\n");
    sb.append("    sl: ").append(toIndentedString(sl)).append("\n");
    sb.append("    sm: ").append(toIndentedString(sm)).append("\n");
    sb.append("    sr: ").append(toIndentedString(sr)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    sv: ").append(toIndentedString(sv)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("avp");
    openapiFields.add("bsp");
    openapiFields.add("cd");
    openapiFields.add("id");
    openapiFields.add("ld");
    openapiFields.add("lsrc");
    openapiFields.add("md");
    openapiFields.add("ot");
    openapiFields.add("p");
    openapiFields.add("pd");
    openapiFields.add("pt");
    openapiFields.add("rac");
    openapiFields.add("rc");
    openapiFields.add("rfo");
    openapiFields.add("rfs");
    openapiFields.add("s");
    openapiFields.add("sc");
    openapiFields.add("side");
    openapiFields.add("sl");
    openapiFields.add("sm");
    openapiFields.add("sr");
    openapiFields.add("status");
    openapiFields.add("sv");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Order
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Order.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Order is not found in the empty JSON string", Order.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Order.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Order` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("lsrc") != null && !jsonObj.get("lsrc").isJsonNull()) && !jsonObj.get("lsrc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lsrc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lsrc").toString()));
      }
      if ((jsonObj.get("ot") != null && !jsonObj.get("ot").isJsonNull()) && !jsonObj.get("ot").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ot` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ot").toString()));
      }
      // validate the optional field `ot`
      if (jsonObj.get("ot") != null && !jsonObj.get("ot").isJsonNull()) {
        OtEnum.validateJsonElement(jsonObj.get("ot"));
      }
      if ((jsonObj.get("pt") != null && !jsonObj.get("pt").isJsonNull()) && !jsonObj.get("pt").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pt` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pt").toString()));
      }
      // validate the optional field `pt`
      if (jsonObj.get("pt") != null && !jsonObj.get("pt").isJsonNull()) {
        PtEnum.validateJsonElement(jsonObj.get("pt"));
      }
      if ((jsonObj.get("rac") != null && !jsonObj.get("rac").isJsonNull()) && !jsonObj.get("rac").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rac` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rac").toString()));
      }
      if ((jsonObj.get("rc") != null && !jsonObj.get("rc").isJsonNull()) && !jsonObj.get("rc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rc").toString()));
      }
      if ((jsonObj.get("rfo") != null && !jsonObj.get("rfo").isJsonNull()) && !jsonObj.get("rfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rfo").toString()));
      }
      if ((jsonObj.get("rfs") != null && !jsonObj.get("rfs").isJsonNull()) && !jsonObj.get("rfs").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rfs` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rfs").toString()));
      }
      if ((jsonObj.get("side") != null && !jsonObj.get("side").isJsonNull()) && !jsonObj.get("side").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `side` to be a primitive type in the JSON string but got `%s`", jsonObj.get("side").toString()));
      }
      // validate the optional field `side`
      if (jsonObj.get("side") != null && !jsonObj.get("side").isJsonNull()) {
        SideEnum.validateJsonElement(jsonObj.get("side"));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Order.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Order' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Order> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Order.class));

       return (TypeAdapter<T>) new TypeAdapter<Order>() {
           @Override
           public void write(JsonWriter out, Order value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Order read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Order given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Order
   * @throws IOException if the JSON string is invalid with respect to Order
   */
  public static Order fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Order.class);
  }

  /**
   * Convert an instance of Order to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

