/*
 * Reports API
 * The [Reports API](/reports/overview) enables you to request a report of activity for your Vonage account.  Depending on your query pattern, you can choose from one of the two versions of the Reports API: asynchronous and synchronous. The asynchronous version is optimized for infrequent and large data queries (from several records to tens of millions). The synchronous version is optimized for frequent and periodic retrievals of small batches of data records (from one record to tens of thousand per query).  Only synchronous version supports retrival of data records by message/record ID.  Vonage recommends that you limit asynchronous queries to a maximum of 20 million records, by setting the start and end dates accordingly. On average, the asynchronous Reports API takes 5 - 10 minutes to generate 1 million records. 
 *
 * The version of the OpenAPI document: 2.2.2
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.CancelReport409Response;
import org.openapitools.client.model.CreateAsyncReport200Response;
import org.openapitools.client.model.CreateAsyncReport400Response;
import org.openapitools.client.model.CreateAsyncReport403Response;
import org.openapitools.client.model.CreateAsyncReport422Response;
import org.openapitools.client.model.CreateAsyncReportRequest;
import org.openapitools.client.model.DownloadReport200Response;
import org.openapitools.client.model.GetRecords200Response;
import org.openapitools.client.model.GetRecords403Response;
import org.openapitools.client.model.GetRecords422Response;
import org.openapitools.client.model.GetReport200Response;
import org.openapitools.client.model.GetReport404Response;
import org.openapitools.client.model.ListReports200Response;
import org.openapitools.client.model.ListReports400Response;
import org.openapitools.client.model.ListReports401Response;
import java.time.LocalDate;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for cancelReport
     * @param reportId UUID of the report (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Invalid Abort Operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelReportCall(String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/reports/{report_id}"
            .replace("{" + "report_id" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelReportValidateBeforeCall(String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling cancelReport(Async)");
        }

        return cancelReportCall(reportId, _callback);

    }

    /**
     * Cancel the execution of a report
     * Cancel the execution of a pending or processing report.
     * @param reportId UUID of the report (required)
     * @return GetReport200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Invalid Abort Operation </td><td>  -  </td></tr>
     </table>
     */
    public GetReport200Response cancelReport(String reportId) throws ApiException {
        ApiResponse<GetReport200Response> localVarResp = cancelReportWithHttpInfo(reportId);
        return localVarResp.getData();
    }

    /**
     * Cancel the execution of a report
     * Cancel the execution of a pending or processing report.
     * @param reportId UUID of the report (required)
     * @return ApiResponse&lt;GetReport200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Invalid Abort Operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReport200Response> cancelReportWithHttpInfo(String reportId) throws ApiException {
        okhttp3.Call localVarCall = cancelReportValidateBeforeCall(reportId, null);
        Type localVarReturnType = new TypeToken<GetReport200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel the execution of a report (asynchronously)
     * Cancel the execution of a pending or processing report.
     * @param reportId UUID of the report (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Invalid Abort Operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelReportAsync(String reportId, final ApiCallback<GetReport200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelReportValidateBeforeCall(reportId, _callback);
        Type localVarReturnType = new TypeToken<GetReport200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createAsyncReport
     * @param createAsyncReportRequest The parameters of the JSON body will be used to create and filter the report.&lt;br&gt; The value of the &#x60;product&#x60; field will define which product the report will be created for and which parameters are accepted.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createAsyncReportCall(CreateAsyncReportRequest createAsyncReportRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createAsyncReportRequest;

        // create path and map variables
        String localVarPath = "/v2/reports";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createAsyncReportValidateBeforeCall(CreateAsyncReportRequest createAsyncReportRequest, final ApiCallback _callback) throws ApiException {
        return createAsyncReportCall(createAsyncReportRequest, _callback);

    }

    /**
     * Create an asynchronous report
     * Request a report on your account activity
     * @param createAsyncReportRequest The parameters of the JSON body will be used to create and filter the report.&lt;br&gt; The value of the &#x60;product&#x60; field will define which product the report will be created for and which parameters are accepted.  (optional)
     * @return CreateAsyncReport200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public CreateAsyncReport200Response createAsyncReport(CreateAsyncReportRequest createAsyncReportRequest) throws ApiException {
        ApiResponse<CreateAsyncReport200Response> localVarResp = createAsyncReportWithHttpInfo(createAsyncReportRequest);
        return localVarResp.getData();
    }

    /**
     * Create an asynchronous report
     * Request a report on your account activity
     * @param createAsyncReportRequest The parameters of the JSON body will be used to create and filter the report.&lt;br&gt; The value of the &#x60;product&#x60; field will define which product the report will be created for and which parameters are accepted.  (optional)
     * @return ApiResponse&lt;CreateAsyncReport200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateAsyncReport200Response> createAsyncReportWithHttpInfo(CreateAsyncReportRequest createAsyncReportRequest) throws ApiException {
        okhttp3.Call localVarCall = createAsyncReportValidateBeforeCall(createAsyncReportRequest, null);
        Type localVarReturnType = new TypeToken<CreateAsyncReport200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an asynchronous report (asynchronously)
     * Request a report on your account activity
     * @param createAsyncReportRequest The parameters of the JSON body will be used to create and filter the report.&lt;br&gt; The value of the &#x60;product&#x60; field will define which product the report will be created for and which parameters are accepted.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createAsyncReportAsync(CreateAsyncReportRequest createAsyncReportRequest, final ApiCallback<CreateAsyncReport200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = createAsyncReportValidateBeforeCall(createAsyncReportRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateAsyncReport200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for downloadReport
     * @param fileId UUID of the file. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Zip file containing CSV files </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call downloadReportCall(String fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v3/media/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/octet-stream",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call downloadReportValidateBeforeCall(String fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling downloadReport(Async)");
        }

        return downloadReportCall(fileId, _callback);

    }

    /**
     * Get report data
     * Download a zipped archive of the rendered report. The file is available for download for 72 hours.&lt;br&gt; The zip file will be named &#x60;&lt;PRODUCT&gt;_&lt;REPORT_ID&gt;.zip&#x60;&lt;br&gt; The csv file in the zip archive will be named as &#x60;report_&lt;PRODUCT&gt;_&lt;ACCOUNT_ID&gt;_&lt;DATE&gt;.csv&#x60; the date will be formatted as &#x60;yyyyMMdd&#x60;. 
     * @param fileId UUID of the file. (required)
     * @return DownloadReport200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Zip file containing CSV files </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public DownloadReport200Response downloadReport(String fileId) throws ApiException {
        ApiResponse<DownloadReport200Response> localVarResp = downloadReportWithHttpInfo(fileId);
        return localVarResp.getData();
    }

    /**
     * Get report data
     * Download a zipped archive of the rendered report. The file is available for download for 72 hours.&lt;br&gt; The zip file will be named &#x60;&lt;PRODUCT&gt;_&lt;REPORT_ID&gt;.zip&#x60;&lt;br&gt; The csv file in the zip archive will be named as &#x60;report_&lt;PRODUCT&gt;_&lt;ACCOUNT_ID&gt;_&lt;DATE&gt;.csv&#x60; the date will be formatted as &#x60;yyyyMMdd&#x60;. 
     * @param fileId UUID of the file. (required)
     * @return ApiResponse&lt;DownloadReport200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Zip file containing CSV files </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DownloadReport200Response> downloadReportWithHttpInfo(String fileId) throws ApiException {
        okhttp3.Call localVarCall = downloadReportValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<DownloadReport200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get report data (asynchronously)
     * Download a zipped archive of the rendered report. The file is available for download for 72 hours.&lt;br&gt; The zip file will be named &#x60;&lt;PRODUCT&gt;_&lt;REPORT_ID&gt;.zip&#x60;&lt;br&gt; The csv file in the zip archive will be named as &#x60;report_&lt;PRODUCT&gt;_&lt;ACCOUNT_ID&gt;_&lt;DATE&gt;.csv&#x60; the date will be formatted as &#x60;yyyyMMdd&#x60;. 
     * @param fileId UUID of the file. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Zip file containing CSV files </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call downloadReportAsync(String fileId, final ApiCallback<DownloadReport200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = downloadReportValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<DownloadReport200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecords
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param product The product to return records for (required)
     * @param direction Direction of the communication, either &#x60;inbound&#x60; (received by our services), or &#x60;outbound&#x60; (originated from our services). Required for products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;. Optional for &#x60;VOICE-CALL&#x60;. Invalid for &#x60;IN-APP-VOICE&#x60;, &#x60;CONVERSATIONS&#x60;, &#x60;NUMBER-INSIGHT&#x60;, &#x60;VERIFY-API&#x60;. (optional)
     * @param id The UUID of the message or call to be searched for. You can specify a comma-separated list of UUIDs. If UUIDs are not found they are listed in the response in the &#x60;ids_not_found&#x60; field.  If you specify &#x60;id&#x60;, you must not specify &#x60;status&#x60;, &#x60;date_start&#x60; or &#x60;date_end&#x60;.  (optional)
     * @param dateStart ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when reports should begin.   It filters on the time the API call was received by Vonage and corresponds to the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the report file. It is inclusive, i.e. the provided value is less than or equal to the value in the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the CDR.  If you provide this, you must provide &#x60;date_end&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param dateEnd **Must be no more than 24 hours later than &#x60;date_start&#x60;**  ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when report should end.  It is exclusive, i.e. the provided value is strictly greater than the value in the field &#x60;date_received&#x60; in the CDR.  If you provide this, you must provide &#x60;date_start&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param includeMessage Include the message contents in the records. Only applicable for use with products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;, where it is optional. (optional, default to false)
     * @param showConcatenated Indicates whether the SMS was split up into multiple parts (due to its length). (optional, default to false)
     * @param status The SMS status to search for. Optional where product is &#x60;SMS&#x60;. (optional, default to none)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unprocessable entity </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordsCall(String accountId, String product, String direction, String id, LocalDate dateStart, LocalDate dateEnd, Boolean includeMessage, Boolean showConcatenated, String status, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/reports/records";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account_id", accountId));
        }

        if (product != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("product", product));
        }

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (id != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id", id));
        }

        if (dateStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_start", dateStart));
        }

        if (dateEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_end", dateEnd));
        }

        if (includeMessage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_message", includeMessage));
        }

        if (showConcatenated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("show_concatenated", showConcatenated));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecordsValidateBeforeCall(String accountId, String product, String direction, String id, LocalDate dateStart, LocalDate dateEnd, Boolean includeMessage, Boolean showConcatenated, String status, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getRecords(Async)");
        }

        // verify the required parameter 'product' is set
        if (product == null) {
            throw new ApiException("Missing the required parameter 'product' when calling getRecords(Async)");
        }

        return getRecordsCall(accountId, product, direction, id, dateStart, dateEnd, includeMessage, showConcatenated, status, _callback);

    }

    /**
     * Load records synchronously
     * Fetch usage data synchronously
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param product The product to return records for (required)
     * @param direction Direction of the communication, either &#x60;inbound&#x60; (received by our services), or &#x60;outbound&#x60; (originated from our services). Required for products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;. Optional for &#x60;VOICE-CALL&#x60;. Invalid for &#x60;IN-APP-VOICE&#x60;, &#x60;CONVERSATIONS&#x60;, &#x60;NUMBER-INSIGHT&#x60;, &#x60;VERIFY-API&#x60;. (optional)
     * @param id The UUID of the message or call to be searched for. You can specify a comma-separated list of UUIDs. If UUIDs are not found they are listed in the response in the &#x60;ids_not_found&#x60; field.  If you specify &#x60;id&#x60;, you must not specify &#x60;status&#x60;, &#x60;date_start&#x60; or &#x60;date_end&#x60;.  (optional)
     * @param dateStart ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when reports should begin.   It filters on the time the API call was received by Vonage and corresponds to the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the report file. It is inclusive, i.e. the provided value is less than or equal to the value in the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the CDR.  If you provide this, you must provide &#x60;date_end&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param dateEnd **Must be no more than 24 hours later than &#x60;date_start&#x60;**  ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when report should end.  It is exclusive, i.e. the provided value is strictly greater than the value in the field &#x60;date_received&#x60; in the CDR.  If you provide this, you must provide &#x60;date_start&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param includeMessage Include the message contents in the records. Only applicable for use with products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;, where it is optional. (optional, default to false)
     * @param showConcatenated Indicates whether the SMS was split up into multiple parts (due to its length). (optional, default to false)
     * @param status The SMS status to search for. Optional where product is &#x60;SMS&#x60;. (optional, default to none)
     * @return GetRecords200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unprocessable entity </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public GetRecords200Response getRecords(String accountId, String product, String direction, String id, LocalDate dateStart, LocalDate dateEnd, Boolean includeMessage, Boolean showConcatenated, String status) throws ApiException {
        ApiResponse<GetRecords200Response> localVarResp = getRecordsWithHttpInfo(accountId, product, direction, id, dateStart, dateEnd, includeMessage, showConcatenated, status);
        return localVarResp.getData();
    }

    /**
     * Load records synchronously
     * Fetch usage data synchronously
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param product The product to return records for (required)
     * @param direction Direction of the communication, either &#x60;inbound&#x60; (received by our services), or &#x60;outbound&#x60; (originated from our services). Required for products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;. Optional for &#x60;VOICE-CALL&#x60;. Invalid for &#x60;IN-APP-VOICE&#x60;, &#x60;CONVERSATIONS&#x60;, &#x60;NUMBER-INSIGHT&#x60;, &#x60;VERIFY-API&#x60;. (optional)
     * @param id The UUID of the message or call to be searched for. You can specify a comma-separated list of UUIDs. If UUIDs are not found they are listed in the response in the &#x60;ids_not_found&#x60; field.  If you specify &#x60;id&#x60;, you must not specify &#x60;status&#x60;, &#x60;date_start&#x60; or &#x60;date_end&#x60;.  (optional)
     * @param dateStart ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when reports should begin.   It filters on the time the API call was received by Vonage and corresponds to the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the report file. It is inclusive, i.e. the provided value is less than or equal to the value in the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the CDR.  If you provide this, you must provide &#x60;date_end&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param dateEnd **Must be no more than 24 hours later than &#x60;date_start&#x60;**  ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when report should end.  It is exclusive, i.e. the provided value is strictly greater than the value in the field &#x60;date_received&#x60; in the CDR.  If you provide this, you must provide &#x60;date_start&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param includeMessage Include the message contents in the records. Only applicable for use with products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;, where it is optional. (optional, default to false)
     * @param showConcatenated Indicates whether the SMS was split up into multiple parts (due to its length). (optional, default to false)
     * @param status The SMS status to search for. Optional where product is &#x60;SMS&#x60;. (optional, default to none)
     * @return ApiResponse&lt;GetRecords200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unprocessable entity </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetRecords200Response> getRecordsWithHttpInfo(String accountId, String product, String direction, String id, LocalDate dateStart, LocalDate dateEnd, Boolean includeMessage, Boolean showConcatenated, String status) throws ApiException {
        okhttp3.Call localVarCall = getRecordsValidateBeforeCall(accountId, product, direction, id, dateStart, dateEnd, includeMessage, showConcatenated, status, null);
        Type localVarReturnType = new TypeToken<GetRecords200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Load records synchronously (asynchronously)
     * Fetch usage data synchronously
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param product The product to return records for (required)
     * @param direction Direction of the communication, either &#x60;inbound&#x60; (received by our services), or &#x60;outbound&#x60; (originated from our services). Required for products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;. Optional for &#x60;VOICE-CALL&#x60;. Invalid for &#x60;IN-APP-VOICE&#x60;, &#x60;CONVERSATIONS&#x60;, &#x60;NUMBER-INSIGHT&#x60;, &#x60;VERIFY-API&#x60;. (optional)
     * @param id The UUID of the message or call to be searched for. You can specify a comma-separated list of UUIDs. If UUIDs are not found they are listed in the response in the &#x60;ids_not_found&#x60; field.  If you specify &#x60;id&#x60;, you must not specify &#x60;status&#x60;, &#x60;date_start&#x60; or &#x60;date_end&#x60;.  (optional)
     * @param dateStart ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when reports should begin.   It filters on the time the API call was received by Vonage and corresponds to the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the report file. It is inclusive, i.e. the provided value is less than or equal to the value in the field &#x60;date_received&#x60; (&#x60;date_start&#x60; for Voice) in the CDR.  If you provide this, you must provide &#x60;date_end&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param dateEnd **Must be no more than 24 hours later than &#x60;date_start&#x60;**  ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date (format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;) for when report should end.  It is exclusive, i.e. the provided value is strictly greater than the value in the field &#x60;date_received&#x60; in the CDR.  If you provide this, you must provide &#x60;date_start&#x60; and must not provide &#x60;id&#x60;.  (optional)
     * @param includeMessage Include the message contents in the records. Only applicable for use with products &#x60;SMS&#x60; and &#x60;MESSAGES&#x60;, where it is optional. (optional, default to false)
     * @param showConcatenated Indicates whether the SMS was split up into multiple parts (due to its length). (optional, default to false)
     * @param status The SMS status to search for. Optional where product is &#x60;SMS&#x60;. (optional, default to none)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unprocessable entity </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordsAsync(String accountId, String product, String direction, String id, LocalDate dateStart, LocalDate dateEnd, Boolean includeMessage, Boolean showConcatenated, String status, final ApiCallback<GetRecords200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecordsValidateBeforeCall(accountId, product, direction, id, dateStart, dateEnd, includeMessage, showConcatenated, status, _callback);
        Type localVarReturnType = new TypeToken<GetRecords200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReport
     * @param reportId UUID of the report request (&#x60;request_id&#x60; in response). (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportCall(String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/reports/{report_id}"
            .replace("{" + "report_id" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReportValidateBeforeCall(String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getReport(Async)");
        }

        return getReportCall(reportId, _callback);

    }

    /**
     * Get status of report
     * Retrieve status and metadata about a requested report.
     * @param reportId UUID of the report request (&#x60;request_id&#x60; in response). (required)
     * @return GetReport200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public GetReport200Response getReport(String reportId) throws ApiException {
        ApiResponse<GetReport200Response> localVarResp = getReportWithHttpInfo(reportId);
        return localVarResp.getData();
    }

    /**
     * Get status of report
     * Retrieve status and metadata about a requested report.
     * @param reportId UUID of the report request (&#x60;request_id&#x60; in response). (required)
     * @return ApiResponse&lt;GetReport200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReport200Response> getReportWithHttpInfo(String reportId) throws ApiException {
        okhttp3.Call localVarCall = getReportValidateBeforeCall(reportId, null);
        Type localVarReturnType = new TypeToken<GetReport200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get status of report (asynchronously)
     * Retrieve status and metadata about a requested report.
     * @param reportId UUID of the report request (&#x60;request_id&#x60; in response). (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportAsync(String reportId, final ApiCallback<GetReport200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReportValidateBeforeCall(reportId, _callback);
        Type localVarReturnType = new TypeToken<GetReport200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listReports
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param status A comma-separated list of report status values. Reports with any of the statuses specified are returned. The values in the comma-seperated list specified for &#x60;status&#x60; can be any of &#x60;PENDING&#x60;, &#x60;PROCESSING&#x60;, &#x60;SUCCESS&#x60;, &#x60;ABORTED&#x60;, &#x60;FAILED&#x60;, &#x60;TRUNCATED&#x60;. (required)
     * @param dateFrom ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date from which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param dateTo ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date until which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listReportsCall(String accountId, String status, LocalDate dateFrom, LocalDate dateTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/reports";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("account_id", accountId));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (dateFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_from", dateFrom));
        }

        if (dateTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_to", dateTo));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listReportsValidateBeforeCall(String accountId, String status, LocalDate dateFrom, LocalDate dateTo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling listReports(Async)");
        }

        // verify the required parameter 'status' is set
        if (status == null) {
            throw new ApiException("Missing the required parameter 'status' when calling listReports(Async)");
        }

        return listReportsCall(accountId, status, dateFrom, dateTo, _callback);

    }

    /**
     * List reports
     * List reports created by the specified account based on filtered provided.
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param status A comma-separated list of report status values. Reports with any of the statuses specified are returned. The values in the comma-seperated list specified for &#x60;status&#x60; can be any of &#x60;PENDING&#x60;, &#x60;PROCESSING&#x60;, &#x60;SUCCESS&#x60;, &#x60;ABORTED&#x60;, &#x60;FAILED&#x60;, &#x60;TRUNCATED&#x60;. (required)
     * @param dateFrom ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date from which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param dateTo ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date until which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @return ListReports200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ListReports200Response listReports(String accountId, String status, LocalDate dateFrom, LocalDate dateTo) throws ApiException {
        ApiResponse<ListReports200Response> localVarResp = listReportsWithHttpInfo(accountId, status, dateFrom, dateTo);
        return localVarResp.getData();
    }

    /**
     * List reports
     * List reports created by the specified account based on filtered provided.
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param status A comma-separated list of report status values. Reports with any of the statuses specified are returned. The values in the comma-seperated list specified for &#x60;status&#x60; can be any of &#x60;PENDING&#x60;, &#x60;PROCESSING&#x60;, &#x60;SUCCESS&#x60;, &#x60;ABORTED&#x60;, &#x60;FAILED&#x60;, &#x60;TRUNCATED&#x60;. (required)
     * @param dateFrom ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date from which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param dateTo ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date until which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @return ApiResponse&lt;ListReports200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ListReports200Response> listReportsWithHttpInfo(String accountId, String status, LocalDate dateFrom, LocalDate dateTo) throws ApiException {
        okhttp3.Call localVarCall = listReportsValidateBeforeCall(accountId, status, dateFrom, dateTo, null);
        Type localVarReturnType = new TypeToken<ListReports200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List reports (asynchronously)
     * List reports created by the specified account based on filtered provided.
     * @param accountId The account for which the list of reports will be queried. (required)
     * @param status A comma-separated list of report status values. Reports with any of the statuses specified are returned. The values in the comma-seperated list specified for &#x60;status&#x60; can be any of &#x60;PENDING&#x60;, &#x60;PROCESSING&#x60;, &#x60;SUCCESS&#x60;, &#x60;ABORTED&#x60;, &#x60;FAILED&#x60;, &#x60;TRUNCATED&#x60;. (required)
     * @param dateFrom ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date from which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param dateTo ISO-8601 extended time zone offset or ISO-8601 UTC zone offset formatted date until which the list of reports will be queried. Format &#x60;yyyy-mm-ddThh:mm:ss[.sss]±hh:mm&#x60; or &#x60;yyyy-mm-ddThh:mm:ss[.sss]Z&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listReportsAsync(String accountId, String status, LocalDate dateFrom, LocalDate dateTo, final ApiCallback<ListReports200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = listReportsValidateBeforeCall(accountId, status, dateFrom, dateTo, _callback);
        Type localVarReturnType = new TypeToken<ListReports200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
