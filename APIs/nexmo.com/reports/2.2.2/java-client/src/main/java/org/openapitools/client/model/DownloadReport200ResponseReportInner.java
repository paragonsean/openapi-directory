/*
 * Reports API
 * The [Reports API](/reports/overview) enables you to request a report of activity for your Vonage account.  Depending on your query pattern, you can choose from one of the two versions of the Reports API: asynchronous and synchronous. The asynchronous version is optimized for infrequent and large data queries (from several records to tens of millions). The synchronous version is optimized for frequent and periodic retrievals of small batches of data records (from one record to tens of thousand per query).  Only synchronous version supports retrival of data records by message/record ID.  Vonage recommends that you limit asynchronous queries to a maximum of 20 million records, by setting the start and end dates accordingly. On average, the asynchronous Reports API takes 5 - 10 minutes to generate 1 million records. 
 *
 * The version of the OpenAPI document: 2.2.2
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.util.Arrays;
import org.openapitools.client.model.AsrStatus;
import org.openapitools.client.model.CsvAsr;
import org.openapitools.client.model.CsvInAppVoice;
import org.openapitools.client.model.CsvMessagesInbound;
import org.openapitools.client.model.CsvMessagesOutbound;
import org.openapitools.client.model.CsvNi;
import org.openapitools.client.model.CsvSmsInbound;
import org.openapitools.client.model.CsvSmsOutbound;
import org.openapitools.client.model.CsvVerify;
import org.openapitools.client.model.CsvVoice;
import org.openapitools.client.model.CsvWebsockets;
import org.openapitools.client.model.Direction;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:24:26.245497-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DownloadReport200ResponseReportInner extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(DownloadReport200ResponseReportInner.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!DownloadReport200ResponseReportInner.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'DownloadReport200ResponseReportInner' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<CsvSmsOutbound> adapterCsvSmsOutbound = gson.getDelegateAdapter(this, TypeToken.get(CsvSmsOutbound.class));
            final TypeAdapter<CsvSmsInbound> adapterCsvSmsInbound = gson.getDelegateAdapter(this, TypeToken.get(CsvSmsInbound.class));
            final TypeAdapter<CsvVoice> adapterCsvVoice = gson.getDelegateAdapter(this, TypeToken.get(CsvVoice.class));
            final TypeAdapter<CsvInAppVoice> adapterCsvInAppVoice = gson.getDelegateAdapter(this, TypeToken.get(CsvInAppVoice.class));
            final TypeAdapter<CsvWebsockets> adapterCsvWebsockets = gson.getDelegateAdapter(this, TypeToken.get(CsvWebsockets.class));
            final TypeAdapter<CsvVerify> adapterCsvVerify = gson.getDelegateAdapter(this, TypeToken.get(CsvVerify.class));
            final TypeAdapter<CsvNi> adapterCsvNi = gson.getDelegateAdapter(this, TypeToken.get(CsvNi.class));
            final TypeAdapter<CsvMessagesOutbound> adapterCsvMessagesOutbound = gson.getDelegateAdapter(this, TypeToken.get(CsvMessagesOutbound.class));
            final TypeAdapter<CsvMessagesInbound> adapterCsvMessagesInbound = gson.getDelegateAdapter(this, TypeToken.get(CsvMessagesInbound.class));
            final TypeAdapter<CsvAsr> adapterCsvAsr = gson.getDelegateAdapter(this, TypeToken.get(CsvAsr.class));

            return (TypeAdapter<T>) new TypeAdapter<DownloadReport200ResponseReportInner>() {
                @Override
                public void write(JsonWriter out, DownloadReport200ResponseReportInner value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `CsvSmsOutbound`
                    if (value.getActualInstance() instanceof CsvSmsOutbound) {
                        JsonElement element = adapterCsvSmsOutbound.toJsonTree((CsvSmsOutbound)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvSmsInbound`
                    if (value.getActualInstance() instanceof CsvSmsInbound) {
                        JsonElement element = adapterCsvSmsInbound.toJsonTree((CsvSmsInbound)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvVoice`
                    if (value.getActualInstance() instanceof CsvVoice) {
                        JsonElement element = adapterCsvVoice.toJsonTree((CsvVoice)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvInAppVoice`
                    if (value.getActualInstance() instanceof CsvInAppVoice) {
                        JsonElement element = adapterCsvInAppVoice.toJsonTree((CsvInAppVoice)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvWebsockets`
                    if (value.getActualInstance() instanceof CsvWebsockets) {
                        JsonElement element = adapterCsvWebsockets.toJsonTree((CsvWebsockets)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvVerify`
                    if (value.getActualInstance() instanceof CsvVerify) {
                        JsonElement element = adapterCsvVerify.toJsonTree((CsvVerify)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvNi`
                    if (value.getActualInstance() instanceof CsvNi) {
                        JsonElement element = adapterCsvNi.toJsonTree((CsvNi)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvMessagesOutbound`
                    if (value.getActualInstance() instanceof CsvMessagesOutbound) {
                        JsonElement element = adapterCsvMessagesOutbound.toJsonTree((CsvMessagesOutbound)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvMessagesInbound`
                    if (value.getActualInstance() instanceof CsvMessagesInbound) {
                        JsonElement element = adapterCsvMessagesInbound.toJsonTree((CsvMessagesInbound)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CsvAsr`
                    if (value.getActualInstance() instanceof CsvAsr) {
                        JsonElement element = adapterCsvAsr.toJsonTree((CsvAsr)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match anyOf schemas: CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets");
                }

                @Override
                public DownloadReport200ResponseReportInner read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize CsvSmsOutbound
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvSmsOutbound.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvSmsOutbound;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvSmsOutbound failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvSmsOutbound'", e);
                    }
                    // deserialize CsvSmsInbound
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvSmsInbound.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvSmsInbound;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvSmsInbound failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvSmsInbound'", e);
                    }
                    // deserialize CsvVoice
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvVoice.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvVoice;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvVoice failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvVoice'", e);
                    }
                    // deserialize CsvInAppVoice
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvInAppVoice.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvInAppVoice;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvInAppVoice failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvInAppVoice'", e);
                    }
                    // deserialize CsvWebsockets
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvWebsockets.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvWebsockets;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvWebsockets failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvWebsockets'", e);
                    }
                    // deserialize CsvVerify
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvVerify.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvVerify;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvVerify failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvVerify'", e);
                    }
                    // deserialize CsvNi
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvNi.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvNi;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvNi failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvNi'", e);
                    }
                    // deserialize CsvMessagesOutbound
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvMessagesOutbound.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvMessagesOutbound;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvMessagesOutbound failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvMessagesOutbound'", e);
                    }
                    // deserialize CsvMessagesInbound
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvMessagesInbound.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvMessagesInbound;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvMessagesInbound failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvMessagesInbound'", e);
                    }
                    // deserialize CsvAsr
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CsvAsr.validateJsonElement(jsonElement);
                        actualAdapter = adapterCsvAsr;
                        DownloadReport200ResponseReportInner ret = new DownloadReport200ResponseReportInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CsvAsr failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CsvAsr'", e);
                    }

                    throw new IOException(String.format("Failed deserialization for DownloadReport200ResponseReportInner: no class matches result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public DownloadReport200ResponseReportInner() {
        super("anyOf", Boolean.FALSE);
    }

    public DownloadReport200ResponseReportInner(Object o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("CsvSmsOutbound", CsvSmsOutbound.class);
        schemas.put("CsvSmsInbound", CsvSmsInbound.class);
        schemas.put("CsvVoice", CsvVoice.class);
        schemas.put("CsvInAppVoice", CsvInAppVoice.class);
        schemas.put("CsvWebsockets", CsvWebsockets.class);
        schemas.put("CsvVerify", CsvVerify.class);
        schemas.put("CsvNi", CsvNi.class);
        schemas.put("CsvMessagesOutbound", CsvMessagesOutbound.class);
        schemas.put("CsvMessagesInbound", CsvMessagesInbound.class);
        schemas.put("CsvAsr", CsvAsr.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return DownloadReport200ResponseReportInner.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets
     *
     * It could be an instance of the 'anyOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof CsvSmsOutbound) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvSmsInbound) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvVoice) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvInAppVoice) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvWebsockets) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvVerify) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvNi) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvMessagesOutbound) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvMessagesInbound) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CsvAsr) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets");
    }

    /**
     * Get the actual instance, which can be the following:
     * CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets
     *
     * @return The actual instance (CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `CsvSmsOutbound`. If the actual instance is not `CsvSmsOutbound`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvSmsOutbound`
     * @throws ClassCastException if the instance is not `CsvSmsOutbound`
     */
    public CsvSmsOutbound getCsvSmsOutbound() throws ClassCastException {
        return (CsvSmsOutbound)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvSmsInbound`. If the actual instance is not `CsvSmsInbound`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvSmsInbound`
     * @throws ClassCastException if the instance is not `CsvSmsInbound`
     */
    public CsvSmsInbound getCsvSmsInbound() throws ClassCastException {
        return (CsvSmsInbound)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvVoice`. If the actual instance is not `CsvVoice`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvVoice`
     * @throws ClassCastException if the instance is not `CsvVoice`
     */
    public CsvVoice getCsvVoice() throws ClassCastException {
        return (CsvVoice)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvInAppVoice`. If the actual instance is not `CsvInAppVoice`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvInAppVoice`
     * @throws ClassCastException if the instance is not `CsvInAppVoice`
     */
    public CsvInAppVoice getCsvInAppVoice() throws ClassCastException {
        return (CsvInAppVoice)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvWebsockets`. If the actual instance is not `CsvWebsockets`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvWebsockets`
     * @throws ClassCastException if the instance is not `CsvWebsockets`
     */
    public CsvWebsockets getCsvWebsockets() throws ClassCastException {
        return (CsvWebsockets)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvVerify`. If the actual instance is not `CsvVerify`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvVerify`
     * @throws ClassCastException if the instance is not `CsvVerify`
     */
    public CsvVerify getCsvVerify() throws ClassCastException {
        return (CsvVerify)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvNi`. If the actual instance is not `CsvNi`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvNi`
     * @throws ClassCastException if the instance is not `CsvNi`
     */
    public CsvNi getCsvNi() throws ClassCastException {
        return (CsvNi)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvMessagesOutbound`. If the actual instance is not `CsvMessagesOutbound`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvMessagesOutbound`
     * @throws ClassCastException if the instance is not `CsvMessagesOutbound`
     */
    public CsvMessagesOutbound getCsvMessagesOutbound() throws ClassCastException {
        return (CsvMessagesOutbound)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvMessagesInbound`. If the actual instance is not `CsvMessagesInbound`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvMessagesInbound`
     * @throws ClassCastException if the instance is not `CsvMessagesInbound`
     */
    public CsvMessagesInbound getCsvMessagesInbound() throws ClassCastException {
        return (CsvMessagesInbound)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CsvAsr`. If the actual instance is not `CsvAsr`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CsvAsr`
     * @throws ClassCastException if the instance is not `CsvAsr`
     */
    public CsvAsr getCsvAsr() throws ClassCastException {
        return (CsvAsr)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to DownloadReport200ResponseReportInner
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate anyOf schemas one by one
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with CsvSmsOutbound
        try {
            CsvSmsOutbound.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvSmsOutbound failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvSmsInbound
        try {
            CsvSmsInbound.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvSmsInbound failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvVoice
        try {
            CsvVoice.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvVoice failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvInAppVoice
        try {
            CsvInAppVoice.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvInAppVoice failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvWebsockets
        try {
            CsvWebsockets.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvWebsockets failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvVerify
        try {
            CsvVerify.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvVerify failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvNi
        try {
            CsvNi.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvNi failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvMessagesOutbound
        try {
            CsvMessagesOutbound.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvMessagesOutbound failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvMessagesInbound
        try {
            CsvMessagesInbound.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvMessagesInbound failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CsvAsr
        try {
            CsvAsr.validateJsonElement(jsonElement);
            return;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CsvAsr failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        throw new IOException(String.format("The JSON string is invalid for DownloadReport200ResponseReportInner with anyOf schemas: CsvAsr, CsvInAppVoice, CsvMessagesInbound, CsvMessagesOutbound, CsvNi, CsvSmsInbound, CsvSmsOutbound, CsvVerify, CsvVoice, CsvWebsockets. no class match the result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
    }

    /**
     * Create an instance of DownloadReport200ResponseReportInner given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of DownloadReport200ResponseReportInner
     * @throws IOException if the JSON string is invalid with respect to DownloadReport200ResponseReportInner
     */
    public static DownloadReport200ResponseReportInner fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, DownloadReport200ResponseReportInner.class);
    }

    /**
     * Convert an instance of DownloadReport200ResponseReportInner to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

