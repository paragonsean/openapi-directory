/*
 * Number Insight API
 * The Number Insight API delivers real-time intelligence about the validity, reachability and roaming status of a phone number and tells you how to format the number correctly in your application. There are three levels of Number Insight API available: [Basic, Standard and Advanced](https://developer.nexmo.com/number-insight/overview#basic-standard-and-advanced-apis). The advanced API is available asynchronously as well as synchronously.
 *
 * The version of the OpenAPI document: 1.2.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.NiCurrentCarrierProperties;
import org.openapitools.client.model.NiInitialCarrierProperties;
import org.openapitools.client.model.NiResponseXmlAdvancedCallerIdentity;
import org.openapitools.client.model.NiResponseXmlAdvancedError;
import org.openapitools.client.model.NiResponseXmlAdvancedLocalNumber;
import org.openapitools.client.model.NiResponseXmlAdvancedLookupOutcome;
import org.openapitools.client.model.NiResponseXmlAdvancedPorted;
import org.openapitools.client.model.NiRoaming;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Advanced
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:24:38.176849-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NiResponseXmlAdvanced {
  public static final String SERIALIZED_NAME_CALLER_IDENTITY = "caller_identity";
  @SerializedName(SERIALIZED_NAME_CALLER_IDENTITY)
  private NiResponseXmlAdvancedCallerIdentity callerIdentity;

  public static final String SERIALIZED_NAME_CALLER_NAME = "caller_name";
  @SerializedName(SERIALIZED_NAME_CALLER_NAME)
  private String callerName;

  /**
   * The value will be &#x60;business&#x60; if the owner of a phone number is a business. If the owner is an individual the value will be &#x60;consumer&#x60;. The value will be &#x60;unknown&#x60; if this information is not available. This parameter is only present if &#x60;cnam&#x60; had a value of &#x60;true&#x60; within the request.
   */
  @JsonAdapter(CallerTypeEnum.Adapter.class)
  public enum CallerTypeEnum {
    BUSINESS("business"),
    
    CONSUMER("consumer"),
    
    UNKNOWN("unknown");

    private String value;

    CallerTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CallerTypeEnum fromValue(String value) {
      for (CallerTypeEnum b : CallerTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CallerTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CallerTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CallerTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CallerTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CallerTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CALLER_TYPE = "caller_type";
  @SerializedName(SERIALIZED_NAME_CALLER_TYPE)
  private CallerTypeEnum callerType;

  public static final String SERIALIZED_NAME_CURRENT_CARRIER = "current_carrier";
  @SerializedName(SERIALIZED_NAME_CURRENT_CARRIER)
  private NiCurrentCarrierProperties currentCarrier;

  public static final String SERIALIZED_NAME_ERROR = "error";
  @SerializedName(SERIALIZED_NAME_ERROR)
  private NiResponseXmlAdvancedError error;

  public static final String SERIALIZED_NAME_FIRS_NAME = "firs_name";
  @SerializedName(SERIALIZED_NAME_FIRS_NAME)
  private String firsName;

  public static final String SERIALIZED_NAME_INTERNATIONAL_FORMAT_NUMBER = "international_format_number";
  @SerializedName(SERIALIZED_NAME_INTERNATIONAL_FORMAT_NUMBER)
  private String internationalFormatNumber;

  public static final String SERIALIZED_NAME_IP_WARNINGS = "ip_warnings";
  @SerializedName(SERIALIZED_NAME_IP_WARNINGS)
  private String ipWarnings;

  public static final String SERIALIZED_NAME_LAST_NAME = "last_name";
  @SerializedName(SERIALIZED_NAME_LAST_NAME)
  private String lastName;

  public static final String SERIALIZED_NAME_LOCAL_NUMBER = "local_number";
  @SerializedName(SERIALIZED_NAME_LOCAL_NUMBER)
  private NiResponseXmlAdvancedLocalNumber localNumber;

  public static final String SERIALIZED_NAME_LOOKUP_OUTCOME = "lookup_outcome";
  @SerializedName(SERIALIZED_NAME_LOOKUP_OUTCOME)
  private NiResponseXmlAdvancedLookupOutcome lookupOutcome;

  public static final String SERIALIZED_NAME_ORIGINAL_CARRIER = "original_carrier";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_CARRIER)
  private NiInitialCarrierProperties originalCarrier;

  public static final String SERIALIZED_NAME_PORTED = "ported";
  @SerializedName(SERIALIZED_NAME_PORTED)
  private NiResponseXmlAdvancedPorted ported;

  /**
   * Can you call &#x60;number&#x60; now. This is applicable to mobile numbers only.
   */
  @JsonAdapter(ReachableEnum.Adapter.class)
  public enum ReachableEnum {
    UNKNOWN("unknown"),
    
    REACHABLE("reachable"),
    
    UNDELIVERABLE("undeliverable"),
    
    ABSENT("absent"),
    
    BAD_NUMBER("bad_number"),
    
    BLACKLISTED("blacklisted"),
    
    NULL("null");

    private String value;

    ReachableEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReachableEnum fromValue(String value) {
      for (ReachableEnum b : ReachableEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ReachableEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReachableEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReachableEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReachableEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReachableEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REACHABLE = "reachable";
  @SerializedName(SERIALIZED_NAME_REACHABLE)
  private ReachableEnum reachable;

  public static final String SERIALIZED_NAME_REMAINING_BALANCE = "remaining_balance";
  @SerializedName(SERIALIZED_NAME_REMAINING_BALANCE)
  private String remainingBalance;

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_REQUEST_PRICE = "request_price";
  @SerializedName(SERIALIZED_NAME_REQUEST_PRICE)
  private String requestPrice;

  public static final String SERIALIZED_NAME_ROAMING = "roaming";
  @SerializedName(SERIALIZED_NAME_ROAMING)
  private NiRoaming roaming;

  /**
   * Does &#x60;number&#x60; exist. &#x60;unknown&#x60; means the number could not be validated. &#x60;valid&#x60; means the number is valid. &#x60;not_valid&#x60; means the number is not valid. &#x60;inferred_not_valid&#x60; means that the number could not be determined as valid or invalid via an external system and the best guess is that the number is invalid. This is applicable to mobile numbers only.
   */
  @JsonAdapter(ValidNumberEnum.Adapter.class)
  public enum ValidNumberEnum {
    UNKNOWN("unknown"),
    
    VALID("valid"),
    
    NOT_VALID("not_valid"),
    
    INFERRED_NOT_VALID("inferred_not_valid");

    private String value;

    ValidNumberEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValidNumberEnum fromValue(String value) {
      for (ValidNumberEnum b : ValidNumberEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValidNumberEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValidNumberEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValidNumberEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValidNumberEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValidNumberEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALID_NUMBER = "valid_number";
  @SerializedName(SERIALIZED_NAME_VALID_NUMBER)
  private ValidNumberEnum validNumber;

  public NiResponseXmlAdvanced() {
  }

  public NiResponseXmlAdvanced callerIdentity(NiResponseXmlAdvancedCallerIdentity callerIdentity) {
    this.callerIdentity = callerIdentity;
    return this;
  }

  /**
   * Get callerIdentity
   * @return callerIdentity
   */
  @javax.annotation.Nullable
  public NiResponseXmlAdvancedCallerIdentity getCallerIdentity() {
    return callerIdentity;
  }

  public void setCallerIdentity(NiResponseXmlAdvancedCallerIdentity callerIdentity) {
    this.callerIdentity = callerIdentity;
  }


  public NiResponseXmlAdvanced callerName(String callerName) {
    this.callerName = callerName;
    return this;
  }

  /**
   * Full name of the person or business who owns the phone number. &#x60;unknown&#x60; if this information is not available. This parameter is only present if &#x60;cnam&#x60; had a value of &#x60;true&#x60; within the request.
   * @return callerName
   */
  @javax.annotation.Nullable
  public String getCallerName() {
    return callerName;
  }

  public void setCallerName(String callerName) {
    this.callerName = callerName;
  }


  public NiResponseXmlAdvanced callerType(CallerTypeEnum callerType) {
    this.callerType = callerType;
    return this;
  }

  /**
   * The value will be &#x60;business&#x60; if the owner of a phone number is a business. If the owner is an individual the value will be &#x60;consumer&#x60;. The value will be &#x60;unknown&#x60; if this information is not available. This parameter is only present if &#x60;cnam&#x60; had a value of &#x60;true&#x60; within the request.
   * @return callerType
   */
  @javax.annotation.Nullable
  public CallerTypeEnum getCallerType() {
    return callerType;
  }

  public void setCallerType(CallerTypeEnum callerType) {
    this.callerType = callerType;
  }


  public NiResponseXmlAdvanced currentCarrier(NiCurrentCarrierProperties currentCarrier) {
    this.currentCarrier = currentCarrier;
    return this;
  }

  /**
   * Get currentCarrier
   * @return currentCarrier
   */
  @javax.annotation.Nullable
  public NiCurrentCarrierProperties getCurrentCarrier() {
    return currentCarrier;
  }

  public void setCurrentCarrier(NiCurrentCarrierProperties currentCarrier) {
    this.currentCarrier = currentCarrier;
  }


  public NiResponseXmlAdvanced error(NiResponseXmlAdvancedError error) {
    this.error = error;
    return this;
  }

  /**
   * Get error
   * @return error
   */
  @javax.annotation.Nullable
  public NiResponseXmlAdvancedError getError() {
    return error;
  }

  public void setError(NiResponseXmlAdvancedError error) {
    this.error = error;
  }


  public NiResponseXmlAdvanced firsName(String firsName) {
    this.firsName = firsName;
    return this;
  }

  /**
   * First name of the person who owns the phone number if the owner is an individual. This parameter is only present if &#x60;cnam&#x60; had a value of &#x60;true&#x60; within the request.
   * @return firsName
   */
  @javax.annotation.Nullable
  public String getFirsName() {
    return firsName;
  }

  public void setFirsName(String firsName) {
    this.firsName = firsName;
  }


  public NiResponseXmlAdvanced internationalFormatNumber(String internationalFormatNumber) {
    this.internationalFormatNumber = internationalFormatNumber;
    return this;
  }

  /**
   * The &#x60;number&#x60; in your request in international format.
   * @return internationalFormatNumber
   */
  @javax.annotation.Nullable
  public String getInternationalFormatNumber() {
    return internationalFormatNumber;
  }

  public void setInternationalFormatNumber(String internationalFormatNumber) {
    this.internationalFormatNumber = internationalFormatNumber;
  }


  public NiResponseXmlAdvanced ipWarnings(String ipWarnings) {
    this.ipWarnings = ipWarnings;
    return this;
  }

  /**
   * This property is deprecated and can safely be ignored.
   * @return ipWarnings
   */
  @javax.annotation.Nullable
  public String getIpWarnings() {
    return ipWarnings;
  }

  public void setIpWarnings(String ipWarnings) {
    this.ipWarnings = ipWarnings;
  }


  public NiResponseXmlAdvanced lastName(String lastName) {
    this.lastName = lastName;
    return this;
  }

  /**
   * Last name of the person who owns the phone number if the owner is an individual. This parameter is only present if &#x60;cnam&#x60; had a value of &#x60;true&#x60; within the request.
   * @return lastName
   */
  @javax.annotation.Nullable
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }


  public NiResponseXmlAdvanced localNumber(NiResponseXmlAdvancedLocalNumber localNumber) {
    this.localNumber = localNumber;
    return this;
  }

  /**
   * Get localNumber
   * @return localNumber
   */
  @javax.annotation.Nullable
  public NiResponseXmlAdvancedLocalNumber getLocalNumber() {
    return localNumber;
  }

  public void setLocalNumber(NiResponseXmlAdvancedLocalNumber localNumber) {
    this.localNumber = localNumber;
  }


  public NiResponseXmlAdvanced lookupOutcome(NiResponseXmlAdvancedLookupOutcome lookupOutcome) {
    this.lookupOutcome = lookupOutcome;
    return this;
  }

  /**
   * Get lookupOutcome
   * @return lookupOutcome
   */
  @javax.annotation.Nullable
  public NiResponseXmlAdvancedLookupOutcome getLookupOutcome() {
    return lookupOutcome;
  }

  public void setLookupOutcome(NiResponseXmlAdvancedLookupOutcome lookupOutcome) {
    this.lookupOutcome = lookupOutcome;
  }


  public NiResponseXmlAdvanced originalCarrier(NiInitialCarrierProperties originalCarrier) {
    this.originalCarrier = originalCarrier;
    return this;
  }

  /**
   * Get originalCarrier
   * @return originalCarrier
   */
  @javax.annotation.Nullable
  public NiInitialCarrierProperties getOriginalCarrier() {
    return originalCarrier;
  }

  public void setOriginalCarrier(NiInitialCarrierProperties originalCarrier) {
    this.originalCarrier = originalCarrier;
  }


  public NiResponseXmlAdvanced ported(NiResponseXmlAdvancedPorted ported) {
    this.ported = ported;
    return this;
  }

  /**
   * Get ported
   * @return ported
   */
  @javax.annotation.Nullable
  public NiResponseXmlAdvancedPorted getPorted() {
    return ported;
  }

  public void setPorted(NiResponseXmlAdvancedPorted ported) {
    this.ported = ported;
  }


  public NiResponseXmlAdvanced reachable(ReachableEnum reachable) {
    this.reachable = reachable;
    return this;
  }

  /**
   * Can you call &#x60;number&#x60; now. This is applicable to mobile numbers only.
   * @return reachable
   */
  @javax.annotation.Nullable
  public ReachableEnum getReachable() {
    return reachable;
  }

  public void setReachable(ReachableEnum reachable) {
    this.reachable = reachable;
  }


  public NiResponseXmlAdvanced remainingBalance(String remainingBalance) {
    this.remainingBalance = remainingBalance;
    return this;
  }

  /**
   * Your account balance in EUR after this request.
   * @return remainingBalance
   */
  @javax.annotation.Nullable
  public String getRemainingBalance() {
    return remainingBalance;
  }

  public void setRemainingBalance(String remainingBalance) {
    this.remainingBalance = remainingBalance;
  }


  public NiResponseXmlAdvanced requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

  /**
   * The unique identifier for your request. This is a alphanumeric string up to 40 characters.
   * @return requestId
   */
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public NiResponseXmlAdvanced requestPrice(String requestPrice) {
    this.requestPrice = requestPrice;
    return this;
  }

  /**
   * If there is an internal lookup error, the &#x60;refund_price&#x60; will reflect the lookup price. If &#x60;cnam&#x60; is requested for a non-US number the &#x60;refund_price&#x60; will reflect the &#x60;cnam&#x60; price. If both of these conditions occur, &#x60;refund_price&#x60; is the sum of the lookup price and &#x60;cnam&#x60; price.
   * @return requestPrice
   */
  @javax.annotation.Nullable
  public String getRequestPrice() {
    return requestPrice;
  }

  public void setRequestPrice(String requestPrice) {
    this.requestPrice = requestPrice;
  }


  public NiResponseXmlAdvanced roaming(NiRoaming roaming) {
    this.roaming = roaming;
    return this;
  }

  /**
   * Get roaming
   * @return roaming
   */
  @javax.annotation.Nullable
  public NiRoaming getRoaming() {
    return roaming;
  }

  public void setRoaming(NiRoaming roaming) {
    this.roaming = roaming;
  }


  public NiResponseXmlAdvanced validNumber(ValidNumberEnum validNumber) {
    this.validNumber = validNumber;
    return this;
  }

  /**
   * Does &#x60;number&#x60; exist. &#x60;unknown&#x60; means the number could not be validated. &#x60;valid&#x60; means the number is valid. &#x60;not_valid&#x60; means the number is not valid. &#x60;inferred_not_valid&#x60; means that the number could not be determined as valid or invalid via an external system and the best guess is that the number is invalid. This is applicable to mobile numbers only.
   * @return validNumber
   */
  @javax.annotation.Nullable
  public ValidNumberEnum getValidNumber() {
    return validNumber;
  }

  public void setValidNumber(ValidNumberEnum validNumber) {
    this.validNumber = validNumber;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NiResponseXmlAdvanced niResponseXmlAdvanced = (NiResponseXmlAdvanced) o;
    return Objects.equals(this.callerIdentity, niResponseXmlAdvanced.callerIdentity) &&
        Objects.equals(this.callerName, niResponseXmlAdvanced.callerName) &&
        Objects.equals(this.callerType, niResponseXmlAdvanced.callerType) &&
        Objects.equals(this.currentCarrier, niResponseXmlAdvanced.currentCarrier) &&
        Objects.equals(this.error, niResponseXmlAdvanced.error) &&
        Objects.equals(this.firsName, niResponseXmlAdvanced.firsName) &&
        Objects.equals(this.internationalFormatNumber, niResponseXmlAdvanced.internationalFormatNumber) &&
        Objects.equals(this.ipWarnings, niResponseXmlAdvanced.ipWarnings) &&
        Objects.equals(this.lastName, niResponseXmlAdvanced.lastName) &&
        Objects.equals(this.localNumber, niResponseXmlAdvanced.localNumber) &&
        Objects.equals(this.lookupOutcome, niResponseXmlAdvanced.lookupOutcome) &&
        Objects.equals(this.originalCarrier, niResponseXmlAdvanced.originalCarrier) &&
        Objects.equals(this.ported, niResponseXmlAdvanced.ported) &&
        Objects.equals(this.reachable, niResponseXmlAdvanced.reachable) &&
        Objects.equals(this.remainingBalance, niResponseXmlAdvanced.remainingBalance) &&
        Objects.equals(this.requestId, niResponseXmlAdvanced.requestId) &&
        Objects.equals(this.requestPrice, niResponseXmlAdvanced.requestPrice) &&
        Objects.equals(this.roaming, niResponseXmlAdvanced.roaming) &&
        Objects.equals(this.validNumber, niResponseXmlAdvanced.validNumber);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(callerIdentity, callerName, callerType, currentCarrier, error, firsName, internationalFormatNumber, ipWarnings, lastName, localNumber, lookupOutcome, originalCarrier, ported, reachable, remainingBalance, requestId, requestPrice, roaming, validNumber);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NiResponseXmlAdvanced {\n");
    sb.append("    callerIdentity: ").append(toIndentedString(callerIdentity)).append("\n");
    sb.append("    callerName: ").append(toIndentedString(callerName)).append("\n");
    sb.append("    callerType: ").append(toIndentedString(callerType)).append("\n");
    sb.append("    currentCarrier: ").append(toIndentedString(currentCarrier)).append("\n");
    sb.append("    error: ").append(toIndentedString(error)).append("\n");
    sb.append("    firsName: ").append(toIndentedString(firsName)).append("\n");
    sb.append("    internationalFormatNumber: ").append(toIndentedString(internationalFormatNumber)).append("\n");
    sb.append("    ipWarnings: ").append(toIndentedString(ipWarnings)).append("\n");
    sb.append("    lastName: ").append(toIndentedString(lastName)).append("\n");
    sb.append("    localNumber: ").append(toIndentedString(localNumber)).append("\n");
    sb.append("    lookupOutcome: ").append(toIndentedString(lookupOutcome)).append("\n");
    sb.append("    originalCarrier: ").append(toIndentedString(originalCarrier)).append("\n");
    sb.append("    ported: ").append(toIndentedString(ported)).append("\n");
    sb.append("    reachable: ").append(toIndentedString(reachable)).append("\n");
    sb.append("    remainingBalance: ").append(toIndentedString(remainingBalance)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    requestPrice: ").append(toIndentedString(requestPrice)).append("\n");
    sb.append("    roaming: ").append(toIndentedString(roaming)).append("\n");
    sb.append("    validNumber: ").append(toIndentedString(validNumber)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("caller_identity");
    openapiFields.add("caller_name");
    openapiFields.add("caller_type");
    openapiFields.add("current_carrier");
    openapiFields.add("error");
    openapiFields.add("firs_name");
    openapiFields.add("international_format_number");
    openapiFields.add("ip_warnings");
    openapiFields.add("last_name");
    openapiFields.add("local_number");
    openapiFields.add("lookup_outcome");
    openapiFields.add("original_carrier");
    openapiFields.add("ported");
    openapiFields.add("reachable");
    openapiFields.add("remaining_balance");
    openapiFields.add("request_id");
    openapiFields.add("request_price");
    openapiFields.add("roaming");
    openapiFields.add("valid_number");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NiResponseXmlAdvanced
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NiResponseXmlAdvanced.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NiResponseXmlAdvanced is not found in the empty JSON string", NiResponseXmlAdvanced.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NiResponseXmlAdvanced.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NiResponseXmlAdvanced` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `caller_identity`
      if (jsonObj.get("caller_identity") != null && !jsonObj.get("caller_identity").isJsonNull()) {
        NiResponseXmlAdvancedCallerIdentity.validateJsonElement(jsonObj.get("caller_identity"));
      }
      if ((jsonObj.get("caller_name") != null && !jsonObj.get("caller_name").isJsonNull()) && !jsonObj.get("caller_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `caller_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("caller_name").toString()));
      }
      if ((jsonObj.get("caller_type") != null && !jsonObj.get("caller_type").isJsonNull()) && !jsonObj.get("caller_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `caller_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("caller_type").toString()));
      }
      // validate the optional field `caller_type`
      if (jsonObj.get("caller_type") != null && !jsonObj.get("caller_type").isJsonNull()) {
        CallerTypeEnum.validateJsonElement(jsonObj.get("caller_type"));
      }
      // validate the optional field `current_carrier`
      if (jsonObj.get("current_carrier") != null && !jsonObj.get("current_carrier").isJsonNull()) {
        NiCurrentCarrierProperties.validateJsonElement(jsonObj.get("current_carrier"));
      }
      // validate the optional field `error`
      if (jsonObj.get("error") != null && !jsonObj.get("error").isJsonNull()) {
        NiResponseXmlAdvancedError.validateJsonElement(jsonObj.get("error"));
      }
      if ((jsonObj.get("firs_name") != null && !jsonObj.get("firs_name").isJsonNull()) && !jsonObj.get("firs_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `firs_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("firs_name").toString()));
      }
      if ((jsonObj.get("international_format_number") != null && !jsonObj.get("international_format_number").isJsonNull()) && !jsonObj.get("international_format_number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `international_format_number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("international_format_number").toString()));
      }
      if ((jsonObj.get("ip_warnings") != null && !jsonObj.get("ip_warnings").isJsonNull()) && !jsonObj.get("ip_warnings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ip_warnings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ip_warnings").toString()));
      }
      if ((jsonObj.get("last_name") != null && !jsonObj.get("last_name").isJsonNull()) && !jsonObj.get("last_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `last_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("last_name").toString()));
      }
      // validate the optional field `local_number`
      if (jsonObj.get("local_number") != null && !jsonObj.get("local_number").isJsonNull()) {
        NiResponseXmlAdvancedLocalNumber.validateJsonElement(jsonObj.get("local_number"));
      }
      // validate the optional field `lookup_outcome`
      if (jsonObj.get("lookup_outcome") != null && !jsonObj.get("lookup_outcome").isJsonNull()) {
        NiResponseXmlAdvancedLookupOutcome.validateJsonElement(jsonObj.get("lookup_outcome"));
      }
      // validate the optional field `original_carrier`
      if (jsonObj.get("original_carrier") != null && !jsonObj.get("original_carrier").isJsonNull()) {
        NiInitialCarrierProperties.validateJsonElement(jsonObj.get("original_carrier"));
      }
      // validate the optional field `ported`
      if (jsonObj.get("ported") != null && !jsonObj.get("ported").isJsonNull()) {
        NiResponseXmlAdvancedPorted.validateJsonElement(jsonObj.get("ported"));
      }
      if ((jsonObj.get("reachable") != null && !jsonObj.get("reachable").isJsonNull()) && !jsonObj.get("reachable").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reachable` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reachable").toString()));
      }
      // validate the optional field `reachable`
      if (jsonObj.get("reachable") != null && !jsonObj.get("reachable").isJsonNull()) {
        ReachableEnum.validateJsonElement(jsonObj.get("reachable"));
      }
      if ((jsonObj.get("remaining_balance") != null && !jsonObj.get("remaining_balance").isJsonNull()) && !jsonObj.get("remaining_balance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `remaining_balance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("remaining_balance").toString()));
      }
      if ((jsonObj.get("request_id") != null && !jsonObj.get("request_id").isJsonNull()) && !jsonObj.get("request_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_id").toString()));
      }
      if ((jsonObj.get("request_price") != null && !jsonObj.get("request_price").isJsonNull()) && !jsonObj.get("request_price").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_price` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_price").toString()));
      }
      // validate the optional field `roaming`
      if (jsonObj.get("roaming") != null && !jsonObj.get("roaming").isJsonNull()) {
        NiRoaming.validateJsonElement(jsonObj.get("roaming"));
      }
      if ((jsonObj.get("valid_number") != null && !jsonObj.get("valid_number").isJsonNull()) && !jsonObj.get("valid_number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valid_number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valid_number").toString()));
      }
      // validate the optional field `valid_number`
      if (jsonObj.get("valid_number") != null && !jsonObj.get("valid_number").isJsonNull()) {
        ValidNumberEnum.validateJsonElement(jsonObj.get("valid_number"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NiResponseXmlAdvanced.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NiResponseXmlAdvanced' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NiResponseXmlAdvanced> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NiResponseXmlAdvanced.class));

       return (TypeAdapter<T>) new TypeAdapter<NiResponseXmlAdvanced>() {
           @Override
           public void write(JsonWriter out, NiResponseXmlAdvanced value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NiResponseXmlAdvanced read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NiResponseXmlAdvanced given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NiResponseXmlAdvanced
   * @throws IOException if the JSON string is invalid with respect to NiResponseXmlAdvanced
   */
  public static NiResponseXmlAdvanced fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NiResponseXmlAdvanced.class);
  }

  /**
   * Convert an instance of NiResponseXmlAdvanced to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

