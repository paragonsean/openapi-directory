/*
 * Verify API
 * The Verify API helps you to implement 2FA (two-factor authentication) in your applications. This is useful for:  * Protecting against spam, by preventing spammers from creating multiple accounts * Monitoring suspicious activity, by forcing an account user to verify ownership of a number * Ensuring that you can reach your users at any time because you have their correct phone number More information is available at <https://developer.nexmo.com/verify>
 *
 * The version of the OpenAPI document: 1.2.4
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.SearchResponseChecksInner;
import org.openapitools.client.model.SearchResponseEventsInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Success
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:24:35.456692-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SearchResponse {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "account_id";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private String accountId;

  public static final String SERIALIZED_NAME_CHECKS = "checks";
  @SerializedName(SERIALIZED_NAME_CHECKS)
  private List<SearchResponseChecksInner> checks = new ArrayList<>();

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_DATE_FINALIZED = "date_finalized";
  @SerializedName(SERIALIZED_NAME_DATE_FINALIZED)
  private String dateFinalized;

  public static final String SERIALIZED_NAME_DATE_SUBMITTED = "date_submitted";
  @SerializedName(SERIALIZED_NAME_DATE_SUBMITTED)
  private String dateSubmitted;

  public static final String SERIALIZED_NAME_ESTIMATED_PRICE_MESSAGES_SENT = "estimated_price_messages_sent";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_PRICE_MESSAGES_SENT)
  private String estimatedPriceMessagesSent;

  public static final String SERIALIZED_NAME_EVENTS = "events";
  @SerializedName(SERIALIZED_NAME_EVENTS)
  private List<SearchResponseEventsInner> events = new ArrayList<>();

  public static final String SERIALIZED_NAME_FIRST_EVENT_DATE = "first_event_date";
  @SerializedName(SERIALIZED_NAME_FIRST_EVENT_DATE)
  private String firstEventDate;

  public static final String SERIALIZED_NAME_LAST_EVENT_DATE = "last_event_date";
  @SerializedName(SERIALIZED_NAME_LAST_EVENT_DATE)
  private String lastEventDate;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private String number;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  private String price;

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_SENDER_ID = "sender_id";
  @SerializedName(SERIALIZED_NAME_SENDER_ID)
  private String senderId = "verify";

  /**
   * Code | Description -- | -- IN PROGRESS | The search is still in progress. SUCCESS | Your user entered a correct verification code. FAILED | Your user entered an incorrect code more than three times. EXPIRED | Your user did not enter a code before the &#x60;pin_expiry&#x60; time elapsed. CANCELLED | The verification process was cancelled by a Verify control request. 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    IN_PROGRESS("IN PROGRESS"),
    
    SUCCESS("SUCCESS"),
    
    FAILED("FAILED"),
    
    EXPIRED("EXPIRED"),
    
    CANCELLED("CANCELLED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public SearchResponse() {
  }

  public SearchResponse accountId(String accountId) {
    this.accountId = accountId;
    return this;
  }

  /**
   * The Vonage account ID the request was for.
   * @return accountId
   */
  @javax.annotation.Nullable
  public String getAccountId() {
    return accountId;
  }

  public void setAccountId(String accountId) {
    this.accountId = accountId;
  }


  public SearchResponse checks(List<SearchResponseChecksInner> checks) {
    this.checks = checks;
    return this;
  }

  public SearchResponse addChecksItem(SearchResponseChecksInner checksItem) {
    if (this.checks == null) {
      this.checks = new ArrayList<>();
    }
    this.checks.add(checksItem);
    return this;
  }

  /**
   * The list of checks made for this verification and their outcomes.
   * @return checks
   */
  @javax.annotation.Nullable
  public List<SearchResponseChecksInner> getChecks() {
    return checks;
  }

  public void setChecks(List<SearchResponseChecksInner> checks) {
    this.checks = checks;
  }


  public SearchResponse currency(String currency) {
    this.currency = currency;
    return this;
  }

  /**
   * The currency code.
   * @return currency
   */
  @javax.annotation.Nullable
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public SearchResponse dateFinalized(String dateFinalized) {
    this.dateFinalized = dateFinalized;
    return this;
  }

  /**
   * The date and time the verification request was completed. This response parameter is in the following format YYYY-MM-DD HH:MM:SS.
   * @return dateFinalized
   */
  @javax.annotation.Nullable
  public String getDateFinalized() {
    return dateFinalized;
  }

  public void setDateFinalized(String dateFinalized) {
    this.dateFinalized = dateFinalized;
  }


  public SearchResponse dateSubmitted(String dateSubmitted) {
    this.dateSubmitted = dateSubmitted;
    return this;
  }

  /**
   * The date and time the verification request was submitted, in the following format YYYY-MM-DD HH:MM:SS.
   * @return dateSubmitted
   */
  @javax.annotation.Nullable
  public String getDateSubmitted() {
    return dateSubmitted;
  }

  public void setDateSubmitted(String dateSubmitted) {
    this.dateSubmitted = dateSubmitted;
  }


  public SearchResponse estimatedPriceMessagesSent(String estimatedPriceMessagesSent) {
    this.estimatedPriceMessagesSent = estimatedPriceMessagesSent;
    return this;
  }

  /**
   * This field may not be present, depending on your pricing model. The value indicates the cost (in EUR) of the calls made and messages sent for the verification process. This value may be updated during and shortly after the request completes because user input events can overlap with message/call events. When this field is present, the total cost of the verification is the sum of this field and the &#x60;price&#x60; field. 
   * @return estimatedPriceMessagesSent
   */
  @javax.annotation.Nullable
  public String getEstimatedPriceMessagesSent() {
    return estimatedPriceMessagesSent;
  }

  public void setEstimatedPriceMessagesSent(String estimatedPriceMessagesSent) {
    this.estimatedPriceMessagesSent = estimatedPriceMessagesSent;
  }


  public SearchResponse events(List<SearchResponseEventsInner> events) {
    this.events = events;
    return this;
  }

  public SearchResponse addEventsItem(SearchResponseEventsInner eventsItem) {
    if (this.events == null) {
      this.events = new ArrayList<>();
    }
    this.events.add(eventsItem);
    return this;
  }

  /**
   * The events that have taken place to verify this number, and their unique identifiers.
   * @return events
   */
  @javax.annotation.Nullable
  public List<SearchResponseEventsInner> getEvents() {
    return events;
  }

  public void setEvents(List<SearchResponseEventsInner> events) {
    this.events = events;
  }


  public SearchResponse firstEventDate(String firstEventDate) {
    this.firstEventDate = firstEventDate;
    return this;
  }

  /**
   * The time the first verification attempt was made, in the following format YYYY-MM-DD HH:MM:SS.
   * @return firstEventDate
   */
  @javax.annotation.Nullable
  public String getFirstEventDate() {
    return firstEventDate;
  }

  public void setFirstEventDate(String firstEventDate) {
    this.firstEventDate = firstEventDate;
  }


  public SearchResponse lastEventDate(String lastEventDate) {
    this.lastEventDate = lastEventDate;
    return this;
  }

  /**
   * The time the last verification attempt was made, in the following format YYYY-MM-DD HH:MM:SS.
   * @return lastEventDate
   */
  @javax.annotation.Nullable
  public String getLastEventDate() {
    return lastEventDate;
  }

  public void setLastEventDate(String lastEventDate) {
    this.lastEventDate = lastEventDate;
  }


  public SearchResponse number(String number) {
    this.number = number;
    return this;
  }

  /**
   * The phone number this verification request was used for.
   * @return number
   */
  @javax.annotation.Nullable
  public String getNumber() {
    return number;
  }

  public void setNumber(String number) {
    this.number = number;
  }


  public SearchResponse price(String price) {
    this.price = price;
    return this;
  }

  /**
   * The cost incurred for this verification request.
   * @return price
   */
  @javax.annotation.Nullable
  public String getPrice() {
    return price;
  }

  public void setPrice(String price) {
    this.price = price;
  }


  public SearchResponse requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

  /**
   * The &#x60;request_id&#x60; that you received in the response to the Verify request and used in the Verify search request.
   * @return requestId
   */
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public SearchResponse senderId(String senderId) {
    this.senderId = senderId;
    return this;
  }

  /**
   * The &#x60;sender_id&#x60; you provided in the Verify request.
   * @return senderId
   */
  @javax.annotation.Nullable
  public String getSenderId() {
    return senderId;
  }

  public void setSenderId(String senderId) {
    this.senderId = senderId;
  }


  public SearchResponse status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * Code | Description -- | -- IN PROGRESS | The search is still in progress. SUCCESS | Your user entered a correct verification code. FAILED | Your user entered an incorrect code more than three times. EXPIRED | Your user did not enter a code before the &#x60;pin_expiry&#x60; time elapsed. CANCELLED | The verification process was cancelled by a Verify control request. 
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchResponse searchResponse = (SearchResponse) o;
    return Objects.equals(this.accountId, searchResponse.accountId) &&
        Objects.equals(this.checks, searchResponse.checks) &&
        Objects.equals(this.currency, searchResponse.currency) &&
        Objects.equals(this.dateFinalized, searchResponse.dateFinalized) &&
        Objects.equals(this.dateSubmitted, searchResponse.dateSubmitted) &&
        Objects.equals(this.estimatedPriceMessagesSent, searchResponse.estimatedPriceMessagesSent) &&
        Objects.equals(this.events, searchResponse.events) &&
        Objects.equals(this.firstEventDate, searchResponse.firstEventDate) &&
        Objects.equals(this.lastEventDate, searchResponse.lastEventDate) &&
        Objects.equals(this.number, searchResponse.number) &&
        Objects.equals(this.price, searchResponse.price) &&
        Objects.equals(this.requestId, searchResponse.requestId) &&
        Objects.equals(this.senderId, searchResponse.senderId) &&
        Objects.equals(this.status, searchResponse.status);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, checks, currency, dateFinalized, dateSubmitted, estimatedPriceMessagesSent, events, firstEventDate, lastEventDate, number, price, requestId, senderId, status);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchResponse {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    checks: ").append(toIndentedString(checks)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    dateFinalized: ").append(toIndentedString(dateFinalized)).append("\n");
    sb.append("    dateSubmitted: ").append(toIndentedString(dateSubmitted)).append("\n");
    sb.append("    estimatedPriceMessagesSent: ").append(toIndentedString(estimatedPriceMessagesSent)).append("\n");
    sb.append("    events: ").append(toIndentedString(events)).append("\n");
    sb.append("    firstEventDate: ").append(toIndentedString(firstEventDate)).append("\n");
    sb.append("    lastEventDate: ").append(toIndentedString(lastEventDate)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    senderId: ").append(toIndentedString(senderId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("account_id");
    openapiFields.add("checks");
    openapiFields.add("currency");
    openapiFields.add("date_finalized");
    openapiFields.add("date_submitted");
    openapiFields.add("estimated_price_messages_sent");
    openapiFields.add("events");
    openapiFields.add("first_event_date");
    openapiFields.add("last_event_date");
    openapiFields.add("number");
    openapiFields.add("price");
    openapiFields.add("request_id");
    openapiFields.add("sender_id");
    openapiFields.add("status");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SearchResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchResponse is not found in the empty JSON string", SearchResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("account_id") != null && !jsonObj.get("account_id").isJsonNull()) && !jsonObj.get("account_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `account_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("account_id").toString()));
      }
      if (jsonObj.get("checks") != null && !jsonObj.get("checks").isJsonNull()) {
        JsonArray jsonArraychecks = jsonObj.getAsJsonArray("checks");
        if (jsonArraychecks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("checks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `checks` to be an array in the JSON string but got `%s`", jsonObj.get("checks").toString()));
          }

          // validate the optional field `checks` (array)
          for (int i = 0; i < jsonArraychecks.size(); i++) {
            SearchResponseChecksInner.validateJsonElement(jsonArraychecks.get(i));
          };
        }
      }
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if ((jsonObj.get("date_finalized") != null && !jsonObj.get("date_finalized").isJsonNull()) && !jsonObj.get("date_finalized").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `date_finalized` to be a primitive type in the JSON string but got `%s`", jsonObj.get("date_finalized").toString()));
      }
      if ((jsonObj.get("date_submitted") != null && !jsonObj.get("date_submitted").isJsonNull()) && !jsonObj.get("date_submitted").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `date_submitted` to be a primitive type in the JSON string but got `%s`", jsonObj.get("date_submitted").toString()));
      }
      if ((jsonObj.get("estimated_price_messages_sent") != null && !jsonObj.get("estimated_price_messages_sent").isJsonNull()) && !jsonObj.get("estimated_price_messages_sent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `estimated_price_messages_sent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("estimated_price_messages_sent").toString()));
      }
      if (jsonObj.get("events") != null && !jsonObj.get("events").isJsonNull()) {
        JsonArray jsonArrayevents = jsonObj.getAsJsonArray("events");
        if (jsonArrayevents != null) {
          // ensure the json data is an array
          if (!jsonObj.get("events").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `events` to be an array in the JSON string but got `%s`", jsonObj.get("events").toString()));
          }

          // validate the optional field `events` (array)
          for (int i = 0; i < jsonArrayevents.size(); i++) {
            SearchResponseEventsInner.validateJsonElement(jsonArrayevents.get(i));
          };
        }
      }
      if ((jsonObj.get("first_event_date") != null && !jsonObj.get("first_event_date").isJsonNull()) && !jsonObj.get("first_event_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `first_event_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("first_event_date").toString()));
      }
      if ((jsonObj.get("last_event_date") != null && !jsonObj.get("last_event_date").isJsonNull()) && !jsonObj.get("last_event_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `last_event_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("last_event_date").toString()));
      }
      if ((jsonObj.get("number") != null && !jsonObj.get("number").isJsonNull()) && !jsonObj.get("number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number").toString()));
      }
      if ((jsonObj.get("price") != null && !jsonObj.get("price").isJsonNull()) && !jsonObj.get("price").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `price` to be a primitive type in the JSON string but got `%s`", jsonObj.get("price").toString()));
      }
      if ((jsonObj.get("request_id") != null && !jsonObj.get("request_id").isJsonNull()) && !jsonObj.get("request_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_id").toString()));
      }
      if ((jsonObj.get("sender_id") != null && !jsonObj.get("sender_id").isJsonNull()) && !jsonObj.get("sender_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sender_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sender_id").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchResponse>() {
           @Override
           public void write(JsonWriter out, SearchResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchResponse
   * @throws IOException if the JSON string is invalid with respect to SearchResponse
   */
  public static SearchResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchResponse.class);
  }

  /**
   * Convert an instance of SearchResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

