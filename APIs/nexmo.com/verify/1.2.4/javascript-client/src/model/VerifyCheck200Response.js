/**
 * Verify API
 * The Verify API helps you to implement 2FA (two-factor authentication) in your applications. This is useful for:  * Protecting against spam, by preventing spammers from creating multiple accounts * Monitoring suspicious activity, by forcing an account user to verify ownership of a number * Ensuring that you can reach your users at any time because you have their correct phone number More information is available at <https://developer.nexmo.com/verify>
 *
 * The version of the OpenAPI document: 1.2.4
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CheckErrorResponse from './CheckErrorResponse';
import CheckResponse from './CheckResponse';

/**
 * The VerifyCheck200Response model module.
 * @module model/VerifyCheck200Response
 * @version 1.2.4
 */
class VerifyCheck200Response {
    /**
     * Constructs a new <code>VerifyCheck200Response</code>.
     * @alias module:model/VerifyCheck200Response
     * @param {(module:model/CheckErrorResponse|module:model/CheckResponse)} instance The actual instance to initialize VerifyCheck200Response.
     */
    constructor(instance = null) {
        if (instance === null) {
            this.actualInstance = null;
            return;
        }
        var match = 0;
        var errorMessages = [];
        try {
            if (typeof instance === "CheckResponse") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                CheckResponse.validateJSON(instance); // throw an exception if no match
                // create CheckResponse from JS object
                this.actualInstance = CheckResponse.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into CheckResponse
            errorMessages.push("Failed to construct CheckResponse: " + err)
        }

        try {
            if (typeof instance === "CheckErrorResponse") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                CheckErrorResponse.validateJSON(instance); // throw an exception if no match
                // create CheckErrorResponse from JS object
                this.actualInstance = CheckErrorResponse.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into CheckErrorResponse
            errorMessages.push("Failed to construct CheckErrorResponse: " + err)
        }

        if (match > 1) {
            throw new Error("Multiple matches found constructing `VerifyCheck200Response` with oneOf schemas CheckErrorResponse, CheckResponse. Input: " + JSON.stringify(instance));
        } else if (match === 0) {
            this.actualInstance = null; // clear the actual instance in case there are multiple matches
            throw new Error("No match found constructing `VerifyCheck200Response` with oneOf schemas CheckErrorResponse, CheckResponse. Details: " +
                            errorMessages.join(", "));
        } else { // only 1 match
            // the input is valid
        }
    }

    /**
     * Constructs a <code>VerifyCheck200Response</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/VerifyCheck200Response} obj Optional instance to populate.
     * @return {module:model/VerifyCheck200Response} The populated <code>VerifyCheck200Response</code> instance.
     */
    static constructFromObject(data, obj) {
        return new VerifyCheck200Response(data);
    }

    /**
     * Gets the actual instance, which can be <code>CheckErrorResponse</code>, <code>CheckResponse</code>.
     * @return {(module:model/CheckErrorResponse|module:model/CheckResponse)} The actual instance.
     */
    getActualInstance() {
        return this.actualInstance;
    }

    /**
     * Sets the actual instance, which can be <code>CheckErrorResponse</code>, <code>CheckResponse</code>.
     * @param {(module:model/CheckErrorResponse|module:model/CheckResponse)} obj The actual instance.
     */
    setActualInstance(obj) {
       this.actualInstance = VerifyCheck200Response.constructFromObject(obj).getActualInstance();
    }

    /**
     * Returns the JSON representation of the actual instance.
     * @return {string}
     */
    toJSON = function(){
        return this.getActualInstance();
    }

    /**
     * Create an instance of VerifyCheck200Response from a JSON string.
     * @param {string} json_string JSON string.
     * @return {module:model/VerifyCheck200Response} An instance of VerifyCheck200Response.
     */
    static fromJSON = function(json_string){
        return VerifyCheck200Response.constructFromObject(JSON.parse(json_string));
    }
}

/**
 * The currency code.
 * @member {String} currency
 */
VerifyCheck200Response.prototype['currency'] = undefined;

/**
 * This field may not be present, depending on your pricing model. The value indicates the cost (in EUR) of the calls made and messages sent for the verification process. This value may be updated during and shortly after the request completes because user input events can overlap with message/call events. When this field is present, the total cost of the verification is the sum of this field and the `price` field. 
 * @member {String} estimated_price_messages_sent
 */
VerifyCheck200Response.prototype['estimated_price_messages_sent'] = undefined;

/**
 * The ID of the verification event, such as an SMS or TTS call.
 * @member {String} event_id
 */
VerifyCheck200Response.prototype['event_id'] = undefined;

/**
 * The cost incurred for this request.
 * @member {String} price
 */
VerifyCheck200Response.prototype['price'] = undefined;

/**
 * The `request_id` that you received in the response to the Verify request and used in the Verify check request.
 * @member {String} request_id
 */
VerifyCheck200Response.prototype['request_id'] = undefined;

/**
 * Code | Text | Description -- | -- | -- 0 | Success | The request was successfully accepted by Vonage. 1 | Throttled | You are trying to send more than the maximum of 30 requests per second. 2 | Your request is incomplete and missing the mandatory parameter `$parameter` | The stated parameter is missing. 3 | Invalid value for parameter `$parameter` | Invalid value for parameter. If you see Facility not allowed in the error text, check that you are using the correct Base URL in your request. 4 | Invalid credentials were provided | The supplied API key or secret in the request is either invalid or disabled. 5 | Internal Error | An error occurred processing this request in the Cloud Communications Platform. 6 | The Vonage platform was unable to process this message for the following reason: `$reason` | The request could not be routed. 16 | The code inserted does not match the expected value | 17 | The wrong code was provided too many times | You can run Verify check on a specific `request_id` up to three times unless a new verification code is generated. If you check a request more than three times, it is set to FAILED and you cannot check it again. 
 * @member {module:model/VerifyCheck200Response.StatusEnum} status
 */
VerifyCheck200Response.prototype['status'] = undefined;

/**
 * If the `status` is non-zero, this explains the error encountered.
 * @member {String} error_text
 */
VerifyCheck200Response.prototype['error_text'] = undefined;


VerifyCheck200Response.OneOf = ["CheckErrorResponse", "CheckResponse"];

export default VerifyCheck200Response;

