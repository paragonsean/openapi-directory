/**
 * Conversation API
 * The Conversation API enables you to build conversation features where communication can take place across multiple mediums including IP Messaging, PSTN Voice, SMS and WebRTC Audio and Video. The context of the conversations is maintained though each communication event taking place within a conversation, no matter the medium.
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAll_events.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAll_events::OAIAll_events(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAll_events::OAIAll_events() {
    this->initializeModel();
}

OAIAll_events::~OAIAll_events() {}

void OAIAll_events::initializeModel() {

    m_body_isSet = false;
    m_body_isValid = false;

    m_conversation_id_isSet = false;
    m_conversation_id_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m__links_isSet = false;
    m__links_isValid = false;

    m_from_isSet = false;
    m_from_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_timestamp_isSet = false;
    m_timestamp_isValid = false;
}

void OAIAll_events::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAll_events::fromJsonObject(QJsonObject json) {

    m_body_isValid = ::OpenAPI::fromJsonValue(m_body, json[QString("body")]);
    m_body_isSet = !json[QString("body")].isNull() && m_body_isValid;

    m_conversation_id_isValid = ::OpenAPI::fromJsonValue(m_conversation_id, json[QString("conversation_id")]);
    m_conversation_id_isSet = !json[QString("conversation_id")].isNull() && m_conversation_id_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m__links_isValid = ::OpenAPI::fromJsonValue(m__links, json[QString("_links")]);
    m__links_isSet = !json[QString("_links")].isNull() && m__links_isValid;

    m_from_isValid = ::OpenAPI::fromJsonValue(m_from, json[QString("from")]);
    m_from_isSet = !json[QString("from")].isNull() && m_from_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_timestamp_isValid = ::OpenAPI::fromJsonValue(m_timestamp, json[QString("timestamp")]);
    m_timestamp_isSet = !json[QString("timestamp")].isNull() && m_timestamp_isValid;
}

QString OAIAll_events::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAll_events::asJsonObject() const {
    QJsonObject obj;
    if (m_body.isSet()) {
        obj.insert(QString("body"), ::OpenAPI::toJsonValue(m_body));
    }
    if (m_conversation_id_isSet) {
        obj.insert(QString("conversation_id"), ::OpenAPI::toJsonValue(m_conversation_id));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m__links.isSet()) {
        obj.insert(QString("_links"), ::OpenAPI::toJsonValue(m__links));
    }
    if (m_from_isSet) {
        obj.insert(QString("from"), ::OpenAPI::toJsonValue(m_from));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_timestamp_isSet) {
        obj.insert(QString("timestamp"), ::OpenAPI::toJsonValue(m_timestamp));
    }
    return obj;
}

OAIMember OAIAll_events::getBody() const {
    return m_body;
}
void OAIAll_events::setBody(const OAIMember &body) {
    m_body = body;
    m_body_isSet = true;
}

bool OAIAll_events::is_body_Set() const{
    return m_body_isSet;
}

bool OAIAll_events::is_body_Valid() const{
    return m_body_isValid;
}

QString OAIAll_events::getConversationId() const {
    return m_conversation_id;
}
void OAIAll_events::setConversationId(const QString &conversation_id) {
    m_conversation_id = conversation_id;
    m_conversation_id_isSet = true;
}

bool OAIAll_events::is_conversation_id_Set() const{
    return m_conversation_id_isSet;
}

bool OAIAll_events::is_conversation_id_Valid() const{
    return m_conversation_id_isValid;
}

QString OAIAll_events::getType() const {
    return m_type;
}
void OAIAll_events::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIAll_events::is_type_Set() const{
    return m_type_isSet;
}

bool OAIAll_events::is_type_Valid() const{
    return m_type_isValid;
}

OAIEvent__links OAIAll_events::getLinks() const {
    return m__links;
}
void OAIAll_events::setLinks(const OAIEvent__links &_links) {
    m__links = _links;
    m__links_isSet = true;
}

bool OAIAll_events::is__links_Set() const{
    return m__links_isSet;
}

bool OAIAll_events::is__links_Valid() const{
    return m__links_isValid;
}

QString OAIAll_events::getFrom() const {
    return m_from;
}
void OAIAll_events::setFrom(const QString &from) {
    m_from = from;
    m_from_isSet = true;
}

bool OAIAll_events::is_from_Set() const{
    return m_from_isSet;
}

bool OAIAll_events::is_from_Valid() const{
    return m_from_isValid;
}

qint32 OAIAll_events::getId() const {
    return m_id;
}
void OAIAll_events::setId(const qint32 &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIAll_events::is_id_Set() const{
    return m_id_isSet;
}

bool OAIAll_events::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIAll_events::getTimestamp() const {
    return m_timestamp;
}
void OAIAll_events::setTimestamp(const QString &timestamp) {
    m_timestamp = timestamp;
    m_timestamp_isSet = true;
}

bool OAIAll_events::is_timestamp_Set() const{
    return m_timestamp_isSet;
}

bool OAIAll_events::is_timestamp_Valid() const{
    return m_timestamp_isValid;
}

bool OAIAll_events::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_body.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_conversation_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m__links.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_from_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAll_events::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
