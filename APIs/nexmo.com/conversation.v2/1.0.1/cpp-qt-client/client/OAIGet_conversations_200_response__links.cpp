/**
 * Conversation API
 * The Conversation API enables you to build conversation features where communication can take place across multiple mediums including IP Messaging, PSTN Voice, SMS and WebRTC Audio and Video. The context of the conversations is maintained though each communication event taking place within a conversation, no matter the medium.
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGet_conversations_200_response__links.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGet_conversations_200_response__links::OAIGet_conversations_200_response__links(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGet_conversations_200_response__links::OAIGet_conversations_200_response__links() {
    this->initializeModel();
}

OAIGet_conversations_200_response__links::~OAIGet_conversations_200_response__links() {}

void OAIGet_conversations_200_response__links::initializeModel() {

    m_first_isSet = false;
    m_first_isValid = false;

    m_next_isSet = false;
    m_next_isValid = false;

    m_prev_isSet = false;
    m_prev_isValid = false;

    m_self_isSet = false;
    m_self_isValid = false;
}

void OAIGet_conversations_200_response__links::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGet_conversations_200_response__links::fromJsonObject(QJsonObject json) {

    m_first_isValid = ::OpenAPI::fromJsonValue(m_first, json[QString("first")]);
    m_first_isSet = !json[QString("first")].isNull() && m_first_isValid;

    m_next_isValid = ::OpenAPI::fromJsonValue(m_next, json[QString("next")]);
    m_next_isSet = !json[QString("next")].isNull() && m_next_isValid;

    m_prev_isValid = ::OpenAPI::fromJsonValue(m_prev, json[QString("prev")]);
    m_prev_isSet = !json[QString("prev")].isNull() && m_prev_isValid;

    m_self_isValid = ::OpenAPI::fromJsonValue(m_self, json[QString("self")]);
    m_self_isSet = !json[QString("self")].isNull() && m_self_isValid;
}

QString OAIGet_conversations_200_response__links::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGet_conversations_200_response__links::asJsonObject() const {
    QJsonObject obj;
    if (m_first.isSet()) {
        obj.insert(QString("first"), ::OpenAPI::toJsonValue(m_first));
    }
    if (m_next.isSet()) {
        obj.insert(QString("next"), ::OpenAPI::toJsonValue(m_next));
    }
    if (m_prev.isSet()) {
        obj.insert(QString("prev"), ::OpenAPI::toJsonValue(m_prev));
    }
    if (m_self.isSet()) {
        obj.insert(QString("self"), ::OpenAPI::toJsonValue(m_self));
    }
    return obj;
}

OAIGet_conversations_200_response__links_first OAIGet_conversations_200_response__links::getFirst() const {
    return m_first;
}
void OAIGet_conversations_200_response__links::setFirst(const OAIGet_conversations_200_response__links_first &first) {
    m_first = first;
    m_first_isSet = true;
}

bool OAIGet_conversations_200_response__links::is_first_Set() const{
    return m_first_isSet;
}

bool OAIGet_conversations_200_response__links::is_first_Valid() const{
    return m_first_isValid;
}

OAIGet_conversations_200_response__links_next OAIGet_conversations_200_response__links::getNext() const {
    return m_next;
}
void OAIGet_conversations_200_response__links::setNext(const OAIGet_conversations_200_response__links_next &next) {
    m_next = next;
    m_next_isSet = true;
}

bool OAIGet_conversations_200_response__links::is_next_Set() const{
    return m_next_isSet;
}

bool OAIGet_conversations_200_response__links::is_next_Valid() const{
    return m_next_isValid;
}

OAIGet_conversations_200_response__links_prev OAIGet_conversations_200_response__links::getPrev() const {
    return m_prev;
}
void OAIGet_conversations_200_response__links::setPrev(const OAIGet_conversations_200_response__links_prev &prev) {
    m_prev = prev;
    m_prev_isSet = true;
}

bool OAIGet_conversations_200_response__links::is_prev_Set() const{
    return m_prev_isSet;
}

bool OAIGet_conversations_200_response__links::is_prev_Valid() const{
    return m_prev_isValid;
}

OAIGet_conversations_200_response__links_self OAIGet_conversations_200_response__links::getSelf() const {
    return m_self;
}
void OAIGet_conversations_200_response__links::setSelf(const OAIGet_conversations_200_response__links_self &self) {
    m_self = self;
    m_self_isSet = true;
}

bool OAIGet_conversations_200_response__links::is_self_Set() const{
    return m_self_isSet;
}

bool OAIGet_conversations_200_response__links::is_self_Valid() const{
    return m_self_isValid;
}

bool OAIGet_conversations_200_response__links::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_first.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_next.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_prev.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_self.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGet_conversations_200_response__links::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
