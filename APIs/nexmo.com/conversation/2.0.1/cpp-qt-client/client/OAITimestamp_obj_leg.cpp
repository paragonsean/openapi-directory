/**
 * Conversation API
 * The Conversation API enables you to build conversation features where communication can take place across multiple mediums including IP Messaging, PSTN Voice, SMS and WebRTC Audio and Video. The context of the conversations is maintained though each communication event taking place within a conversation, no matter the medium.
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITimestamp_obj_leg.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITimestamp_obj_leg::OAITimestamp_obj_leg(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITimestamp_obj_leg::OAITimestamp_obj_leg() {
    this->initializeModel();
}

OAITimestamp_obj_leg::~OAITimestamp_obj_leg() {}

void OAITimestamp_obj_leg::initializeModel() {

    m_end_isSet = false;
    m_end_isValid = false;

    m_request_isSet = false;
    m_request_isValid = false;

    m_start_isSet = false;
    m_start_isValid = false;
}

void OAITimestamp_obj_leg::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITimestamp_obj_leg::fromJsonObject(QJsonObject json) {

    m_end_isValid = ::OpenAPI::fromJsonValue(m_end, json[QString("end")]);
    m_end_isSet = !json[QString("end")].isNull() && m_end_isValid;

    m_request_isValid = ::OpenAPI::fromJsonValue(m_request, json[QString("request")]);
    m_request_isSet = !json[QString("request")].isNull() && m_request_isValid;

    m_start_isValid = ::OpenAPI::fromJsonValue(m_start, json[QString("start")]);
    m_start_isSet = !json[QString("start")].isNull() && m_start_isValid;
}

QString OAITimestamp_obj_leg::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITimestamp_obj_leg::asJsonObject() const {
    QJsonObject obj;
    if (m_end_isSet) {
        obj.insert(QString("end"), ::OpenAPI::toJsonValue(m_end));
    }
    if (m_request_isSet) {
        obj.insert(QString("request"), ::OpenAPI::toJsonValue(m_request));
    }
    if (m_start_isSet) {
        obj.insert(QString("start"), ::OpenAPI::toJsonValue(m_start));
    }
    return obj;
}

QString OAITimestamp_obj_leg::getEnd() const {
    return m_end;
}
void OAITimestamp_obj_leg::setEnd(const QString &end) {
    m_end = end;
    m_end_isSet = true;
}

bool OAITimestamp_obj_leg::is_end_Set() const{
    return m_end_isSet;
}

bool OAITimestamp_obj_leg::is_end_Valid() const{
    return m_end_isValid;
}

QString OAITimestamp_obj_leg::getRequest() const {
    return m_request;
}
void OAITimestamp_obj_leg::setRequest(const QString &request) {
    m_request = request;
    m_request_isSet = true;
}

bool OAITimestamp_obj_leg::is_request_Set() const{
    return m_request_isSet;
}

bool OAITimestamp_obj_leg::is_request_Valid() const{
    return m_request_isValid;
}

QString OAITimestamp_obj_leg::getStart() const {
    return m_start;
}
void OAITimestamp_obj_leg::setStart(const QString &start) {
    m_start = start;
    m_start_isSet = true;
}

bool OAITimestamp_obj_leg::is_start_Set() const{
    return m_start_isSet;
}

bool OAITimestamp_obj_leg::is_start_Valid() const{
    return m_start_isValid;
}

bool OAITimestamp_obj_leg::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_end_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITimestamp_obj_leg::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
