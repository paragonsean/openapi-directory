/**
 * Conversation API
 * The Conversation API enables you to build conversation features where communication can take place across multiple mediums including IP Messaging, PSTN Voice, SMS and WebRTC Audio and Video. The context of the conversations is maintained though each communication event taking place within a conversation, no matter the medium.
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIChannel.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIChannel::OAIChannel(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIChannel::OAIChannel() {
    this->initializeModel();
}

OAIChannel::~OAIChannel() {}

void OAIChannel::initializeModel() {

    m_from_isSet = false;
    m_from_isValid = false;

    m_leg_id_isSet = false;
    m_leg_id_isValid = false;

    m_leg_ids_isSet = false;
    m_leg_ids_isValid = false;

    m_to_isSet = false;
    m_to_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIChannel::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIChannel::fromJsonObject(QJsonObject json) {

    m_from_isValid = ::OpenAPI::fromJsonValue(m_from, json[QString("from")]);
    m_from_isSet = !json[QString("from")].isNull() && m_from_isValid;

    m_leg_id_isValid = ::OpenAPI::fromJsonValue(m_leg_id, json[QString("leg_id")]);
    m_leg_id_isSet = !json[QString("leg_id")].isNull() && m_leg_id_isValid;

    m_leg_ids_isValid = ::OpenAPI::fromJsonValue(m_leg_ids, json[QString("leg_ids")]);
    m_leg_ids_isSet = !json[QString("leg_ids")].isNull() && m_leg_ids_isValid;

    m_to_isValid = ::OpenAPI::fromJsonValue(m_to, json[QString("to")]);
    m_to_isSet = !json[QString("to")].isNull() && m_to_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIChannel::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIChannel::asJsonObject() const {
    QJsonObject obj;
    if (m_from.isSet()) {
        obj.insert(QString("from"), ::OpenAPI::toJsonValue(m_from));
    }
    if (m_leg_id_isSet) {
        obj.insert(QString("leg_id"), ::OpenAPI::toJsonValue(m_leg_id));
    }
    if (m_leg_ids.size() > 0) {
        obj.insert(QString("leg_ids"), ::OpenAPI::toJsonValue(m_leg_ids));
    }
    if (m_to.isSet()) {
        obj.insert(QString("to"), ::OpenAPI::toJsonValue(m_to));
    }
    if (m_type.isSet()) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

OAIChannel_from OAIChannel::getFrom() const {
    return m_from;
}
void OAIChannel::setFrom(const OAIChannel_from &from) {
    m_from = from;
    m_from_isSet = true;
}

bool OAIChannel::is_from_Set() const{
    return m_from_isSet;
}

bool OAIChannel::is_from_Valid() const{
    return m_from_isValid;
}

QString OAIChannel::getLegId() const {
    return m_leg_id;
}
void OAIChannel::setLegId(const QString &leg_id) {
    m_leg_id = leg_id;
    m_leg_id_isSet = true;
}

bool OAIChannel::is_leg_id_Set() const{
    return m_leg_id_isSet;
}

bool OAIChannel::is_leg_id_Valid() const{
    return m_leg_id_isValid;
}

QList<OAIChannel_leg_ids_inner> OAIChannel::getLegIds() const {
    return m_leg_ids;
}
void OAIChannel::setLegIds(const QList<OAIChannel_leg_ids_inner> &leg_ids) {
    m_leg_ids = leg_ids;
    m_leg_ids_isSet = true;
}

bool OAIChannel::is_leg_ids_Set() const{
    return m_leg_ids_isSet;
}

bool OAIChannel::is_leg_ids_Valid() const{
    return m_leg_ids_isValid;
}

OAIChannel_to OAIChannel::getTo() const {
    return m_to;
}
void OAIChannel::setTo(const OAIChannel_to &to) {
    m_to = to;
    m_to_isSet = true;
}

bool OAIChannel::is_to_Set() const{
    return m_to_isSet;
}

bool OAIChannel::is_to_Valid() const{
    return m_to_isValid;
}

OAIChannel_type OAIChannel::getType() const {
    return m_type;
}
void OAIChannel::setType(const OAIChannel_type &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIChannel::is_type_Set() const{
    return m_type_isSet;
}

bool OAIChannel::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIChannel::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_from.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_leg_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_leg_ids.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_to.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIChannel::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
