/**
 * Conversation API
 * The Conversation API enables you to build conversation features where communication can take place across multiple mediums including IP Messaging, PSTN Voice, SMS and WebRTC Audio and Video. The context of the conversations is maintained though each communication event taking place within a conversation, no matter the medium.
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRecordConversation_request.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRecordConversation_request::OAIRecordConversation_request(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRecordConversation_request::OAIRecordConversation_request() {
    this->initializeModel();
}

OAIRecordConversation_request::~OAIRecordConversation_request() {}

void OAIRecordConversation_request::initializeModel() {

    m_action_isSet = false;
    m_action_isValid = false;

    m_event_method_isSet = false;
    m_event_method_isValid = false;

    m_event_url_isSet = false;
    m_event_url_isValid = false;

    m_format_isSet = false;
    m_format_isValid = false;

    m_split_isSet = false;
    m_split_isValid = false;
}

void OAIRecordConversation_request::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRecordConversation_request::fromJsonObject(QJsonObject json) {

    m_action_isValid = ::OpenAPI::fromJsonValue(m_action, json[QString("action")]);
    m_action_isSet = !json[QString("action")].isNull() && m_action_isValid;

    m_event_method_isValid = ::OpenAPI::fromJsonValue(m_event_method, json[QString("event_method")]);
    m_event_method_isSet = !json[QString("event_method")].isNull() && m_event_method_isValid;

    m_event_url_isValid = ::OpenAPI::fromJsonValue(m_event_url, json[QString("event_url")]);
    m_event_url_isSet = !json[QString("event_url")].isNull() && m_event_url_isValid;

    m_format_isValid = ::OpenAPI::fromJsonValue(m_format, json[QString("format")]);
    m_format_isSet = !json[QString("format")].isNull() && m_format_isValid;

    m_split_isValid = ::OpenAPI::fromJsonValue(m_split, json[QString("split")]);
    m_split_isSet = !json[QString("split")].isNull() && m_split_isValid;
}

QString OAIRecordConversation_request::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRecordConversation_request::asJsonObject() const {
    QJsonObject obj;
    if (m_action.isSet()) {
        obj.insert(QString("action"), ::OpenAPI::toJsonValue(m_action));
    }
    if (m_event_method_isSet) {
        obj.insert(QString("event_method"), ::OpenAPI::toJsonValue(m_event_method));
    }
    if (m_event_url.size() > 0) {
        obj.insert(QString("event_url"), ::OpenAPI::toJsonValue(m_event_url));
    }
    if (m_format.isSet()) {
        obj.insert(QString("format"), ::OpenAPI::toJsonValue(m_format));
    }
    if (m_split_isSet) {
        obj.insert(QString("split"), ::OpenAPI::toJsonValue(m_split));
    }
    return obj;
}

OAIAction OAIRecordConversation_request::getAction() const {
    return m_action;
}
void OAIRecordConversation_request::setAction(const OAIAction &action) {
    m_action = action;
    m_action_isSet = true;
}

bool OAIRecordConversation_request::is_action_Set() const{
    return m_action_isSet;
}

bool OAIRecordConversation_request::is_action_Valid() const{
    return m_action_isValid;
}

QString OAIRecordConversation_request::getEventMethod() const {
    return m_event_method;
}
void OAIRecordConversation_request::setEventMethod(const QString &event_method) {
    m_event_method = event_method;
    m_event_method_isSet = true;
}

bool OAIRecordConversation_request::is_event_method_Set() const{
    return m_event_method_isSet;
}

bool OAIRecordConversation_request::is_event_method_Valid() const{
    return m_event_method_isValid;
}

QList<QString> OAIRecordConversation_request::getEventUrl() const {
    return m_event_url;
}
void OAIRecordConversation_request::setEventUrl(const QList<QString> &event_url) {
    m_event_url = event_url;
    m_event_url_isSet = true;
}

bool OAIRecordConversation_request::is_event_url_Set() const{
    return m_event_url_isSet;
}

bool OAIRecordConversation_request::is_event_url_Valid() const{
    return m_event_url_isValid;
}

OAIFormat OAIRecordConversation_request::getFormat() const {
    return m_format;
}
void OAIRecordConversation_request::setFormat(const OAIFormat &format) {
    m_format = format;
    m_format_isSet = true;
}

bool OAIRecordConversation_request::is_format_Set() const{
    return m_format_isSet;
}

bool OAIRecordConversation_request::is_format_Valid() const{
    return m_format_isValid;
}

QString OAIRecordConversation_request::getSplit() const {
    return m_split;
}
void OAIRecordConversation_request::setSplit(const QString &split) {
    m_split = split;
    m_split_isSet = true;
}

bool OAIRecordConversation_request::is_split_Set() const{
    return m_split_isSet;
}

bool OAIRecordConversation_request::is_split_Valid() const{
    return m_split_isValid;
}

bool OAIRecordConversation_request::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_action.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_event_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_event_url.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_format.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_split_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRecordConversation_request::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_action_isValid && true;
}

} // namespace OpenAPI
