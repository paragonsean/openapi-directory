/**
 * Dispatch API
 * The Dispatch API enables the developer to specify a multiple message workflow. A workflow follows a template. The first one we are adding is the failover template. The failover template instructs the Messages API to first send a message to the specified channel. If that message fails immediately or if the condition_status is not reached within the given time period the next message is sent. The developer will also receive status webhooks from the messages resource for each delivery and read event. This API is currently in Beta.
 *
 * The version of the OpenAPI document: 0.3.4
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISendWithFailoverMessage.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAISendWithFailoverMessage::OAISendWithFailoverMessage(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAISendWithFailoverMessage::OAISendWithFailoverMessage() {
    this->initializeModel();
}

OAISendWithFailoverMessage::~OAISendWithFailoverMessage() {}

void OAISendWithFailoverMessage::initializeModel() {

    m_failover_isSet = false;
    m_failover_isValid = false;

    m_from_isSet = false;
    m_from_isValid = false;

    m_message_isSet = false;
    m_message_isValid = false;

    m_to_isSet = false;
    m_to_isValid = false;
}

void OAISendWithFailoverMessage::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAISendWithFailoverMessage::fromJsonObject(QJsonObject json) {

    m_failover_isValid = ::OpenAPI::fromJsonValue(m_failover, json[QString("failover")]);
    m_failover_isSet = !json[QString("failover")].isNull() && m_failover_isValid;

    m_from_isValid = ::OpenAPI::fromJsonValue(m_from, json[QString("from")]);
    m_from_isSet = !json[QString("from")].isNull() && m_from_isValid;

    m_message_isValid = ::OpenAPI::fromJsonValue(m_message, json[QString("message")]);
    m_message_isSet = !json[QString("message")].isNull() && m_message_isValid;

    m_to_isValid = ::OpenAPI::fromJsonValue(m_to, json[QString("to")]);
    m_to_isSet = !json[QString("to")].isNull() && m_to_isValid;
}

QString OAISendWithFailoverMessage::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAISendWithFailoverMessage::asJsonObject() const {
    QJsonObject obj;
    if (m_failover.isSet()) {
        obj.insert(QString("failover"), ::OpenAPI::toJsonValue(m_failover));
    }
    if (m_from.isSet()) {
        obj.insert(QString("from"), ::OpenAPI::toJsonValue(m_from));
    }
    if (m_message.isSet()) {
        obj.insert(QString("message"), ::OpenAPI::toJsonValue(m_message));
    }
    if (m_to.isSet()) {
        obj.insert(QString("to"), ::OpenAPI::toJsonValue(m_to));
    }
    return obj;
}

OAIFailoverProperty OAISendWithFailoverMessage::getFailover() const {
    return m_failover;
}
void OAISendWithFailoverMessage::setFailover(const OAIFailoverProperty &failover) {
    m_failover = failover;
    m_failover_isSet = true;
}

bool OAISendWithFailoverMessage::is_failover_Set() const{
    return m_failover_isSet;
}

bool OAISendWithFailoverMessage::is_failover_Valid() const{
    return m_failover_isValid;
}

OAIFromProperty OAISendWithFailoverMessage::getFrom() const {
    return m_from;
}
void OAISendWithFailoverMessage::setFrom(const OAIFromProperty &from) {
    m_from = from;
    m_from_isSet = true;
}

bool OAISendWithFailoverMessage::is_from_Set() const{
    return m_from_isSet;
}

bool OAISendWithFailoverMessage::is_from_Valid() const{
    return m_from_isValid;
}

OAIMessageProperty OAISendWithFailoverMessage::getMessage() const {
    return m_message;
}
void OAISendWithFailoverMessage::setMessage(const OAIMessageProperty &message) {
    m_message = message;
    m_message_isSet = true;
}

bool OAISendWithFailoverMessage::is_message_Set() const{
    return m_message_isSet;
}

bool OAISendWithFailoverMessage::is_message_Valid() const{
    return m_message_isValid;
}

OAIToProperty OAISendWithFailoverMessage::getTo() const {
    return m_to;
}
void OAISendWithFailoverMessage::setTo(const OAIToProperty &to) {
    m_to = to;
    m_to_isSet = true;
}

bool OAISendWithFailoverMessage::is_to_Set() const{
    return m_to_isSet;
}

bool OAISendWithFailoverMessage::is_to_Valid() const{
    return m_to_isValid;
}

bool OAISendWithFailoverMessage::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_failover.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_from.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_message.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_to.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAISendWithFailoverMessage::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_from_isValid && m_message_isValid && m_to_isValid && true;
}

} // namespace OpenAPI
