/**
 * Dispatch API
 * The Dispatch API enables the developer to specify a multiple message workflow. A workflow follows a template. The first one we are adding is the failover template. The failover template instructs the Messages API to first send a message to the specified channel. If that message fails immediately or if the condition_status is not reached within the given time period the next message is sent. The developer will also receive status webhooks from the messages resource for each delivery and read event. This API is currently in Beta.
 *
 * The version of the OpenAPI document: 0.3.4
 * Contact: devrel@vonage.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMessageProperty_content.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMessageProperty_content::OAIMessageProperty_content(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMessageProperty_content::OAIMessageProperty_content() {
    this->initializeModel();
}

OAIMessageProperty_content::~OAIMessageProperty_content() {}

void OAIMessageProperty_content::initializeModel() {

    m_audio_isSet = false;
    m_audio_isValid = false;

    m_file_isSet = false;
    m_file_isValid = false;

    m_image_isSet = false;
    m_image_isValid = false;

    m_r_template_isSet = false;
    m_r_template_isValid = false;

    m_text_isSet = false;
    m_text_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_video_isSet = false;
    m_video_isValid = false;
}

void OAIMessageProperty_content::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMessageProperty_content::fromJsonObject(QJsonObject json) {

    m_audio_isValid = ::OpenAPI::fromJsonValue(m_audio, json[QString("audio")]);
    m_audio_isSet = !json[QString("audio")].isNull() && m_audio_isValid;

    m_file_isValid = ::OpenAPI::fromJsonValue(m_file, json[QString("file")]);
    m_file_isSet = !json[QString("file")].isNull() && m_file_isValid;

    m_image_isValid = ::OpenAPI::fromJsonValue(m_image, json[QString("image")]);
    m_image_isSet = !json[QString("image")].isNull() && m_image_isValid;

    m_r_template_isValid = ::OpenAPI::fromJsonValue(m_r_template, json[QString("template")]);
    m_r_template_isSet = !json[QString("template")].isNull() && m_r_template_isValid;

    m_text_isValid = ::OpenAPI::fromJsonValue(m_text, json[QString("text")]);
    m_text_isSet = !json[QString("text")].isNull() && m_text_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_video_isValid = ::OpenAPI::fromJsonValue(m_video, json[QString("video")]);
    m_video_isSet = !json[QString("video")].isNull() && m_video_isValid;
}

QString OAIMessageProperty_content::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMessageProperty_content::asJsonObject() const {
    QJsonObject obj;
    if (m_audio.isSet()) {
        obj.insert(QString("audio"), ::OpenAPI::toJsonValue(m_audio));
    }
    if (m_file.isSet()) {
        obj.insert(QString("file"), ::OpenAPI::toJsonValue(m_file));
    }
    if (m_image.isSet()) {
        obj.insert(QString("image"), ::OpenAPI::toJsonValue(m_image));
    }
    if (m_r_template.isSet()) {
        obj.insert(QString("template"), ::OpenAPI::toJsonValue(m_r_template));
    }
    if (m_text_isSet) {
        obj.insert(QString("text"), ::OpenAPI::toJsonValue(m_text));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_video.isSet()) {
        obj.insert(QString("video"), ::OpenAPI::toJsonValue(m_video));
    }
    return obj;
}

OAIAudioProperty OAIMessageProperty_content::getAudio() const {
    return m_audio;
}
void OAIMessageProperty_content::setAudio(const OAIAudioProperty &audio) {
    m_audio = audio;
    m_audio_isSet = true;
}

bool OAIMessageProperty_content::is_audio_Set() const{
    return m_audio_isSet;
}

bool OAIMessageProperty_content::is_audio_Valid() const{
    return m_audio_isValid;
}

OAIFileProperty OAIMessageProperty_content::getFile() const {
    return m_file;
}
void OAIMessageProperty_content::setFile(const OAIFileProperty &file) {
    m_file = file;
    m_file_isSet = true;
}

bool OAIMessageProperty_content::is_file_Set() const{
    return m_file_isSet;
}

bool OAIMessageProperty_content::is_file_Valid() const{
    return m_file_isValid;
}

OAIImageProperty OAIMessageProperty_content::getImage() const {
    return m_image;
}
void OAIMessageProperty_content::setImage(const OAIImageProperty &image) {
    m_image = image;
    m_image_isSet = true;
}

bool OAIMessageProperty_content::is_image_Set() const{
    return m_image_isSet;
}

bool OAIMessageProperty_content::is_image_Valid() const{
    return m_image_isValid;
}

OAITemplateProperty OAIMessageProperty_content::getRTemplate() const {
    return m_r_template;
}
void OAIMessageProperty_content::setRTemplate(const OAITemplateProperty &r_template) {
    m_r_template = r_template;
    m_r_template_isSet = true;
}

bool OAIMessageProperty_content::is_r_template_Set() const{
    return m_r_template_isSet;
}

bool OAIMessageProperty_content::is_r_template_Valid() const{
    return m_r_template_isValid;
}

QString OAIMessageProperty_content::getText() const {
    return m_text;
}
void OAIMessageProperty_content::setText(const QString &text) {
    m_text = text;
    m_text_isSet = true;
}

bool OAIMessageProperty_content::is_text_Set() const{
    return m_text_isSet;
}

bool OAIMessageProperty_content::is_text_Valid() const{
    return m_text_isValid;
}

QString OAIMessageProperty_content::getType() const {
    return m_type;
}
void OAIMessageProperty_content::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIMessageProperty_content::is_type_Set() const{
    return m_type_isSet;
}

bool OAIMessageProperty_content::is_type_Valid() const{
    return m_type_isValid;
}

OAIVideoProperty OAIMessageProperty_content::getVideo() const {
    return m_video;
}
void OAIMessageProperty_content::setVideo(const OAIVideoProperty &video) {
    m_video = video;
    m_video_isSet = true;
}

bool OAIMessageProperty_content::is_video_Set() const{
    return m_video_isSet;
}

bool OAIMessageProperty_content::is_video_Valid() const{
    return m_video_isValid;
}

bool OAIMessageProperty_content::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_audio.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_file.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_image.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_template.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_video.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMessageProperty_content::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_type_isValid && true;
}

} // namespace OpenAPI
