/*
 * SimplyRETS
 * The SimplyRETS API is an exciting step towards making it easier for developers and real estate agents to build something awesome with real estate data!  The documentation below makes live requests to our API using the trial data. To get set up with the API using live MLS data, you must have RETS credentials from your MLS, which you can then use to create an app with SimplyRETS. For more information on that process, please see our [FAQ](https://simplyrets.com/faq), [Getting Started](https://simplyrets.com/blog/getting-set-up.html) page, or [contact us](https://simplyrets.com/\\#home-contact).  Below you'll find the API endpoints, query parameters, response bodies, and other information about using the SimplyRETS API. You can run queries by clicking the 'Try it Out' button at the bottom of each section.  ### Authentication The SimplyRETS API uses Basic Authentication. When you create an app, you'll get a set of API credentials to access your listings. If you're trying out the test data, you can use `simplyrets:simplyrets` for connecting to the API.  ### Media Types The SimplyRETS API uses the `Accept` header to allow clients to control media types (content versions). We maintain backwards compatibility with API clients by allowing them to specify a content version. We highly recommend setting and explicity media type when your application reaches production. Both the structure and content of our API response bodies is subject to change so we can add new features while respecting the stability of applications which have already been developed.  To always use the latest SimplyRETS content version, simply use `application/json` in your application `Accept` header.  If you want to pin your clients media type to a specific version, you can use the vendor-specific SimplyRETS media type, e.g. `application/vnd.simplyrets-v0.1+json\"`  To view all valid content-types for making an `OPTIONS`, make a request to the SimplyRETS api root  `curl -XOPTIONS -u simplyrets:simplyrets https://api.simplyrets.com/`  The default media types used in our API responses may change in the future. If you're building an application and care about the stability of the API, be sure to request a specific media type in the Accept header as shown in the examples below.  The wordpress plugin automatically sets the `Accept` header for the compatible SimplyRETS media types.  ### Pagination  To paginate through listings, start your query with these parameters: 'limit=500&lastId=0'. The 'lastId' is the important part, you can use any limit up to 500. When you receive the response from the API with the results, check the 'Link' header for the 'next' link. That link is pre-built to access the next 'page' of listings. Alternatively, you can use the last listing's 'mlsId' from the previous request and use that in the next query. For example:  First query:  curl -u username:password 'https://api.simplyrets.com/properties?limit=500&lastId=0'  If the 'mlsId' in the last listing of the results is '1234567', then the next query will be:  curl -u username:password 'https://api.simplyrets.com/properties?limit=500&lastId=1234567'  ...and so one until you have reached the final page of listings.  There a few pieces of useful information about each request stored in the HTTP Headers:  - `X-Total-Count` shows you the total amount of listings that match   your current query. - `Link` contains pre-built pagination links for accessing the next 'page' of listings that match your query.  ### RETS Vendor Compliance  Many RETS vendors have strict requirements for showing disclaimers with specific information embedded. For example, in many areas it's required to show the timestamp of the time the listings were refreshed inside a disclaimer or on a listing page.  The timestamp of the last listing refresh timestamp can be found in one of two spots:  - The `X-SimplyRETS-LastUpdate` header from `GET /properties` or `GET /properties/{mlsId}`  - Calling the API root `/` or properties api endpoint `/properties`   with an OPTIONS request    - `OPTIONS /`      This request will show the last update timestamp for all RETS     vendors associated with your application. Look for the     `updates` list in the JSON response.    - `OPTIONS /properties`      Using this request, look for the `lastUpdate` field in the JSON     response. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RETS MLS Vendor Data
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:24:54.606138-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MlsInformation {
  public static final String SERIALIZED_NAME_AREA = "area";
  @SerializedName(SERIALIZED_NAME_AREA)
  private String area;

  public static final String SERIALIZED_NAME_AREA_MINOR = "areaMinor";
  @SerializedName(SERIALIZED_NAME_AREA_MINOR)
  private String areaMinor;

  public static final String SERIALIZED_NAME_DAYS_ON_MARKET = "daysOnMarket";
  @SerializedName(SERIALIZED_NAME_DAYS_ON_MARKET)
  private Long daysOnMarket;

  public static final String SERIALIZED_NAME_ORIGINATING_SYSTEM_NAME = "originatingSystemName";
  @SerializedName(SERIALIZED_NAME_ORIGINATING_SYSTEM_NAME)
  private String originatingSystemName;

  /**
   * Normalized MLS Status Code. Compliant with data dictionary v1.3 ListingStatus Listing statuses depend on your MLS&#39;s availability. Below is a brief description of each status with possible synonyms which may map to your MLS-specific statuses  - Active: Active Listing which is still on the market - ActiveUnderContract: An offer has been accepted but the listing is still on market. Synonyms: Accepting Backup Offers, Backup Offer, Active With Accepted. Synonyms: Offer, Backup, Contingent - Pending: An offer has been accepted and the listing is no longer on market. Synonyms: Offer Accepted, Under Contract - Hold: The listing has been withdrawn from the market, but a contract   still exists between the seller and the listing member. Synonyms: Hold, Hold Do Not Show, Temp Off Market - Withdrawn: The listing has been withdrawn from the market, but a contract   still exists between the seller and the listing member. Synonyms: Hold, Hold Do Not Show, Temp Off Market - Closed: The purchase agreement has been fulfilled or the lease   agreement has been executed. Synonyms: Sold, Leased, Rented, Closed Sale - Expired: The listing contract has expired - Delete: The listing contract was never valid or other reason for the contract to be nullified. Synonyms: Kill, Zap - Incomplete: The listing has not yet be completely entered and is not yet   published in the MLS. Synonyms: Draft, Partially Complted - ComingSoon 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    ACTIVE("Active"),
    
    ACTIVE_UNDER_CONTRACT_BACKUP_OFFER_("ActiveUnderContract (Backup-Offer)"),
    
    PENDING("Pending"),
    
    HOLD("Hold"),
    
    WITHDRAWN("Withdrawn"),
    
    CLOSED("Closed"),
    
    EXPIRED("Expired"),
    
    DELETE("Delete"),
    
    INCOMPLETE("Incomplete"),
    
    COMING_SOON("ComingSoon");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_STATUS_TEXT = "statusText";
  @SerializedName(SERIALIZED_NAME_STATUS_TEXT)
  private String statusText;

  public MlsInformation() {
  }

  public MlsInformation area(String area) {
    this.area = area;
    return this;
  }

  /**
   * MLS Area major. The major marketing area name, as defined by the MLS or other non-governmental organization.
   * @return area
   */
  @javax.annotation.Nullable
  public String getArea() {
    return area;
  }

  public void setArea(String area) {
    this.area = area;
  }


  public MlsInformation areaMinor(String areaMinor) {
    this.areaMinor = areaMinor;
    return this;
  }

  /**
   * MLS Area minor. The minor/sub marketing area name, as defined by the MLS or other non-governmental organization.
   * @return areaMinor
   */
  @javax.annotation.Nullable
  public String getAreaMinor() {
    return areaMinor;
  }

  public void setAreaMinor(String areaMinor) {
    this.areaMinor = areaMinor;
  }


  public MlsInformation daysOnMarket(Long daysOnMarket) {
    this.daysOnMarket = daysOnMarket;
    return this;
  }

  /**
   * Amount of days the property has been Active
   * @return daysOnMarket
   */
  @javax.annotation.Nullable
  public Long getDaysOnMarket() {
    return daysOnMarket;
  }

  public void setDaysOnMarket(Long daysOnMarket) {
    this.daysOnMarket = daysOnMarket;
  }


  public MlsInformation originatingSystemName(String originatingSystemName) {
    this.originatingSystemName = originatingSystemName;
    return this;
  }

  /**
   * Alias for the listing office or brokerage  This field corresponds to the data-dictionary &#x60;OriginatingSystemName&#x60; field  The name of the originating record provider.  Most commonly the name of the MLS. The place where the listing is originally input by the member.  The legal name of the company.  To be used for display.  If you&#39;re RETS provider aggregates feeds from multiple MLS&#39;s, this will be the name of the corresponding MLS. 
   * @return originatingSystemName
   */
  @javax.annotation.Nullable
  public String getOriginatingSystemName() {
    return originatingSystemName;
  }

  public void setOriginatingSystemName(String originatingSystemName) {
    this.originatingSystemName = originatingSystemName;
  }


  public MlsInformation status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * Normalized MLS Status Code. Compliant with data dictionary v1.3 ListingStatus Listing statuses depend on your MLS&#39;s availability. Below is a brief description of each status with possible synonyms which may map to your MLS-specific statuses  - Active: Active Listing which is still on the market - ActiveUnderContract: An offer has been accepted but the listing is still on market. Synonyms: Accepting Backup Offers, Backup Offer, Active With Accepted. Synonyms: Offer, Backup, Contingent - Pending: An offer has been accepted and the listing is no longer on market. Synonyms: Offer Accepted, Under Contract - Hold: The listing has been withdrawn from the market, but a contract   still exists between the seller and the listing member. Synonyms: Hold, Hold Do Not Show, Temp Off Market - Withdrawn: The listing has been withdrawn from the market, but a contract   still exists between the seller and the listing member. Synonyms: Hold, Hold Do Not Show, Temp Off Market - Closed: The purchase agreement has been fulfilled or the lease   agreement has been executed. Synonyms: Sold, Leased, Rented, Closed Sale - Expired: The listing contract has expired - Delete: The listing contract was never valid or other reason for the contract to be nullified. Synonyms: Kill, Zap - Incomplete: The listing has not yet be completely entered and is not yet   published in the MLS. Synonyms: Draft, Partially Complted - ComingSoon 
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  public MlsInformation statusText(String statusText) {
    this.statusText = statusText;
    return this;
  }

  /**
   * Raw MLS status text. This &#x60;field&#x60; comes directly from your RETS data field and is not normalized. 
   * @return statusText
   */
  @javax.annotation.Nullable
  public String getStatusText() {
    return statusText;
  }

  public void setStatusText(String statusText) {
    this.statusText = statusText;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MlsInformation mlsInformation = (MlsInformation) o;
    return Objects.equals(this.area, mlsInformation.area) &&
        Objects.equals(this.areaMinor, mlsInformation.areaMinor) &&
        Objects.equals(this.daysOnMarket, mlsInformation.daysOnMarket) &&
        Objects.equals(this.originatingSystemName, mlsInformation.originatingSystemName) &&
        Objects.equals(this.status, mlsInformation.status) &&
        Objects.equals(this.statusText, mlsInformation.statusText);
  }

  @Override
  public int hashCode() {
    return Objects.hash(area, areaMinor, daysOnMarket, originatingSystemName, status, statusText);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MlsInformation {\n");
    sb.append("    area: ").append(toIndentedString(area)).append("\n");
    sb.append("    areaMinor: ").append(toIndentedString(areaMinor)).append("\n");
    sb.append("    daysOnMarket: ").append(toIndentedString(daysOnMarket)).append("\n");
    sb.append("    originatingSystemName: ").append(toIndentedString(originatingSystemName)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusText: ").append(toIndentedString(statusText)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("area");
    openapiFields.add("areaMinor");
    openapiFields.add("daysOnMarket");
    openapiFields.add("originatingSystemName");
    openapiFields.add("status");
    openapiFields.add("statusText");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MlsInformation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MlsInformation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MlsInformation is not found in the empty JSON string", MlsInformation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MlsInformation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MlsInformation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("area") != null && !jsonObj.get("area").isJsonNull()) && !jsonObj.get("area").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `area` to be a primitive type in the JSON string but got `%s`", jsonObj.get("area").toString()));
      }
      if ((jsonObj.get("areaMinor") != null && !jsonObj.get("areaMinor").isJsonNull()) && !jsonObj.get("areaMinor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `areaMinor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("areaMinor").toString()));
      }
      if ((jsonObj.get("originatingSystemName") != null && !jsonObj.get("originatingSystemName").isJsonNull()) && !jsonObj.get("originatingSystemName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originatingSystemName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originatingSystemName").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("statusText") != null && !jsonObj.get("statusText").isJsonNull()) && !jsonObj.get("statusText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statusText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statusText").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MlsInformation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MlsInformation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MlsInformation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MlsInformation.class));

       return (TypeAdapter<T>) new TypeAdapter<MlsInformation>() {
           @Override
           public void write(JsonWriter out, MlsInformation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MlsInformation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MlsInformation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MlsInformation
   * @throws IOException if the JSON string is invalid with respect to MlsInformation
   */
  public static MlsInformation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MlsInformation.class);
  }

  /**
   * Convert an instance of MlsInformation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

