# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
import re
from openapi_server import util


class CreateStreamRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, device_name: str=None, stream_name: str=None, media_type: str=None, kms_key_id: str=None, data_retention_in_hours: int=None, tags: Dict[str, str]=None):
        """CreateStreamRequest - a model defined in OpenAPI

        :param device_name: The device_name of this CreateStreamRequest.
        :param stream_name: The stream_name of this CreateStreamRequest.
        :param media_type: The media_type of this CreateStreamRequest.
        :param kms_key_id: The kms_key_id of this CreateStreamRequest.
        :param data_retention_in_hours: The data_retention_in_hours of this CreateStreamRequest.
        :param tags: The tags of this CreateStreamRequest.
        """
        self.openapi_types = {
            'device_name': str,
            'stream_name': str,
            'media_type': str,
            'kms_key_id': str,
            'data_retention_in_hours': int,
            'tags': Dict[str, str]
        }

        self.attribute_map = {
            'device_name': 'DeviceName',
            'stream_name': 'StreamName',
            'media_type': 'MediaType',
            'kms_key_id': 'KmsKeyId',
            'data_retention_in_hours': 'DataRetentionInHours',
            'tags': 'Tags'
        }

        self._device_name = device_name
        self._stream_name = stream_name
        self._media_type = media_type
        self._kms_key_id = kms_key_id
        self._data_retention_in_hours = data_retention_in_hours
        self._tags = tags

    @classmethod
    def from_dict(cls, dikt: dict) -> 'CreateStreamRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The CreateStream_request of this CreateStreamRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def device_name(self):
        """Gets the device_name of this CreateStreamRequest.

        <p>The name of the device that is writing to the stream. </p> <note> <p>In the current implementation, Kinesis Video Streams does not use this name.</p> </note>

        :return: The device_name of this CreateStreamRequest.
        :rtype: str
        """
        return self._device_name

    @device_name.setter
    def device_name(self, device_name):
        """Sets the device_name of this CreateStreamRequest.

        <p>The name of the device that is writing to the stream. </p> <note> <p>In the current implementation, Kinesis Video Streams does not use this name.</p> </note>

        :param device_name: The device_name of this CreateStreamRequest.
        :type device_name: str
        """
        if device_name is not None and len(device_name) > 128:
            raise ValueError("Invalid value for `device_name`, length must be less than or equal to `128`")
        if device_name is not None and len(device_name) < 1:
            raise ValueError("Invalid value for `device_name`, length must be greater than or equal to `1`")
        if device_name is not None and not re.search(r'[a-zA-Z0-9_.-]+', device_name):
            raise ValueError("Invalid value for `device_name`, must be a follow pattern or equal to `/[a-zA-Z0-9_.-]+/`")

        self._device_name = device_name

    @property
    def stream_name(self):
        """Gets the stream_name of this CreateStreamRequest.

        <p>A name for the stream that you are creating.</p> <p>The stream name is an identifier for the stream, and must be unique for each account and region.</p>

        :return: The stream_name of this CreateStreamRequest.
        :rtype: str
        """
        return self._stream_name

    @stream_name.setter
    def stream_name(self, stream_name):
        """Sets the stream_name of this CreateStreamRequest.

        <p>A name for the stream that you are creating.</p> <p>The stream name is an identifier for the stream, and must be unique for each account and region.</p>

        :param stream_name: The stream_name of this CreateStreamRequest.
        :type stream_name: str
        """
        if stream_name is None:
            raise ValueError("Invalid value for `stream_name`, must not be `None`")
        if stream_name is not None and len(stream_name) > 256:
            raise ValueError("Invalid value for `stream_name`, length must be less than or equal to `256`")
        if stream_name is not None and len(stream_name) < 1:
            raise ValueError("Invalid value for `stream_name`, length must be greater than or equal to `1`")
        if stream_name is not None and not re.search(r'[a-zA-Z0-9_.-]+', stream_name):
            raise ValueError("Invalid value for `stream_name`, must be a follow pattern or equal to `/[a-zA-Z0-9_.-]+/`")

        self._stream_name = stream_name

    @property
    def media_type(self):
        """Gets the media_type of this CreateStreamRequest.

        <p>The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see <a href=\"http://www.iana.org/assignments/media-types/media-types.xhtml\">Media Types</a>. If you choose to specify the <code>MediaType</code>, see <a href=\"https://tools.ietf.org/html/rfc6838#section-4.2\">Naming Requirements</a> for guidelines.</p> <p>Example valid values include \"video/h264\" and \"video/h264,audio/aac\".</p> <p>This parameter is optional; the default value is <code>null</code> (or empty in JSON).</p>

        :return: The media_type of this CreateStreamRequest.
        :rtype: str
        """
        return self._media_type

    @media_type.setter
    def media_type(self, media_type):
        """Sets the media_type of this CreateStreamRequest.

        <p>The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see <a href=\"http://www.iana.org/assignments/media-types/media-types.xhtml\">Media Types</a>. If you choose to specify the <code>MediaType</code>, see <a href=\"https://tools.ietf.org/html/rfc6838#section-4.2\">Naming Requirements</a> for guidelines.</p> <p>Example valid values include \"video/h264\" and \"video/h264,audio/aac\".</p> <p>This parameter is optional; the default value is <code>null</code> (or empty in JSON).</p>

        :param media_type: The media_type of this CreateStreamRequest.
        :type media_type: str
        """
        if media_type is not None and len(media_type) > 128:
            raise ValueError("Invalid value for `media_type`, length must be less than or equal to `128`")
        if media_type is not None and len(media_type) < 1:
            raise ValueError("Invalid value for `media_type`, length must be greater than or equal to `1`")
        if media_type is not None and not re.search(r'[\w\-\.\+]+\/[\w\-\.\+]+(,[\w\-\.\+]+\/[\w\-\.\+]+)*', media_type):
            raise ValueError("Invalid value for `media_type`, must be a follow pattern or equal to `/[\w\-\.\+]+\/[\w\-\.\+]+(,[\w\-\.\+]+\/[\w\-\.\+]+)*/`")

        self._media_type = media_type

    @property
    def kms_key_id(self):
        """Gets the kms_key_id of this CreateStreamRequest.

        <p>The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data.</p> <p>If no key ID is specified, the default, Kinesis Video-managed key (<code>Amazon Web Services/kinesisvideo</code>) is used.</p> <p> For more information, see <a href=\"https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters\">DescribeKey</a>. </p>

        :return: The kms_key_id of this CreateStreamRequest.
        :rtype: str
        """
        return self._kms_key_id

    @kms_key_id.setter
    def kms_key_id(self, kms_key_id):
        """Sets the kms_key_id of this CreateStreamRequest.

        <p>The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data.</p> <p>If no key ID is specified, the default, Kinesis Video-managed key (<code>Amazon Web Services/kinesisvideo</code>) is used.</p> <p> For more information, see <a href=\"https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters\">DescribeKey</a>. </p>

        :param kms_key_id: The kms_key_id of this CreateStreamRequest.
        :type kms_key_id: str
        """
        if kms_key_id is not None and len(kms_key_id) > 2048:
            raise ValueError("Invalid value for `kms_key_id`, length must be less than or equal to `2048`")
        if kms_key_id is not None and len(kms_key_id) < 1:
            raise ValueError("Invalid value for `kms_key_id`, length must be greater than or equal to `1`")
        if kms_key_id is not None and not re.search(r'.+', kms_key_id):
            raise ValueError("Invalid value for `kms_key_id`, must be a follow pattern or equal to `/.+/`")

        self._kms_key_id = kms_key_id

    @property
    def data_retention_in_hours(self):
        """Gets the data_retention_in_hours of this CreateStreamRequest.

        <p>The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p> <p>The default value is 0, indicating that the stream does not persist data.</p> <p>When the <code>DataRetentionInHours</code> value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.</p>

        :return: The data_retention_in_hours of this CreateStreamRequest.
        :rtype: int
        """
        return self._data_retention_in_hours

    @data_retention_in_hours.setter
    def data_retention_in_hours(self, data_retention_in_hours):
        """Sets the data_retention_in_hours of this CreateStreamRequest.

        <p>The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p> <p>The default value is 0, indicating that the stream does not persist data.</p> <p>When the <code>DataRetentionInHours</code> value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.</p>

        :param data_retention_in_hours: The data_retention_in_hours of this CreateStreamRequest.
        :type data_retention_in_hours: int
        """
        if data_retention_in_hours is not None and data_retention_in_hours < 0:
            raise ValueError("Invalid value for `data_retention_in_hours`, must be a value greater than or equal to `0`")

        self._data_retention_in_hours = data_retention_in_hours

    @property
    def tags(self):
        """Gets the tags of this CreateStreamRequest.

        A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).

        :return: The tags of this CreateStreamRequest.
        :rtype: Dict[str, str]
        """
        return self._tags

    @tags.setter
    def tags(self, tags):
        """Sets the tags of this CreateStreamRequest.

        A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).

        :param tags: The tags of this CreateStreamRequest.
        :type tags: Dict[str, str]
        """
        if tags is not None and len(tags) > 50:
            raise ValueError("Invalid value for `tags`, number of items must be less than or equal to `50`")
        if tags is not None and len(tags) < 1:
            raise ValueError("Invalid value for `tags`, number of items must be greater than or equal to `1`")

        self._tags = tags
