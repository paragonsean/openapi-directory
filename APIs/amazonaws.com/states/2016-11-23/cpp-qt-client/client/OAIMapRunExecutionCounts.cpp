/**
 * AWS Step Functions
 * <fullname>Step Functions</fullname> <p>Step Functions is a service that lets you coordinate the components of distributed applications and microservices using visual workflows.</p> <p>You can use Step Functions to build applications from individual components, each of which performs a discrete function, or <i>task</i>, allowing you to scale and change applications quickly. Step Functions provides a console that helps visualize the components of your application as a series of steps. Step Functions automatically triggers and tracks each step, and retries steps when there are errors, so your application executes predictably and in the right order every time. Step Functions logs the state of each step, so you can quickly diagnose and debug any issues.</p> <p>Step Functions manages operations and underlying infrastructure to ensure your application is available at any scale. You can run tasks on Amazon Web Services, your own servers, or any system that has access to Amazon Web Services. You can access and use Step Functions using the console, the Amazon Web Services SDKs, or an HTTP API. For more information about Step Functions, see the <i> <a href=\"https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html\">Step Functions Developer Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2016-11-23
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMapRunExecutionCounts.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMapRunExecutionCounts::OAIMapRunExecutionCounts(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMapRunExecutionCounts::OAIMapRunExecutionCounts() {
    this->initializeModel();
}

OAIMapRunExecutionCounts::~OAIMapRunExecutionCounts() {}

void OAIMapRunExecutionCounts::initializeModel() {

    m_pending_isSet = false;
    m_pending_isValid = false;

    m_running_isSet = false;
    m_running_isValid = false;

    m_succeeded_isSet = false;
    m_succeeded_isValid = false;

    m_failed_isSet = false;
    m_failed_isValid = false;

    m_timed_out_isSet = false;
    m_timed_out_isValid = false;

    m_aborted_isSet = false;
    m_aborted_isValid = false;

    m_total_isSet = false;
    m_total_isValid = false;

    m_results_written_isSet = false;
    m_results_written_isValid = false;
}

void OAIMapRunExecutionCounts::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMapRunExecutionCounts::fromJsonObject(QJsonObject json) {

    m_pending_isValid = ::OpenAPI::fromJsonValue(m_pending, json[QString("pending")]);
    m_pending_isSet = !json[QString("pending")].isNull() && m_pending_isValid;

    m_running_isValid = ::OpenAPI::fromJsonValue(m_running, json[QString("running")]);
    m_running_isSet = !json[QString("running")].isNull() && m_running_isValid;

    m_succeeded_isValid = ::OpenAPI::fromJsonValue(m_succeeded, json[QString("succeeded")]);
    m_succeeded_isSet = !json[QString("succeeded")].isNull() && m_succeeded_isValid;

    m_failed_isValid = ::OpenAPI::fromJsonValue(m_failed, json[QString("failed")]);
    m_failed_isSet = !json[QString("failed")].isNull() && m_failed_isValid;

    m_timed_out_isValid = ::OpenAPI::fromJsonValue(m_timed_out, json[QString("timedOut")]);
    m_timed_out_isSet = !json[QString("timedOut")].isNull() && m_timed_out_isValid;

    m_aborted_isValid = ::OpenAPI::fromJsonValue(m_aborted, json[QString("aborted")]);
    m_aborted_isSet = !json[QString("aborted")].isNull() && m_aborted_isValid;

    m_total_isValid = ::OpenAPI::fromJsonValue(m_total, json[QString("total")]);
    m_total_isSet = !json[QString("total")].isNull() && m_total_isValid;

    m_results_written_isValid = ::OpenAPI::fromJsonValue(m_results_written, json[QString("resultsWritten")]);
    m_results_written_isSet = !json[QString("resultsWritten")].isNull() && m_results_written_isValid;
}

QString OAIMapRunExecutionCounts::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMapRunExecutionCounts::asJsonObject() const {
    QJsonObject obj;
    if (m_pending_isSet) {
        obj.insert(QString("pending"), ::OpenAPI::toJsonValue(m_pending));
    }
    if (m_running_isSet) {
        obj.insert(QString("running"), ::OpenAPI::toJsonValue(m_running));
    }
    if (m_succeeded_isSet) {
        obj.insert(QString("succeeded"), ::OpenAPI::toJsonValue(m_succeeded));
    }
    if (m_failed_isSet) {
        obj.insert(QString("failed"), ::OpenAPI::toJsonValue(m_failed));
    }
    if (m_timed_out_isSet) {
        obj.insert(QString("timedOut"), ::OpenAPI::toJsonValue(m_timed_out));
    }
    if (m_aborted_isSet) {
        obj.insert(QString("aborted"), ::OpenAPI::toJsonValue(m_aborted));
    }
    if (m_total_isSet) {
        obj.insert(QString("total"), ::OpenAPI::toJsonValue(m_total));
    }
    if (m_results_written_isSet) {
        obj.insert(QString("resultsWritten"), ::OpenAPI::toJsonValue(m_results_written));
    }
    return obj;
}

qint32 OAIMapRunExecutionCounts::getPending() const {
    return m_pending;
}
void OAIMapRunExecutionCounts::setPending(const qint32 &pending) {
    m_pending = pending;
    m_pending_isSet = true;
}

bool OAIMapRunExecutionCounts::is_pending_Set() const{
    return m_pending_isSet;
}

bool OAIMapRunExecutionCounts::is_pending_Valid() const{
    return m_pending_isValid;
}

qint32 OAIMapRunExecutionCounts::getRunning() const {
    return m_running;
}
void OAIMapRunExecutionCounts::setRunning(const qint32 &running) {
    m_running = running;
    m_running_isSet = true;
}

bool OAIMapRunExecutionCounts::is_running_Set() const{
    return m_running_isSet;
}

bool OAIMapRunExecutionCounts::is_running_Valid() const{
    return m_running_isValid;
}

qint32 OAIMapRunExecutionCounts::getSucceeded() const {
    return m_succeeded;
}
void OAIMapRunExecutionCounts::setSucceeded(const qint32 &succeeded) {
    m_succeeded = succeeded;
    m_succeeded_isSet = true;
}

bool OAIMapRunExecutionCounts::is_succeeded_Set() const{
    return m_succeeded_isSet;
}

bool OAIMapRunExecutionCounts::is_succeeded_Valid() const{
    return m_succeeded_isValid;
}

qint32 OAIMapRunExecutionCounts::getFailed() const {
    return m_failed;
}
void OAIMapRunExecutionCounts::setFailed(const qint32 &failed) {
    m_failed = failed;
    m_failed_isSet = true;
}

bool OAIMapRunExecutionCounts::is_failed_Set() const{
    return m_failed_isSet;
}

bool OAIMapRunExecutionCounts::is_failed_Valid() const{
    return m_failed_isValid;
}

qint32 OAIMapRunExecutionCounts::getTimedOut() const {
    return m_timed_out;
}
void OAIMapRunExecutionCounts::setTimedOut(const qint32 &timed_out) {
    m_timed_out = timed_out;
    m_timed_out_isSet = true;
}

bool OAIMapRunExecutionCounts::is_timed_out_Set() const{
    return m_timed_out_isSet;
}

bool OAIMapRunExecutionCounts::is_timed_out_Valid() const{
    return m_timed_out_isValid;
}

qint32 OAIMapRunExecutionCounts::getAborted() const {
    return m_aborted;
}
void OAIMapRunExecutionCounts::setAborted(const qint32 &aborted) {
    m_aborted = aborted;
    m_aborted_isSet = true;
}

bool OAIMapRunExecutionCounts::is_aborted_Set() const{
    return m_aborted_isSet;
}

bool OAIMapRunExecutionCounts::is_aborted_Valid() const{
    return m_aborted_isValid;
}

qint32 OAIMapRunExecutionCounts::getTotal() const {
    return m_total;
}
void OAIMapRunExecutionCounts::setTotal(const qint32 &total) {
    m_total = total;
    m_total_isSet = true;
}

bool OAIMapRunExecutionCounts::is_total_Set() const{
    return m_total_isSet;
}

bool OAIMapRunExecutionCounts::is_total_Valid() const{
    return m_total_isValid;
}

qint32 OAIMapRunExecutionCounts::getResultsWritten() const {
    return m_results_written;
}
void OAIMapRunExecutionCounts::setResultsWritten(const qint32 &results_written) {
    m_results_written = results_written;
    m_results_written_isSet = true;
}

bool OAIMapRunExecutionCounts::is_results_written_Set() const{
    return m_results_written_isSet;
}

bool OAIMapRunExecutionCounts::is_results_written_Valid() const{
    return m_results_written_isValid;
}

bool OAIMapRunExecutionCounts::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_pending_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_running_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_succeeded_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_failed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timed_out_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aborted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_results_written_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMapRunExecutionCounts::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_pending_isValid && m_running_isValid && m_succeeded_isValid && m_failed_isValid && m_timed_out_isValid && m_aborted_isValid && m_total_isValid && m_results_written_isValid && true;
}

} // namespace OpenAPI
