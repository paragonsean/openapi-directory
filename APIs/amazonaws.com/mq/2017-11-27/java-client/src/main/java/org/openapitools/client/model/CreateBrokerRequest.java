/*
 * AmazonMQ
 * Amazon MQ is a managed message broker service for Apache ActiveMQ and RabbitMQ that makes it easy to set up and operate message brokers in the cloud. A message broker allows software applications and components to communicate using various programming languages, operating systems, and formal messaging protocols.
 *
 * The version of the OpenAPI document: 2017-11-27
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.CreateBrokerRequestConfiguration;
import org.openapitools.client.model.CreateBrokerRequestEncryptionOptions;
import org.openapitools.client.model.CreateBrokerRequestLdapServerMetadata;
import org.openapitools.client.model.CreateBrokerRequestLogs;
import org.openapitools.client.model.CreateBrokerRequestMaintenanceWindowStartTime;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateBrokerRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:00:52.574212-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateBrokerRequest {
  /**
   * Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
   */
  @JsonAdapter(AuthenticationStrategyEnum.Adapter.class)
  public enum AuthenticationStrategyEnum {
    SIMPLE("SIMPLE"),
    
    LDAP("LDAP");

    private String value;

    AuthenticationStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AuthenticationStrategyEnum fromValue(String value) {
      for (AuthenticationStrategyEnum b : AuthenticationStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AuthenticationStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthenticationStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthenticationStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AuthenticationStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AuthenticationStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AUTHENTICATION_STRATEGY = "authenticationStrategy";
  @SerializedName(SERIALIZED_NAME_AUTHENTICATION_STRATEGY)
  private AuthenticationStrategyEnum authenticationStrategy;

  public static final String SERIALIZED_NAME_AUTO_MINOR_VERSION_UPGRADE = "autoMinorVersionUpgrade";
  @SerializedName(SERIALIZED_NAME_AUTO_MINOR_VERSION_UPGRADE)
  private Boolean autoMinorVersionUpgrade;

  public static final String SERIALIZED_NAME_BROKER_NAME = "brokerName";
  @SerializedName(SERIALIZED_NAME_BROKER_NAME)
  private String brokerName;

  public static final String SERIALIZED_NAME_CONFIGURATION = "configuration";
  @SerializedName(SERIALIZED_NAME_CONFIGURATION)
  private CreateBrokerRequestConfiguration _configuration;

  public static final String SERIALIZED_NAME_CREATOR_REQUEST_ID = "creatorRequestId";
  @SerializedName(SERIALIZED_NAME_CREATOR_REQUEST_ID)
  private String creatorRequestId;

  /**
   * The broker&#39;s deployment mode.
   */
  @JsonAdapter(DeploymentModeEnum.Adapter.class)
  public enum DeploymentModeEnum {
    SINGLE_INSTANCE("SINGLE_INSTANCE"),
    
    ACTIVE_STANDBY_MULTI_AZ("ACTIVE_STANDBY_MULTI_AZ"),
    
    CLUSTER_MULTI_AZ("CLUSTER_MULTI_AZ");

    private String value;

    DeploymentModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeploymentModeEnum fromValue(String value) {
      for (DeploymentModeEnum b : DeploymentModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeploymentModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeploymentModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeploymentModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeploymentModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeploymentModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEPLOYMENT_MODE = "deploymentMode";
  @SerializedName(SERIALIZED_NAME_DEPLOYMENT_MODE)
  private DeploymentModeEnum deploymentMode;

  public static final String SERIALIZED_NAME_ENCRYPTION_OPTIONS = "encryptionOptions";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_OPTIONS)
  private CreateBrokerRequestEncryptionOptions encryptionOptions;

  /**
   * The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
   */
  @JsonAdapter(EngineTypeEnum.Adapter.class)
  public enum EngineTypeEnum {
    ACTIVEMQ("ACTIVEMQ"),
    
    RABBITMQ("RABBITMQ");

    private String value;

    EngineTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EngineTypeEnum fromValue(String value) {
      for (EngineTypeEnum b : EngineTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EngineTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EngineTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EngineTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EngineTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EngineTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ENGINE_TYPE = "engineType";
  @SerializedName(SERIALIZED_NAME_ENGINE_TYPE)
  private EngineTypeEnum engineType;

  public static final String SERIALIZED_NAME_ENGINE_VERSION = "engineVersion";
  @SerializedName(SERIALIZED_NAME_ENGINE_VERSION)
  private String engineVersion;

  public static final String SERIALIZED_NAME_HOST_INSTANCE_TYPE = "hostInstanceType";
  @SerializedName(SERIALIZED_NAME_HOST_INSTANCE_TYPE)
  private String hostInstanceType;

  public static final String SERIALIZED_NAME_LDAP_SERVER_METADATA = "ldapServerMetadata";
  @SerializedName(SERIALIZED_NAME_LDAP_SERVER_METADATA)
  private CreateBrokerRequestLdapServerMetadata ldapServerMetadata;

  public static final String SERIALIZED_NAME_LOGS = "logs";
  @SerializedName(SERIALIZED_NAME_LOGS)
  private CreateBrokerRequestLogs logs;

  public static final String SERIALIZED_NAME_MAINTENANCE_WINDOW_START_TIME = "maintenanceWindowStartTime";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_WINDOW_START_TIME)
  private CreateBrokerRequestMaintenanceWindowStartTime maintenanceWindowStartTime;

  public static final String SERIALIZED_NAME_PUBLICLY_ACCESSIBLE = "publiclyAccessible";
  @SerializedName(SERIALIZED_NAME_PUBLICLY_ACCESSIBLE)
  private Boolean publiclyAccessible;

  public static final String SERIALIZED_NAME_SECURITY_GROUPS = "securityGroups";
  @SerializedName(SERIALIZED_NAME_SECURITY_GROUPS)
  private List<String> securityGroups = new ArrayList<>();

  /**
   * &lt;p&gt;The broker&#39;s storage type.&lt;/p&gt; &lt;important&gt;&lt;p&gt;EFS is not supported for RabbitMQ engine type.&lt;/p&gt;&lt;/important&gt;
   */
  @JsonAdapter(StorageTypeEnum.Adapter.class)
  public enum StorageTypeEnum {
    EBS("EBS"),
    
    EFS("EFS");

    private String value;

    StorageTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StorageTypeEnum fromValue(String value) {
      for (StorageTypeEnum b : StorageTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StorageTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StorageTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StorageTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StorageTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StorageTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STORAGE_TYPE = "storageType";
  @SerializedName(SERIALIZED_NAME_STORAGE_TYPE)
  private StorageTypeEnum storageType;

  public static final String SERIALIZED_NAME_SUBNET_IDS = "subnetIds";
  @SerializedName(SERIALIZED_NAME_SUBNET_IDS)
  private List<String> subnetIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private Map<String, String> tags = new HashMap<>();

  public static final String SERIALIZED_NAME_USERS = "users";
  @SerializedName(SERIALIZED_NAME_USERS)
  private List<User> users = new ArrayList<>();

  /**
   * Specifies whether a broker is a part of a data replication pair.
   */
  @JsonAdapter(DataReplicationModeEnum.Adapter.class)
  public enum DataReplicationModeEnum {
    NONE("NONE"),
    
    CRDR("CRDR");

    private String value;

    DataReplicationModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataReplicationModeEnum fromValue(String value) {
      for (DataReplicationModeEnum b : DataReplicationModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataReplicationModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataReplicationModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataReplicationModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataReplicationModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataReplicationModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_REPLICATION_MODE = "dataReplicationMode";
  @SerializedName(SERIALIZED_NAME_DATA_REPLICATION_MODE)
  private DataReplicationModeEnum dataReplicationMode;

  public static final String SERIALIZED_NAME_DATA_REPLICATION_PRIMARY_BROKER_ARN = "dataReplicationPrimaryBrokerArn";
  @SerializedName(SERIALIZED_NAME_DATA_REPLICATION_PRIMARY_BROKER_ARN)
  private String dataReplicationPrimaryBrokerArn;

  public CreateBrokerRequest() {
  }

  public CreateBrokerRequest authenticationStrategy(AuthenticationStrategyEnum authenticationStrategy) {
    this.authenticationStrategy = authenticationStrategy;
    return this;
  }

  /**
   * Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
   * @return authenticationStrategy
   */
  @javax.annotation.Nullable
  public AuthenticationStrategyEnum getAuthenticationStrategy() {
    return authenticationStrategy;
  }

  public void setAuthenticationStrategy(AuthenticationStrategyEnum authenticationStrategy) {
    this.authenticationStrategy = authenticationStrategy;
  }


  public CreateBrokerRequest autoMinorVersionUpgrade(Boolean autoMinorVersionUpgrade) {
    this.autoMinorVersionUpgrade = autoMinorVersionUpgrade;
    return this;
  }

  /**
   * Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot. Set to true by default, if no value is specified.
   * @return autoMinorVersionUpgrade
   */
  @javax.annotation.Nonnull
  public Boolean getAutoMinorVersionUpgrade() {
    return autoMinorVersionUpgrade;
  }

  public void setAutoMinorVersionUpgrade(Boolean autoMinorVersionUpgrade) {
    this.autoMinorVersionUpgrade = autoMinorVersionUpgrade;
  }


  public CreateBrokerRequest brokerName(String brokerName) {
    this.brokerName = brokerName;
    return this;
  }

  /**
   * &lt;p&gt;Required. The broker&#39;s name. This value must be unique in your Amazon Web Services account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.&lt;/p&gt; &lt;important&gt;&lt;p&gt;Do not add personally identifiable information (PII) or other confidential or sensitive information in broker names. Broker names are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker names are not intended to be used for private or sensitive data.&lt;/p&gt;&lt;/important&gt;
   * @return brokerName
   */
  @javax.annotation.Nonnull
  public String getBrokerName() {
    return brokerName;
  }

  public void setBrokerName(String brokerName) {
    this.brokerName = brokerName;
  }


  public CreateBrokerRequest _configuration(CreateBrokerRequestConfiguration _configuration) {
    this._configuration = _configuration;
    return this;
  }

  /**
   * Get _configuration
   * @return _configuration
   */
  @javax.annotation.Nullable
  public CreateBrokerRequestConfiguration getConfiguration() {
    return _configuration;
  }

  public void setConfiguration(CreateBrokerRequestConfiguration _configuration) {
    this._configuration = _configuration;
  }


  public CreateBrokerRequest creatorRequestId(String creatorRequestId) {
    this.creatorRequestId = creatorRequestId;
    return this;
  }

  /**
   * &lt;p&gt;The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action.&lt;/p&gt; &lt;note&gt;&lt;p&gt;We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn&#39;t require idempotency.&lt;/p&gt;&lt;/note&gt;
   * @return creatorRequestId
   */
  @javax.annotation.Nullable
  public String getCreatorRequestId() {
    return creatorRequestId;
  }

  public void setCreatorRequestId(String creatorRequestId) {
    this.creatorRequestId = creatorRequestId;
  }


  public CreateBrokerRequest deploymentMode(DeploymentModeEnum deploymentMode) {
    this.deploymentMode = deploymentMode;
    return this;
  }

  /**
   * The broker&#39;s deployment mode.
   * @return deploymentMode
   */
  @javax.annotation.Nonnull
  public DeploymentModeEnum getDeploymentMode() {
    return deploymentMode;
  }

  public void setDeploymentMode(DeploymentModeEnum deploymentMode) {
    this.deploymentMode = deploymentMode;
  }


  public CreateBrokerRequest encryptionOptions(CreateBrokerRequestEncryptionOptions encryptionOptions) {
    this.encryptionOptions = encryptionOptions;
    return this;
  }

  /**
   * Get encryptionOptions
   * @return encryptionOptions
   */
  @javax.annotation.Nullable
  public CreateBrokerRequestEncryptionOptions getEncryptionOptions() {
    return encryptionOptions;
  }

  public void setEncryptionOptions(CreateBrokerRequestEncryptionOptions encryptionOptions) {
    this.encryptionOptions = encryptionOptions;
  }


  public CreateBrokerRequest engineType(EngineTypeEnum engineType) {
    this.engineType = engineType;
    return this;
  }

  /**
   * The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
   * @return engineType
   */
  @javax.annotation.Nonnull
  public EngineTypeEnum getEngineType() {
    return engineType;
  }

  public void setEngineType(EngineTypeEnum engineType) {
    this.engineType = engineType;
  }


  public CreateBrokerRequest engineVersion(String engineVersion) {
    this.engineVersion = engineVersion;
    return this;
  }

  /**
   * Required. The broker engine&#39;s version. For a list of supported engine versions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html\&quot;&gt;Supported engines&lt;/a&gt;.
   * @return engineVersion
   */
  @javax.annotation.Nonnull
  public String getEngineVersion() {
    return engineVersion;
  }

  public void setEngineVersion(String engineVersion) {
    this.engineVersion = engineVersion;
  }


  public CreateBrokerRequest hostInstanceType(String hostInstanceType) {
    this.hostInstanceType = hostInstanceType;
    return this;
  }

  /**
   * Required. The broker&#39;s instance type.
   * @return hostInstanceType
   */
  @javax.annotation.Nonnull
  public String getHostInstanceType() {
    return hostInstanceType;
  }

  public void setHostInstanceType(String hostInstanceType) {
    this.hostInstanceType = hostInstanceType;
  }


  public CreateBrokerRequest ldapServerMetadata(CreateBrokerRequestLdapServerMetadata ldapServerMetadata) {
    this.ldapServerMetadata = ldapServerMetadata;
    return this;
  }

  /**
   * Get ldapServerMetadata
   * @return ldapServerMetadata
   */
  @javax.annotation.Nullable
  public CreateBrokerRequestLdapServerMetadata getLdapServerMetadata() {
    return ldapServerMetadata;
  }

  public void setLdapServerMetadata(CreateBrokerRequestLdapServerMetadata ldapServerMetadata) {
    this.ldapServerMetadata = ldapServerMetadata;
  }


  public CreateBrokerRequest logs(CreateBrokerRequestLogs logs) {
    this.logs = logs;
    return this;
  }

  /**
   * Get logs
   * @return logs
   */
  @javax.annotation.Nullable
  public CreateBrokerRequestLogs getLogs() {
    return logs;
  }

  public void setLogs(CreateBrokerRequestLogs logs) {
    this.logs = logs;
  }


  public CreateBrokerRequest maintenanceWindowStartTime(CreateBrokerRequestMaintenanceWindowStartTime maintenanceWindowStartTime) {
    this.maintenanceWindowStartTime = maintenanceWindowStartTime;
    return this;
  }

  /**
   * Get maintenanceWindowStartTime
   * @return maintenanceWindowStartTime
   */
  @javax.annotation.Nullable
  public CreateBrokerRequestMaintenanceWindowStartTime getMaintenanceWindowStartTime() {
    return maintenanceWindowStartTime;
  }

  public void setMaintenanceWindowStartTime(CreateBrokerRequestMaintenanceWindowStartTime maintenanceWindowStartTime) {
    this.maintenanceWindowStartTime = maintenanceWindowStartTime;
  }


  public CreateBrokerRequest publiclyAccessible(Boolean publiclyAccessible) {
    this.publiclyAccessible = publiclyAccessible;
    return this;
  }

  /**
   * Enables connections from applications outside of the VPC that hosts the broker&#39;s subnets. Set to false by default, if no value is provided.
   * @return publiclyAccessible
   */
  @javax.annotation.Nonnull
  public Boolean getPubliclyAccessible() {
    return publiclyAccessible;
  }

  public void setPubliclyAccessible(Boolean publiclyAccessible) {
    this.publiclyAccessible = publiclyAccessible;
  }


  public CreateBrokerRequest securityGroups(List<String> securityGroups) {
    this.securityGroups = securityGroups;
    return this;
  }

  public CreateBrokerRequest addSecurityGroupsItem(String securityGroupsItem) {
    if (this.securityGroups == null) {
      this.securityGroups = new ArrayList<>();
    }
    this.securityGroups.add(securityGroupsItem);
    return this;
  }

  /**
   * The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
   * @return securityGroups
   */
  @javax.annotation.Nullable
  public List<String> getSecurityGroups() {
    return securityGroups;
  }

  public void setSecurityGroups(List<String> securityGroups) {
    this.securityGroups = securityGroups;
  }


  public CreateBrokerRequest storageType(StorageTypeEnum storageType) {
    this.storageType = storageType;
    return this;
  }

  /**
   * &lt;p&gt;The broker&#39;s storage type.&lt;/p&gt; &lt;important&gt;&lt;p&gt;EFS is not supported for RabbitMQ engine type.&lt;/p&gt;&lt;/important&gt;
   * @return storageType
   */
  @javax.annotation.Nullable
  public StorageTypeEnum getStorageType() {
    return storageType;
  }

  public void setStorageType(StorageTypeEnum storageType) {
    this.storageType = storageType;
  }


  public CreateBrokerRequest subnetIds(List<String> subnetIds) {
    this.subnetIds = subnetIds;
    return this;
  }

  public CreateBrokerRequest addSubnetIdsItem(String subnetIdsItem) {
    if (this.subnetIds == null) {
      this.subnetIds = new ArrayList<>();
    }
    this.subnetIds.add(subnetIdsItem);
    return this;
  }

  /**
   * &lt;p&gt;The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet.&lt;/p&gt; &lt;important&gt;&lt;p&gt;If you specify subnets in a &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/vpc/latest/userguide/vpc-sharing.html\&quot;&gt;shared VPC&lt;/a&gt; for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your Amazon Web Services account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your Amazon Web Services account.&lt;/p&gt;&lt;/important&gt;
   * @return subnetIds
   */
  @javax.annotation.Nullable
  public List<String> getSubnetIds() {
    return subnetIds;
  }

  public void setSubnetIds(List<String> subnetIds) {
    this.subnetIds = subnetIds;
  }


  public CreateBrokerRequest tags(Map<String, String> tags) {
    this.tags = tags;
    return this;
  }

  public CreateBrokerRequest putTagsItem(String key, String tagsItem) {
    if (this.tags == null) {
      this.tags = new HashMap<>();
    }
    this.tags.put(key, tagsItem);
    return this;
  }

  /**
   * Create tags when creating the broker.
   * @return tags
   */
  @javax.annotation.Nullable
  public Map<String, String> getTags() {
    return tags;
  }

  public void setTags(Map<String, String> tags) {
    this.tags = tags;
  }


  public CreateBrokerRequest users(List<User> users) {
    this.users = users;
    return this;
  }

  public CreateBrokerRequest addUsersItem(User usersItem) {
    if (this.users == null) {
      this.users = new ArrayList<>();
    }
    this.users.add(usersItem);
    return this;
  }

  /**
   * The list of broker users (persons or applications) who can access queues and topics. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
   * @return users
   */
  @javax.annotation.Nonnull
  public List<User> getUsers() {
    return users;
  }

  public void setUsers(List<User> users) {
    this.users = users;
  }


  public CreateBrokerRequest dataReplicationMode(DataReplicationModeEnum dataReplicationMode) {
    this.dataReplicationMode = dataReplicationMode;
    return this;
  }

  /**
   * Specifies whether a broker is a part of a data replication pair.
   * @return dataReplicationMode
   */
  @javax.annotation.Nullable
  public DataReplicationModeEnum getDataReplicationMode() {
    return dataReplicationMode;
  }

  public void setDataReplicationMode(DataReplicationModeEnum dataReplicationMode) {
    this.dataReplicationMode = dataReplicationMode;
  }


  public CreateBrokerRequest dataReplicationPrimaryBrokerArn(String dataReplicationPrimaryBrokerArn) {
    this.dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArn;
    return this;
  }

  /**
   * The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when dataReplicationMode is set to CRDR.
   * @return dataReplicationPrimaryBrokerArn
   */
  @javax.annotation.Nullable
  public String getDataReplicationPrimaryBrokerArn() {
    return dataReplicationPrimaryBrokerArn;
  }

  public void setDataReplicationPrimaryBrokerArn(String dataReplicationPrimaryBrokerArn) {
    this.dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArn;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateBrokerRequest createBrokerRequest = (CreateBrokerRequest) o;
    return Objects.equals(this.authenticationStrategy, createBrokerRequest.authenticationStrategy) &&
        Objects.equals(this.autoMinorVersionUpgrade, createBrokerRequest.autoMinorVersionUpgrade) &&
        Objects.equals(this.brokerName, createBrokerRequest.brokerName) &&
        Objects.equals(this._configuration, createBrokerRequest._configuration) &&
        Objects.equals(this.creatorRequestId, createBrokerRequest.creatorRequestId) &&
        Objects.equals(this.deploymentMode, createBrokerRequest.deploymentMode) &&
        Objects.equals(this.encryptionOptions, createBrokerRequest.encryptionOptions) &&
        Objects.equals(this.engineType, createBrokerRequest.engineType) &&
        Objects.equals(this.engineVersion, createBrokerRequest.engineVersion) &&
        Objects.equals(this.hostInstanceType, createBrokerRequest.hostInstanceType) &&
        Objects.equals(this.ldapServerMetadata, createBrokerRequest.ldapServerMetadata) &&
        Objects.equals(this.logs, createBrokerRequest.logs) &&
        Objects.equals(this.maintenanceWindowStartTime, createBrokerRequest.maintenanceWindowStartTime) &&
        Objects.equals(this.publiclyAccessible, createBrokerRequest.publiclyAccessible) &&
        Objects.equals(this.securityGroups, createBrokerRequest.securityGroups) &&
        Objects.equals(this.storageType, createBrokerRequest.storageType) &&
        Objects.equals(this.subnetIds, createBrokerRequest.subnetIds) &&
        Objects.equals(this.tags, createBrokerRequest.tags) &&
        Objects.equals(this.users, createBrokerRequest.users) &&
        Objects.equals(this.dataReplicationMode, createBrokerRequest.dataReplicationMode) &&
        Objects.equals(this.dataReplicationPrimaryBrokerArn, createBrokerRequest.dataReplicationPrimaryBrokerArn);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authenticationStrategy, autoMinorVersionUpgrade, brokerName, _configuration, creatorRequestId, deploymentMode, encryptionOptions, engineType, engineVersion, hostInstanceType, ldapServerMetadata, logs, maintenanceWindowStartTime, publiclyAccessible, securityGroups, storageType, subnetIds, tags, users, dataReplicationMode, dataReplicationPrimaryBrokerArn);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateBrokerRequest {\n");
    sb.append("    authenticationStrategy: ").append(toIndentedString(authenticationStrategy)).append("\n");
    sb.append("    autoMinorVersionUpgrade: ").append(toIndentedString(autoMinorVersionUpgrade)).append("\n");
    sb.append("    brokerName: ").append(toIndentedString(brokerName)).append("\n");
    sb.append("    _configuration: ").append(toIndentedString(_configuration)).append("\n");
    sb.append("    creatorRequestId: ").append(toIndentedString(creatorRequestId)).append("\n");
    sb.append("    deploymentMode: ").append(toIndentedString(deploymentMode)).append("\n");
    sb.append("    encryptionOptions: ").append(toIndentedString(encryptionOptions)).append("\n");
    sb.append("    engineType: ").append(toIndentedString(engineType)).append("\n");
    sb.append("    engineVersion: ").append(toIndentedString(engineVersion)).append("\n");
    sb.append("    hostInstanceType: ").append(toIndentedString(hostInstanceType)).append("\n");
    sb.append("    ldapServerMetadata: ").append(toIndentedString(ldapServerMetadata)).append("\n");
    sb.append("    logs: ").append(toIndentedString(logs)).append("\n");
    sb.append("    maintenanceWindowStartTime: ").append(toIndentedString(maintenanceWindowStartTime)).append("\n");
    sb.append("    publiclyAccessible: ").append(toIndentedString(publiclyAccessible)).append("\n");
    sb.append("    securityGroups: ").append(toIndentedString(securityGroups)).append("\n");
    sb.append("    storageType: ").append(toIndentedString(storageType)).append("\n");
    sb.append("    subnetIds: ").append(toIndentedString(subnetIds)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    users: ").append(toIndentedString(users)).append("\n");
    sb.append("    dataReplicationMode: ").append(toIndentedString(dataReplicationMode)).append("\n");
    sb.append("    dataReplicationPrimaryBrokerArn: ").append(toIndentedString(dataReplicationPrimaryBrokerArn)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authenticationStrategy");
    openapiFields.add("autoMinorVersionUpgrade");
    openapiFields.add("brokerName");
    openapiFields.add("configuration");
    openapiFields.add("creatorRequestId");
    openapiFields.add("deploymentMode");
    openapiFields.add("encryptionOptions");
    openapiFields.add("engineType");
    openapiFields.add("engineVersion");
    openapiFields.add("hostInstanceType");
    openapiFields.add("ldapServerMetadata");
    openapiFields.add("logs");
    openapiFields.add("maintenanceWindowStartTime");
    openapiFields.add("publiclyAccessible");
    openapiFields.add("securityGroups");
    openapiFields.add("storageType");
    openapiFields.add("subnetIds");
    openapiFields.add("tags");
    openapiFields.add("users");
    openapiFields.add("dataReplicationMode");
    openapiFields.add("dataReplicationPrimaryBrokerArn");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("autoMinorVersionUpgrade");
    openapiRequiredFields.add("brokerName");
    openapiRequiredFields.add("deploymentMode");
    openapiRequiredFields.add("engineType");
    openapiRequiredFields.add("engineVersion");
    openapiRequiredFields.add("hostInstanceType");
    openapiRequiredFields.add("publiclyAccessible");
    openapiRequiredFields.add("users");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateBrokerRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateBrokerRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateBrokerRequest is not found in the empty JSON string", CreateBrokerRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateBrokerRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateBrokerRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateBrokerRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("authenticationStrategy") != null && !jsonObj.get("authenticationStrategy").isJsonNull()) && !jsonObj.get("authenticationStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authenticationStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authenticationStrategy").toString()));
      }
      // validate the optional field `authenticationStrategy`
      if (jsonObj.get("authenticationStrategy") != null && !jsonObj.get("authenticationStrategy").isJsonNull()) {
        AuthenticationStrategyEnum.validateJsonElement(jsonObj.get("authenticationStrategy"));
      }
      if (!jsonObj.get("brokerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `brokerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("brokerName").toString()));
      }
      // validate the optional field `configuration`
      if (jsonObj.get("configuration") != null && !jsonObj.get("configuration").isJsonNull()) {
        CreateBrokerRequestConfiguration.validateJsonElement(jsonObj.get("configuration"));
      }
      if ((jsonObj.get("creatorRequestId") != null && !jsonObj.get("creatorRequestId").isJsonNull()) && !jsonObj.get("creatorRequestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creatorRequestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creatorRequestId").toString()));
      }
      if (!jsonObj.get("deploymentMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deploymentMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deploymentMode").toString()));
      }
      // validate the required field `deploymentMode`
      DeploymentModeEnum.validateJsonElement(jsonObj.get("deploymentMode"));
      // validate the optional field `encryptionOptions`
      if (jsonObj.get("encryptionOptions") != null && !jsonObj.get("encryptionOptions").isJsonNull()) {
        CreateBrokerRequestEncryptionOptions.validateJsonElement(jsonObj.get("encryptionOptions"));
      }
      if (!jsonObj.get("engineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `engineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("engineType").toString()));
      }
      // validate the required field `engineType`
      EngineTypeEnum.validateJsonElement(jsonObj.get("engineType"));
      if (!jsonObj.get("engineVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `engineVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("engineVersion").toString()));
      }
      if (!jsonObj.get("hostInstanceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostInstanceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostInstanceType").toString()));
      }
      // validate the optional field `ldapServerMetadata`
      if (jsonObj.get("ldapServerMetadata") != null && !jsonObj.get("ldapServerMetadata").isJsonNull()) {
        CreateBrokerRequestLdapServerMetadata.validateJsonElement(jsonObj.get("ldapServerMetadata"));
      }
      // validate the optional field `logs`
      if (jsonObj.get("logs") != null && !jsonObj.get("logs").isJsonNull()) {
        CreateBrokerRequestLogs.validateJsonElement(jsonObj.get("logs"));
      }
      // validate the optional field `maintenanceWindowStartTime`
      if (jsonObj.get("maintenanceWindowStartTime") != null && !jsonObj.get("maintenanceWindowStartTime").isJsonNull()) {
        CreateBrokerRequestMaintenanceWindowStartTime.validateJsonElement(jsonObj.get("maintenanceWindowStartTime"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("securityGroups") != null && !jsonObj.get("securityGroups").isJsonNull() && !jsonObj.get("securityGroups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityGroups` to be an array in the JSON string but got `%s`", jsonObj.get("securityGroups").toString()));
      }
      if ((jsonObj.get("storageType") != null && !jsonObj.get("storageType").isJsonNull()) && !jsonObj.get("storageType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageType").toString()));
      }
      // validate the optional field `storageType`
      if (jsonObj.get("storageType") != null && !jsonObj.get("storageType").isJsonNull()) {
        StorageTypeEnum.validateJsonElement(jsonObj.get("storageType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subnetIds") != null && !jsonObj.get("subnetIds").isJsonNull() && !jsonObj.get("subnetIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetIds` to be an array in the JSON string but got `%s`", jsonObj.get("subnetIds").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("users").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `users` to be an array in the JSON string but got `%s`", jsonObj.get("users").toString()));
      }

      JsonArray jsonArrayusers = jsonObj.getAsJsonArray("users");
      // validate the required field `users` (array)
      for (int i = 0; i < jsonArrayusers.size(); i++) {
        User.validateJsonElement(jsonArrayusers.get(i));
      };
      if ((jsonObj.get("dataReplicationMode") != null && !jsonObj.get("dataReplicationMode").isJsonNull()) && !jsonObj.get("dataReplicationMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataReplicationMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataReplicationMode").toString()));
      }
      // validate the optional field `dataReplicationMode`
      if (jsonObj.get("dataReplicationMode") != null && !jsonObj.get("dataReplicationMode").isJsonNull()) {
        DataReplicationModeEnum.validateJsonElement(jsonObj.get("dataReplicationMode"));
      }
      if ((jsonObj.get("dataReplicationPrimaryBrokerArn") != null && !jsonObj.get("dataReplicationPrimaryBrokerArn").isJsonNull()) && !jsonObj.get("dataReplicationPrimaryBrokerArn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataReplicationPrimaryBrokerArn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataReplicationPrimaryBrokerArn").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateBrokerRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateBrokerRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateBrokerRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateBrokerRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateBrokerRequest>() {
           @Override
           public void write(JsonWriter out, CreateBrokerRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateBrokerRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateBrokerRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateBrokerRequest
   * @throws IOException if the JSON string is invalid with respect to CreateBrokerRequest
   */
  public static CreateBrokerRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateBrokerRequest.class);
  }

  /**
   * Convert an instance of CreateBrokerRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

