/*
 * AWS Resource Groups Tagging API
 * <fullname>Resource Groups Tagging API</fullname>
 *
 * The version of the OpenAPI document: 2017-01-26
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ErrorCode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Information about the errors that are returned for each failed resource. This information can include &lt;code&gt;InternalServiceException&lt;/code&gt; and &lt;code&gt;InvalidParameterException&lt;/code&gt; errors. It can also include any valid error code returned by the Amazon Web Services service that hosts the resource that the ARN key represents.&lt;/p&gt; &lt;p&gt;The following are common error codes that you might receive from other Amazon Web Services services:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;InternalServiceException&lt;/b&gt; – This can mean that the Resource Groups Tagging API didn&#39;t receive a response from another Amazon Web Services service. It can also mean that the resource type in the request is not supported by the Resource Groups Tagging API. In these cases, it&#39;s safe to retry the request and then call &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html\&quot;&gt;GetResources&lt;/a&gt; to verify the changes.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;AccessDeniedException&lt;/b&gt; – This can mean that you need permission to call the tagging operations in the Amazon Web Services service that contains the resource. For example, to use the Resource Groups Tagging API to tag a Amazon CloudWatch alarm resource, you need permission to call both &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_TagResources.html\&quot;&gt; &lt;code&gt;TagResources&lt;/code&gt; &lt;/a&gt; &lt;i&gt;and&lt;/i&gt; &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html\&quot;&gt; &lt;code&gt;TagResource&lt;/code&gt; &lt;/a&gt; in the CloudWatch API. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information on errors that are generated from other Amazon Web Services services, see the documentation for that service. &lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:13:20.547708-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FailureInfo {
  public static final String SERIALIZED_NAME_STATUS_CODE = "StatusCode";
  @SerializedName(SERIALIZED_NAME_STATUS_CODE)
  private Integer statusCode;

  public static final String SERIALIZED_NAME_ERROR_CODE = "ErrorCode";
  @SerializedName(SERIALIZED_NAME_ERROR_CODE)
  private ErrorCode errorCode;

  public static final String SERIALIZED_NAME_ERROR_MESSAGE = "ErrorMessage";
  @SerializedName(SERIALIZED_NAME_ERROR_MESSAGE)
  private String errorMessage;

  public FailureInfo() {
  }

  public FailureInfo statusCode(Integer statusCode) {
    this.statusCode = statusCode;
    return this;
  }

  /**
   * Get statusCode
   * @return statusCode
   */
  @javax.annotation.Nullable
  public Integer getStatusCode() {
    return statusCode;
  }

  public void setStatusCode(Integer statusCode) {
    this.statusCode = statusCode;
  }


  public FailureInfo errorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
    return this;
  }

  /**
   * Get errorCode
   * @return errorCode
   */
  @javax.annotation.Nullable
  public ErrorCode getErrorCode() {
    return errorCode;
  }

  public void setErrorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }


  public FailureInfo errorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
    return this;
  }

  /**
   * Get errorMessage
   * @return errorMessage
   */
  @javax.annotation.Nullable
  public String getErrorMessage() {
    return errorMessage;
  }

  public void setErrorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FailureInfo failureInfo = (FailureInfo) o;
    return Objects.equals(this.statusCode, failureInfo.statusCode) &&
        Objects.equals(this.errorCode, failureInfo.errorCode) &&
        Objects.equals(this.errorMessage, failureInfo.errorMessage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(statusCode, errorCode, errorMessage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FailureInfo {\n");
    sb.append("    statusCode: ").append(toIndentedString(statusCode)).append("\n");
    sb.append("    errorCode: ").append(toIndentedString(errorCode)).append("\n");
    sb.append("    errorMessage: ").append(toIndentedString(errorMessage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("StatusCode");
    openapiFields.add("ErrorCode");
    openapiFields.add("ErrorMessage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FailureInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FailureInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FailureInfo is not found in the empty JSON string", FailureInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FailureInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FailureInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `StatusCode`
      if (jsonObj.get("StatusCode") != null && !jsonObj.get("StatusCode").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("StatusCode"));
      }
      // validate the optional field `ErrorCode`
      if (jsonObj.get("ErrorCode") != null && !jsonObj.get("ErrorCode").isJsonNull()) {
        ErrorCode.validateJsonElement(jsonObj.get("ErrorCode"));
      }
      // validate the optional field `ErrorMessage`
      if (jsonObj.get("ErrorMessage") != null && !jsonObj.get("ErrorMessage").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("ErrorMessage"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FailureInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FailureInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FailureInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FailureInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<FailureInfo>() {
           @Override
           public void write(JsonWriter out, FailureInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FailureInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FailureInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FailureInfo
   * @throws IOException if the JSON string is invalid with respect to FailureInfo
   */
  public static FailureInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FailureInfo.class);
  }

  /**
   * Convert an instance of FailureInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

