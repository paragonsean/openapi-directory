/*
 * AWSKendraFrontendService
 * Amazon Kendra is a service for indexing large document sets.
 *
 * The version of the OpenAPI document: 2019-02-03
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An excerpt from a table within a document. The table excerpt displays up to five columns and three rows, depending on how many table cells are relevant to the query and how many columns are available in the original table. The top most relevant cell is displayed in the table excerpt, along with the next most relevant cells.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:06:16.778416-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TableExcerpt {
  public static final String SERIALIZED_NAME_ROWS = "Rows";
  @SerializedName(SERIALIZED_NAME_ROWS)
  private List rows;

  public static final String SERIALIZED_NAME_TOTAL_NUMBER_OF_ROWS = "TotalNumberOfRows";
  @SerializedName(SERIALIZED_NAME_TOTAL_NUMBER_OF_ROWS)
  private Integer totalNumberOfRows;

  public TableExcerpt() {
  }

  public TableExcerpt rows(List rows) {
    this.rows = rows;
    return this;
  }

  /**
   * Get rows
   * @return rows
   */
  @javax.annotation.Nullable
  public List getRows() {
    return rows;
  }

  public void setRows(List rows) {
    this.rows = rows;
  }


  public TableExcerpt totalNumberOfRows(Integer totalNumberOfRows) {
    this.totalNumberOfRows = totalNumberOfRows;
    return this;
  }

  /**
   * Get totalNumberOfRows
   * @return totalNumberOfRows
   */
  @javax.annotation.Nullable
  public Integer getTotalNumberOfRows() {
    return totalNumberOfRows;
  }

  public void setTotalNumberOfRows(Integer totalNumberOfRows) {
    this.totalNumberOfRows = totalNumberOfRows;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TableExcerpt tableExcerpt = (TableExcerpt) o;
    return Objects.equals(this.rows, tableExcerpt.rows) &&
        Objects.equals(this.totalNumberOfRows, tableExcerpt.totalNumberOfRows);
  }

  @Override
  public int hashCode() {
    return Objects.hash(rows, totalNumberOfRows);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TableExcerpt {\n");
    sb.append("    rows: ").append(toIndentedString(rows)).append("\n");
    sb.append("    totalNumberOfRows: ").append(toIndentedString(totalNumberOfRows)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Rows");
    openapiFields.add("TotalNumberOfRows");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TableExcerpt
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TableExcerpt.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TableExcerpt is not found in the empty JSON string", TableExcerpt.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TableExcerpt.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TableExcerpt` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Rows`
      if (jsonObj.get("Rows") != null && !jsonObj.get("Rows").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Rows"));
      }
      // validate the optional field `TotalNumberOfRows`
      if (jsonObj.get("TotalNumberOfRows") != null && !jsonObj.get("TotalNumberOfRows").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("TotalNumberOfRows"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TableExcerpt.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TableExcerpt' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TableExcerpt> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TableExcerpt.class));

       return (TypeAdapter<T>) new TypeAdapter<TableExcerpt>() {
           @Override
           public void write(JsonWriter out, TableExcerpt value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TableExcerpt read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TableExcerpt given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TableExcerpt
   * @throws IOException if the JSON string is invalid with respect to TableExcerpt
   */
  public static TableExcerpt fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TableExcerpt.class);
  }

  /**
   * Convert an instance of TableExcerpt to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

