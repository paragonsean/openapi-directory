/**
 * Amazon AppStream
 * <fullname>Amazon AppStream 2.0</fullname> <p>This is the <i>Amazon AppStream 2.0 API Reference</i>. This documentation provides descriptions and syntax for each of the actions and data types in AppStream 2.0. AppStream 2.0 is a fully managed, secure application streaming service that lets you stream desktop applications to users without rewriting applications. AppStream 2.0 manages the AWS resources that are required to host and run your applications, scales automatically, and provides access to your users on demand. </p> <note> <p>You can call the AppStream 2.0 API operations by using an interface VPC endpoint (interface endpoint). For more information, see <a href=\"https://docs.aws.amazon.com/appstream2/latest/developerguide/access-api-cli-through-interface-vpc-endpoint.html\">Access AppStream 2.0 API Operations and CLI Commands Through an Interface VPC Endpoint</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p> </note> <p>To learn more about AppStream 2.0, see the following resources:</p> <ul> <li> <p> <a href=\"http://aws.amazon.com/appstream2\">Amazon AppStream 2.0 product page</a> </p> </li> <li> <p> <a href=\"http://aws.amazon.com/documentation/appstream2\">Amazon AppStream 2.0 documentation</a> </p> </li> </ul>
 *
 * The version of the OpenAPI document: 2016-12-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFleet.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFleet::OAIFleet(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFleet::OAIFleet() {
    this->initializeModel();
}

OAIFleet::~OAIFleet() {}

void OAIFleet::initializeModel() {

    m_arn_isSet = false;
    m_arn_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_image_name_isSet = false;
    m_image_name_isValid = false;

    m_image_arn_isSet = false;
    m_image_arn_isValid = false;

    m_instance_type_isSet = false;
    m_instance_type_isValid = false;

    m_fleet_type_isSet = false;
    m_fleet_type_isValid = false;

    m_compute_capacity_status_isSet = false;
    m_compute_capacity_status_isValid = false;

    m_max_user_duration_in_seconds_isSet = false;
    m_max_user_duration_in_seconds_isValid = false;

    m_disconnect_timeout_in_seconds_isSet = false;
    m_disconnect_timeout_in_seconds_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_vpc_config_isSet = false;
    m_vpc_config_isValid = false;

    m_created_time_isSet = false;
    m_created_time_isValid = false;

    m_fleet_errors_isSet = false;
    m_fleet_errors_isValid = false;

    m_enable_default_internet_access_isSet = false;
    m_enable_default_internet_access_isValid = false;

    m_domain_join_info_isSet = false;
    m_domain_join_info_isValid = false;

    m_idle_disconnect_timeout_in_seconds_isSet = false;
    m_idle_disconnect_timeout_in_seconds_isValid = false;

    m_iam_role_arn_isSet = false;
    m_iam_role_arn_isValid = false;

    m_stream_view_isSet = false;
    m_stream_view_isValid = false;

    m_platform_isSet = false;
    m_platform_isValid = false;

    m_max_concurrent_sessions_isSet = false;
    m_max_concurrent_sessions_isValid = false;

    m_usb_device_filter_strings_isSet = false;
    m_usb_device_filter_strings_isValid = false;

    m_session_script_s3_location_isSet = false;
    m_session_script_s3_location_isValid = false;
}

void OAIFleet::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFleet::fromJsonObject(QJsonObject json) {

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("Arn")]);
    m_arn_isSet = !json[QString("Arn")].isNull() && m_arn_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("Name")]);
    m_name_isSet = !json[QString("Name")].isNull() && m_name_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("DisplayName")]);
    m_display_name_isSet = !json[QString("DisplayName")].isNull() && m_display_name_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("Description")]);
    m_description_isSet = !json[QString("Description")].isNull() && m_description_isValid;

    m_image_name_isValid = ::OpenAPI::fromJsonValue(m_image_name, json[QString("ImageName")]);
    m_image_name_isSet = !json[QString("ImageName")].isNull() && m_image_name_isValid;

    m_image_arn_isValid = ::OpenAPI::fromJsonValue(m_image_arn, json[QString("ImageArn")]);
    m_image_arn_isSet = !json[QString("ImageArn")].isNull() && m_image_arn_isValid;

    m_instance_type_isValid = ::OpenAPI::fromJsonValue(m_instance_type, json[QString("InstanceType")]);
    m_instance_type_isSet = !json[QString("InstanceType")].isNull() && m_instance_type_isValid;

    m_fleet_type_isValid = ::OpenAPI::fromJsonValue(m_fleet_type, json[QString("FleetType")]);
    m_fleet_type_isSet = !json[QString("FleetType")].isNull() && m_fleet_type_isValid;

    m_compute_capacity_status_isValid = ::OpenAPI::fromJsonValue(m_compute_capacity_status, json[QString("ComputeCapacityStatus")]);
    m_compute_capacity_status_isSet = !json[QString("ComputeCapacityStatus")].isNull() && m_compute_capacity_status_isValid;

    m_max_user_duration_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_max_user_duration_in_seconds, json[QString("MaxUserDurationInSeconds")]);
    m_max_user_duration_in_seconds_isSet = !json[QString("MaxUserDurationInSeconds")].isNull() && m_max_user_duration_in_seconds_isValid;

    m_disconnect_timeout_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_disconnect_timeout_in_seconds, json[QString("DisconnectTimeoutInSeconds")]);
    m_disconnect_timeout_in_seconds_isSet = !json[QString("DisconnectTimeoutInSeconds")].isNull() && m_disconnect_timeout_in_seconds_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("State")]);
    m_state_isSet = !json[QString("State")].isNull() && m_state_isValid;

    m_vpc_config_isValid = ::OpenAPI::fromJsonValue(m_vpc_config, json[QString("VpcConfig")]);
    m_vpc_config_isSet = !json[QString("VpcConfig")].isNull() && m_vpc_config_isValid;

    m_created_time_isValid = ::OpenAPI::fromJsonValue(m_created_time, json[QString("CreatedTime")]);
    m_created_time_isSet = !json[QString("CreatedTime")].isNull() && m_created_time_isValid;

    m_fleet_errors_isValid = ::OpenAPI::fromJsonValue(m_fleet_errors, json[QString("FleetErrors")]);
    m_fleet_errors_isSet = !json[QString("FleetErrors")].isNull() && m_fleet_errors_isValid;

    m_enable_default_internet_access_isValid = ::OpenAPI::fromJsonValue(m_enable_default_internet_access, json[QString("EnableDefaultInternetAccess")]);
    m_enable_default_internet_access_isSet = !json[QString("EnableDefaultInternetAccess")].isNull() && m_enable_default_internet_access_isValid;

    m_domain_join_info_isValid = ::OpenAPI::fromJsonValue(m_domain_join_info, json[QString("DomainJoinInfo")]);
    m_domain_join_info_isSet = !json[QString("DomainJoinInfo")].isNull() && m_domain_join_info_isValid;

    m_idle_disconnect_timeout_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_idle_disconnect_timeout_in_seconds, json[QString("IdleDisconnectTimeoutInSeconds")]);
    m_idle_disconnect_timeout_in_seconds_isSet = !json[QString("IdleDisconnectTimeoutInSeconds")].isNull() && m_idle_disconnect_timeout_in_seconds_isValid;

    m_iam_role_arn_isValid = ::OpenAPI::fromJsonValue(m_iam_role_arn, json[QString("IamRoleArn")]);
    m_iam_role_arn_isSet = !json[QString("IamRoleArn")].isNull() && m_iam_role_arn_isValid;

    m_stream_view_isValid = ::OpenAPI::fromJsonValue(m_stream_view, json[QString("StreamView")]);
    m_stream_view_isSet = !json[QString("StreamView")].isNull() && m_stream_view_isValid;

    m_platform_isValid = ::OpenAPI::fromJsonValue(m_platform, json[QString("Platform")]);
    m_platform_isSet = !json[QString("Platform")].isNull() && m_platform_isValid;

    m_max_concurrent_sessions_isValid = ::OpenAPI::fromJsonValue(m_max_concurrent_sessions, json[QString("MaxConcurrentSessions")]);
    m_max_concurrent_sessions_isSet = !json[QString("MaxConcurrentSessions")].isNull() && m_max_concurrent_sessions_isValid;

    m_usb_device_filter_strings_isValid = ::OpenAPI::fromJsonValue(m_usb_device_filter_strings, json[QString("UsbDeviceFilterStrings")]);
    m_usb_device_filter_strings_isSet = !json[QString("UsbDeviceFilterStrings")].isNull() && m_usb_device_filter_strings_isValid;

    m_session_script_s3_location_isValid = ::OpenAPI::fromJsonValue(m_session_script_s3_location, json[QString("SessionScriptS3Location")]);
    m_session_script_s3_location_isSet = !json[QString("SessionScriptS3Location")].isNull() && m_session_script_s3_location_isValid;
}

QString OAIFleet::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFleet::asJsonObject() const {
    QJsonObject obj;
    if (m_arn_isSet) {
        obj.insert(QString("Arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    if (m_name_isSet) {
        obj.insert(QString("Name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("DisplayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_description_isSet) {
        obj.insert(QString("Description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_image_name_isSet) {
        obj.insert(QString("ImageName"), ::OpenAPI::toJsonValue(m_image_name));
    }
    if (m_image_arn_isSet) {
        obj.insert(QString("ImageArn"), ::OpenAPI::toJsonValue(m_image_arn));
    }
    if (m_instance_type_isSet) {
        obj.insert(QString("InstanceType"), ::OpenAPI::toJsonValue(m_instance_type));
    }
    if (m_fleet_type.isSet()) {
        obj.insert(QString("FleetType"), ::OpenAPI::toJsonValue(m_fleet_type));
    }
    if (m_compute_capacity_status.isSet()) {
        obj.insert(QString("ComputeCapacityStatus"), ::OpenAPI::toJsonValue(m_compute_capacity_status));
    }
    if (m_max_user_duration_in_seconds_isSet) {
        obj.insert(QString("MaxUserDurationInSeconds"), ::OpenAPI::toJsonValue(m_max_user_duration_in_seconds));
    }
    if (m_disconnect_timeout_in_seconds_isSet) {
        obj.insert(QString("DisconnectTimeoutInSeconds"), ::OpenAPI::toJsonValue(m_disconnect_timeout_in_seconds));
    }
    if (m_state.isSet()) {
        obj.insert(QString("State"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_vpc_config.isSet()) {
        obj.insert(QString("VpcConfig"), ::OpenAPI::toJsonValue(m_vpc_config));
    }
    if (m_created_time_isSet) {
        obj.insert(QString("CreatedTime"), ::OpenAPI::toJsonValue(m_created_time));
    }
    if (m_fleet_errors.isSet()) {
        obj.insert(QString("FleetErrors"), ::OpenAPI::toJsonValue(m_fleet_errors));
    }
    if (m_enable_default_internet_access_isSet) {
        obj.insert(QString("EnableDefaultInternetAccess"), ::OpenAPI::toJsonValue(m_enable_default_internet_access));
    }
    if (m_domain_join_info.isSet()) {
        obj.insert(QString("DomainJoinInfo"), ::OpenAPI::toJsonValue(m_domain_join_info));
    }
    if (m_idle_disconnect_timeout_in_seconds_isSet) {
        obj.insert(QString("IdleDisconnectTimeoutInSeconds"), ::OpenAPI::toJsonValue(m_idle_disconnect_timeout_in_seconds));
    }
    if (m_iam_role_arn_isSet) {
        obj.insert(QString("IamRoleArn"), ::OpenAPI::toJsonValue(m_iam_role_arn));
    }
    if (m_stream_view.isSet()) {
        obj.insert(QString("StreamView"), ::OpenAPI::toJsonValue(m_stream_view));
    }
    if (m_platform.isSet()) {
        obj.insert(QString("Platform"), ::OpenAPI::toJsonValue(m_platform));
    }
    if (m_max_concurrent_sessions_isSet) {
        obj.insert(QString("MaxConcurrentSessions"), ::OpenAPI::toJsonValue(m_max_concurrent_sessions));
    }
    if (m_usb_device_filter_strings.isSet()) {
        obj.insert(QString("UsbDeviceFilterStrings"), ::OpenAPI::toJsonValue(m_usb_device_filter_strings));
    }
    if (m_session_script_s3_location.isSet()) {
        obj.insert(QString("SessionScriptS3Location"), ::OpenAPI::toJsonValue(m_session_script_s3_location));
    }
    return obj;
}

QString OAIFleet::getArn() const {
    return m_arn;
}
void OAIFleet::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAIFleet::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAIFleet::is_arn_Valid() const{
    return m_arn_isValid;
}

QString OAIFleet::getName() const {
    return m_name;
}
void OAIFleet::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIFleet::is_name_Set() const{
    return m_name_isSet;
}

bool OAIFleet::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIFleet::getDisplayName() const {
    return m_display_name;
}
void OAIFleet::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIFleet::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIFleet::is_display_name_Valid() const{
    return m_display_name_isValid;
}

QString OAIFleet::getDescription() const {
    return m_description;
}
void OAIFleet::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAIFleet::is_description_Set() const{
    return m_description_isSet;
}

bool OAIFleet::is_description_Valid() const{
    return m_description_isValid;
}

QString OAIFleet::getImageName() const {
    return m_image_name;
}
void OAIFleet::setImageName(const QString &image_name) {
    m_image_name = image_name;
    m_image_name_isSet = true;
}

bool OAIFleet::is_image_name_Set() const{
    return m_image_name_isSet;
}

bool OAIFleet::is_image_name_Valid() const{
    return m_image_name_isValid;
}

QString OAIFleet::getImageArn() const {
    return m_image_arn;
}
void OAIFleet::setImageArn(const QString &image_arn) {
    m_image_arn = image_arn;
    m_image_arn_isSet = true;
}

bool OAIFleet::is_image_arn_Set() const{
    return m_image_arn_isSet;
}

bool OAIFleet::is_image_arn_Valid() const{
    return m_image_arn_isValid;
}

QString OAIFleet::getInstanceType() const {
    return m_instance_type;
}
void OAIFleet::setInstanceType(const QString &instance_type) {
    m_instance_type = instance_type;
    m_instance_type_isSet = true;
}

bool OAIFleet::is_instance_type_Set() const{
    return m_instance_type_isSet;
}

bool OAIFleet::is_instance_type_Valid() const{
    return m_instance_type_isValid;
}

OAIFleetType OAIFleet::getFleetType() const {
    return m_fleet_type;
}
void OAIFleet::setFleetType(const OAIFleetType &fleet_type) {
    m_fleet_type = fleet_type;
    m_fleet_type_isSet = true;
}

bool OAIFleet::is_fleet_type_Set() const{
    return m_fleet_type_isSet;
}

bool OAIFleet::is_fleet_type_Valid() const{
    return m_fleet_type_isValid;
}

OAIFleet_ComputeCapacityStatus OAIFleet::getComputeCapacityStatus() const {
    return m_compute_capacity_status;
}
void OAIFleet::setComputeCapacityStatus(const OAIFleet_ComputeCapacityStatus &compute_capacity_status) {
    m_compute_capacity_status = compute_capacity_status;
    m_compute_capacity_status_isSet = true;
}

bool OAIFleet::is_compute_capacity_status_Set() const{
    return m_compute_capacity_status_isSet;
}

bool OAIFleet::is_compute_capacity_status_Valid() const{
    return m_compute_capacity_status_isValid;
}

qint32 OAIFleet::getMaxUserDurationInSeconds() const {
    return m_max_user_duration_in_seconds;
}
void OAIFleet::setMaxUserDurationInSeconds(const qint32 &max_user_duration_in_seconds) {
    m_max_user_duration_in_seconds = max_user_duration_in_seconds;
    m_max_user_duration_in_seconds_isSet = true;
}

bool OAIFleet::is_max_user_duration_in_seconds_Set() const{
    return m_max_user_duration_in_seconds_isSet;
}

bool OAIFleet::is_max_user_duration_in_seconds_Valid() const{
    return m_max_user_duration_in_seconds_isValid;
}

qint32 OAIFleet::getDisconnectTimeoutInSeconds() const {
    return m_disconnect_timeout_in_seconds;
}
void OAIFleet::setDisconnectTimeoutInSeconds(const qint32 &disconnect_timeout_in_seconds) {
    m_disconnect_timeout_in_seconds = disconnect_timeout_in_seconds;
    m_disconnect_timeout_in_seconds_isSet = true;
}

bool OAIFleet::is_disconnect_timeout_in_seconds_Set() const{
    return m_disconnect_timeout_in_seconds_isSet;
}

bool OAIFleet::is_disconnect_timeout_in_seconds_Valid() const{
    return m_disconnect_timeout_in_seconds_isValid;
}

OAIFleetState OAIFleet::getState() const {
    return m_state;
}
void OAIFleet::setState(const OAIFleetState &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIFleet::is_state_Set() const{
    return m_state_isSet;
}

bool OAIFleet::is_state_Valid() const{
    return m_state_isValid;
}

OAIFleet_VpcConfig OAIFleet::getVpcConfig() const {
    return m_vpc_config;
}
void OAIFleet::setVpcConfig(const OAIFleet_VpcConfig &vpc_config) {
    m_vpc_config = vpc_config;
    m_vpc_config_isSet = true;
}

bool OAIFleet::is_vpc_config_Set() const{
    return m_vpc_config_isSet;
}

bool OAIFleet::is_vpc_config_Valid() const{
    return m_vpc_config_isValid;
}

QDateTime OAIFleet::getCreatedTime() const {
    return m_created_time;
}
void OAIFleet::setCreatedTime(const QDateTime &created_time) {
    m_created_time = created_time;
    m_created_time_isSet = true;
}

bool OAIFleet::is_created_time_Set() const{
    return m_created_time_isSet;
}

bool OAIFleet::is_created_time_Valid() const{
    return m_created_time_isValid;
}

QList OAIFleet::getFleetErrors() const {
    return m_fleet_errors;
}
void OAIFleet::setFleetErrors(const QList &fleet_errors) {
    m_fleet_errors = fleet_errors;
    m_fleet_errors_isSet = true;
}

bool OAIFleet::is_fleet_errors_Set() const{
    return m_fleet_errors_isSet;
}

bool OAIFleet::is_fleet_errors_Valid() const{
    return m_fleet_errors_isValid;
}

bool OAIFleet::getEnableDefaultInternetAccess() const {
    return m_enable_default_internet_access;
}
void OAIFleet::setEnableDefaultInternetAccess(const bool &enable_default_internet_access) {
    m_enable_default_internet_access = enable_default_internet_access;
    m_enable_default_internet_access_isSet = true;
}

bool OAIFleet::is_enable_default_internet_access_Set() const{
    return m_enable_default_internet_access_isSet;
}

bool OAIFleet::is_enable_default_internet_access_Valid() const{
    return m_enable_default_internet_access_isValid;
}

OAIUpdateFleetRequest_DomainJoinInfo OAIFleet::getDomainJoinInfo() const {
    return m_domain_join_info;
}
void OAIFleet::setDomainJoinInfo(const OAIUpdateFleetRequest_DomainJoinInfo &domain_join_info) {
    m_domain_join_info = domain_join_info;
    m_domain_join_info_isSet = true;
}

bool OAIFleet::is_domain_join_info_Set() const{
    return m_domain_join_info_isSet;
}

bool OAIFleet::is_domain_join_info_Valid() const{
    return m_domain_join_info_isValid;
}

qint32 OAIFleet::getIdleDisconnectTimeoutInSeconds() const {
    return m_idle_disconnect_timeout_in_seconds;
}
void OAIFleet::setIdleDisconnectTimeoutInSeconds(const qint32 &idle_disconnect_timeout_in_seconds) {
    m_idle_disconnect_timeout_in_seconds = idle_disconnect_timeout_in_seconds;
    m_idle_disconnect_timeout_in_seconds_isSet = true;
}

bool OAIFleet::is_idle_disconnect_timeout_in_seconds_Set() const{
    return m_idle_disconnect_timeout_in_seconds_isSet;
}

bool OAIFleet::is_idle_disconnect_timeout_in_seconds_Valid() const{
    return m_idle_disconnect_timeout_in_seconds_isValid;
}

QString OAIFleet::getIamRoleArn() const {
    return m_iam_role_arn;
}
void OAIFleet::setIamRoleArn(const QString &iam_role_arn) {
    m_iam_role_arn = iam_role_arn;
    m_iam_role_arn_isSet = true;
}

bool OAIFleet::is_iam_role_arn_Set() const{
    return m_iam_role_arn_isSet;
}

bool OAIFleet::is_iam_role_arn_Valid() const{
    return m_iam_role_arn_isValid;
}

OAIStreamView OAIFleet::getStreamView() const {
    return m_stream_view;
}
void OAIFleet::setStreamView(const OAIStreamView &stream_view) {
    m_stream_view = stream_view;
    m_stream_view_isSet = true;
}

bool OAIFleet::is_stream_view_Set() const{
    return m_stream_view_isSet;
}

bool OAIFleet::is_stream_view_Valid() const{
    return m_stream_view_isValid;
}

OAIPlatformType OAIFleet::getPlatform() const {
    return m_platform;
}
void OAIFleet::setPlatform(const OAIPlatformType &platform) {
    m_platform = platform;
    m_platform_isSet = true;
}

bool OAIFleet::is_platform_Set() const{
    return m_platform_isSet;
}

bool OAIFleet::is_platform_Valid() const{
    return m_platform_isValid;
}

qint32 OAIFleet::getMaxConcurrentSessions() const {
    return m_max_concurrent_sessions;
}
void OAIFleet::setMaxConcurrentSessions(const qint32 &max_concurrent_sessions) {
    m_max_concurrent_sessions = max_concurrent_sessions;
    m_max_concurrent_sessions_isSet = true;
}

bool OAIFleet::is_max_concurrent_sessions_Set() const{
    return m_max_concurrent_sessions_isSet;
}

bool OAIFleet::is_max_concurrent_sessions_Valid() const{
    return m_max_concurrent_sessions_isValid;
}

QList OAIFleet::getUsbDeviceFilterStrings() const {
    return m_usb_device_filter_strings;
}
void OAIFleet::setUsbDeviceFilterStrings(const QList &usb_device_filter_strings) {
    m_usb_device_filter_strings = usb_device_filter_strings;
    m_usb_device_filter_strings_isSet = true;
}

bool OAIFleet::is_usb_device_filter_strings_Set() const{
    return m_usb_device_filter_strings_isSet;
}

bool OAIFleet::is_usb_device_filter_strings_Valid() const{
    return m_usb_device_filter_strings_isValid;
}

OAICreateFleetRequest_SessionScriptS3Location OAIFleet::getSessionScriptS3Location() const {
    return m_session_script_s3_location;
}
void OAIFleet::setSessionScriptS3Location(const OAICreateFleetRequest_SessionScriptS3Location &session_script_s3_location) {
    m_session_script_s3_location = session_script_s3_location;
    m_session_script_s3_location_isSet = true;
}

bool OAIFleet::is_session_script_s3_location_Set() const{
    return m_session_script_s3_location_isSet;
}

bool OAIFleet::is_session_script_s3_location_Valid() const{
    return m_session_script_s3_location_isValid;
}

bool OAIFleet::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fleet_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_compute_capacity_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_user_duration_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disconnect_timeout_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_vpc_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fleet_errors.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_default_internet_access_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_domain_join_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_idle_disconnect_timeout_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_iam_role_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stream_view.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_concurrent_sessions_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_usb_device_filter_strings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_session_script_s3_location.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFleet::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_arn_isValid && m_name_isValid && m_instance_type_isValid && m_compute_capacity_status_isValid && m_state_isValid && true;
}

} // namespace OpenAPI
