/*
 * Amazon AppStream
 * <fullname>Amazon AppStream 2.0</fullname> <p>This is the <i>Amazon AppStream 2.0 API Reference</i>. This documentation provides descriptions and syntax for each of the actions and data types in AppStream 2.0. AppStream 2.0 is a fully managed, secure application streaming service that lets you stream desktop applications to users without rewriting applications. AppStream 2.0 manages the AWS resources that are required to host and run your applications, scales automatically, and provides access to your users on demand. </p> <note> <p>You can call the AppStream 2.0 API operations by using an interface VPC endpoint (interface endpoint). For more information, see <a href=\"https://docs.aws.amazon.com/appstream2/latest/developerguide/access-api-cli-through-interface-vpc-endpoint.html\">Access AppStream 2.0 API Operations and CLI Commands Through an Interface VPC Endpoint</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p> </note> <p>To learn more about AppStream 2.0, see the following resources:</p> <ul> <li> <p> <a href=\"http://aws.amazon.com/appstream2\">Amazon AppStream 2.0 product page</a> </p> </li> <li> <p> <a href=\"http://aws.amazon.com/documentation/appstream2\">Amazon AppStream 2.0 documentation</a> </p> </li> </ul>
 *
 * The version of the OpenAPI document: 2016-12-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AccessEndpointType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:27:46.976213-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AccessEndpoint {
  public static final String SERIALIZED_NAME_ENDPOINT_TYPE = "EndpointType";
  @SerializedName(SERIALIZED_NAME_ENDPOINT_TYPE)
  private AccessEndpointType endpointType;

  public static final String SERIALIZED_NAME_VPCE_ID = "VpceId";
  @SerializedName(SERIALIZED_NAME_VPCE_ID)
  private String vpceId;

  public AccessEndpoint() {
  }

  public AccessEndpoint endpointType(AccessEndpointType endpointType) {
    this.endpointType = endpointType;
    return this;
  }

  /**
   * Get endpointType
   * @return endpointType
   */
  @javax.annotation.Nonnull
  public AccessEndpointType getEndpointType() {
    return endpointType;
  }

  public void setEndpointType(AccessEndpointType endpointType) {
    this.endpointType = endpointType;
  }


  public AccessEndpoint vpceId(String vpceId) {
    this.vpceId = vpceId;
    return this;
  }

  /**
   * Get vpceId
   * @return vpceId
   */
  @javax.annotation.Nullable
  public String getVpceId() {
    return vpceId;
  }

  public void setVpceId(String vpceId) {
    this.vpceId = vpceId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccessEndpoint accessEndpoint = (AccessEndpoint) o;
    return Objects.equals(this.endpointType, accessEndpoint.endpointType) &&
        Objects.equals(this.vpceId, accessEndpoint.vpceId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(endpointType, vpceId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccessEndpoint {\n");
    sb.append("    endpointType: ").append(toIndentedString(endpointType)).append("\n");
    sb.append("    vpceId: ").append(toIndentedString(vpceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("EndpointType");
    openapiFields.add("VpceId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("EndpointType");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AccessEndpoint
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AccessEndpoint.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccessEndpoint is not found in the empty JSON string", AccessEndpoint.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AccessEndpoint.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AccessEndpoint` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AccessEndpoint.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `EndpointType`
      AccessEndpointType.validateJsonElement(jsonObj.get("EndpointType"));
      // validate the optional field `VpceId`
      if (jsonObj.get("VpceId") != null && !jsonObj.get("VpceId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("VpceId"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccessEndpoint.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccessEndpoint' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccessEndpoint> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccessEndpoint.class));

       return (TypeAdapter<T>) new TypeAdapter<AccessEndpoint>() {
           @Override
           public void write(JsonWriter out, AccessEndpoint value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AccessEndpoint read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AccessEndpoint given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AccessEndpoint
   * @throws IOException if the JSON string is invalid with respect to AccessEndpoint
   */
  public static AccessEndpoint fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccessEndpoint.class);
  }

  /**
   * Convert an instance of AccessEndpoint to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

