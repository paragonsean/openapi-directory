/**
 * AWS Ground Station
 * Welcome to the AWS Ground Station API Reference. AWS Ground Station is a fully managed service that enables you to control satellite communications, downlink and process satellite data, and scale your satellite operations efficiently and cost-effectively without having to build or manage your own ground station infrastructure.
 *
 * The version of the OpenAPI document: 2019-05-23
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGetMinuteUsageResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGetMinuteUsageResponse::OAIGetMinuteUsageResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGetMinuteUsageResponse::OAIGetMinuteUsageResponse() {
    this->initializeModel();
}

OAIGetMinuteUsageResponse::~OAIGetMinuteUsageResponse() {}

void OAIGetMinuteUsageResponse::initializeModel() {

    m_estimated_minutes_remaining_isSet = false;
    m_estimated_minutes_remaining_isValid = false;

    m_is_reserved_minutes_customer_isSet = false;
    m_is_reserved_minutes_customer_isValid = false;

    m_total_reserved_minute_allocation_isSet = false;
    m_total_reserved_minute_allocation_isValid = false;

    m_total_scheduled_minutes_isSet = false;
    m_total_scheduled_minutes_isValid = false;

    m_upcoming_minutes_scheduled_isSet = false;
    m_upcoming_minutes_scheduled_isValid = false;
}

void OAIGetMinuteUsageResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGetMinuteUsageResponse::fromJsonObject(QJsonObject json) {

    m_estimated_minutes_remaining_isValid = ::OpenAPI::fromJsonValue(m_estimated_minutes_remaining, json[QString("estimatedMinutesRemaining")]);
    m_estimated_minutes_remaining_isSet = !json[QString("estimatedMinutesRemaining")].isNull() && m_estimated_minutes_remaining_isValid;

    m_is_reserved_minutes_customer_isValid = ::OpenAPI::fromJsonValue(m_is_reserved_minutes_customer, json[QString("isReservedMinutesCustomer")]);
    m_is_reserved_minutes_customer_isSet = !json[QString("isReservedMinutesCustomer")].isNull() && m_is_reserved_minutes_customer_isValid;

    m_total_reserved_minute_allocation_isValid = ::OpenAPI::fromJsonValue(m_total_reserved_minute_allocation, json[QString("totalReservedMinuteAllocation")]);
    m_total_reserved_minute_allocation_isSet = !json[QString("totalReservedMinuteAllocation")].isNull() && m_total_reserved_minute_allocation_isValid;

    m_total_scheduled_minutes_isValid = ::OpenAPI::fromJsonValue(m_total_scheduled_minutes, json[QString("totalScheduledMinutes")]);
    m_total_scheduled_minutes_isSet = !json[QString("totalScheduledMinutes")].isNull() && m_total_scheduled_minutes_isValid;

    m_upcoming_minutes_scheduled_isValid = ::OpenAPI::fromJsonValue(m_upcoming_minutes_scheduled, json[QString("upcomingMinutesScheduled")]);
    m_upcoming_minutes_scheduled_isSet = !json[QString("upcomingMinutesScheduled")].isNull() && m_upcoming_minutes_scheduled_isValid;
}

QString OAIGetMinuteUsageResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGetMinuteUsageResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_estimated_minutes_remaining_isSet) {
        obj.insert(QString("estimatedMinutesRemaining"), ::OpenAPI::toJsonValue(m_estimated_minutes_remaining));
    }
    if (m_is_reserved_minutes_customer_isSet) {
        obj.insert(QString("isReservedMinutesCustomer"), ::OpenAPI::toJsonValue(m_is_reserved_minutes_customer));
    }
    if (m_total_reserved_minute_allocation_isSet) {
        obj.insert(QString("totalReservedMinuteAllocation"), ::OpenAPI::toJsonValue(m_total_reserved_minute_allocation));
    }
    if (m_total_scheduled_minutes_isSet) {
        obj.insert(QString("totalScheduledMinutes"), ::OpenAPI::toJsonValue(m_total_scheduled_minutes));
    }
    if (m_upcoming_minutes_scheduled_isSet) {
        obj.insert(QString("upcomingMinutesScheduled"), ::OpenAPI::toJsonValue(m_upcoming_minutes_scheduled));
    }
    return obj;
}

qint32 OAIGetMinuteUsageResponse::getEstimatedMinutesRemaining() const {
    return m_estimated_minutes_remaining;
}
void OAIGetMinuteUsageResponse::setEstimatedMinutesRemaining(const qint32 &estimated_minutes_remaining) {
    m_estimated_minutes_remaining = estimated_minutes_remaining;
    m_estimated_minutes_remaining_isSet = true;
}

bool OAIGetMinuteUsageResponse::is_estimated_minutes_remaining_Set() const{
    return m_estimated_minutes_remaining_isSet;
}

bool OAIGetMinuteUsageResponse::is_estimated_minutes_remaining_Valid() const{
    return m_estimated_minutes_remaining_isValid;
}

bool OAIGetMinuteUsageResponse::getIsReservedMinutesCustomer() const {
    return m_is_reserved_minutes_customer;
}
void OAIGetMinuteUsageResponse::setIsReservedMinutesCustomer(const bool &is_reserved_minutes_customer) {
    m_is_reserved_minutes_customer = is_reserved_minutes_customer;
    m_is_reserved_minutes_customer_isSet = true;
}

bool OAIGetMinuteUsageResponse::is_is_reserved_minutes_customer_Set() const{
    return m_is_reserved_minutes_customer_isSet;
}

bool OAIGetMinuteUsageResponse::is_is_reserved_minutes_customer_Valid() const{
    return m_is_reserved_minutes_customer_isValid;
}

qint32 OAIGetMinuteUsageResponse::getTotalReservedMinuteAllocation() const {
    return m_total_reserved_minute_allocation;
}
void OAIGetMinuteUsageResponse::setTotalReservedMinuteAllocation(const qint32 &total_reserved_minute_allocation) {
    m_total_reserved_minute_allocation = total_reserved_minute_allocation;
    m_total_reserved_minute_allocation_isSet = true;
}

bool OAIGetMinuteUsageResponse::is_total_reserved_minute_allocation_Set() const{
    return m_total_reserved_minute_allocation_isSet;
}

bool OAIGetMinuteUsageResponse::is_total_reserved_minute_allocation_Valid() const{
    return m_total_reserved_minute_allocation_isValid;
}

qint32 OAIGetMinuteUsageResponse::getTotalScheduledMinutes() const {
    return m_total_scheduled_minutes;
}
void OAIGetMinuteUsageResponse::setTotalScheduledMinutes(const qint32 &total_scheduled_minutes) {
    m_total_scheduled_minutes = total_scheduled_minutes;
    m_total_scheduled_minutes_isSet = true;
}

bool OAIGetMinuteUsageResponse::is_total_scheduled_minutes_Set() const{
    return m_total_scheduled_minutes_isSet;
}

bool OAIGetMinuteUsageResponse::is_total_scheduled_minutes_Valid() const{
    return m_total_scheduled_minutes_isValid;
}

qint32 OAIGetMinuteUsageResponse::getUpcomingMinutesScheduled() const {
    return m_upcoming_minutes_scheduled;
}
void OAIGetMinuteUsageResponse::setUpcomingMinutesScheduled(const qint32 &upcoming_minutes_scheduled) {
    m_upcoming_minutes_scheduled = upcoming_minutes_scheduled;
    m_upcoming_minutes_scheduled_isSet = true;
}

bool OAIGetMinuteUsageResponse::is_upcoming_minutes_scheduled_Set() const{
    return m_upcoming_minutes_scheduled_isSet;
}

bool OAIGetMinuteUsageResponse::is_upcoming_minutes_scheduled_Valid() const{
    return m_upcoming_minutes_scheduled_isValid;
}

bool OAIGetMinuteUsageResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_estimated_minutes_remaining_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_reserved_minutes_customer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_reserved_minute_allocation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_scheduled_minutes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_upcoming_minutes_scheduled_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGetMinuteUsageResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
