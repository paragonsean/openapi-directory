/**
 * AWS Elemental MediaLive
 * API for AWS Elemental MediaLive
 *
 * The version of the OpenAPI document: 2017-10-14
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVideoCodecSettings_Mpeg2Settings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVideoCodecSettings_Mpeg2Settings::OAIVideoCodecSettings_Mpeg2Settings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVideoCodecSettings_Mpeg2Settings::OAIVideoCodecSettings_Mpeg2Settings() {
    this->initializeModel();
}

OAIVideoCodecSettings_Mpeg2Settings::~OAIVideoCodecSettings_Mpeg2Settings() {}

void OAIVideoCodecSettings_Mpeg2Settings::initializeModel() {

    m_adaptive_quantization_isSet = false;
    m_adaptive_quantization_isValid = false;

    m_afd_signaling_isSet = false;
    m_afd_signaling_isValid = false;

    m_color_metadata_isSet = false;
    m_color_metadata_isValid = false;

    m_color_space_isSet = false;
    m_color_space_isValid = false;

    m_display_aspect_ratio_isSet = false;
    m_display_aspect_ratio_isValid = false;

    m_filter_settings_isSet = false;
    m_filter_settings_isValid = false;

    m_fixed_afd_isSet = false;
    m_fixed_afd_isValid = false;

    m_framerate_denominator_isSet = false;
    m_framerate_denominator_isValid = false;

    m_framerate_numerator_isSet = false;
    m_framerate_numerator_isValid = false;

    m_gop_closed_cadence_isSet = false;
    m_gop_closed_cadence_isValid = false;

    m_gop_num_b_frames_isSet = false;
    m_gop_num_b_frames_isValid = false;

    m_gop_size_isSet = false;
    m_gop_size_isValid = false;

    m_gop_size_units_isSet = false;
    m_gop_size_units_isValid = false;

    m_scan_type_isSet = false;
    m_scan_type_isValid = false;

    m_subgop_length_isSet = false;
    m_subgop_length_isValid = false;

    m_timecode_insertion_isSet = false;
    m_timecode_insertion_isValid = false;

    m_timecode_burnin_settings_isSet = false;
    m_timecode_burnin_settings_isValid = false;
}

void OAIVideoCodecSettings_Mpeg2Settings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVideoCodecSettings_Mpeg2Settings::fromJsonObject(QJsonObject json) {

    m_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_adaptive_quantization, json[QString("AdaptiveQuantization")]);
    m_adaptive_quantization_isSet = !json[QString("AdaptiveQuantization")].isNull() && m_adaptive_quantization_isValid;

    m_afd_signaling_isValid = ::OpenAPI::fromJsonValue(m_afd_signaling, json[QString("AfdSignaling")]);
    m_afd_signaling_isSet = !json[QString("AfdSignaling")].isNull() && m_afd_signaling_isValid;

    m_color_metadata_isValid = ::OpenAPI::fromJsonValue(m_color_metadata, json[QString("ColorMetadata")]);
    m_color_metadata_isSet = !json[QString("ColorMetadata")].isNull() && m_color_metadata_isValid;

    m_color_space_isValid = ::OpenAPI::fromJsonValue(m_color_space, json[QString("ColorSpace")]);
    m_color_space_isSet = !json[QString("ColorSpace")].isNull() && m_color_space_isValid;

    m_display_aspect_ratio_isValid = ::OpenAPI::fromJsonValue(m_display_aspect_ratio, json[QString("DisplayAspectRatio")]);
    m_display_aspect_ratio_isSet = !json[QString("DisplayAspectRatio")].isNull() && m_display_aspect_ratio_isValid;

    m_filter_settings_isValid = ::OpenAPI::fromJsonValue(m_filter_settings, json[QString("FilterSettings")]);
    m_filter_settings_isSet = !json[QString("FilterSettings")].isNull() && m_filter_settings_isValid;

    m_fixed_afd_isValid = ::OpenAPI::fromJsonValue(m_fixed_afd, json[QString("FixedAfd")]);
    m_fixed_afd_isSet = !json[QString("FixedAfd")].isNull() && m_fixed_afd_isValid;

    m_framerate_denominator_isValid = ::OpenAPI::fromJsonValue(m_framerate_denominator, json[QString("FramerateDenominator")]);
    m_framerate_denominator_isSet = !json[QString("FramerateDenominator")].isNull() && m_framerate_denominator_isValid;

    m_framerate_numerator_isValid = ::OpenAPI::fromJsonValue(m_framerate_numerator, json[QString("FramerateNumerator")]);
    m_framerate_numerator_isSet = !json[QString("FramerateNumerator")].isNull() && m_framerate_numerator_isValid;

    m_gop_closed_cadence_isValid = ::OpenAPI::fromJsonValue(m_gop_closed_cadence, json[QString("GopClosedCadence")]);
    m_gop_closed_cadence_isSet = !json[QString("GopClosedCadence")].isNull() && m_gop_closed_cadence_isValid;

    m_gop_num_b_frames_isValid = ::OpenAPI::fromJsonValue(m_gop_num_b_frames, json[QString("GopNumBFrames")]);
    m_gop_num_b_frames_isSet = !json[QString("GopNumBFrames")].isNull() && m_gop_num_b_frames_isValid;

    m_gop_size_isValid = ::OpenAPI::fromJsonValue(m_gop_size, json[QString("GopSize")]);
    m_gop_size_isSet = !json[QString("GopSize")].isNull() && m_gop_size_isValid;

    m_gop_size_units_isValid = ::OpenAPI::fromJsonValue(m_gop_size_units, json[QString("GopSizeUnits")]);
    m_gop_size_units_isSet = !json[QString("GopSizeUnits")].isNull() && m_gop_size_units_isValid;

    m_scan_type_isValid = ::OpenAPI::fromJsonValue(m_scan_type, json[QString("ScanType")]);
    m_scan_type_isSet = !json[QString("ScanType")].isNull() && m_scan_type_isValid;

    m_subgop_length_isValid = ::OpenAPI::fromJsonValue(m_subgop_length, json[QString("SubgopLength")]);
    m_subgop_length_isSet = !json[QString("SubgopLength")].isNull() && m_subgop_length_isValid;

    m_timecode_insertion_isValid = ::OpenAPI::fromJsonValue(m_timecode_insertion, json[QString("TimecodeInsertion")]);
    m_timecode_insertion_isSet = !json[QString("TimecodeInsertion")].isNull() && m_timecode_insertion_isValid;

    m_timecode_burnin_settings_isValid = ::OpenAPI::fromJsonValue(m_timecode_burnin_settings, json[QString("TimecodeBurninSettings")]);
    m_timecode_burnin_settings_isSet = !json[QString("TimecodeBurninSettings")].isNull() && m_timecode_burnin_settings_isValid;
}

QString OAIVideoCodecSettings_Mpeg2Settings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVideoCodecSettings_Mpeg2Settings::asJsonObject() const {
    QJsonObject obj;
    if (m_adaptive_quantization.isSet()) {
        obj.insert(QString("AdaptiveQuantization"), ::OpenAPI::toJsonValue(m_adaptive_quantization));
    }
    if (m_afd_signaling.isSet()) {
        obj.insert(QString("AfdSignaling"), ::OpenAPI::toJsonValue(m_afd_signaling));
    }
    if (m_color_metadata.isSet()) {
        obj.insert(QString("ColorMetadata"), ::OpenAPI::toJsonValue(m_color_metadata));
    }
    if (m_color_space.isSet()) {
        obj.insert(QString("ColorSpace"), ::OpenAPI::toJsonValue(m_color_space));
    }
    if (m_display_aspect_ratio.isSet()) {
        obj.insert(QString("DisplayAspectRatio"), ::OpenAPI::toJsonValue(m_display_aspect_ratio));
    }
    if (m_filter_settings.isSet()) {
        obj.insert(QString("FilterSettings"), ::OpenAPI::toJsonValue(m_filter_settings));
    }
    if (m_fixed_afd.isSet()) {
        obj.insert(QString("FixedAfd"), ::OpenAPI::toJsonValue(m_fixed_afd));
    }
    if (m_framerate_denominator_isSet) {
        obj.insert(QString("FramerateDenominator"), ::OpenAPI::toJsonValue(m_framerate_denominator));
    }
    if (m_framerate_numerator_isSet) {
        obj.insert(QString("FramerateNumerator"), ::OpenAPI::toJsonValue(m_framerate_numerator));
    }
    if (m_gop_closed_cadence_isSet) {
        obj.insert(QString("GopClosedCadence"), ::OpenAPI::toJsonValue(m_gop_closed_cadence));
    }
    if (m_gop_num_b_frames_isSet) {
        obj.insert(QString("GopNumBFrames"), ::OpenAPI::toJsonValue(m_gop_num_b_frames));
    }
    if (m_gop_size_isSet) {
        obj.insert(QString("GopSize"), ::OpenAPI::toJsonValue(m_gop_size));
    }
    if (m_gop_size_units.isSet()) {
        obj.insert(QString("GopSizeUnits"), ::OpenAPI::toJsonValue(m_gop_size_units));
    }
    if (m_scan_type.isSet()) {
        obj.insert(QString("ScanType"), ::OpenAPI::toJsonValue(m_scan_type));
    }
    if (m_subgop_length.isSet()) {
        obj.insert(QString("SubgopLength"), ::OpenAPI::toJsonValue(m_subgop_length));
    }
    if (m_timecode_insertion.isSet()) {
        obj.insert(QString("TimecodeInsertion"), ::OpenAPI::toJsonValue(m_timecode_insertion));
    }
    if (m_timecode_burnin_settings.isSet()) {
        obj.insert(QString("TimecodeBurninSettings"), ::OpenAPI::toJsonValue(m_timecode_burnin_settings));
    }
    return obj;
}

OAIMpeg2AdaptiveQuantization OAIVideoCodecSettings_Mpeg2Settings::getAdaptiveQuantization() const {
    return m_adaptive_quantization;
}
void OAIVideoCodecSettings_Mpeg2Settings::setAdaptiveQuantization(const OAIMpeg2AdaptiveQuantization &adaptive_quantization) {
    m_adaptive_quantization = adaptive_quantization;
    m_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_adaptive_quantization_Set() const{
    return m_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_adaptive_quantization_Valid() const{
    return m_adaptive_quantization_isValid;
}

OAIAfdSignaling OAIVideoCodecSettings_Mpeg2Settings::getAfdSignaling() const {
    return m_afd_signaling;
}
void OAIVideoCodecSettings_Mpeg2Settings::setAfdSignaling(const OAIAfdSignaling &afd_signaling) {
    m_afd_signaling = afd_signaling;
    m_afd_signaling_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_afd_signaling_Set() const{
    return m_afd_signaling_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_afd_signaling_Valid() const{
    return m_afd_signaling_isValid;
}

OAIMpeg2ColorMetadata OAIVideoCodecSettings_Mpeg2Settings::getColorMetadata() const {
    return m_color_metadata;
}
void OAIVideoCodecSettings_Mpeg2Settings::setColorMetadata(const OAIMpeg2ColorMetadata &color_metadata) {
    m_color_metadata = color_metadata;
    m_color_metadata_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_color_metadata_Set() const{
    return m_color_metadata_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_color_metadata_Valid() const{
    return m_color_metadata_isValid;
}

OAIMpeg2ColorSpace OAIVideoCodecSettings_Mpeg2Settings::getColorSpace() const {
    return m_color_space;
}
void OAIVideoCodecSettings_Mpeg2Settings::setColorSpace(const OAIMpeg2ColorSpace &color_space) {
    m_color_space = color_space;
    m_color_space_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_color_space_Set() const{
    return m_color_space_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_color_space_Valid() const{
    return m_color_space_isValid;
}

OAIMpeg2DisplayRatio OAIVideoCodecSettings_Mpeg2Settings::getDisplayAspectRatio() const {
    return m_display_aspect_ratio;
}
void OAIVideoCodecSettings_Mpeg2Settings::setDisplayAspectRatio(const OAIMpeg2DisplayRatio &display_aspect_ratio) {
    m_display_aspect_ratio = display_aspect_ratio;
    m_display_aspect_ratio_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_display_aspect_ratio_Set() const{
    return m_display_aspect_ratio_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_display_aspect_ratio_Valid() const{
    return m_display_aspect_ratio_isValid;
}

OAIMpeg2Settings_FilterSettings OAIVideoCodecSettings_Mpeg2Settings::getFilterSettings() const {
    return m_filter_settings;
}
void OAIVideoCodecSettings_Mpeg2Settings::setFilterSettings(const OAIMpeg2Settings_FilterSettings &filter_settings) {
    m_filter_settings = filter_settings;
    m_filter_settings_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_filter_settings_Set() const{
    return m_filter_settings_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_filter_settings_Valid() const{
    return m_filter_settings_isValid;
}

OAIFixedAfd OAIVideoCodecSettings_Mpeg2Settings::getFixedAfd() const {
    return m_fixed_afd;
}
void OAIVideoCodecSettings_Mpeg2Settings::setFixedAfd(const OAIFixedAfd &fixed_afd) {
    m_fixed_afd = fixed_afd;
    m_fixed_afd_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_fixed_afd_Set() const{
    return m_fixed_afd_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_fixed_afd_Valid() const{
    return m_fixed_afd_isValid;
}

qint32 OAIVideoCodecSettings_Mpeg2Settings::getFramerateDenominator() const {
    return m_framerate_denominator;
}
void OAIVideoCodecSettings_Mpeg2Settings::setFramerateDenominator(const qint32 &framerate_denominator) {
    m_framerate_denominator = framerate_denominator;
    m_framerate_denominator_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_framerate_denominator_Set() const{
    return m_framerate_denominator_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_framerate_denominator_Valid() const{
    return m_framerate_denominator_isValid;
}

qint32 OAIVideoCodecSettings_Mpeg2Settings::getFramerateNumerator() const {
    return m_framerate_numerator;
}
void OAIVideoCodecSettings_Mpeg2Settings::setFramerateNumerator(const qint32 &framerate_numerator) {
    m_framerate_numerator = framerate_numerator;
    m_framerate_numerator_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_framerate_numerator_Set() const{
    return m_framerate_numerator_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_framerate_numerator_Valid() const{
    return m_framerate_numerator_isValid;
}

qint32 OAIVideoCodecSettings_Mpeg2Settings::getGopClosedCadence() const {
    return m_gop_closed_cadence;
}
void OAIVideoCodecSettings_Mpeg2Settings::setGopClosedCadence(const qint32 &gop_closed_cadence) {
    m_gop_closed_cadence = gop_closed_cadence;
    m_gop_closed_cadence_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_closed_cadence_Set() const{
    return m_gop_closed_cadence_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_closed_cadence_Valid() const{
    return m_gop_closed_cadence_isValid;
}

qint32 OAIVideoCodecSettings_Mpeg2Settings::getGopNumBFrames() const {
    return m_gop_num_b_frames;
}
void OAIVideoCodecSettings_Mpeg2Settings::setGopNumBFrames(const qint32 &gop_num_b_frames) {
    m_gop_num_b_frames = gop_num_b_frames;
    m_gop_num_b_frames_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_num_b_frames_Set() const{
    return m_gop_num_b_frames_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_num_b_frames_Valid() const{
    return m_gop_num_b_frames_isValid;
}

double OAIVideoCodecSettings_Mpeg2Settings::getGopSize() const {
    return m_gop_size;
}
void OAIVideoCodecSettings_Mpeg2Settings::setGopSize(const double &gop_size) {
    m_gop_size = gop_size;
    m_gop_size_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_size_Set() const{
    return m_gop_size_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_size_Valid() const{
    return m_gop_size_isValid;
}

OAIMpeg2GopSizeUnits OAIVideoCodecSettings_Mpeg2Settings::getGopSizeUnits() const {
    return m_gop_size_units;
}
void OAIVideoCodecSettings_Mpeg2Settings::setGopSizeUnits(const OAIMpeg2GopSizeUnits &gop_size_units) {
    m_gop_size_units = gop_size_units;
    m_gop_size_units_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_size_units_Set() const{
    return m_gop_size_units_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_gop_size_units_Valid() const{
    return m_gop_size_units_isValid;
}

OAIMpeg2ScanType OAIVideoCodecSettings_Mpeg2Settings::getScanType() const {
    return m_scan_type;
}
void OAIVideoCodecSettings_Mpeg2Settings::setScanType(const OAIMpeg2ScanType &scan_type) {
    m_scan_type = scan_type;
    m_scan_type_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_scan_type_Set() const{
    return m_scan_type_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_scan_type_Valid() const{
    return m_scan_type_isValid;
}

OAIMpeg2SubGopLength OAIVideoCodecSettings_Mpeg2Settings::getSubgopLength() const {
    return m_subgop_length;
}
void OAIVideoCodecSettings_Mpeg2Settings::setSubgopLength(const OAIMpeg2SubGopLength &subgop_length) {
    m_subgop_length = subgop_length;
    m_subgop_length_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_subgop_length_Set() const{
    return m_subgop_length_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_subgop_length_Valid() const{
    return m_subgop_length_isValid;
}

OAIMpeg2TimecodeInsertionBehavior OAIVideoCodecSettings_Mpeg2Settings::getTimecodeInsertion() const {
    return m_timecode_insertion;
}
void OAIVideoCodecSettings_Mpeg2Settings::setTimecodeInsertion(const OAIMpeg2TimecodeInsertionBehavior &timecode_insertion) {
    m_timecode_insertion = timecode_insertion;
    m_timecode_insertion_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_timecode_insertion_Set() const{
    return m_timecode_insertion_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_timecode_insertion_Valid() const{
    return m_timecode_insertion_isValid;
}

OAIFrameCaptureSettings_TimecodeBurninSettings OAIVideoCodecSettings_Mpeg2Settings::getTimecodeBurninSettings() const {
    return m_timecode_burnin_settings;
}
void OAIVideoCodecSettings_Mpeg2Settings::setTimecodeBurninSettings(const OAIFrameCaptureSettings_TimecodeBurninSettings &timecode_burnin_settings) {
    m_timecode_burnin_settings = timecode_burnin_settings;
    m_timecode_burnin_settings_isSet = true;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_timecode_burnin_settings_Set() const{
    return m_timecode_burnin_settings_isSet;
}

bool OAIVideoCodecSettings_Mpeg2Settings::is_timecode_burnin_settings_Valid() const{
    return m_timecode_burnin_settings_isValid;
}

bool OAIVideoCodecSettings_Mpeg2Settings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_afd_signaling.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_aspect_ratio.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_filter_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_fixed_afd.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_closed_cadence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_num_b_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_units.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scan_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subgop_length.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timecode_insertion.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timecode_burnin_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVideoCodecSettings_Mpeg2Settings::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_framerate_denominator_isValid && m_framerate_numerator_isValid && true;
}

} // namespace OpenAPI
