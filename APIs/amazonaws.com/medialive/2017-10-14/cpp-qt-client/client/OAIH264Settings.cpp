/**
 * AWS Elemental MediaLive
 * API for AWS Elemental MediaLive
 *
 * The version of the OpenAPI document: 2017-10-14
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIH264Settings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIH264Settings::OAIH264Settings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIH264Settings::OAIH264Settings() {
    this->initializeModel();
}

OAIH264Settings::~OAIH264Settings() {}

void OAIH264Settings::initializeModel() {

    m_adaptive_quantization_isSet = false;
    m_adaptive_quantization_isValid = false;

    m_afd_signaling_isSet = false;
    m_afd_signaling_isValid = false;

    m_bitrate_isSet = false;
    m_bitrate_isValid = false;

    m_buf_fill_pct_isSet = false;
    m_buf_fill_pct_isValid = false;

    m_buf_size_isSet = false;
    m_buf_size_isValid = false;

    m_color_metadata_isSet = false;
    m_color_metadata_isValid = false;

    m_color_space_settings_isSet = false;
    m_color_space_settings_isValid = false;

    m_entropy_encoding_isSet = false;
    m_entropy_encoding_isValid = false;

    m_filter_settings_isSet = false;
    m_filter_settings_isValid = false;

    m_fixed_afd_isSet = false;
    m_fixed_afd_isValid = false;

    m_flicker_aq_isSet = false;
    m_flicker_aq_isValid = false;

    m_force_field_pictures_isSet = false;
    m_force_field_pictures_isValid = false;

    m_framerate_control_isSet = false;
    m_framerate_control_isValid = false;

    m_framerate_denominator_isSet = false;
    m_framerate_denominator_isValid = false;

    m_framerate_numerator_isSet = false;
    m_framerate_numerator_isValid = false;

    m_gop_b_reference_isSet = false;
    m_gop_b_reference_isValid = false;

    m_gop_closed_cadence_isSet = false;
    m_gop_closed_cadence_isValid = false;

    m_gop_num_b_frames_isSet = false;
    m_gop_num_b_frames_isValid = false;

    m_gop_size_isSet = false;
    m_gop_size_isValid = false;

    m_gop_size_units_isSet = false;
    m_gop_size_units_isValid = false;

    m_level_isSet = false;
    m_level_isValid = false;

    m_look_ahead_rate_control_isSet = false;
    m_look_ahead_rate_control_isValid = false;

    m_max_bitrate_isSet = false;
    m_max_bitrate_isValid = false;

    m_min_i_interval_isSet = false;
    m_min_i_interval_isValid = false;

    m_num_ref_frames_isSet = false;
    m_num_ref_frames_isValid = false;

    m_par_control_isSet = false;
    m_par_control_isValid = false;

    m_par_denominator_isSet = false;
    m_par_denominator_isValid = false;

    m_par_numerator_isSet = false;
    m_par_numerator_isValid = false;

    m_profile_isSet = false;
    m_profile_isValid = false;

    m_quality_level_isSet = false;
    m_quality_level_isValid = false;

    m_qvbr_quality_level_isSet = false;
    m_qvbr_quality_level_isValid = false;

    m_rate_control_mode_isSet = false;
    m_rate_control_mode_isValid = false;

    m_scan_type_isSet = false;
    m_scan_type_isValid = false;

    m_scene_change_detect_isSet = false;
    m_scene_change_detect_isValid = false;

    m_slices_isSet = false;
    m_slices_isValid = false;

    m_softness_isSet = false;
    m_softness_isValid = false;

    m_spatial_aq_isSet = false;
    m_spatial_aq_isValid = false;

    m_subgop_length_isSet = false;
    m_subgop_length_isValid = false;

    m_syntax_isSet = false;
    m_syntax_isValid = false;

    m_temporal_aq_isSet = false;
    m_temporal_aq_isValid = false;

    m_timecode_insertion_isSet = false;
    m_timecode_insertion_isValid = false;

    m_timecode_burnin_settings_isSet = false;
    m_timecode_burnin_settings_isValid = false;
}

void OAIH264Settings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIH264Settings::fromJsonObject(QJsonObject json) {

    m_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_adaptive_quantization, json[QString("AdaptiveQuantization")]);
    m_adaptive_quantization_isSet = !json[QString("AdaptiveQuantization")].isNull() && m_adaptive_quantization_isValid;

    m_afd_signaling_isValid = ::OpenAPI::fromJsonValue(m_afd_signaling, json[QString("AfdSignaling")]);
    m_afd_signaling_isSet = !json[QString("AfdSignaling")].isNull() && m_afd_signaling_isValid;

    m_bitrate_isValid = ::OpenAPI::fromJsonValue(m_bitrate, json[QString("Bitrate")]);
    m_bitrate_isSet = !json[QString("Bitrate")].isNull() && m_bitrate_isValid;

    m_buf_fill_pct_isValid = ::OpenAPI::fromJsonValue(m_buf_fill_pct, json[QString("BufFillPct")]);
    m_buf_fill_pct_isSet = !json[QString("BufFillPct")].isNull() && m_buf_fill_pct_isValid;

    m_buf_size_isValid = ::OpenAPI::fromJsonValue(m_buf_size, json[QString("BufSize")]);
    m_buf_size_isSet = !json[QString("BufSize")].isNull() && m_buf_size_isValid;

    m_color_metadata_isValid = ::OpenAPI::fromJsonValue(m_color_metadata, json[QString("ColorMetadata")]);
    m_color_metadata_isSet = !json[QString("ColorMetadata")].isNull() && m_color_metadata_isValid;

    m_color_space_settings_isValid = ::OpenAPI::fromJsonValue(m_color_space_settings, json[QString("ColorSpaceSettings")]);
    m_color_space_settings_isSet = !json[QString("ColorSpaceSettings")].isNull() && m_color_space_settings_isValid;

    m_entropy_encoding_isValid = ::OpenAPI::fromJsonValue(m_entropy_encoding, json[QString("EntropyEncoding")]);
    m_entropy_encoding_isSet = !json[QString("EntropyEncoding")].isNull() && m_entropy_encoding_isValid;

    m_filter_settings_isValid = ::OpenAPI::fromJsonValue(m_filter_settings, json[QString("FilterSettings")]);
    m_filter_settings_isSet = !json[QString("FilterSettings")].isNull() && m_filter_settings_isValid;

    m_fixed_afd_isValid = ::OpenAPI::fromJsonValue(m_fixed_afd, json[QString("FixedAfd")]);
    m_fixed_afd_isSet = !json[QString("FixedAfd")].isNull() && m_fixed_afd_isValid;

    m_flicker_aq_isValid = ::OpenAPI::fromJsonValue(m_flicker_aq, json[QString("FlickerAq")]);
    m_flicker_aq_isSet = !json[QString("FlickerAq")].isNull() && m_flicker_aq_isValid;

    m_force_field_pictures_isValid = ::OpenAPI::fromJsonValue(m_force_field_pictures, json[QString("ForceFieldPictures")]);
    m_force_field_pictures_isSet = !json[QString("ForceFieldPictures")].isNull() && m_force_field_pictures_isValid;

    m_framerate_control_isValid = ::OpenAPI::fromJsonValue(m_framerate_control, json[QString("FramerateControl")]);
    m_framerate_control_isSet = !json[QString("FramerateControl")].isNull() && m_framerate_control_isValid;

    m_framerate_denominator_isValid = ::OpenAPI::fromJsonValue(m_framerate_denominator, json[QString("FramerateDenominator")]);
    m_framerate_denominator_isSet = !json[QString("FramerateDenominator")].isNull() && m_framerate_denominator_isValid;

    m_framerate_numerator_isValid = ::OpenAPI::fromJsonValue(m_framerate_numerator, json[QString("FramerateNumerator")]);
    m_framerate_numerator_isSet = !json[QString("FramerateNumerator")].isNull() && m_framerate_numerator_isValid;

    m_gop_b_reference_isValid = ::OpenAPI::fromJsonValue(m_gop_b_reference, json[QString("GopBReference")]);
    m_gop_b_reference_isSet = !json[QString("GopBReference")].isNull() && m_gop_b_reference_isValid;

    m_gop_closed_cadence_isValid = ::OpenAPI::fromJsonValue(m_gop_closed_cadence, json[QString("GopClosedCadence")]);
    m_gop_closed_cadence_isSet = !json[QString("GopClosedCadence")].isNull() && m_gop_closed_cadence_isValid;

    m_gop_num_b_frames_isValid = ::OpenAPI::fromJsonValue(m_gop_num_b_frames, json[QString("GopNumBFrames")]);
    m_gop_num_b_frames_isSet = !json[QString("GopNumBFrames")].isNull() && m_gop_num_b_frames_isValid;

    m_gop_size_isValid = ::OpenAPI::fromJsonValue(m_gop_size, json[QString("GopSize")]);
    m_gop_size_isSet = !json[QString("GopSize")].isNull() && m_gop_size_isValid;

    m_gop_size_units_isValid = ::OpenAPI::fromJsonValue(m_gop_size_units, json[QString("GopSizeUnits")]);
    m_gop_size_units_isSet = !json[QString("GopSizeUnits")].isNull() && m_gop_size_units_isValid;

    m_level_isValid = ::OpenAPI::fromJsonValue(m_level, json[QString("Level")]);
    m_level_isSet = !json[QString("Level")].isNull() && m_level_isValid;

    m_look_ahead_rate_control_isValid = ::OpenAPI::fromJsonValue(m_look_ahead_rate_control, json[QString("LookAheadRateControl")]);
    m_look_ahead_rate_control_isSet = !json[QString("LookAheadRateControl")].isNull() && m_look_ahead_rate_control_isValid;

    m_max_bitrate_isValid = ::OpenAPI::fromJsonValue(m_max_bitrate, json[QString("MaxBitrate")]);
    m_max_bitrate_isSet = !json[QString("MaxBitrate")].isNull() && m_max_bitrate_isValid;

    m_min_i_interval_isValid = ::OpenAPI::fromJsonValue(m_min_i_interval, json[QString("MinIInterval")]);
    m_min_i_interval_isSet = !json[QString("MinIInterval")].isNull() && m_min_i_interval_isValid;

    m_num_ref_frames_isValid = ::OpenAPI::fromJsonValue(m_num_ref_frames, json[QString("NumRefFrames")]);
    m_num_ref_frames_isSet = !json[QString("NumRefFrames")].isNull() && m_num_ref_frames_isValid;

    m_par_control_isValid = ::OpenAPI::fromJsonValue(m_par_control, json[QString("ParControl")]);
    m_par_control_isSet = !json[QString("ParControl")].isNull() && m_par_control_isValid;

    m_par_denominator_isValid = ::OpenAPI::fromJsonValue(m_par_denominator, json[QString("ParDenominator")]);
    m_par_denominator_isSet = !json[QString("ParDenominator")].isNull() && m_par_denominator_isValid;

    m_par_numerator_isValid = ::OpenAPI::fromJsonValue(m_par_numerator, json[QString("ParNumerator")]);
    m_par_numerator_isSet = !json[QString("ParNumerator")].isNull() && m_par_numerator_isValid;

    m_profile_isValid = ::OpenAPI::fromJsonValue(m_profile, json[QString("Profile")]);
    m_profile_isSet = !json[QString("Profile")].isNull() && m_profile_isValid;

    m_quality_level_isValid = ::OpenAPI::fromJsonValue(m_quality_level, json[QString("QualityLevel")]);
    m_quality_level_isSet = !json[QString("QualityLevel")].isNull() && m_quality_level_isValid;

    m_qvbr_quality_level_isValid = ::OpenAPI::fromJsonValue(m_qvbr_quality_level, json[QString("QvbrQualityLevel")]);
    m_qvbr_quality_level_isSet = !json[QString("QvbrQualityLevel")].isNull() && m_qvbr_quality_level_isValid;

    m_rate_control_mode_isValid = ::OpenAPI::fromJsonValue(m_rate_control_mode, json[QString("RateControlMode")]);
    m_rate_control_mode_isSet = !json[QString("RateControlMode")].isNull() && m_rate_control_mode_isValid;

    m_scan_type_isValid = ::OpenAPI::fromJsonValue(m_scan_type, json[QString("ScanType")]);
    m_scan_type_isSet = !json[QString("ScanType")].isNull() && m_scan_type_isValid;

    m_scene_change_detect_isValid = ::OpenAPI::fromJsonValue(m_scene_change_detect, json[QString("SceneChangeDetect")]);
    m_scene_change_detect_isSet = !json[QString("SceneChangeDetect")].isNull() && m_scene_change_detect_isValid;

    m_slices_isValid = ::OpenAPI::fromJsonValue(m_slices, json[QString("Slices")]);
    m_slices_isSet = !json[QString("Slices")].isNull() && m_slices_isValid;

    m_softness_isValid = ::OpenAPI::fromJsonValue(m_softness, json[QString("Softness")]);
    m_softness_isSet = !json[QString("Softness")].isNull() && m_softness_isValid;

    m_spatial_aq_isValid = ::OpenAPI::fromJsonValue(m_spatial_aq, json[QString("SpatialAq")]);
    m_spatial_aq_isSet = !json[QString("SpatialAq")].isNull() && m_spatial_aq_isValid;

    m_subgop_length_isValid = ::OpenAPI::fromJsonValue(m_subgop_length, json[QString("SubgopLength")]);
    m_subgop_length_isSet = !json[QString("SubgopLength")].isNull() && m_subgop_length_isValid;

    m_syntax_isValid = ::OpenAPI::fromJsonValue(m_syntax, json[QString("Syntax")]);
    m_syntax_isSet = !json[QString("Syntax")].isNull() && m_syntax_isValid;

    m_temporal_aq_isValid = ::OpenAPI::fromJsonValue(m_temporal_aq, json[QString("TemporalAq")]);
    m_temporal_aq_isSet = !json[QString("TemporalAq")].isNull() && m_temporal_aq_isValid;

    m_timecode_insertion_isValid = ::OpenAPI::fromJsonValue(m_timecode_insertion, json[QString("TimecodeInsertion")]);
    m_timecode_insertion_isSet = !json[QString("TimecodeInsertion")].isNull() && m_timecode_insertion_isValid;

    m_timecode_burnin_settings_isValid = ::OpenAPI::fromJsonValue(m_timecode_burnin_settings, json[QString("TimecodeBurninSettings")]);
    m_timecode_burnin_settings_isSet = !json[QString("TimecodeBurninSettings")].isNull() && m_timecode_burnin_settings_isValid;
}

QString OAIH264Settings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIH264Settings::asJsonObject() const {
    QJsonObject obj;
    if (m_adaptive_quantization.isSet()) {
        obj.insert(QString("AdaptiveQuantization"), ::OpenAPI::toJsonValue(m_adaptive_quantization));
    }
    if (m_afd_signaling.isSet()) {
        obj.insert(QString("AfdSignaling"), ::OpenAPI::toJsonValue(m_afd_signaling));
    }
    if (m_bitrate_isSet) {
        obj.insert(QString("Bitrate"), ::OpenAPI::toJsonValue(m_bitrate));
    }
    if (m_buf_fill_pct_isSet) {
        obj.insert(QString("BufFillPct"), ::OpenAPI::toJsonValue(m_buf_fill_pct));
    }
    if (m_buf_size_isSet) {
        obj.insert(QString("BufSize"), ::OpenAPI::toJsonValue(m_buf_size));
    }
    if (m_color_metadata.isSet()) {
        obj.insert(QString("ColorMetadata"), ::OpenAPI::toJsonValue(m_color_metadata));
    }
    if (m_color_space_settings.isSet()) {
        obj.insert(QString("ColorSpaceSettings"), ::OpenAPI::toJsonValue(m_color_space_settings));
    }
    if (m_entropy_encoding.isSet()) {
        obj.insert(QString("EntropyEncoding"), ::OpenAPI::toJsonValue(m_entropy_encoding));
    }
    if (m_filter_settings.isSet()) {
        obj.insert(QString("FilterSettings"), ::OpenAPI::toJsonValue(m_filter_settings));
    }
    if (m_fixed_afd.isSet()) {
        obj.insert(QString("FixedAfd"), ::OpenAPI::toJsonValue(m_fixed_afd));
    }
    if (m_flicker_aq.isSet()) {
        obj.insert(QString("FlickerAq"), ::OpenAPI::toJsonValue(m_flicker_aq));
    }
    if (m_force_field_pictures.isSet()) {
        obj.insert(QString("ForceFieldPictures"), ::OpenAPI::toJsonValue(m_force_field_pictures));
    }
    if (m_framerate_control.isSet()) {
        obj.insert(QString("FramerateControl"), ::OpenAPI::toJsonValue(m_framerate_control));
    }
    if (m_framerate_denominator_isSet) {
        obj.insert(QString("FramerateDenominator"), ::OpenAPI::toJsonValue(m_framerate_denominator));
    }
    if (m_framerate_numerator_isSet) {
        obj.insert(QString("FramerateNumerator"), ::OpenAPI::toJsonValue(m_framerate_numerator));
    }
    if (m_gop_b_reference.isSet()) {
        obj.insert(QString("GopBReference"), ::OpenAPI::toJsonValue(m_gop_b_reference));
    }
    if (m_gop_closed_cadence_isSet) {
        obj.insert(QString("GopClosedCadence"), ::OpenAPI::toJsonValue(m_gop_closed_cadence));
    }
    if (m_gop_num_b_frames_isSet) {
        obj.insert(QString("GopNumBFrames"), ::OpenAPI::toJsonValue(m_gop_num_b_frames));
    }
    if (m_gop_size_isSet) {
        obj.insert(QString("GopSize"), ::OpenAPI::toJsonValue(m_gop_size));
    }
    if (m_gop_size_units.isSet()) {
        obj.insert(QString("GopSizeUnits"), ::OpenAPI::toJsonValue(m_gop_size_units));
    }
    if (m_level.isSet()) {
        obj.insert(QString("Level"), ::OpenAPI::toJsonValue(m_level));
    }
    if (m_look_ahead_rate_control.isSet()) {
        obj.insert(QString("LookAheadRateControl"), ::OpenAPI::toJsonValue(m_look_ahead_rate_control));
    }
    if (m_max_bitrate_isSet) {
        obj.insert(QString("MaxBitrate"), ::OpenAPI::toJsonValue(m_max_bitrate));
    }
    if (m_min_i_interval_isSet) {
        obj.insert(QString("MinIInterval"), ::OpenAPI::toJsonValue(m_min_i_interval));
    }
    if (m_num_ref_frames_isSet) {
        obj.insert(QString("NumRefFrames"), ::OpenAPI::toJsonValue(m_num_ref_frames));
    }
    if (m_par_control.isSet()) {
        obj.insert(QString("ParControl"), ::OpenAPI::toJsonValue(m_par_control));
    }
    if (m_par_denominator_isSet) {
        obj.insert(QString("ParDenominator"), ::OpenAPI::toJsonValue(m_par_denominator));
    }
    if (m_par_numerator_isSet) {
        obj.insert(QString("ParNumerator"), ::OpenAPI::toJsonValue(m_par_numerator));
    }
    if (m_profile.isSet()) {
        obj.insert(QString("Profile"), ::OpenAPI::toJsonValue(m_profile));
    }
    if (m_quality_level.isSet()) {
        obj.insert(QString("QualityLevel"), ::OpenAPI::toJsonValue(m_quality_level));
    }
    if (m_qvbr_quality_level_isSet) {
        obj.insert(QString("QvbrQualityLevel"), ::OpenAPI::toJsonValue(m_qvbr_quality_level));
    }
    if (m_rate_control_mode.isSet()) {
        obj.insert(QString("RateControlMode"), ::OpenAPI::toJsonValue(m_rate_control_mode));
    }
    if (m_scan_type.isSet()) {
        obj.insert(QString("ScanType"), ::OpenAPI::toJsonValue(m_scan_type));
    }
    if (m_scene_change_detect.isSet()) {
        obj.insert(QString("SceneChangeDetect"), ::OpenAPI::toJsonValue(m_scene_change_detect));
    }
    if (m_slices_isSet) {
        obj.insert(QString("Slices"), ::OpenAPI::toJsonValue(m_slices));
    }
    if (m_softness_isSet) {
        obj.insert(QString("Softness"), ::OpenAPI::toJsonValue(m_softness));
    }
    if (m_spatial_aq.isSet()) {
        obj.insert(QString("SpatialAq"), ::OpenAPI::toJsonValue(m_spatial_aq));
    }
    if (m_subgop_length.isSet()) {
        obj.insert(QString("SubgopLength"), ::OpenAPI::toJsonValue(m_subgop_length));
    }
    if (m_syntax.isSet()) {
        obj.insert(QString("Syntax"), ::OpenAPI::toJsonValue(m_syntax));
    }
    if (m_temporal_aq.isSet()) {
        obj.insert(QString("TemporalAq"), ::OpenAPI::toJsonValue(m_temporal_aq));
    }
    if (m_timecode_insertion.isSet()) {
        obj.insert(QString("TimecodeInsertion"), ::OpenAPI::toJsonValue(m_timecode_insertion));
    }
    if (m_timecode_burnin_settings.isSet()) {
        obj.insert(QString("TimecodeBurninSettings"), ::OpenAPI::toJsonValue(m_timecode_burnin_settings));
    }
    return obj;
}

OAIH264AdaptiveQuantization OAIH264Settings::getAdaptiveQuantization() const {
    return m_adaptive_quantization;
}
void OAIH264Settings::setAdaptiveQuantization(const OAIH264AdaptiveQuantization &adaptive_quantization) {
    m_adaptive_quantization = adaptive_quantization;
    m_adaptive_quantization_isSet = true;
}

bool OAIH264Settings::is_adaptive_quantization_Set() const{
    return m_adaptive_quantization_isSet;
}

bool OAIH264Settings::is_adaptive_quantization_Valid() const{
    return m_adaptive_quantization_isValid;
}

OAIAfdSignaling OAIH264Settings::getAfdSignaling() const {
    return m_afd_signaling;
}
void OAIH264Settings::setAfdSignaling(const OAIAfdSignaling &afd_signaling) {
    m_afd_signaling = afd_signaling;
    m_afd_signaling_isSet = true;
}

bool OAIH264Settings::is_afd_signaling_Set() const{
    return m_afd_signaling_isSet;
}

bool OAIH264Settings::is_afd_signaling_Valid() const{
    return m_afd_signaling_isValid;
}

qint32 OAIH264Settings::getBitrate() const {
    return m_bitrate;
}
void OAIH264Settings::setBitrate(const qint32 &bitrate) {
    m_bitrate = bitrate;
    m_bitrate_isSet = true;
}

bool OAIH264Settings::is_bitrate_Set() const{
    return m_bitrate_isSet;
}

bool OAIH264Settings::is_bitrate_Valid() const{
    return m_bitrate_isValid;
}

qint32 OAIH264Settings::getBufFillPct() const {
    return m_buf_fill_pct;
}
void OAIH264Settings::setBufFillPct(const qint32 &buf_fill_pct) {
    m_buf_fill_pct = buf_fill_pct;
    m_buf_fill_pct_isSet = true;
}

bool OAIH264Settings::is_buf_fill_pct_Set() const{
    return m_buf_fill_pct_isSet;
}

bool OAIH264Settings::is_buf_fill_pct_Valid() const{
    return m_buf_fill_pct_isValid;
}

qint32 OAIH264Settings::getBufSize() const {
    return m_buf_size;
}
void OAIH264Settings::setBufSize(const qint32 &buf_size) {
    m_buf_size = buf_size;
    m_buf_size_isSet = true;
}

bool OAIH264Settings::is_buf_size_Set() const{
    return m_buf_size_isSet;
}

bool OAIH264Settings::is_buf_size_Valid() const{
    return m_buf_size_isValid;
}

OAIH264ColorMetadata OAIH264Settings::getColorMetadata() const {
    return m_color_metadata;
}
void OAIH264Settings::setColorMetadata(const OAIH264ColorMetadata &color_metadata) {
    m_color_metadata = color_metadata;
    m_color_metadata_isSet = true;
}

bool OAIH264Settings::is_color_metadata_Set() const{
    return m_color_metadata_isSet;
}

bool OAIH264Settings::is_color_metadata_Valid() const{
    return m_color_metadata_isValid;
}

OAIH264Settings_ColorSpaceSettings OAIH264Settings::getColorSpaceSettings() const {
    return m_color_space_settings;
}
void OAIH264Settings::setColorSpaceSettings(const OAIH264Settings_ColorSpaceSettings &color_space_settings) {
    m_color_space_settings = color_space_settings;
    m_color_space_settings_isSet = true;
}

bool OAIH264Settings::is_color_space_settings_Set() const{
    return m_color_space_settings_isSet;
}

bool OAIH264Settings::is_color_space_settings_Valid() const{
    return m_color_space_settings_isValid;
}

OAIH264EntropyEncoding OAIH264Settings::getEntropyEncoding() const {
    return m_entropy_encoding;
}
void OAIH264Settings::setEntropyEncoding(const OAIH264EntropyEncoding &entropy_encoding) {
    m_entropy_encoding = entropy_encoding;
    m_entropy_encoding_isSet = true;
}

bool OAIH264Settings::is_entropy_encoding_Set() const{
    return m_entropy_encoding_isSet;
}

bool OAIH264Settings::is_entropy_encoding_Valid() const{
    return m_entropy_encoding_isValid;
}

OAIH264Settings_FilterSettings OAIH264Settings::getFilterSettings() const {
    return m_filter_settings;
}
void OAIH264Settings::setFilterSettings(const OAIH264Settings_FilterSettings &filter_settings) {
    m_filter_settings = filter_settings;
    m_filter_settings_isSet = true;
}

bool OAIH264Settings::is_filter_settings_Set() const{
    return m_filter_settings_isSet;
}

bool OAIH264Settings::is_filter_settings_Valid() const{
    return m_filter_settings_isValid;
}

OAIFixedAfd OAIH264Settings::getFixedAfd() const {
    return m_fixed_afd;
}
void OAIH264Settings::setFixedAfd(const OAIFixedAfd &fixed_afd) {
    m_fixed_afd = fixed_afd;
    m_fixed_afd_isSet = true;
}

bool OAIH264Settings::is_fixed_afd_Set() const{
    return m_fixed_afd_isSet;
}

bool OAIH264Settings::is_fixed_afd_Valid() const{
    return m_fixed_afd_isValid;
}

OAIH264FlickerAq OAIH264Settings::getFlickerAq() const {
    return m_flicker_aq;
}
void OAIH264Settings::setFlickerAq(const OAIH264FlickerAq &flicker_aq) {
    m_flicker_aq = flicker_aq;
    m_flicker_aq_isSet = true;
}

bool OAIH264Settings::is_flicker_aq_Set() const{
    return m_flicker_aq_isSet;
}

bool OAIH264Settings::is_flicker_aq_Valid() const{
    return m_flicker_aq_isValid;
}

OAIH264ForceFieldPictures OAIH264Settings::getForceFieldPictures() const {
    return m_force_field_pictures;
}
void OAIH264Settings::setForceFieldPictures(const OAIH264ForceFieldPictures &force_field_pictures) {
    m_force_field_pictures = force_field_pictures;
    m_force_field_pictures_isSet = true;
}

bool OAIH264Settings::is_force_field_pictures_Set() const{
    return m_force_field_pictures_isSet;
}

bool OAIH264Settings::is_force_field_pictures_Valid() const{
    return m_force_field_pictures_isValid;
}

OAIH264FramerateControl OAIH264Settings::getFramerateControl() const {
    return m_framerate_control;
}
void OAIH264Settings::setFramerateControl(const OAIH264FramerateControl &framerate_control) {
    m_framerate_control = framerate_control;
    m_framerate_control_isSet = true;
}

bool OAIH264Settings::is_framerate_control_Set() const{
    return m_framerate_control_isSet;
}

bool OAIH264Settings::is_framerate_control_Valid() const{
    return m_framerate_control_isValid;
}

qint32 OAIH264Settings::getFramerateDenominator() const {
    return m_framerate_denominator;
}
void OAIH264Settings::setFramerateDenominator(const qint32 &framerate_denominator) {
    m_framerate_denominator = framerate_denominator;
    m_framerate_denominator_isSet = true;
}

bool OAIH264Settings::is_framerate_denominator_Set() const{
    return m_framerate_denominator_isSet;
}

bool OAIH264Settings::is_framerate_denominator_Valid() const{
    return m_framerate_denominator_isValid;
}

qint32 OAIH264Settings::getFramerateNumerator() const {
    return m_framerate_numerator;
}
void OAIH264Settings::setFramerateNumerator(const qint32 &framerate_numerator) {
    m_framerate_numerator = framerate_numerator;
    m_framerate_numerator_isSet = true;
}

bool OAIH264Settings::is_framerate_numerator_Set() const{
    return m_framerate_numerator_isSet;
}

bool OAIH264Settings::is_framerate_numerator_Valid() const{
    return m_framerate_numerator_isValid;
}

OAIH264GopBReference OAIH264Settings::getGopBReference() const {
    return m_gop_b_reference;
}
void OAIH264Settings::setGopBReference(const OAIH264GopBReference &gop_b_reference) {
    m_gop_b_reference = gop_b_reference;
    m_gop_b_reference_isSet = true;
}

bool OAIH264Settings::is_gop_b_reference_Set() const{
    return m_gop_b_reference_isSet;
}

bool OAIH264Settings::is_gop_b_reference_Valid() const{
    return m_gop_b_reference_isValid;
}

qint32 OAIH264Settings::getGopClosedCadence() const {
    return m_gop_closed_cadence;
}
void OAIH264Settings::setGopClosedCadence(const qint32 &gop_closed_cadence) {
    m_gop_closed_cadence = gop_closed_cadence;
    m_gop_closed_cadence_isSet = true;
}

bool OAIH264Settings::is_gop_closed_cadence_Set() const{
    return m_gop_closed_cadence_isSet;
}

bool OAIH264Settings::is_gop_closed_cadence_Valid() const{
    return m_gop_closed_cadence_isValid;
}

qint32 OAIH264Settings::getGopNumBFrames() const {
    return m_gop_num_b_frames;
}
void OAIH264Settings::setGopNumBFrames(const qint32 &gop_num_b_frames) {
    m_gop_num_b_frames = gop_num_b_frames;
    m_gop_num_b_frames_isSet = true;
}

bool OAIH264Settings::is_gop_num_b_frames_Set() const{
    return m_gop_num_b_frames_isSet;
}

bool OAIH264Settings::is_gop_num_b_frames_Valid() const{
    return m_gop_num_b_frames_isValid;
}

double OAIH264Settings::getGopSize() const {
    return m_gop_size;
}
void OAIH264Settings::setGopSize(const double &gop_size) {
    m_gop_size = gop_size;
    m_gop_size_isSet = true;
}

bool OAIH264Settings::is_gop_size_Set() const{
    return m_gop_size_isSet;
}

bool OAIH264Settings::is_gop_size_Valid() const{
    return m_gop_size_isValid;
}

OAIH264GopSizeUnits OAIH264Settings::getGopSizeUnits() const {
    return m_gop_size_units;
}
void OAIH264Settings::setGopSizeUnits(const OAIH264GopSizeUnits &gop_size_units) {
    m_gop_size_units = gop_size_units;
    m_gop_size_units_isSet = true;
}

bool OAIH264Settings::is_gop_size_units_Set() const{
    return m_gop_size_units_isSet;
}

bool OAIH264Settings::is_gop_size_units_Valid() const{
    return m_gop_size_units_isValid;
}

OAIH264Level OAIH264Settings::getLevel() const {
    return m_level;
}
void OAIH264Settings::setLevel(const OAIH264Level &level) {
    m_level = level;
    m_level_isSet = true;
}

bool OAIH264Settings::is_level_Set() const{
    return m_level_isSet;
}

bool OAIH264Settings::is_level_Valid() const{
    return m_level_isValid;
}

OAIH264LookAheadRateControl OAIH264Settings::getLookAheadRateControl() const {
    return m_look_ahead_rate_control;
}
void OAIH264Settings::setLookAheadRateControl(const OAIH264LookAheadRateControl &look_ahead_rate_control) {
    m_look_ahead_rate_control = look_ahead_rate_control;
    m_look_ahead_rate_control_isSet = true;
}

bool OAIH264Settings::is_look_ahead_rate_control_Set() const{
    return m_look_ahead_rate_control_isSet;
}

bool OAIH264Settings::is_look_ahead_rate_control_Valid() const{
    return m_look_ahead_rate_control_isValid;
}

qint32 OAIH264Settings::getMaxBitrate() const {
    return m_max_bitrate;
}
void OAIH264Settings::setMaxBitrate(const qint32 &max_bitrate) {
    m_max_bitrate = max_bitrate;
    m_max_bitrate_isSet = true;
}

bool OAIH264Settings::is_max_bitrate_Set() const{
    return m_max_bitrate_isSet;
}

bool OAIH264Settings::is_max_bitrate_Valid() const{
    return m_max_bitrate_isValid;
}

qint32 OAIH264Settings::getMinIInterval() const {
    return m_min_i_interval;
}
void OAIH264Settings::setMinIInterval(const qint32 &min_i_interval) {
    m_min_i_interval = min_i_interval;
    m_min_i_interval_isSet = true;
}

bool OAIH264Settings::is_min_i_interval_Set() const{
    return m_min_i_interval_isSet;
}

bool OAIH264Settings::is_min_i_interval_Valid() const{
    return m_min_i_interval_isValid;
}

qint32 OAIH264Settings::getNumRefFrames() const {
    return m_num_ref_frames;
}
void OAIH264Settings::setNumRefFrames(const qint32 &num_ref_frames) {
    m_num_ref_frames = num_ref_frames;
    m_num_ref_frames_isSet = true;
}

bool OAIH264Settings::is_num_ref_frames_Set() const{
    return m_num_ref_frames_isSet;
}

bool OAIH264Settings::is_num_ref_frames_Valid() const{
    return m_num_ref_frames_isValid;
}

OAIH264ParControl OAIH264Settings::getParControl() const {
    return m_par_control;
}
void OAIH264Settings::setParControl(const OAIH264ParControl &par_control) {
    m_par_control = par_control;
    m_par_control_isSet = true;
}

bool OAIH264Settings::is_par_control_Set() const{
    return m_par_control_isSet;
}

bool OAIH264Settings::is_par_control_Valid() const{
    return m_par_control_isValid;
}

qint32 OAIH264Settings::getParDenominator() const {
    return m_par_denominator;
}
void OAIH264Settings::setParDenominator(const qint32 &par_denominator) {
    m_par_denominator = par_denominator;
    m_par_denominator_isSet = true;
}

bool OAIH264Settings::is_par_denominator_Set() const{
    return m_par_denominator_isSet;
}

bool OAIH264Settings::is_par_denominator_Valid() const{
    return m_par_denominator_isValid;
}

qint32 OAIH264Settings::getParNumerator() const {
    return m_par_numerator;
}
void OAIH264Settings::setParNumerator(const qint32 &par_numerator) {
    m_par_numerator = par_numerator;
    m_par_numerator_isSet = true;
}

bool OAIH264Settings::is_par_numerator_Set() const{
    return m_par_numerator_isSet;
}

bool OAIH264Settings::is_par_numerator_Valid() const{
    return m_par_numerator_isValid;
}

OAIH264Profile OAIH264Settings::getProfile() const {
    return m_profile;
}
void OAIH264Settings::setProfile(const OAIH264Profile &profile) {
    m_profile = profile;
    m_profile_isSet = true;
}

bool OAIH264Settings::is_profile_Set() const{
    return m_profile_isSet;
}

bool OAIH264Settings::is_profile_Valid() const{
    return m_profile_isValid;
}

OAIH264QualityLevel OAIH264Settings::getQualityLevel() const {
    return m_quality_level;
}
void OAIH264Settings::setQualityLevel(const OAIH264QualityLevel &quality_level) {
    m_quality_level = quality_level;
    m_quality_level_isSet = true;
}

bool OAIH264Settings::is_quality_level_Set() const{
    return m_quality_level_isSet;
}

bool OAIH264Settings::is_quality_level_Valid() const{
    return m_quality_level_isValid;
}

qint32 OAIH264Settings::getQvbrQualityLevel() const {
    return m_qvbr_quality_level;
}
void OAIH264Settings::setQvbrQualityLevel(const qint32 &qvbr_quality_level) {
    m_qvbr_quality_level = qvbr_quality_level;
    m_qvbr_quality_level_isSet = true;
}

bool OAIH264Settings::is_qvbr_quality_level_Set() const{
    return m_qvbr_quality_level_isSet;
}

bool OAIH264Settings::is_qvbr_quality_level_Valid() const{
    return m_qvbr_quality_level_isValid;
}

OAIH264RateControlMode OAIH264Settings::getRateControlMode() const {
    return m_rate_control_mode;
}
void OAIH264Settings::setRateControlMode(const OAIH264RateControlMode &rate_control_mode) {
    m_rate_control_mode = rate_control_mode;
    m_rate_control_mode_isSet = true;
}

bool OAIH264Settings::is_rate_control_mode_Set() const{
    return m_rate_control_mode_isSet;
}

bool OAIH264Settings::is_rate_control_mode_Valid() const{
    return m_rate_control_mode_isValid;
}

OAIH264ScanType OAIH264Settings::getScanType() const {
    return m_scan_type;
}
void OAIH264Settings::setScanType(const OAIH264ScanType &scan_type) {
    m_scan_type = scan_type;
    m_scan_type_isSet = true;
}

bool OAIH264Settings::is_scan_type_Set() const{
    return m_scan_type_isSet;
}

bool OAIH264Settings::is_scan_type_Valid() const{
    return m_scan_type_isValid;
}

OAIH264SceneChangeDetect OAIH264Settings::getSceneChangeDetect() const {
    return m_scene_change_detect;
}
void OAIH264Settings::setSceneChangeDetect(const OAIH264SceneChangeDetect &scene_change_detect) {
    m_scene_change_detect = scene_change_detect;
    m_scene_change_detect_isSet = true;
}

bool OAIH264Settings::is_scene_change_detect_Set() const{
    return m_scene_change_detect_isSet;
}

bool OAIH264Settings::is_scene_change_detect_Valid() const{
    return m_scene_change_detect_isValid;
}

qint32 OAIH264Settings::getSlices() const {
    return m_slices;
}
void OAIH264Settings::setSlices(const qint32 &slices) {
    m_slices = slices;
    m_slices_isSet = true;
}

bool OAIH264Settings::is_slices_Set() const{
    return m_slices_isSet;
}

bool OAIH264Settings::is_slices_Valid() const{
    return m_slices_isValid;
}

qint32 OAIH264Settings::getSoftness() const {
    return m_softness;
}
void OAIH264Settings::setSoftness(const qint32 &softness) {
    m_softness = softness;
    m_softness_isSet = true;
}

bool OAIH264Settings::is_softness_Set() const{
    return m_softness_isSet;
}

bool OAIH264Settings::is_softness_Valid() const{
    return m_softness_isValid;
}

OAIH264SpatialAq OAIH264Settings::getSpatialAq() const {
    return m_spatial_aq;
}
void OAIH264Settings::setSpatialAq(const OAIH264SpatialAq &spatial_aq) {
    m_spatial_aq = spatial_aq;
    m_spatial_aq_isSet = true;
}

bool OAIH264Settings::is_spatial_aq_Set() const{
    return m_spatial_aq_isSet;
}

bool OAIH264Settings::is_spatial_aq_Valid() const{
    return m_spatial_aq_isValid;
}

OAIH264SubGopLength OAIH264Settings::getSubgopLength() const {
    return m_subgop_length;
}
void OAIH264Settings::setSubgopLength(const OAIH264SubGopLength &subgop_length) {
    m_subgop_length = subgop_length;
    m_subgop_length_isSet = true;
}

bool OAIH264Settings::is_subgop_length_Set() const{
    return m_subgop_length_isSet;
}

bool OAIH264Settings::is_subgop_length_Valid() const{
    return m_subgop_length_isValid;
}

OAIH264Syntax OAIH264Settings::getSyntax() const {
    return m_syntax;
}
void OAIH264Settings::setSyntax(const OAIH264Syntax &syntax) {
    m_syntax = syntax;
    m_syntax_isSet = true;
}

bool OAIH264Settings::is_syntax_Set() const{
    return m_syntax_isSet;
}

bool OAIH264Settings::is_syntax_Valid() const{
    return m_syntax_isValid;
}

OAIH264TemporalAq OAIH264Settings::getTemporalAq() const {
    return m_temporal_aq;
}
void OAIH264Settings::setTemporalAq(const OAIH264TemporalAq &temporal_aq) {
    m_temporal_aq = temporal_aq;
    m_temporal_aq_isSet = true;
}

bool OAIH264Settings::is_temporal_aq_Set() const{
    return m_temporal_aq_isSet;
}

bool OAIH264Settings::is_temporal_aq_Valid() const{
    return m_temporal_aq_isValid;
}

OAIH264TimecodeInsertionBehavior OAIH264Settings::getTimecodeInsertion() const {
    return m_timecode_insertion;
}
void OAIH264Settings::setTimecodeInsertion(const OAIH264TimecodeInsertionBehavior &timecode_insertion) {
    m_timecode_insertion = timecode_insertion;
    m_timecode_insertion_isSet = true;
}

bool OAIH264Settings::is_timecode_insertion_Set() const{
    return m_timecode_insertion_isSet;
}

bool OAIH264Settings::is_timecode_insertion_Valid() const{
    return m_timecode_insertion_isValid;
}

OAIFrameCaptureSettings_TimecodeBurninSettings OAIH264Settings::getTimecodeBurninSettings() const {
    return m_timecode_burnin_settings;
}
void OAIH264Settings::setTimecodeBurninSettings(const OAIFrameCaptureSettings_TimecodeBurninSettings &timecode_burnin_settings) {
    m_timecode_burnin_settings = timecode_burnin_settings;
    m_timecode_burnin_settings_isSet = true;
}

bool OAIH264Settings::is_timecode_burnin_settings_Set() const{
    return m_timecode_burnin_settings_isSet;
}

bool OAIH264Settings::is_timecode_burnin_settings_Valid() const{
    return m_timecode_burnin_settings_isValid;
}

bool OAIH264Settings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_afd_signaling.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_buf_fill_pct_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_buf_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_entropy_encoding.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_filter_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_fixed_afd.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_flicker_aq.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_force_field_pictures.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_b_reference.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_closed_cadence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_num_b_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_units.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_look_ahead_rate_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_i_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_ref_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_profile.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_quality_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_qvbr_quality_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rate_control_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scan_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scene_change_detect.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_slices_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_softness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_spatial_aq.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subgop_length.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_syntax.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_temporal_aq.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timecode_insertion.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timecode_burnin_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIH264Settings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
