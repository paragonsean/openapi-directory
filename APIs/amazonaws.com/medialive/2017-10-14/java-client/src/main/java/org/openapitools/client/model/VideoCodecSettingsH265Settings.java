/*
 * AWS Elemental MediaLive
 * API for AWS Elemental MediaLive
 *
 * The version of the OpenAPI document: 2017-10-14
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AfdSignaling;
import org.openapitools.client.model.FixedAfd;
import org.openapitools.client.model.FrameCaptureSettingsTimecodeBurninSettings;
import org.openapitools.client.model.H265AdaptiveQuantization;
import org.openapitools.client.model.H265AlternativeTransferFunction;
import org.openapitools.client.model.H265ColorMetadata;
import org.openapitools.client.model.H265FlickerAq;
import org.openapitools.client.model.H265GopSizeUnits;
import org.openapitools.client.model.H265Level;
import org.openapitools.client.model.H265LookAheadRateControl;
import org.openapitools.client.model.H265Profile;
import org.openapitools.client.model.H265RateControlMode;
import org.openapitools.client.model.H265ScanType;
import org.openapitools.client.model.H265SceneChangeDetect;
import org.openapitools.client.model.H265SettingsColorSpaceSettings;
import org.openapitools.client.model.H265SettingsFilterSettings;
import org.openapitools.client.model.H265Tier;
import org.openapitools.client.model.H265TimecodeInsertionBehavior;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * VideoCodecSettingsH265Settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:26:18.892689-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoCodecSettingsH265Settings {
  public static final String SERIALIZED_NAME_ADAPTIVE_QUANTIZATION = "AdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_ADAPTIVE_QUANTIZATION)
  private H265AdaptiveQuantization adaptiveQuantization;

  public static final String SERIALIZED_NAME_AFD_SIGNALING = "AfdSignaling";
  @SerializedName(SERIALIZED_NAME_AFD_SIGNALING)
  private AfdSignaling afdSignaling;

  public static final String SERIALIZED_NAME_ALTERNATIVE_TRANSFER_FUNCTION = "AlternativeTransferFunction";
  @SerializedName(SERIALIZED_NAME_ALTERNATIVE_TRANSFER_FUNCTION)
  private H265AlternativeTransferFunction alternativeTransferFunction;

  public static final String SERIALIZED_NAME_BITRATE = "Bitrate";
  @SerializedName(SERIALIZED_NAME_BITRATE)
  private Integer bitrate;

  public static final String SERIALIZED_NAME_BUF_SIZE = "BufSize";
  @SerializedName(SERIALIZED_NAME_BUF_SIZE)
  private Integer bufSize;

  public static final String SERIALIZED_NAME_COLOR_METADATA = "ColorMetadata";
  @SerializedName(SERIALIZED_NAME_COLOR_METADATA)
  private H265ColorMetadata colorMetadata;

  public static final String SERIALIZED_NAME_COLOR_SPACE_SETTINGS = "ColorSpaceSettings";
  @SerializedName(SERIALIZED_NAME_COLOR_SPACE_SETTINGS)
  private H265SettingsColorSpaceSettings colorSpaceSettings;

  public static final String SERIALIZED_NAME_FILTER_SETTINGS = "FilterSettings";
  @SerializedName(SERIALIZED_NAME_FILTER_SETTINGS)
  private H265SettingsFilterSettings filterSettings;

  public static final String SERIALIZED_NAME_FIXED_AFD = "FixedAfd";
  @SerializedName(SERIALIZED_NAME_FIXED_AFD)
  private FixedAfd fixedAfd;

  public static final String SERIALIZED_NAME_FLICKER_AQ = "FlickerAq";
  @SerializedName(SERIALIZED_NAME_FLICKER_AQ)
  private H265FlickerAq flickerAq;

  public static final String SERIALIZED_NAME_FRAMERATE_DENOMINATOR = "FramerateDenominator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_DENOMINATOR)
  private Integer framerateDenominator;

  public static final String SERIALIZED_NAME_FRAMERATE_NUMERATOR = "FramerateNumerator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_NUMERATOR)
  private Integer framerateNumerator;

  public static final String SERIALIZED_NAME_GOP_CLOSED_CADENCE = "GopClosedCadence";
  @SerializedName(SERIALIZED_NAME_GOP_CLOSED_CADENCE)
  private Integer gopClosedCadence;

  public static final String SERIALIZED_NAME_GOP_SIZE = "GopSize";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE)
  private Double gopSize;

  public static final String SERIALIZED_NAME_GOP_SIZE_UNITS = "GopSizeUnits";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE_UNITS)
  private H265GopSizeUnits gopSizeUnits;

  public static final String SERIALIZED_NAME_LEVEL = "Level";
  @SerializedName(SERIALIZED_NAME_LEVEL)
  private H265Level level;

  public static final String SERIALIZED_NAME_LOOK_AHEAD_RATE_CONTROL = "LookAheadRateControl";
  @SerializedName(SERIALIZED_NAME_LOOK_AHEAD_RATE_CONTROL)
  private H265LookAheadRateControl lookAheadRateControl;

  public static final String SERIALIZED_NAME_MAX_BITRATE = "MaxBitrate";
  @SerializedName(SERIALIZED_NAME_MAX_BITRATE)
  private Integer maxBitrate;

  public static final String SERIALIZED_NAME_MIN_I_INTERVAL = "MinIInterval";
  @SerializedName(SERIALIZED_NAME_MIN_I_INTERVAL)
  private Integer minIInterval;

  public static final String SERIALIZED_NAME_PAR_DENOMINATOR = "ParDenominator";
  @SerializedName(SERIALIZED_NAME_PAR_DENOMINATOR)
  private Integer parDenominator;

  public static final String SERIALIZED_NAME_PAR_NUMERATOR = "ParNumerator";
  @SerializedName(SERIALIZED_NAME_PAR_NUMERATOR)
  private Integer parNumerator;

  public static final String SERIALIZED_NAME_PROFILE = "Profile";
  @SerializedName(SERIALIZED_NAME_PROFILE)
  private H265Profile profile;

  public static final String SERIALIZED_NAME_QVBR_QUALITY_LEVEL = "QvbrQualityLevel";
  @SerializedName(SERIALIZED_NAME_QVBR_QUALITY_LEVEL)
  private Integer qvbrQualityLevel;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "RateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private H265RateControlMode rateControlMode;

  public static final String SERIALIZED_NAME_SCAN_TYPE = "ScanType";
  @SerializedName(SERIALIZED_NAME_SCAN_TYPE)
  private H265ScanType scanType;

  public static final String SERIALIZED_NAME_SCENE_CHANGE_DETECT = "SceneChangeDetect";
  @SerializedName(SERIALIZED_NAME_SCENE_CHANGE_DETECT)
  private H265SceneChangeDetect sceneChangeDetect;

  public static final String SERIALIZED_NAME_SLICES = "Slices";
  @SerializedName(SERIALIZED_NAME_SLICES)
  private Integer slices;

  public static final String SERIALIZED_NAME_TIER = "Tier";
  @SerializedName(SERIALIZED_NAME_TIER)
  private H265Tier tier;

  public static final String SERIALIZED_NAME_TIMECODE_INSERTION = "TimecodeInsertion";
  @SerializedName(SERIALIZED_NAME_TIMECODE_INSERTION)
  private H265TimecodeInsertionBehavior timecodeInsertion;

  public static final String SERIALIZED_NAME_TIMECODE_BURNIN_SETTINGS = "TimecodeBurninSettings";
  @SerializedName(SERIALIZED_NAME_TIMECODE_BURNIN_SETTINGS)
  private FrameCaptureSettingsTimecodeBurninSettings timecodeBurninSettings;

  public VideoCodecSettingsH265Settings() {
  }

  public VideoCodecSettingsH265Settings adaptiveQuantization(H265AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
    return this;
  }

  /**
   * Get adaptiveQuantization
   * @return adaptiveQuantization
   */
  @javax.annotation.Nullable
  public H265AdaptiveQuantization getAdaptiveQuantization() {
    return adaptiveQuantization;
  }

  public void setAdaptiveQuantization(H265AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
  }


  public VideoCodecSettingsH265Settings afdSignaling(AfdSignaling afdSignaling) {
    this.afdSignaling = afdSignaling;
    return this;
  }

  /**
   * Get afdSignaling
   * @return afdSignaling
   */
  @javax.annotation.Nullable
  public AfdSignaling getAfdSignaling() {
    return afdSignaling;
  }

  public void setAfdSignaling(AfdSignaling afdSignaling) {
    this.afdSignaling = afdSignaling;
  }


  public VideoCodecSettingsH265Settings alternativeTransferFunction(H265AlternativeTransferFunction alternativeTransferFunction) {
    this.alternativeTransferFunction = alternativeTransferFunction;
    return this;
  }

  /**
   * Get alternativeTransferFunction
   * @return alternativeTransferFunction
   */
  @javax.annotation.Nullable
  public H265AlternativeTransferFunction getAlternativeTransferFunction() {
    return alternativeTransferFunction;
  }

  public void setAlternativeTransferFunction(H265AlternativeTransferFunction alternativeTransferFunction) {
    this.alternativeTransferFunction = alternativeTransferFunction;
  }


  public VideoCodecSettingsH265Settings bitrate(Integer bitrate) {
    this.bitrate = bitrate;
    return this;
  }

  /**
   * Get bitrate
   * @return bitrate
   */
  @javax.annotation.Nullable
  public Integer getBitrate() {
    return bitrate;
  }

  public void setBitrate(Integer bitrate) {
    this.bitrate = bitrate;
  }


  public VideoCodecSettingsH265Settings bufSize(Integer bufSize) {
    this.bufSize = bufSize;
    return this;
  }

  /**
   * Get bufSize
   * @return bufSize
   */
  @javax.annotation.Nullable
  public Integer getBufSize() {
    return bufSize;
  }

  public void setBufSize(Integer bufSize) {
    this.bufSize = bufSize;
  }


  public VideoCodecSettingsH265Settings colorMetadata(H265ColorMetadata colorMetadata) {
    this.colorMetadata = colorMetadata;
    return this;
  }

  /**
   * Get colorMetadata
   * @return colorMetadata
   */
  @javax.annotation.Nullable
  public H265ColorMetadata getColorMetadata() {
    return colorMetadata;
  }

  public void setColorMetadata(H265ColorMetadata colorMetadata) {
    this.colorMetadata = colorMetadata;
  }


  public VideoCodecSettingsH265Settings colorSpaceSettings(H265SettingsColorSpaceSettings colorSpaceSettings) {
    this.colorSpaceSettings = colorSpaceSettings;
    return this;
  }

  /**
   * Get colorSpaceSettings
   * @return colorSpaceSettings
   */
  @javax.annotation.Nullable
  public H265SettingsColorSpaceSettings getColorSpaceSettings() {
    return colorSpaceSettings;
  }

  public void setColorSpaceSettings(H265SettingsColorSpaceSettings colorSpaceSettings) {
    this.colorSpaceSettings = colorSpaceSettings;
  }


  public VideoCodecSettingsH265Settings filterSettings(H265SettingsFilterSettings filterSettings) {
    this.filterSettings = filterSettings;
    return this;
  }

  /**
   * Get filterSettings
   * @return filterSettings
   */
  @javax.annotation.Nullable
  public H265SettingsFilterSettings getFilterSettings() {
    return filterSettings;
  }

  public void setFilterSettings(H265SettingsFilterSettings filterSettings) {
    this.filterSettings = filterSettings;
  }


  public VideoCodecSettingsH265Settings fixedAfd(FixedAfd fixedAfd) {
    this.fixedAfd = fixedAfd;
    return this;
  }

  /**
   * Get fixedAfd
   * @return fixedAfd
   */
  @javax.annotation.Nullable
  public FixedAfd getFixedAfd() {
    return fixedAfd;
  }

  public void setFixedAfd(FixedAfd fixedAfd) {
    this.fixedAfd = fixedAfd;
  }


  public VideoCodecSettingsH265Settings flickerAq(H265FlickerAq flickerAq) {
    this.flickerAq = flickerAq;
    return this;
  }

  /**
   * Get flickerAq
   * @return flickerAq
   */
  @javax.annotation.Nullable
  public H265FlickerAq getFlickerAq() {
    return flickerAq;
  }

  public void setFlickerAq(H265FlickerAq flickerAq) {
    this.flickerAq = flickerAq;
  }


  public VideoCodecSettingsH265Settings framerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
    return this;
  }

  /**
   * Get framerateDenominator
   * @return framerateDenominator
   */
  @javax.annotation.Nonnull
  public Integer getFramerateDenominator() {
    return framerateDenominator;
  }

  public void setFramerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
  }


  public VideoCodecSettingsH265Settings framerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
    return this;
  }

  /**
   * Get framerateNumerator
   * @return framerateNumerator
   */
  @javax.annotation.Nonnull
  public Integer getFramerateNumerator() {
    return framerateNumerator;
  }

  public void setFramerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
  }


  public VideoCodecSettingsH265Settings gopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
    return this;
  }

  /**
   * Get gopClosedCadence
   * @return gopClosedCadence
   */
  @javax.annotation.Nullable
  public Integer getGopClosedCadence() {
    return gopClosedCadence;
  }

  public void setGopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
  }


  public VideoCodecSettingsH265Settings gopSize(Double gopSize) {
    this.gopSize = gopSize;
    return this;
  }

  /**
   * Get gopSize
   * @return gopSize
   */
  @javax.annotation.Nullable
  public Double getGopSize() {
    return gopSize;
  }

  public void setGopSize(Double gopSize) {
    this.gopSize = gopSize;
  }


  public VideoCodecSettingsH265Settings gopSizeUnits(H265GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
    return this;
  }

  /**
   * Get gopSizeUnits
   * @return gopSizeUnits
   */
  @javax.annotation.Nullable
  public H265GopSizeUnits getGopSizeUnits() {
    return gopSizeUnits;
  }

  public void setGopSizeUnits(H265GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
  }


  public VideoCodecSettingsH265Settings level(H265Level level) {
    this.level = level;
    return this;
  }

  /**
   * Get level
   * @return level
   */
  @javax.annotation.Nullable
  public H265Level getLevel() {
    return level;
  }

  public void setLevel(H265Level level) {
    this.level = level;
  }


  public VideoCodecSettingsH265Settings lookAheadRateControl(H265LookAheadRateControl lookAheadRateControl) {
    this.lookAheadRateControl = lookAheadRateControl;
    return this;
  }

  /**
   * Get lookAheadRateControl
   * @return lookAheadRateControl
   */
  @javax.annotation.Nullable
  public H265LookAheadRateControl getLookAheadRateControl() {
    return lookAheadRateControl;
  }

  public void setLookAheadRateControl(H265LookAheadRateControl lookAheadRateControl) {
    this.lookAheadRateControl = lookAheadRateControl;
  }


  public VideoCodecSettingsH265Settings maxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
    return this;
  }

  /**
   * Get maxBitrate
   * @return maxBitrate
   */
  @javax.annotation.Nullable
  public Integer getMaxBitrate() {
    return maxBitrate;
  }

  public void setMaxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
  }


  public VideoCodecSettingsH265Settings minIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
    return this;
  }

  /**
   * Get minIInterval
   * @return minIInterval
   */
  @javax.annotation.Nullable
  public Integer getMinIInterval() {
    return minIInterval;
  }

  public void setMinIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
  }


  public VideoCodecSettingsH265Settings parDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
    return this;
  }

  /**
   * Get parDenominator
   * @return parDenominator
   */
  @javax.annotation.Nullable
  public Integer getParDenominator() {
    return parDenominator;
  }

  public void setParDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
  }


  public VideoCodecSettingsH265Settings parNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
    return this;
  }

  /**
   * Get parNumerator
   * @return parNumerator
   */
  @javax.annotation.Nullable
  public Integer getParNumerator() {
    return parNumerator;
  }

  public void setParNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
  }


  public VideoCodecSettingsH265Settings profile(H265Profile profile) {
    this.profile = profile;
    return this;
  }

  /**
   * Get profile
   * @return profile
   */
  @javax.annotation.Nullable
  public H265Profile getProfile() {
    return profile;
  }

  public void setProfile(H265Profile profile) {
    this.profile = profile;
  }


  public VideoCodecSettingsH265Settings qvbrQualityLevel(Integer qvbrQualityLevel) {
    this.qvbrQualityLevel = qvbrQualityLevel;
    return this;
  }

  /**
   * Get qvbrQualityLevel
   * @return qvbrQualityLevel
   */
  @javax.annotation.Nullable
  public Integer getQvbrQualityLevel() {
    return qvbrQualityLevel;
  }

  public void setQvbrQualityLevel(Integer qvbrQualityLevel) {
    this.qvbrQualityLevel = qvbrQualityLevel;
  }


  public VideoCodecSettingsH265Settings rateControlMode(H265RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Get rateControlMode
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public H265RateControlMode getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(H265RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public VideoCodecSettingsH265Settings scanType(H265ScanType scanType) {
    this.scanType = scanType;
    return this;
  }

  /**
   * Get scanType
   * @return scanType
   */
  @javax.annotation.Nullable
  public H265ScanType getScanType() {
    return scanType;
  }

  public void setScanType(H265ScanType scanType) {
    this.scanType = scanType;
  }


  public VideoCodecSettingsH265Settings sceneChangeDetect(H265SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
    return this;
  }

  /**
   * Get sceneChangeDetect
   * @return sceneChangeDetect
   */
  @javax.annotation.Nullable
  public H265SceneChangeDetect getSceneChangeDetect() {
    return sceneChangeDetect;
  }

  public void setSceneChangeDetect(H265SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
  }


  public VideoCodecSettingsH265Settings slices(Integer slices) {
    this.slices = slices;
    return this;
  }

  /**
   * Get slices
   * @return slices
   */
  @javax.annotation.Nullable
  public Integer getSlices() {
    return slices;
  }

  public void setSlices(Integer slices) {
    this.slices = slices;
  }


  public VideoCodecSettingsH265Settings tier(H265Tier tier) {
    this.tier = tier;
    return this;
  }

  /**
   * Get tier
   * @return tier
   */
  @javax.annotation.Nullable
  public H265Tier getTier() {
    return tier;
  }

  public void setTier(H265Tier tier) {
    this.tier = tier;
  }


  public VideoCodecSettingsH265Settings timecodeInsertion(H265TimecodeInsertionBehavior timecodeInsertion) {
    this.timecodeInsertion = timecodeInsertion;
    return this;
  }

  /**
   * Get timecodeInsertion
   * @return timecodeInsertion
   */
  @javax.annotation.Nullable
  public H265TimecodeInsertionBehavior getTimecodeInsertion() {
    return timecodeInsertion;
  }

  public void setTimecodeInsertion(H265TimecodeInsertionBehavior timecodeInsertion) {
    this.timecodeInsertion = timecodeInsertion;
  }


  public VideoCodecSettingsH265Settings timecodeBurninSettings(FrameCaptureSettingsTimecodeBurninSettings timecodeBurninSettings) {
    this.timecodeBurninSettings = timecodeBurninSettings;
    return this;
  }

  /**
   * Get timecodeBurninSettings
   * @return timecodeBurninSettings
   */
  @javax.annotation.Nullable
  public FrameCaptureSettingsTimecodeBurninSettings getTimecodeBurninSettings() {
    return timecodeBurninSettings;
  }

  public void setTimecodeBurninSettings(FrameCaptureSettingsTimecodeBurninSettings timecodeBurninSettings) {
    this.timecodeBurninSettings = timecodeBurninSettings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoCodecSettingsH265Settings videoCodecSettingsH265Settings = (VideoCodecSettingsH265Settings) o;
    return Objects.equals(this.adaptiveQuantization, videoCodecSettingsH265Settings.adaptiveQuantization) &&
        Objects.equals(this.afdSignaling, videoCodecSettingsH265Settings.afdSignaling) &&
        Objects.equals(this.alternativeTransferFunction, videoCodecSettingsH265Settings.alternativeTransferFunction) &&
        Objects.equals(this.bitrate, videoCodecSettingsH265Settings.bitrate) &&
        Objects.equals(this.bufSize, videoCodecSettingsH265Settings.bufSize) &&
        Objects.equals(this.colorMetadata, videoCodecSettingsH265Settings.colorMetadata) &&
        Objects.equals(this.colorSpaceSettings, videoCodecSettingsH265Settings.colorSpaceSettings) &&
        Objects.equals(this.filterSettings, videoCodecSettingsH265Settings.filterSettings) &&
        Objects.equals(this.fixedAfd, videoCodecSettingsH265Settings.fixedAfd) &&
        Objects.equals(this.flickerAq, videoCodecSettingsH265Settings.flickerAq) &&
        Objects.equals(this.framerateDenominator, videoCodecSettingsH265Settings.framerateDenominator) &&
        Objects.equals(this.framerateNumerator, videoCodecSettingsH265Settings.framerateNumerator) &&
        Objects.equals(this.gopClosedCadence, videoCodecSettingsH265Settings.gopClosedCadence) &&
        Objects.equals(this.gopSize, videoCodecSettingsH265Settings.gopSize) &&
        Objects.equals(this.gopSizeUnits, videoCodecSettingsH265Settings.gopSizeUnits) &&
        Objects.equals(this.level, videoCodecSettingsH265Settings.level) &&
        Objects.equals(this.lookAheadRateControl, videoCodecSettingsH265Settings.lookAheadRateControl) &&
        Objects.equals(this.maxBitrate, videoCodecSettingsH265Settings.maxBitrate) &&
        Objects.equals(this.minIInterval, videoCodecSettingsH265Settings.minIInterval) &&
        Objects.equals(this.parDenominator, videoCodecSettingsH265Settings.parDenominator) &&
        Objects.equals(this.parNumerator, videoCodecSettingsH265Settings.parNumerator) &&
        Objects.equals(this.profile, videoCodecSettingsH265Settings.profile) &&
        Objects.equals(this.qvbrQualityLevel, videoCodecSettingsH265Settings.qvbrQualityLevel) &&
        Objects.equals(this.rateControlMode, videoCodecSettingsH265Settings.rateControlMode) &&
        Objects.equals(this.scanType, videoCodecSettingsH265Settings.scanType) &&
        Objects.equals(this.sceneChangeDetect, videoCodecSettingsH265Settings.sceneChangeDetect) &&
        Objects.equals(this.slices, videoCodecSettingsH265Settings.slices) &&
        Objects.equals(this.tier, videoCodecSettingsH265Settings.tier) &&
        Objects.equals(this.timecodeInsertion, videoCodecSettingsH265Settings.timecodeInsertion) &&
        Objects.equals(this.timecodeBurninSettings, videoCodecSettingsH265Settings.timecodeBurninSettings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adaptiveQuantization, afdSignaling, alternativeTransferFunction, bitrate, bufSize, colorMetadata, colorSpaceSettings, filterSettings, fixedAfd, flickerAq, framerateDenominator, framerateNumerator, gopClosedCadence, gopSize, gopSizeUnits, level, lookAheadRateControl, maxBitrate, minIInterval, parDenominator, parNumerator, profile, qvbrQualityLevel, rateControlMode, scanType, sceneChangeDetect, slices, tier, timecodeInsertion, timecodeBurninSettings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoCodecSettingsH265Settings {\n");
    sb.append("    adaptiveQuantization: ").append(toIndentedString(adaptiveQuantization)).append("\n");
    sb.append("    afdSignaling: ").append(toIndentedString(afdSignaling)).append("\n");
    sb.append("    alternativeTransferFunction: ").append(toIndentedString(alternativeTransferFunction)).append("\n");
    sb.append("    bitrate: ").append(toIndentedString(bitrate)).append("\n");
    sb.append("    bufSize: ").append(toIndentedString(bufSize)).append("\n");
    sb.append("    colorMetadata: ").append(toIndentedString(colorMetadata)).append("\n");
    sb.append("    colorSpaceSettings: ").append(toIndentedString(colorSpaceSettings)).append("\n");
    sb.append("    filterSettings: ").append(toIndentedString(filterSettings)).append("\n");
    sb.append("    fixedAfd: ").append(toIndentedString(fixedAfd)).append("\n");
    sb.append("    flickerAq: ").append(toIndentedString(flickerAq)).append("\n");
    sb.append("    framerateDenominator: ").append(toIndentedString(framerateDenominator)).append("\n");
    sb.append("    framerateNumerator: ").append(toIndentedString(framerateNumerator)).append("\n");
    sb.append("    gopClosedCadence: ").append(toIndentedString(gopClosedCadence)).append("\n");
    sb.append("    gopSize: ").append(toIndentedString(gopSize)).append("\n");
    sb.append("    gopSizeUnits: ").append(toIndentedString(gopSizeUnits)).append("\n");
    sb.append("    level: ").append(toIndentedString(level)).append("\n");
    sb.append("    lookAheadRateControl: ").append(toIndentedString(lookAheadRateControl)).append("\n");
    sb.append("    maxBitrate: ").append(toIndentedString(maxBitrate)).append("\n");
    sb.append("    minIInterval: ").append(toIndentedString(minIInterval)).append("\n");
    sb.append("    parDenominator: ").append(toIndentedString(parDenominator)).append("\n");
    sb.append("    parNumerator: ").append(toIndentedString(parNumerator)).append("\n");
    sb.append("    profile: ").append(toIndentedString(profile)).append("\n");
    sb.append("    qvbrQualityLevel: ").append(toIndentedString(qvbrQualityLevel)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    scanType: ").append(toIndentedString(scanType)).append("\n");
    sb.append("    sceneChangeDetect: ").append(toIndentedString(sceneChangeDetect)).append("\n");
    sb.append("    slices: ").append(toIndentedString(slices)).append("\n");
    sb.append("    tier: ").append(toIndentedString(tier)).append("\n");
    sb.append("    timecodeInsertion: ").append(toIndentedString(timecodeInsertion)).append("\n");
    sb.append("    timecodeBurninSettings: ").append(toIndentedString(timecodeBurninSettings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AdaptiveQuantization");
    openapiFields.add("AfdSignaling");
    openapiFields.add("AlternativeTransferFunction");
    openapiFields.add("Bitrate");
    openapiFields.add("BufSize");
    openapiFields.add("ColorMetadata");
    openapiFields.add("ColorSpaceSettings");
    openapiFields.add("FilterSettings");
    openapiFields.add("FixedAfd");
    openapiFields.add("FlickerAq");
    openapiFields.add("FramerateDenominator");
    openapiFields.add("FramerateNumerator");
    openapiFields.add("GopClosedCadence");
    openapiFields.add("GopSize");
    openapiFields.add("GopSizeUnits");
    openapiFields.add("Level");
    openapiFields.add("LookAheadRateControl");
    openapiFields.add("MaxBitrate");
    openapiFields.add("MinIInterval");
    openapiFields.add("ParDenominator");
    openapiFields.add("ParNumerator");
    openapiFields.add("Profile");
    openapiFields.add("QvbrQualityLevel");
    openapiFields.add("RateControlMode");
    openapiFields.add("ScanType");
    openapiFields.add("SceneChangeDetect");
    openapiFields.add("Slices");
    openapiFields.add("Tier");
    openapiFields.add("TimecodeInsertion");
    openapiFields.add("TimecodeBurninSettings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("FramerateDenominator");
    openapiRequiredFields.add("FramerateNumerator");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoCodecSettingsH265Settings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoCodecSettingsH265Settings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoCodecSettingsH265Settings is not found in the empty JSON string", VideoCodecSettingsH265Settings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoCodecSettingsH265Settings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoCodecSettingsH265Settings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : VideoCodecSettingsH265Settings.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AdaptiveQuantization`
      if (jsonObj.get("AdaptiveQuantization") != null && !jsonObj.get("AdaptiveQuantization").isJsonNull()) {
        H265AdaptiveQuantization.validateJsonElement(jsonObj.get("AdaptiveQuantization"));
      }
      // validate the optional field `AfdSignaling`
      if (jsonObj.get("AfdSignaling") != null && !jsonObj.get("AfdSignaling").isJsonNull()) {
        AfdSignaling.validateJsonElement(jsonObj.get("AfdSignaling"));
      }
      // validate the optional field `AlternativeTransferFunction`
      if (jsonObj.get("AlternativeTransferFunction") != null && !jsonObj.get("AlternativeTransferFunction").isJsonNull()) {
        H265AlternativeTransferFunction.validateJsonElement(jsonObj.get("AlternativeTransferFunction"));
      }
      // validate the optional field `Bitrate`
      if (jsonObj.get("Bitrate") != null && !jsonObj.get("Bitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Bitrate"));
      }
      // validate the optional field `BufSize`
      if (jsonObj.get("BufSize") != null && !jsonObj.get("BufSize").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("BufSize"));
      }
      // validate the optional field `ColorMetadata`
      if (jsonObj.get("ColorMetadata") != null && !jsonObj.get("ColorMetadata").isJsonNull()) {
        H265ColorMetadata.validateJsonElement(jsonObj.get("ColorMetadata"));
      }
      // validate the optional field `ColorSpaceSettings`
      if (jsonObj.get("ColorSpaceSettings") != null && !jsonObj.get("ColorSpaceSettings").isJsonNull()) {
        H265SettingsColorSpaceSettings.validateJsonElement(jsonObj.get("ColorSpaceSettings"));
      }
      // validate the optional field `FilterSettings`
      if (jsonObj.get("FilterSettings") != null && !jsonObj.get("FilterSettings").isJsonNull()) {
        H265SettingsFilterSettings.validateJsonElement(jsonObj.get("FilterSettings"));
      }
      // validate the optional field `FixedAfd`
      if (jsonObj.get("FixedAfd") != null && !jsonObj.get("FixedAfd").isJsonNull()) {
        FixedAfd.validateJsonElement(jsonObj.get("FixedAfd"));
      }
      // validate the optional field `FlickerAq`
      if (jsonObj.get("FlickerAq") != null && !jsonObj.get("FlickerAq").isJsonNull()) {
        H265FlickerAq.validateJsonElement(jsonObj.get("FlickerAq"));
      }
      // validate the required field `FramerateDenominator`
      Integer.validateJsonElement(jsonObj.get("FramerateDenominator"));
      // validate the required field `FramerateNumerator`
      Integer.validateJsonElement(jsonObj.get("FramerateNumerator"));
      // validate the optional field `GopClosedCadence`
      if (jsonObj.get("GopClosedCadence") != null && !jsonObj.get("GopClosedCadence").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("GopClosedCadence"));
      }
      // validate the optional field `GopSize`
      if (jsonObj.get("GopSize") != null && !jsonObj.get("GopSize").isJsonNull()) {
        Double.validateJsonElement(jsonObj.get("GopSize"));
      }
      // validate the optional field `GopSizeUnits`
      if (jsonObj.get("GopSizeUnits") != null && !jsonObj.get("GopSizeUnits").isJsonNull()) {
        H265GopSizeUnits.validateJsonElement(jsonObj.get("GopSizeUnits"));
      }
      // validate the optional field `Level`
      if (jsonObj.get("Level") != null && !jsonObj.get("Level").isJsonNull()) {
        H265Level.validateJsonElement(jsonObj.get("Level"));
      }
      // validate the optional field `LookAheadRateControl`
      if (jsonObj.get("LookAheadRateControl") != null && !jsonObj.get("LookAheadRateControl").isJsonNull()) {
        H265LookAheadRateControl.validateJsonElement(jsonObj.get("LookAheadRateControl"));
      }
      // validate the optional field `MaxBitrate`
      if (jsonObj.get("MaxBitrate") != null && !jsonObj.get("MaxBitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxBitrate"));
      }
      // validate the optional field `MinIInterval`
      if (jsonObj.get("MinIInterval") != null && !jsonObj.get("MinIInterval").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinIInterval"));
      }
      // validate the optional field `ParDenominator`
      if (jsonObj.get("ParDenominator") != null && !jsonObj.get("ParDenominator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParDenominator"));
      }
      // validate the optional field `ParNumerator`
      if (jsonObj.get("ParNumerator") != null && !jsonObj.get("ParNumerator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParNumerator"));
      }
      // validate the optional field `Profile`
      if (jsonObj.get("Profile") != null && !jsonObj.get("Profile").isJsonNull()) {
        H265Profile.validateJsonElement(jsonObj.get("Profile"));
      }
      // validate the optional field `QvbrQualityLevel`
      if (jsonObj.get("QvbrQualityLevel") != null && !jsonObj.get("QvbrQualityLevel").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("QvbrQualityLevel"));
      }
      // validate the optional field `RateControlMode`
      if (jsonObj.get("RateControlMode") != null && !jsonObj.get("RateControlMode").isJsonNull()) {
        H265RateControlMode.validateJsonElement(jsonObj.get("RateControlMode"));
      }
      // validate the optional field `ScanType`
      if (jsonObj.get("ScanType") != null && !jsonObj.get("ScanType").isJsonNull()) {
        H265ScanType.validateJsonElement(jsonObj.get("ScanType"));
      }
      // validate the optional field `SceneChangeDetect`
      if (jsonObj.get("SceneChangeDetect") != null && !jsonObj.get("SceneChangeDetect").isJsonNull()) {
        H265SceneChangeDetect.validateJsonElement(jsonObj.get("SceneChangeDetect"));
      }
      // validate the optional field `Slices`
      if (jsonObj.get("Slices") != null && !jsonObj.get("Slices").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Slices"));
      }
      // validate the optional field `Tier`
      if (jsonObj.get("Tier") != null && !jsonObj.get("Tier").isJsonNull()) {
        H265Tier.validateJsonElement(jsonObj.get("Tier"));
      }
      // validate the optional field `TimecodeInsertion`
      if (jsonObj.get("TimecodeInsertion") != null && !jsonObj.get("TimecodeInsertion").isJsonNull()) {
        H265TimecodeInsertionBehavior.validateJsonElement(jsonObj.get("TimecodeInsertion"));
      }
      // validate the optional field `TimecodeBurninSettings`
      if (jsonObj.get("TimecodeBurninSettings") != null && !jsonObj.get("TimecodeBurninSettings").isJsonNull()) {
        FrameCaptureSettingsTimecodeBurninSettings.validateJsonElement(jsonObj.get("TimecodeBurninSettings"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoCodecSettingsH265Settings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoCodecSettingsH265Settings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoCodecSettingsH265Settings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoCodecSettingsH265Settings.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoCodecSettingsH265Settings>() {
           @Override
           public void write(JsonWriter out, VideoCodecSettingsH265Settings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoCodecSettingsH265Settings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoCodecSettingsH265Settings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoCodecSettingsH265Settings
   * @throws IOException if the JSON string is invalid with respect to VideoCodecSettingsH265Settings
   */
  public static VideoCodecSettingsH265Settings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoCodecSettingsH265Settings.class);
  }

  /**
   * Convert an instance of VideoCodecSettingsH265Settings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

