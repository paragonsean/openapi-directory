/*
 * Amazon Route 53
 * <p>Amazon Route 53 is a highly available and scalable Domain Name System (DNS) web service.</p> <p>You can use Route 53 to:</p> <ul> <li> <p>Register domain names.</p> <p>For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-domain-registration.html\">How domain registration works</a>.</p> </li> <li> <p>Route internet traffic to the resources for your domain</p> <p>For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-dns-service.html\">How internet traffic is routed to your website or web application</a>.</p> </li> <li> <p>Check the health of your resources.</p> <p>For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-health-checks.html\">How Route 53 checks the health of your resources</a>.</p> </li> </ul>
 *
 * The version of the OpenAPI document: 2013-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.HealthCheckRegion;
import org.openapitools.client.model.ResettableElementName;
import org.openapitools.client.model.UpdateHealthCheckRequestAlarmIdentifier;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateHealthCheckRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:09:28.020907-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateHealthCheckRequest {
  public static final String SERIALIZED_NAME_HEALTH_CHECK_VERSION = "HealthCheckVersion";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK_VERSION)
  private Integer healthCheckVersion;

  public static final String SERIALIZED_NAME_IP_ADDRESS = "IPAddress";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS)
  private String ipAddress;

  public static final String SERIALIZED_NAME_PORT = "Port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Integer port;

  public static final String SERIALIZED_NAME_RESOURCE_PATH = "ResourcePath";
  @SerializedName(SERIALIZED_NAME_RESOURCE_PATH)
  private String resourcePath;

  public static final String SERIALIZED_NAME_FULLY_QUALIFIED_DOMAIN_NAME = "FullyQualifiedDomainName";
  @SerializedName(SERIALIZED_NAME_FULLY_QUALIFIED_DOMAIN_NAME)
  private String fullyQualifiedDomainName;

  public static final String SERIALIZED_NAME_SEARCH_STRING = "SearchString";
  @SerializedName(SERIALIZED_NAME_SEARCH_STRING)
  private String searchString;

  public static final String SERIALIZED_NAME_FAILURE_THRESHOLD = "FailureThreshold";
  @SerializedName(SERIALIZED_NAME_FAILURE_THRESHOLD)
  private Integer failureThreshold;

  public static final String SERIALIZED_NAME_INVERTED = "Inverted";
  @SerializedName(SERIALIZED_NAME_INVERTED)
  private Boolean inverted;

  public static final String SERIALIZED_NAME_DISABLED = "Disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  private Boolean disabled;

  public static final String SERIALIZED_NAME_HEALTH_THRESHOLD = "HealthThreshold";
  @SerializedName(SERIALIZED_NAME_HEALTH_THRESHOLD)
  private Integer healthThreshold;

  public static final String SERIALIZED_NAME_CHILD_HEALTH_CHECKS = "ChildHealthChecks";
  @SerializedName(SERIALIZED_NAME_CHILD_HEALTH_CHECKS)
  private List<String> childHealthChecks = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENABLE_S_N_I = "EnableSNI";
  @SerializedName(SERIALIZED_NAME_ENABLE_S_N_I)
  private Boolean enableSNI;

  public static final String SERIALIZED_NAME_REGIONS = "Regions";
  @SerializedName(SERIALIZED_NAME_REGIONS)
  private List<HealthCheckRegion> regions = new ArrayList<>();

  public static final String SERIALIZED_NAME_ALARM_IDENTIFIER = "AlarmIdentifier";
  @SerializedName(SERIALIZED_NAME_ALARM_IDENTIFIER)
  private UpdateHealthCheckRequestAlarmIdentifier alarmIdentifier;

  /**
   * &lt;p&gt;When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Healthy&lt;/code&gt;: Route 53 considers the health check to be healthy.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Unhealthy&lt;/code&gt;: Route 53 considers the health check to be unhealthy.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;LastKnownStatus&lt;/code&gt;: By default, Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the status for the health check is healthy.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   */
  @JsonAdapter(InsufficientDataHealthStatusEnum.Adapter.class)
  public enum InsufficientDataHealthStatusEnum {
    HEALTHY("Healthy"),
    
    UNHEALTHY("Unhealthy"),
    
    LAST_KNOWN_STATUS("LastKnownStatus");

    private String value;

    InsufficientDataHealthStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InsufficientDataHealthStatusEnum fromValue(String value) {
      for (InsufficientDataHealthStatusEnum b : InsufficientDataHealthStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InsufficientDataHealthStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InsufficientDataHealthStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InsufficientDataHealthStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InsufficientDataHealthStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InsufficientDataHealthStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INSUFFICIENT_DATA_HEALTH_STATUS = "InsufficientDataHealthStatus";
  @SerializedName(SERIALIZED_NAME_INSUFFICIENT_DATA_HEALTH_STATUS)
  private InsufficientDataHealthStatusEnum insufficientDataHealthStatus;

  public static final String SERIALIZED_NAME_RESET_ELEMENTS = "ResetElements";
  @SerializedName(SERIALIZED_NAME_RESET_ELEMENTS)
  private List<ResettableElementName> resetElements = new ArrayList<>();

  public UpdateHealthCheckRequest() {
  }

  public UpdateHealthCheckRequest healthCheckVersion(Integer healthCheckVersion) {
    this.healthCheckVersion = healthCheckVersion;
    return this;
  }

  /**
   * &lt;p&gt;A sequential counter that Amazon Route 53 sets to &lt;code&gt;1&lt;/code&gt; when you create a health check and increments by 1 each time you update settings for the health check.&lt;/p&gt; &lt;p&gt;We recommend that you use &lt;code&gt;GetHealthCheck&lt;/code&gt; or &lt;code&gt;ListHealthChecks&lt;/code&gt; to get the current value of &lt;code&gt;HealthCheckVersion&lt;/code&gt; for the health check that you want to update, and that you include that value in your &lt;code&gt;UpdateHealthCheck&lt;/code&gt; request. This prevents Route 53 from overwriting an intervening update:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If the value in the &lt;code&gt;UpdateHealthCheck&lt;/code&gt; request matches the value of &lt;code&gt;HealthCheckVersion&lt;/code&gt; in the health check, Route 53 updates the health check with the new settings.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If the value of &lt;code&gt;HealthCheckVersion&lt;/code&gt; in the health check is greater, the health check was changed after you got the version number. Route 53 does not update the health check, and it returns a &lt;code&gt;HealthCheckVersionMismatch&lt;/code&gt; error.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * minimum: 1
   * @return healthCheckVersion
   */
  @javax.annotation.Nullable
  public Integer getHealthCheckVersion() {
    return healthCheckVersion;
  }

  public void setHealthCheckVersion(Integer healthCheckVersion) {
    this.healthCheckVersion = healthCheckVersion;
  }


  public UpdateHealthCheckRequest ipAddress(String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

  /**
   * &lt;p&gt;The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don&#39;t specify a value for &lt;code&gt;IPAddress&lt;/code&gt;, Route 53 sends a DNS request to resolve the domain name that you specify in &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; at the interval that you specify in &lt;code&gt;RequestInterval&lt;/code&gt;. Using an IP address that is returned by DNS, Route 53 then checks the health of the endpoint.&lt;/p&gt; &lt;p&gt;Use one of the following formats for the value of &lt;code&gt;IPAddress&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;IPv4 address&lt;/b&gt;: four values between 0 and 255, separated by periods (.), for example, &lt;code&gt;192.0.2.44&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;IPv6 address&lt;/b&gt;: eight groups of four hexadecimal values, separated by colons (:), for example, &lt;code&gt;2001:0db8:85a3:0000:0000:abcd:0001:2345&lt;/code&gt;. You can also shorten IPv6 addresses as described in RFC 5952, for example, &lt;code&gt;2001:db8:85a3::abcd:1:2345&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for &lt;code&gt;IPAddress&lt;/code&gt;. This ensures that the IP address of your instance never changes. For more information, see the applicable documentation:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Linux: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html\&quot;&gt;Elastic IP Addresses (EIP)&lt;/a&gt; in the &lt;i&gt;Amazon EC2 User Guide for Linux Instances&lt;/i&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Windows: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html\&quot;&gt;Elastic IP Addresses (EIP)&lt;/a&gt; in the &lt;i&gt;Amazon EC2 User Guide for Windows Instances&lt;/i&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;If a health check already has a value for &lt;code&gt;IPAddress&lt;/code&gt;, you can change the value. However, you can&#39;t update an existing health check to add or remove the value of &lt;code&gt;IPAddress&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\&quot;&gt;FullyQualifiedDomainName&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Constraints: Route 53 can&#39;t check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can&#39;t create health checks, see the following documents:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;a href&#x3D;\&quot;https://tools.ietf.org/html/rfc5735\&quot;&gt;RFC 5735, Special Use IPv4 Addresses&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;a href&#x3D;\&quot;https://tools.ietf.org/html/rfc6598\&quot;&gt;RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;a href&#x3D;\&quot;https://tools.ietf.org/html/rfc5156\&quot;&gt;RFC 5156, Special-Use IPv6 Addresses&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return ipAddress
   */
  @javax.annotation.Nullable
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }


  public UpdateHealthCheckRequest port(Integer port) {
    this.port = port;
    return this;
  }

  /**
   * &lt;p&gt;The port on the endpoint that you want Amazon Route 53 to perform health checks on.&lt;/p&gt; &lt;note&gt; &lt;p&gt;Don&#39;t specify a value for &lt;code&gt;Port&lt;/code&gt; when you specify a value for &lt;code&gt;Type&lt;/code&gt; of &lt;code&gt;CLOUDWATCH_METRIC&lt;/code&gt; or &lt;code&gt;CALCULATED&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt;
   * minimum: 1
   * maximum: 65535
   * @return port
   */
  @javax.annotation.Nullable
  public Integer getPort() {
    return port;
  }

  public void setPort(Integer port) {
    this.port = port;
  }


  public UpdateHealthCheckRequest resourcePath(String resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }

  /**
   * &lt;p&gt;The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html. You can also include query string parameters, for example, &lt;code&gt;/welcome.html?language&#x3D;jp&amp;amp;login&#x3D;y&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;Specify this value only if you want to change it.&lt;/p&gt;
   * @return resourcePath
   */
  @javax.annotation.Nullable
  public String getResourcePath() {
    return resourcePath;
  }

  public void setResourcePath(String resourcePath) {
    this.resourcePath = resourcePath;
  }


  public UpdateHealthCheckRequest fullyQualifiedDomainName(String fullyQualifiedDomainName) {
    this.fullyQualifiedDomainName = fullyQualifiedDomainName;
    return this;
  }

  /**
   * &lt;p&gt;Amazon Route 53 behavior depends on whether you specify a value for &lt;code&gt;IPAddress&lt;/code&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;If a health check already has a value for &lt;code&gt;IPAddress&lt;/code&gt;, you can change the value. However, you can&#39;t update an existing health check to add or remove the value of &lt;code&gt;IPAddress&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt; &lt;p&gt; &lt;b&gt;If you specify a value for&lt;/b&gt; &lt;code&gt;IPAddress&lt;/code&gt;:&lt;/p&gt; &lt;p&gt;Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; in the &lt;code&gt;Host&lt;/code&gt; header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.&lt;/p&gt; &lt;p&gt;When Route 53 checks the health of an endpoint, here is how it constructs the &lt;code&gt;Host&lt;/code&gt; header:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If you specify a value of &lt;code&gt;80&lt;/code&gt; for &lt;code&gt;Port&lt;/code&gt; and &lt;code&gt;HTTP&lt;/code&gt; or &lt;code&gt;HTTP_STR_MATCH&lt;/code&gt; for &lt;code&gt;Type&lt;/code&gt;, Route 53 passes the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; to the endpoint in the &lt;code&gt;Host&lt;/code&gt; header.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If you specify a value of &lt;code&gt;443&lt;/code&gt; for &lt;code&gt;Port&lt;/code&gt; and &lt;code&gt;HTTPS&lt;/code&gt; or &lt;code&gt;HTTPS_STR_MATCH&lt;/code&gt; for &lt;code&gt;Type&lt;/code&gt;, Route 53 passes the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; to the endpoint in the &lt;code&gt;Host&lt;/code&gt; header.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If you specify another value for &lt;code&gt;Port&lt;/code&gt; and any value except &lt;code&gt;TCP&lt;/code&gt; for &lt;code&gt;Type&lt;/code&gt;, Route 53 passes &lt;i&gt; &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;:&lt;code&gt;Port&lt;/code&gt; &lt;/i&gt; to the endpoint in the &lt;code&gt;Host&lt;/code&gt; header.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you don&#39;t specify a value for &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;, Route 53 substitutes the value of &lt;code&gt;IPAddress&lt;/code&gt; in the &lt;code&gt;Host&lt;/code&gt; header in each of the above cases.&lt;/p&gt; &lt;p&gt; &lt;b&gt;If you don&#39;t specify a value for&lt;/b&gt; &lt;code&gt;IPAddress&lt;/code&gt;:&lt;/p&gt; &lt;p&gt;If you don&#39;t specify a value for &lt;code&gt;IPAddress&lt;/code&gt;, Route 53 sends a DNS request to the domain that you specify in &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; at the interval you specify in &lt;code&gt;RequestInterval&lt;/code&gt;. Using an IPv4 address that is returned by DNS, Route 53 then checks the health of the endpoint.&lt;/p&gt; &lt;note&gt; &lt;p&gt;If you don&#39;t specify a value for &lt;code&gt;IPAddress&lt;/code&gt;, Route 53 uses only IPv4 to send health checks to the endpoint. If there&#39;s no resource record set with a type of A for the name that you specify for &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;, the health check fails with a \&quot;DNS resolution failed\&quot; error.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;, we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;, specify the domain name of the server (such as &lt;code&gt;us-east-2-www.example.com&lt;/code&gt;), not the name of the resource record sets (www.example.com).&lt;/p&gt; &lt;important&gt; &lt;p&gt;In this configuration, if the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; matches the name of the resource record sets and you then associate the health check with those resource record sets, health check results will be unpredictable.&lt;/p&gt; &lt;/important&gt; &lt;p&gt;In addition, if the value of &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;HTTP&lt;/code&gt;, &lt;code&gt;HTTPS&lt;/code&gt;, &lt;code&gt;HTTP_STR_MATCH&lt;/code&gt;, or &lt;code&gt;HTTPS_STR_MATCH&lt;/code&gt;, Route 53 passes the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; in the &lt;code&gt;Host&lt;/code&gt; header, as it does when you specify a value for &lt;code&gt;IPAddress&lt;/code&gt;. If the value of &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;TCP&lt;/code&gt;, Route 53 doesn&#39;t pass a &lt;code&gt;Host&lt;/code&gt; header.&lt;/p&gt;
   * @return fullyQualifiedDomainName
   */
  @javax.annotation.Nullable
  public String getFullyQualifiedDomainName() {
    return fullyQualifiedDomainName;
  }

  public void setFullyQualifiedDomainName(String fullyQualifiedDomainName) {
    this.fullyQualifiedDomainName = fullyQualifiedDomainName;
  }


  public UpdateHealthCheckRequest searchString(String searchString) {
    this.searchString = searchString;
    return this;
  }

  /**
   * If the value of &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;HTTP_STR_MATCH&lt;/code&gt; or &lt;code&gt;HTTPS_STR_MATCH&lt;/code&gt;, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy. (You can&#39;t change the value of &lt;code&gt;Type&lt;/code&gt; when you update a health check.)
   * @return searchString
   */
  @javax.annotation.Nullable
  public String getSearchString() {
    return searchString;
  }

  public void setSearchString(String searchString) {
    this.searchString = searchString;
  }


  public UpdateHealthCheckRequest failureThreshold(Integer failureThreshold) {
    this.failureThreshold = failureThreshold;
    return this;
  }

  /**
   * &lt;p&gt;The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html\&quot;&gt;How Amazon Route 53 Determines Whether an Endpoint Is Healthy&lt;/a&gt; in the &lt;i&gt;Amazon Route 53 Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you don&#39;t specify a value for &lt;code&gt;FailureThreshold&lt;/code&gt;, the default value is three health checks.&lt;/p&gt;
   * minimum: 1
   * maximum: 10
   * @return failureThreshold
   */
  @javax.annotation.Nullable
  public Integer getFailureThreshold() {
    return failureThreshold;
  }

  public void setFailureThreshold(Integer failureThreshold) {
    this.failureThreshold = failureThreshold;
  }


  public UpdateHealthCheckRequest inverted(Boolean inverted) {
    this.inverted = inverted;
    return this;
  }

  /**
   * Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.
   * @return inverted
   */
  @javax.annotation.Nullable
  public Boolean getInverted() {
    return inverted;
  }

  public void setInverted(Boolean inverted) {
    this.inverted = inverted;
  }


  public UpdateHealthCheckRequest disabled(Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * &lt;p&gt;Stops Route 53 from performing health checks. When you disable a health check, here&#39;s what happens:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;Health checks that check the health of endpoints:&lt;/b&gt; Route 53 stops submitting requests to your application, server, or other resource.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;Calculated health checks:&lt;/b&gt; Route 53 stops aggregating the status of the referenced health checks.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;b&gt;Health checks that monitor CloudWatch alarms:&lt;/b&gt; Route 53 stops monitoring the corresponding CloudWatch metrics.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;After you disable a health check, Route 53 considers the status of the health check to always be healthy. If you configured DNS failover, Route 53 continues to route traffic to the corresponding resources. If you want to stop routing traffic to a resource, change the value of &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-Inverted\&quot;&gt;Inverted&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Charges for a health check still apply when the health check is disabled. For more information, see &lt;a href&#x3D;\&quot;http://aws.amazon.com/route53/pricing/\&quot;&gt;Amazon Route 53 Pricing&lt;/a&gt;.&lt;/p&gt;
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(Boolean disabled) {
    this.disabled = disabled;
  }


  public UpdateHealthCheckRequest healthThreshold(Integer healthThreshold) {
    this.healthThreshold = healthThreshold;
    return this;
  }

  /**
   * &lt;p&gt;The number of child health checks that are associated with a &lt;code&gt;CALCULATED&lt;/code&gt; health that Amazon Route 53 must consider healthy for the &lt;code&gt;CALCULATED&lt;/code&gt; health check to be considered healthy. To specify the child health checks that you want to associate with a &lt;code&gt;CALCULATED&lt;/code&gt; health check, use the &lt;code&gt;ChildHealthChecks&lt;/code&gt; and &lt;code&gt;ChildHealthCheck&lt;/code&gt; elements.&lt;/p&gt; &lt;p&gt;Note the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If you specify &lt;code&gt;0&lt;/code&gt;, Route 53 always considers this health check to be healthy.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * minimum: 0
   * maximum: 256
   * @return healthThreshold
   */
  @javax.annotation.Nullable
  public Integer getHealthThreshold() {
    return healthThreshold;
  }

  public void setHealthThreshold(Integer healthThreshold) {
    this.healthThreshold = healthThreshold;
  }


  public UpdateHealthCheckRequest childHealthChecks(List<String> childHealthChecks) {
    this.childHealthChecks = childHealthChecks;
    return this;
  }

  public UpdateHealthCheckRequest addChildHealthChecksItem(String childHealthChecksItem) {
    if (this.childHealthChecks == null) {
      this.childHealthChecks = new ArrayList<>();
    }
    this.childHealthChecks.add(childHealthChecksItem);
    return this;
  }

  /**
   * A complex type that contains one &lt;code&gt;ChildHealthCheck&lt;/code&gt; element for each health check that you want to associate with a &lt;code&gt;CALCULATED&lt;/code&gt; health check.
   * @return childHealthChecks
   */
  @javax.annotation.Nullable
  public List<String> getChildHealthChecks() {
    return childHealthChecks;
  }

  public void setChildHealthChecks(List<String> childHealthChecks) {
    this.childHealthChecks = childHealthChecks;
  }


  public UpdateHealthCheckRequest enableSNI(Boolean enableSNI) {
    this.enableSNI = enableSNI;
    return this;
  }

  /**
   * &lt;p&gt;Specify whether you want Amazon Route 53 to send the value of &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; to the endpoint in the &lt;code&gt;client_hello&lt;/code&gt; message during &lt;code&gt;TLS&lt;/code&gt; negotiation. This allows the endpoint to respond to &lt;code&gt;HTTPS&lt;/code&gt; health check requests with the applicable SSL/TLS certificate.&lt;/p&gt; &lt;p&gt;Some endpoints require that HTTPS requests include the host name in the &lt;code&gt;client_hello&lt;/code&gt; message. If you don&#39;t enable SNI, the status of the health check will be SSL alert &lt;code&gt;handshake_failure&lt;/code&gt;. A health check can also have that status for other reasons. If SNI is enabled and you&#39;re still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.&lt;/p&gt; &lt;p&gt;The SSL/TLS certificate on your endpoint includes a domain name in the &lt;code&gt;Common Name&lt;/code&gt; field and possibly several more in the &lt;code&gt;Subject Alternative Names&lt;/code&gt; field. One of the domain names in the certificate should match the value that you specify for &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;. If the endpoint responds to the &lt;code&gt;client_hello&lt;/code&gt; message with a certificate that does not include the domain name that you specified in &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;, a health checker will retry the handshake. In the second attempt, the health checker will omit &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt; from the &lt;code&gt;client_hello&lt;/code&gt; message.&lt;/p&gt;
   * @return enableSNI
   */
  @javax.annotation.Nullable
  public Boolean getEnableSNI() {
    return enableSNI;
  }

  public void setEnableSNI(Boolean enableSNI) {
    this.enableSNI = enableSNI;
  }


  public UpdateHealthCheckRequest regions(List<HealthCheckRegion> regions) {
    this.regions = regions;
    return this;
  }

  public UpdateHealthCheckRequest addRegionsItem(HealthCheckRegion regionsItem) {
    if (this.regions == null) {
      this.regions = new ArrayList<>();
    }
    this.regions.add(regionsItem);
    return this;
  }

  /**
   * A complex type that contains one &lt;code&gt;Region&lt;/code&gt; element for each region that you want Amazon Route 53 health checkers to check the specified endpoint from.
   * @return regions
   */
  @javax.annotation.Nullable
  public List<HealthCheckRegion> getRegions() {
    return regions;
  }

  public void setRegions(List<HealthCheckRegion> regions) {
    this.regions = regions;
  }


  public UpdateHealthCheckRequest alarmIdentifier(UpdateHealthCheckRequestAlarmIdentifier alarmIdentifier) {
    this.alarmIdentifier = alarmIdentifier;
    return this;
  }

  /**
   * Get alarmIdentifier
   * @return alarmIdentifier
   */
  @javax.annotation.Nullable
  public UpdateHealthCheckRequestAlarmIdentifier getAlarmIdentifier() {
    return alarmIdentifier;
  }

  public void setAlarmIdentifier(UpdateHealthCheckRequestAlarmIdentifier alarmIdentifier) {
    this.alarmIdentifier = alarmIdentifier;
  }


  public UpdateHealthCheckRequest insufficientDataHealthStatus(InsufficientDataHealthStatusEnum insufficientDataHealthStatus) {
    this.insufficientDataHealthStatus = insufficientDataHealthStatus;
    return this;
  }

  /**
   * &lt;p&gt;When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Healthy&lt;/code&gt;: Route 53 considers the health check to be healthy.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Unhealthy&lt;/code&gt;: Route 53 considers the health check to be unhealthy.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;LastKnownStatus&lt;/code&gt;: By default, Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the status for the health check is healthy.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return insufficientDataHealthStatus
   */
  @javax.annotation.Nullable
  public InsufficientDataHealthStatusEnum getInsufficientDataHealthStatus() {
    return insufficientDataHealthStatus;
  }

  public void setInsufficientDataHealthStatus(InsufficientDataHealthStatusEnum insufficientDataHealthStatus) {
    this.insufficientDataHealthStatus = insufficientDataHealthStatus;
  }


  public UpdateHealthCheckRequest resetElements(List<ResettableElementName> resetElements) {
    this.resetElements = resetElements;
    return this;
  }

  public UpdateHealthCheckRequest addResetElementsItem(ResettableElementName resetElementsItem) {
    if (this.resetElements == null) {
      this.resetElements = new ArrayList<>();
    }
    this.resetElements.add(resetElementsItem);
    return this;
  }

  /**
   * &lt;p&gt;A complex type that contains one &lt;code&gt;ResettableElementName&lt;/code&gt; element for each element that you want to reset to the default value. Valid values for &lt;code&gt;ResettableElementName&lt;/code&gt; include the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;ChildHealthChecks&lt;/code&gt;: Amazon Route 53 resets &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ChildHealthChecks\&quot;&gt;ChildHealthChecks&lt;/a&gt; to null.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;FullyQualifiedDomainName&lt;/code&gt;: Route 53 resets &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\&quot;&gt;FullyQualifiedDomainName&lt;/a&gt;. to null.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Regions&lt;/code&gt;: Route 53 resets the &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions\&quot;&gt;Regions&lt;/a&gt; list to the default set of regions. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;ResourcePath&lt;/code&gt;: Route 53 resets &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ResourcePath\&quot;&gt;ResourcePath&lt;/a&gt; to null.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return resetElements
   */
  @javax.annotation.Nullable
  public List<ResettableElementName> getResetElements() {
    return resetElements;
  }

  public void setResetElements(List<ResettableElementName> resetElements) {
    this.resetElements = resetElements;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateHealthCheckRequest updateHealthCheckRequest = (UpdateHealthCheckRequest) o;
    return Objects.equals(this.healthCheckVersion, updateHealthCheckRequest.healthCheckVersion) &&
        Objects.equals(this.ipAddress, updateHealthCheckRequest.ipAddress) &&
        Objects.equals(this.port, updateHealthCheckRequest.port) &&
        Objects.equals(this.resourcePath, updateHealthCheckRequest.resourcePath) &&
        Objects.equals(this.fullyQualifiedDomainName, updateHealthCheckRequest.fullyQualifiedDomainName) &&
        Objects.equals(this.searchString, updateHealthCheckRequest.searchString) &&
        Objects.equals(this.failureThreshold, updateHealthCheckRequest.failureThreshold) &&
        Objects.equals(this.inverted, updateHealthCheckRequest.inverted) &&
        Objects.equals(this.disabled, updateHealthCheckRequest.disabled) &&
        Objects.equals(this.healthThreshold, updateHealthCheckRequest.healthThreshold) &&
        Objects.equals(this.childHealthChecks, updateHealthCheckRequest.childHealthChecks) &&
        Objects.equals(this.enableSNI, updateHealthCheckRequest.enableSNI) &&
        Objects.equals(this.regions, updateHealthCheckRequest.regions) &&
        Objects.equals(this.alarmIdentifier, updateHealthCheckRequest.alarmIdentifier) &&
        Objects.equals(this.insufficientDataHealthStatus, updateHealthCheckRequest.insufficientDataHealthStatus) &&
        Objects.equals(this.resetElements, updateHealthCheckRequest.resetElements);
  }

  @Override
  public int hashCode() {
    return Objects.hash(healthCheckVersion, ipAddress, port, resourcePath, fullyQualifiedDomainName, searchString, failureThreshold, inverted, disabled, healthThreshold, childHealthChecks, enableSNI, regions, alarmIdentifier, insufficientDataHealthStatus, resetElements);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateHealthCheckRequest {\n");
    sb.append("    healthCheckVersion: ").append(toIndentedString(healthCheckVersion)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    resourcePath: ").append(toIndentedString(resourcePath)).append("\n");
    sb.append("    fullyQualifiedDomainName: ").append(toIndentedString(fullyQualifiedDomainName)).append("\n");
    sb.append("    searchString: ").append(toIndentedString(searchString)).append("\n");
    sb.append("    failureThreshold: ").append(toIndentedString(failureThreshold)).append("\n");
    sb.append("    inverted: ").append(toIndentedString(inverted)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    healthThreshold: ").append(toIndentedString(healthThreshold)).append("\n");
    sb.append("    childHealthChecks: ").append(toIndentedString(childHealthChecks)).append("\n");
    sb.append("    enableSNI: ").append(toIndentedString(enableSNI)).append("\n");
    sb.append("    regions: ").append(toIndentedString(regions)).append("\n");
    sb.append("    alarmIdentifier: ").append(toIndentedString(alarmIdentifier)).append("\n");
    sb.append("    insufficientDataHealthStatus: ").append(toIndentedString(insufficientDataHealthStatus)).append("\n");
    sb.append("    resetElements: ").append(toIndentedString(resetElements)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("HealthCheckVersion");
    openapiFields.add("IPAddress");
    openapiFields.add("Port");
    openapiFields.add("ResourcePath");
    openapiFields.add("FullyQualifiedDomainName");
    openapiFields.add("SearchString");
    openapiFields.add("FailureThreshold");
    openapiFields.add("Inverted");
    openapiFields.add("Disabled");
    openapiFields.add("HealthThreshold");
    openapiFields.add("ChildHealthChecks");
    openapiFields.add("EnableSNI");
    openapiFields.add("Regions");
    openapiFields.add("AlarmIdentifier");
    openapiFields.add("InsufficientDataHealthStatus");
    openapiFields.add("ResetElements");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateHealthCheckRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateHealthCheckRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateHealthCheckRequest is not found in the empty JSON string", UpdateHealthCheckRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateHealthCheckRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateHealthCheckRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("IPAddress") != null && !jsonObj.get("IPAddress").isJsonNull()) && !jsonObj.get("IPAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `IPAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("IPAddress").toString()));
      }
      if ((jsonObj.get("ResourcePath") != null && !jsonObj.get("ResourcePath").isJsonNull()) && !jsonObj.get("ResourcePath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ResourcePath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ResourcePath").toString()));
      }
      if ((jsonObj.get("FullyQualifiedDomainName") != null && !jsonObj.get("FullyQualifiedDomainName").isJsonNull()) && !jsonObj.get("FullyQualifiedDomainName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `FullyQualifiedDomainName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("FullyQualifiedDomainName").toString()));
      }
      if ((jsonObj.get("SearchString") != null && !jsonObj.get("SearchString").isJsonNull()) && !jsonObj.get("SearchString").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SearchString` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SearchString").toString()));
      }
      if (jsonObj.get("ChildHealthChecks") != null && !jsonObj.get("ChildHealthChecks").isJsonNull()) {
        JsonArray jsonArraychildHealthChecks = jsonObj.getAsJsonArray("ChildHealthChecks");
        if (jsonArraychildHealthChecks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ChildHealthChecks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ChildHealthChecks` to be an array in the JSON string but got `%s`", jsonObj.get("ChildHealthChecks").toString()));
          }

          // validate the optional field `ChildHealthChecks` (array)
          for (int i = 0; i < jsonArraychildHealthChecks.size(); i++) {
            String.validateJsonElement(jsonArraychildHealthChecks.get(i));
          };
        }
      }
      if (jsonObj.get("Regions") != null && !jsonObj.get("Regions").isJsonNull()) {
        JsonArray jsonArrayregions = jsonObj.getAsJsonArray("Regions");
        if (jsonArrayregions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("Regions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `Regions` to be an array in the JSON string but got `%s`", jsonObj.get("Regions").toString()));
          }

          // validate the optional field `Regions` (array)
          for (int i = 0; i < jsonArrayregions.size(); i++) {
            HealthCheckRegion.validateJsonElement(jsonArrayregions.get(i));
          };
        }
      }
      // validate the optional field `AlarmIdentifier`
      if (jsonObj.get("AlarmIdentifier") != null && !jsonObj.get("AlarmIdentifier").isJsonNull()) {
        UpdateHealthCheckRequestAlarmIdentifier.validateJsonElement(jsonObj.get("AlarmIdentifier"));
      }
      if ((jsonObj.get("InsufficientDataHealthStatus") != null && !jsonObj.get("InsufficientDataHealthStatus").isJsonNull()) && !jsonObj.get("InsufficientDataHealthStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `InsufficientDataHealthStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("InsufficientDataHealthStatus").toString()));
      }
      // validate the optional field `InsufficientDataHealthStatus`
      if (jsonObj.get("InsufficientDataHealthStatus") != null && !jsonObj.get("InsufficientDataHealthStatus").isJsonNull()) {
        InsufficientDataHealthStatusEnum.validateJsonElement(jsonObj.get("InsufficientDataHealthStatus"));
      }
      if (jsonObj.get("ResetElements") != null && !jsonObj.get("ResetElements").isJsonNull()) {
        JsonArray jsonArrayresetElements = jsonObj.getAsJsonArray("ResetElements");
        if (jsonArrayresetElements != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ResetElements").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ResetElements` to be an array in the JSON string but got `%s`", jsonObj.get("ResetElements").toString()));
          }

          // validate the optional field `ResetElements` (array)
          for (int i = 0; i < jsonArrayresetElements.size(); i++) {
            ResettableElementName.validateJsonElement(jsonArrayresetElements.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateHealthCheckRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateHealthCheckRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateHealthCheckRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateHealthCheckRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateHealthCheckRequest>() {
           @Override
           public void write(JsonWriter out, UpdateHealthCheckRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateHealthCheckRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateHealthCheckRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateHealthCheckRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateHealthCheckRequest
   */
  public static UpdateHealthCheckRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateHealthCheckRequest.class);
  }

  /**
   * Convert an instance of UpdateHealthCheckRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

