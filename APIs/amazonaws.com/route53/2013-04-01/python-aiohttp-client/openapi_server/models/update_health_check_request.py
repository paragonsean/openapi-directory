# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.health_check_region import HealthCheckRegion
from openapi_server.models.resettable_element_name import ResettableElementName
from openapi_server.models.update_health_check_request_alarm_identifier import UpdateHealthCheckRequestAlarmIdentifier
import re
from openapi_server import util


class UpdateHealthCheckRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, health_check_version: int=None, ip_address: str=None, port: int=None, _resource_path: str=None, fully_qualified_domain_name: str=None, search_string: str=None, failure_threshold: int=None, inverted: bool=None, disabled: bool=None, health_threshold: int=None, child_health_checks: List[str]=None, enable_sni: bool=None, regions: List[HealthCheckRegion]=None, alarm_identifier: UpdateHealthCheckRequestAlarmIdentifier=None, insufficient_data_health_status: str=None, reset_elements: List[ResettableElementName]=None):
        """UpdateHealthCheckRequest - a model defined in OpenAPI

        :param health_check_version: The health_check_version of this UpdateHealthCheckRequest.
        :param ip_address: The ip_address of this UpdateHealthCheckRequest.
        :param port: The port of this UpdateHealthCheckRequest.
        :param _resource_path: The _resource_path of this UpdateHealthCheckRequest.
        :param fully_qualified_domain_name: The fully_qualified_domain_name of this UpdateHealthCheckRequest.
        :param search_string: The search_string of this UpdateHealthCheckRequest.
        :param failure_threshold: The failure_threshold of this UpdateHealthCheckRequest.
        :param inverted: The inverted of this UpdateHealthCheckRequest.
        :param disabled: The disabled of this UpdateHealthCheckRequest.
        :param health_threshold: The health_threshold of this UpdateHealthCheckRequest.
        :param child_health_checks: The child_health_checks of this UpdateHealthCheckRequest.
        :param enable_sni: The enable_sni of this UpdateHealthCheckRequest.
        :param regions: The regions of this UpdateHealthCheckRequest.
        :param alarm_identifier: The alarm_identifier of this UpdateHealthCheckRequest.
        :param insufficient_data_health_status: The insufficient_data_health_status of this UpdateHealthCheckRequest.
        :param reset_elements: The reset_elements of this UpdateHealthCheckRequest.
        """
        self.openapi_types = {
            'health_check_version': int,
            'ip_address': str,
            'port': int,
            '_resource_path': str,
            'fully_qualified_domain_name': str,
            'search_string': str,
            'failure_threshold': int,
            'inverted': bool,
            'disabled': bool,
            'health_threshold': int,
            'child_health_checks': List[str],
            'enable_sni': bool,
            'regions': List[HealthCheckRegion],
            'alarm_identifier': UpdateHealthCheckRequestAlarmIdentifier,
            'insufficient_data_health_status': str,
            'reset_elements': List[ResettableElementName]
        }

        self.attribute_map = {
            'health_check_version': 'HealthCheckVersion',
            'ip_address': 'IPAddress',
            'port': 'Port',
            '_resource_path': 'ResourcePath',
            'fully_qualified_domain_name': 'FullyQualifiedDomainName',
            'search_string': 'SearchString',
            'failure_threshold': 'FailureThreshold',
            'inverted': 'Inverted',
            'disabled': 'Disabled',
            'health_threshold': 'HealthThreshold',
            'child_health_checks': 'ChildHealthChecks',
            'enable_sni': 'EnableSNI',
            'regions': 'Regions',
            'alarm_identifier': 'AlarmIdentifier',
            'insufficient_data_health_status': 'InsufficientDataHealthStatus',
            'reset_elements': 'ResetElements'
        }

        self._health_check_version = health_check_version
        self._ip_address = ip_address
        self._port = port
        self.__resource_path = _resource_path
        self._fully_qualified_domain_name = fully_qualified_domain_name
        self._search_string = search_string
        self._failure_threshold = failure_threshold
        self._inverted = inverted
        self._disabled = disabled
        self._health_threshold = health_threshold
        self._child_health_checks = child_health_checks
        self._enable_sni = enable_sni
        self._regions = regions
        self._alarm_identifier = alarm_identifier
        self._insufficient_data_health_status = insufficient_data_health_status
        self._reset_elements = reset_elements

    @classmethod
    def from_dict(cls, dikt: dict) -> 'UpdateHealthCheckRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The UpdateHealthCheck_request of this UpdateHealthCheckRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def health_check_version(self):
        """Gets the health_check_version of this UpdateHealthCheckRequest.

        <p>A sequential counter that Amazon Route 53 sets to <code>1</code> when you create a health check and increments by 1 each time you update settings for the health check.</p> <p>We recommend that you use <code>GetHealthCheck</code> or <code>ListHealthChecks</code> to get the current value of <code>HealthCheckVersion</code> for the health check that you want to update, and that you include that value in your <code>UpdateHealthCheck</code> request. This prevents Route 53 from overwriting an intervening update:</p> <ul> <li> <p>If the value in the <code>UpdateHealthCheck</code> request matches the value of <code>HealthCheckVersion</code> in the health check, Route 53 updates the health check with the new settings.</p> </li> <li> <p>If the value of <code>HealthCheckVersion</code> in the health check is greater, the health check was changed after you got the version number. Route 53 does not update the health check, and it returns a <code>HealthCheckVersionMismatch</code> error.</p> </li> </ul>

        :return: The health_check_version of this UpdateHealthCheckRequest.
        :rtype: int
        """
        return self._health_check_version

    @health_check_version.setter
    def health_check_version(self, health_check_version):
        """Sets the health_check_version of this UpdateHealthCheckRequest.

        <p>A sequential counter that Amazon Route 53 sets to <code>1</code> when you create a health check and increments by 1 each time you update settings for the health check.</p> <p>We recommend that you use <code>GetHealthCheck</code> or <code>ListHealthChecks</code> to get the current value of <code>HealthCheckVersion</code> for the health check that you want to update, and that you include that value in your <code>UpdateHealthCheck</code> request. This prevents Route 53 from overwriting an intervening update:</p> <ul> <li> <p>If the value in the <code>UpdateHealthCheck</code> request matches the value of <code>HealthCheckVersion</code> in the health check, Route 53 updates the health check with the new settings.</p> </li> <li> <p>If the value of <code>HealthCheckVersion</code> in the health check is greater, the health check was changed after you got the version number. Route 53 does not update the health check, and it returns a <code>HealthCheckVersionMismatch</code> error.</p> </li> </ul>

        :param health_check_version: The health_check_version of this UpdateHealthCheckRequest.
        :type health_check_version: int
        """
        if health_check_version is not None and health_check_version < 1:
            raise ValueError("Invalid value for `health_check_version`, must be a value greater than or equal to `1`")

        self._health_check_version = health_check_version

    @property
    def ip_address(self):
        """Gets the ip_address of this UpdateHealthCheckRequest.

        <p>The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to resolve the domain name that you specify in <code>FullyQualifiedDomainName</code> at the interval that you specify in <code>RequestInterval</code>. Using an IP address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <p>Use one of the following formats for the value of <code>IPAddress</code>: </p> <ul> <li> <p> <b>IPv4 address</b>: four values between 0 and 255, separated by periods (.), for example, <code>192.0.2.44</code>.</p> </li> <li> <p> <b>IPv6 address</b>: eight groups of four hexadecimal values, separated by colons (:), for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>. You can also shorten IPv6 addresses as described in RFC 5952, for example, <code>2001:db8:85a3::abcd:1:2345</code>.</p> </li> </ul> <p>If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for <code>IPAddress</code>. This ensures that the IP address of your instance never changes. For more information, see the applicable documentation:</p> <ul> <li> <p>Linux: <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html\">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Linux Instances</i> </p> </li> <li> <p>Windows: <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html\">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Windows Instances</i> </p> </li> </ul> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p>For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\">FullyQualifiedDomainName</a>. </p> <p>Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:</p> <ul> <li> <p> <a href=\"https://tools.ietf.org/html/rfc5735\">RFC 5735, Special Use IPv4 Addresses</a> </p> </li> <li> <p> <a href=\"https://tools.ietf.org/html/rfc6598\">RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space</a> </p> </li> <li> <p> <a href=\"https://tools.ietf.org/html/rfc5156\">RFC 5156, Special-Use IPv6 Addresses</a> </p> </li> </ul>

        :return: The ip_address of this UpdateHealthCheckRequest.
        :rtype: str
        """
        return self._ip_address

    @ip_address.setter
    def ip_address(self, ip_address):
        """Sets the ip_address of this UpdateHealthCheckRequest.

        <p>The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to resolve the domain name that you specify in <code>FullyQualifiedDomainName</code> at the interval that you specify in <code>RequestInterval</code>. Using an IP address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <p>Use one of the following formats for the value of <code>IPAddress</code>: </p> <ul> <li> <p> <b>IPv4 address</b>: four values between 0 and 255, separated by periods (.), for example, <code>192.0.2.44</code>.</p> </li> <li> <p> <b>IPv6 address</b>: eight groups of four hexadecimal values, separated by colons (:), for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>. You can also shorten IPv6 addresses as described in RFC 5952, for example, <code>2001:db8:85a3::abcd:1:2345</code>.</p> </li> </ul> <p>If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for <code>IPAddress</code>. This ensures that the IP address of your instance never changes. For more information, see the applicable documentation:</p> <ul> <li> <p>Linux: <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html\">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Linux Instances</i> </p> </li> <li> <p>Windows: <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html\">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Windows Instances</i> </p> </li> </ul> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p>For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\">FullyQualifiedDomainName</a>. </p> <p>Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:</p> <ul> <li> <p> <a href=\"https://tools.ietf.org/html/rfc5735\">RFC 5735, Special Use IPv4 Addresses</a> </p> </li> <li> <p> <a href=\"https://tools.ietf.org/html/rfc6598\">RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space</a> </p> </li> <li> <p> <a href=\"https://tools.ietf.org/html/rfc5156\">RFC 5156, Special-Use IPv6 Addresses</a> </p> </li> </ul>

        :param ip_address: The ip_address of this UpdateHealthCheckRequest.
        :type ip_address: str
        """
        if ip_address is not None and len(ip_address) > 45:
            raise ValueError("Invalid value for `ip_address`, length must be less than or equal to `45`")
        if ip_address is not None and not re.search(r'(^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$)', ip_address):
            raise ValueError("Invalid value for `ip_address`, must be a follow pattern or equal to `/(^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$)/`")

        self._ip_address = ip_address

    @property
    def port(self):
        """Gets the port of this UpdateHealthCheckRequest.

        <p>The port on the endpoint that you want Amazon Route 53 to perform health checks on.</p> <note> <p>Don't specify a value for <code>Port</code> when you specify a value for <code>Type</code> of <code>CLOUDWATCH_METRIC</code> or <code>CALCULATED</code>.</p> </note>

        :return: The port of this UpdateHealthCheckRequest.
        :rtype: int
        """
        return self._port

    @port.setter
    def port(self, port):
        """Sets the port of this UpdateHealthCheckRequest.

        <p>The port on the endpoint that you want Amazon Route 53 to perform health checks on.</p> <note> <p>Don't specify a value for <code>Port</code> when you specify a value for <code>Type</code> of <code>CLOUDWATCH_METRIC</code> or <code>CALCULATED</code>.</p> </note>

        :param port: The port of this UpdateHealthCheckRequest.
        :type port: int
        """
        if port is not None and port > 65535:
            raise ValueError("Invalid value for `port`, must be a value less than or equal to `65535`")
        if port is not None and port < 1:
            raise ValueError("Invalid value for `port`, must be a value greater than or equal to `1`")

        self._port = port

    @property
    def _resource_path(self):
        """Gets the _resource_path of this UpdateHealthCheckRequest.

        <p>The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html. You can also include query string parameters, for example, <code>/welcome.html?language=jp&amp;login=y</code>. </p> <p>Specify this value only if you want to change it.</p>

        :return: The _resource_path of this UpdateHealthCheckRequest.
        :rtype: str
        """
        return self.__resource_path

    @_resource_path.setter
    def _resource_path(self, _resource_path):
        """Sets the _resource_path of this UpdateHealthCheckRequest.

        <p>The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html. You can also include query string parameters, for example, <code>/welcome.html?language=jp&amp;login=y</code>. </p> <p>Specify this value only if you want to change it.</p>

        :param _resource_path: The _resource_path of this UpdateHealthCheckRequest.
        :type _resource_path: str
        """
        if _resource_path is not None and len(_resource_path) > 255:
            raise ValueError("Invalid value for `_resource_path`, length must be less than or equal to `255`")

        self.__resource_path = _resource_path

    @property
    def fully_qualified_domain_name(self):
        """Gets the fully_qualified_domain_name of this UpdateHealthCheckRequest.

        <p>Amazon Route 53 behavior depends on whether you specify a value for <code>IPAddress</code>.</p> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p> <b>If you specify a value for</b> <code>IPAddress</code>:</p> <p>Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.</p> <p>When Route 53 checks the health of an endpoint, here is how it constructs the <code>Host</code> header:</p> <ul> <li> <p>If you specify a value of <code>80</code> for <code>Port</code> and <code>HTTP</code> or <code>HTTP_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify a value of <code>443</code> for <code>Port</code> and <code>HTTPS</code> or <code>HTTPS_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify another value for <code>Port</code> and any value except <code>TCP</code> for <code>Type</code>, Route 53 passes <i> <code>FullyQualifiedDomainName</code>:<code>Port</code> </i> to the endpoint in the <code>Host</code> header.</p> </li> </ul> <p>If you don't specify a value for <code>FullyQualifiedDomainName</code>, Route 53 substitutes the value of <code>IPAddress</code> in the <code>Host</code> header in each of the above cases.</p> <p> <b>If you don't specify a value for</b> <code>IPAddress</code>:</p> <p>If you don't specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to the domain that you specify in <code>FullyQualifiedDomainName</code> at the interval you specify in <code>RequestInterval</code>. Using an IPv4 address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <note> <p>If you don't specify a value for <code>IPAddress</code>, Route 53 uses only IPv4 to send health checks to the endpoint. If there's no resource record set with a type of A for the name that you specify for <code>FullyQualifiedDomainName</code>, the health check fails with a \"DNS resolution failed\" error.</p> </note> <p>If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by <code>FullyQualifiedDomainName</code>, we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of <code>FullyQualifiedDomainName</code>, specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (www.example.com).</p> <important> <p>In this configuration, if the value of <code>FullyQualifiedDomainName</code> matches the name of the resource record sets and you then associate the health check with those resource record sets, health check results will be unpredictable.</p> </important> <p>In addition, if the value of <code>Type</code> is <code>HTTP</code>, <code>HTTPS</code>, <code>HTTP_STR_MATCH</code>, or <code>HTTPS_STR_MATCH</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header, as it does when you specify a value for <code>IPAddress</code>. If the value of <code>Type</code> is <code>TCP</code>, Route 53 doesn't pass a <code>Host</code> header.</p>

        :return: The fully_qualified_domain_name of this UpdateHealthCheckRequest.
        :rtype: str
        """
        return self._fully_qualified_domain_name

    @fully_qualified_domain_name.setter
    def fully_qualified_domain_name(self, fully_qualified_domain_name):
        """Sets the fully_qualified_domain_name of this UpdateHealthCheckRequest.

        <p>Amazon Route 53 behavior depends on whether you specify a value for <code>IPAddress</code>.</p> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p> <b>If you specify a value for</b> <code>IPAddress</code>:</p> <p>Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.</p> <p>When Route 53 checks the health of an endpoint, here is how it constructs the <code>Host</code> header:</p> <ul> <li> <p>If you specify a value of <code>80</code> for <code>Port</code> and <code>HTTP</code> or <code>HTTP_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify a value of <code>443</code> for <code>Port</code> and <code>HTTPS</code> or <code>HTTPS_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify another value for <code>Port</code> and any value except <code>TCP</code> for <code>Type</code>, Route 53 passes <i> <code>FullyQualifiedDomainName</code>:<code>Port</code> </i> to the endpoint in the <code>Host</code> header.</p> </li> </ul> <p>If you don't specify a value for <code>FullyQualifiedDomainName</code>, Route 53 substitutes the value of <code>IPAddress</code> in the <code>Host</code> header in each of the above cases.</p> <p> <b>If you don't specify a value for</b> <code>IPAddress</code>:</p> <p>If you don't specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to the domain that you specify in <code>FullyQualifiedDomainName</code> at the interval you specify in <code>RequestInterval</code>. Using an IPv4 address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <note> <p>If you don't specify a value for <code>IPAddress</code>, Route 53 uses only IPv4 to send health checks to the endpoint. If there's no resource record set with a type of A for the name that you specify for <code>FullyQualifiedDomainName</code>, the health check fails with a \"DNS resolution failed\" error.</p> </note> <p>If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by <code>FullyQualifiedDomainName</code>, we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of <code>FullyQualifiedDomainName</code>, specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (www.example.com).</p> <important> <p>In this configuration, if the value of <code>FullyQualifiedDomainName</code> matches the name of the resource record sets and you then associate the health check with those resource record sets, health check results will be unpredictable.</p> </important> <p>In addition, if the value of <code>Type</code> is <code>HTTP</code>, <code>HTTPS</code>, <code>HTTP_STR_MATCH</code>, or <code>HTTPS_STR_MATCH</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header, as it does when you specify a value for <code>IPAddress</code>. If the value of <code>Type</code> is <code>TCP</code>, Route 53 doesn't pass a <code>Host</code> header.</p>

        :param fully_qualified_domain_name: The fully_qualified_domain_name of this UpdateHealthCheckRequest.
        :type fully_qualified_domain_name: str
        """
        if fully_qualified_domain_name is not None and len(fully_qualified_domain_name) > 255:
            raise ValueError("Invalid value for `fully_qualified_domain_name`, length must be less than or equal to `255`")

        self._fully_qualified_domain_name = fully_qualified_domain_name

    @property
    def search_string(self):
        """Gets the search_string of this UpdateHealthCheckRequest.

        If the value of <code>Type</code> is <code>HTTP_STR_MATCH</code> or <code>HTTPS_STR_MATCH</code>, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy. (You can't change the value of <code>Type</code> when you update a health check.)

        :return: The search_string of this UpdateHealthCheckRequest.
        :rtype: str
        """
        return self._search_string

    @search_string.setter
    def search_string(self, search_string):
        """Sets the search_string of this UpdateHealthCheckRequest.

        If the value of <code>Type</code> is <code>HTTP_STR_MATCH</code> or <code>HTTPS_STR_MATCH</code>, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy. (You can't change the value of <code>Type</code> when you update a health check.)

        :param search_string: The search_string of this UpdateHealthCheckRequest.
        :type search_string: str
        """
        if search_string is not None and len(search_string) > 255:
            raise ValueError("Invalid value for `search_string`, length must be less than or equal to `255`")

        self._search_string = search_string

    @property
    def failure_threshold(self):
        """Gets the failure_threshold of this UpdateHealthCheckRequest.

        <p>The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html\">How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>If you don't specify a value for <code>FailureThreshold</code>, the default value is three health checks.</p>

        :return: The failure_threshold of this UpdateHealthCheckRequest.
        :rtype: int
        """
        return self._failure_threshold

    @failure_threshold.setter
    def failure_threshold(self, failure_threshold):
        """Sets the failure_threshold of this UpdateHealthCheckRequest.

        <p>The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html\">How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>If you don't specify a value for <code>FailureThreshold</code>, the default value is three health checks.</p>

        :param failure_threshold: The failure_threshold of this UpdateHealthCheckRequest.
        :type failure_threshold: int
        """
        if failure_threshold is not None and failure_threshold > 10:
            raise ValueError("Invalid value for `failure_threshold`, must be a value less than or equal to `10`")
        if failure_threshold is not None and failure_threshold < 1:
            raise ValueError("Invalid value for `failure_threshold`, must be a value greater than or equal to `1`")

        self._failure_threshold = failure_threshold

    @property
    def inverted(self):
        """Gets the inverted of this UpdateHealthCheckRequest.

        Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.

        :return: The inverted of this UpdateHealthCheckRequest.
        :rtype: bool
        """
        return self._inverted

    @inverted.setter
    def inverted(self, inverted):
        """Sets the inverted of this UpdateHealthCheckRequest.

        Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.

        :param inverted: The inverted of this UpdateHealthCheckRequest.
        :type inverted: bool
        """

        self._inverted = inverted

    @property
    def disabled(self):
        """Gets the disabled of this UpdateHealthCheckRequest.

        <p>Stops Route 53 from performing health checks. When you disable a health check, here's what happens:</p> <ul> <li> <p> <b>Health checks that check the health of endpoints:</b> Route 53 stops submitting requests to your application, server, or other resource.</p> </li> <li> <p> <b>Calculated health checks:</b> Route 53 stops aggregating the status of the referenced health checks.</p> </li> <li> <p> <b>Health checks that monitor CloudWatch alarms:</b> Route 53 stops monitoring the corresponding CloudWatch metrics.</p> </li> </ul> <p>After you disable a health check, Route 53 considers the status of the health check to always be healthy. If you configured DNS failover, Route 53 continues to route traffic to the corresponding resources. If you want to stop routing traffic to a resource, change the value of <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-Inverted\">Inverted</a>. </p> <p>Charges for a health check still apply when the health check is disabled. For more information, see <a href=\"http://aws.amazon.com/route53/pricing/\">Amazon Route 53 Pricing</a>.</p>

        :return: The disabled of this UpdateHealthCheckRequest.
        :rtype: bool
        """
        return self._disabled

    @disabled.setter
    def disabled(self, disabled):
        """Sets the disabled of this UpdateHealthCheckRequest.

        <p>Stops Route 53 from performing health checks. When you disable a health check, here's what happens:</p> <ul> <li> <p> <b>Health checks that check the health of endpoints:</b> Route 53 stops submitting requests to your application, server, or other resource.</p> </li> <li> <p> <b>Calculated health checks:</b> Route 53 stops aggregating the status of the referenced health checks.</p> </li> <li> <p> <b>Health checks that monitor CloudWatch alarms:</b> Route 53 stops monitoring the corresponding CloudWatch metrics.</p> </li> </ul> <p>After you disable a health check, Route 53 considers the status of the health check to always be healthy. If you configured DNS failover, Route 53 continues to route traffic to the corresponding resources. If you want to stop routing traffic to a resource, change the value of <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-Inverted\">Inverted</a>. </p> <p>Charges for a health check still apply when the health check is disabled. For more information, see <a href=\"http://aws.amazon.com/route53/pricing/\">Amazon Route 53 Pricing</a>.</p>

        :param disabled: The disabled of this UpdateHealthCheckRequest.
        :type disabled: bool
        """

        self._disabled = disabled

    @property
    def health_threshold(self):
        """Gets the health_threshold of this UpdateHealthCheckRequest.

        <p>The number of child health checks that are associated with a <code>CALCULATED</code> health that Amazon Route 53 must consider healthy for the <code>CALCULATED</code> health check to be considered healthy. To specify the child health checks that you want to associate with a <code>CALCULATED</code> health check, use the <code>ChildHealthChecks</code> and <code>ChildHealthCheck</code> elements.</p> <p>Note the following:</p> <ul> <li> <p>If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.</p> </li> <li> <p>If you specify <code>0</code>, Route 53 always considers this health check to be healthy.</p> </li> </ul>

        :return: The health_threshold of this UpdateHealthCheckRequest.
        :rtype: int
        """
        return self._health_threshold

    @health_threshold.setter
    def health_threshold(self, health_threshold):
        """Sets the health_threshold of this UpdateHealthCheckRequest.

        <p>The number of child health checks that are associated with a <code>CALCULATED</code> health that Amazon Route 53 must consider healthy for the <code>CALCULATED</code> health check to be considered healthy. To specify the child health checks that you want to associate with a <code>CALCULATED</code> health check, use the <code>ChildHealthChecks</code> and <code>ChildHealthCheck</code> elements.</p> <p>Note the following:</p> <ul> <li> <p>If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.</p> </li> <li> <p>If you specify <code>0</code>, Route 53 always considers this health check to be healthy.</p> </li> </ul>

        :param health_threshold: The health_threshold of this UpdateHealthCheckRequest.
        :type health_threshold: int
        """
        if health_threshold is not None and health_threshold > 256:
            raise ValueError("Invalid value for `health_threshold`, must be a value less than or equal to `256`")
        if health_threshold is not None and health_threshold < 0:
            raise ValueError("Invalid value for `health_threshold`, must be a value greater than or equal to `0`")

        self._health_threshold = health_threshold

    @property
    def child_health_checks(self):
        """Gets the child_health_checks of this UpdateHealthCheckRequest.

        A complex type that contains one <code>ChildHealthCheck</code> element for each health check that you want to associate with a <code>CALCULATED</code> health check.

        :return: The child_health_checks of this UpdateHealthCheckRequest.
        :rtype: List[str]
        """
        return self._child_health_checks

    @child_health_checks.setter
    def child_health_checks(self, child_health_checks):
        """Sets the child_health_checks of this UpdateHealthCheckRequest.

        A complex type that contains one <code>ChildHealthCheck</code> element for each health check that you want to associate with a <code>CALCULATED</code> health check.

        :param child_health_checks: The child_health_checks of this UpdateHealthCheckRequest.
        :type child_health_checks: List[str]
        """
        if child_health_checks is not None and len(child_health_checks) > 256:
            raise ValueError("Invalid value for `child_health_checks`, number of items must be less than or equal to `256`")

        self._child_health_checks = child_health_checks

    @property
    def enable_sni(self):
        """Gets the enable_sni of this UpdateHealthCheckRequest.

        <p>Specify whether you want Amazon Route 53 to send the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>client_hello</code> message during <code>TLS</code> negotiation. This allows the endpoint to respond to <code>HTTPS</code> health check requests with the applicable SSL/TLS certificate.</p> <p>Some endpoints require that HTTPS requests include the host name in the <code>client_hello</code> message. If you don't enable SNI, the status of the health check will be SSL alert <code>handshake_failure</code>. A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.</p> <p>The SSL/TLS certificate on your endpoint includes a domain name in the <code>Common Name</code> field and possibly several more in the <code>Subject Alternative Names</code> field. One of the domain names in the certificate should match the value that you specify for <code>FullyQualifiedDomainName</code>. If the endpoint responds to the <code>client_hello</code> message with a certificate that does not include the domain name that you specified in <code>FullyQualifiedDomainName</code>, a health checker will retry the handshake. In the second attempt, the health checker will omit <code>FullyQualifiedDomainName</code> from the <code>client_hello</code> message.</p>

        :return: The enable_sni of this UpdateHealthCheckRequest.
        :rtype: bool
        """
        return self._enable_sni

    @enable_sni.setter
    def enable_sni(self, enable_sni):
        """Sets the enable_sni of this UpdateHealthCheckRequest.

        <p>Specify whether you want Amazon Route 53 to send the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>client_hello</code> message during <code>TLS</code> negotiation. This allows the endpoint to respond to <code>HTTPS</code> health check requests with the applicable SSL/TLS certificate.</p> <p>Some endpoints require that HTTPS requests include the host name in the <code>client_hello</code> message. If you don't enable SNI, the status of the health check will be SSL alert <code>handshake_failure</code>. A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.</p> <p>The SSL/TLS certificate on your endpoint includes a domain name in the <code>Common Name</code> field and possibly several more in the <code>Subject Alternative Names</code> field. One of the domain names in the certificate should match the value that you specify for <code>FullyQualifiedDomainName</code>. If the endpoint responds to the <code>client_hello</code> message with a certificate that does not include the domain name that you specified in <code>FullyQualifiedDomainName</code>, a health checker will retry the handshake. In the second attempt, the health checker will omit <code>FullyQualifiedDomainName</code> from the <code>client_hello</code> message.</p>

        :param enable_sni: The enable_sni of this UpdateHealthCheckRequest.
        :type enable_sni: bool
        """

        self._enable_sni = enable_sni

    @property
    def regions(self):
        """Gets the regions of this UpdateHealthCheckRequest.

        A complex type that contains one <code>Region</code> element for each region that you want Amazon Route 53 health checkers to check the specified endpoint from.

        :return: The regions of this UpdateHealthCheckRequest.
        :rtype: List[HealthCheckRegion]
        """
        return self._regions

    @regions.setter
    def regions(self, regions):
        """Sets the regions of this UpdateHealthCheckRequest.

        A complex type that contains one <code>Region</code> element for each region that you want Amazon Route 53 health checkers to check the specified endpoint from.

        :param regions: The regions of this UpdateHealthCheckRequest.
        :type regions: List[HealthCheckRegion]
        """
        if regions is not None and len(regions) > 64:
            raise ValueError("Invalid value for `regions`, number of items must be less than or equal to `64`")
        if regions is not None and len(regions) < 3:
            raise ValueError("Invalid value for `regions`, number of items must be greater than or equal to `3`")

        self._regions = regions

    @property
    def alarm_identifier(self):
        """Gets the alarm_identifier of this UpdateHealthCheckRequest.


        :return: The alarm_identifier of this UpdateHealthCheckRequest.
        :rtype: UpdateHealthCheckRequestAlarmIdentifier
        """
        return self._alarm_identifier

    @alarm_identifier.setter
    def alarm_identifier(self, alarm_identifier):
        """Sets the alarm_identifier of this UpdateHealthCheckRequest.


        :param alarm_identifier: The alarm_identifier of this UpdateHealthCheckRequest.
        :type alarm_identifier: UpdateHealthCheckRequestAlarmIdentifier
        """

        self._alarm_identifier = alarm_identifier

    @property
    def insufficient_data_health_status(self):
        """Gets the insufficient_data_health_status of this UpdateHealthCheckRequest.

        <p>When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:</p> <ul> <li> <p> <code>Healthy</code>: Route 53 considers the health check to be healthy.</p> </li> <li> <p> <code>Unhealthy</code>: Route 53 considers the health check to be unhealthy.</p> </li> <li> <p> <code>LastKnownStatus</code>: By default, Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the status for the health check is healthy.</p> </li> </ul>

        :return: The insufficient_data_health_status of this UpdateHealthCheckRequest.
        :rtype: str
        """
        return self._insufficient_data_health_status

    @insufficient_data_health_status.setter
    def insufficient_data_health_status(self, insufficient_data_health_status):
        """Sets the insufficient_data_health_status of this UpdateHealthCheckRequest.

        <p>When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:</p> <ul> <li> <p> <code>Healthy</code>: Route 53 considers the health check to be healthy.</p> </li> <li> <p> <code>Unhealthy</code>: Route 53 considers the health check to be unhealthy.</p> </li> <li> <p> <code>LastKnownStatus</code>: By default, Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the status for the health check is healthy.</p> </li> </ul>

        :param insufficient_data_health_status: The insufficient_data_health_status of this UpdateHealthCheckRequest.
        :type insufficient_data_health_status: str
        """
        allowed_values = ["Healthy", "Unhealthy", "LastKnownStatus"]  # noqa: E501
        if insufficient_data_health_status not in allowed_values:
            raise ValueError(
                "Invalid value for `insufficient_data_health_status` ({0}), must be one of {1}"
                .format(insufficient_data_health_status, allowed_values)
            )

        self._insufficient_data_health_status = insufficient_data_health_status

    @property
    def reset_elements(self):
        """Gets the reset_elements of this UpdateHealthCheckRequest.

        <p>A complex type that contains one <code>ResettableElementName</code> element for each element that you want to reset to the default value. Valid values for <code>ResettableElementName</code> include the following:</p> <ul> <li> <p> <code>ChildHealthChecks</code>: Amazon Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ChildHealthChecks\">ChildHealthChecks</a> to null.</p> </li> <li> <p> <code>FullyQualifiedDomainName</code>: Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\">FullyQualifiedDomainName</a>. to null.</p> </li> <li> <p> <code>Regions</code>: Route 53 resets the <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions\">Regions</a> list to the default set of regions. </p> </li> <li> <p> <code>ResourcePath</code>: Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ResourcePath\">ResourcePath</a> to null.</p> </li> </ul>

        :return: The reset_elements of this UpdateHealthCheckRequest.
        :rtype: List[ResettableElementName]
        """
        return self._reset_elements

    @reset_elements.setter
    def reset_elements(self, reset_elements):
        """Sets the reset_elements of this UpdateHealthCheckRequest.

        <p>A complex type that contains one <code>ResettableElementName</code> element for each element that you want to reset to the default value. Valid values for <code>ResettableElementName</code> include the following:</p> <ul> <li> <p> <code>ChildHealthChecks</code>: Amazon Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ChildHealthChecks\">ChildHealthChecks</a> to null.</p> </li> <li> <p> <code>FullyQualifiedDomainName</code>: Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName\">FullyQualifiedDomainName</a>. to null.</p> </li> <li> <p> <code>Regions</code>: Route 53 resets the <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions\">Regions</a> list to the default set of regions. </p> </li> <li> <p> <code>ResourcePath</code>: Route 53 resets <a href=\"https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ResourcePath\">ResourcePath</a> to null.</p> </li> </ul>

        :param reset_elements: The reset_elements of this UpdateHealthCheckRequest.
        :type reset_elements: List[ResettableElementName]
        """
        if reset_elements is not None and len(reset_elements) > 64:
            raise ValueError("Invalid value for `reset_elements`, number of items must be less than or equal to `64`")

        self._reset_elements = reset_elements
