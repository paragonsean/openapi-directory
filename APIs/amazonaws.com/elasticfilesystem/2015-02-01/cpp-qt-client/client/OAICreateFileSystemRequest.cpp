/**
 * Amazon Elastic File System
 * <fullname>Amazon Elastic File System</fullname> <p>Amazon Elastic File System (Amazon EFS) provides simple, scalable file storage for use with Amazon EC2 Linux and Mac instances in the Amazon Web Services Cloud. With Amazon EFS, storage capacity is elastic, growing and shrinking automatically as you add and remove files, so that your applications have the storage they need, when they need it. For more information, see the <a href=\"https://docs.aws.amazon.com/efs/latest/ug/api-reference.html\">Amazon Elastic File System API Reference</a> and the <a href=\"https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html\">Amazon Elastic File System User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2015-02-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateFileSystemRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateFileSystemRequest::OAICreateFileSystemRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateFileSystemRequest::OAICreateFileSystemRequest() {
    this->initializeModel();
}

OAICreateFileSystemRequest::~OAICreateFileSystemRequest() {}

void OAICreateFileSystemRequest::initializeModel() {

    m_creation_token_isSet = false;
    m_creation_token_isValid = false;

    m_performance_mode_isSet = false;
    m_performance_mode_isValid = false;

    m_encrypted_isSet = false;
    m_encrypted_isValid = false;

    m_kms_key_id_isSet = false;
    m_kms_key_id_isValid = false;

    m_throughput_mode_isSet = false;
    m_throughput_mode_isValid = false;

    m_provisioned_throughput_in_mibps_isSet = false;
    m_provisioned_throughput_in_mibps_isValid = false;

    m_availability_zone_name_isSet = false;
    m_availability_zone_name_isValid = false;

    m_backup_isSet = false;
    m_backup_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAICreateFileSystemRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateFileSystemRequest::fromJsonObject(QJsonObject json) {

    m_creation_token_isValid = ::OpenAPI::fromJsonValue(m_creation_token, json[QString("CreationToken")]);
    m_creation_token_isSet = !json[QString("CreationToken")].isNull() && m_creation_token_isValid;

    m_performance_mode_isValid = ::OpenAPI::fromJsonValue(m_performance_mode, json[QString("PerformanceMode")]);
    m_performance_mode_isSet = !json[QString("PerformanceMode")].isNull() && m_performance_mode_isValid;

    m_encrypted_isValid = ::OpenAPI::fromJsonValue(m_encrypted, json[QString("Encrypted")]);
    m_encrypted_isSet = !json[QString("Encrypted")].isNull() && m_encrypted_isValid;

    m_kms_key_id_isValid = ::OpenAPI::fromJsonValue(m_kms_key_id, json[QString("KmsKeyId")]);
    m_kms_key_id_isSet = !json[QString("KmsKeyId")].isNull() && m_kms_key_id_isValid;

    m_throughput_mode_isValid = ::OpenAPI::fromJsonValue(m_throughput_mode, json[QString("ThroughputMode")]);
    m_throughput_mode_isSet = !json[QString("ThroughputMode")].isNull() && m_throughput_mode_isValid;

    m_provisioned_throughput_in_mibps_isValid = ::OpenAPI::fromJsonValue(m_provisioned_throughput_in_mibps, json[QString("ProvisionedThroughputInMibps")]);
    m_provisioned_throughput_in_mibps_isSet = !json[QString("ProvisionedThroughputInMibps")].isNull() && m_provisioned_throughput_in_mibps_isValid;

    m_availability_zone_name_isValid = ::OpenAPI::fromJsonValue(m_availability_zone_name, json[QString("AvailabilityZoneName")]);
    m_availability_zone_name_isSet = !json[QString("AvailabilityZoneName")].isNull() && m_availability_zone_name_isValid;

    m_backup_isValid = ::OpenAPI::fromJsonValue(m_backup, json[QString("Backup")]);
    m_backup_isSet = !json[QString("Backup")].isNull() && m_backup_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("Tags")]);
    m_tags_isSet = !json[QString("Tags")].isNull() && m_tags_isValid;
}

QString OAICreateFileSystemRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateFileSystemRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_creation_token_isSet) {
        obj.insert(QString("CreationToken"), ::OpenAPI::toJsonValue(m_creation_token));
    }
    if (m_performance_mode.isSet()) {
        obj.insert(QString("PerformanceMode"), ::OpenAPI::toJsonValue(m_performance_mode));
    }
    if (m_encrypted_isSet) {
        obj.insert(QString("Encrypted"), ::OpenAPI::toJsonValue(m_encrypted));
    }
    if (m_kms_key_id_isSet) {
        obj.insert(QString("KmsKeyId"), ::OpenAPI::toJsonValue(m_kms_key_id));
    }
    if (m_throughput_mode.isSet()) {
        obj.insert(QString("ThroughputMode"), ::OpenAPI::toJsonValue(m_throughput_mode));
    }
    if (m_provisioned_throughput_in_mibps_isSet) {
        obj.insert(QString("ProvisionedThroughputInMibps"), ::OpenAPI::toJsonValue(m_provisioned_throughput_in_mibps));
    }
    if (m_availability_zone_name_isSet) {
        obj.insert(QString("AvailabilityZoneName"), ::OpenAPI::toJsonValue(m_availability_zone_name));
    }
    if (m_backup_isSet) {
        obj.insert(QString("Backup"), ::OpenAPI::toJsonValue(m_backup));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("Tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

QString OAICreateFileSystemRequest::getCreationToken() const {
    return m_creation_token;
}
void OAICreateFileSystemRequest::setCreationToken(const QString &creation_token) {
    m_creation_token = creation_token;
    m_creation_token_isSet = true;
}

bool OAICreateFileSystemRequest::is_creation_token_Set() const{
    return m_creation_token_isSet;
}

bool OAICreateFileSystemRequest::is_creation_token_Valid() const{
    return m_creation_token_isValid;
}

OAIPerformanceMode OAICreateFileSystemRequest::getPerformanceMode() const {
    return m_performance_mode;
}
void OAICreateFileSystemRequest::setPerformanceMode(const OAIPerformanceMode &performance_mode) {
    m_performance_mode = performance_mode;
    m_performance_mode_isSet = true;
}

bool OAICreateFileSystemRequest::is_performance_mode_Set() const{
    return m_performance_mode_isSet;
}

bool OAICreateFileSystemRequest::is_performance_mode_Valid() const{
    return m_performance_mode_isValid;
}

bool OAICreateFileSystemRequest::getEncrypted() const {
    return m_encrypted;
}
void OAICreateFileSystemRequest::setEncrypted(const bool &encrypted) {
    m_encrypted = encrypted;
    m_encrypted_isSet = true;
}

bool OAICreateFileSystemRequest::is_encrypted_Set() const{
    return m_encrypted_isSet;
}

bool OAICreateFileSystemRequest::is_encrypted_Valid() const{
    return m_encrypted_isValid;
}

QString OAICreateFileSystemRequest::getKmsKeyId() const {
    return m_kms_key_id;
}
void OAICreateFileSystemRequest::setKmsKeyId(const QString &kms_key_id) {
    m_kms_key_id = kms_key_id;
    m_kms_key_id_isSet = true;
}

bool OAICreateFileSystemRequest::is_kms_key_id_Set() const{
    return m_kms_key_id_isSet;
}

bool OAICreateFileSystemRequest::is_kms_key_id_Valid() const{
    return m_kms_key_id_isValid;
}

OAIThroughputMode OAICreateFileSystemRequest::getThroughputMode() const {
    return m_throughput_mode;
}
void OAICreateFileSystemRequest::setThroughputMode(const OAIThroughputMode &throughput_mode) {
    m_throughput_mode = throughput_mode;
    m_throughput_mode_isSet = true;
}

bool OAICreateFileSystemRequest::is_throughput_mode_Set() const{
    return m_throughput_mode_isSet;
}

bool OAICreateFileSystemRequest::is_throughput_mode_Valid() const{
    return m_throughput_mode_isValid;
}

double OAICreateFileSystemRequest::getProvisionedThroughputInMibps() const {
    return m_provisioned_throughput_in_mibps;
}
void OAICreateFileSystemRequest::setProvisionedThroughputInMibps(const double &provisioned_throughput_in_mibps) {
    m_provisioned_throughput_in_mibps = provisioned_throughput_in_mibps;
    m_provisioned_throughput_in_mibps_isSet = true;
}

bool OAICreateFileSystemRequest::is_provisioned_throughput_in_mibps_Set() const{
    return m_provisioned_throughput_in_mibps_isSet;
}

bool OAICreateFileSystemRequest::is_provisioned_throughput_in_mibps_Valid() const{
    return m_provisioned_throughput_in_mibps_isValid;
}

QString OAICreateFileSystemRequest::getAvailabilityZoneName() const {
    return m_availability_zone_name;
}
void OAICreateFileSystemRequest::setAvailabilityZoneName(const QString &availability_zone_name) {
    m_availability_zone_name = availability_zone_name;
    m_availability_zone_name_isSet = true;
}

bool OAICreateFileSystemRequest::is_availability_zone_name_Set() const{
    return m_availability_zone_name_isSet;
}

bool OAICreateFileSystemRequest::is_availability_zone_name_Valid() const{
    return m_availability_zone_name_isValid;
}

bool OAICreateFileSystemRequest::getBackup() const {
    return m_backup;
}
void OAICreateFileSystemRequest::setBackup(const bool &backup) {
    m_backup = backup;
    m_backup_isSet = true;
}

bool OAICreateFileSystemRequest::is_backup_Set() const{
    return m_backup_isSet;
}

bool OAICreateFileSystemRequest::is_backup_Valid() const{
    return m_backup_isValid;
}

QList OAICreateFileSystemRequest::getTags() const {
    return m_tags;
}
void OAICreateFileSystemRequest::setTags(const QList &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAICreateFileSystemRequest::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAICreateFileSystemRequest::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAICreateFileSystemRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_creation_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_performance_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_encrypted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kms_key_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_throughput_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_provisioned_throughput_in_mibps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_zone_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_backup_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateFileSystemRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_creation_token_isValid && true;
}

} // namespace OpenAPI
