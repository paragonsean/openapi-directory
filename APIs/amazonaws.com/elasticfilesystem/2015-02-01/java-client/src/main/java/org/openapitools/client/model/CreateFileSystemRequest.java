/*
 * Amazon Elastic File System
 * <fullname>Amazon Elastic File System</fullname> <p>Amazon Elastic File System (Amazon EFS) provides simple, scalable file storage for use with Amazon EC2 Linux and Mac instances in the Amazon Web Services Cloud. With Amazon EFS, storage capacity is elastic, growing and shrinking automatically as you add and remove files, so that your applications have the storage they need, when they need it. For more information, see the <a href=\"https://docs.aws.amazon.com/efs/latest/ug/api-reference.html\">Amazon Elastic File System API Reference</a> and the <a href=\"https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html\">Amazon Elastic File System User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2015-02-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Tag;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateFileSystemRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:27.318831-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateFileSystemRequest {
  public static final String SERIALIZED_NAME_CREATION_TOKEN = "CreationToken";
  @SerializedName(SERIALIZED_NAME_CREATION_TOKEN)
  private String creationToken;

  /**
   * &lt;p&gt;The performance mode of the file system. We recommend &lt;code&gt;generalPurpose&lt;/code&gt; performance mode for most file systems. File systems using the &lt;code&gt;maxIO&lt;/code&gt; performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can&#39;t be changed after the file system has been created.&lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;code&gt;maxIO&lt;/code&gt; mode is not supported on file systems using One Zone storage classes.&lt;/p&gt; &lt;/note&gt;
   */
  @JsonAdapter(PerformanceModeEnum.Adapter.class)
  public enum PerformanceModeEnum {
    GENERAL_PURPOSE("generalPurpose"),
    
    MAX_IO("maxIO");

    private String value;

    PerformanceModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PerformanceModeEnum fromValue(String value) {
      for (PerformanceModeEnum b : PerformanceModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PerformanceModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PerformanceModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PerformanceModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PerformanceModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PerformanceModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PERFORMANCE_MODE = "PerformanceMode";
  @SerializedName(SERIALIZED_NAME_PERFORMANCE_MODE)
  private PerformanceModeEnum performanceMode;

  public static final String SERIALIZED_NAME_ENCRYPTED = "Encrypted";
  @SerializedName(SERIALIZED_NAME_ENCRYPTED)
  private Boolean encrypted;

  public static final String SERIALIZED_NAME_KMS_KEY_ID = "KmsKeyId";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_ID)
  private String kmsKeyId;

  /**
   * &lt;p&gt;Specifies the throughput mode for the file system. The mode can be &lt;code&gt;bursting&lt;/code&gt;, &lt;code&gt;provisioned&lt;/code&gt;, or &lt;code&gt;elastic&lt;/code&gt;. If you set &lt;code&gt;ThroughputMode&lt;/code&gt; to &lt;code&gt;provisioned&lt;/code&gt;, you must also set a value for &lt;code&gt;ProvisionedThroughputInMibps&lt;/code&gt;. After you create the file system, you can decrease your file system&#39;s throughput in Provisioned Throughput mode or change between the throughput modes, with certain time restrictions. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput\&quot;&gt;Specifying throughput with provisioned mode&lt;/a&gt; in the &lt;i&gt;Amazon EFS User Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Default is &lt;code&gt;bursting&lt;/code&gt;.&lt;/p&gt;
   */
  @JsonAdapter(ThroughputModeEnum.Adapter.class)
  public enum ThroughputModeEnum {
    BURSTING("bursting"),
    
    PROVISIONED("provisioned"),
    
    ELASTIC("elastic");

    private String value;

    ThroughputModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ThroughputModeEnum fromValue(String value) {
      for (ThroughputModeEnum b : ThroughputModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ThroughputModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ThroughputModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ThroughputModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ThroughputModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ThroughputModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_THROUGHPUT_MODE = "ThroughputMode";
  @SerializedName(SERIALIZED_NAME_THROUGHPUT_MODE)
  private ThroughputModeEnum throughputMode;

  public static final String SERIALIZED_NAME_PROVISIONED_THROUGHPUT_IN_MIBPS = "ProvisionedThroughputInMibps";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_THROUGHPUT_IN_MIBPS)
  private Double provisionedThroughputInMibps;

  public static final String SERIALIZED_NAME_AVAILABILITY_ZONE_NAME = "AvailabilityZoneName";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_ZONE_NAME)
  private String availabilityZoneName;

  public static final String SERIALIZED_NAME_BACKUP = "Backup";
  @SerializedName(SERIALIZED_NAME_BACKUP)
  private Boolean backup;

  public static final String SERIALIZED_NAME_TAGS = "Tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<Tag> tags = new ArrayList<>();

  public CreateFileSystemRequest() {
  }

  public CreateFileSystemRequest creationToken(String creationToken) {
    this.creationToken = creationToken;
    return this;
  }

  /**
   * A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent creation.
   * @return creationToken
   */
  @javax.annotation.Nonnull
  public String getCreationToken() {
    return creationToken;
  }

  public void setCreationToken(String creationToken) {
    this.creationToken = creationToken;
  }


  public CreateFileSystemRequest performanceMode(PerformanceModeEnum performanceMode) {
    this.performanceMode = performanceMode;
    return this;
  }

  /**
   * &lt;p&gt;The performance mode of the file system. We recommend &lt;code&gt;generalPurpose&lt;/code&gt; performance mode for most file systems. File systems using the &lt;code&gt;maxIO&lt;/code&gt; performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can&#39;t be changed after the file system has been created.&lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;code&gt;maxIO&lt;/code&gt; mode is not supported on file systems using One Zone storage classes.&lt;/p&gt; &lt;/note&gt;
   * @return performanceMode
   */
  @javax.annotation.Nullable
  public PerformanceModeEnum getPerformanceMode() {
    return performanceMode;
  }

  public void setPerformanceMode(PerformanceModeEnum performanceMode) {
    this.performanceMode = performanceMode;
  }


  public CreateFileSystemRequest encrypted(Boolean encrypted) {
    this.encrypted = encrypted;
    return this;
  }

  /**
   * A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key). If you don&#39;t specify a KMS key, then the default KMS key for Amazon EFS, &lt;code&gt;/aws/elasticfilesystem&lt;/code&gt;, is used to protect the encrypted file system. 
   * @return encrypted
   */
  @javax.annotation.Nullable
  public Boolean getEncrypted() {
    return encrypted;
  }

  public void setEncrypted(Boolean encrypted) {
    this.encrypted = encrypted;
  }


  public CreateFileSystemRequest kmsKeyId(String kmsKeyId) {
    this.kmsKeyId = kmsKeyId;
    return this;
  }

  /**
   * &lt;p&gt;The ID of the KMS key that you want to use to protect the encrypted file system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following formats:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Key ID - A unique identifier of the key, for example &lt;code&gt;1234abcd-12ab-34cd-56ef-1234567890ab&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ARN - An Amazon Resource Name (ARN) for the key, for example &lt;code&gt;arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Key alias - A previously created display name for a key, for example &lt;code&gt;alias/projectKey1&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Key alias ARN - An ARN for a key alias, for example &lt;code&gt;arn:aws:kms:us-west-2:444455556666:alias/projectKey1&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you use &lt;code&gt;KmsKeyId&lt;/code&gt;, you must set the &lt;a&gt;CreateFileSystemRequest$Encrypted&lt;/a&gt; parameter to true.&lt;/p&gt; &lt;important&gt; &lt;p&gt;EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with Amazon EFS file systems.&lt;/p&gt; &lt;/important&gt;
   * @return kmsKeyId
   */
  @javax.annotation.Nullable
  public String getKmsKeyId() {
    return kmsKeyId;
  }

  public void setKmsKeyId(String kmsKeyId) {
    this.kmsKeyId = kmsKeyId;
  }


  public CreateFileSystemRequest throughputMode(ThroughputModeEnum throughputMode) {
    this.throughputMode = throughputMode;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the throughput mode for the file system. The mode can be &lt;code&gt;bursting&lt;/code&gt;, &lt;code&gt;provisioned&lt;/code&gt;, or &lt;code&gt;elastic&lt;/code&gt;. If you set &lt;code&gt;ThroughputMode&lt;/code&gt; to &lt;code&gt;provisioned&lt;/code&gt;, you must also set a value for &lt;code&gt;ProvisionedThroughputInMibps&lt;/code&gt;. After you create the file system, you can decrease your file system&#39;s throughput in Provisioned Throughput mode or change between the throughput modes, with certain time restrictions. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput\&quot;&gt;Specifying throughput with provisioned mode&lt;/a&gt; in the &lt;i&gt;Amazon EFS User Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Default is &lt;code&gt;bursting&lt;/code&gt;.&lt;/p&gt;
   * @return throughputMode
   */
  @javax.annotation.Nullable
  public ThroughputModeEnum getThroughputMode() {
    return throughputMode;
  }

  public void setThroughputMode(ThroughputModeEnum throughputMode) {
    this.throughputMode = throughputMode;
  }


  public CreateFileSystemRequest provisionedThroughputInMibps(Double provisionedThroughputInMibps) {
    this.provisionedThroughputInMibps = provisionedThroughputInMibps;
    return this;
  }

  /**
   * The throughput, measured in MiB/s, that you want to provision for a file system that you&#39;re creating. Valid values are 1-1024. Required if &lt;code&gt;ThroughputMode&lt;/code&gt; is set to &lt;code&gt;provisioned&lt;/code&gt;. The upper limit for throughput is 1024 MiB/s. To increase this limit, contact Amazon Web Services Support. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits\&quot;&gt;Amazon EFS quotas that you can increase&lt;/a&gt; in the &lt;i&gt;Amazon EFS User Guide&lt;/i&gt;.
   * minimum: 1
   * @return provisionedThroughputInMibps
   */
  @javax.annotation.Nullable
  public Double getProvisionedThroughputInMibps() {
    return provisionedThroughputInMibps;
  }

  public void setProvisionedThroughputInMibps(Double provisionedThroughputInMibps) {
    this.provisionedThroughputInMibps = provisionedThroughputInMibps;
  }


  public CreateFileSystemRequest availabilityZoneName(String availabilityZoneName) {
    this.availabilityZoneName = availabilityZoneName;
    return this;
  }

  /**
   * &lt;p&gt;Used to create a file system that uses One Zone storage classes. It specifies the Amazon Web Services Availability Zone in which to create the file system. Use the format &lt;code&gt;us-east-1a&lt;/code&gt; to specify the Availability Zone. For more information about One Zone storage classes, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html\&quot;&gt;Using EFS storage classes&lt;/a&gt; in the &lt;i&gt;Amazon EFS User Guide&lt;/i&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;One Zone storage classes are not available in all Availability Zones in Amazon Web Services Regions where Amazon EFS is available.&lt;/p&gt; &lt;/note&gt;
   * @return availabilityZoneName
   */
  @javax.annotation.Nullable
  public String getAvailabilityZoneName() {
    return availabilityZoneName;
  }

  public void setAvailabilityZoneName(String availabilityZoneName) {
    this.availabilityZoneName = availabilityZoneName;
  }


  public CreateFileSystemRequest backup(Boolean backup) {
    this.backup = backup;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether automatic backups are enabled on the file system that you are creating. Set the value to &lt;code&gt;true&lt;/code&gt; to enable automatic backups. If you are creating a file system that uses One Zone storage classes, automatic backups are enabled by default. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups\&quot;&gt;Automatic backups&lt;/a&gt; in the &lt;i&gt;Amazon EFS User Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Default is &lt;code&gt;false&lt;/code&gt;. However, if you specify an &lt;code&gt;AvailabilityZoneName&lt;/code&gt;, the default is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.&lt;/p&gt; &lt;/note&gt;
   * @return backup
   */
  @javax.annotation.Nullable
  public Boolean getBackup() {
    return backup;
  }

  public void setBackup(Boolean backup) {
    this.backup = backup;
  }


  public CreateFileSystemRequest tags(List<Tag> tags) {
    this.tags = tags;
    return this;
  }

  public CreateFileSystemRequest addTagsItem(Tag tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a &lt;code&gt;\&quot;Key\&quot;:\&quot;Name\&quot;,\&quot;Value\&quot;:\&quot;{value}\&quot;&lt;/code&gt; key-value pair. Each key must be unique. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html\&quot;&gt;Tagging Amazon Web Services resources&lt;/a&gt; in the &lt;i&gt;Amazon Web Services General Reference Guide&lt;/i&gt;.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateFileSystemRequest createFileSystemRequest = (CreateFileSystemRequest) o;
    return Objects.equals(this.creationToken, createFileSystemRequest.creationToken) &&
        Objects.equals(this.performanceMode, createFileSystemRequest.performanceMode) &&
        Objects.equals(this.encrypted, createFileSystemRequest.encrypted) &&
        Objects.equals(this.kmsKeyId, createFileSystemRequest.kmsKeyId) &&
        Objects.equals(this.throughputMode, createFileSystemRequest.throughputMode) &&
        Objects.equals(this.provisionedThroughputInMibps, createFileSystemRequest.provisionedThroughputInMibps) &&
        Objects.equals(this.availabilityZoneName, createFileSystemRequest.availabilityZoneName) &&
        Objects.equals(this.backup, createFileSystemRequest.backup) &&
        Objects.equals(this.tags, createFileSystemRequest.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(creationToken, performanceMode, encrypted, kmsKeyId, throughputMode, provisionedThroughputInMibps, availabilityZoneName, backup, tags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateFileSystemRequest {\n");
    sb.append("    creationToken: ").append(toIndentedString(creationToken)).append("\n");
    sb.append("    performanceMode: ").append(toIndentedString(performanceMode)).append("\n");
    sb.append("    encrypted: ").append(toIndentedString(encrypted)).append("\n");
    sb.append("    kmsKeyId: ").append(toIndentedString(kmsKeyId)).append("\n");
    sb.append("    throughputMode: ").append(toIndentedString(throughputMode)).append("\n");
    sb.append("    provisionedThroughputInMibps: ").append(toIndentedString(provisionedThroughputInMibps)).append("\n");
    sb.append("    availabilityZoneName: ").append(toIndentedString(availabilityZoneName)).append("\n");
    sb.append("    backup: ").append(toIndentedString(backup)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("CreationToken");
    openapiFields.add("PerformanceMode");
    openapiFields.add("Encrypted");
    openapiFields.add("KmsKeyId");
    openapiFields.add("ThroughputMode");
    openapiFields.add("ProvisionedThroughputInMibps");
    openapiFields.add("AvailabilityZoneName");
    openapiFields.add("Backup");
    openapiFields.add("Tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("CreationToken");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateFileSystemRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateFileSystemRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateFileSystemRequest is not found in the empty JSON string", CreateFileSystemRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateFileSystemRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateFileSystemRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateFileSystemRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("CreationToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CreationToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CreationToken").toString()));
      }
      if ((jsonObj.get("PerformanceMode") != null && !jsonObj.get("PerformanceMode").isJsonNull()) && !jsonObj.get("PerformanceMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PerformanceMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PerformanceMode").toString()));
      }
      // validate the optional field `PerformanceMode`
      if (jsonObj.get("PerformanceMode") != null && !jsonObj.get("PerformanceMode").isJsonNull()) {
        PerformanceModeEnum.validateJsonElement(jsonObj.get("PerformanceMode"));
      }
      if ((jsonObj.get("KmsKeyId") != null && !jsonObj.get("KmsKeyId").isJsonNull()) && !jsonObj.get("KmsKeyId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `KmsKeyId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("KmsKeyId").toString()));
      }
      if ((jsonObj.get("ThroughputMode") != null && !jsonObj.get("ThroughputMode").isJsonNull()) && !jsonObj.get("ThroughputMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ThroughputMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ThroughputMode").toString()));
      }
      // validate the optional field `ThroughputMode`
      if (jsonObj.get("ThroughputMode") != null && !jsonObj.get("ThroughputMode").isJsonNull()) {
        ThroughputModeEnum.validateJsonElement(jsonObj.get("ThroughputMode"));
      }
      if ((jsonObj.get("AvailabilityZoneName") != null && !jsonObj.get("AvailabilityZoneName").isJsonNull()) && !jsonObj.get("AvailabilityZoneName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `AvailabilityZoneName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("AvailabilityZoneName").toString()));
      }
      if (jsonObj.get("Tags") != null && !jsonObj.get("Tags").isJsonNull()) {
        JsonArray jsonArraytags = jsonObj.getAsJsonArray("Tags");
        if (jsonArraytags != null) {
          // ensure the json data is an array
          if (!jsonObj.get("Tags").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `Tags` to be an array in the JSON string but got `%s`", jsonObj.get("Tags").toString()));
          }

          // validate the optional field `Tags` (array)
          for (int i = 0; i < jsonArraytags.size(); i++) {
            Tag.validateJsonElement(jsonArraytags.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateFileSystemRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateFileSystemRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateFileSystemRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateFileSystemRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateFileSystemRequest>() {
           @Override
           public void write(JsonWriter out, CreateFileSystemRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateFileSystemRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateFileSystemRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateFileSystemRequest
   * @throws IOException if the JSON string is invalid with respect to CreateFileSystemRequest
   */
  public static CreateFileSystemRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateFileSystemRequest.class);
  }

  /**
   * Convert an instance of CreateFileSystemRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

