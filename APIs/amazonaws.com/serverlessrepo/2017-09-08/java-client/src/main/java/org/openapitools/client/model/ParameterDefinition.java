/*
 * AWSServerlessApplicationRepository
 * <p>The AWS Serverless Application Repository makes it easy for developers and enterprises to quickly find  and deploy serverless applications in the AWS Cloud. For more information about serverless applications,  see Serverless Computing and Applications on the AWS website.</p><p>The AWS Serverless Application Repository is deeply integrated with the AWS Lambda console, so that developers of   all levels can get started with serverless computing without needing to learn anything new. You can use category   keywords to browse for applications such as web and mobile backends, data processing applications, or chatbots.   You can also search for applications by name, publisher, or event source. To use an application, you simply choose it,   configure any required fields, and deploy it with a few clicks. </p><p>You can also easily publish applications, sharing them publicly with the community at large, or privately  within your team or across your organization. To publish a serverless application (or app), you can use the  AWS Management Console, AWS Command Line Interface (AWS CLI), or AWS SDKs to upload the code. Along with the  code, you upload a simple manifest file, also known as the AWS Serverless Application Model (AWS SAM) template.  For more information about AWS SAM, see AWS Serverless Application Model (AWS SAM) on the AWS Labs  GitHub repository.</p><p>The AWS Serverless Application Repository Developer Guide contains more information about the two developer  experiences available:</p><ul>  <li>  <p>Consuming Applications – Browse for applications and view information about them, including  source code and readme files. Also install, configure, and deploy applications of your choosing. </p>  <p>Publishing Applications – Configure and upload applications to make them available to other  developers, and publish new versions of applications. </p>  </li>  </ul>
 *
 * The version of the OpenAPI document: 2017-09-08
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters supported by the application.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:07:44.517434-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ParameterDefinition {
  public static final String SERIALIZED_NAME_ALLOWED_PATTERN = "AllowedPattern";
  @SerializedName(SERIALIZED_NAME_ALLOWED_PATTERN)
  private String allowedPattern;

  public static final String SERIALIZED_NAME_ALLOWED_VALUES = "AllowedValues";
  @SerializedName(SERIALIZED_NAME_ALLOWED_VALUES)
  private List allowedValues;

  public static final String SERIALIZED_NAME_CONSTRAINT_DESCRIPTION = "ConstraintDescription";
  @SerializedName(SERIALIZED_NAME_CONSTRAINT_DESCRIPTION)
  private String constraintDescription;

  public static final String SERIALIZED_NAME_DEFAULT_VALUE = "DefaultValue";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VALUE)
  private String defaultValue;

  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_MAX_LENGTH = "MaxLength";
  @SerializedName(SERIALIZED_NAME_MAX_LENGTH)
  private Integer maxLength;

  public static final String SERIALIZED_NAME_MAX_VALUE = "MaxValue";
  @SerializedName(SERIALIZED_NAME_MAX_VALUE)
  private Integer maxValue;

  public static final String SERIALIZED_NAME_MIN_LENGTH = "MinLength";
  @SerializedName(SERIALIZED_NAME_MIN_LENGTH)
  private Integer minLength;

  public static final String SERIALIZED_NAME_MIN_VALUE = "MinValue";
  @SerializedName(SERIALIZED_NAME_MIN_VALUE)
  private Integer minValue;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NO_ECHO = "NoEcho";
  @SerializedName(SERIALIZED_NAME_NO_ECHO)
  private Boolean noEcho;

  public static final String SERIALIZED_NAME_REFERENCED_BY_RESOURCES = "ReferencedByResources";
  @SerializedName(SERIALIZED_NAME_REFERENCED_BY_RESOURCES)
  private List referencedByResources;

  public static final String SERIALIZED_NAME_TYPE = "Type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public ParameterDefinition() {
  }

  public ParameterDefinition allowedPattern(String allowedPattern) {
    this.allowedPattern = allowedPattern;
    return this;
  }

  /**
   * Get allowedPattern
   * @return allowedPattern
   */
  @javax.annotation.Nullable
  public String getAllowedPattern() {
    return allowedPattern;
  }

  public void setAllowedPattern(String allowedPattern) {
    this.allowedPattern = allowedPattern;
  }


  public ParameterDefinition allowedValues(List allowedValues) {
    this.allowedValues = allowedValues;
    return this;
  }

  /**
   * Get allowedValues
   * @return allowedValues
   */
  @javax.annotation.Nullable
  public List getAllowedValues() {
    return allowedValues;
  }

  public void setAllowedValues(List allowedValues) {
    this.allowedValues = allowedValues;
  }


  public ParameterDefinition constraintDescription(String constraintDescription) {
    this.constraintDescription = constraintDescription;
    return this;
  }

  /**
   * Get constraintDescription
   * @return constraintDescription
   */
  @javax.annotation.Nullable
  public String getConstraintDescription() {
    return constraintDescription;
  }

  public void setConstraintDescription(String constraintDescription) {
    this.constraintDescription = constraintDescription;
  }


  public ParameterDefinition defaultValue(String defaultValue) {
    this.defaultValue = defaultValue;
    return this;
  }

  /**
   * Get defaultValue
   * @return defaultValue
   */
  @javax.annotation.Nullable
  public String getDefaultValue() {
    return defaultValue;
  }

  public void setDefaultValue(String defaultValue) {
    this.defaultValue = defaultValue;
  }


  public ParameterDefinition description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ParameterDefinition maxLength(Integer maxLength) {
    this.maxLength = maxLength;
    return this;
  }

  /**
   * Get maxLength
   * @return maxLength
   */
  @javax.annotation.Nullable
  public Integer getMaxLength() {
    return maxLength;
  }

  public void setMaxLength(Integer maxLength) {
    this.maxLength = maxLength;
  }


  public ParameterDefinition maxValue(Integer maxValue) {
    this.maxValue = maxValue;
    return this;
  }

  /**
   * Get maxValue
   * @return maxValue
   */
  @javax.annotation.Nullable
  public Integer getMaxValue() {
    return maxValue;
  }

  public void setMaxValue(Integer maxValue) {
    this.maxValue = maxValue;
  }


  public ParameterDefinition minLength(Integer minLength) {
    this.minLength = minLength;
    return this;
  }

  /**
   * Get minLength
   * @return minLength
   */
  @javax.annotation.Nullable
  public Integer getMinLength() {
    return minLength;
  }

  public void setMinLength(Integer minLength) {
    this.minLength = minLength;
  }


  public ParameterDefinition minValue(Integer minValue) {
    this.minValue = minValue;
    return this;
  }

  /**
   * Get minValue
   * @return minValue
   */
  @javax.annotation.Nullable
  public Integer getMinValue() {
    return minValue;
  }

  public void setMinValue(Integer minValue) {
    this.minValue = minValue;
  }


  public ParameterDefinition name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ParameterDefinition noEcho(Boolean noEcho) {
    this.noEcho = noEcho;
    return this;
  }

  /**
   * Get noEcho
   * @return noEcho
   */
  @javax.annotation.Nullable
  public Boolean getNoEcho() {
    return noEcho;
  }

  public void setNoEcho(Boolean noEcho) {
    this.noEcho = noEcho;
  }


  public ParameterDefinition referencedByResources(List referencedByResources) {
    this.referencedByResources = referencedByResources;
    return this;
  }

  /**
   * Get referencedByResources
   * @return referencedByResources
   */
  @javax.annotation.Nonnull
  public List getReferencedByResources() {
    return referencedByResources;
  }

  public void setReferencedByResources(List referencedByResources) {
    this.referencedByResources = referencedByResources;
  }


  public ParameterDefinition type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ParameterDefinition parameterDefinition = (ParameterDefinition) o;
    return Objects.equals(this.allowedPattern, parameterDefinition.allowedPattern) &&
        Objects.equals(this.allowedValues, parameterDefinition.allowedValues) &&
        Objects.equals(this.constraintDescription, parameterDefinition.constraintDescription) &&
        Objects.equals(this.defaultValue, parameterDefinition.defaultValue) &&
        Objects.equals(this.description, parameterDefinition.description) &&
        Objects.equals(this.maxLength, parameterDefinition.maxLength) &&
        Objects.equals(this.maxValue, parameterDefinition.maxValue) &&
        Objects.equals(this.minLength, parameterDefinition.minLength) &&
        Objects.equals(this.minValue, parameterDefinition.minValue) &&
        Objects.equals(this.name, parameterDefinition.name) &&
        Objects.equals(this.noEcho, parameterDefinition.noEcho) &&
        Objects.equals(this.referencedByResources, parameterDefinition.referencedByResources) &&
        Objects.equals(this.type, parameterDefinition.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowedPattern, allowedValues, constraintDescription, defaultValue, description, maxLength, maxValue, minLength, minValue, name, noEcho, referencedByResources, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ParameterDefinition {\n");
    sb.append("    allowedPattern: ").append(toIndentedString(allowedPattern)).append("\n");
    sb.append("    allowedValues: ").append(toIndentedString(allowedValues)).append("\n");
    sb.append("    constraintDescription: ").append(toIndentedString(constraintDescription)).append("\n");
    sb.append("    defaultValue: ").append(toIndentedString(defaultValue)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    maxLength: ").append(toIndentedString(maxLength)).append("\n");
    sb.append("    maxValue: ").append(toIndentedString(maxValue)).append("\n");
    sb.append("    minLength: ").append(toIndentedString(minLength)).append("\n");
    sb.append("    minValue: ").append(toIndentedString(minValue)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    noEcho: ").append(toIndentedString(noEcho)).append("\n");
    sb.append("    referencedByResources: ").append(toIndentedString(referencedByResources)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AllowedPattern");
    openapiFields.add("AllowedValues");
    openapiFields.add("ConstraintDescription");
    openapiFields.add("DefaultValue");
    openapiFields.add("Description");
    openapiFields.add("MaxLength");
    openapiFields.add("MaxValue");
    openapiFields.add("MinLength");
    openapiFields.add("MinValue");
    openapiFields.add("Name");
    openapiFields.add("NoEcho");
    openapiFields.add("ReferencedByResources");
    openapiFields.add("Type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Name");
    openapiRequiredFields.add("ReferencedByResources");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ParameterDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ParameterDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ParameterDefinition is not found in the empty JSON string", ParameterDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ParameterDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ParameterDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ParameterDefinition.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AllowedPattern`
      if (jsonObj.get("AllowedPattern") != null && !jsonObj.get("AllowedPattern").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AllowedPattern"));
      }
      // validate the optional field `AllowedValues`
      if (jsonObj.get("AllowedValues") != null && !jsonObj.get("AllowedValues").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("AllowedValues"));
      }
      // validate the optional field `ConstraintDescription`
      if (jsonObj.get("ConstraintDescription") != null && !jsonObj.get("ConstraintDescription").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("ConstraintDescription"));
      }
      // validate the optional field `DefaultValue`
      if (jsonObj.get("DefaultValue") != null && !jsonObj.get("DefaultValue").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("DefaultValue"));
      }
      // validate the optional field `Description`
      if (jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Description"));
      }
      // validate the optional field `MaxLength`
      if (jsonObj.get("MaxLength") != null && !jsonObj.get("MaxLength").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxLength"));
      }
      // validate the optional field `MaxValue`
      if (jsonObj.get("MaxValue") != null && !jsonObj.get("MaxValue").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxValue"));
      }
      // validate the optional field `MinLength`
      if (jsonObj.get("MinLength") != null && !jsonObj.get("MinLength").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinLength"));
      }
      // validate the optional field `MinValue`
      if (jsonObj.get("MinValue") != null && !jsonObj.get("MinValue").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinValue"));
      }
      // validate the required field `Name`
      String.validateJsonElement(jsonObj.get("Name"));
      // validate the optional field `NoEcho`
      if (jsonObj.get("NoEcho") != null && !jsonObj.get("NoEcho").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("NoEcho"));
      }
      // validate the required field `ReferencedByResources`
      List.validateJsonElement(jsonObj.get("ReferencedByResources"));
      // validate the optional field `Type`
      if (jsonObj.get("Type") != null && !jsonObj.get("Type").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ParameterDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ParameterDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ParameterDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ParameterDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<ParameterDefinition>() {
           @Override
           public void write(JsonWriter out, ParameterDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ParameterDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ParameterDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ParameterDefinition
   * @throws IOException if the JSON string is invalid with respect to ParameterDefinition
   */
  public static ParameterDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ParameterDefinition.class);
  }

  /**
   * Convert an instance of ParameterDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

