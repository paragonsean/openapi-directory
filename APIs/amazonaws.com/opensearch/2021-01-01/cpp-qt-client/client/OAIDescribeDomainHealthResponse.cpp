/**
 * Amazon OpenSearch Service
 * <p>Use the Amazon OpenSearch Service configuration API to create, configure, and manage OpenSearch Service domains.</p> <p>For sample code that uses the configuration API, see the <a href=\"https://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-configuration-samples.html\"> <i>Amazon OpenSearch Service Developer Guide</i> </a>. The guide also contains <a href=\"https://docs.aws.amazon.com/opensearch-service/latest/developerguide/request-signing.html\">sample code</a> for sending signed HTTP requests to the OpenSearch APIs. The endpoint for configuration service requests is Region specific: es.<i>region</i>.amazonaws.com. For example, es.us-east-1.amazonaws.com. For a current list of supported Regions and endpoints, see <a href=\"https://docs.aws.amazon.com/general/latest/gr/rande.html#service-regions\">Amazon Web Services service endpoints</a>.</p>
 *
 * The version of the OpenAPI document: 2021-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDescribeDomainHealthResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDescribeDomainHealthResponse::OAIDescribeDomainHealthResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDescribeDomainHealthResponse::OAIDescribeDomainHealthResponse() {
    this->initializeModel();
}

OAIDescribeDomainHealthResponse::~OAIDescribeDomainHealthResponse() {}

void OAIDescribeDomainHealthResponse::initializeModel() {

    m_domain_state_isSet = false;
    m_domain_state_isValid = false;

    m_availability_zone_count_isSet = false;
    m_availability_zone_count_isValid = false;

    m_active_availability_zone_count_isSet = false;
    m_active_availability_zone_count_isValid = false;

    m_stand_by_availability_zone_count_isSet = false;
    m_stand_by_availability_zone_count_isValid = false;

    m_data_node_count_isSet = false;
    m_data_node_count_isValid = false;

    m_dedicated_master_isSet = false;
    m_dedicated_master_isValid = false;

    m_master_eligible_node_count_isSet = false;
    m_master_eligible_node_count_isValid = false;

    m_warm_node_count_isSet = false;
    m_warm_node_count_isValid = false;

    m_master_node_isSet = false;
    m_master_node_isValid = false;

    m_cluster_health_isSet = false;
    m_cluster_health_isValid = false;

    m_total_shards_isSet = false;
    m_total_shards_isValid = false;

    m_total_un_assigned_shards_isSet = false;
    m_total_un_assigned_shards_isValid = false;

    m_environment_information_isSet = false;
    m_environment_information_isValid = false;
}

void OAIDescribeDomainHealthResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDescribeDomainHealthResponse::fromJsonObject(QJsonObject json) {

    m_domain_state_isValid = ::OpenAPI::fromJsonValue(m_domain_state, json[QString("DomainState")]);
    m_domain_state_isSet = !json[QString("DomainState")].isNull() && m_domain_state_isValid;

    m_availability_zone_count_isValid = ::OpenAPI::fromJsonValue(m_availability_zone_count, json[QString("AvailabilityZoneCount")]);
    m_availability_zone_count_isSet = !json[QString("AvailabilityZoneCount")].isNull() && m_availability_zone_count_isValid;

    m_active_availability_zone_count_isValid = ::OpenAPI::fromJsonValue(m_active_availability_zone_count, json[QString("ActiveAvailabilityZoneCount")]);
    m_active_availability_zone_count_isSet = !json[QString("ActiveAvailabilityZoneCount")].isNull() && m_active_availability_zone_count_isValid;

    m_stand_by_availability_zone_count_isValid = ::OpenAPI::fromJsonValue(m_stand_by_availability_zone_count, json[QString("StandByAvailabilityZoneCount")]);
    m_stand_by_availability_zone_count_isSet = !json[QString("StandByAvailabilityZoneCount")].isNull() && m_stand_by_availability_zone_count_isValid;

    m_data_node_count_isValid = ::OpenAPI::fromJsonValue(m_data_node_count, json[QString("DataNodeCount")]);
    m_data_node_count_isSet = !json[QString("DataNodeCount")].isNull() && m_data_node_count_isValid;

    m_dedicated_master_isValid = ::OpenAPI::fromJsonValue(m_dedicated_master, json[QString("DedicatedMaster")]);
    m_dedicated_master_isSet = !json[QString("DedicatedMaster")].isNull() && m_dedicated_master_isValid;

    m_master_eligible_node_count_isValid = ::OpenAPI::fromJsonValue(m_master_eligible_node_count, json[QString("MasterEligibleNodeCount")]);
    m_master_eligible_node_count_isSet = !json[QString("MasterEligibleNodeCount")].isNull() && m_master_eligible_node_count_isValid;

    m_warm_node_count_isValid = ::OpenAPI::fromJsonValue(m_warm_node_count, json[QString("WarmNodeCount")]);
    m_warm_node_count_isSet = !json[QString("WarmNodeCount")].isNull() && m_warm_node_count_isValid;

    m_master_node_isValid = ::OpenAPI::fromJsonValue(m_master_node, json[QString("MasterNode")]);
    m_master_node_isSet = !json[QString("MasterNode")].isNull() && m_master_node_isValid;

    m_cluster_health_isValid = ::OpenAPI::fromJsonValue(m_cluster_health, json[QString("ClusterHealth")]);
    m_cluster_health_isSet = !json[QString("ClusterHealth")].isNull() && m_cluster_health_isValid;

    m_total_shards_isValid = ::OpenAPI::fromJsonValue(m_total_shards, json[QString("TotalShards")]);
    m_total_shards_isSet = !json[QString("TotalShards")].isNull() && m_total_shards_isValid;

    m_total_un_assigned_shards_isValid = ::OpenAPI::fromJsonValue(m_total_un_assigned_shards, json[QString("TotalUnAssignedShards")]);
    m_total_un_assigned_shards_isSet = !json[QString("TotalUnAssignedShards")].isNull() && m_total_un_assigned_shards_isValid;

    m_environment_information_isValid = ::OpenAPI::fromJsonValue(m_environment_information, json[QString("EnvironmentInformation")]);
    m_environment_information_isSet = !json[QString("EnvironmentInformation")].isNull() && m_environment_information_isValid;
}

QString OAIDescribeDomainHealthResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDescribeDomainHealthResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_domain_state.isSet()) {
        obj.insert(QString("DomainState"), ::OpenAPI::toJsonValue(m_domain_state));
    }
    if (m_availability_zone_count_isSet) {
        obj.insert(QString("AvailabilityZoneCount"), ::OpenAPI::toJsonValue(m_availability_zone_count));
    }
    if (m_active_availability_zone_count_isSet) {
        obj.insert(QString("ActiveAvailabilityZoneCount"), ::OpenAPI::toJsonValue(m_active_availability_zone_count));
    }
    if (m_stand_by_availability_zone_count_isSet) {
        obj.insert(QString("StandByAvailabilityZoneCount"), ::OpenAPI::toJsonValue(m_stand_by_availability_zone_count));
    }
    if (m_data_node_count_isSet) {
        obj.insert(QString("DataNodeCount"), ::OpenAPI::toJsonValue(m_data_node_count));
    }
    if (m_dedicated_master_isSet) {
        obj.insert(QString("DedicatedMaster"), ::OpenAPI::toJsonValue(m_dedicated_master));
    }
    if (m_master_eligible_node_count_isSet) {
        obj.insert(QString("MasterEligibleNodeCount"), ::OpenAPI::toJsonValue(m_master_eligible_node_count));
    }
    if (m_warm_node_count_isSet) {
        obj.insert(QString("WarmNodeCount"), ::OpenAPI::toJsonValue(m_warm_node_count));
    }
    if (m_master_node.isSet()) {
        obj.insert(QString("MasterNode"), ::OpenAPI::toJsonValue(m_master_node));
    }
    if (m_cluster_health.isSet()) {
        obj.insert(QString("ClusterHealth"), ::OpenAPI::toJsonValue(m_cluster_health));
    }
    if (m_total_shards_isSet) {
        obj.insert(QString("TotalShards"), ::OpenAPI::toJsonValue(m_total_shards));
    }
    if (m_total_un_assigned_shards_isSet) {
        obj.insert(QString("TotalUnAssignedShards"), ::OpenAPI::toJsonValue(m_total_un_assigned_shards));
    }
    if (m_environment_information.isSet()) {
        obj.insert(QString("EnvironmentInformation"), ::OpenAPI::toJsonValue(m_environment_information));
    }
    return obj;
}

OAIDomainState OAIDescribeDomainHealthResponse::getDomainState() const {
    return m_domain_state;
}
void OAIDescribeDomainHealthResponse::setDomainState(const OAIDomainState &domain_state) {
    m_domain_state = domain_state;
    m_domain_state_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_domain_state_Set() const{
    return m_domain_state_isSet;
}

bool OAIDescribeDomainHealthResponse::is_domain_state_Valid() const{
    return m_domain_state_isValid;
}

QString OAIDescribeDomainHealthResponse::getAvailabilityZoneCount() const {
    return m_availability_zone_count;
}
void OAIDescribeDomainHealthResponse::setAvailabilityZoneCount(const QString &availability_zone_count) {
    m_availability_zone_count = availability_zone_count;
    m_availability_zone_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_availability_zone_count_Set() const{
    return m_availability_zone_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_availability_zone_count_Valid() const{
    return m_availability_zone_count_isValid;
}

QString OAIDescribeDomainHealthResponse::getActiveAvailabilityZoneCount() const {
    return m_active_availability_zone_count;
}
void OAIDescribeDomainHealthResponse::setActiveAvailabilityZoneCount(const QString &active_availability_zone_count) {
    m_active_availability_zone_count = active_availability_zone_count;
    m_active_availability_zone_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_active_availability_zone_count_Set() const{
    return m_active_availability_zone_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_active_availability_zone_count_Valid() const{
    return m_active_availability_zone_count_isValid;
}

QString OAIDescribeDomainHealthResponse::getStandByAvailabilityZoneCount() const {
    return m_stand_by_availability_zone_count;
}
void OAIDescribeDomainHealthResponse::setStandByAvailabilityZoneCount(const QString &stand_by_availability_zone_count) {
    m_stand_by_availability_zone_count = stand_by_availability_zone_count;
    m_stand_by_availability_zone_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_stand_by_availability_zone_count_Set() const{
    return m_stand_by_availability_zone_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_stand_by_availability_zone_count_Valid() const{
    return m_stand_by_availability_zone_count_isValid;
}

QString OAIDescribeDomainHealthResponse::getDataNodeCount() const {
    return m_data_node_count;
}
void OAIDescribeDomainHealthResponse::setDataNodeCount(const QString &data_node_count) {
    m_data_node_count = data_node_count;
    m_data_node_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_data_node_count_Set() const{
    return m_data_node_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_data_node_count_Valid() const{
    return m_data_node_count_isValid;
}

bool OAIDescribeDomainHealthResponse::getDedicatedMaster() const {
    return m_dedicated_master;
}
void OAIDescribeDomainHealthResponse::setDedicatedMaster(const bool &dedicated_master) {
    m_dedicated_master = dedicated_master;
    m_dedicated_master_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_dedicated_master_Set() const{
    return m_dedicated_master_isSet;
}

bool OAIDescribeDomainHealthResponse::is_dedicated_master_Valid() const{
    return m_dedicated_master_isValid;
}

QString OAIDescribeDomainHealthResponse::getMasterEligibleNodeCount() const {
    return m_master_eligible_node_count;
}
void OAIDescribeDomainHealthResponse::setMasterEligibleNodeCount(const QString &master_eligible_node_count) {
    m_master_eligible_node_count = master_eligible_node_count;
    m_master_eligible_node_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_master_eligible_node_count_Set() const{
    return m_master_eligible_node_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_master_eligible_node_count_Valid() const{
    return m_master_eligible_node_count_isValid;
}

QString OAIDescribeDomainHealthResponse::getWarmNodeCount() const {
    return m_warm_node_count;
}
void OAIDescribeDomainHealthResponse::setWarmNodeCount(const QString &warm_node_count) {
    m_warm_node_count = warm_node_count;
    m_warm_node_count_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_warm_node_count_Set() const{
    return m_warm_node_count_isSet;
}

bool OAIDescribeDomainHealthResponse::is_warm_node_count_Valid() const{
    return m_warm_node_count_isValid;
}

OAIMasterNodeStatus OAIDescribeDomainHealthResponse::getMasterNode() const {
    return m_master_node;
}
void OAIDescribeDomainHealthResponse::setMasterNode(const OAIMasterNodeStatus &master_node) {
    m_master_node = master_node;
    m_master_node_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_master_node_Set() const{
    return m_master_node_isSet;
}

bool OAIDescribeDomainHealthResponse::is_master_node_Valid() const{
    return m_master_node_isValid;
}

OAIDomainHealth OAIDescribeDomainHealthResponse::getClusterHealth() const {
    return m_cluster_health;
}
void OAIDescribeDomainHealthResponse::setClusterHealth(const OAIDomainHealth &cluster_health) {
    m_cluster_health = cluster_health;
    m_cluster_health_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_cluster_health_Set() const{
    return m_cluster_health_isSet;
}

bool OAIDescribeDomainHealthResponse::is_cluster_health_Valid() const{
    return m_cluster_health_isValid;
}

QString OAIDescribeDomainHealthResponse::getTotalShards() const {
    return m_total_shards;
}
void OAIDescribeDomainHealthResponse::setTotalShards(const QString &total_shards) {
    m_total_shards = total_shards;
    m_total_shards_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_total_shards_Set() const{
    return m_total_shards_isSet;
}

bool OAIDescribeDomainHealthResponse::is_total_shards_Valid() const{
    return m_total_shards_isValid;
}

QString OAIDescribeDomainHealthResponse::getTotalUnAssignedShards() const {
    return m_total_un_assigned_shards;
}
void OAIDescribeDomainHealthResponse::setTotalUnAssignedShards(const QString &total_un_assigned_shards) {
    m_total_un_assigned_shards = total_un_assigned_shards;
    m_total_un_assigned_shards_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_total_un_assigned_shards_Set() const{
    return m_total_un_assigned_shards_isSet;
}

bool OAIDescribeDomainHealthResponse::is_total_un_assigned_shards_Valid() const{
    return m_total_un_assigned_shards_isValid;
}

QList OAIDescribeDomainHealthResponse::getEnvironmentInformation() const {
    return m_environment_information;
}
void OAIDescribeDomainHealthResponse::setEnvironmentInformation(const QList &environment_information) {
    m_environment_information = environment_information;
    m_environment_information_isSet = true;
}

bool OAIDescribeDomainHealthResponse::is_environment_information_Set() const{
    return m_environment_information_isSet;
}

bool OAIDescribeDomainHealthResponse::is_environment_information_Valid() const{
    return m_environment_information_isValid;
}

bool OAIDescribeDomainHealthResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_domain_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_zone_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_active_availability_zone_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stand_by_availability_zone_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dedicated_master_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_master_eligible_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_warm_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_master_node.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_health.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_shards_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_un_assigned_shards_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_environment_information.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDescribeDomainHealthResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
