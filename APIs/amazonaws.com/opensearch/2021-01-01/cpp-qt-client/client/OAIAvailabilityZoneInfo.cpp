/**
 * Amazon OpenSearch Service
 * <p>Use the Amazon OpenSearch Service configuration API to create, configure, and manage OpenSearch Service domains.</p> <p>For sample code that uses the configuration API, see the <a href=\"https://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-configuration-samples.html\"> <i>Amazon OpenSearch Service Developer Guide</i> </a>. The guide also contains <a href=\"https://docs.aws.amazon.com/opensearch-service/latest/developerguide/request-signing.html\">sample code</a> for sending signed HTTP requests to the OpenSearch APIs. The endpoint for configuration service requests is Region specific: es.<i>region</i>.amazonaws.com. For example, es.us-east-1.amazonaws.com. For a current list of supported Regions and endpoints, see <a href=\"https://docs.aws.amazon.com/general/latest/gr/rande.html#service-regions\">Amazon Web Services service endpoints</a>.</p>
 *
 * The version of the OpenAPI document: 2021-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAvailabilityZoneInfo.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAvailabilityZoneInfo::OAIAvailabilityZoneInfo(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAvailabilityZoneInfo::OAIAvailabilityZoneInfo() {
    this->initializeModel();
}

OAIAvailabilityZoneInfo::~OAIAvailabilityZoneInfo() {}

void OAIAvailabilityZoneInfo::initializeModel() {

    m_availability_zone_name_isSet = false;
    m_availability_zone_name_isValid = false;

    m_zone_status_isSet = false;
    m_zone_status_isValid = false;

    m_configured_data_node_count_isSet = false;
    m_configured_data_node_count_isValid = false;

    m_available_data_node_count_isSet = false;
    m_available_data_node_count_isValid = false;

    m_total_shards_isSet = false;
    m_total_shards_isValid = false;

    m_total_un_assigned_shards_isSet = false;
    m_total_un_assigned_shards_isValid = false;
}

void OAIAvailabilityZoneInfo::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAvailabilityZoneInfo::fromJsonObject(QJsonObject json) {

    m_availability_zone_name_isValid = ::OpenAPI::fromJsonValue(m_availability_zone_name, json[QString("AvailabilityZoneName")]);
    m_availability_zone_name_isSet = !json[QString("AvailabilityZoneName")].isNull() && m_availability_zone_name_isValid;

    m_zone_status_isValid = ::OpenAPI::fromJsonValue(m_zone_status, json[QString("ZoneStatus")]);
    m_zone_status_isSet = !json[QString("ZoneStatus")].isNull() && m_zone_status_isValid;

    m_configured_data_node_count_isValid = ::OpenAPI::fromJsonValue(m_configured_data_node_count, json[QString("ConfiguredDataNodeCount")]);
    m_configured_data_node_count_isSet = !json[QString("ConfiguredDataNodeCount")].isNull() && m_configured_data_node_count_isValid;

    m_available_data_node_count_isValid = ::OpenAPI::fromJsonValue(m_available_data_node_count, json[QString("AvailableDataNodeCount")]);
    m_available_data_node_count_isSet = !json[QString("AvailableDataNodeCount")].isNull() && m_available_data_node_count_isValid;

    m_total_shards_isValid = ::OpenAPI::fromJsonValue(m_total_shards, json[QString("TotalShards")]);
    m_total_shards_isSet = !json[QString("TotalShards")].isNull() && m_total_shards_isValid;

    m_total_un_assigned_shards_isValid = ::OpenAPI::fromJsonValue(m_total_un_assigned_shards, json[QString("TotalUnAssignedShards")]);
    m_total_un_assigned_shards_isSet = !json[QString("TotalUnAssignedShards")].isNull() && m_total_un_assigned_shards_isValid;
}

QString OAIAvailabilityZoneInfo::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAvailabilityZoneInfo::asJsonObject() const {
    QJsonObject obj;
    if (m_availability_zone_name_isSet) {
        obj.insert(QString("AvailabilityZoneName"), ::OpenAPI::toJsonValue(m_availability_zone_name));
    }
    if (m_zone_status.isSet()) {
        obj.insert(QString("ZoneStatus"), ::OpenAPI::toJsonValue(m_zone_status));
    }
    if (m_configured_data_node_count_isSet) {
        obj.insert(QString("ConfiguredDataNodeCount"), ::OpenAPI::toJsonValue(m_configured_data_node_count));
    }
    if (m_available_data_node_count_isSet) {
        obj.insert(QString("AvailableDataNodeCount"), ::OpenAPI::toJsonValue(m_available_data_node_count));
    }
    if (m_total_shards_isSet) {
        obj.insert(QString("TotalShards"), ::OpenAPI::toJsonValue(m_total_shards));
    }
    if (m_total_un_assigned_shards_isSet) {
        obj.insert(QString("TotalUnAssignedShards"), ::OpenAPI::toJsonValue(m_total_un_assigned_shards));
    }
    return obj;
}

QString OAIAvailabilityZoneInfo::getAvailabilityZoneName() const {
    return m_availability_zone_name;
}
void OAIAvailabilityZoneInfo::setAvailabilityZoneName(const QString &availability_zone_name) {
    m_availability_zone_name = availability_zone_name;
    m_availability_zone_name_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_availability_zone_name_Set() const{
    return m_availability_zone_name_isSet;
}

bool OAIAvailabilityZoneInfo::is_availability_zone_name_Valid() const{
    return m_availability_zone_name_isValid;
}

OAIZoneStatus OAIAvailabilityZoneInfo::getZoneStatus() const {
    return m_zone_status;
}
void OAIAvailabilityZoneInfo::setZoneStatus(const OAIZoneStatus &zone_status) {
    m_zone_status = zone_status;
    m_zone_status_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_zone_status_Set() const{
    return m_zone_status_isSet;
}

bool OAIAvailabilityZoneInfo::is_zone_status_Valid() const{
    return m_zone_status_isValid;
}

QString OAIAvailabilityZoneInfo::getConfiguredDataNodeCount() const {
    return m_configured_data_node_count;
}
void OAIAvailabilityZoneInfo::setConfiguredDataNodeCount(const QString &configured_data_node_count) {
    m_configured_data_node_count = configured_data_node_count;
    m_configured_data_node_count_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_configured_data_node_count_Set() const{
    return m_configured_data_node_count_isSet;
}

bool OAIAvailabilityZoneInfo::is_configured_data_node_count_Valid() const{
    return m_configured_data_node_count_isValid;
}

QString OAIAvailabilityZoneInfo::getAvailableDataNodeCount() const {
    return m_available_data_node_count;
}
void OAIAvailabilityZoneInfo::setAvailableDataNodeCount(const QString &available_data_node_count) {
    m_available_data_node_count = available_data_node_count;
    m_available_data_node_count_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_available_data_node_count_Set() const{
    return m_available_data_node_count_isSet;
}

bool OAIAvailabilityZoneInfo::is_available_data_node_count_Valid() const{
    return m_available_data_node_count_isValid;
}

QString OAIAvailabilityZoneInfo::getTotalShards() const {
    return m_total_shards;
}
void OAIAvailabilityZoneInfo::setTotalShards(const QString &total_shards) {
    m_total_shards = total_shards;
    m_total_shards_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_total_shards_Set() const{
    return m_total_shards_isSet;
}

bool OAIAvailabilityZoneInfo::is_total_shards_Valid() const{
    return m_total_shards_isValid;
}

QString OAIAvailabilityZoneInfo::getTotalUnAssignedShards() const {
    return m_total_un_assigned_shards;
}
void OAIAvailabilityZoneInfo::setTotalUnAssignedShards(const QString &total_un_assigned_shards) {
    m_total_un_assigned_shards = total_un_assigned_shards;
    m_total_un_assigned_shards_isSet = true;
}

bool OAIAvailabilityZoneInfo::is_total_un_assigned_shards_Set() const{
    return m_total_un_assigned_shards_isSet;
}

bool OAIAvailabilityZoneInfo::is_total_un_assigned_shards_Valid() const{
    return m_total_un_assigned_shards_isValid;
}

bool OAIAvailabilityZoneInfo::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_availability_zone_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_configured_data_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_data_node_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_shards_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_un_assigned_shards_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAvailabilityZoneInfo::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
