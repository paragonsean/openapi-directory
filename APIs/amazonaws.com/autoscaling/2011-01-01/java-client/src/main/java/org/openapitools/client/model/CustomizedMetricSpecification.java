/*
 * Auto Scaling
 * <fullname>Amazon EC2 Auto Scaling</fullname> <p>Amazon EC2 Auto Scaling is designed to automatically launch and terminate EC2 instances based on user-defined scaling policies, scheduled actions, and health checks.</p> <p>For more information, see the <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/\">Amazon EC2 Auto Scaling User Guide</a> and the <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/APIReference/Welcome.html\">Amazon EC2 Auto Scaling API Reference</a>.</p>
 *
 * The version of the OpenAPI document: 2011-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MetricStatistic;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Represents a CloudWatch metric of your choosing for a target tracking scaling policy to use with Amazon EC2 Auto Scaling.&lt;/p&gt; &lt;p&gt;To create your customized metric specification:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Add values for each required property from CloudWatch. You can use an existing metric, or a new metric that you create. To use your own metric, you must first publish the metric to CloudWatch. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html\&quot;&gt;Publish custom metrics&lt;/a&gt; in the &lt;i&gt;Amazon CloudWatch User Guide&lt;/i&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Choose a metric that changes proportionally with capacity. The value of the metric should increase or decrease in inverse proportion to the number of capacity units. That is, the value of the metric should decrease when capacity increases.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information about the CloudWatch terminology below, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html\&quot;&gt;Amazon CloudWatch concepts&lt;/a&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;Each individual service provides information about the metrics, namespace, and dimensions they use. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html\&quot;&gt;Amazon Web Services services that publish CloudWatch metrics&lt;/a&gt; in the &lt;i&gt;Amazon CloudWatch User Guide&lt;/i&gt;.&lt;/p&gt; &lt;/note&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:05:42.641692-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CustomizedMetricSpecification {
  public static final String SERIALIZED_NAME_METRIC_NAME = "MetricName";
  @SerializedName(SERIALIZED_NAME_METRIC_NAME)
  private String metricName;

  public static final String SERIALIZED_NAME_NAMESPACE = "Namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_DIMENSIONS = "Dimensions";
  @SerializedName(SERIALIZED_NAME_DIMENSIONS)
  private List dimensions;

  public static final String SERIALIZED_NAME_STATISTIC = "Statistic";
  @SerializedName(SERIALIZED_NAME_STATISTIC)
  private MetricStatistic statistic;

  public static final String SERIALIZED_NAME_UNIT = "Unit";
  @SerializedName(SERIALIZED_NAME_UNIT)
  private String unit;

  public static final String SERIALIZED_NAME_METRICS = "Metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List metrics;

  public CustomizedMetricSpecification() {
  }

  public CustomizedMetricSpecification metricName(String metricName) {
    this.metricName = metricName;
    return this;
  }

  /**
   * Get metricName
   * @return metricName
   */
  @javax.annotation.Nullable
  public String getMetricName() {
    return metricName;
  }

  public void setMetricName(String metricName) {
    this.metricName = metricName;
  }


  public CustomizedMetricSpecification namespace(String namespace) {
    this.namespace = namespace;
    return this;
  }

  /**
   * Get namespace
   * @return namespace
   */
  @javax.annotation.Nullable
  public String getNamespace() {
    return namespace;
  }

  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public CustomizedMetricSpecification dimensions(List dimensions) {
    this.dimensions = dimensions;
    return this;
  }

  /**
   * Get dimensions
   * @return dimensions
   */
  @javax.annotation.Nullable
  public List getDimensions() {
    return dimensions;
  }

  public void setDimensions(List dimensions) {
    this.dimensions = dimensions;
  }


  public CustomizedMetricSpecification statistic(MetricStatistic statistic) {
    this.statistic = statistic;
    return this;
  }

  /**
   * Get statistic
   * @return statistic
   */
  @javax.annotation.Nullable
  public MetricStatistic getStatistic() {
    return statistic;
  }

  public void setStatistic(MetricStatistic statistic) {
    this.statistic = statistic;
  }


  public CustomizedMetricSpecification unit(String unit) {
    this.unit = unit;
    return this;
  }

  /**
   * Get unit
   * @return unit
   */
  @javax.annotation.Nullable
  public String getUnit() {
    return unit;
  }

  public void setUnit(String unit) {
    this.unit = unit;
  }


  public CustomizedMetricSpecification metrics(List metrics) {
    this.metrics = metrics;
    return this;
  }

  /**
   * Get metrics
   * @return metrics
   */
  @javax.annotation.Nullable
  public List getMetrics() {
    return metrics;
  }

  public void setMetrics(List metrics) {
    this.metrics = metrics;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CustomizedMetricSpecification customizedMetricSpecification = (CustomizedMetricSpecification) o;
    return Objects.equals(this.metricName, customizedMetricSpecification.metricName) &&
        Objects.equals(this.namespace, customizedMetricSpecification.namespace) &&
        Objects.equals(this.dimensions, customizedMetricSpecification.dimensions) &&
        Objects.equals(this.statistic, customizedMetricSpecification.statistic) &&
        Objects.equals(this.unit, customizedMetricSpecification.unit) &&
        Objects.equals(this.metrics, customizedMetricSpecification.metrics);
  }

  @Override
  public int hashCode() {
    return Objects.hash(metricName, namespace, dimensions, statistic, unit, metrics);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CustomizedMetricSpecification {\n");
    sb.append("    metricName: ").append(toIndentedString(metricName)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("    statistic: ").append(toIndentedString(statistic)).append("\n");
    sb.append("    unit: ").append(toIndentedString(unit)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("MetricName");
    openapiFields.add("Namespace");
    openapiFields.add("Dimensions");
    openapiFields.add("Statistic");
    openapiFields.add("Unit");
    openapiFields.add("Metrics");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CustomizedMetricSpecification
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CustomizedMetricSpecification.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CustomizedMetricSpecification is not found in the empty JSON string", CustomizedMetricSpecification.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CustomizedMetricSpecification.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CustomizedMetricSpecification` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `MetricName`
      if (jsonObj.get("MetricName") != null && !jsonObj.get("MetricName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("MetricName"));
      }
      // validate the optional field `Namespace`
      if (jsonObj.get("Namespace") != null && !jsonObj.get("Namespace").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Namespace"));
      }
      // validate the optional field `Dimensions`
      if (jsonObj.get("Dimensions") != null && !jsonObj.get("Dimensions").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Dimensions"));
      }
      // validate the optional field `Statistic`
      if (jsonObj.get("Statistic") != null && !jsonObj.get("Statistic").isJsonNull()) {
        MetricStatistic.validateJsonElement(jsonObj.get("Statistic"));
      }
      // validate the optional field `Unit`
      if (jsonObj.get("Unit") != null && !jsonObj.get("Unit").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Unit"));
      }
      // validate the optional field `Metrics`
      if (jsonObj.get("Metrics") != null && !jsonObj.get("Metrics").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Metrics"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CustomizedMetricSpecification.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CustomizedMetricSpecification' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CustomizedMetricSpecification> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CustomizedMetricSpecification.class));

       return (TypeAdapter<T>) new TypeAdapter<CustomizedMetricSpecification>() {
           @Override
           public void write(JsonWriter out, CustomizedMetricSpecification value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CustomizedMetricSpecification read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CustomizedMetricSpecification given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CustomizedMetricSpecification
   * @throws IOException if the JSON string is invalid with respect to CustomizedMetricSpecification
   */
  public static CustomizedMetricSpecification fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CustomizedMetricSpecification.class);
  }

  /**
   * Convert an instance of CustomizedMetricSpecification to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

