/*
 * Auto Scaling
 * <fullname>Amazon EC2 Auto Scaling</fullname> <p>Amazon EC2 Auto Scaling is designed to automatically launch and terminate EC2 instances based on user-defined scaling policies, scheduled actions, and health checks.</p> <p>For more information, see the <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/\">Amazon EC2 Auto Scaling User Guide</a> and the <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/APIReference/Welcome.html\">Amazon EC2 Auto Scaling API Reference</a>.</p>
 *
 * The version of the OpenAPI document: 2011-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.LaunchTemplateOverridesInstanceRequirements;
import org.openapitools.client.model.LaunchTemplateOverridesLaunchTemplateSpecification;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Use this structure to let Amazon EC2 Auto Scaling do the following when the Auto Scaling group has a mixed instances policy:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Override the instance type that is specified in the launch template.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Use multiple instance types.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Specify the instance types that you want, or define your instance requirements instead and let Amazon EC2 Auto Scaling provision the available instance types that meet your requirements. This can provide Amazon EC2 Auto Scaling with a larger selection of instance types to choose from when fulfilling Spot and On-Demand capacities. You can view which instance types are matched before you apply the instance requirements to your Auto Scaling group.&lt;/p&gt; &lt;p&gt;After you define your instance requirements, you don&#39;t have to keep updating these settings to get new EC2 instance types automatically. Amazon EC2 Auto Scaling uses the instance requirements of the Auto Scaling group to determine whether a new EC2 instance type can be used.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:05:42.641692-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LaunchTemplateOverrides {
  public static final String SERIALIZED_NAME_INSTANCE_TYPE = "InstanceType";
  @SerializedName(SERIALIZED_NAME_INSTANCE_TYPE)
  private String instanceType;

  public static final String SERIALIZED_NAME_WEIGHTED_CAPACITY = "WeightedCapacity";
  @SerializedName(SERIALIZED_NAME_WEIGHTED_CAPACITY)
  private String weightedCapacity;

  public static final String SERIALIZED_NAME_LAUNCH_TEMPLATE_SPECIFICATION = "LaunchTemplateSpecification";
  @SerializedName(SERIALIZED_NAME_LAUNCH_TEMPLATE_SPECIFICATION)
  private LaunchTemplateOverridesLaunchTemplateSpecification launchTemplateSpecification;

  public static final String SERIALIZED_NAME_INSTANCE_REQUIREMENTS = "InstanceRequirements";
  @SerializedName(SERIALIZED_NAME_INSTANCE_REQUIREMENTS)
  private LaunchTemplateOverridesInstanceRequirements instanceRequirements;

  public LaunchTemplateOverrides() {
  }

  public LaunchTemplateOverrides instanceType(String instanceType) {
    this.instanceType = instanceType;
    return this;
  }

  /**
   * Get instanceType
   * @return instanceType
   */
  @javax.annotation.Nullable
  public String getInstanceType() {
    return instanceType;
  }

  public void setInstanceType(String instanceType) {
    this.instanceType = instanceType;
  }


  public LaunchTemplateOverrides weightedCapacity(String weightedCapacity) {
    this.weightedCapacity = weightedCapacity;
    return this;
  }

  /**
   * Get weightedCapacity
   * @return weightedCapacity
   */
  @javax.annotation.Nullable
  public String getWeightedCapacity() {
    return weightedCapacity;
  }

  public void setWeightedCapacity(String weightedCapacity) {
    this.weightedCapacity = weightedCapacity;
  }


  public LaunchTemplateOverrides launchTemplateSpecification(LaunchTemplateOverridesLaunchTemplateSpecification launchTemplateSpecification) {
    this.launchTemplateSpecification = launchTemplateSpecification;
    return this;
  }

  /**
   * Get launchTemplateSpecification
   * @return launchTemplateSpecification
   */
  @javax.annotation.Nullable
  public LaunchTemplateOverridesLaunchTemplateSpecification getLaunchTemplateSpecification() {
    return launchTemplateSpecification;
  }

  public void setLaunchTemplateSpecification(LaunchTemplateOverridesLaunchTemplateSpecification launchTemplateSpecification) {
    this.launchTemplateSpecification = launchTemplateSpecification;
  }


  public LaunchTemplateOverrides instanceRequirements(LaunchTemplateOverridesInstanceRequirements instanceRequirements) {
    this.instanceRequirements = instanceRequirements;
    return this;
  }

  /**
   * Get instanceRequirements
   * @return instanceRequirements
   */
  @javax.annotation.Nullable
  public LaunchTemplateOverridesInstanceRequirements getInstanceRequirements() {
    return instanceRequirements;
  }

  public void setInstanceRequirements(LaunchTemplateOverridesInstanceRequirements instanceRequirements) {
    this.instanceRequirements = instanceRequirements;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LaunchTemplateOverrides launchTemplateOverrides = (LaunchTemplateOverrides) o;
    return Objects.equals(this.instanceType, launchTemplateOverrides.instanceType) &&
        Objects.equals(this.weightedCapacity, launchTemplateOverrides.weightedCapacity) &&
        Objects.equals(this.launchTemplateSpecification, launchTemplateOverrides.launchTemplateSpecification) &&
        Objects.equals(this.instanceRequirements, launchTemplateOverrides.instanceRequirements);
  }

  @Override
  public int hashCode() {
    return Objects.hash(instanceType, weightedCapacity, launchTemplateSpecification, instanceRequirements);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LaunchTemplateOverrides {\n");
    sb.append("    instanceType: ").append(toIndentedString(instanceType)).append("\n");
    sb.append("    weightedCapacity: ").append(toIndentedString(weightedCapacity)).append("\n");
    sb.append("    launchTemplateSpecification: ").append(toIndentedString(launchTemplateSpecification)).append("\n");
    sb.append("    instanceRequirements: ").append(toIndentedString(instanceRequirements)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("InstanceType");
    openapiFields.add("WeightedCapacity");
    openapiFields.add("LaunchTemplateSpecification");
    openapiFields.add("InstanceRequirements");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LaunchTemplateOverrides
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LaunchTemplateOverrides.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LaunchTemplateOverrides is not found in the empty JSON string", LaunchTemplateOverrides.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LaunchTemplateOverrides.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LaunchTemplateOverrides` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `InstanceType`
      if (jsonObj.get("InstanceType") != null && !jsonObj.get("InstanceType").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("InstanceType"));
      }
      // validate the optional field `WeightedCapacity`
      if (jsonObj.get("WeightedCapacity") != null && !jsonObj.get("WeightedCapacity").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("WeightedCapacity"));
      }
      // validate the optional field `LaunchTemplateSpecification`
      if (jsonObj.get("LaunchTemplateSpecification") != null && !jsonObj.get("LaunchTemplateSpecification").isJsonNull()) {
        LaunchTemplateOverridesLaunchTemplateSpecification.validateJsonElement(jsonObj.get("LaunchTemplateSpecification"));
      }
      // validate the optional field `InstanceRequirements`
      if (jsonObj.get("InstanceRequirements") != null && !jsonObj.get("InstanceRequirements").isJsonNull()) {
        LaunchTemplateOverridesInstanceRequirements.validateJsonElement(jsonObj.get("InstanceRequirements"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LaunchTemplateOverrides.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LaunchTemplateOverrides' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LaunchTemplateOverrides> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LaunchTemplateOverrides.class));

       return (TypeAdapter<T>) new TypeAdapter<LaunchTemplateOverrides>() {
           @Override
           public void write(JsonWriter out, LaunchTemplateOverrides value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LaunchTemplateOverrides read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LaunchTemplateOverrides given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LaunchTemplateOverrides
   * @throws IOException if the JSON string is invalid with respect to LaunchTemplateOverrides
   */
  public static LaunchTemplateOverrides fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LaunchTemplateOverrides.class);
  }

  /**
   * Convert an instance of LaunchTemplateOverrides to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

