/**
 * AmazonApiGatewayV2
 * Amazon API Gateway V2
 *
 * The version of the OpenAPI document: 2018-11-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CreateAuthorizerRequestJwtConfiguration from './CreateAuthorizerRequestJwtConfiguration';

/**
 * The CreateAuthorizerRequest model module.
 * @module model/CreateAuthorizerRequest
 * @version 2018-11-29
 */
class CreateAuthorizerRequest {
    /**
     * Constructs a new <code>CreateAuthorizerRequest</code>.
     * @alias module:model/CreateAuthorizerRequest
     * @param authorizerType {module:model/CreateAuthorizerRequest.AuthorizerTypeEnum} The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
     * @param identitySource {Array.<String>} The identity source for which authorization is requested. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is $method.request.header.Auth, $method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
     * @param name {String} A string with a length between [1-128].
     */
    constructor(authorizerType, identitySource, name) { 
        
        CreateAuthorizerRequest.initialize(this, authorizerType, identitySource, name);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, authorizerType, identitySource, name) { 
        obj['authorizerType'] = authorizerType;
        obj['identitySource'] = identitySource;
        obj['name'] = name;
    }

    /**
     * Constructs a <code>CreateAuthorizerRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/CreateAuthorizerRequest} obj Optional instance to populate.
     * @return {module:model/CreateAuthorizerRequest} The populated <code>CreateAuthorizerRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new CreateAuthorizerRequest();

            if (data.hasOwnProperty('authorizerCredentialsArn')) {
                obj['authorizerCredentialsArn'] = ApiClient.convertToType(data['authorizerCredentialsArn'], 'String');
            }
            if (data.hasOwnProperty('authorizerPayloadFormatVersion')) {
                obj['authorizerPayloadFormatVersion'] = ApiClient.convertToType(data['authorizerPayloadFormatVersion'], 'String');
            }
            if (data.hasOwnProperty('authorizerResultTtlInSeconds')) {
                obj['authorizerResultTtlInSeconds'] = ApiClient.convertToType(data['authorizerResultTtlInSeconds'], 'Number');
            }
            if (data.hasOwnProperty('authorizerType')) {
                obj['authorizerType'] = ApiClient.convertToType(data['authorizerType'], 'String');
            }
            if (data.hasOwnProperty('authorizerUri')) {
                obj['authorizerUri'] = ApiClient.convertToType(data['authorizerUri'], 'String');
            }
            if (data.hasOwnProperty('enableSimpleResponses')) {
                obj['enableSimpleResponses'] = ApiClient.convertToType(data['enableSimpleResponses'], 'Boolean');
            }
            if (data.hasOwnProperty('identitySource')) {
                obj['identitySource'] = ApiClient.convertToType(data['identitySource'], ['String']);
            }
            if (data.hasOwnProperty('identityValidationExpression')) {
                obj['identityValidationExpression'] = ApiClient.convertToType(data['identityValidationExpression'], 'String');
            }
            if (data.hasOwnProperty('jwtConfiguration')) {
                obj['jwtConfiguration'] = CreateAuthorizerRequestJwtConfiguration.constructFromObject(data['jwtConfiguration']);
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>CreateAuthorizerRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>CreateAuthorizerRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of CreateAuthorizerRequest.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['authorizerCredentialsArn'] && !(typeof data['authorizerCredentialsArn'] === 'string' || data['authorizerCredentialsArn'] instanceof String)) {
            throw new Error("Expected the field `authorizerCredentialsArn` to be a primitive type in the JSON string but got " + data['authorizerCredentialsArn']);
        }
        // ensure the json data is a string
        if (data['authorizerPayloadFormatVersion'] && !(typeof data['authorizerPayloadFormatVersion'] === 'string' || data['authorizerPayloadFormatVersion'] instanceof String)) {
            throw new Error("Expected the field `authorizerPayloadFormatVersion` to be a primitive type in the JSON string but got " + data['authorizerPayloadFormatVersion']);
        }
        // ensure the json data is a string
        if (data['authorizerType'] && !(typeof data['authorizerType'] === 'string' || data['authorizerType'] instanceof String)) {
            throw new Error("Expected the field `authorizerType` to be a primitive type in the JSON string but got " + data['authorizerType']);
        }
        // ensure the json data is a string
        if (data['authorizerUri'] && !(typeof data['authorizerUri'] === 'string' || data['authorizerUri'] instanceof String)) {
            throw new Error("Expected the field `authorizerUri` to be a primitive type in the JSON string but got " + data['authorizerUri']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['identitySource'])) {
            throw new Error("Expected the field `identitySource` to be an array in the JSON data but got " + data['identitySource']);
        }
        // ensure the json data is a string
        if (data['identityValidationExpression'] && !(typeof data['identityValidationExpression'] === 'string' || data['identityValidationExpression'] instanceof String)) {
            throw new Error("Expected the field `identityValidationExpression` to be a primitive type in the JSON string but got " + data['identityValidationExpression']);
        }
        // validate the optional field `jwtConfiguration`
        if (data['jwtConfiguration']) { // data not null
          CreateAuthorizerRequestJwtConfiguration.validateJSON(data['jwtConfiguration']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }

        return true;
    }


}

CreateAuthorizerRequest.RequiredProperties = ["authorizerType", "identitySource", "name"];

/**
 * Represents an Amazon Resource Name (ARN).
 * @member {String} authorizerCredentialsArn
 */
CreateAuthorizerRequest.prototype['authorizerCredentialsArn'] = undefined;

/**
 * A string with a length between [1-64].
 * @member {String} authorizerPayloadFormatVersion
 */
CreateAuthorizerRequest.prototype['authorizerPayloadFormatVersion'] = undefined;

/**
 * An integer with a value between [0-3600].
 * @member {Number} authorizerResultTtlInSeconds
 */
CreateAuthorizerRequest.prototype['authorizerResultTtlInSeconds'] = undefined;

/**
 * The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
 * @member {module:model/CreateAuthorizerRequest.AuthorizerTypeEnum} authorizerType
 */
CreateAuthorizerRequest.prototype['authorizerType'] = undefined;

/**
 * A string representation of a URI with a length between [1-2048].
 * @member {String} authorizerUri
 */
CreateAuthorizerRequest.prototype['authorizerUri'] = undefined;

/**
 * Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html\">Working with AWS Lambda authorizers for HTTP APIs</a>
 * @member {Boolean} enableSimpleResponses
 */
CreateAuthorizerRequest.prototype['enableSimpleResponses'] = undefined;

/**
 * The identity source for which authorization is requested. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is $method.request.header.Auth, $method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
 * @member {Array.<String>} identitySource
 */
CreateAuthorizerRequest.prototype['identitySource'] = undefined;

/**
 * A string with a length between [0-1024].
 * @member {String} identityValidationExpression
 */
CreateAuthorizerRequest.prototype['identityValidationExpression'] = undefined;

/**
 * @member {module:model/CreateAuthorizerRequestJwtConfiguration} jwtConfiguration
 */
CreateAuthorizerRequest.prototype['jwtConfiguration'] = undefined;

/**
 * A string with a length between [1-128].
 * @member {String} name
 */
CreateAuthorizerRequest.prototype['name'] = undefined;





/**
 * Allowed values for the <code>authorizerType</code> property.
 * @enum {String}
 * @readonly
 */
CreateAuthorizerRequest['AuthorizerTypeEnum'] = {

    /**
     * value: "REQUEST"
     * @const
     */
    "REQUEST": "REQUEST",

    /**
     * value: "JWT"
     * @const
     */
    "JWT": "JWT"
};



export default CreateAuthorizerRequest;

