/**
 * Amazon Chime SDK Media Pipelines
 * The Amazon Chime SDK media pipeline APIs in this section allow software developers to create Amazon Chime SDK media pipelines that capture, concatenate, or stream your Amazon Chime SDK meetings. For more information about media pipelines, see <a href=\"https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_Operations_Amazon_Chime_SDK_Media_Pipelines.html\">Amazon Chime SDK media pipelines</a>. 
 *
 * The version of the OpenAPI document: 2021-07-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIKinesisVideoStreamSourceRuntimeConfiguration.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIKinesisVideoStreamSourceRuntimeConfiguration::OAIKinesisVideoStreamSourceRuntimeConfiguration(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIKinesisVideoStreamSourceRuntimeConfiguration::OAIKinesisVideoStreamSourceRuntimeConfiguration() {
    this->initializeModel();
}

OAIKinesisVideoStreamSourceRuntimeConfiguration::~OAIKinesisVideoStreamSourceRuntimeConfiguration() {}

void OAIKinesisVideoStreamSourceRuntimeConfiguration::initializeModel() {

    m_streams_isSet = false;
    m_streams_isValid = false;

    m_media_encoding_isSet = false;
    m_media_encoding_isValid = false;

    m_media_sample_rate_isSet = false;
    m_media_sample_rate_isValid = false;
}

void OAIKinesisVideoStreamSourceRuntimeConfiguration::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIKinesisVideoStreamSourceRuntimeConfiguration::fromJsonObject(QJsonObject json) {

    m_streams_isValid = ::OpenAPI::fromJsonValue(m_streams, json[QString("Streams")]);
    m_streams_isSet = !json[QString("Streams")].isNull() && m_streams_isValid;

    m_media_encoding_isValid = ::OpenAPI::fromJsonValue(m_media_encoding, json[QString("MediaEncoding")]);
    m_media_encoding_isSet = !json[QString("MediaEncoding")].isNull() && m_media_encoding_isValid;

    m_media_sample_rate_isValid = ::OpenAPI::fromJsonValue(m_media_sample_rate, json[QString("MediaSampleRate")]);
    m_media_sample_rate_isSet = !json[QString("MediaSampleRate")].isNull() && m_media_sample_rate_isValid;
}

QString OAIKinesisVideoStreamSourceRuntimeConfiguration::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIKinesisVideoStreamSourceRuntimeConfiguration::asJsonObject() const {
    QJsonObject obj;
    if (m_streams.isSet()) {
        obj.insert(QString("Streams"), ::OpenAPI::toJsonValue(m_streams));
    }
    if (m_media_encoding.isSet()) {
        obj.insert(QString("MediaEncoding"), ::OpenAPI::toJsonValue(m_media_encoding));
    }
    if (m_media_sample_rate_isSet) {
        obj.insert(QString("MediaSampleRate"), ::OpenAPI::toJsonValue(m_media_sample_rate));
    }
    return obj;
}

QList OAIKinesisVideoStreamSourceRuntimeConfiguration::getStreams() const {
    return m_streams;
}
void OAIKinesisVideoStreamSourceRuntimeConfiguration::setStreams(const QList &streams) {
    m_streams = streams;
    m_streams_isSet = true;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_streams_Set() const{
    return m_streams_isSet;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_streams_Valid() const{
    return m_streams_isValid;
}

OAIMediaEncoding OAIKinesisVideoStreamSourceRuntimeConfiguration::getMediaEncoding() const {
    return m_media_encoding;
}
void OAIKinesisVideoStreamSourceRuntimeConfiguration::setMediaEncoding(const OAIMediaEncoding &media_encoding) {
    m_media_encoding = media_encoding;
    m_media_encoding_isSet = true;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_media_encoding_Set() const{
    return m_media_encoding_isSet;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_media_encoding_Valid() const{
    return m_media_encoding_isValid;
}

qint32 OAIKinesisVideoStreamSourceRuntimeConfiguration::getMediaSampleRate() const {
    return m_media_sample_rate;
}
void OAIKinesisVideoStreamSourceRuntimeConfiguration::setMediaSampleRate(const qint32 &media_sample_rate) {
    m_media_sample_rate = media_sample_rate;
    m_media_sample_rate_isSet = true;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_media_sample_rate_Set() const{
    return m_media_sample_rate_isSet;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::is_media_sample_rate_Valid() const{
    return m_media_sample_rate_isValid;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_streams.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_encoding.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_sample_rate_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIKinesisVideoStreamSourceRuntimeConfiguration::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_streams_isValid && m_media_encoding_isValid && m_media_sample_rate_isValid && true;
}

} // namespace OpenAPI
