/**
 * Amazon Chime SDK Media Pipelines
 * The Amazon Chime SDK media pipeline APIs in this section allow software developers to create Amazon Chime SDK media pipelines that capture, concatenate, or stream your Amazon Chime SDK meetings. For more information about media pipelines, see <a href=\"https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_Operations_Amazon_Chime_SDK_Media_Pipelines.html\">Amazon Chime SDK media pipelines</a>. 
 *
 * The version of the OpenAPI document: 2021-07-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRealTimeAlertRule_SentimentConfiguration.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRealTimeAlertRule_SentimentConfiguration::OAIRealTimeAlertRule_SentimentConfiguration(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRealTimeAlertRule_SentimentConfiguration::OAIRealTimeAlertRule_SentimentConfiguration() {
    this->initializeModel();
}

OAIRealTimeAlertRule_SentimentConfiguration::~OAIRealTimeAlertRule_SentimentConfiguration() {}

void OAIRealTimeAlertRule_SentimentConfiguration::initializeModel() {

    m_rule_name_isSet = false;
    m_rule_name_isValid = false;

    m_sentiment_type_isSet = false;
    m_sentiment_type_isValid = false;

    m_time_period_isSet = false;
    m_time_period_isValid = false;
}

void OAIRealTimeAlertRule_SentimentConfiguration::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRealTimeAlertRule_SentimentConfiguration::fromJsonObject(QJsonObject json) {

    m_rule_name_isValid = ::OpenAPI::fromJsonValue(m_rule_name, json[QString("RuleName")]);
    m_rule_name_isSet = !json[QString("RuleName")].isNull() && m_rule_name_isValid;

    m_sentiment_type_isValid = ::OpenAPI::fromJsonValue(m_sentiment_type, json[QString("SentimentType")]);
    m_sentiment_type_isSet = !json[QString("SentimentType")].isNull() && m_sentiment_type_isValid;

    m_time_period_isValid = ::OpenAPI::fromJsonValue(m_time_period, json[QString("TimePeriod")]);
    m_time_period_isSet = !json[QString("TimePeriod")].isNull() && m_time_period_isValid;
}

QString OAIRealTimeAlertRule_SentimentConfiguration::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRealTimeAlertRule_SentimentConfiguration::asJsonObject() const {
    QJsonObject obj;
    if (m_rule_name_isSet) {
        obj.insert(QString("RuleName"), ::OpenAPI::toJsonValue(m_rule_name));
    }
    if (m_sentiment_type.isSet()) {
        obj.insert(QString("SentimentType"), ::OpenAPI::toJsonValue(m_sentiment_type));
    }
    if (m_time_period_isSet) {
        obj.insert(QString("TimePeriod"), ::OpenAPI::toJsonValue(m_time_period));
    }
    return obj;
}

QString OAIRealTimeAlertRule_SentimentConfiguration::getRuleName() const {
    return m_rule_name;
}
void OAIRealTimeAlertRule_SentimentConfiguration::setRuleName(const QString &rule_name) {
    m_rule_name = rule_name;
    m_rule_name_isSet = true;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_rule_name_Set() const{
    return m_rule_name_isSet;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_rule_name_Valid() const{
    return m_rule_name_isValid;
}

OAISentimentType OAIRealTimeAlertRule_SentimentConfiguration::getSentimentType() const {
    return m_sentiment_type;
}
void OAIRealTimeAlertRule_SentimentConfiguration::setSentimentType(const OAISentimentType &sentiment_type) {
    m_sentiment_type = sentiment_type;
    m_sentiment_type_isSet = true;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_sentiment_type_Set() const{
    return m_sentiment_type_isSet;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_sentiment_type_Valid() const{
    return m_sentiment_type_isValid;
}

qint32 OAIRealTimeAlertRule_SentimentConfiguration::getTimePeriod() const {
    return m_time_period;
}
void OAIRealTimeAlertRule_SentimentConfiguration::setTimePeriod(const qint32 &time_period) {
    m_time_period = time_period;
    m_time_period_isSet = true;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_time_period_Set() const{
    return m_time_period_isSet;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::is_time_period_Valid() const{
    return m_time_period_isValid;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_rule_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sentiment_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_period_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRealTimeAlertRule_SentimentConfiguration::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_rule_name_isValid && m_sentiment_type_isValid && m_time_period_isValid && true;
}

} // namespace OpenAPI
