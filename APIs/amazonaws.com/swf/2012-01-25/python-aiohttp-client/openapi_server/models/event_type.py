# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class EventType(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    """
    allowed enum values
    """
    WORKFLOWEXECUTIONSTARTED = 'WorkflowExecutionStarted'
    WORKFLOWEXECUTIONCANCELREQUESTED = 'WorkflowExecutionCancelRequested'
    WORKFLOWEXECUTIONCOMPLETED = 'WorkflowExecutionCompleted'
    COMPLETEWORKFLOWEXECUTIONFAILED = 'CompleteWorkflowExecutionFailed'
    WORKFLOWEXECUTIONFAILED = 'WorkflowExecutionFailed'
    FAILWORKFLOWEXECUTIONFAILED = 'FailWorkflowExecutionFailed'
    WORKFLOWEXECUTIONTIMEDOUT = 'WorkflowExecutionTimedOut'
    WORKFLOWEXECUTIONCANCELED = 'WorkflowExecutionCanceled'
    CANCELWORKFLOWEXECUTIONFAILED = 'CancelWorkflowExecutionFailed'
    WORKFLOWEXECUTIONCONTINUEDASNEW = 'WorkflowExecutionContinuedAsNew'
    CONTINUEASNEWWORKFLOWEXECUTIONFAILED = 'ContinueAsNewWorkflowExecutionFailed'
    WORKFLOWEXECUTIONTERMINATED = 'WorkflowExecutionTerminated'
    DECISIONTASKSCHEDULED = 'DecisionTaskScheduled'
    DECISIONTASKSTARTED = 'DecisionTaskStarted'
    DECISIONTASKCOMPLETED = 'DecisionTaskCompleted'
    DECISIONTASKTIMEDOUT = 'DecisionTaskTimedOut'
    ACTIVITYTASKSCHEDULED = 'ActivityTaskScheduled'
    SCHEDULEACTIVITYTASKFAILED = 'ScheduleActivityTaskFailed'
    ACTIVITYTASKSTARTED = 'ActivityTaskStarted'
    ACTIVITYTASKCOMPLETED = 'ActivityTaskCompleted'
    ACTIVITYTASKFAILED = 'ActivityTaskFailed'
    ACTIVITYTASKTIMEDOUT = 'ActivityTaskTimedOut'
    ACTIVITYTASKCANCELED = 'ActivityTaskCanceled'
    ACTIVITYTASKCANCELREQUESTED = 'ActivityTaskCancelRequested'
    REQUESTCANCELACTIVITYTASKFAILED = 'RequestCancelActivityTaskFailed'
    WORKFLOWEXECUTIONSIGNALED = 'WorkflowExecutionSignaled'
    MARKERRECORDED = 'MarkerRecorded'
    RECORDMARKERFAILED = 'RecordMarkerFailed'
    TIMERSTARTED = 'TimerStarted'
    STARTTIMERFAILED = 'StartTimerFailed'
    TIMERFIRED = 'TimerFired'
    TIMERCANCELED = 'TimerCanceled'
    CANCELTIMERFAILED = 'CancelTimerFailed'
    STARTCHILDWORKFLOWEXECUTIONINITIATED = 'StartChildWorkflowExecutionInitiated'
    STARTCHILDWORKFLOWEXECUTIONFAILED = 'StartChildWorkflowExecutionFailed'
    CHILDWORKFLOWEXECUTIONSTARTED = 'ChildWorkflowExecutionStarted'
    CHILDWORKFLOWEXECUTIONCOMPLETED = 'ChildWorkflowExecutionCompleted'
    CHILDWORKFLOWEXECUTIONFAILED = 'ChildWorkflowExecutionFailed'
    CHILDWORKFLOWEXECUTIONTIMEDOUT = 'ChildWorkflowExecutionTimedOut'
    CHILDWORKFLOWEXECUTIONCANCELED = 'ChildWorkflowExecutionCanceled'
    CHILDWORKFLOWEXECUTIONTERMINATED = 'ChildWorkflowExecutionTerminated'
    SIGNALEXTERNALWORKFLOWEXECUTIONINITIATED = 'SignalExternalWorkflowExecutionInitiated'
    SIGNALEXTERNALWORKFLOWEXECUTIONFAILED = 'SignalExternalWorkflowExecutionFailed'
    EXTERNALWORKFLOWEXECUTIONSIGNALED = 'ExternalWorkflowExecutionSignaled'
    REQUESTCANCELEXTERNALWORKFLOWEXECUTIONINITIATED = 'RequestCancelExternalWorkflowExecutionInitiated'
    REQUESTCANCELEXTERNALWORKFLOWEXECUTIONFAILED = 'RequestCancelExternalWorkflowExecutionFailed'
    EXTERNALWORKFLOWEXECUTIONCANCELREQUESTED = 'ExternalWorkflowExecutionCancelRequested'
    LAMBDAFUNCTIONSCHEDULED = 'LambdaFunctionScheduled'
    LAMBDAFUNCTIONSTARTED = 'LambdaFunctionStarted'
    LAMBDAFUNCTIONCOMPLETED = 'LambdaFunctionCompleted'
    LAMBDAFUNCTIONFAILED = 'LambdaFunctionFailed'
    LAMBDAFUNCTIONTIMEDOUT = 'LambdaFunctionTimedOut'
    SCHEDULELAMBDAFUNCTIONFAILED = 'ScheduleLambdaFunctionFailed'
    STARTLAMBDAFUNCTIONFAILED = 'StartLambdaFunctionFailed'

    def __init__(self):
        """EventType - a model defined in OpenAPI

        """
        self.openapi_types = {
        }

        self.attribute_map = {
        }

    @classmethod
    def from_dict(cls, dikt: dict) -> 'EventType':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The EventType of this EventType.
        """
        return util.deserialize_model(dikt, cls)
