/*
 * Amazon Connect Wisdom Service
 * Amazon Connect Wisdom delivers agents the information they need to solve customer issues as they're actively speaking with customers. Agents can search across connected repositories from within their agent desktop to find answers quickly. Use Amazon Connect Wisdom to create an assistant and a knowledge base, for example, or manage content by uploading custom files.
 *
 * The version of the OpenAPI document: 2020-10-19
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateContentRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:01:30.807270-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateContentRequest {
  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_OVERRIDE_LINK_OUT_URI = "overrideLinkOutUri";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_LINK_OUT_URI)
  private String overrideLinkOutUri;

  public static final String SERIALIZED_NAME_REMOVE_OVERRIDE_LINK_OUT_URI = "removeOverrideLinkOutUri";
  @SerializedName(SERIALIZED_NAME_REMOVE_OVERRIDE_LINK_OUT_URI)
  private Boolean removeOverrideLinkOutUri;

  public static final String SERIALIZED_NAME_REVISION_ID = "revisionId";
  @SerializedName(SERIALIZED_NAME_REVISION_ID)
  private String revisionId;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_UPLOAD_ID = "uploadId";
  @SerializedName(SERIALIZED_NAME_UPLOAD_ID)
  private String uploadId;

  public UpdateContentRequest() {
  }

  public UpdateContentRequest metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public UpdateContentRequest putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public UpdateContentRequest overrideLinkOutUri(String overrideLinkOutUri) {
    this.overrideLinkOutUri = overrideLinkOutUri;
    return this;
  }

  /**
   * The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing &lt;code&gt;overrideLinkOurUri&lt;/code&gt;, exclude this argument and set &lt;code&gt;removeOverrideLinkOutUri&lt;/code&gt; to true.
   * @return overrideLinkOutUri
   */
  @javax.annotation.Nullable
  public String getOverrideLinkOutUri() {
    return overrideLinkOutUri;
  }

  public void setOverrideLinkOutUri(String overrideLinkOutUri) {
    this.overrideLinkOutUri = overrideLinkOutUri;
  }


  public UpdateContentRequest removeOverrideLinkOutUri(Boolean removeOverrideLinkOutUri) {
    this.removeOverrideLinkOutUri = removeOverrideLinkOutUri;
    return this;
  }

  /**
   * Unset the existing &lt;code&gt;overrideLinkOutUri&lt;/code&gt; if it exists.
   * @return removeOverrideLinkOutUri
   */
  @javax.annotation.Nullable
  public Boolean getRemoveOverrideLinkOutUri() {
    return removeOverrideLinkOutUri;
  }

  public void setRemoveOverrideLinkOutUri(Boolean removeOverrideLinkOutUri) {
    this.removeOverrideLinkOutUri = removeOverrideLinkOutUri;
  }


  public UpdateContentRequest revisionId(String revisionId) {
    this.revisionId = revisionId;
    return this;
  }

  /**
   * The &lt;code&gt;revisionId&lt;/code&gt; of the content resource to update, taken from an earlier call to &lt;code&gt;GetContent&lt;/code&gt;, &lt;code&gt;GetContentSummary&lt;/code&gt;, &lt;code&gt;SearchContent&lt;/code&gt;, or &lt;code&gt;ListContents&lt;/code&gt;. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a &lt;code&gt;PreconditionFailedException&lt;/code&gt;.
   * @return revisionId
   */
  @javax.annotation.Nullable
  public String getRevisionId() {
    return revisionId;
  }

  public void setRevisionId(String revisionId) {
    this.revisionId = revisionId;
  }


  public UpdateContentRequest title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the content.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public UpdateContentRequest uploadId(String uploadId) {
    this.uploadId = uploadId;
    return this;
  }

  /**
   * A pointer to the uploaded asset. This value is returned by &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html\&quot;&gt;StartContentUpload&lt;/a&gt;. 
   * @return uploadId
   */
  @javax.annotation.Nullable
  public String getUploadId() {
    return uploadId;
  }

  public void setUploadId(String uploadId) {
    this.uploadId = uploadId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateContentRequest updateContentRequest = (UpdateContentRequest) o;
    return Objects.equals(this.metadata, updateContentRequest.metadata) &&
        Objects.equals(this.overrideLinkOutUri, updateContentRequest.overrideLinkOutUri) &&
        Objects.equals(this.removeOverrideLinkOutUri, updateContentRequest.removeOverrideLinkOutUri) &&
        Objects.equals(this.revisionId, updateContentRequest.revisionId) &&
        Objects.equals(this.title, updateContentRequest.title) &&
        Objects.equals(this.uploadId, updateContentRequest.uploadId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(metadata, overrideLinkOutUri, removeOverrideLinkOutUri, revisionId, title, uploadId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateContentRequest {\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    overrideLinkOutUri: ").append(toIndentedString(overrideLinkOutUri)).append("\n");
    sb.append("    removeOverrideLinkOutUri: ").append(toIndentedString(removeOverrideLinkOutUri)).append("\n");
    sb.append("    revisionId: ").append(toIndentedString(revisionId)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    uploadId: ").append(toIndentedString(uploadId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("metadata");
    openapiFields.add("overrideLinkOutUri");
    openapiFields.add("removeOverrideLinkOutUri");
    openapiFields.add("revisionId");
    openapiFields.add("title");
    openapiFields.add("uploadId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateContentRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateContentRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateContentRequest is not found in the empty JSON string", UpdateContentRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateContentRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateContentRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("overrideLinkOutUri") != null && !jsonObj.get("overrideLinkOutUri").isJsonNull()) && !jsonObj.get("overrideLinkOutUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `overrideLinkOutUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("overrideLinkOutUri").toString()));
      }
      if ((jsonObj.get("revisionId") != null && !jsonObj.get("revisionId").isJsonNull()) && !jsonObj.get("revisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionId").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      if ((jsonObj.get("uploadId") != null && !jsonObj.get("uploadId").isJsonNull()) && !jsonObj.get("uploadId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uploadId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uploadId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateContentRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateContentRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateContentRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateContentRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateContentRequest>() {
           @Override
           public void write(JsonWriter out, UpdateContentRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateContentRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateContentRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateContentRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateContentRequest
   */
  public static UpdateContentRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateContentRequest.class);
  }

  /**
   * Convert an instance of UpdateContentRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

