/*
 * AWS CodeBuild
 * <fullname>CodeBuild</fullname> <p>CodeBuild is a fully managed build service in the cloud. CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. CodeBuild eliminates the need to provision, manage, and scale your own build servers. It provides prepackaged build environments for the most popular programming languages and build tools, such as Apache Maven, Gradle, and more. You can also fully customize build environments in CodeBuild to use your own build tools. CodeBuild scales automatically to meet peak build requests. You pay only for the build time you consume. For more information about CodeBuild, see the <i> <a href=\"https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html\">CodeBuild User Guide</a>.</i> </p>
 *
 * The version of the OpenAPI document: 2016-10-06
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BuildBatchArtifacts;
import org.openapitools.client.model.LogsConfig;
import org.openapitools.client.model.ProjectBuildBatchConfig;
import org.openapitools.client.model.ProjectCache;
import org.openapitools.client.model.ProjectEnvironment;
import org.openapitools.client.model.ProjectSource;
import org.openapitools.client.model.StatusType;
import org.openapitools.client.model.VpcConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * StartBuildBatchOutputBuildBatch
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:18.687160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class StartBuildBatchOutputBuildBatch {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_ARN = "arn";
  @SerializedName(SERIALIZED_NAME_ARN)
  private String arn;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private OffsetDateTime endTime;

  public static final String SERIALIZED_NAME_CURRENT_PHASE = "currentPhase";
  @SerializedName(SERIALIZED_NAME_CURRENT_PHASE)
  private String currentPhase;

  public static final String SERIALIZED_NAME_BUILD_BATCH_STATUS = "buildBatchStatus";
  @SerializedName(SERIALIZED_NAME_BUILD_BATCH_STATUS)
  private StatusType buildBatchStatus;

  public static final String SERIALIZED_NAME_SOURCE_VERSION = "sourceVersion";
  @SerializedName(SERIALIZED_NAME_SOURCE_VERSION)
  private String sourceVersion;

  public static final String SERIALIZED_NAME_RESOLVED_SOURCE_VERSION = "resolvedSourceVersion";
  @SerializedName(SERIALIZED_NAME_RESOLVED_SOURCE_VERSION)
  private String resolvedSourceVersion;

  public static final String SERIALIZED_NAME_PROJECT_NAME = "projectName";
  @SerializedName(SERIALIZED_NAME_PROJECT_NAME)
  private String projectName;

  public static final String SERIALIZED_NAME_PHASES = "phases";
  @SerializedName(SERIALIZED_NAME_PHASES)
  private List phases;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private ProjectSource source;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCES = "secondarySources";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCES)
  private List secondarySources;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS = "secondarySourceVersions";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS)
  private List secondarySourceVersions;

  public static final String SERIALIZED_NAME_ARTIFACTS = "artifacts";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS)
  private BuildBatchArtifacts artifacts;

  public static final String SERIALIZED_NAME_SECONDARY_ARTIFACTS = "secondaryArtifacts";
  @SerializedName(SERIALIZED_NAME_SECONDARY_ARTIFACTS)
  private List secondaryArtifacts;

  public static final String SERIALIZED_NAME_CACHE = "cache";
  @SerializedName(SERIALIZED_NAME_CACHE)
  private ProjectCache cache;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private ProjectEnvironment environment;

  public static final String SERIALIZED_NAME_SERVICE_ROLE = "serviceRole";
  @SerializedName(SERIALIZED_NAME_SERVICE_ROLE)
  private String serviceRole;

  public static final String SERIALIZED_NAME_LOG_CONFIG = "logConfig";
  @SerializedName(SERIALIZED_NAME_LOG_CONFIG)
  private LogsConfig logConfig;

  public static final String SERIALIZED_NAME_BUILD_TIMEOUT_IN_MINUTES = "buildTimeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_BUILD_TIMEOUT_IN_MINUTES)
  private Integer buildTimeoutInMinutes;

  public static final String SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES = "queuedTimeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES)
  private Integer queuedTimeoutInMinutes;

  public static final String SERIALIZED_NAME_COMPLETE = "complete";
  @SerializedName(SERIALIZED_NAME_COMPLETE)
  private Boolean complete;

  public static final String SERIALIZED_NAME_INITIATOR = "initiator";
  @SerializedName(SERIALIZED_NAME_INITIATOR)
  private String initiator;

  public static final String SERIALIZED_NAME_VPC_CONFIG = "vpcConfig";
  @SerializedName(SERIALIZED_NAME_VPC_CONFIG)
  private VpcConfig vpcConfig;

  public static final String SERIALIZED_NAME_ENCRYPTION_KEY = "encryptionKey";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_KEY)
  private String encryptionKey;

  public static final String SERIALIZED_NAME_BUILD_BATCH_NUMBER = "buildBatchNumber";
  @SerializedName(SERIALIZED_NAME_BUILD_BATCH_NUMBER)
  private Integer buildBatchNumber;

  public static final String SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS = "fileSystemLocations";
  @SerializedName(SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS)
  private List fileSystemLocations;

  public static final String SERIALIZED_NAME_BUILD_BATCH_CONFIG = "buildBatchConfig";
  @SerializedName(SERIALIZED_NAME_BUILD_BATCH_CONFIG)
  private ProjectBuildBatchConfig buildBatchConfig;

  public static final String SERIALIZED_NAME_BUILD_GROUPS = "buildGroups";
  @SerializedName(SERIALIZED_NAME_BUILD_GROUPS)
  private List buildGroups;

  public static final String SERIALIZED_NAME_DEBUG_SESSION_ENABLED = "debugSessionEnabled";
  @SerializedName(SERIALIZED_NAME_DEBUG_SESSION_ENABLED)
  private Boolean debugSessionEnabled;

  public StartBuildBatchOutputBuildBatch() {
  }

  public StartBuildBatchOutputBuildBatch id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public StartBuildBatchOutputBuildBatch arn(String arn) {
    this.arn = arn;
    return this;
  }

  /**
   * Get arn
   * @return arn
   */
  @javax.annotation.Nullable
  public String getArn() {
    return arn;
  }

  public void setArn(String arn) {
    this.arn = arn;
  }


  public StartBuildBatchOutputBuildBatch startTime(OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Get startTime
   * @return startTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public StartBuildBatchOutputBuildBatch endTime(OffsetDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Get endTime
   * @return endTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(OffsetDateTime endTime) {
    this.endTime = endTime;
  }


  public StartBuildBatchOutputBuildBatch currentPhase(String currentPhase) {
    this.currentPhase = currentPhase;
    return this;
  }

  /**
   * Get currentPhase
   * @return currentPhase
   */
  @javax.annotation.Nullable
  public String getCurrentPhase() {
    return currentPhase;
  }

  public void setCurrentPhase(String currentPhase) {
    this.currentPhase = currentPhase;
  }


  public StartBuildBatchOutputBuildBatch buildBatchStatus(StatusType buildBatchStatus) {
    this.buildBatchStatus = buildBatchStatus;
    return this;
  }

  /**
   * Get buildBatchStatus
   * @return buildBatchStatus
   */
  @javax.annotation.Nullable
  public StatusType getBuildBatchStatus() {
    return buildBatchStatus;
  }

  public void setBuildBatchStatus(StatusType buildBatchStatus) {
    this.buildBatchStatus = buildBatchStatus;
  }


  public StartBuildBatchOutputBuildBatch sourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
    return this;
  }

  /**
   * Get sourceVersion
   * @return sourceVersion
   */
  @javax.annotation.Nullable
  public String getSourceVersion() {
    return sourceVersion;
  }

  public void setSourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
  }


  public StartBuildBatchOutputBuildBatch resolvedSourceVersion(String resolvedSourceVersion) {
    this.resolvedSourceVersion = resolvedSourceVersion;
    return this;
  }

  /**
   * Get resolvedSourceVersion
   * @return resolvedSourceVersion
   */
  @javax.annotation.Nullable
  public String getResolvedSourceVersion() {
    return resolvedSourceVersion;
  }

  public void setResolvedSourceVersion(String resolvedSourceVersion) {
    this.resolvedSourceVersion = resolvedSourceVersion;
  }


  public StartBuildBatchOutputBuildBatch projectName(String projectName) {
    this.projectName = projectName;
    return this;
  }

  /**
   * Get projectName
   * @return projectName
   */
  @javax.annotation.Nullable
  public String getProjectName() {
    return projectName;
  }

  public void setProjectName(String projectName) {
    this.projectName = projectName;
  }


  public StartBuildBatchOutputBuildBatch phases(List phases) {
    this.phases = phases;
    return this;
  }

  /**
   * Get phases
   * @return phases
   */
  @javax.annotation.Nullable
  public List getPhases() {
    return phases;
  }

  public void setPhases(List phases) {
    this.phases = phases;
  }


  public StartBuildBatchOutputBuildBatch source(ProjectSource source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nullable
  public ProjectSource getSource() {
    return source;
  }

  public void setSource(ProjectSource source) {
    this.source = source;
  }


  public StartBuildBatchOutputBuildBatch secondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
    return this;
  }

  /**
   * Get secondarySources
   * @return secondarySources
   */
  @javax.annotation.Nullable
  public List getSecondarySources() {
    return secondarySources;
  }

  public void setSecondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
  }


  public StartBuildBatchOutputBuildBatch secondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
    return this;
  }

  /**
   * Get secondarySourceVersions
   * @return secondarySourceVersions
   */
  @javax.annotation.Nullable
  public List getSecondarySourceVersions() {
    return secondarySourceVersions;
  }

  public void setSecondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
  }


  public StartBuildBatchOutputBuildBatch artifacts(BuildBatchArtifacts artifacts) {
    this.artifacts = artifacts;
    return this;
  }

  /**
   * Get artifacts
   * @return artifacts
   */
  @javax.annotation.Nullable
  public BuildBatchArtifacts getArtifacts() {
    return artifacts;
  }

  public void setArtifacts(BuildBatchArtifacts artifacts) {
    this.artifacts = artifacts;
  }


  public StartBuildBatchOutputBuildBatch secondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
    return this;
  }

  /**
   * Get secondaryArtifacts
   * @return secondaryArtifacts
   */
  @javax.annotation.Nullable
  public List getSecondaryArtifacts() {
    return secondaryArtifacts;
  }

  public void setSecondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
  }


  public StartBuildBatchOutputBuildBatch cache(ProjectCache cache) {
    this.cache = cache;
    return this;
  }

  /**
   * Get cache
   * @return cache
   */
  @javax.annotation.Nullable
  public ProjectCache getCache() {
    return cache;
  }

  public void setCache(ProjectCache cache) {
    this.cache = cache;
  }


  public StartBuildBatchOutputBuildBatch environment(ProjectEnvironment environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nullable
  public ProjectEnvironment getEnvironment() {
    return environment;
  }

  public void setEnvironment(ProjectEnvironment environment) {
    this.environment = environment;
  }


  public StartBuildBatchOutputBuildBatch serviceRole(String serviceRole) {
    this.serviceRole = serviceRole;
    return this;
  }

  /**
   * Get serviceRole
   * @return serviceRole
   */
  @javax.annotation.Nullable
  public String getServiceRole() {
    return serviceRole;
  }

  public void setServiceRole(String serviceRole) {
    this.serviceRole = serviceRole;
  }


  public StartBuildBatchOutputBuildBatch logConfig(LogsConfig logConfig) {
    this.logConfig = logConfig;
    return this;
  }

  /**
   * Get logConfig
   * @return logConfig
   */
  @javax.annotation.Nullable
  public LogsConfig getLogConfig() {
    return logConfig;
  }

  public void setLogConfig(LogsConfig logConfig) {
    this.logConfig = logConfig;
  }


  public StartBuildBatchOutputBuildBatch buildTimeoutInMinutes(Integer buildTimeoutInMinutes) {
    this.buildTimeoutInMinutes = buildTimeoutInMinutes;
    return this;
  }

  /**
   * Get buildTimeoutInMinutes
   * @return buildTimeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getBuildTimeoutInMinutes() {
    return buildTimeoutInMinutes;
  }

  public void setBuildTimeoutInMinutes(Integer buildTimeoutInMinutes) {
    this.buildTimeoutInMinutes = buildTimeoutInMinutes;
  }


  public StartBuildBatchOutputBuildBatch queuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
    return this;
  }

  /**
   * Get queuedTimeoutInMinutes
   * @return queuedTimeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getQueuedTimeoutInMinutes() {
    return queuedTimeoutInMinutes;
  }

  public void setQueuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
  }


  public StartBuildBatchOutputBuildBatch complete(Boolean complete) {
    this.complete = complete;
    return this;
  }

  /**
   * Get complete
   * @return complete
   */
  @javax.annotation.Nullable
  public Boolean getComplete() {
    return complete;
  }

  public void setComplete(Boolean complete) {
    this.complete = complete;
  }


  public StartBuildBatchOutputBuildBatch initiator(String initiator) {
    this.initiator = initiator;
    return this;
  }

  /**
   * Get initiator
   * @return initiator
   */
  @javax.annotation.Nullable
  public String getInitiator() {
    return initiator;
  }

  public void setInitiator(String initiator) {
    this.initiator = initiator;
  }


  public StartBuildBatchOutputBuildBatch vpcConfig(VpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
    return this;
  }

  /**
   * Get vpcConfig
   * @return vpcConfig
   */
  @javax.annotation.Nullable
  public VpcConfig getVpcConfig() {
    return vpcConfig;
  }

  public void setVpcConfig(VpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
  }


  public StartBuildBatchOutputBuildBatch encryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
    return this;
  }

  /**
   * Get encryptionKey
   * @return encryptionKey
   */
  @javax.annotation.Nullable
  public String getEncryptionKey() {
    return encryptionKey;
  }

  public void setEncryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
  }


  public StartBuildBatchOutputBuildBatch buildBatchNumber(Integer buildBatchNumber) {
    this.buildBatchNumber = buildBatchNumber;
    return this;
  }

  /**
   * Get buildBatchNumber
   * @return buildBatchNumber
   */
  @javax.annotation.Nullable
  public Integer getBuildBatchNumber() {
    return buildBatchNumber;
  }

  public void setBuildBatchNumber(Integer buildBatchNumber) {
    this.buildBatchNumber = buildBatchNumber;
  }


  public StartBuildBatchOutputBuildBatch fileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
    return this;
  }

  /**
   * Get fileSystemLocations
   * @return fileSystemLocations
   */
  @javax.annotation.Nullable
  public List getFileSystemLocations() {
    return fileSystemLocations;
  }

  public void setFileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
  }


  public StartBuildBatchOutputBuildBatch buildBatchConfig(ProjectBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
    return this;
  }

  /**
   * Get buildBatchConfig
   * @return buildBatchConfig
   */
  @javax.annotation.Nullable
  public ProjectBuildBatchConfig getBuildBatchConfig() {
    return buildBatchConfig;
  }

  public void setBuildBatchConfig(ProjectBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
  }


  public StartBuildBatchOutputBuildBatch buildGroups(List buildGroups) {
    this.buildGroups = buildGroups;
    return this;
  }

  /**
   * Get buildGroups
   * @return buildGroups
   */
  @javax.annotation.Nullable
  public List getBuildGroups() {
    return buildGroups;
  }

  public void setBuildGroups(List buildGroups) {
    this.buildGroups = buildGroups;
  }


  public StartBuildBatchOutputBuildBatch debugSessionEnabled(Boolean debugSessionEnabled) {
    this.debugSessionEnabled = debugSessionEnabled;
    return this;
  }

  /**
   * Get debugSessionEnabled
   * @return debugSessionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDebugSessionEnabled() {
    return debugSessionEnabled;
  }

  public void setDebugSessionEnabled(Boolean debugSessionEnabled) {
    this.debugSessionEnabled = debugSessionEnabled;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StartBuildBatchOutputBuildBatch startBuildBatchOutputBuildBatch = (StartBuildBatchOutputBuildBatch) o;
    return Objects.equals(this.id, startBuildBatchOutputBuildBatch.id) &&
        Objects.equals(this.arn, startBuildBatchOutputBuildBatch.arn) &&
        Objects.equals(this.startTime, startBuildBatchOutputBuildBatch.startTime) &&
        Objects.equals(this.endTime, startBuildBatchOutputBuildBatch.endTime) &&
        Objects.equals(this.currentPhase, startBuildBatchOutputBuildBatch.currentPhase) &&
        Objects.equals(this.buildBatchStatus, startBuildBatchOutputBuildBatch.buildBatchStatus) &&
        Objects.equals(this.sourceVersion, startBuildBatchOutputBuildBatch.sourceVersion) &&
        Objects.equals(this.resolvedSourceVersion, startBuildBatchOutputBuildBatch.resolvedSourceVersion) &&
        Objects.equals(this.projectName, startBuildBatchOutputBuildBatch.projectName) &&
        Objects.equals(this.phases, startBuildBatchOutputBuildBatch.phases) &&
        Objects.equals(this.source, startBuildBatchOutputBuildBatch.source) &&
        Objects.equals(this.secondarySources, startBuildBatchOutputBuildBatch.secondarySources) &&
        Objects.equals(this.secondarySourceVersions, startBuildBatchOutputBuildBatch.secondarySourceVersions) &&
        Objects.equals(this.artifacts, startBuildBatchOutputBuildBatch.artifacts) &&
        Objects.equals(this.secondaryArtifacts, startBuildBatchOutputBuildBatch.secondaryArtifacts) &&
        Objects.equals(this.cache, startBuildBatchOutputBuildBatch.cache) &&
        Objects.equals(this.environment, startBuildBatchOutputBuildBatch.environment) &&
        Objects.equals(this.serviceRole, startBuildBatchOutputBuildBatch.serviceRole) &&
        Objects.equals(this.logConfig, startBuildBatchOutputBuildBatch.logConfig) &&
        Objects.equals(this.buildTimeoutInMinutes, startBuildBatchOutputBuildBatch.buildTimeoutInMinutes) &&
        Objects.equals(this.queuedTimeoutInMinutes, startBuildBatchOutputBuildBatch.queuedTimeoutInMinutes) &&
        Objects.equals(this.complete, startBuildBatchOutputBuildBatch.complete) &&
        Objects.equals(this.initiator, startBuildBatchOutputBuildBatch.initiator) &&
        Objects.equals(this.vpcConfig, startBuildBatchOutputBuildBatch.vpcConfig) &&
        Objects.equals(this.encryptionKey, startBuildBatchOutputBuildBatch.encryptionKey) &&
        Objects.equals(this.buildBatchNumber, startBuildBatchOutputBuildBatch.buildBatchNumber) &&
        Objects.equals(this.fileSystemLocations, startBuildBatchOutputBuildBatch.fileSystemLocations) &&
        Objects.equals(this.buildBatchConfig, startBuildBatchOutputBuildBatch.buildBatchConfig) &&
        Objects.equals(this.buildGroups, startBuildBatchOutputBuildBatch.buildGroups) &&
        Objects.equals(this.debugSessionEnabled, startBuildBatchOutputBuildBatch.debugSessionEnabled);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, arn, startTime, endTime, currentPhase, buildBatchStatus, sourceVersion, resolvedSourceVersion, projectName, phases, source, secondarySources, secondarySourceVersions, artifacts, secondaryArtifacts, cache, environment, serviceRole, logConfig, buildTimeoutInMinutes, queuedTimeoutInMinutes, complete, initiator, vpcConfig, encryptionKey, buildBatchNumber, fileSystemLocations, buildBatchConfig, buildGroups, debugSessionEnabled);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StartBuildBatchOutputBuildBatch {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    arn: ").append(toIndentedString(arn)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    currentPhase: ").append(toIndentedString(currentPhase)).append("\n");
    sb.append("    buildBatchStatus: ").append(toIndentedString(buildBatchStatus)).append("\n");
    sb.append("    sourceVersion: ").append(toIndentedString(sourceVersion)).append("\n");
    sb.append("    resolvedSourceVersion: ").append(toIndentedString(resolvedSourceVersion)).append("\n");
    sb.append("    projectName: ").append(toIndentedString(projectName)).append("\n");
    sb.append("    phases: ").append(toIndentedString(phases)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    secondarySources: ").append(toIndentedString(secondarySources)).append("\n");
    sb.append("    secondarySourceVersions: ").append(toIndentedString(secondarySourceVersions)).append("\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    secondaryArtifacts: ").append(toIndentedString(secondaryArtifacts)).append("\n");
    sb.append("    cache: ").append(toIndentedString(cache)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    serviceRole: ").append(toIndentedString(serviceRole)).append("\n");
    sb.append("    logConfig: ").append(toIndentedString(logConfig)).append("\n");
    sb.append("    buildTimeoutInMinutes: ").append(toIndentedString(buildTimeoutInMinutes)).append("\n");
    sb.append("    queuedTimeoutInMinutes: ").append(toIndentedString(queuedTimeoutInMinutes)).append("\n");
    sb.append("    complete: ").append(toIndentedString(complete)).append("\n");
    sb.append("    initiator: ").append(toIndentedString(initiator)).append("\n");
    sb.append("    vpcConfig: ").append(toIndentedString(vpcConfig)).append("\n");
    sb.append("    encryptionKey: ").append(toIndentedString(encryptionKey)).append("\n");
    sb.append("    buildBatchNumber: ").append(toIndentedString(buildBatchNumber)).append("\n");
    sb.append("    fileSystemLocations: ").append(toIndentedString(fileSystemLocations)).append("\n");
    sb.append("    buildBatchConfig: ").append(toIndentedString(buildBatchConfig)).append("\n");
    sb.append("    buildGroups: ").append(toIndentedString(buildGroups)).append("\n");
    sb.append("    debugSessionEnabled: ").append(toIndentedString(debugSessionEnabled)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("arn");
    openapiFields.add("startTime");
    openapiFields.add("endTime");
    openapiFields.add("currentPhase");
    openapiFields.add("buildBatchStatus");
    openapiFields.add("sourceVersion");
    openapiFields.add("resolvedSourceVersion");
    openapiFields.add("projectName");
    openapiFields.add("phases");
    openapiFields.add("source");
    openapiFields.add("secondarySources");
    openapiFields.add("secondarySourceVersions");
    openapiFields.add("artifacts");
    openapiFields.add("secondaryArtifacts");
    openapiFields.add("cache");
    openapiFields.add("environment");
    openapiFields.add("serviceRole");
    openapiFields.add("logConfig");
    openapiFields.add("buildTimeoutInMinutes");
    openapiFields.add("queuedTimeoutInMinutes");
    openapiFields.add("complete");
    openapiFields.add("initiator");
    openapiFields.add("vpcConfig");
    openapiFields.add("encryptionKey");
    openapiFields.add("buildBatchNumber");
    openapiFields.add("fileSystemLocations");
    openapiFields.add("buildBatchConfig");
    openapiFields.add("buildGroups");
    openapiFields.add("debugSessionEnabled");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to StartBuildBatchOutputBuildBatch
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!StartBuildBatchOutputBuildBatch.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in StartBuildBatchOutputBuildBatch is not found in the empty JSON string", StartBuildBatchOutputBuildBatch.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!StartBuildBatchOutputBuildBatch.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `StartBuildBatchOutputBuildBatch` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `id`
      if (jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("id"));
      }
      // validate the optional field `arn`
      if (jsonObj.get("arn") != null && !jsonObj.get("arn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("arn"));
      }
      // validate the optional field `startTime`
      if (jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("startTime"));
      }
      // validate the optional field `endTime`
      if (jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("endTime"));
      }
      // validate the optional field `currentPhase`
      if (jsonObj.get("currentPhase") != null && !jsonObj.get("currentPhase").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("currentPhase"));
      }
      // validate the optional field `buildBatchStatus`
      if (jsonObj.get("buildBatchStatus") != null && !jsonObj.get("buildBatchStatus").isJsonNull()) {
        StatusType.validateJsonElement(jsonObj.get("buildBatchStatus"));
      }
      // validate the optional field `sourceVersion`
      if (jsonObj.get("sourceVersion") != null && !jsonObj.get("sourceVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("sourceVersion"));
      }
      // validate the optional field `resolvedSourceVersion`
      if (jsonObj.get("resolvedSourceVersion") != null && !jsonObj.get("resolvedSourceVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("resolvedSourceVersion"));
      }
      // validate the optional field `projectName`
      if (jsonObj.get("projectName") != null && !jsonObj.get("projectName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("projectName"));
      }
      // validate the optional field `phases`
      if (jsonObj.get("phases") != null && !jsonObj.get("phases").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("phases"));
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        ProjectSource.validateJsonElement(jsonObj.get("source"));
      }
      // validate the optional field `secondarySources`
      if (jsonObj.get("secondarySources") != null && !jsonObj.get("secondarySources").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySources"));
      }
      // validate the optional field `secondarySourceVersions`
      if (jsonObj.get("secondarySourceVersions") != null && !jsonObj.get("secondarySourceVersions").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySourceVersions"));
      }
      // validate the optional field `artifacts`
      if (jsonObj.get("artifacts") != null && !jsonObj.get("artifacts").isJsonNull()) {
        BuildBatchArtifacts.validateJsonElement(jsonObj.get("artifacts"));
      }
      // validate the optional field `secondaryArtifacts`
      if (jsonObj.get("secondaryArtifacts") != null && !jsonObj.get("secondaryArtifacts").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondaryArtifacts"));
      }
      // validate the optional field `cache`
      if (jsonObj.get("cache") != null && !jsonObj.get("cache").isJsonNull()) {
        ProjectCache.validateJsonElement(jsonObj.get("cache"));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        ProjectEnvironment.validateJsonElement(jsonObj.get("environment"));
      }
      // validate the optional field `serviceRole`
      if (jsonObj.get("serviceRole") != null && !jsonObj.get("serviceRole").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("serviceRole"));
      }
      // validate the optional field `logConfig`
      if (jsonObj.get("logConfig") != null && !jsonObj.get("logConfig").isJsonNull()) {
        LogsConfig.validateJsonElement(jsonObj.get("logConfig"));
      }
      // validate the optional field `buildTimeoutInMinutes`
      if (jsonObj.get("buildTimeoutInMinutes") != null && !jsonObj.get("buildTimeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("buildTimeoutInMinutes"));
      }
      // validate the optional field `queuedTimeoutInMinutes`
      if (jsonObj.get("queuedTimeoutInMinutes") != null && !jsonObj.get("queuedTimeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("queuedTimeoutInMinutes"));
      }
      // validate the optional field `complete`
      if (jsonObj.get("complete") != null && !jsonObj.get("complete").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("complete"));
      }
      // validate the optional field `initiator`
      if (jsonObj.get("initiator") != null && !jsonObj.get("initiator").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("initiator"));
      }
      // validate the optional field `vpcConfig`
      if (jsonObj.get("vpcConfig") != null && !jsonObj.get("vpcConfig").isJsonNull()) {
        VpcConfig.validateJsonElement(jsonObj.get("vpcConfig"));
      }
      // validate the optional field `encryptionKey`
      if (jsonObj.get("encryptionKey") != null && !jsonObj.get("encryptionKey").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("encryptionKey"));
      }
      // validate the optional field `buildBatchNumber`
      if (jsonObj.get("buildBatchNumber") != null && !jsonObj.get("buildBatchNumber").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("buildBatchNumber"));
      }
      // validate the optional field `fileSystemLocations`
      if (jsonObj.get("fileSystemLocations") != null && !jsonObj.get("fileSystemLocations").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("fileSystemLocations"));
      }
      // validate the optional field `buildBatchConfig`
      if (jsonObj.get("buildBatchConfig") != null && !jsonObj.get("buildBatchConfig").isJsonNull()) {
        ProjectBuildBatchConfig.validateJsonElement(jsonObj.get("buildBatchConfig"));
      }
      // validate the optional field `buildGroups`
      if (jsonObj.get("buildGroups") != null && !jsonObj.get("buildGroups").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("buildGroups"));
      }
      // validate the optional field `debugSessionEnabled`
      if (jsonObj.get("debugSessionEnabled") != null && !jsonObj.get("debugSessionEnabled").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("debugSessionEnabled"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!StartBuildBatchOutputBuildBatch.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'StartBuildBatchOutputBuildBatch' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<StartBuildBatchOutputBuildBatch> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(StartBuildBatchOutputBuildBatch.class));

       return (TypeAdapter<T>) new TypeAdapter<StartBuildBatchOutputBuildBatch>() {
           @Override
           public void write(JsonWriter out, StartBuildBatchOutputBuildBatch value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public StartBuildBatchOutputBuildBatch read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of StartBuildBatchOutputBuildBatch given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of StartBuildBatchOutputBuildBatch
   * @throws IOException if the JSON string is invalid with respect to StartBuildBatchOutputBuildBatch
   */
  public static StartBuildBatchOutputBuildBatch fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StartBuildBatchOutputBuildBatch.class);
  }

  /**
   * Convert an instance of StartBuildBatchOutputBuildBatch to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

