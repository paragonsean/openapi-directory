/*
 * AWS CodeBuild
 * <fullname>CodeBuild</fullname> <p>CodeBuild is a fully managed build service in the cloud. CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. CodeBuild eliminates the need to provision, manage, and scale your own build servers. It provides prepackaged build environments for the most popular programming languages and build tools, such as Apache Maven, Gradle, and more. You can also fully customize build environments in CodeBuild to use your own build tools. CodeBuild scales automatically to meet peak build requests. You pay only for the build time you consume. For more information about CodeBuild, see the <i> <a href=\"https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html\">CodeBuild User Guide</a>.</i> </p>
 *
 * The version of the OpenAPI document: 2016-10-06
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BatchReportModeType;
import org.openapitools.client.model.ProjectBuildBatchConfigRestrictions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains configuration information about a batch build project.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:18.687160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ProjectBuildBatchConfig {
  public static final String SERIALIZED_NAME_SERVICE_ROLE = "serviceRole";
  @SerializedName(SERIALIZED_NAME_SERVICE_ROLE)
  private String serviceRole;

  public static final String SERIALIZED_NAME_COMBINE_ARTIFACTS = "combineArtifacts";
  @SerializedName(SERIALIZED_NAME_COMBINE_ARTIFACTS)
  private Boolean combineArtifacts;

  public static final String SERIALIZED_NAME_RESTRICTIONS = "restrictions";
  @SerializedName(SERIALIZED_NAME_RESTRICTIONS)
  private ProjectBuildBatchConfigRestrictions restrictions;

  public static final String SERIALIZED_NAME_TIMEOUT_IN_MINS = "timeoutInMins";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_IN_MINS)
  private Integer timeoutInMins;

  public static final String SERIALIZED_NAME_BATCH_REPORT_MODE = "batchReportMode";
  @SerializedName(SERIALIZED_NAME_BATCH_REPORT_MODE)
  private BatchReportModeType batchReportMode;

  public ProjectBuildBatchConfig() {
  }

  public ProjectBuildBatchConfig serviceRole(String serviceRole) {
    this.serviceRole = serviceRole;
    return this;
  }

  /**
   * Get serviceRole
   * @return serviceRole
   */
  @javax.annotation.Nullable
  public String getServiceRole() {
    return serviceRole;
  }

  public void setServiceRole(String serviceRole) {
    this.serviceRole = serviceRole;
  }


  public ProjectBuildBatchConfig combineArtifacts(Boolean combineArtifacts) {
    this.combineArtifacts = combineArtifacts;
    return this;
  }

  /**
   * Get combineArtifacts
   * @return combineArtifacts
   */
  @javax.annotation.Nullable
  public Boolean getCombineArtifacts() {
    return combineArtifacts;
  }

  public void setCombineArtifacts(Boolean combineArtifacts) {
    this.combineArtifacts = combineArtifacts;
  }


  public ProjectBuildBatchConfig restrictions(ProjectBuildBatchConfigRestrictions restrictions) {
    this.restrictions = restrictions;
    return this;
  }

  /**
   * Get restrictions
   * @return restrictions
   */
  @javax.annotation.Nullable
  public ProjectBuildBatchConfigRestrictions getRestrictions() {
    return restrictions;
  }

  public void setRestrictions(ProjectBuildBatchConfigRestrictions restrictions) {
    this.restrictions = restrictions;
  }


  public ProjectBuildBatchConfig timeoutInMins(Integer timeoutInMins) {
    this.timeoutInMins = timeoutInMins;
    return this;
  }

  /**
   * Get timeoutInMins
   * @return timeoutInMins
   */
  @javax.annotation.Nullable
  public Integer getTimeoutInMins() {
    return timeoutInMins;
  }

  public void setTimeoutInMins(Integer timeoutInMins) {
    this.timeoutInMins = timeoutInMins;
  }


  public ProjectBuildBatchConfig batchReportMode(BatchReportModeType batchReportMode) {
    this.batchReportMode = batchReportMode;
    return this;
  }

  /**
   * Get batchReportMode
   * @return batchReportMode
   */
  @javax.annotation.Nullable
  public BatchReportModeType getBatchReportMode() {
    return batchReportMode;
  }

  public void setBatchReportMode(BatchReportModeType batchReportMode) {
    this.batchReportMode = batchReportMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProjectBuildBatchConfig projectBuildBatchConfig = (ProjectBuildBatchConfig) o;
    return Objects.equals(this.serviceRole, projectBuildBatchConfig.serviceRole) &&
        Objects.equals(this.combineArtifacts, projectBuildBatchConfig.combineArtifacts) &&
        Objects.equals(this.restrictions, projectBuildBatchConfig.restrictions) &&
        Objects.equals(this.timeoutInMins, projectBuildBatchConfig.timeoutInMins) &&
        Objects.equals(this.batchReportMode, projectBuildBatchConfig.batchReportMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(serviceRole, combineArtifacts, restrictions, timeoutInMins, batchReportMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProjectBuildBatchConfig {\n");
    sb.append("    serviceRole: ").append(toIndentedString(serviceRole)).append("\n");
    sb.append("    combineArtifacts: ").append(toIndentedString(combineArtifacts)).append("\n");
    sb.append("    restrictions: ").append(toIndentedString(restrictions)).append("\n");
    sb.append("    timeoutInMins: ").append(toIndentedString(timeoutInMins)).append("\n");
    sb.append("    batchReportMode: ").append(toIndentedString(batchReportMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("serviceRole");
    openapiFields.add("combineArtifacts");
    openapiFields.add("restrictions");
    openapiFields.add("timeoutInMins");
    openapiFields.add("batchReportMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ProjectBuildBatchConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ProjectBuildBatchConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ProjectBuildBatchConfig is not found in the empty JSON string", ProjectBuildBatchConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ProjectBuildBatchConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ProjectBuildBatchConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `serviceRole`
      if (jsonObj.get("serviceRole") != null && !jsonObj.get("serviceRole").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("serviceRole"));
      }
      // validate the optional field `combineArtifacts`
      if (jsonObj.get("combineArtifacts") != null && !jsonObj.get("combineArtifacts").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("combineArtifacts"));
      }
      // validate the optional field `restrictions`
      if (jsonObj.get("restrictions") != null && !jsonObj.get("restrictions").isJsonNull()) {
        ProjectBuildBatchConfigRestrictions.validateJsonElement(jsonObj.get("restrictions"));
      }
      // validate the optional field `timeoutInMins`
      if (jsonObj.get("timeoutInMins") != null && !jsonObj.get("timeoutInMins").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("timeoutInMins"));
      }
      // validate the optional field `batchReportMode`
      if (jsonObj.get("batchReportMode") != null && !jsonObj.get("batchReportMode").isJsonNull()) {
        BatchReportModeType.validateJsonElement(jsonObj.get("batchReportMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ProjectBuildBatchConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ProjectBuildBatchConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ProjectBuildBatchConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ProjectBuildBatchConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ProjectBuildBatchConfig>() {
           @Override
           public void write(JsonWriter out, ProjectBuildBatchConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ProjectBuildBatchConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ProjectBuildBatchConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ProjectBuildBatchConfig
   * @throws IOException if the JSON string is invalid with respect to ProjectBuildBatchConfig
   */
  public static ProjectBuildBatchConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ProjectBuildBatchConfig.class);
  }

  /**
   * Convert an instance of ProjectBuildBatchConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

