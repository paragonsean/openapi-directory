/*
 * AWS CodeBuild
 * <fullname>CodeBuild</fullname> <p>CodeBuild is a fully managed build service in the cloud. CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. CodeBuild eliminates the need to provision, manage, and scale your own build servers. It provides prepackaged build environments for the most popular programming languages and build tools, such as Apache Maven, Gradle, and more. You can also fully customize build environments in CodeBuild to use your own build tools. CodeBuild scales automatically to meet peak build requests. You pay only for the build time you consume. For more information about CodeBuild, see the <i> <a href=\"https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html\">CodeBuild User Guide</a>.</i> </p>
 *
 * The version of the OpenAPI document: 2016-10-06
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CreateProjectInputArtifacts;
import org.openapitools.client.model.CreateProjectInputBuildBatchConfig;
import org.openapitools.client.model.CreateProjectInputCache;
import org.openapitools.client.model.CreateProjectInputEnvironment;
import org.openapitools.client.model.CreateProjectInputLogsConfig;
import org.openapitools.client.model.CreateProjectInputSource;
import org.openapitools.client.model.CreateProjectInputVpcConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateProjectInput
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:18.687160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateProjectInput {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private CreateProjectInputSource source;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCES = "secondarySources";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCES)
  private List secondarySources;

  public static final String SERIALIZED_NAME_SOURCE_VERSION = "sourceVersion";
  @SerializedName(SERIALIZED_NAME_SOURCE_VERSION)
  private String sourceVersion;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS = "secondarySourceVersions";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS)
  private List secondarySourceVersions;

  public static final String SERIALIZED_NAME_ARTIFACTS = "artifacts";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS)
  private CreateProjectInputArtifacts artifacts;

  public static final String SERIALIZED_NAME_SECONDARY_ARTIFACTS = "secondaryArtifacts";
  @SerializedName(SERIALIZED_NAME_SECONDARY_ARTIFACTS)
  private List secondaryArtifacts;

  public static final String SERIALIZED_NAME_CACHE = "cache";
  @SerializedName(SERIALIZED_NAME_CACHE)
  private CreateProjectInputCache cache;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private CreateProjectInputEnvironment environment;

  public static final String SERIALIZED_NAME_SERVICE_ROLE = "serviceRole";
  @SerializedName(SERIALIZED_NAME_SERVICE_ROLE)
  private String serviceRole;

  public static final String SERIALIZED_NAME_TIMEOUT_IN_MINUTES = "timeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_IN_MINUTES)
  private Integer timeoutInMinutes;

  public static final String SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES = "queuedTimeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES)
  private Integer queuedTimeoutInMinutes;

  public static final String SERIALIZED_NAME_ENCRYPTION_KEY = "encryptionKey";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_KEY)
  private String encryptionKey;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List tags;

  public static final String SERIALIZED_NAME_VPC_CONFIG = "vpcConfig";
  @SerializedName(SERIALIZED_NAME_VPC_CONFIG)
  private CreateProjectInputVpcConfig vpcConfig;

  public static final String SERIALIZED_NAME_BADGE_ENABLED = "badgeEnabled";
  @SerializedName(SERIALIZED_NAME_BADGE_ENABLED)
  private Boolean badgeEnabled;

  public static final String SERIALIZED_NAME_LOGS_CONFIG = "logsConfig";
  @SerializedName(SERIALIZED_NAME_LOGS_CONFIG)
  private CreateProjectInputLogsConfig logsConfig;

  public static final String SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS = "fileSystemLocations";
  @SerializedName(SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS)
  private List fileSystemLocations;

  public static final String SERIALIZED_NAME_BUILD_BATCH_CONFIG = "buildBatchConfig";
  @SerializedName(SERIALIZED_NAME_BUILD_BATCH_CONFIG)
  private CreateProjectInputBuildBatchConfig buildBatchConfig;

  public static final String SERIALIZED_NAME_CONCURRENT_BUILD_LIMIT = "concurrentBuildLimit";
  @SerializedName(SERIALIZED_NAME_CONCURRENT_BUILD_LIMIT)
  private Integer concurrentBuildLimit;

  public CreateProjectInput() {
  }

  public CreateProjectInput name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public CreateProjectInput description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public CreateProjectInput source(CreateProjectInputSource source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nonnull
  public CreateProjectInputSource getSource() {
    return source;
  }

  public void setSource(CreateProjectInputSource source) {
    this.source = source;
  }


  public CreateProjectInput secondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
    return this;
  }

  /**
   * Get secondarySources
   * @return secondarySources
   */
  @javax.annotation.Nullable
  public List getSecondarySources() {
    return secondarySources;
  }

  public void setSecondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
  }


  public CreateProjectInput sourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
    return this;
  }

  /**
   * Get sourceVersion
   * @return sourceVersion
   */
  @javax.annotation.Nullable
  public String getSourceVersion() {
    return sourceVersion;
  }

  public void setSourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
  }


  public CreateProjectInput secondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
    return this;
  }

  /**
   * Get secondarySourceVersions
   * @return secondarySourceVersions
   */
  @javax.annotation.Nullable
  public List getSecondarySourceVersions() {
    return secondarySourceVersions;
  }

  public void setSecondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
  }


  public CreateProjectInput artifacts(CreateProjectInputArtifacts artifacts) {
    this.artifacts = artifacts;
    return this;
  }

  /**
   * Get artifacts
   * @return artifacts
   */
  @javax.annotation.Nonnull
  public CreateProjectInputArtifacts getArtifacts() {
    return artifacts;
  }

  public void setArtifacts(CreateProjectInputArtifacts artifacts) {
    this.artifacts = artifacts;
  }


  public CreateProjectInput secondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
    return this;
  }

  /**
   * Get secondaryArtifacts
   * @return secondaryArtifacts
   */
  @javax.annotation.Nullable
  public List getSecondaryArtifacts() {
    return secondaryArtifacts;
  }

  public void setSecondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
  }


  public CreateProjectInput cache(CreateProjectInputCache cache) {
    this.cache = cache;
    return this;
  }

  /**
   * Get cache
   * @return cache
   */
  @javax.annotation.Nullable
  public CreateProjectInputCache getCache() {
    return cache;
  }

  public void setCache(CreateProjectInputCache cache) {
    this.cache = cache;
  }


  public CreateProjectInput environment(CreateProjectInputEnvironment environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nonnull
  public CreateProjectInputEnvironment getEnvironment() {
    return environment;
  }

  public void setEnvironment(CreateProjectInputEnvironment environment) {
    this.environment = environment;
  }


  public CreateProjectInput serviceRole(String serviceRole) {
    this.serviceRole = serviceRole;
    return this;
  }

  /**
   * Get serviceRole
   * @return serviceRole
   */
  @javax.annotation.Nonnull
  public String getServiceRole() {
    return serviceRole;
  }

  public void setServiceRole(String serviceRole) {
    this.serviceRole = serviceRole;
  }


  public CreateProjectInput timeoutInMinutes(Integer timeoutInMinutes) {
    this.timeoutInMinutes = timeoutInMinutes;
    return this;
  }

  /**
   * Get timeoutInMinutes
   * @return timeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getTimeoutInMinutes() {
    return timeoutInMinutes;
  }

  public void setTimeoutInMinutes(Integer timeoutInMinutes) {
    this.timeoutInMinutes = timeoutInMinutes;
  }


  public CreateProjectInput queuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
    return this;
  }

  /**
   * Get queuedTimeoutInMinutes
   * @return queuedTimeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getQueuedTimeoutInMinutes() {
    return queuedTimeoutInMinutes;
  }

  public void setQueuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
  }


  public CreateProjectInput encryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
    return this;
  }

  /**
   * Get encryptionKey
   * @return encryptionKey
   */
  @javax.annotation.Nullable
  public String getEncryptionKey() {
    return encryptionKey;
  }

  public void setEncryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
  }


  public CreateProjectInput tags(List tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Get tags
   * @return tags
   */
  @javax.annotation.Nullable
  public List getTags() {
    return tags;
  }

  public void setTags(List tags) {
    this.tags = tags;
  }


  public CreateProjectInput vpcConfig(CreateProjectInputVpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
    return this;
  }

  /**
   * Get vpcConfig
   * @return vpcConfig
   */
  @javax.annotation.Nullable
  public CreateProjectInputVpcConfig getVpcConfig() {
    return vpcConfig;
  }

  public void setVpcConfig(CreateProjectInputVpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
  }


  public CreateProjectInput badgeEnabled(Boolean badgeEnabled) {
    this.badgeEnabled = badgeEnabled;
    return this;
  }

  /**
   * Get badgeEnabled
   * @return badgeEnabled
   */
  @javax.annotation.Nullable
  public Boolean getBadgeEnabled() {
    return badgeEnabled;
  }

  public void setBadgeEnabled(Boolean badgeEnabled) {
    this.badgeEnabled = badgeEnabled;
  }


  public CreateProjectInput logsConfig(CreateProjectInputLogsConfig logsConfig) {
    this.logsConfig = logsConfig;
    return this;
  }

  /**
   * Get logsConfig
   * @return logsConfig
   */
  @javax.annotation.Nullable
  public CreateProjectInputLogsConfig getLogsConfig() {
    return logsConfig;
  }

  public void setLogsConfig(CreateProjectInputLogsConfig logsConfig) {
    this.logsConfig = logsConfig;
  }


  public CreateProjectInput fileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
    return this;
  }

  /**
   * Get fileSystemLocations
   * @return fileSystemLocations
   */
  @javax.annotation.Nullable
  public List getFileSystemLocations() {
    return fileSystemLocations;
  }

  public void setFileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
  }


  public CreateProjectInput buildBatchConfig(CreateProjectInputBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
    return this;
  }

  /**
   * Get buildBatchConfig
   * @return buildBatchConfig
   */
  @javax.annotation.Nullable
  public CreateProjectInputBuildBatchConfig getBuildBatchConfig() {
    return buildBatchConfig;
  }

  public void setBuildBatchConfig(CreateProjectInputBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
  }


  public CreateProjectInput concurrentBuildLimit(Integer concurrentBuildLimit) {
    this.concurrentBuildLimit = concurrentBuildLimit;
    return this;
  }

  /**
   * Get concurrentBuildLimit
   * @return concurrentBuildLimit
   */
  @javax.annotation.Nullable
  public Integer getConcurrentBuildLimit() {
    return concurrentBuildLimit;
  }

  public void setConcurrentBuildLimit(Integer concurrentBuildLimit) {
    this.concurrentBuildLimit = concurrentBuildLimit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateProjectInput createProjectInput = (CreateProjectInput) o;
    return Objects.equals(this.name, createProjectInput.name) &&
        Objects.equals(this.description, createProjectInput.description) &&
        Objects.equals(this.source, createProjectInput.source) &&
        Objects.equals(this.secondarySources, createProjectInput.secondarySources) &&
        Objects.equals(this.sourceVersion, createProjectInput.sourceVersion) &&
        Objects.equals(this.secondarySourceVersions, createProjectInput.secondarySourceVersions) &&
        Objects.equals(this.artifacts, createProjectInput.artifacts) &&
        Objects.equals(this.secondaryArtifacts, createProjectInput.secondaryArtifacts) &&
        Objects.equals(this.cache, createProjectInput.cache) &&
        Objects.equals(this.environment, createProjectInput.environment) &&
        Objects.equals(this.serviceRole, createProjectInput.serviceRole) &&
        Objects.equals(this.timeoutInMinutes, createProjectInput.timeoutInMinutes) &&
        Objects.equals(this.queuedTimeoutInMinutes, createProjectInput.queuedTimeoutInMinutes) &&
        Objects.equals(this.encryptionKey, createProjectInput.encryptionKey) &&
        Objects.equals(this.tags, createProjectInput.tags) &&
        Objects.equals(this.vpcConfig, createProjectInput.vpcConfig) &&
        Objects.equals(this.badgeEnabled, createProjectInput.badgeEnabled) &&
        Objects.equals(this.logsConfig, createProjectInput.logsConfig) &&
        Objects.equals(this.fileSystemLocations, createProjectInput.fileSystemLocations) &&
        Objects.equals(this.buildBatchConfig, createProjectInput.buildBatchConfig) &&
        Objects.equals(this.concurrentBuildLimit, createProjectInput.concurrentBuildLimit);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, source, secondarySources, sourceVersion, secondarySourceVersions, artifacts, secondaryArtifacts, cache, environment, serviceRole, timeoutInMinutes, queuedTimeoutInMinutes, encryptionKey, tags, vpcConfig, badgeEnabled, logsConfig, fileSystemLocations, buildBatchConfig, concurrentBuildLimit);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateProjectInput {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    secondarySources: ").append(toIndentedString(secondarySources)).append("\n");
    sb.append("    sourceVersion: ").append(toIndentedString(sourceVersion)).append("\n");
    sb.append("    secondarySourceVersions: ").append(toIndentedString(secondarySourceVersions)).append("\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    secondaryArtifacts: ").append(toIndentedString(secondaryArtifacts)).append("\n");
    sb.append("    cache: ").append(toIndentedString(cache)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    serviceRole: ").append(toIndentedString(serviceRole)).append("\n");
    sb.append("    timeoutInMinutes: ").append(toIndentedString(timeoutInMinutes)).append("\n");
    sb.append("    queuedTimeoutInMinutes: ").append(toIndentedString(queuedTimeoutInMinutes)).append("\n");
    sb.append("    encryptionKey: ").append(toIndentedString(encryptionKey)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    vpcConfig: ").append(toIndentedString(vpcConfig)).append("\n");
    sb.append("    badgeEnabled: ").append(toIndentedString(badgeEnabled)).append("\n");
    sb.append("    logsConfig: ").append(toIndentedString(logsConfig)).append("\n");
    sb.append("    fileSystemLocations: ").append(toIndentedString(fileSystemLocations)).append("\n");
    sb.append("    buildBatchConfig: ").append(toIndentedString(buildBatchConfig)).append("\n");
    sb.append("    concurrentBuildLimit: ").append(toIndentedString(concurrentBuildLimit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("source");
    openapiFields.add("secondarySources");
    openapiFields.add("sourceVersion");
    openapiFields.add("secondarySourceVersions");
    openapiFields.add("artifacts");
    openapiFields.add("secondaryArtifacts");
    openapiFields.add("cache");
    openapiFields.add("environment");
    openapiFields.add("serviceRole");
    openapiFields.add("timeoutInMinutes");
    openapiFields.add("queuedTimeoutInMinutes");
    openapiFields.add("encryptionKey");
    openapiFields.add("tags");
    openapiFields.add("vpcConfig");
    openapiFields.add("badgeEnabled");
    openapiFields.add("logsConfig");
    openapiFields.add("fileSystemLocations");
    openapiFields.add("buildBatchConfig");
    openapiFields.add("concurrentBuildLimit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("source");
    openapiRequiredFields.add("artifacts");
    openapiRequiredFields.add("environment");
    openapiRequiredFields.add("serviceRole");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateProjectInput
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateProjectInput.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateProjectInput is not found in the empty JSON string", CreateProjectInput.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateProjectInput.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateProjectInput` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateProjectInput.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `name`
      String.validateJsonElement(jsonObj.get("name"));
      // validate the optional field `description`
      if (jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("description"));
      }
      // validate the required field `source`
      CreateProjectInputSource.validateJsonElement(jsonObj.get("source"));
      // validate the optional field `secondarySources`
      if (jsonObj.get("secondarySources") != null && !jsonObj.get("secondarySources").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySources"));
      }
      // validate the optional field `sourceVersion`
      if (jsonObj.get("sourceVersion") != null && !jsonObj.get("sourceVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("sourceVersion"));
      }
      // validate the optional field `secondarySourceVersions`
      if (jsonObj.get("secondarySourceVersions") != null && !jsonObj.get("secondarySourceVersions").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySourceVersions"));
      }
      // validate the required field `artifacts`
      CreateProjectInputArtifacts.validateJsonElement(jsonObj.get("artifacts"));
      // validate the optional field `secondaryArtifacts`
      if (jsonObj.get("secondaryArtifacts") != null && !jsonObj.get("secondaryArtifacts").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondaryArtifacts"));
      }
      // validate the optional field `cache`
      if (jsonObj.get("cache") != null && !jsonObj.get("cache").isJsonNull()) {
        CreateProjectInputCache.validateJsonElement(jsonObj.get("cache"));
      }
      // validate the required field `environment`
      CreateProjectInputEnvironment.validateJsonElement(jsonObj.get("environment"));
      // validate the required field `serviceRole`
      String.validateJsonElement(jsonObj.get("serviceRole"));
      // validate the optional field `timeoutInMinutes`
      if (jsonObj.get("timeoutInMinutes") != null && !jsonObj.get("timeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("timeoutInMinutes"));
      }
      // validate the optional field `queuedTimeoutInMinutes`
      if (jsonObj.get("queuedTimeoutInMinutes") != null && !jsonObj.get("queuedTimeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("queuedTimeoutInMinutes"));
      }
      // validate the optional field `encryptionKey`
      if (jsonObj.get("encryptionKey") != null && !jsonObj.get("encryptionKey").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("encryptionKey"));
      }
      // validate the optional field `tags`
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("tags"));
      }
      // validate the optional field `vpcConfig`
      if (jsonObj.get("vpcConfig") != null && !jsonObj.get("vpcConfig").isJsonNull()) {
        CreateProjectInputVpcConfig.validateJsonElement(jsonObj.get("vpcConfig"));
      }
      // validate the optional field `badgeEnabled`
      if (jsonObj.get("badgeEnabled") != null && !jsonObj.get("badgeEnabled").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("badgeEnabled"));
      }
      // validate the optional field `logsConfig`
      if (jsonObj.get("logsConfig") != null && !jsonObj.get("logsConfig").isJsonNull()) {
        CreateProjectInputLogsConfig.validateJsonElement(jsonObj.get("logsConfig"));
      }
      // validate the optional field `fileSystemLocations`
      if (jsonObj.get("fileSystemLocations") != null && !jsonObj.get("fileSystemLocations").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("fileSystemLocations"));
      }
      // validate the optional field `buildBatchConfig`
      if (jsonObj.get("buildBatchConfig") != null && !jsonObj.get("buildBatchConfig").isJsonNull()) {
        CreateProjectInputBuildBatchConfig.validateJsonElement(jsonObj.get("buildBatchConfig"));
      }
      // validate the optional field `concurrentBuildLimit`
      if (jsonObj.get("concurrentBuildLimit") != null && !jsonObj.get("concurrentBuildLimit").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("concurrentBuildLimit"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateProjectInput.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateProjectInput' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateProjectInput> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateProjectInput.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateProjectInput>() {
           @Override
           public void write(JsonWriter out, CreateProjectInput value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateProjectInput read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateProjectInput given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateProjectInput
   * @throws IOException if the JSON string is invalid with respect to CreateProjectInput
   */
  public static CreateProjectInput fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateProjectInput.class);
  }

  /**
   * Convert an instance of CreateProjectInput to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

