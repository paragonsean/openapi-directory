/*
 * AWS CodeBuild
 * <fullname>CodeBuild</fullname> <p>CodeBuild is a fully managed build service in the cloud. CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. CodeBuild eliminates the need to provision, manage, and scale your own build servers. It provides prepackaged build environments for the most popular programming languages and build tools, such as Apache Maven, Gradle, and more. You can also fully customize build environments in CodeBuild to use your own build tools. CodeBuild scales automatically to meet peak build requests. You pay only for the build time you consume. For more information about CodeBuild, see the <i> <a href=\"https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html\">CodeBuild User Guide</a>.</i> </p>
 *
 * The version of the OpenAPI document: 2016-10-06
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CreateProjectInputCache;
import org.openapitools.client.model.CreateProjectInputVpcConfig;
import org.openapitools.client.model.ProjectBuildBatchConfig;
import org.openapitools.client.model.UpdateProjectInputArtifacts;
import org.openapitools.client.model.UpdateProjectInputEnvironment;
import org.openapitools.client.model.UpdateProjectInputLogsConfig;
import org.openapitools.client.model.UpdateProjectInputSource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateProjectInput
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:18.687160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateProjectInput {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private UpdateProjectInputSource source;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCES = "secondarySources";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCES)
  private List secondarySources;

  public static final String SERIALIZED_NAME_SOURCE_VERSION = "sourceVersion";
  @SerializedName(SERIALIZED_NAME_SOURCE_VERSION)
  private String sourceVersion;

  public static final String SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS = "secondarySourceVersions";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOURCE_VERSIONS)
  private List secondarySourceVersions;

  public static final String SERIALIZED_NAME_ARTIFACTS = "artifacts";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS)
  private UpdateProjectInputArtifacts artifacts;

  public static final String SERIALIZED_NAME_SECONDARY_ARTIFACTS = "secondaryArtifacts";
  @SerializedName(SERIALIZED_NAME_SECONDARY_ARTIFACTS)
  private List secondaryArtifacts;

  public static final String SERIALIZED_NAME_CACHE = "cache";
  @SerializedName(SERIALIZED_NAME_CACHE)
  private CreateProjectInputCache cache;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private UpdateProjectInputEnvironment environment;

  public static final String SERIALIZED_NAME_SERVICE_ROLE = "serviceRole";
  @SerializedName(SERIALIZED_NAME_SERVICE_ROLE)
  private String serviceRole;

  public static final String SERIALIZED_NAME_TIMEOUT_IN_MINUTES = "timeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_IN_MINUTES)
  private Integer timeoutInMinutes;

  public static final String SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES = "queuedTimeoutInMinutes";
  @SerializedName(SERIALIZED_NAME_QUEUED_TIMEOUT_IN_MINUTES)
  private Integer queuedTimeoutInMinutes;

  public static final String SERIALIZED_NAME_ENCRYPTION_KEY = "encryptionKey";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_KEY)
  private String encryptionKey;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List tags;

  public static final String SERIALIZED_NAME_VPC_CONFIG = "vpcConfig";
  @SerializedName(SERIALIZED_NAME_VPC_CONFIG)
  private CreateProjectInputVpcConfig vpcConfig;

  public static final String SERIALIZED_NAME_BADGE_ENABLED = "badgeEnabled";
  @SerializedName(SERIALIZED_NAME_BADGE_ENABLED)
  private Boolean badgeEnabled;

  public static final String SERIALIZED_NAME_LOGS_CONFIG = "logsConfig";
  @SerializedName(SERIALIZED_NAME_LOGS_CONFIG)
  private UpdateProjectInputLogsConfig logsConfig;

  public static final String SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS = "fileSystemLocations";
  @SerializedName(SERIALIZED_NAME_FILE_SYSTEM_LOCATIONS)
  private List fileSystemLocations;

  public static final String SERIALIZED_NAME_BUILD_BATCH_CONFIG = "buildBatchConfig";
  @SerializedName(SERIALIZED_NAME_BUILD_BATCH_CONFIG)
  private ProjectBuildBatchConfig buildBatchConfig;

  public static final String SERIALIZED_NAME_CONCURRENT_BUILD_LIMIT = "concurrentBuildLimit";
  @SerializedName(SERIALIZED_NAME_CONCURRENT_BUILD_LIMIT)
  private Integer concurrentBuildLimit;

  public UpdateProjectInput() {
  }

  public UpdateProjectInput name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public UpdateProjectInput description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public UpdateProjectInput source(UpdateProjectInputSource source) {
    this.source = source;
    return this;
  }

  /**
   * Get source
   * @return source
   */
  @javax.annotation.Nullable
  public UpdateProjectInputSource getSource() {
    return source;
  }

  public void setSource(UpdateProjectInputSource source) {
    this.source = source;
  }


  public UpdateProjectInput secondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
    return this;
  }

  /**
   * Get secondarySources
   * @return secondarySources
   */
  @javax.annotation.Nullable
  public List getSecondarySources() {
    return secondarySources;
  }

  public void setSecondarySources(List secondarySources) {
    this.secondarySources = secondarySources;
  }


  public UpdateProjectInput sourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
    return this;
  }

  /**
   * Get sourceVersion
   * @return sourceVersion
   */
  @javax.annotation.Nullable
  public String getSourceVersion() {
    return sourceVersion;
  }

  public void setSourceVersion(String sourceVersion) {
    this.sourceVersion = sourceVersion;
  }


  public UpdateProjectInput secondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
    return this;
  }

  /**
   * Get secondarySourceVersions
   * @return secondarySourceVersions
   */
  @javax.annotation.Nullable
  public List getSecondarySourceVersions() {
    return secondarySourceVersions;
  }

  public void setSecondarySourceVersions(List secondarySourceVersions) {
    this.secondarySourceVersions = secondarySourceVersions;
  }


  public UpdateProjectInput artifacts(UpdateProjectInputArtifacts artifacts) {
    this.artifacts = artifacts;
    return this;
  }

  /**
   * Get artifacts
   * @return artifacts
   */
  @javax.annotation.Nullable
  public UpdateProjectInputArtifacts getArtifacts() {
    return artifacts;
  }

  public void setArtifacts(UpdateProjectInputArtifacts artifacts) {
    this.artifacts = artifacts;
  }


  public UpdateProjectInput secondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
    return this;
  }

  /**
   * Get secondaryArtifacts
   * @return secondaryArtifacts
   */
  @javax.annotation.Nullable
  public List getSecondaryArtifacts() {
    return secondaryArtifacts;
  }

  public void setSecondaryArtifacts(List secondaryArtifacts) {
    this.secondaryArtifacts = secondaryArtifacts;
  }


  public UpdateProjectInput cache(CreateProjectInputCache cache) {
    this.cache = cache;
    return this;
  }

  /**
   * Get cache
   * @return cache
   */
  @javax.annotation.Nullable
  public CreateProjectInputCache getCache() {
    return cache;
  }

  public void setCache(CreateProjectInputCache cache) {
    this.cache = cache;
  }


  public UpdateProjectInput environment(UpdateProjectInputEnvironment environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nullable
  public UpdateProjectInputEnvironment getEnvironment() {
    return environment;
  }

  public void setEnvironment(UpdateProjectInputEnvironment environment) {
    this.environment = environment;
  }


  public UpdateProjectInput serviceRole(String serviceRole) {
    this.serviceRole = serviceRole;
    return this;
  }

  /**
   * Get serviceRole
   * @return serviceRole
   */
  @javax.annotation.Nullable
  public String getServiceRole() {
    return serviceRole;
  }

  public void setServiceRole(String serviceRole) {
    this.serviceRole = serviceRole;
  }


  public UpdateProjectInput timeoutInMinutes(Integer timeoutInMinutes) {
    this.timeoutInMinutes = timeoutInMinutes;
    return this;
  }

  /**
   * Get timeoutInMinutes
   * @return timeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getTimeoutInMinutes() {
    return timeoutInMinutes;
  }

  public void setTimeoutInMinutes(Integer timeoutInMinutes) {
    this.timeoutInMinutes = timeoutInMinutes;
  }


  public UpdateProjectInput queuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
    return this;
  }

  /**
   * Get queuedTimeoutInMinutes
   * @return queuedTimeoutInMinutes
   */
  @javax.annotation.Nullable
  public Integer getQueuedTimeoutInMinutes() {
    return queuedTimeoutInMinutes;
  }

  public void setQueuedTimeoutInMinutes(Integer queuedTimeoutInMinutes) {
    this.queuedTimeoutInMinutes = queuedTimeoutInMinutes;
  }


  public UpdateProjectInput encryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
    return this;
  }

  /**
   * Get encryptionKey
   * @return encryptionKey
   */
  @javax.annotation.Nullable
  public String getEncryptionKey() {
    return encryptionKey;
  }

  public void setEncryptionKey(String encryptionKey) {
    this.encryptionKey = encryptionKey;
  }


  public UpdateProjectInput tags(List tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Get tags
   * @return tags
   */
  @javax.annotation.Nullable
  public List getTags() {
    return tags;
  }

  public void setTags(List tags) {
    this.tags = tags;
  }


  public UpdateProjectInput vpcConfig(CreateProjectInputVpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
    return this;
  }

  /**
   * Get vpcConfig
   * @return vpcConfig
   */
  @javax.annotation.Nullable
  public CreateProjectInputVpcConfig getVpcConfig() {
    return vpcConfig;
  }

  public void setVpcConfig(CreateProjectInputVpcConfig vpcConfig) {
    this.vpcConfig = vpcConfig;
  }


  public UpdateProjectInput badgeEnabled(Boolean badgeEnabled) {
    this.badgeEnabled = badgeEnabled;
    return this;
  }

  /**
   * Get badgeEnabled
   * @return badgeEnabled
   */
  @javax.annotation.Nullable
  public Boolean getBadgeEnabled() {
    return badgeEnabled;
  }

  public void setBadgeEnabled(Boolean badgeEnabled) {
    this.badgeEnabled = badgeEnabled;
  }


  public UpdateProjectInput logsConfig(UpdateProjectInputLogsConfig logsConfig) {
    this.logsConfig = logsConfig;
    return this;
  }

  /**
   * Get logsConfig
   * @return logsConfig
   */
  @javax.annotation.Nullable
  public UpdateProjectInputLogsConfig getLogsConfig() {
    return logsConfig;
  }

  public void setLogsConfig(UpdateProjectInputLogsConfig logsConfig) {
    this.logsConfig = logsConfig;
  }


  public UpdateProjectInput fileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
    return this;
  }

  /**
   * Get fileSystemLocations
   * @return fileSystemLocations
   */
  @javax.annotation.Nullable
  public List getFileSystemLocations() {
    return fileSystemLocations;
  }

  public void setFileSystemLocations(List fileSystemLocations) {
    this.fileSystemLocations = fileSystemLocations;
  }


  public UpdateProjectInput buildBatchConfig(ProjectBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
    return this;
  }

  /**
   * Get buildBatchConfig
   * @return buildBatchConfig
   */
  @javax.annotation.Nullable
  public ProjectBuildBatchConfig getBuildBatchConfig() {
    return buildBatchConfig;
  }

  public void setBuildBatchConfig(ProjectBuildBatchConfig buildBatchConfig) {
    this.buildBatchConfig = buildBatchConfig;
  }


  public UpdateProjectInput concurrentBuildLimit(Integer concurrentBuildLimit) {
    this.concurrentBuildLimit = concurrentBuildLimit;
    return this;
  }

  /**
   * Get concurrentBuildLimit
   * @return concurrentBuildLimit
   */
  @javax.annotation.Nullable
  public Integer getConcurrentBuildLimit() {
    return concurrentBuildLimit;
  }

  public void setConcurrentBuildLimit(Integer concurrentBuildLimit) {
    this.concurrentBuildLimit = concurrentBuildLimit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateProjectInput updateProjectInput = (UpdateProjectInput) o;
    return Objects.equals(this.name, updateProjectInput.name) &&
        Objects.equals(this.description, updateProjectInput.description) &&
        Objects.equals(this.source, updateProjectInput.source) &&
        Objects.equals(this.secondarySources, updateProjectInput.secondarySources) &&
        Objects.equals(this.sourceVersion, updateProjectInput.sourceVersion) &&
        Objects.equals(this.secondarySourceVersions, updateProjectInput.secondarySourceVersions) &&
        Objects.equals(this.artifacts, updateProjectInput.artifacts) &&
        Objects.equals(this.secondaryArtifacts, updateProjectInput.secondaryArtifacts) &&
        Objects.equals(this.cache, updateProjectInput.cache) &&
        Objects.equals(this.environment, updateProjectInput.environment) &&
        Objects.equals(this.serviceRole, updateProjectInput.serviceRole) &&
        Objects.equals(this.timeoutInMinutes, updateProjectInput.timeoutInMinutes) &&
        Objects.equals(this.queuedTimeoutInMinutes, updateProjectInput.queuedTimeoutInMinutes) &&
        Objects.equals(this.encryptionKey, updateProjectInput.encryptionKey) &&
        Objects.equals(this.tags, updateProjectInput.tags) &&
        Objects.equals(this.vpcConfig, updateProjectInput.vpcConfig) &&
        Objects.equals(this.badgeEnabled, updateProjectInput.badgeEnabled) &&
        Objects.equals(this.logsConfig, updateProjectInput.logsConfig) &&
        Objects.equals(this.fileSystemLocations, updateProjectInput.fileSystemLocations) &&
        Objects.equals(this.buildBatchConfig, updateProjectInput.buildBatchConfig) &&
        Objects.equals(this.concurrentBuildLimit, updateProjectInput.concurrentBuildLimit);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, source, secondarySources, sourceVersion, secondarySourceVersions, artifacts, secondaryArtifacts, cache, environment, serviceRole, timeoutInMinutes, queuedTimeoutInMinutes, encryptionKey, tags, vpcConfig, badgeEnabled, logsConfig, fileSystemLocations, buildBatchConfig, concurrentBuildLimit);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateProjectInput {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    secondarySources: ").append(toIndentedString(secondarySources)).append("\n");
    sb.append("    sourceVersion: ").append(toIndentedString(sourceVersion)).append("\n");
    sb.append("    secondarySourceVersions: ").append(toIndentedString(secondarySourceVersions)).append("\n");
    sb.append("    artifacts: ").append(toIndentedString(artifacts)).append("\n");
    sb.append("    secondaryArtifacts: ").append(toIndentedString(secondaryArtifacts)).append("\n");
    sb.append("    cache: ").append(toIndentedString(cache)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    serviceRole: ").append(toIndentedString(serviceRole)).append("\n");
    sb.append("    timeoutInMinutes: ").append(toIndentedString(timeoutInMinutes)).append("\n");
    sb.append("    queuedTimeoutInMinutes: ").append(toIndentedString(queuedTimeoutInMinutes)).append("\n");
    sb.append("    encryptionKey: ").append(toIndentedString(encryptionKey)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    vpcConfig: ").append(toIndentedString(vpcConfig)).append("\n");
    sb.append("    badgeEnabled: ").append(toIndentedString(badgeEnabled)).append("\n");
    sb.append("    logsConfig: ").append(toIndentedString(logsConfig)).append("\n");
    sb.append("    fileSystemLocations: ").append(toIndentedString(fileSystemLocations)).append("\n");
    sb.append("    buildBatchConfig: ").append(toIndentedString(buildBatchConfig)).append("\n");
    sb.append("    concurrentBuildLimit: ").append(toIndentedString(concurrentBuildLimit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("source");
    openapiFields.add("secondarySources");
    openapiFields.add("sourceVersion");
    openapiFields.add("secondarySourceVersions");
    openapiFields.add("artifacts");
    openapiFields.add("secondaryArtifacts");
    openapiFields.add("cache");
    openapiFields.add("environment");
    openapiFields.add("serviceRole");
    openapiFields.add("timeoutInMinutes");
    openapiFields.add("queuedTimeoutInMinutes");
    openapiFields.add("encryptionKey");
    openapiFields.add("tags");
    openapiFields.add("vpcConfig");
    openapiFields.add("badgeEnabled");
    openapiFields.add("logsConfig");
    openapiFields.add("fileSystemLocations");
    openapiFields.add("buildBatchConfig");
    openapiFields.add("concurrentBuildLimit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateProjectInput
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateProjectInput.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateProjectInput is not found in the empty JSON string", UpdateProjectInput.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateProjectInput.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateProjectInput` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : UpdateProjectInput.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `name`
      String.validateJsonElement(jsonObj.get("name"));
      // validate the optional field `description`
      if (jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("description"));
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        UpdateProjectInputSource.validateJsonElement(jsonObj.get("source"));
      }
      // validate the optional field `secondarySources`
      if (jsonObj.get("secondarySources") != null && !jsonObj.get("secondarySources").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySources"));
      }
      // validate the optional field `sourceVersion`
      if (jsonObj.get("sourceVersion") != null && !jsonObj.get("sourceVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("sourceVersion"));
      }
      // validate the optional field `secondarySourceVersions`
      if (jsonObj.get("secondarySourceVersions") != null && !jsonObj.get("secondarySourceVersions").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondarySourceVersions"));
      }
      // validate the optional field `artifacts`
      if (jsonObj.get("artifacts") != null && !jsonObj.get("artifacts").isJsonNull()) {
        UpdateProjectInputArtifacts.validateJsonElement(jsonObj.get("artifacts"));
      }
      // validate the optional field `secondaryArtifacts`
      if (jsonObj.get("secondaryArtifacts") != null && !jsonObj.get("secondaryArtifacts").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("secondaryArtifacts"));
      }
      // validate the optional field `cache`
      if (jsonObj.get("cache") != null && !jsonObj.get("cache").isJsonNull()) {
        CreateProjectInputCache.validateJsonElement(jsonObj.get("cache"));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        UpdateProjectInputEnvironment.validateJsonElement(jsonObj.get("environment"));
      }
      // validate the optional field `serviceRole`
      if (jsonObj.get("serviceRole") != null && !jsonObj.get("serviceRole").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("serviceRole"));
      }
      // validate the optional field `timeoutInMinutes`
      if (jsonObj.get("timeoutInMinutes") != null && !jsonObj.get("timeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("timeoutInMinutes"));
      }
      // validate the optional field `queuedTimeoutInMinutes`
      if (jsonObj.get("queuedTimeoutInMinutes") != null && !jsonObj.get("queuedTimeoutInMinutes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("queuedTimeoutInMinutes"));
      }
      // validate the optional field `encryptionKey`
      if (jsonObj.get("encryptionKey") != null && !jsonObj.get("encryptionKey").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("encryptionKey"));
      }
      // validate the optional field `tags`
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("tags"));
      }
      // validate the optional field `vpcConfig`
      if (jsonObj.get("vpcConfig") != null && !jsonObj.get("vpcConfig").isJsonNull()) {
        CreateProjectInputVpcConfig.validateJsonElement(jsonObj.get("vpcConfig"));
      }
      // validate the optional field `badgeEnabled`
      if (jsonObj.get("badgeEnabled") != null && !jsonObj.get("badgeEnabled").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("badgeEnabled"));
      }
      // validate the optional field `logsConfig`
      if (jsonObj.get("logsConfig") != null && !jsonObj.get("logsConfig").isJsonNull()) {
        UpdateProjectInputLogsConfig.validateJsonElement(jsonObj.get("logsConfig"));
      }
      // validate the optional field `fileSystemLocations`
      if (jsonObj.get("fileSystemLocations") != null && !jsonObj.get("fileSystemLocations").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("fileSystemLocations"));
      }
      // validate the optional field `buildBatchConfig`
      if (jsonObj.get("buildBatchConfig") != null && !jsonObj.get("buildBatchConfig").isJsonNull()) {
        ProjectBuildBatchConfig.validateJsonElement(jsonObj.get("buildBatchConfig"));
      }
      // validate the optional field `concurrentBuildLimit`
      if (jsonObj.get("concurrentBuildLimit") != null && !jsonObj.get("concurrentBuildLimit").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("concurrentBuildLimit"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateProjectInput.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateProjectInput' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateProjectInput> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateProjectInput.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateProjectInput>() {
           @Override
           public void write(JsonWriter out, UpdateProjectInput value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateProjectInput read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateProjectInput given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateProjectInput
   * @throws IOException if the JSON string is invalid with respect to UpdateProjectInput
   */
  public static UpdateProjectInput fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateProjectInput.class);
  }

  /**
   * Convert an instance of UpdateProjectInput to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

