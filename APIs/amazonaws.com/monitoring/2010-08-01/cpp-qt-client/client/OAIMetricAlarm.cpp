/**
 * Amazon CloudWatch
 * <p>Amazon CloudWatch monitors your Amazon Web Services (Amazon Web Services) resources and the applications you run on Amazon Web Services in real time. You can use CloudWatch to collect and track metrics, which are the variables you want to measure for your resources and applications.</p> <p>CloudWatch alarms send notifications or automatically change the resources you are monitoring based on rules that you define. For example, you can monitor the CPU usage and disk reads and writes of your Amazon EC2 instances. Then, use this data to determine whether you should launch additional instances to handle increased load. You can also use this data to stop under-used instances to save money.</p> <p>In addition to monitoring the built-in metrics that come with Amazon Web Services, you can monitor your own custom metrics. With CloudWatch, you gain system-wide visibility into resource utilization, application performance, and operational health.</p>
 *
 * The version of the OpenAPI document: 2010-08-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMetricAlarm.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMetricAlarm::OAIMetricAlarm(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMetricAlarm::OAIMetricAlarm() {
    this->initializeModel();
}

OAIMetricAlarm::~OAIMetricAlarm() {}

void OAIMetricAlarm::initializeModel() {

    m_alarm_name_isSet = false;
    m_alarm_name_isValid = false;

    m_alarm_arn_isSet = false;
    m_alarm_arn_isValid = false;

    m_alarm_description_isSet = false;
    m_alarm_description_isValid = false;

    m_alarm_configuration_updated_timestamp_isSet = false;
    m_alarm_configuration_updated_timestamp_isValid = false;

    m_actions_enabled_isSet = false;
    m_actions_enabled_isValid = false;

    m_ok_actions_isSet = false;
    m_ok_actions_isValid = false;

    m_alarm_actions_isSet = false;
    m_alarm_actions_isValid = false;

    m_insufficient_data_actions_isSet = false;
    m_insufficient_data_actions_isValid = false;

    m_state_value_isSet = false;
    m_state_value_isValid = false;

    m_state_reason_isSet = false;
    m_state_reason_isValid = false;

    m_state_reason_data_isSet = false;
    m_state_reason_data_isValid = false;

    m_state_updated_timestamp_isSet = false;
    m_state_updated_timestamp_isValid = false;

    m_metric_name_isSet = false;
    m_metric_name_isValid = false;

    m_r_namespace_isSet = false;
    m_r_namespace_isValid = false;

    m_statistic_isSet = false;
    m_statistic_isValid = false;

    m_extended_statistic_isSet = false;
    m_extended_statistic_isValid = false;

    m_dimensions_isSet = false;
    m_dimensions_isValid = false;

    m_period_isSet = false;
    m_period_isValid = false;

    m_unit_isSet = false;
    m_unit_isValid = false;

    m_evaluation_periods_isSet = false;
    m_evaluation_periods_isValid = false;

    m_datapoints_to_alarm_isSet = false;
    m_datapoints_to_alarm_isValid = false;

    m_threshold_isSet = false;
    m_threshold_isValid = false;

    m_comparison_operator_isSet = false;
    m_comparison_operator_isValid = false;

    m_treat_missing_data_isSet = false;
    m_treat_missing_data_isValid = false;

    m_evaluate_low_sample_count_percentile_isSet = false;
    m_evaluate_low_sample_count_percentile_isValid = false;

    m_metrics_isSet = false;
    m_metrics_isValid = false;

    m_threshold_metric_id_isSet = false;
    m_threshold_metric_id_isValid = false;

    m_evaluation_state_isSet = false;
    m_evaluation_state_isValid = false;

    m_state_transitioned_timestamp_isSet = false;
    m_state_transitioned_timestamp_isValid = false;
}

void OAIMetricAlarm::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMetricAlarm::fromJsonObject(QJsonObject json) {

    m_alarm_name_isValid = ::OpenAPI::fromJsonValue(m_alarm_name, json[QString("AlarmName")]);
    m_alarm_name_isSet = !json[QString("AlarmName")].isNull() && m_alarm_name_isValid;

    m_alarm_arn_isValid = ::OpenAPI::fromJsonValue(m_alarm_arn, json[QString("AlarmArn")]);
    m_alarm_arn_isSet = !json[QString("AlarmArn")].isNull() && m_alarm_arn_isValid;

    m_alarm_description_isValid = ::OpenAPI::fromJsonValue(m_alarm_description, json[QString("AlarmDescription")]);
    m_alarm_description_isSet = !json[QString("AlarmDescription")].isNull() && m_alarm_description_isValid;

    m_alarm_configuration_updated_timestamp_isValid = ::OpenAPI::fromJsonValue(m_alarm_configuration_updated_timestamp, json[QString("AlarmConfigurationUpdatedTimestamp")]);
    m_alarm_configuration_updated_timestamp_isSet = !json[QString("AlarmConfigurationUpdatedTimestamp")].isNull() && m_alarm_configuration_updated_timestamp_isValid;

    m_actions_enabled_isValid = ::OpenAPI::fromJsonValue(m_actions_enabled, json[QString("ActionsEnabled")]);
    m_actions_enabled_isSet = !json[QString("ActionsEnabled")].isNull() && m_actions_enabled_isValid;

    m_ok_actions_isValid = ::OpenAPI::fromJsonValue(m_ok_actions, json[QString("OKActions")]);
    m_ok_actions_isSet = !json[QString("OKActions")].isNull() && m_ok_actions_isValid;

    m_alarm_actions_isValid = ::OpenAPI::fromJsonValue(m_alarm_actions, json[QString("AlarmActions")]);
    m_alarm_actions_isSet = !json[QString("AlarmActions")].isNull() && m_alarm_actions_isValid;

    m_insufficient_data_actions_isValid = ::OpenAPI::fromJsonValue(m_insufficient_data_actions, json[QString("InsufficientDataActions")]);
    m_insufficient_data_actions_isSet = !json[QString("InsufficientDataActions")].isNull() && m_insufficient_data_actions_isValid;

    m_state_value_isValid = ::OpenAPI::fromJsonValue(m_state_value, json[QString("StateValue")]);
    m_state_value_isSet = !json[QString("StateValue")].isNull() && m_state_value_isValid;

    m_state_reason_isValid = ::OpenAPI::fromJsonValue(m_state_reason, json[QString("StateReason")]);
    m_state_reason_isSet = !json[QString("StateReason")].isNull() && m_state_reason_isValid;

    m_state_reason_data_isValid = ::OpenAPI::fromJsonValue(m_state_reason_data, json[QString("StateReasonData")]);
    m_state_reason_data_isSet = !json[QString("StateReasonData")].isNull() && m_state_reason_data_isValid;

    m_state_updated_timestamp_isValid = ::OpenAPI::fromJsonValue(m_state_updated_timestamp, json[QString("StateUpdatedTimestamp")]);
    m_state_updated_timestamp_isSet = !json[QString("StateUpdatedTimestamp")].isNull() && m_state_updated_timestamp_isValid;

    m_metric_name_isValid = ::OpenAPI::fromJsonValue(m_metric_name, json[QString("MetricName")]);
    m_metric_name_isSet = !json[QString("MetricName")].isNull() && m_metric_name_isValid;

    m_r_namespace_isValid = ::OpenAPI::fromJsonValue(m_r_namespace, json[QString("Namespace")]);
    m_r_namespace_isSet = !json[QString("Namespace")].isNull() && m_r_namespace_isValid;

    m_statistic_isValid = ::OpenAPI::fromJsonValue(m_statistic, json[QString("Statistic")]);
    m_statistic_isSet = !json[QString("Statistic")].isNull() && m_statistic_isValid;

    m_extended_statistic_isValid = ::OpenAPI::fromJsonValue(m_extended_statistic, json[QString("ExtendedStatistic")]);
    m_extended_statistic_isSet = !json[QString("ExtendedStatistic")].isNull() && m_extended_statistic_isValid;

    m_dimensions_isValid = ::OpenAPI::fromJsonValue(m_dimensions, json[QString("Dimensions")]);
    m_dimensions_isSet = !json[QString("Dimensions")].isNull() && m_dimensions_isValid;

    m_period_isValid = ::OpenAPI::fromJsonValue(m_period, json[QString("Period")]);
    m_period_isSet = !json[QString("Period")].isNull() && m_period_isValid;

    m_unit_isValid = ::OpenAPI::fromJsonValue(m_unit, json[QString("Unit")]);
    m_unit_isSet = !json[QString("Unit")].isNull() && m_unit_isValid;

    m_evaluation_periods_isValid = ::OpenAPI::fromJsonValue(m_evaluation_periods, json[QString("EvaluationPeriods")]);
    m_evaluation_periods_isSet = !json[QString("EvaluationPeriods")].isNull() && m_evaluation_periods_isValid;

    m_datapoints_to_alarm_isValid = ::OpenAPI::fromJsonValue(m_datapoints_to_alarm, json[QString("DatapointsToAlarm")]);
    m_datapoints_to_alarm_isSet = !json[QString("DatapointsToAlarm")].isNull() && m_datapoints_to_alarm_isValid;

    m_threshold_isValid = ::OpenAPI::fromJsonValue(m_threshold, json[QString("Threshold")]);
    m_threshold_isSet = !json[QString("Threshold")].isNull() && m_threshold_isValid;

    m_comparison_operator_isValid = ::OpenAPI::fromJsonValue(m_comparison_operator, json[QString("ComparisonOperator")]);
    m_comparison_operator_isSet = !json[QString("ComparisonOperator")].isNull() && m_comparison_operator_isValid;

    m_treat_missing_data_isValid = ::OpenAPI::fromJsonValue(m_treat_missing_data, json[QString("TreatMissingData")]);
    m_treat_missing_data_isSet = !json[QString("TreatMissingData")].isNull() && m_treat_missing_data_isValid;

    m_evaluate_low_sample_count_percentile_isValid = ::OpenAPI::fromJsonValue(m_evaluate_low_sample_count_percentile, json[QString("EvaluateLowSampleCountPercentile")]);
    m_evaluate_low_sample_count_percentile_isSet = !json[QString("EvaluateLowSampleCountPercentile")].isNull() && m_evaluate_low_sample_count_percentile_isValid;

    m_metrics_isValid = ::OpenAPI::fromJsonValue(m_metrics, json[QString("Metrics")]);
    m_metrics_isSet = !json[QString("Metrics")].isNull() && m_metrics_isValid;

    m_threshold_metric_id_isValid = ::OpenAPI::fromJsonValue(m_threshold_metric_id, json[QString("ThresholdMetricId")]);
    m_threshold_metric_id_isSet = !json[QString("ThresholdMetricId")].isNull() && m_threshold_metric_id_isValid;

    m_evaluation_state_isValid = ::OpenAPI::fromJsonValue(m_evaluation_state, json[QString("EvaluationState")]);
    m_evaluation_state_isSet = !json[QString("EvaluationState")].isNull() && m_evaluation_state_isValid;

    m_state_transitioned_timestamp_isValid = ::OpenAPI::fromJsonValue(m_state_transitioned_timestamp, json[QString("StateTransitionedTimestamp")]);
    m_state_transitioned_timestamp_isSet = !json[QString("StateTransitionedTimestamp")].isNull() && m_state_transitioned_timestamp_isValid;
}

QString OAIMetricAlarm::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMetricAlarm::asJsonObject() const {
    QJsonObject obj;
    if (m_alarm_name_isSet) {
        obj.insert(QString("AlarmName"), ::OpenAPI::toJsonValue(m_alarm_name));
    }
    if (m_alarm_arn_isSet) {
        obj.insert(QString("AlarmArn"), ::OpenAPI::toJsonValue(m_alarm_arn));
    }
    if (m_alarm_description_isSet) {
        obj.insert(QString("AlarmDescription"), ::OpenAPI::toJsonValue(m_alarm_description));
    }
    if (m_alarm_configuration_updated_timestamp_isSet) {
        obj.insert(QString("AlarmConfigurationUpdatedTimestamp"), ::OpenAPI::toJsonValue(m_alarm_configuration_updated_timestamp));
    }
    if (m_actions_enabled_isSet) {
        obj.insert(QString("ActionsEnabled"), ::OpenAPI::toJsonValue(m_actions_enabled));
    }
    if (m_ok_actions.isSet()) {
        obj.insert(QString("OKActions"), ::OpenAPI::toJsonValue(m_ok_actions));
    }
    if (m_alarm_actions.isSet()) {
        obj.insert(QString("AlarmActions"), ::OpenAPI::toJsonValue(m_alarm_actions));
    }
    if (m_insufficient_data_actions.isSet()) {
        obj.insert(QString("InsufficientDataActions"), ::OpenAPI::toJsonValue(m_insufficient_data_actions));
    }
    if (m_state_value.isSet()) {
        obj.insert(QString("StateValue"), ::OpenAPI::toJsonValue(m_state_value));
    }
    if (m_state_reason_isSet) {
        obj.insert(QString("StateReason"), ::OpenAPI::toJsonValue(m_state_reason));
    }
    if (m_state_reason_data_isSet) {
        obj.insert(QString("StateReasonData"), ::OpenAPI::toJsonValue(m_state_reason_data));
    }
    if (m_state_updated_timestamp_isSet) {
        obj.insert(QString("StateUpdatedTimestamp"), ::OpenAPI::toJsonValue(m_state_updated_timestamp));
    }
    if (m_metric_name_isSet) {
        obj.insert(QString("MetricName"), ::OpenAPI::toJsonValue(m_metric_name));
    }
    if (m_r_namespace_isSet) {
        obj.insert(QString("Namespace"), ::OpenAPI::toJsonValue(m_r_namespace));
    }
    if (m_statistic.isSet()) {
        obj.insert(QString("Statistic"), ::OpenAPI::toJsonValue(m_statistic));
    }
    if (m_extended_statistic_isSet) {
        obj.insert(QString("ExtendedStatistic"), ::OpenAPI::toJsonValue(m_extended_statistic));
    }
    if (m_dimensions.isSet()) {
        obj.insert(QString("Dimensions"), ::OpenAPI::toJsonValue(m_dimensions));
    }
    if (m_period_isSet) {
        obj.insert(QString("Period"), ::OpenAPI::toJsonValue(m_period));
    }
    if (m_unit.isSet()) {
        obj.insert(QString("Unit"), ::OpenAPI::toJsonValue(m_unit));
    }
    if (m_evaluation_periods_isSet) {
        obj.insert(QString("EvaluationPeriods"), ::OpenAPI::toJsonValue(m_evaluation_periods));
    }
    if (m_datapoints_to_alarm_isSet) {
        obj.insert(QString("DatapointsToAlarm"), ::OpenAPI::toJsonValue(m_datapoints_to_alarm));
    }
    if (m_threshold_isSet) {
        obj.insert(QString("Threshold"), ::OpenAPI::toJsonValue(m_threshold));
    }
    if (m_comparison_operator.isSet()) {
        obj.insert(QString("ComparisonOperator"), ::OpenAPI::toJsonValue(m_comparison_operator));
    }
    if (m_treat_missing_data_isSet) {
        obj.insert(QString("TreatMissingData"), ::OpenAPI::toJsonValue(m_treat_missing_data));
    }
    if (m_evaluate_low_sample_count_percentile_isSet) {
        obj.insert(QString("EvaluateLowSampleCountPercentile"), ::OpenAPI::toJsonValue(m_evaluate_low_sample_count_percentile));
    }
    if (m_metrics.isSet()) {
        obj.insert(QString("Metrics"), ::OpenAPI::toJsonValue(m_metrics));
    }
    if (m_threshold_metric_id_isSet) {
        obj.insert(QString("ThresholdMetricId"), ::OpenAPI::toJsonValue(m_threshold_metric_id));
    }
    if (m_evaluation_state.isSet()) {
        obj.insert(QString("EvaluationState"), ::OpenAPI::toJsonValue(m_evaluation_state));
    }
    if (m_state_transitioned_timestamp_isSet) {
        obj.insert(QString("StateTransitionedTimestamp"), ::OpenAPI::toJsonValue(m_state_transitioned_timestamp));
    }
    return obj;
}

QString OAIMetricAlarm::getAlarmName() const {
    return m_alarm_name;
}
void OAIMetricAlarm::setAlarmName(const QString &alarm_name) {
    m_alarm_name = alarm_name;
    m_alarm_name_isSet = true;
}

bool OAIMetricAlarm::is_alarm_name_Set() const{
    return m_alarm_name_isSet;
}

bool OAIMetricAlarm::is_alarm_name_Valid() const{
    return m_alarm_name_isValid;
}

QString OAIMetricAlarm::getAlarmArn() const {
    return m_alarm_arn;
}
void OAIMetricAlarm::setAlarmArn(const QString &alarm_arn) {
    m_alarm_arn = alarm_arn;
    m_alarm_arn_isSet = true;
}

bool OAIMetricAlarm::is_alarm_arn_Set() const{
    return m_alarm_arn_isSet;
}

bool OAIMetricAlarm::is_alarm_arn_Valid() const{
    return m_alarm_arn_isValid;
}

QString OAIMetricAlarm::getAlarmDescription() const {
    return m_alarm_description;
}
void OAIMetricAlarm::setAlarmDescription(const QString &alarm_description) {
    m_alarm_description = alarm_description;
    m_alarm_description_isSet = true;
}

bool OAIMetricAlarm::is_alarm_description_Set() const{
    return m_alarm_description_isSet;
}

bool OAIMetricAlarm::is_alarm_description_Valid() const{
    return m_alarm_description_isValid;
}

QDateTime OAIMetricAlarm::getAlarmConfigurationUpdatedTimestamp() const {
    return m_alarm_configuration_updated_timestamp;
}
void OAIMetricAlarm::setAlarmConfigurationUpdatedTimestamp(const QDateTime &alarm_configuration_updated_timestamp) {
    m_alarm_configuration_updated_timestamp = alarm_configuration_updated_timestamp;
    m_alarm_configuration_updated_timestamp_isSet = true;
}

bool OAIMetricAlarm::is_alarm_configuration_updated_timestamp_Set() const{
    return m_alarm_configuration_updated_timestamp_isSet;
}

bool OAIMetricAlarm::is_alarm_configuration_updated_timestamp_Valid() const{
    return m_alarm_configuration_updated_timestamp_isValid;
}

bool OAIMetricAlarm::getActionsEnabled() const {
    return m_actions_enabled;
}
void OAIMetricAlarm::setActionsEnabled(const bool &actions_enabled) {
    m_actions_enabled = actions_enabled;
    m_actions_enabled_isSet = true;
}

bool OAIMetricAlarm::is_actions_enabled_Set() const{
    return m_actions_enabled_isSet;
}

bool OAIMetricAlarm::is_actions_enabled_Valid() const{
    return m_actions_enabled_isValid;
}

QList OAIMetricAlarm::getOkActions() const {
    return m_ok_actions;
}
void OAIMetricAlarm::setOkActions(const QList &ok_actions) {
    m_ok_actions = ok_actions;
    m_ok_actions_isSet = true;
}

bool OAIMetricAlarm::is_ok_actions_Set() const{
    return m_ok_actions_isSet;
}

bool OAIMetricAlarm::is_ok_actions_Valid() const{
    return m_ok_actions_isValid;
}

QList OAIMetricAlarm::getAlarmActions() const {
    return m_alarm_actions;
}
void OAIMetricAlarm::setAlarmActions(const QList &alarm_actions) {
    m_alarm_actions = alarm_actions;
    m_alarm_actions_isSet = true;
}

bool OAIMetricAlarm::is_alarm_actions_Set() const{
    return m_alarm_actions_isSet;
}

bool OAIMetricAlarm::is_alarm_actions_Valid() const{
    return m_alarm_actions_isValid;
}

QList OAIMetricAlarm::getInsufficientDataActions() const {
    return m_insufficient_data_actions;
}
void OAIMetricAlarm::setInsufficientDataActions(const QList &insufficient_data_actions) {
    m_insufficient_data_actions = insufficient_data_actions;
    m_insufficient_data_actions_isSet = true;
}

bool OAIMetricAlarm::is_insufficient_data_actions_Set() const{
    return m_insufficient_data_actions_isSet;
}

bool OAIMetricAlarm::is_insufficient_data_actions_Valid() const{
    return m_insufficient_data_actions_isValid;
}

OAIStateValue OAIMetricAlarm::getStateValue() const {
    return m_state_value;
}
void OAIMetricAlarm::setStateValue(const OAIStateValue &state_value) {
    m_state_value = state_value;
    m_state_value_isSet = true;
}

bool OAIMetricAlarm::is_state_value_Set() const{
    return m_state_value_isSet;
}

bool OAIMetricAlarm::is_state_value_Valid() const{
    return m_state_value_isValid;
}

QString OAIMetricAlarm::getStateReason() const {
    return m_state_reason;
}
void OAIMetricAlarm::setStateReason(const QString &state_reason) {
    m_state_reason = state_reason;
    m_state_reason_isSet = true;
}

bool OAIMetricAlarm::is_state_reason_Set() const{
    return m_state_reason_isSet;
}

bool OAIMetricAlarm::is_state_reason_Valid() const{
    return m_state_reason_isValid;
}

QString OAIMetricAlarm::getStateReasonData() const {
    return m_state_reason_data;
}
void OAIMetricAlarm::setStateReasonData(const QString &state_reason_data) {
    m_state_reason_data = state_reason_data;
    m_state_reason_data_isSet = true;
}

bool OAIMetricAlarm::is_state_reason_data_Set() const{
    return m_state_reason_data_isSet;
}

bool OAIMetricAlarm::is_state_reason_data_Valid() const{
    return m_state_reason_data_isValid;
}

QDateTime OAIMetricAlarm::getStateUpdatedTimestamp() const {
    return m_state_updated_timestamp;
}
void OAIMetricAlarm::setStateUpdatedTimestamp(const QDateTime &state_updated_timestamp) {
    m_state_updated_timestamp = state_updated_timestamp;
    m_state_updated_timestamp_isSet = true;
}

bool OAIMetricAlarm::is_state_updated_timestamp_Set() const{
    return m_state_updated_timestamp_isSet;
}

bool OAIMetricAlarm::is_state_updated_timestamp_Valid() const{
    return m_state_updated_timestamp_isValid;
}

QString OAIMetricAlarm::getMetricName() const {
    return m_metric_name;
}
void OAIMetricAlarm::setMetricName(const QString &metric_name) {
    m_metric_name = metric_name;
    m_metric_name_isSet = true;
}

bool OAIMetricAlarm::is_metric_name_Set() const{
    return m_metric_name_isSet;
}

bool OAIMetricAlarm::is_metric_name_Valid() const{
    return m_metric_name_isValid;
}

QString OAIMetricAlarm::getRNamespace() const {
    return m_r_namespace;
}
void OAIMetricAlarm::setRNamespace(const QString &r_namespace) {
    m_r_namespace = r_namespace;
    m_r_namespace_isSet = true;
}

bool OAIMetricAlarm::is_r_namespace_Set() const{
    return m_r_namespace_isSet;
}

bool OAIMetricAlarm::is_r_namespace_Valid() const{
    return m_r_namespace_isValid;
}

OAIStatistic OAIMetricAlarm::getStatistic() const {
    return m_statistic;
}
void OAIMetricAlarm::setStatistic(const OAIStatistic &statistic) {
    m_statistic = statistic;
    m_statistic_isSet = true;
}

bool OAIMetricAlarm::is_statistic_Set() const{
    return m_statistic_isSet;
}

bool OAIMetricAlarm::is_statistic_Valid() const{
    return m_statistic_isValid;
}

QString OAIMetricAlarm::getExtendedStatistic() const {
    return m_extended_statistic;
}
void OAIMetricAlarm::setExtendedStatistic(const QString &extended_statistic) {
    m_extended_statistic = extended_statistic;
    m_extended_statistic_isSet = true;
}

bool OAIMetricAlarm::is_extended_statistic_Set() const{
    return m_extended_statistic_isSet;
}

bool OAIMetricAlarm::is_extended_statistic_Valid() const{
    return m_extended_statistic_isValid;
}

QList OAIMetricAlarm::getDimensions() const {
    return m_dimensions;
}
void OAIMetricAlarm::setDimensions(const QList &dimensions) {
    m_dimensions = dimensions;
    m_dimensions_isSet = true;
}

bool OAIMetricAlarm::is_dimensions_Set() const{
    return m_dimensions_isSet;
}

bool OAIMetricAlarm::is_dimensions_Valid() const{
    return m_dimensions_isValid;
}

qint32 OAIMetricAlarm::getPeriod() const {
    return m_period;
}
void OAIMetricAlarm::setPeriod(const qint32 &period) {
    m_period = period;
    m_period_isSet = true;
}

bool OAIMetricAlarm::is_period_Set() const{
    return m_period_isSet;
}

bool OAIMetricAlarm::is_period_Valid() const{
    return m_period_isValid;
}

OAIStandardUnit OAIMetricAlarm::getUnit() const {
    return m_unit;
}
void OAIMetricAlarm::setUnit(const OAIStandardUnit &unit) {
    m_unit = unit;
    m_unit_isSet = true;
}

bool OAIMetricAlarm::is_unit_Set() const{
    return m_unit_isSet;
}

bool OAIMetricAlarm::is_unit_Valid() const{
    return m_unit_isValid;
}

qint32 OAIMetricAlarm::getEvaluationPeriods() const {
    return m_evaluation_periods;
}
void OAIMetricAlarm::setEvaluationPeriods(const qint32 &evaluation_periods) {
    m_evaluation_periods = evaluation_periods;
    m_evaluation_periods_isSet = true;
}

bool OAIMetricAlarm::is_evaluation_periods_Set() const{
    return m_evaluation_periods_isSet;
}

bool OAIMetricAlarm::is_evaluation_periods_Valid() const{
    return m_evaluation_periods_isValid;
}

qint32 OAIMetricAlarm::getDatapointsToAlarm() const {
    return m_datapoints_to_alarm;
}
void OAIMetricAlarm::setDatapointsToAlarm(const qint32 &datapoints_to_alarm) {
    m_datapoints_to_alarm = datapoints_to_alarm;
    m_datapoints_to_alarm_isSet = true;
}

bool OAIMetricAlarm::is_datapoints_to_alarm_Set() const{
    return m_datapoints_to_alarm_isSet;
}

bool OAIMetricAlarm::is_datapoints_to_alarm_Valid() const{
    return m_datapoints_to_alarm_isValid;
}

double OAIMetricAlarm::getThreshold() const {
    return m_threshold;
}
void OAIMetricAlarm::setThreshold(const double &threshold) {
    m_threshold = threshold;
    m_threshold_isSet = true;
}

bool OAIMetricAlarm::is_threshold_Set() const{
    return m_threshold_isSet;
}

bool OAIMetricAlarm::is_threshold_Valid() const{
    return m_threshold_isValid;
}

OAIComparisonOperator OAIMetricAlarm::getComparisonOperator() const {
    return m_comparison_operator;
}
void OAIMetricAlarm::setComparisonOperator(const OAIComparisonOperator &comparison_operator) {
    m_comparison_operator = comparison_operator;
    m_comparison_operator_isSet = true;
}

bool OAIMetricAlarm::is_comparison_operator_Set() const{
    return m_comparison_operator_isSet;
}

bool OAIMetricAlarm::is_comparison_operator_Valid() const{
    return m_comparison_operator_isValid;
}

QString OAIMetricAlarm::getTreatMissingData() const {
    return m_treat_missing_data;
}
void OAIMetricAlarm::setTreatMissingData(const QString &treat_missing_data) {
    m_treat_missing_data = treat_missing_data;
    m_treat_missing_data_isSet = true;
}

bool OAIMetricAlarm::is_treat_missing_data_Set() const{
    return m_treat_missing_data_isSet;
}

bool OAIMetricAlarm::is_treat_missing_data_Valid() const{
    return m_treat_missing_data_isValid;
}

QString OAIMetricAlarm::getEvaluateLowSampleCountPercentile() const {
    return m_evaluate_low_sample_count_percentile;
}
void OAIMetricAlarm::setEvaluateLowSampleCountPercentile(const QString &evaluate_low_sample_count_percentile) {
    m_evaluate_low_sample_count_percentile = evaluate_low_sample_count_percentile;
    m_evaluate_low_sample_count_percentile_isSet = true;
}

bool OAIMetricAlarm::is_evaluate_low_sample_count_percentile_Set() const{
    return m_evaluate_low_sample_count_percentile_isSet;
}

bool OAIMetricAlarm::is_evaluate_low_sample_count_percentile_Valid() const{
    return m_evaluate_low_sample_count_percentile_isValid;
}

QList OAIMetricAlarm::getMetrics() const {
    return m_metrics;
}
void OAIMetricAlarm::setMetrics(const QList &metrics) {
    m_metrics = metrics;
    m_metrics_isSet = true;
}

bool OAIMetricAlarm::is_metrics_Set() const{
    return m_metrics_isSet;
}

bool OAIMetricAlarm::is_metrics_Valid() const{
    return m_metrics_isValid;
}

QString OAIMetricAlarm::getThresholdMetricId() const {
    return m_threshold_metric_id;
}
void OAIMetricAlarm::setThresholdMetricId(const QString &threshold_metric_id) {
    m_threshold_metric_id = threshold_metric_id;
    m_threshold_metric_id_isSet = true;
}

bool OAIMetricAlarm::is_threshold_metric_id_Set() const{
    return m_threshold_metric_id_isSet;
}

bool OAIMetricAlarm::is_threshold_metric_id_Valid() const{
    return m_threshold_metric_id_isValid;
}

OAIEvaluationState OAIMetricAlarm::getEvaluationState() const {
    return m_evaluation_state;
}
void OAIMetricAlarm::setEvaluationState(const OAIEvaluationState &evaluation_state) {
    m_evaluation_state = evaluation_state;
    m_evaluation_state_isSet = true;
}

bool OAIMetricAlarm::is_evaluation_state_Set() const{
    return m_evaluation_state_isSet;
}

bool OAIMetricAlarm::is_evaluation_state_Valid() const{
    return m_evaluation_state_isValid;
}

QDateTime OAIMetricAlarm::getStateTransitionedTimestamp() const {
    return m_state_transitioned_timestamp;
}
void OAIMetricAlarm::setStateTransitionedTimestamp(const QDateTime &state_transitioned_timestamp) {
    m_state_transitioned_timestamp = state_transitioned_timestamp;
    m_state_transitioned_timestamp_isSet = true;
}

bool OAIMetricAlarm::is_state_transitioned_timestamp_Set() const{
    return m_state_transitioned_timestamp_isSet;
}

bool OAIMetricAlarm::is_state_transitioned_timestamp_Valid() const{
    return m_state_transitioned_timestamp_isValid;
}

bool OAIMetricAlarm::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alarm_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_alarm_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_alarm_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_alarm_configuration_updated_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_actions_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ok_actions.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_alarm_actions.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_insufficient_data_actions.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_value.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_reason_data_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_updated_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_namespace_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_statistic.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_extended_statistic_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dimensions.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_evaluation_periods_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_datapoints_to_alarm_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_comparison_operator.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_treat_missing_data_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_evaluate_low_sample_count_percentile_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metrics.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_threshold_metric_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_evaluation_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_transitioned_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMetricAlarm::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
